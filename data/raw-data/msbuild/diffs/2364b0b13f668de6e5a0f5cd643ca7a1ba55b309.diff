diff --git a/.github/ISSUE_TEMPLATE/06_feature_request.yml b/.github/ISSUE_TEMPLATE/06_feature_request.yml
new file mode 100644
index 00000000000..c2108af202e
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/06_feature_request.yml
@@ -0,0 +1,27 @@
+name: ðŸ’¡ Feature  Request
+description: Suggest an idea for this project.
+title: "[Feature Request]: "
+labels: ["Feature Request", "needs-triage"]
+body:
+  - type: textarea
+    attributes:
+      label: Summary
+      description: Brief summary of what this proposal is about.
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Background and Motivation
+      description: What is the problem we are solving and in what context did you encounter it?
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Proposed Feature
+      description: Please provide a sketch of the feature you are proposing.
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Alternative Designs
+      description: If you have an idea how to achieve this new feature, let us know that here. Please include any pointers to code, relevant changes, or related issues you know of.
diff --git a/.github/fabricbot.json b/.github/fabricbot.json
index 61fca534d95..af4f1a94a7a 100644
--- a/.github/fabricbot.json
+++ b/.github/fabricbot.json
@@ -444,7 +444,129 @@
           }
         ]
       }
+    },
+    {
+      "taskType": "trigger",
+      "capabilityId": "IssueResponder",
+      "subCapability": "PullRequestResponder",
+      "version": "1.0",
+      "config": {
+        "conditions": {
+          "operator": "and",
+          "operands": [
+            {
+              "operator": "or",
+              "operands": [
+                {
+                  "name": "isAction",
+                  "parameters": {
+                    "action": "opened"
+                  }
+                },
+                {
+                  "name": "isAction",
+                  "parameters": {
+                    "action": "reopened"
+                  }
+                },
+                {
+                  "name": "labelAdded",
+                  "parameters": {
+                    "label": "Servicing-consider"
+                  }
+                }
+              ]
+            },
+            {
+              "operator": "or",
+              "operands": [
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.0"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.2"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.4"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.5"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.6"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.7"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.8"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.9"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.10"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs16.11"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs15.9"
+                  }
+                }
+              ]
+            }
+          ]
+        },
+        "eventType": "pull_request",
+        "eventNames": [
+          "pull_request",
+          "issues",
+          "project_card"
+        ],
+        "taskName": "Comment on vs* branches",
+        "actions": [
+          {
+            "name": "addReply",
+            "parameters": {
+              "comment": "Hello! I noticed that you're targeting one of our servicing branches. Please consider updating the version."
+            }
+          }
+        ]
+      }
     }
   ],
   "userGroups": []
-}
+}
\ No newline at end of file
diff --git a/.opt-prof.yml b/.opt-prof.yml
index 35a5a5382d8..47c168210ca 100644
--- a/.opt-prof.yml
+++ b/.opt-prof.yml
@@ -34,6 +34,15 @@ resources:
     name: DartLab.OptProf
     ref: refs/heads/main
 
+parameters:
+  # Whether or not to delete the test machines after the run completes
+  - name: testMachineCleanUpStrategy
+    type: string
+    default: delete
+    values:
+    - delete
+    - stop
+
 stages:
 - template: \templates\stages\visual-studio\single-runsettings.yml@DartLabOptProfTemplates
   parameters:
@@ -45,6 +54,7 @@ stages:
     displayName: OptProf Profiling Workflow
     optOptimizationInputsDropName: $(OptimizationInputsDropName)
     testLabPoolName: VS-Platform # The test lab pool to run your tests in
+    testMachineCleanUpStrategy: ${{parameters.testMachineCleanUpStrategy}}
     testMachineImageName: Windows-10-Enterprise-20H2
     visualStudioSigning: Test
     variables:
@@ -68,7 +78,7 @@ stages:
           $vsBranch = $bootstrapperInfoJson[0].VSBranch
           Write-Host "VSBootstrapperBranch: $vsBranch"
           Set-AzurePipelinesVariable 'VSBootstrapperBranch' $vsBranch
-        }        
+        }
         catch {
           Write-Host $_
           Write-Error "Failed to set VSBootstrapperBranch pipeline variable"
@@ -81,4 +91,4 @@ stages:
         filePath: $(DartLab.Path)\Scripts\VisualStudio\Bootstrapper\Get-BootstrapperURL.ps1
         arguments: -BootstrapperInfoJsonURI '$(Pipeline.Workspace)\ComponentBuildUnderTest\MicroBuildOutputs\BootstrapperInfo.json' -VSBranch '$(VSBootstrapperBranch)' -OutVariableName 'VisualStudio.InstallationUnderTest.BootstrapperURL'
     preDeployAndRunTestsStepList:
-    - download: ComponentBuildUnderTest
\ No newline at end of file
+    - download: ComponentBuildUnderTest
diff --git a/documentation/design/rar-core-scenarios.md b/documentation/design/rar-core-scenarios.md
new file mode 100644
index 00000000000..3fb19ad7846
--- /dev/null
+++ b/documentation/design/rar-core-scenarios.md
@@ -0,0 +1,200 @@
+# Resolve Assembly Reference core scenarios
+
+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.
+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously
+slow build tasks.
+
+## Overview
+
+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different
+locations where it searches for assemblies. Please see the [official documentation](https://learn.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task) and
+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description
+of its features.
+
+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,
+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of
+the "resolvers", internal classes implementing various resolution strategies, are not used in modern scenarios.
+
+## Requirements
+
+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the
+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because
+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,
+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.
+
+### Inputs
+
+In a typical build targeting modern .NET (*not* .NET Framework), RAR inputs come from three sources.
+
+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the
+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are
+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are
+guaranteed to be passed in.
+
+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,
+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.
+
+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly
+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly
+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are
+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is
+established.
+
+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the
+combined SDK, NuGet, and project references in one input array.
+
+## Design
+
+To meet the requirements, RAR must internally be able to do the following.
+
+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores
+the reference.
+
+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as
+`C:\_nugetpackages\microsoft.netcore.app.ref\7.0.2\ref\net7.0\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be
+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees
+such an AssemblyRef in another assembly.
+
+- For project references (reference given as a path to an assembly file that is not guaranteed to have its dependencies resolved), RAR must be able to look
+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.
+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,
+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is
+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,
+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.
+
+## Scale
+
+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything
+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.
+In the OrchardCore solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.
+
+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR
+has to touch the disk.
+
+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually
+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.
+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the
+file with a .NET metadata reader.
+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening
+the file with a .NET metadata reader.
+
+## Optimizations
+
+RAR optimizations tend to revolve around caching of information that is expensive to calculate.
+
+### Existing caching
+
+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.
+
+#### **Per invocation in-memory cache**
+
+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot
+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.
+One issue with this cache is that the key is not normalized so a file specified as `C:\dir\file` will use a different cache entry than the same file specified as
+`C:/dir/file`.
+
+#### **Per process in-memory cache**
+
+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last
+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer
+considered valid.
+
+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`
+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that
+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is
+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like
+`C:\_nugetpackages\microsoft.aspnetcore.app.ref\7.0.2\ref\net7.0`, for example.
+
+#### **Per project disk cache**
+
+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the
+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified
+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written
+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.
+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.
+
+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents
+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom
+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.
+
+#### **SDK disk pre-cache**
+
+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global
+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the
+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.
+
+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`
+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.
+
+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.
+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the
+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also
+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.
+
+## Proposed design
+
+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly
+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional
+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help
+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.
+
+For regular project references the system works as about as efficient as possible.
+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.
+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the
+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.
+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.
+
+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.
+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race
+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.
+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.
+
+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project
+references, so optimizing them has the best bang for the buck.
+
+### Obtain assembly names from the SDK
+
+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its
+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies
+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)
+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense
+to save it to disk.
+
+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,
+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.
+
+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not
+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only
+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.
+
+### Treat NuGet references as immutable [shelved]
+
+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as
+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller
+because the number of NuGet references is typically lower. The proposal is to shelve this opportunity for now due to the unfavorable risk-benefit ratio.
+
+### Don't load the per project disk cache when not needed
+
+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to
+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is
+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.
+
+### Save only relevant data to the per project disk cache
+
+As for saving the per-project cache, we would guarantee that after RAR is done, the cache contains exactly the data needed for this specific project. This would
+be done by keeping track of the items used during RAR execution, and writing those and only those to the cache. Having a cache that's guaranteed to have certain
+well-defined content after each build is a very good property to have. For instance, in dev box scenarios it would otherwise be hard to reliably "prime" a repo
+enlistment - the system may prime by building the full solution and then the developer uses the box to build a specific project that happens to have an incomplete
+cache and get sub-optimal first-time build performance.
+
+Saving of the per-project disk cache may be further optimized by
+- Keeping the timestamp of the cache file in memory and skipping the save if the relevant cache items haven't become dirty (i.e. the dependencies have not changed)
+*and* the timestamp of the cache file hasn't changed since the last save. In hot inner loop scenarios this would reduce the save to a timestamp check.
+- Saving the file asynchronously, i.e. not blocking the build on completing the save operation.
+
+### Don't use the SDK disk pre-cache
+
+The idea of pre-generated on-disk cache is sound. For the `ExternallyResolved` SDK assemblies specifically, though, it effectively duplicates the information already
+present in `FrameworkList.xml`. That is, it maps assembly paths to assembly names. If the need arises we may want to re-design the pre-cache to remove the major
+drawback that it duplicates itself into all per-project caches. Cold RAR would load both caches and combine their contents (currently it's either or). Until then,
+it should be OK to leave it unchanged and unused.
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 99bceac17ab..1ad0c954695 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -223,15 +223,17 @@ A project reference protocol may contain multiple targets, for example `A -> B,
 
 The common project reference protocols (Build, Rebuild, Restore, Clean) will be specified by the common props and targets file in the msbuild repository. Other SDKs can implement their own protocols (e.g. ASPNET implementing Publish).
 
+For this section and the remainder of this spec, a project's default target(s) (what it would execute if no other targets are specified, so often Build but configurable via DefaultTargets) will be referred to as `.default`. That is also how it is used in MSBuild code.
+
 Here are the rules for the common protocols:
 
-`Build -> GetTargetFrameworks, <default>, GetNativeManifest, GetCopyToOutputDirectoryItems`
+`Build -> GetTargetFrameworks, .default, GetNativeManifest, GetCopyToOutputDirectoryItems`
 
-The default target (represented in this spec's pseudo protocol representation as `<default>`) is resolved for each project.
+`.default` is resolved for each project.
 
 `Clean -> GetTargetFrameworks, Clean`
 
-`Rebuild -> GetTargetFrameworks, Clean, <default>, GetNativeManifest, GetCopyToOutputDirectoryItems`
+`Rebuild -> GetTargetFrameworks, Clean, .default, GetNativeManifest, GetCopyToOutputDirectoryItems`
 
 `Rebuild` actually calls `Clean` and `Build`, which in turn uses the concatenation of the `Clean` and `Build` mappings. `GetTargetFrameworks` is repeated so only the first call to it remains in the final target list.
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 4ef85d8de35..25f81f0eebe 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -28,6 +28,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
 - [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
 - [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
+- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
 
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
diff --git a/eng/SourceBuild.props b/eng/SourceBuild.props
index 0bc1c2b8324..2bd3712f6ee 100644
--- a/eng/SourceBuild.props
+++ b/eng/SourceBuild.props
@@ -3,6 +3,7 @@
   <PropertyGroup>
     <GitHubRepositoryName>msbuild</GitHubRepositoryName>
     <SourceBuildManagedOnly>true</SourceBuildManagedOnly>
+    <SourceBuildTrimNetFrameworkTargets>true</SourceBuildTrimNetFrameworkTargets>
   </PropertyGroup>
 
   <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration">
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 009a31bbea5..e312a5bbfef 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23114.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23167.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>0c93c1cb1ef9c9d5c1a59f4ab98c2f7e37f12197</Sha>
+      <Sha>92c39a4f0bacef20812f63e2e1d3f7aa8776038d</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-rc.149">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>ca5029046d7b6e55f322c45abb7b342054543710</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.6.0-1.23109.10">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.6.0-2.23171.5">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>73338d92270b9f26982eca2e8872037a0214b912</Sha>
+      <Sha>48b13597fee9df5ecfbd0b8c0758b3f46bc1d440</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23114.5">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23167.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>0c93c1cb1ef9c9d5c1a59f4ab98c2f7e37f12197</Sha>
+      <Sha>92c39a4f0bacef20812f63e2e1d3f7aa8776038d</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 1b66f02385a..7109c4f75a6 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.6.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.5.0-preview-23075-01</PackageValidationBaselineVersion>
+    <VersionPrefix>17.7.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.6.0-preview-23178-11</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -48,10 +48,10 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23114.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23167.1</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.6.0-1.23109.10</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.6.0-2.23171.5</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.5.0-rc.149</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
diff --git a/global.json b/global.json
index 6db16c7387f..4bd9c24c01e 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23114.5"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23167.1"
   }
 }
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 14c83442af4..1dcc2fb9fc2 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -35,9 +35,6 @@
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index e86e7622799..7748a189690 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -84,6 +85,32 @@ public void TasksAreDiscoveredWhenTaskConditionTrue()
             logger.AssertLogDoesntContain("Made it");
         }
 
+        [Fact]
+        public void TasksOnlyLogStartedEventOnceEach()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectFileContents = ObjectModelHelpers.CleanupFileContents(
+            @"<Project>
+              <Target Name='t'>
+                  <Message Text='Made it'/>
+              </Target>
+            </Project>");
+
+            TransientTestFile projectFile = env.CreateFile("myProj.proj", projectFileContents);
+            env.SetEnvironmentVariable("DOTNET_PERFLOG_DIR", @"C:\Users\namytelk\Desktop");
+
+            string results = RunnerUtilities.ExecMSBuild(projectFile.Path + " /v:diag", out bool success);
+
+            int count = 0;
+            for (int index = results.IndexOf("Task \"Message\""); index >= 0; index = results.IndexOf("Task \"Message\"", index))
+            {
+                count++;
+                index += 14; // Skip to the end of this string
+            }
+
+            count.ShouldBe(1);
+        }
+
         /// <summary>
         /// Tests that when the task condition is false, Execute still returns true even though we never loaded
         /// the task.  We verify that we never loaded the task because if we did try, the task load itself would
diff --git a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
index c08c92c9134..0e9ea26e3c7 100644
--- a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
+++ b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
@@ -5,7 +5,10 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Xml;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -254,5 +257,92 @@ public void ProjectEvaluationShouldRespectConditionsIfProjectLoadSettingsSaysSo(
                 });
             }
         }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromFile(string, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromFileInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                Project project = Project.FromFile(
+                    projectRootElement.FullPath,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromProjectRootElement(ProjectRootElement, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromProjectRootElementInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                Project project = Project.FromProjectRootElement(
+                    projectRootElement,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromXmlReader(XmlReader, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromXmlReaderInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                using (XmlReader xmlReader = XmlReader.Create(projectRootElement.FullPath))
+                {
+                    Project project = Project.FromXmlReader(
+                        xmlReader,
+                        new ProjectOptions
+                        {
+                            Interactive = interactive,
+                            ProjectCollection = projectCollection,
+                        });
+
+                    project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+                }
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index d93e4342dc0..3b04989a30b 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -222,6 +222,18 @@ public void ExpandItemVectorFunctionsAnyHaveMetadataValue()
             Assert.Equal("false", itemsFalse[0].EvaluatedInclude);
         }
 
+        [Fact]
+        public void ExpandEmptyItemVectorFunctionWithAnyHaveMetadataValue()
+        {
+            ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = CreateItemFunctionExpander();
+            ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(project, "i");
+
+            IList<ProjectItemInstance> itemsEmpty = expander.ExpandIntoItemsLeaveEscaped("@(unsetItem->AnyHaveMetadataValue('Metadatum', 'value'))", itemFactory, ExpanderOptions.ExpandItems, MockElementLocation.Instance);
+            ProjectItemInstance pii = itemsEmpty.ShouldHaveSingleItem<ProjectItemInstance>();
+            pii.EvaluatedInclude.ShouldBe("false");
+        }
+
         /// <summary>
         /// Expand an item vector function Metadata()->DirectoryName()->Distinct()
         /// </summary>
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index fdce69b8b3b..845b0c556c8 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -34,6 +34,33 @@ namespace Microsoft.Build.Graph.UnitTests
     public class ProjectGraphSetPlatformTests
     {
 
+        [Fact]
+        public void ValidateGlobalPropertyCopyByValueNotReference()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" />
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+            }
+        }
+
         [Fact]
         public void ValidateSetPlatformOverride()
         {
@@ -75,6 +102,48 @@ public void ValidateSetPlatformOverride()
             }
         }
 
+        [Fact]
+        public void ValidateNegotiationOverride()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                    <OverridePlatformNegotiationValue>x86</OverridePlatformNegotiationValue>
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>x64;AnyCPU</Platforms>
+                                                            <Platform>x86</Platform>
+                                                        </PropertyGroup>
+                                                        <ItemGroup>
+                                                            <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" >
+                                                            </ProjectReference>
+                                                        </ItemGroup>
+                                                    </Project>");
+                var proj3 = env.CreateFile("3.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <Platforms>AnyCPU;x86</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
         [Fact]
         public void ResolvesMultipleReferencesToSameProject()
         {
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index 546c42c9432..9cbb3ea8b5f 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
@@ -68,11 +69,11 @@ public void GetTaskRegistrations()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Assert.Equal(3, project.TaskRegistry.TaskRegistrations.Count);
-                Assert.Equal(Path.Combine(Directory.GetCurrentDirectory(), "af0"), project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t0", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile);
-                Assert.Equal(Path.Combine(Directory.GetCurrentDirectory(), "af1a"), project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile);
-                Assert.Equal("an1", project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][1].TaskFactoryAssemblyLoadInfo.AssemblyName);
-                Assert.Equal("an2", project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t2", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyName);
+                project.TaskRegistry.TaskRegistrations.Count.ShouldBe(3);
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t0", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af0"));
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af1a"));
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][1].TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an1");
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t2", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an2");
             }
             finally
             {
@@ -115,8 +116,8 @@ public void InitialTargetsDefaultTargets()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Helpers.AssertListsValueEqual(new string[] { "d0a", "d0b" }, project.DefaultTargets);
-                Helpers.AssertListsValueEqual(new string[] { "i0a", "i0b", "i1a", "i1b", "i3a", "i3b", "i2a", "i2b" }, project.InitialTargets);
+                project.DefaultTargets.ShouldBe(new string[] { "d0a", "d0b" });
+                project.InitialTargets.ShouldBe(new string[] { "i0a", "i0b", "i1a", "i1b", "i3a", "i3b", "i2a", "i2b" });
             }
             finally
             {
@@ -140,8 +141,8 @@ public void InitialTargetsDefaultTargetsEscaped()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Helpers.AssertListsValueEqual(new string[] { "d0a;d0b" }, project.DefaultTargets);
-                Helpers.AssertListsValueEqual(new string[] { "i0a;i0b" }, project.InitialTargets);
+                project.DefaultTargets.ShouldBe(new string[] { "d0a;d0b" });
+                project.InitialTargets.ShouldBe(new string[] { "i0a;i0b" });
             }
             finally
             {
@@ -169,16 +170,16 @@ public void GetPropertyGroupUnderTarget()
             ProjectInstance p = GetProjectInstance(content);
             ProjectPropertyGroupTaskInstance propertyGroup = (ProjectPropertyGroupTaskInstance)(p.Targets["t"].Children[0]);
 
-            Assert.Equal("c1", propertyGroup.Condition);
+            propertyGroup.Condition.ShouldBe("c1");
 
             List<ProjectPropertyGroupTaskPropertyInstance> properties = Helpers.MakeList(propertyGroup.Properties);
-            Assert.Equal(2, properties.Count);
+            properties.Count.ShouldBe(2);
 
-            Assert.Equal("c2", properties[0].Condition);
-            Assert.Equal("v1", properties[0].Value);
+            properties[0].Condition.ShouldBe("c2");
+            properties[0].Value.ShouldBe("v1");
 
-            Assert.Equal(String.Empty, properties[1].Condition);
-            Assert.Equal(String.Empty, properties[1].Value);
+            properties[1].Condition.ShouldBe(String.Empty);
+            properties[1].Value.ShouldBe(String.Empty);
         }
 
         /// <summary>
@@ -207,41 +208,41 @@ public void GetItemGroupUnderTarget()
             ProjectInstance p = GetProjectInstance(content);
             ProjectItemGroupTaskInstance itemGroup = (ProjectItemGroupTaskInstance)(p.Targets["t"].Children[0]);
 
-            Assert.Equal("c1", itemGroup.Condition);
+            itemGroup.Condition.ShouldBe("c1");
 
             List<ProjectItemGroupTaskItemInstance> items = Helpers.MakeList(itemGroup.Items);
-            Assert.Equal(3, items.Count);
+            items.Count.ShouldBe(3);
 
-            Assert.Equal("i1", items[0].Include);
-            Assert.Equal("e1", items[0].Exclude);
-            Assert.Equal(String.Empty, items[0].Remove);
-            Assert.Equal("c2", items[0].Condition);
+            items[0].Include.ShouldBe("i1");
+            items[0].Exclude.ShouldBe("e1");
+            items[0].Remove.ShouldBe(String.Empty);
+            items[0].Condition.ShouldBe("c2");
 
-            Assert.Equal(String.Empty, items[1].Include);
-            Assert.Equal(String.Empty, items[1].Exclude);
-            Assert.Equal("r1", items[1].Remove);
-            Assert.Equal(String.Empty, items[1].Condition);
+            items[1].Include.ShouldBe(String.Empty);
+            items[1].Exclude.ShouldBe(String.Empty);
+            items[1].Remove.ShouldBe("r1");
+            items[1].Condition.ShouldBe(String.Empty);
 
-            Assert.Equal(String.Empty, items[2].Include);
-            Assert.Equal(String.Empty, items[2].Exclude);
-            Assert.Equal(String.Empty, items[2].Remove);
-            Assert.Equal(String.Empty, items[2].Condition);
+            items[2].Include.ShouldBe(String.Empty);
+            items[2].Exclude.ShouldBe(String.Empty);
+            items[2].Remove.ShouldBe(String.Empty);
+            items[2].Condition.ShouldBe(String.Empty);
 
             List<ProjectItemGroupTaskMetadataInstance> metadata1 = Helpers.MakeList(items[0].Metadata);
             List<ProjectItemGroupTaskMetadataInstance> metadata2 = Helpers.MakeList(items[1].Metadata);
             List<ProjectItemGroupTaskMetadataInstance> metadata3 = Helpers.MakeList(items[2].Metadata);
 
-            Assert.Equal(2, metadata1.Count);
-            Assert.Empty(metadata2);
-            Assert.Single(metadata3);
+            metadata1.Count.ShouldBe(2);
+            metadata2.ShouldBeEmpty();
+            metadata3.ShouldHaveSingleItem();
 
-            Assert.Equal("c3", metadata1[0].Condition);
-            Assert.Equal("m1", metadata1[0].Value);
-            Assert.Equal(String.Empty, metadata1[1].Condition);
-            Assert.Equal("n1", metadata1[1].Value);
+            metadata1[0].Condition.ShouldBe("c3");
+            metadata1[0].Value.ShouldBe("m1");
+            metadata1[1].Condition.ShouldBe(String.Empty);
+            metadata1[1].Value.ShouldBe("n1");
 
-            Assert.Equal(String.Empty, metadata3[0].Condition);
-            Assert.Equal("o1", metadata3[0].Value);
+            metadata3[0].Condition.ShouldBe(String.Empty);
+            metadata3[0].Value.ShouldBe("o1");
         }
 
         /// <summary>
@@ -252,7 +253,7 @@ public void GetTaskRegistry()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.True(p.TaskRegistry != null);
+            p.TaskRegistry.ShouldNotBeNull();
         }
 
         /// <summary>
@@ -263,8 +264,8 @@ public void GetGlobalProperties()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.Equal("v1", p.GlobalPropertiesDictionary["g1"].EvaluatedValue);
-            Assert.Equal("v2", p.GlobalPropertiesDictionary["g2"].EvaluatedValue);
+            p.GlobalPropertiesDictionary["g1"].EvaluatedValue.ShouldBe("v1");
+            p.GlobalPropertiesDictionary["g2"].EvaluatedValue.ShouldBe("v2");
         }
 
         /// <summary>
@@ -275,7 +276,7 @@ public void GetToolsVersion()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
+            p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         [Fact]
@@ -298,9 +299,9 @@ public void CloneToolsetData()
             CreateMockToolsetIfNotExists("TESTTV", projectCollection);
             ProjectInstance first = GetSampleProjectInstance(null, null, projectCollection, toolsVersion: "TESTTV");
             ProjectInstance second = first.DeepCopy();
-            Assert.Equal(first.ToolsVersion, second.ToolsVersion);
-            Assert.Equal(first.ExplicitToolsVersion, second.ExplicitToolsVersion);
-            Assert.Equal(first.ExplicitToolsVersionSpecified, second.ExplicitToolsVersionSpecified);
+            second.ToolsVersion.ShouldBe(first.ToolsVersion);
+            second.ExplicitToolsVersion.ShouldBe(first.ExplicitToolsVersion);
+            second.ExplicitToolsVersionSpecified.ShouldBe(first.ExplicitToolsVersionSpecified);
         }
 
         /// <summary>
@@ -317,16 +318,16 @@ public void GetSubToolsetVersion()
 
                 ProjectInstance p = GetSampleProjectInstance(null, null, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal(p.Toolset.DefaultSubToolsetVersion, p.SubToolsetVersion);
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe(p.Toolset.DefaultSubToolsetVersion);
 
                 if (p.Toolset.DefaultSubToolsetVersion == null)
                 {
-                    Assert.Equal(MSBuildConstants.CurrentVisualStudioVersion, p.GetPropertyValue("VisualStudioVersion"));
+                    p.GetPropertyValue("VisualStudioVersion").ShouldBe(MSBuildConstants.CurrentVisualStudioVersion);
                 }
                 else
                 {
-                    Assert.Equal(p.Toolset.DefaultSubToolsetVersion, p.GetPropertyValue("VisualStudioVersion"));
+                    p.GetPropertyValue("VisualStudioVersion").ShouldBe(p.Toolset.DefaultSubToolsetVersion);
                 }
             }
             finally
@@ -350,9 +351,9 @@ public void GetSubToolsetVersion_FromEnvironment()
 
                 ProjectInstance p = GetSampleProjectInstance(null, null, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCD", p.SubToolsetVersion);
-                Assert.Equal("ABCD", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCD");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCD");
             }
             finally
             {
@@ -377,9 +378,9 @@ public void GetSubToolsetVersion_FromProjectGlobalProperties()
 
                 ProjectInstance p = GetSampleProjectInstance(null, globalProperties, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCDE", p.SubToolsetVersion);
-                Assert.Equal("ABCDE", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDE");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDE");
             }
             finally
             {
@@ -416,9 +417,9 @@ public void GetSubToolsetVersion_FromConstructor()
 
                 ProjectInstance p = new ProjectInstance(xml, globalProperties, ObjectModelHelpers.MSBuildDefaultToolsVersion, "ABCDEF", new ProjectCollection(projectCollectionGlobalProperties));
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCDEF", p.SubToolsetVersion);
-                Assert.Equal("ABCDEF", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDEF");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDEF");
             }
             finally
             {
@@ -434,7 +435,7 @@ public void GetDefaultTargets()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Helpers.AssertListsValueEqual(new string[] { "dt" }, p.DefaultTargets);
+            p.DefaultTargets.ShouldBe(new string[] { "dt" });
         }
 
         /// <summary>
@@ -445,7 +446,7 @@ public void GetInitialTargets()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Helpers.AssertListsValueEqual(new string[] { "it" }, p.InitialTargets);
+            p.InitialTargets.ShouldBe(new string[] { "it" });
         }
 
         /// <summary>
@@ -460,13 +461,14 @@ public void CloneTargets()
             ProjectInstance second = first.DeepCopy();
 
             // Targets, tasks are immutable so we can expect the same objects
-            Assert.True(Object.ReferenceEquals(first.Targets, second.Targets));
-            Assert.True(Object.ReferenceEquals(first.Targets["t"], second.Targets["t"]));
+            first.Targets.ShouldBeSameAs(second.Targets);
+
+            first.Targets["t"].ShouldBeSameAs(second.Targets["t"]);
 
             var firstTasks = first.Targets["t"];
             var secondTasks = second.Targets["t"];
 
-            Assert.True(Object.ReferenceEquals(firstTasks.Children[0], secondTasks.Children[0]));
+            firstTasks.Children[0].ShouldBeSameAs(secondTasks.Children[0]);
         }
 
         /// <summary>
@@ -479,7 +481,7 @@ public void CloneTaskRegistry()
             ProjectInstance second = first.DeepCopy();
 
             // Task registry object should be immutable
-            Assert.Same(first.TaskRegistry, second.TaskRegistry);
+            first.TaskRegistry.ShouldBeSameAs(second.TaskRegistry);
         }
 
         /// <summary>
@@ -491,8 +493,8 @@ public void CloneGlobalProperties()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.Equal("v1", second.GlobalPropertiesDictionary["g1"].EvaluatedValue);
-            Assert.Equal("v2", second.GlobalPropertiesDictionary["g2"].EvaluatedValue);
+            second.GlobalPropertiesDictionary["g1"].EvaluatedValue.ShouldBe("v1");
+            second.GlobalPropertiesDictionary["g2"].EvaluatedValue.ShouldBe("v2");
         }
 
         /// <summary>
@@ -504,7 +506,7 @@ public void CloneDefaultTargets()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Helpers.AssertListsValueEqual(new string[] { "dt" }, second.DefaultTargets);
+            second.DefaultTargets.ShouldBe(new string[] { "dt" });
         }
 
         /// <summary>
@@ -516,7 +518,7 @@ public void CloneInitialTargets()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Helpers.AssertListsValueEqual(new string[] { "it" }, second.InitialTargets);
+            second.InitialTargets.ShouldBe(new string[] { "it" });
         }
 
         /// <summary>
@@ -528,7 +530,7 @@ public void CloneToolsVersion()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.Equal(first.Toolset, second.Toolset);
+            second.Toolset.ShouldBe(first.Toolset);
         }
 
         /// <summary>
@@ -542,7 +544,7 @@ public void CloneStateTranslation()
 
             ProjectInstance second = first.DeepCopy();
 
-            Assert.True(second.TranslateEntireState);
+            second.TranslateEntireState.ShouldBeTrue();
         }
 
         /// <summary>
@@ -574,7 +576,7 @@ public void Build()
             loggers.Add(mockLogger);
             bool success = projectInstance.Build("Build", loggers);
 
-            Assert.True(success);
+            success.ShouldBeTrue();
             mockLogger.AssertLogContains(new string[] { "Building...", "Completed!" });
         }
 
@@ -684,7 +686,7 @@ public void ProjectInstanceCanSerializeEntireStateViaTranslator(string projectCo
             ((ITranslatable)original).Translate(TranslationHelpers.GetWriteTranslator());
             var copy = ProjectInstance.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(original, copy, new ProjectInstanceComparer());
+            new ProjectInstanceComparer().Equals(original, copy).ShouldBeTrue($"{nameof(copy)} and {original} should be equal according to the {nameof(ProjectInstanceComparer)}");
         }
 
         public delegate ProjectInstance ProjectInstanceFactory(string file, ProjectRootElement xml, ProjectCollection collection);
@@ -757,7 +759,7 @@ public void ProjectInstanceHasEvaluationId(ProjectInstanceFactory projectInstanc
                 xml.Save(file);
 
                 var projectInstance = projectInstanceFactory.Invoke(file, xml, projectCollection);
-                Assert.NotEqual(BuildEventContext.InvalidEvaluationId, projectInstance.EvaluationId);
+                projectInstance.EvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);
             }
         }
 
@@ -773,27 +775,27 @@ public void AddTargetAddsNewTarget()
 
             ProjectTargetInstance targetInstance = projectInstance.AddTarget("b", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true);
 
-            Assert.Equal(2, projectInstance.Targets.Count);
-            Assert.Equal(targetInstance, projectInstance.Targets["b"]);
-            Assert.Equal("b", targetInstance.Name);
-            Assert.Equal("1==1", targetInstance.Condition);
-            Assert.Equal("inputs", targetInstance.Inputs);
-            Assert.Equal("outputs", targetInstance.Outputs);
-            Assert.Equal("returns", targetInstance.Returns);
-            Assert.Equal("keepDuplicateOutputs", targetInstance.KeepDuplicateOutputs);
-            Assert.Equal("dependsOnTargets", targetInstance.DependsOnTargets);
-            Assert.Equal("beforeTargets", targetInstance.BeforeTargets);
-            Assert.Equal("afterTargets", targetInstance.AfterTargets);
-            Assert.Equal(projectInstance.ProjectFileLocation, targetInstance.Location);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.ConditionLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.InputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.OutputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.ReturnsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.KeepDuplicateOutputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.DependsOnTargetsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.BeforeTargetsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.AfterTargetsLocation);
-            Assert.True(targetInstance.ParentProjectSupportsReturnsAttribute);
+            projectInstance.Targets.Count.ShouldBe(2);
+            projectInstance.Targets["b"].ShouldBe(targetInstance);
+            targetInstance.Name.ShouldBe("b");
+            targetInstance.Condition.ShouldBe("1==1");
+            targetInstance.Inputs.ShouldBe("inputs");
+            targetInstance.Outputs.ShouldBe("outputs");
+            targetInstance.Returns.ShouldBe("returns");
+            targetInstance.KeepDuplicateOutputs.ShouldBe("keepDuplicateOutputs");
+            targetInstance.DependsOnTargets.ShouldBe("dependsOnTargets");
+            targetInstance.BeforeTargets.ShouldBe("beforeTargets");
+            targetInstance.AfterTargets.ShouldBe("afterTargets");
+            targetInstance.Location.ShouldBe(projectInstance.ProjectFileLocation);
+            targetInstance.ConditionLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.InputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.OutputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.ReturnsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.KeepDuplicateOutputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.DependsOnTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.BeforeTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.AfterTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.ParentProjectSupportsReturnsAttribute.ShouldBeTrue();
         }
 
         [Fact]
@@ -806,7 +808,7 @@ public void AddTargetThrowsWithExistingTarget()
             ProjectRootElement rootElement = ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)));
             ProjectInstance projectInstance = new ProjectInstance(rootElement);
 
-            Assert.Throws<InternalErrorException>(() => projectInstance.AddTarget("a", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true));
+            Should.Throw<InternalErrorException>(() => projectInstance.AddTarget("a", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true));
         }
 
         [Theory]
@@ -856,8 +858,8 @@ public void GetImportPathsAndImportPathsIncludingDuplicates(bool useDirectConstr
                     ? new string[] { import1Path, import2Path, import3Path, import2Path, import1Path }
                     : expectedImportPaths;
 
-                Helpers.AssertListsValueEqual(expectedImportPaths, projectInstance.ImportPaths.ToList());
-                Helpers.AssertListsValueEqual(expectedImportPathsIncludingDuplicates, projectInstance.ImportPathsIncludingDuplicates.ToList());
+                projectInstance.ImportPaths.ToList().ShouldBe(expectedImportPaths);
+                projectInstance.ImportPathsIncludingDuplicates.ToList().ShouldBe(expectedImportPathsIncludingDuplicates);
             }
             finally
             {
@@ -865,6 +867,62 @@ public void GetImportPathsAndImportPathsIncludingDuplicates(bool useDirectConstr
             }
         }
 
+        /// <summary>
+        /// Verifies that when calling <see cref="ProjectInstance.FromFile(string, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectInstanceFromFileInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                ProjectInstance projectInstance = ProjectInstance.FromFile(
+                    projectRootElement.FullPath,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                projectInstance.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="ProjectInstance.FromProjectRootElement(ProjectRootElement, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectInstanceFromProjectRootElementInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                ProjectInstance projectInstance = ProjectInstance.FromProjectRootElement(
+                    projectRootElement,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                projectInstance.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
         /// <summary>
         /// Create a ProjectInstance from provided project content
         /// </summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 3e926e2e75e..1ded6e6fc8a 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -5,8 +5,9 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
-using Microsoft.Build.Execution;
+using System.Linq;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Execution;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 #nullable disable
@@ -289,15 +290,7 @@ public List<BuildRequestConfiguration> GetUnresolvedConfigurationsToIssue()
         /// </summary>
         public string[] GetActiveTargets()
         {
-            var activeTargets = new string[RequestConfiguration.ActivelyBuildingTargets.Count];
-
-            int index = 0;
-            foreach (string target in RequestConfiguration.ActivelyBuildingTargets.Keys)
-            {
-                activeTargets[index++] = target;
-            }
-
-            return activeTargets;
+            return RequestConfiguration.ActivelyBuildingTargets.Keys.ToArray();
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index c9223838572..7346954557d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -287,7 +287,10 @@ bool TryReuseAnyFromPossibleRunningNodes(int nodeId)
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeToReuse.Id);
                         string msg = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("NodeReused", nodeId, nodeToReuse.Id);
-                        _componentHost.LoggingService.LogBuildEvent(new BuildMessageEventArgs(msg, null, null, MessageImportance.Low));
+                        _componentHost.LoggingService.LogBuildEvent(new BuildMessageEventArgs(msg, null, null, MessageImportance.Low)
+                        {
+                            BuildEventContext = new BuildEventContext(nodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId)
+                        });
 
                         CreateNodeContext(nodeId, nodeToReuse, nodeStream);
                         return true;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 0f80c152ba5..a4c66a74ce0 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -246,15 +246,15 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// Event set when message is consumed from queue.
         /// </summary>
-        private ManualResetEventSlim _dequeueEvent;
+        private AutoResetEvent _dequeueEvent;
         /// <summary>
         /// Event set when queue become empty.
         /// </summary>
-        private ManualResetEventSlim _emptyQueueEvent;
+        private ManualResetEvent _emptyQueueEvent;
         /// <summary>
         /// Even set when message is added into queue.
         /// </summary>
-        private ManualResetEventSlim _enqueueEvent;
+        private AutoResetEvent _enqueueEvent;
 
         /// <summary>
         /// CTS for stopping logging event processing.
@@ -1183,8 +1183,7 @@ internal virtual void ProcessLoggingEvent(object buildEvent)
                 while (_eventQueue.Count >= _queueCapacity)
                 {
                     // Block and wait for dequeue event.
-                    _dequeueEvent.Wait();
-                    _dequeueEvent.Reset();
+                    _dequeueEvent.WaitOne();
                 }
 
                 _eventQueue.Enqueue(buildEvent);
@@ -1209,12 +1208,12 @@ public void WaitForLoggingToProcessEvents()
         {
             while (_eventQueue?.IsEmpty == false)
             {
-                _emptyQueueEvent?.Wait();
+                _emptyQueueEvent?.WaitOne();
             }
             // To avoid race condition when last message has been removed from queue but
             //   not yet fully processed (handled by loggers), we need to make sure _emptyQueueEvent
             //   is set as it is guaranteed to be in set state no sooner than after event has been processed.
-            _emptyQueueEvent?.Wait();
+            _emptyQueueEvent?.WaitOne();
         }
 
         /// <summary>
@@ -1263,9 +1262,9 @@ private static int GetWarningsAsErrorOrMessageKey(BuildEventArgs buildEventArgs)
         private void StartLoggingEventProcessing()
         {
             _eventQueue = new ConcurrentQueue<object>();
-            _dequeueEvent = new ManualResetEventSlim(false);
-            _emptyQueueEvent = new ManualResetEventSlim(false);
-            _enqueueEvent = new ManualResetEventSlim(false);
+            _dequeueEvent = new AutoResetEvent(false);
+            _emptyQueueEvent = new ManualResetEvent(false);
+            _enqueueEvent = new AutoResetEvent(false);
             _loggingEventProcessingCancellation = new CancellationTokenSource();
 
             _loggingEventProcessingThread = new Thread(LoggingEventProc);
@@ -1276,7 +1275,7 @@ private void StartLoggingEventProcessing()
             void LoggingEventProc()
             {
                 var completeAdding = _loggingEventProcessingCancellation.Token;
-                WaitHandle[] waitHandlesForNextEvent = { completeAdding.WaitHandle, _enqueueEvent.WaitHandle };
+                WaitHandle[] waitHandlesForNextEvent = { completeAdding.WaitHandle, _enqueueEvent };
 
                 do
                 {
@@ -1295,7 +1294,6 @@ void LoggingEventProc()
                             WaitHandle.WaitAny(waitHandlesForNextEvent);
                         }
 
-                        _enqueueEvent.Reset();
                         _emptyQueueEvent.Reset();
                     }
                 } while (!_eventQueue.IsEmpty || !completeAdding.IsCancellationRequested);
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index cf228ca379a..9d1cefe040d 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -543,22 +543,19 @@ static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromS
                 string definingProjectPath,
                 Dictionary<string, string> templateGlobalProperties)
             {
-                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
-                var doc = new XmlDocument();
-                doc.LoadXml(solutionConfigurationXml);
-
-                var root = doc.DocumentElement!;
-                var projectConfigurationNodes = root.GetElementsByTagName("ProjectConfiguration");
-
-                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, "Expected at least one project in solution");
+                XmlNodeList? projectConfigurations = SolutionConfiguration.GetProjectConfigurations(solutionConfigurationXml);
+                if (projectConfigurations == null || projectConfigurations.Count == 0)
+                {
+                    return Array.Empty<ProjectGraphEntryPoint>();
+                }
 
-                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);
+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurations.Count);
 
-                foreach (XmlNode node in projectConfigurationNodes)
+                foreach (XmlElement projectConfiguration in projectConfigurations)
                 {
-                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));
+                    ErrorUtilities.VerifyThrowInternalNull(projectConfiguration.Attributes, nameof(projectConfiguration.Attributes));
 
-                    var buildProjectInSolution = node.Attributes!["BuildProjectInSolution"];
+                    var buildProjectInSolution = projectConfiguration.Attributes![SolutionConfiguration.BuildProjectInSolutionAttribute];
                     if (buildProjectInSolution is not null &&
                         string.IsNullOrWhiteSpace(buildProjectInSolution.Value) is false &&
                         bool.TryParse(buildProjectInSolution.Value, out var buildProject) &&
@@ -567,12 +564,12 @@ static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromS
                         continue;
                     }
 
-                    var projectPathAttribute = node.Attributes!["AbsolutePath"];
+                    XmlAttribute? projectPathAttribute = projectConfiguration.Attributes![SolutionConfiguration.AbsolutePathAttribute];
                     ErrorUtilities.VerifyThrow(projectPathAttribute is not null, "Expected VS to set the project path on each ProjectConfiguration element.");
 
-                    var projectPath = projectPathAttribute!.Value;
+                    string projectPath = projectPathAttribute!.Value;
 
-                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);
+                    (string configuration, string platform) = SolutionFile.ParseConfigurationName(projectConfiguration.InnerText, definingProjectPath, 0, solutionConfigurationXml);
 
                     // Take the defining project global properties and override the configuration and platform.
                     // It's sufficient to only set Configuration and Platform.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 61f4bcb31fb..0f9f1858b52 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -150,7 +150,7 @@ private void StopTracking()
         private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs args)
         {
             string? assemblyName = args.LoadedAssembly.FullName;
-            string assemblyPath = args.LoadedAssembly.Location;
+            string assemblyPath = args.LoadedAssembly.IsDynamic ? string.Empty : args.LoadedAssembly.Location;
             Guid mvid = args.LoadedAssembly.ManifestModule.ModuleVersionId;
             string? appDomainDescriptor = _appDomain.IsDefaultAppDomain()
                 ? null
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index f593edb11fc..dcf16e16545 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -202,7 +202,7 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
                          * 
                          */
                         ErrorUtilities.VerifyThrow(itemVectorsReferencedInBothTargetInputsAndOutputs.Count > 0, "The target must have inputs.");
-                        ErrorUtilities.VerifyThrow(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs).Count > 0, "The target must have inputs.");
+                        ErrorUtilities.VerifyThrow(!IsItemVectorEmpty(itemVectorsInTargetInputs), "The target must have inputs.");
 
                         result = PerformDependencyAnalysisIfDiscreteInputs(itemVectorsInTargetInputs,
                                     itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs, itemVectorsReferencedOnlyInTargetInputs,
@@ -527,7 +527,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteInputs(
             // cannot correlate them to any output item
             foreach (string itemVectorType in itemVectorsReferencedOnlyInTargetInputs)
             {
-                discreteTargetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs, itemVectorType));
+                discreteTargetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs, itemVectorType, itemVectorsInTargetInputs[itemVectorType]));
             }
 
             // if there are any discrete input items, we can treat them as "meta" inputs, because:
@@ -857,6 +857,19 @@ private void SeparateItemVectorsFromDiscreteItems(
             }
         }
 
+        private static bool IsItemVectorEmpty(ItemVectorPartitionCollection itemVectors)
+        {
+            foreach (KeyValuePair<string, ItemVectorPartition> item in itemVectors)
+            {
+                if (GetItemSpecsFromItemVectors(itemVectors, item.Key, item.Value).Any())
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
         /// <summary>
         /// Retrieves the item-specs of all items in the given item vector collection.
         /// </summary>
@@ -864,11 +877,11 @@ private void SeparateItemVectorsFromDiscreteItems(
         /// <returns>list of item-specs</returns>
         private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors)
         {
-            List<string> itemSpecs = new List<string>();
+            List<string> itemSpecs = new();
 
-            foreach (string itemType in itemVectors.Keys)
+            foreach (KeyValuePair<string, ItemVectorPartition> item in itemVectors)
             {
-                itemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectors, itemType));
+                itemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectors, item.Key, item.Value));
             }
 
             return itemSpecs;
@@ -879,13 +892,10 @@ private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionColle
         /// </summary>
         /// <param name="itemVectors"></param>
         /// <param name="itemType"></param>
+        /// <param name="itemVectorPartition"></param>
         /// <returns>list of item-specs</returns>
-        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, string itemType)
+        private static IEnumerable<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, string itemType, ItemVectorPartition itemVectorPartition)
         {
-            List<string> itemSpecs = new List<string>();
-
-            ItemVectorPartition itemVectorPartition = itemVectors[itemType];
-
             if (itemVectorPartition != null)
             {
                 foreach (IList<ProjectItemInstance> items in itemVectorPartition.Values)
@@ -895,12 +905,10 @@ private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionColle
                         // The item can be null in the case of an item transform.
                         // eg., @(Compile->'%(NonExistentMetadata)')
                         // Nevertheless, include these, so that correlation can still occur.
-                        itemSpecs.Add((item == null) ? null : ((IItem)item).EvaluatedIncludeEscaped);
+                        yield return item == null ? null : ((IItem)item).EvaluatedIncludeEscaped;
                     }
                 }
             }
-
-            return itemSpecs;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b83da0aa245..f8768988732 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -391,12 +391,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
             }
 
             // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-            if (MSBuildEventSource.Log.IsEnabled())
-            {
-                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-            }
-
             // If this is an Intrinsic task, it gets handled in a special fashion.
             if (_taskNode == null)
             {
@@ -433,6 +427,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                     if (requirements != null)
                     {
                         TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                        MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
                         _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
 
                         try
@@ -487,6 +482,8 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                                 // We coerce the failing result to a successful result.
                                 taskResult = new WorkUnitResult(WorkUnitResultCode.Success, taskResult.ActionCode, taskResult.Exception);
                             }
+
+                            MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
                         }
                     }
                 }
@@ -514,13 +511,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 }
             }
 
-            // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-            if (MSBuildEventSource.Log.IsEnabled())
-            {
-                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-            }
-
             return taskResult;
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 0c11f731cb5..bedccfe03cd 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -906,53 +906,53 @@ private bool GetSchedulingPlanAndAlgorithm()
         /// </summary>
         private void AssignUnscheduledRequestsWithPlanByMostImmediateReferences(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
-            foreach (int idleNodeId in idleNodes)
-            {
-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();
-
-                // Find the most expensive request in the plan to schedule from among the ones available.
-                foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)
-                {
-                    if (CanScheduleRequestToNode(request, idleNodeId))
-                    {
-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;
-                    }
-                }
-
-                if (configsWhichCanBeScheduledToThisNode.Count > 0)
-                {
-                    int configToSchedule = _schedulingPlan.GetConfigWithGreatestNumberOfReferences(configsWhichCanBeScheduledToThisNode.Keys);
-
-                    ErrorUtilities.VerifyThrow(configToSchedule != BuildRequestConfiguration.InvalidConfigurationId, "No configuration returned even though there are some available.");
-                    AssignUnscheduledRequestToNode(configsWhichCanBeScheduledToThisNode[configToSchedule], idleNodeId, responses);
-                }
-            }
+            AssignUnscheduledRequestsWithPlan(responses, idleNodes, (plan1, plan2) => plan1.ReferencesCount < plan2.ReferencesCount);
         }
 
         /// <summary>
         /// Assigns requests to nodes based on those which have the most plan time.
         /// </summary>
         private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleResponse> responses, HashSet<int> idleNodes)
+        {
+            AssignUnscheduledRequestsWithPlan(responses, idleNodes, (plan1, plan2) => plan1.TotalPlanTime < plan2.TotalPlanTime);
+        }
+
+        private void AssignUnscheduledRequestsWithPlan(List<ScheduleResponse> responses, HashSet<int> idleNodes, Func<SchedulingPlan.PlanConfigData, SchedulingPlan.PlanConfigData, bool> comparisonFunction)
         {
             foreach (int idleNodeId in idleNodes)
             {
-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();
+                SchedulingPlan.PlanConfigData bestConfig = null;
+                SchedulableRequest bestRequest = null;
 
                 // Find the most expensive request in the plan to schedule from among the ones available.
                 foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)
                 {
                     if (CanScheduleRequestToNode(request, idleNodeId))
                     {
-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;
+                        SchedulingPlan.PlanConfigData configToConsider = _schedulingPlan.GetConfiguration(request.BuildRequest.ConfigurationId);
+                        if (configToConsider is null)
+                        {
+                            if (bestConfig is null)
+                            {
+                                // By default we assume configs we don't know about aren't as important, and will only schedule them
+                                // if nothing else is suitable
+                                bestRequest ??= request;
+                            }
+                        }
+                        else
+                        {
+                            if (bestConfig is null || comparisonFunction(bestConfig, configToConsider))
+                            {
+                                bestConfig = configToConsider;
+                                bestRequest = request;
+                            }
+                        }
                     }
                 }
 
-                if (configsWhichCanBeScheduledToThisNode.Count > 0)
+                if (bestRequest is not null)
                 {
-                    int configToSchedule = _schedulingPlan.GetConfigWithGreatestPlanTime(configsWhichCanBeScheduledToThisNode.Keys);
-
-                    ErrorUtilities.VerifyThrow(configToSchedule != BuildRequestConfiguration.InvalidConfigurationId, "No configuration returned even though there are some available.");
-                    AssignUnscheduledRequestToNode(configsWhichCanBeScheduledToThisNode[configToSchedule], idleNodeId, responses);
+                    AssignUnscheduledRequestToNode(bestRequest, idleNodeId, responses);
                 }
             }
         }
@@ -962,23 +962,7 @@ private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleRe
         /// </summary>
         private void AssignUnscheduledRequestsByTraversalsFirst(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
-            if (idleNodes.Contains(InProcNodeId))
-            {
-                // Assign traversal projects first (to find more work.)
-                List<SchedulableRequest> unscheduledRequests = new List<SchedulableRequest>(_schedulingData.UnscheduledRequestsWhichCanBeScheduled);
-                foreach (SchedulableRequest request in unscheduledRequests)
-                {
-                    if (CanScheduleRequestToNode(request, InProcNodeId))
-                    {
-                        if (IsTraversalRequest(request.BuildRequest))
-                        {
-                            AssignUnscheduledRequestToNode(request, InProcNodeId, responses);
-                            idleNodes.Remove(InProcNodeId);
-                            break;
-                        }
-                    }
-                }
-            }
+            AssignUnscheduledRequestsToInProcNode(responses, idleNodes, request => IsTraversalRequest(request.BuildRequest));
         }
 
         /// <summary>
@@ -986,13 +970,18 @@ private void AssignUnscheduledRequestsByTraversalsFirst(List<ScheduleResponse> r
         /// paying the IPC cost and re-evaluating them on out of proc nodes (they are guaranteed to be evaluated in the Scheduler process).
         /// </summary>
         private void AssignUnscheduledProxyBuildRequestsToInProcNode(List<ScheduleResponse> responses, HashSet<int> idleNodes)
+        {
+            AssignUnscheduledRequestsToInProcNode(responses, idleNodes, request => request.IsProxyBuildRequest());
+        }
+
+        private void AssignUnscheduledRequestsToInProcNode(List<ScheduleResponse> responses, HashSet<int> idleNodes, Func<SchedulableRequest, bool> shouldBeScheduled)
         {
             if (idleNodes.Contains(InProcNodeId))
             {
                 List<SchedulableRequest> unscheduledRequests = new List<SchedulableRequest>(_schedulingData.UnscheduledRequestsWhichCanBeScheduled);
                 foreach (SchedulableRequest request in unscheduledRequests)
                 {
-                    if (CanScheduleRequestToNode(request, InProcNodeId) && request.IsProxyBuildRequest())
+                    if (CanScheduleRequestToNode(request, InProcNodeId) && shouldBeScheduled(request))
                     {
                         AssignUnscheduledRequestToNode(request, InProcNodeId, responses);
                         idleNodes.Remove(InProcNodeId);
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 022b6acf9d0..19f75d8da72 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -56,6 +56,12 @@ public SchedulingPlan(IConfigCache configCache, SchedulingData schedulingData)
             this.MaximumConfigurationId = BuildRequestConfiguration.InvalidConfigurationId;
         }
 
+        public PlanConfigData GetConfiguration(int configId)
+        {
+            _configPathToData.TryGetValue(_configCache[configId].ProjectFullPath, out PlanConfigData data);
+            return data;
+        }
+
         /// <summary>
         /// Returns true if a valid plan was read, false otherwise.
         /// </summary>
@@ -104,11 +110,11 @@ public void WritePlan(int submissionId, ILoggingService loggingService, BuildEve
                     Dictionary<int, double> accumulatedTimeByConfiguration = new Dictionary<int, double>();
                     RecursiveAccumulateConfigurationTimes(rootRequest, accumulatedTimeByConfiguration);
 
-                    List<int> configurationsInOrder = new List<int>(accumulatedTimeByConfiguration.Keys);
-                    configurationsInOrder.Sort();
-                    foreach (int configId in configurationsInOrder)
+                    List<KeyValuePair<int, double>> configurationsInOrder = new(accumulatedTimeByConfiguration);
+                    configurationsInOrder.Sort((KeyValuePair<int, double> l, KeyValuePair<int, double> r) => Comparer<int>.Default.Compare(l.Key, r.Key));
+                    foreach (KeyValuePair<int, double> configuration in configurationsInOrder)
                     {
-                        file.WriteLine(String.Format(CultureInfo.InvariantCulture, "{0} {1} {2}", configId, accumulatedTimeByConfiguration[configId], _configCache[configId].ProjectFullPath));
+                        file.WriteLine(String.Format(CultureInfo.InvariantCulture, "{0} {1} {2}", configuration.Key, configuration.Value, _configCache[configuration.Key].ProjectFullPath));
                     }
 
                     file.WriteLine();
@@ -192,80 +198,6 @@ public int GetConfigIdForPath(string configPath)
             return config.ConfigId;
         }
 
-        /// <summary>
-        /// Given a list of configuration IDs, returns the id of the config with the greatest number of immediate references.
-        /// </summary>
-        /// <param name="configsToSchedule">The set of configurations to consider.</param>
-        /// <returns>The id of the configuration with the most immediate references.</returns>
-        public int GetConfigWithGreatestNumberOfReferences(IEnumerable<int> configsToSchedule)
-        {
-            return GetConfigWithComparison(configsToSchedule, delegate (PlanConfigData left, PlanConfigData right) { return Comparer<int>.Default.Compare(left.ReferencesCount, right.ReferencesCount); });
-        }
-
-        /// <summary>
-        /// Given a list of real configuration IDs, returns the id of the config with the largest plan time.
-        /// </summary>
-        public int GetConfigWithGreatestPlanTime(IEnumerable<int> realConfigsToSchedule)
-        {
-            return GetConfigWithComparison(realConfigsToSchedule, delegate (PlanConfigData left, PlanConfigData right) { return Comparer<double>.Default.Compare(left.TotalPlanTime, right.TotalPlanTime); });
-        }
-
-        /// <summary>
-        /// Determines how many references a config with a particular path has.
-        /// </summary>
-        public int GetReferencesCountForConfigByPath(string configFullPath)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configFullPath, out data))
-            {
-                return 0;
-            }
-
-            return data.ReferencesCount;
-        }
-
-        /// <summary>
-        /// Advances the state of the plan by removing the specified config from all paths
-        /// </summary>
-        public void VisitConfig(string configName)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configName, out data))
-            {
-                return;
-            }
-
-            // UNDONE: Parallelize
-            foreach (List<Stack<PlanConfigData>> paths in _configIdToPaths.Values)
-            {
-                foreach (Stack<PlanConfigData> path in paths)
-                {
-                    if (path.Count > 0 && path.Peek() == data)
-                    {
-                        path.Pop();
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Advances the state of the plan by zeroing out the time spend on the config.
-        /// </summary>
-        public void CompleteConfig(string configName)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configName, out data))
-            {
-                return;
-            }
-
-            ErrorUtilities.VerifyThrow(data.AccumulatedTimeOfReferences < 0.00001, "Unexpected config completed before references were completed.");
-
-            // Recursively subtract the amount of time from this config's referrers.
-            data.RecursivelyApplyReferenceTimeToReferrers(-data.AccumulatedTime);
-            data.AccumulatedTime = 0;
-        }
-
         /// <summary>
         /// Gets the name of the plan file for a specified submission.
         /// </summary>
@@ -279,39 +211,6 @@ private string GetPlanName(SchedulableRequest rootRequest)
             return _configCache[rootRequest.BuildRequest.ConfigurationId].ProjectFullPath + ".buildplan";
         }
 
-        /// <summary>
-        /// Returns the config id with the greatest value according to the comparer.
-        /// </summary>
-        private int GetConfigWithComparison(IEnumerable<int> realConfigsToSchedule, Comparison<PlanConfigData> comparer)
-        {
-            PlanConfigData bestConfig = null;
-            int bestRealConfigId = BuildRequestConfiguration.InvalidConfigurationId;
-
-            foreach (int realConfigId in realConfigsToSchedule)
-            {
-                PlanConfigData configToConsider;
-                if (!_configPathToData.TryGetValue(_configCache[realConfigId].ProjectFullPath, out configToConsider))
-                {
-                    // By default we assume configs we don't know about aren't as important, and will only schedule them
-                    // if nothing else is suitable
-                    if (bestRealConfigId == BuildRequestConfiguration.InvalidConfigurationId)
-                    {
-                        bestRealConfigId = realConfigId;
-                    }
-
-                    continue;
-                }
-
-                if (bestConfig == null || (comparer(bestConfig, configToConsider) < 0))
-                {
-                    bestConfig = configToConsider;
-                    bestRealConfigId = realConfigId;
-                }
-            }
-
-            return bestRealConfigId;
-        }
-
         /// <summary>
         /// Analyzes the plan data which has been read.
         /// </summary>
@@ -334,12 +233,12 @@ private void AnalyzeData()
         /// </summary>
         private void DetermineConfigsWithGreatestPlanTime()
         {
-            List<int> projectsInOrderOfTotalPlanTime = new List<int>(_configIdToData.Keys);
-            projectsInOrderOfTotalPlanTime.Sort(delegate (int left, int right) { return -Comparer<double>.Default.Compare(_configIdToData[left].TotalPlanTime, _configIdToData[right].TotalPlanTime); });
-            foreach (int configId in projectsInOrderOfTotalPlanTime)
+            List<KeyValuePair<int, PlanConfigData>> projectsInOrderOfTotalPlanTime = new(_configIdToData);
+            projectsInOrderOfTotalPlanTime.Sort((left, right) => Comparer<double>.Default.Compare(right.Value.TotalPlanTime, left.Value.TotalPlanTime));
+            foreach (KeyValuePair<int, PlanConfigData> configuration in projectsInOrderOfTotalPlanTime)
             {
-                PlanConfigData config = _configIdToData[configId];
-                Console.WriteLine("{0}: {1} ({2} referrers) {3}", configId, config.TotalPlanTime, config.ReferrerCount, config.ConfigFullPath);
+                PlanConfigData config = configuration.Value;
+                Console.WriteLine("{0}: {1} ({2} referrers) {3}", configuration.Key, config.TotalPlanTime, config.ReferrerCount, config.ConfigFullPath);
                 foreach (PlanConfigData referrer in config.Referrers)
                 {
                     Console.WriteLine("     {0} {1}", referrer.ConfigId, referrer.ConfigFullPath);
@@ -357,11 +256,11 @@ private void DetermineConfigsWithGreatestPlanTime()
         private void DetermineConfigsWithTheMostImmediateReferences()
         {
             Console.WriteLine("Projects with the most immediate children:");
-            List<int> projectsInOrderOfImmediateChildCount = new List<int>(_configIdToData.Keys);
-            projectsInOrderOfImmediateChildCount.Sort(delegate (int left, int right) { return -Comparer<int>.Default.Compare(_configIdToData[left].ReferencesCount, _configIdToData[right].ReferencesCount); });
-            foreach (int configId in projectsInOrderOfImmediateChildCount)
+            List<KeyValuePair<int, PlanConfigData>> projectsInOrderOfImmediateChildCount = new(_configIdToData);
+            projectsInOrderOfImmediateChildCount.Sort((left, right) => Comparer<int>.Default.Compare(right.Value.ReferencesCount, left.Value.ReferencesCount));
+            foreach (KeyValuePair<int, PlanConfigData> configuration in projectsInOrderOfImmediateChildCount)
             {
-                Console.WriteLine("{0}: {1} {2}", configId, _configIdToData[configId].ReferencesCount, _configIdToData[configId].ConfigFullPath);
+                Console.WriteLine("{0}: {1} {2}", configuration.Key, configuration.Value.ReferencesCount, configuration.Value.ConfigFullPath);
             }
 
             Console.WriteLine();
@@ -577,7 +476,7 @@ private void RecursiveAccumulateConfigurationTimes(SchedulableRequest request, D
         /// <summary>
         /// The data associated with a config as read from a build plan.
         /// </summary>
-        private class PlanConfigData
+        internal class PlanConfigData
         {
             /// <summary>
             /// The configuration id.
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 8b5f572381a..a684c59618a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -317,13 +317,12 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
 
                 SdkResultFactory resultFactory = new SdkResultFactory(sdk);
 
-                SdkResult result;
+                SdkResult result = null;
 
                 try
                 {
                     MSBuildEventSource.Log.SdkResolverResolveSdkStart();
                     result = (SdkResult)sdkResolver.Resolve(sdk, context, resultFactory);
-                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath, projectPath, result?.Path, result?.Success ?? false);
                 }
                 catch (Exception e) when ((e is FileNotFoundException || e is FileLoadException) && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal))
                 {
@@ -339,6 +338,10 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
                     // The SDK resolver "{0}" failed while attempting to resolve the SDK "{1}": {2}
                     throw new SdkResolverException("SDKResolverFailed", sdkResolver, sdk, e, sdkResolver.Name, sdk.ToString(), e.ToString());
                 }
+                finally
+                {
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath, projectPath, result?.Path, result?.Success ?? false);
+                }
 
                 SetResolverState(submissionId, sdkResolver, context.State);
 
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index ca443451880..149ec426518 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -598,9 +598,9 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)
         /// </summary>
         internal void CacheIfPossible()
         {
-            foreach (string target in _resultsByTarget.Keys)
+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget)
             {
-                _resultsByTarget[target].CacheItems(ConfigurationId, target);
+                targetResultPair.Value.CacheItems(ConfigurationId, targetResultPair.Key);
             }
         }
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 3cca122ba99..69da00e3955 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
+using System.Linq;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
@@ -123,7 +124,7 @@ internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
         private List<TaskItem> _remotedTaskItems;
 
         /// <summary>
-        /// We need access to the build component host so that we can get at the 
+        /// We need access to the build component host so that we can get at the
         /// task host node provider when running a task wrapped by TaskHostTask
         /// </summary>
         private readonly IBuildComponentHost _buildComponentHost;
@@ -818,15 +819,15 @@ private string[] GetValueOutputs(TaskPropertyInfo parameter)
         /// 2) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by exact name and task identity parameters
         /// 3) checks the tasks declared by the project, searching by fuzzy match (missing namespace, etc.) and task identity parameters
         /// 4) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by fuzzy match (missing namespace, etc.) and task identity parameters
-        /// 5) 1-4 again in order without the task identity parameters, to gather additional information for the user (if the task identity 
-        ///    parameters don't match, it is an error, but at least we can return them a more useful error in this case than just "could not 
+        /// 5) 1-4 again in order without the task identity parameters, to gather additional information for the user (if the task identity
+        ///    parameters don't match, it is an error, but at least we can return them a more useful error in this case than just "could not
         ///    find task")
-        /// 
+        ///
         /// The search ordering is meant to reduce the number of assemblies we scan, because loading assemblies can be expensive.
         /// The tasks and assemblies declared by the project are scanned first, on the assumption that if the project declared
         /// them, they are likely used.
-        /// 
-        /// If the set of task identity parameters are defined, only tasks that match that identity are chosen. 
+        ///
+        /// If the set of task identity parameters are defined, only tasks that match that identity are chosen.
         /// </summary>
         /// <returns>The Type of the task, or null if it was not found.</returns>
         private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskIdentityParameters)
@@ -879,7 +880,7 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
                                 taskRuntime ?? XMakeAttributes.MSBuildRuntimeValues.any,
                                 taskArchitecture ?? XMakeAttributes.MSBuildArchitectureValues.any);
 
-                        // if we've logged this error, even though we've found something, we want to act like we didn't.  
+                        // if we've logged this error, even though we've found something, we want to act like we didn't.
                         return null;
                     }
                 }
@@ -1245,8 +1246,8 @@ private bool InitializeTaskVectorParameter(
             bool success;
             IList<TaskItem> finalTaskItems = _batchBucket.Expander.ExpandIntoTaskItemsLeaveEscaped(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
 
-            // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required 
-            // parameter, in which case we made an explicit decision to pass in an empty array.  This is 
+            // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required
+            // parameter, in which case we made an explicit decision to pass in an empty array.  This is
             // to avoid project authors having to add Conditions on all their tasks to avoid calling them
             // when a particular item list is empty.  This way, we just call the task with an empty list,
             // the task will loop over an empty list, and return quickly.
@@ -1372,7 +1373,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
 
                             if (outputAsProjectItem != null)
                             {
-                                // The common case -- all items involved are Microsoft.Build.Execution.ProjectItemInstance.TaskItems.  
+                                // The common case -- all items involved are Microsoft.Build.Execution.ProjectItemInstance.TaskItems.
                                 // Furthermore, because that is true, we know by definition that they also implement ITaskItem2.
                                 newItem = new ProjectItemInstance(_projectInstance, outputTargetName, outputAsProjectItem.IncludeEscaped, parameterLocationEscaped);
 
@@ -1382,25 +1383,21 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                             {
                                 if (output is ITaskItem2 outputAsITaskItem2)
                                 {
-                                    // Probably a Microsoft.Build.Utilities.TaskItem.  Not quite as good, but we can still preserve escaping. 
+                                    // Probably a Microsoft.Build.Utilities.TaskItem.  Not quite as good, but we can still preserve escaping.
                                     newItem = new ProjectItemInstance(_projectInstance, outputTargetName, outputAsITaskItem2.EvaluatedIncludeEscaped, parameterLocationEscaped);
 
-                                    // It would be nice to be copy-on-write here, but Utilities.TaskItem doesn't know about CopyOnWritePropertyDictionary. 
-                                    foreach (DictionaryEntry entry in outputAsITaskItem2.CloneCustomMetadataEscaped())
-                                    {
-                                        newItem.SetMetadataOnTaskOutput((string)entry.Key, (string)entry.Value);
-                                    }
+                                    // It would be nice to be copy-on-write here, but Utilities.TaskItem doesn't know about CopyOnWritePropertyDictionary.
+                                    newItem.SetMetadataOnTaskOutput(outputAsITaskItem2.CloneCustomMetadataEscaped().Cast<KeyValuePair<string, string>>());
                                 }
                                 else
                                 {
-                                    // Not a ProjectItemInstance.TaskItem or even a ITaskItem2, so we have to fake it.  
-                                    // Setting an item spec expects the escaped value, as does setting metadata. 
+                                    // Not a ProjectItemInstance.TaskItem or even a ITaskItem2, so we have to fake it.
+                                    // Setting an item spec expects the escaped value, as does setting metadata.
                                     newItem = new ProjectItemInstance(_projectInstance, outputTargetName, EscapingUtilities.Escape(output.ItemSpec), parameterLocationEscaped);
 
-                                    foreach (DictionaryEntry entry in output.CloneCustomMetadata())
-                                    {
-                                        newItem.SetMetadataOnTaskOutput((string)entry.Key, EscapingUtilities.Escape((string)entry.Value));
-                                    }
+                                    newItem.SetMetadataOnTaskOutput(output.CloneCustomMetadata()
+                                        .Cast<KeyValuePair<string, string>>()
+                                        .Select(x => new KeyValuePair<string, string>(x.Key, EscapingUtilities.Escape(x.Value))));
                                 }
                             }
 
@@ -1423,7 +1420,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                     // to store an ITaskItem array in a property, join all the item-specs with semi-colons to make the
                     // property value, and ignore/discard the attributes on the ITaskItems.
                     //
-                    // An empty ITaskItem[] should create a blank value property, for compatibility.                 
+                    // An empty ITaskItem[] should create a blank value property, for compatibility.
                     StringBuilder joinedOutputs = (outputs.Length == 0) ? new StringBuilder() : null;
 
                     foreach (ITaskItem output in outputs)
@@ -1468,7 +1465,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
         /// </summary>
         private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, string[] outputs, ElementLocation parameterLocation, TaskPropertyInfo parameter)
         {
-            // if the task has generated outputs (if it didn't, don't do anything)            
+            // if the task has generated outputs (if it didn't, don't do anything)
             if (outputs != null)
             {
                 if (outputTargetIsItem)
@@ -1499,7 +1496,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                     // to store an object array in a property, join all the string representations of the objects with
                     // semi-colons to make the property value
                     //
-                    // An empty ITaskItem[] should create a blank value property, for compatibility.                 
+                    // An empty ITaskItem[] should create a blank value property, for compatibility.
                     StringBuilder joinedOutputs = (outputs.Length == 0) ? new StringBuilder() : null;
 
                     foreach (string output in outputs)
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 02b2bc09e15..1e11e628e65 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -247,7 +247,7 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
             };
             using (XmlWriter xw = XmlWriter.Create(solutionConfigurationContents, settings))
             {
-                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
+                // TODO: Consider augmenting SolutionConfiguration with this code
                 xw.WriteStartElement("SolutionConfiguration");
 
                 // add a project configuration entry for each project in the solution
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index c3df653db94..7db7747eea1 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -257,12 +257,12 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -273,7 +273,7 @@ private Project(ProjectRootElement xml, IDictionary<string, string> globalProper
             implementation = defaultImplementation;
 
             _directoryCacheFactory = directoryCacheFactory;
-            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
         }
 
         /// <summary>
@@ -351,12 +351,12 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -367,7 +367,7 @@ private Project(XmlReader xmlReader, IDictionary<string, string> globalPropertie
             implementation = defaultImplementation;
 
             _directoryCacheFactory = directoryCacheFactory;
-            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
         }
 
         /// <summary>
@@ -447,12 +447,12 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -469,7 +469,7 @@ private Project(string projectFile, IDictionary<string, string> globalProperties
             // seems the XmlReader based one should also clean the same way.
             try
             {
-                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
             }
             catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
             {
@@ -500,7 +500,8 @@ public static Project FromFile(string file, ProjectOptions options)
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -518,7 +519,8 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -536,7 +538,8 @@ public static Project FromXmlReader(XmlReader reader, ProjectOptions options)
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -1871,6 +1874,11 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// </summary>
             private RenameHandlerDelegate _renameHandler;
 
+            /// <summary>
+            /// Indicates if the process of loading the project is allowed to interact with the user.
+            /// </summary>
+            private bool _interactive = false;
+
             /// <summary>
             ///
             /// </summary>
@@ -3733,7 +3741,8 @@ private void Reevaluate(
                     s_buildEventContext,
                     evaluationContext.SdkResolverService,
                     BuildEventContext.InvalidSubmissionId,
-                    evaluationContext);
+                    evaluationContext,
+                    _interactive);
 
                 ErrorUtilities.VerifyThrow(LastEvaluationId != BuildEventContext.InvalidEvaluationId, "Evaluation should produce an evaluation ID");
 
@@ -3766,7 +3775,7 @@ private void Reevaluate(
             /// Global properties may be null.
             /// Tools version may be null.
             /// </summary>
-            internal void Initialize(IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+            internal void Initialize(IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext, bool interactive)
             {
                 Xml.MarkAsExplicitlyLoaded();
 
@@ -3801,6 +3810,7 @@ internal void Initialize(IDictionary<string, string> globalProperties, string to
                 _data = new Data(Owner, globalPropertiesCollection, toolsVersion, subToolsetVersion, canEvaluateElementsWithFalseConditions);
 
                 _loadSettings = loadSettings;
+                _interactive = interactive;
 
                 ErrorUtilities.VerifyThrow(LastEvaluationId == BuildEventContext.InvalidEvaluationId, "This is the first evaluation therefore the last evaluation id is invalid");
 
diff --git a/src/Build/Definition/ProjectOptions.cs b/src/Build/Definition/ProjectOptions.cs
index 5c5e3cee3f9..c03507b3d3c 100644
--- a/src/Build/Definition/ProjectOptions.cs
+++ b/src/Build/Definition/ProjectOptions.cs
@@ -31,7 +31,7 @@ public class ProjectOptions
         public string SubToolsetVersion { get; set; }
 
         /// <summary>
-        /// The <see cref="ProjectCollection"/> the project is added to. Default is <see cref="ProjectCollection.GlobalProjectCollection"/>/>
+        /// The <see cref="ProjectCollection"/> the project is added to. Default is <see cref="ProjectCollection.GlobalProjectCollection"/>.
         /// </summary>
         public ProjectCollection ProjectCollection { get; set; }
 
@@ -49,5 +49,10 @@ public class ProjectOptions
         /// Provides <see cref="IDirectoryCache"/> to be used for evaluation.
         /// </summary>
         public IDirectoryCacheFactory DirectoryCacheFactory { get; set; }
+
+        /// <summary>
+        /// Gets or sets a value indicating if loading the project is allowed to interact with the user.
+        /// </summary>
+        public bool Interactive { get; set; }
     }
 }
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 5e3147ec52f..c76c6a47780 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1946,11 +1946,16 @@ internal static bool ExpandExpressionCapture<S>(
                 // If there are no items of the given type, then bail out early
                 if (itemsOfType.Count == 0)
                 {
-                    // .. but only if there isn't a function "Count()", since that will want to return something (zero) for an empty list
+                    // ... but only if there isn't a function "Count", since that will want to return something (zero) for an empty list
                     if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)) != true)
                     {
-                        itemsFromCapture = new List<Pair<string, S>>();
-                        return false;
+                        // ...or a function "AnyHaveMetadataValue", since that will want to return false for an empty list.
+                        if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
+                            expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
+                        {
+                            itemsFromCapture = new List<Pair<string, S>>();
+                            return false;
+                        }
                     }
                 }
 
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 49e921d8160..3303e62a056 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -2,13 +2,16 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Xml;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
@@ -88,11 +91,30 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
 
 #if DEBUG
         /// <summary>
-        /// Number of entries into Get function of the ProjectRootElementCache.
-        /// Shall be always 0 or 1. Reentrance to the Get function (value > 1) could lead to race condition.
+        /// A simple IDisposable struct implementing the holder/guard pattern over the Get reentrancy counter.
         /// </summary>
-        [ThreadStatic]
-        private static int s_getEntriesNumber = 0;
+        private struct ReentrancyGuard : IDisposable
+        {
+            /// <summary>
+            /// Number of entries into Get function of the ProjectRootElementCache.
+            /// Shall be always 0 or 1. Reentrance to the Get function (value > 1) could lead to race condition.
+            /// </summary>
+            [ThreadStatic]
+            private static int s_getEntriesNumber = 0;
+
+            public ReentrancyGuard()
+            {
+                s_getEntriesNumber++;
+                ErrorUtilities.VerifyThrow(
+                    s_getEntriesNumber == 1,
+                    "Reentrance to the ProjectRootElementCache.Get function detected.");
+            }
+
+            public void Dispose()
+            {
+                s_getEntriesNumber--;
+            }
+        }
 #endif
 
         /// <summary>
@@ -104,6 +126,11 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// </remarks>
         private WeakValueDictionary<string, ProjectRootElement> _weakCache;
 
+        /// <summary>
+        /// Lock objects keyed by project file path.
+        /// </summary>
+        private ConcurrentDictionary<string, object> _fileLoadLocks;
+
         /// <summary>
         /// The list of strongly-held ProjectRootElement's
         /// </summary>
@@ -119,7 +146,7 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// <summary>
         /// Locking object for this shared cache
         /// </summary>
-        private Object _locker = new Object();
+        private object _locker = new object();
 
         /// <summary>
         /// Creates an empty cache.
@@ -130,6 +157,7 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
 
             _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
             _strongCache = new LinkedList<ProjectRootElement>();
+            _fileLoadLocks = new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase);
             _autoReloadFromDisk = autoReloadFromDisk;
             LoadProjectsReadOnly = loadProjectsReadOnly;
         }
@@ -140,45 +168,57 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
         /// </summary>
         private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)
         {
-            if (projectRootElement != null && _autoReloadFromDisk)
+            // When we do not _autoReloadFromDisk we expect that cached value is always valid.
+            // Usually lifespan of cache is expected to be build duration (process will terminate after build).
+            if (projectRootElement == null || !_autoReloadFromDisk)
             {
-                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);
+                return false;
+            }
 
-                // If the file doesn't exist on disk, go ahead and use the cached version.
-                // It's an in-memory project that hasn't been saved yet.
-                if (fileInfo != null)
-                {
-                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)
-                    {
-                        // File was changed on disk by external means. Cached version is no longer valid.
-                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file
-                        // externally and load a new project over it to see the new content. So we dump it from the cache
-                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,
-                        // but clients ought not get themselves into such a state - and unless they save them to disk,
-                        // it may not be a problem.
-                        return true;
-                    }
-                    else if (s_ÑheckFileContent)
-                    {
-                        // QA tests run too fast for the timestamp check to work. This environment variable is for their
-                        // use: it checks the file content as well as the timestamp. That's better than completely disabling
-                        // the cache as we get test coverage of the rest of the cache code.
-                        XmlDocument document = new XmlDocument();
-                        document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;
+            // If the project file is non modifiable, assume it is up to date and consider the cached value valid.
+            if (!Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck && FileClassifier.Shared.IsNonModifiable(projectFile))
+            {
+                return false;
+            }
 
-                        using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))
-                        {
-                            document.Load(xtr.Reader);
-                        }
+            FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);
+
+            // If the file doesn't exist on disk, go ahead and use the cached version.
+            // It's an in-memory project that hasn't been saved yet.
+            if (fileInfo == null)
+            {
+                return false;
+            }
 
-                        string diskContent = document.OuterXml;
-                        string cacheContent = projectRootElement.XmlDocument.OuterXml;
+            if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)
+            {
+                // File was changed on disk by external means. Cached version is no longer valid.
+                // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file
+                // externally and load a new project over it to see the new content. So we dump it from the cache
+                // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,
+                // but clients ought not get themselves into such a state - and unless they save them to disk,
+                // it may not be a problem.
+                return true;
+            }
+            else if (s_ÑheckFileContent)
+            {
+                // QA tests run too fast for the timestamp check to work. This environment variable is for their
+                // use: it checks the file content as well as the timestamp. That's better than completely disabling
+                // the cache as we get test coverage of the rest of the cache code.
+                XmlDocument document = new XmlDocument();
+                document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;
 
-                        if (diskContent != cacheContent)
-                        {
-                            return true;
-                        }
-                    }
+                using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))
+                {
+                    document.Load(xtr.Reader);
+                }
+
+                string diskContent = document.OuterXml;
+                string cacheContent = projectRootElement.XmlDocument.OuterXml;
+
+                if (diskContent != cacheContent)
+                {
+                    return true;
                 }
             }
 
@@ -211,106 +251,127 @@ internal override ProjectRootElement Get(string projectFile, OpenProjectRootElem
         {
 #if DEBUG
             // Verify that loadProjectRootElement delegate does not call ProjectRootElementCache.Get().
-            s_getEntriesNumber++;
+            using var reentrancyGuard = new ReentrancyGuard();
+
+            // Verify that we never call this with _locker held, as that would create a lock ordering inversion with the per-file lock.
             ErrorUtilities.VerifyThrow(
-                s_getEntriesNumber == 1,
-                "Reentrance to the ProjectRootElementCache.Get function detected.");
+                !System.Threading.Monitor.IsEntered(_locker),
+                "Detected lock ordering inversion in ProjectRootElementCache.");
+#endif
+            // Should already have been canonicalized
+            ErrorUtilities.VerifyThrowInternalRooted(projectFile);
 
-            try
+            // First try getting the ProjectRootElement from the cache.
+            ProjectRootElement projectRootElement = GetOrLoad(projectFile, loadProjectRootElement: null, isExplicitlyLoaded, preserveFormatting);
+
+            if (projectRootElement != null || loadProjectRootElement == null)
             {
-#endif
-#pragma warning disable format // the release configuration fails as try-catch block is conditioned only for Debug; making the formatting in correct in Release.
-                // Should already have been canonicalized
-                ErrorUtilities.VerifyThrowInternalRooted(projectFile);
+                // If we found it or no load callback was specified, we are done.
+                return projectRootElement;
+            }
 
-                ProjectRootElement projectRootElement;
-                lock (_locker)
+            try
+            {
+                // We are about to load. Take a per-file lock to prevent multiple threads from duplicating the work multiple times.
+                object perFileLock = _fileLoadLocks.GetOrAdd(projectFile, () => new object());
+                lock (perFileLock)
                 {
-                    _weakCache.TryGetValue(projectFile, out projectRootElement);
+                    // Call GetOrLoad again, this time with the OpenProjectRootElement callback.
+                    return GetOrLoad(projectFile, loadProjectRootElement, isExplicitlyLoaded, preserveFormatting);
+                }
+            }
+            finally
+            {
+                // Remove the lock object as we have otherwise no good way of preventing _fileLoadLocks from growing unboundedly.
+                // If another thread is inside the lock, we effectively create a race condition where someone else may enter
+                // GetOrLoad. This is OK because this fine-grained locking is just a perf optimization, and we have either loaded
+                // the ProjectRootElement by now, or it is an error condition where perf is not critical.
+                _fileLoadLocks.TryRemove(projectFile, out _);
+            }
+        }
 
-                    if (projectRootElement != null)
-                    {
-                        BoostEntryInStrongCache(projectRootElement);
+        /// <summary>
+        /// A helper used by <see cref="Get"/>.
+        /// </summary>
+        private ProjectRootElement GetOrLoad(string projectFile, OpenProjectRootElement loadProjectRootElement, bool isExplicitlyLoaded,
+            bool? preserveFormatting)
+        {
+            ProjectRootElement projectRootElement;
+            lock (_locker)
+            {
+                _weakCache.TryGetValue(projectFile, out projectRootElement);
 
-                        // An implicit load will never reset the explicit flag.
-                        if (isExplicitlyLoaded)
-                        {
-                            projectRootElement.MarkAsExplicitlyLoaded();
-                        }
-                    }
-                    else
-                    {
-                        DebugTraceCache("Not found in cache: ", projectFile);
-                    }
+                if (projectRootElement != null)
+                {
+                    BoostEntryInStrongCache(projectRootElement);
 
-                    if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
+                    // An implicit load will never reset the explicit flag.
+                    if (isExplicitlyLoaded)
                     {
-                        // Cached project doesn't match preserveFormatting setting, so reload it
-                        projectRootElement.Reload(true, preserveFormatting);
+                        projectRootElement.MarkAsExplicitlyLoaded();
                     }
                 }
-
-                bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);
-                if (projectRootElementIsInvalid)
+                else
                 {
-                    DebugTraceCache("Not satisfied from cache: ", projectFile);
-                    ForgetEntryIfExists(projectRootElement);
+                    DebugTraceCache("Not found in cache: ", projectFile);
                 }
 
-                if (loadProjectRootElement == null)
+                if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
                 {
-                    if (projectRootElement == null || projectRootElementIsInvalid)
-                    {
-                        return null;
-                    }
-                    else
-                    {
-                        DebugTraceCache("Satisfied from XML cache: ", projectFile);
-                        return projectRootElement;
-                    }
+                    // Cached project doesn't match preserveFormatting setting, so reload it
+                    projectRootElement.Reload(true, preserveFormatting);
                 }
+            }
+
+            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);
+            if (projectRootElementIsInvalid)
+            {
+                DebugTraceCache("Not satisfied from cache: ", projectFile);
+                ForgetEntryIfExists(projectRootElement);
+            }
 
-                // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.
+            if (loadProjectRootElement == null)
+            {
                 if (projectRootElement == null || projectRootElementIsInvalid)
                 {
-                    // We do not lock loading with common _locker of the cache, to avoid lock contention.
-                    // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as
-                    // it is not likely that two threads would use Get function for the same project simultaneously and it is not a big deal if in some cases we load the same project twice.
-
-                    projectRootElement = loadProjectRootElement(projectFile, this);
-                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
-                    ErrorUtilities.VerifyThrow(
-                        projectRootElement.FullPath.Equals(projectFile, StringComparison.OrdinalIgnoreCase),
-                        "Got project back with incorrect path. Expected path: {0}, received path: {1}.",
-                        projectFile,
-                        projectRootElement.FullPath);
-
-                    // An implicit load will never reset the explicit flag.
-                    if (isExplicitlyLoaded)
-                    {
-                        projectRootElement.MarkAsExplicitlyLoaded();
-                    }
-
-                    // Update cache element.
-                    // It is unlikely, but it might be that while without the lock, the projectRootElement in cache was updated by another thread.
-                    // And here its entry will be replaced with the loaded projectRootElement. This is fine:
-                    // if loaded projectRootElement is out of date (so, it changed since the time we loaded it), it will be updated the next time some thread calls Get function.
-                    AddEntry(projectRootElement);
+                    return null;
                 }
                 else
                 {
                     DebugTraceCache("Satisfied from XML cache: ", projectFile);
+                    return projectRootElement;
                 }
+            }
 
-                return projectRootElement;
-#pragma warning restore format
-#if DEBUG
+            // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.
+            if (projectRootElement == null || projectRootElementIsInvalid)
+            {
+                projectRootElement = loadProjectRootElement(projectFile, this);
+                ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
+                ErrorUtilities.VerifyThrow(
+                    projectRootElement.FullPath.Equals(projectFile, StringComparison.OrdinalIgnoreCase),
+                    "Got project back with incorrect path. Expected path: {0}, received path: {1}.",
+                    projectFile,
+                    projectRootElement.FullPath);
+
+                // An implicit load will never reset the explicit flag.
+                if (isExplicitlyLoaded)
+                {
+                    projectRootElement.MarkAsExplicitlyLoaded();
+                }
+
+                // Update cache element.
+                // It is unlikely, but it might be that while without the lock, the projectRootElement in cache was updated by another thread.
+                // And here its entry will be replaced with the loaded projectRootElement. This is fine:
+                // if loaded projectRootElement is out of date (so, it changed since the time we loaded it), it will be updated the next time some thread calls Get function.
+                AddEntry(projectRootElement);
             }
-            finally
+            else
             {
-                s_getEntriesNumber--;
+                DebugTraceCache("Satisfied from XML cache: ", projectFile);
             }
-#endif
+
+            return projectRootElement;
         }
 
         /// <summary>
@@ -398,13 +459,44 @@ internal override void Clear()
         {
             lock (_locker)
             {
-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
-                _strongCache = new LinkedList<ProjectRootElement>();
+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)
+                {
+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
+                    _strongCache = new LinkedList<ProjectRootElement>();
 
-                foreach (ProjectRootElement projectRootElement in oldStrongCache)
+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)
+                    {
+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
+                    }
+                }
+                else
                 {
-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
+                    // Manually iterate through LinkedList so we can remove items during this iteration
+                    for (var listNode = _strongCache.First; listNode != null;)
+                    {
+                        var nextNode = listNode.Next;
+
+                        ProjectRootElement projectRootElement = listNode.Value;
+                        // Do not remove cache of files from immutable locations.
+                        // Those are mostly SDK project files and will be most probably needed in next builds.
+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))
+                        {
+                            _weakCache.Remove(projectRootElement.FullPath);
+                            _strongCache.Remove(listNode);
+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
+                        }
+
+                        listNode = nextNode;
+                    }
+
+                    // From weak list remove all which is not in strong list anymore
+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();
+                    foreach (string victim in toBeRemovedFromWeakRefs)
+                    {
+                        _weakCache.Remove(victim);
+                    }
+                    _weakCache.Scavenge();
                 }
             }
         }
@@ -511,7 +603,7 @@ private void RenameEntryInternal(string oldFullPathIfAny, ProjectRootElement pro
             ProjectRootElement existingWeakEntry;
             _weakCache.TryGetValue(projectRootElement.FullPath, out existingWeakEntry);
 
-            if (existingWeakEntry != null && !Object.ReferenceEquals(existingWeakEntry, projectRootElement))
+            if (existingWeakEntry != null && !object.ReferenceEquals(existingWeakEntry, projectRootElement))
             {
                 _strongCache.Remove(existingWeakEntry);
                 RaiseProjectRootElementRemovedFromStrongCache(existingWeakEntry);
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index fa1642fb36b..23b0fc15ad9 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -33,6 +33,7 @@ internal sealed class ProjectInterpretation
         private const string PlatformMetadataName = "Platform";
         private const string PlatformsMetadataName = "Platforms";
         private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
+        private const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -119,7 +120,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
 
                 var projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
 
-                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)), globalPropertiesModifiers);
 
                 var requesterPlatform = "";
                 var requesterPlatformLookupTable = "";
@@ -134,7 +135,9 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                         null, // Platform negotiation requires an evaluation with no global properties first
                         _projectCollection);
 
-                    var selectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), requesterInstance.GetPropertyValue(PlatformLookupTableMetadataName), projectInstance.FullPath, requesterInstance.GetPropertyValue(PlatformMetadataName));
+                    string overridePlatformNegotiationMetadataValue = projectReferenceItem.GetMetadataValue(OverridePlatformNegotiationValue);
+
+                    var selectedPlatform = PlatformNegotiation.GetNearestPlatform(overridePlatformNegotiationMetadataValue, projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), requesterInstance.GetPropertyValue(PlatformLookupTableMetadataName), projectInstance.FullPath, requesterInstance.GetPropertyValue(PlatformMetadataName));
 
                     if (selectedPlatform.Equals(String.Empty))
                     {
@@ -324,6 +327,7 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
         private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(
             ProjectItemInstance projectReference,
             PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,
+            bool dynamicPlatformEnabled,
             IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers = null)
         {
             ErrorUtilities.VerifyThrowInternalNull(projectReference, nameof(projectReference));
@@ -337,7 +341,7 @@ private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesFo
 
             var globalPropertyParts = globalPropertyModifiers?.Aggregate(defaultParts, (currentProperties, modifier) => modifier(currentProperties, projectReference)) ?? defaultParts;
 
-            if (globalPropertyParts.AllEmpty())
+            if (globalPropertyParts.AllEmpty() && !dynamicPlatformEnabled)
             {
                 return requesterGlobalProperties;
             }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 763a09442b3..9a301afd793 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -241,7 +241,7 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
         {
         }
 
@@ -260,8 +260,9 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
+        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -270,7 +271,10 @@ private ProjectInstance(string projectFile, IDictionary<string, string> globalPr
             // passed a relative path, the caller assumes we will prepend the current directory.
             projectFile = FileUtilities.NormalizePath(projectFile);
 
-            BuildParameters buildParameters = new BuildParameters(projectCollection);
+            BuildParameters buildParameters = new BuildParameters(projectCollection)
+            {
+                Interactive = interactive
+            };
 
             BuildEventContext buildEventContext = new BuildEventContext(buildParameters.NodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, true /*Explicitly Loaded*/);
@@ -323,7 +327,7 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
         {
         }
 
@@ -395,11 +399,18 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
+        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
         {
             BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, new BuildParameters(projectCollection), projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
+
+            BuildParameters buildParameters = new BuildParameters(projectCollection)
+            {
+                Interactive = interactive
+            };
+
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, buildParameters, projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
         }
 
         /// <summary>
@@ -743,7 +754,8 @@ public static ProjectInstance FromFile(string file, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.Interactive);
         }
 
         /// <summary>
@@ -760,7 +772,8 @@ public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElem
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.Interactive);
         }
 
         /// <summary>
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 2d124f82d8d..9258eb5b33f 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -628,11 +628,11 @@ internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance>
         /// which legally have built-in metadata. If necessary we can calculate it on the new items we're making if requested.
         /// We don't copy them too because tasks shouldn't set them (they might become inconsistent)
         /// </summary>
-        internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
+        internal void SetMetadataOnTaskOutput(IEnumerable<KeyValuePair<string, string>> items)
         {
             _project.VerifyThrowNotImmutable();
 
-            _taskItem.SetMetadataOnTaskOutput(name, evaluatedValueEscaped);
+            _taskItem.SetMetadataOnTaskOutput(items);
         }
 
         /// <summary>
@@ -1489,8 +1489,8 @@ void ITranslatable.Translate(ITranslator translator)
             /// </summary>
             public override int GetHashCode()
             {
-                // This is ignore case to ensure that task items whose item specs differ only by 
-                // casing still have the same hash code, since this is used to determine if we have duplicates when 
+                // This is ignore case to ensure that task items whose item specs differ only by
+                // casing still have the same hash code, since this is used to determine if we have duplicates when
                 // we do duplicate removal.
                 return StringComparer.OrdinalIgnoreCase.GetHashCode(ItemSpec);
             }
@@ -1785,6 +1785,18 @@ internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
                 }
             }
 
+            internal void SetMetadataOnTaskOutput(IEnumerable<KeyValuePair<string, string>> items)
+            {
+                ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
+                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+
+                var metadata = items
+                    .Where(item => !FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(item.Key))
+                    .Select(item => new ProjectMetadataInstance(item.Key, item.Value, true /* may be built-in metadata name */));
+
+                _directMetadata.ImportProperties(metadata);
+            }
+
             /// <summary>
             /// Deep clone this into another TaskItem
             /// </summary>
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c2757e1ff4d..5525799a483 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -56,9 +56,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>SharedUtilities\EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\EnvironmentUtilities.cs">
       <Link>SharedUtilities\EnvironmentUtilities.cs</Link>
     </Compile>
@@ -126,6 +123,7 @@
       <Link>PlatformNegotiation.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\SolutionConfiguration.cs" />
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelper.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 278dbe4c739..482f271ba03 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznÃ¡n.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznÃ¡n.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 759cbf24118..35576a9f7af 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
+        <target state="translated">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 88c3b698231..3b491802de3 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
+        <target state="translated">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 2264173e816..fbbb2252b81 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: L'Ã©lÃ©ment "{0}" situÃ© sous l'Ã©lÃ©ment &lt;{1}&gt; n'est pas reconnu.</target>
+        <target state="translated">MSB4067: L'Ã©lÃ©ment "{0}" situÃ© sous l'Ã©lÃ©ment &lt;{1}&gt; n'est pas reconnu.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 4c5f37c1953..a3a5cb9eca1 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
+        <target state="translated">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 25261590068..e45710015a8 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: è¦ç´  &lt;{1}&gt; ã®ä¸‹ã®è¦ç´  &lt;{0}&gt; ã¯èªè­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</target>
+        <target state="translated">MSB4067: è¦ç´  &lt;{1}&gt; ã®ä¸‹ã®è¦ç´  &lt;{0}&gt; ã¯èªè­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index a315a48652f..78c2001194e 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; ìš”ì†Œ ì•„ëž˜ì˜ &lt;{0}&gt; ìš”ì†Œë¥¼ ì¸ì‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</target>
+        <target state="translated">MSB4067: &lt;{1}&gt; ìš”ì†Œ ì•„ëž˜ì˜ &lt;{0}&gt; ìš”ì†Œë¥¼ ì¸ì‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 00856a177e8..bcc1dad73ba 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; znajdujÄ…cy siÄ™ pod elementem &lt;{1}&gt; nie zostaÅ‚ rozpoznany.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; znajdujÄ…cy siÄ™ pod elementem &lt;{1}&gt; nie zostaÅ‚ rozpoznany.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index becfa993d0d..fcfbad3e5df 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; nÃ£o Ã© reconhecido.</target>
+        <target state="translated">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; nÃ£o Ã© reconhecido.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index abdf27bb687..3b33882791c 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Ð½ÐµÐ¾Ð¿Ð¾Ð·Ð½Ð°Ð½Ð½Ñ‹Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ &lt;{0}&gt; Ð² ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ðµ &lt;{1}&gt;.</target>
+        <target state="translated">MSB4067: Ð½ÐµÐ¾Ð¿Ð¾Ð·Ð½Ð°Ð½Ð½Ñ‹Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ &lt;{0}&gt; Ð² ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ðµ &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 023ad6274fd..8822dee74ae 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; Ã¶ÄŸesinin altÄ±ndaki &lt;{0}&gt; Ã¶ÄŸesi tanÄ±nmÄ±yor.</target>
+        <target state="translated">MSB4067: &lt;{1}&gt; Ã¶ÄŸesinin altÄ±ndaki &lt;{0}&gt; Ã¶ÄŸesi tanÄ±nmÄ±yor.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 400130f727e..198d36450b9 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: æ— æ³•è¯†åˆ«å…ƒç´  &lt;{1}&gt; ä¸‹é¢çš„å…ƒç´  &lt;{0}&gt;ã€‚</target>
+        <target state="translated">MSB4067: æ— æ³•è¯†åˆ«å…ƒç´  &lt;{1}&gt; ä¸‹é¢çš„å…ƒç´  &lt;{0}&gt;ã€‚</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 970cd8cd04f..201836b008e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -1851,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: ç„¡æ³•è¾¨èªé …ç›® &lt;{1}&gt; ä¸‹çš„é …ç›® &lt;{0}&gt;ã€‚</target>
+        <target state="translated">MSB4067: ç„¡æ³•è¾¨èªé …ç›® &lt;{1}&gt; ä¸‹çš„é …ç›® &lt;{0}&gt;ã€‚</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Shared/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
similarity index 97%
rename from src/Shared/EncodingUtilities.cs
rename to src/Framework/EncodingUtilities.cs
index b7d1813f368..9ad987bd730 100644
--- a/src/Shared/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -7,6 +7,8 @@
 using System.Linq;
 using System.Text;
 
+using Microsoft.Build.Framework;
+
 #nullable disable
 
 namespace Microsoft.Build.Shared
@@ -48,17 +50,17 @@ internal static Encoding CurrentSystemOemEncoding
 
                 try
                 {
-                    if (NativeMethodsShared.IsWindows)
+                    if (NativeMethods.IsWindows)
                     {
 #if RUNTIME_TYPE_NETCORE
                         Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
 #endif
                         // get the current OEM code page
-                        s_currentOemEncoding = Encoding.GetEncoding(NativeMethodsShared.GetOEMCP());
+                        s_currentOemEncoding = Encoding.GetEncoding(NativeMethods.GetOEMCP());
                     }
                 }
                 // theoretically, GetEncoding may throw an ArgumentException or a NotSupportedException. This should never
-                // really happen, since the code page we pass in has just been returned from the "underlying platform", 
+                // really happen, since the code page we pass in has just been returned from the "underlying platform",
                 // so it really should support it. If it ever happens, we'll just fall back to the default encoding.
                 // No point in showing any errors to the users, since they most likely wouldn't be actionable.
                 catch (ArgumentException ex)
@@ -214,7 +216,7 @@ internal static bool CanEncodeString(int codePage, string stringToEncode)
         /// </remarks>
         internal static Encoding BatchFileEncoding(string contents, string encodingSpecification)
         {
-            if (!NativeMethodsShared.IsWindows)
+            if (!NativeMethods.IsWindows)
             {
                 return EncodingUtilities.Utf8WithoutBom;
             }
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
index 9c4f18ea8ef..7dc7dbdaf86 100644
--- a/src/Framework/ITaskItemExtensions.cs
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -57,8 +57,7 @@ public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this I
                     Debug.Fail(e.ToString());
                 }
 
-                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);
-                i += 1;
+                list[i++] = new KeyValuePair<string, string>(metadataName, valueOrError);
             }
 
             return list;
diff --git a/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs b/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
index 818795fbe20..0a261bceaba 100644
--- a/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
+++ b/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using System.Windows.Markup;
 
 #nullable disable
@@ -41,16 +42,7 @@ public List<IProjectSchemaNode> Nodes
         [SuppressMessage("Microsoft.Usage", "CA2301:EmbeddableTypesInContainersRule", MessageId = "allTypes", Justification = "All object types come from within this assembly, so there will not be any type equivalence problems")]
         public IEnumerable<Type> GetSchemaObjectTypes()
         {
-            Dictionary<Type, bool> allTypes = new Dictionary<Type, bool>();
-            foreach (IProjectSchemaNode node in Nodes)
-            {
-                foreach (Type t in node.GetSchemaObjectTypes())
-                {
-                    allTypes[t] = true;
-                }
-            }
-
-            return allTypes.Keys;
+            return Nodes.SelectMany(node => node.GetSchemaObjectTypes()).Distinct();
         }
 
         /// <summary>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index e9991973cf6..3f2d3d8cee2 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -6173,5 +6173,11 @@ elementFormDefault="qualified">
       </xs:complexContent>
     </xs:complexType>
   </xs:element>
+  
+  <xs:element name="InvariantGlobalization" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:annotation>
+      <xs:documentation><!-- _locID_text="InvariantGlobalization" _locComment="" -->Indicates whether an app runs in globalization-invariant mode without access to culture-specific data and behavior.</xs:documentation>
+    </xs:annotation>
+  </xs:element>
 
 </xs:schema>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 31209200c7b..f1f7c3b7ffe 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -982,16 +982,16 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
 
             if (_updateEnvironment)
             {
-                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
+                foreach (KeyValuePair<string, KeyValuePair<string, string>> variable in s_mismatchedEnvironmentValues)
                 {
-                    string oldValue = s_mismatchedEnvironmentValues[variable].Key;
-                    string newValue = s_mismatchedEnvironmentValues[variable].Value;
+                    string oldValue = variable.Value.Key;
+                    string newValue = variable.Value.Value;
 
                     // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
-                    environment.TryGetValue(variable, out environmentValue);
+                    environment.TryGetValue(variable.Key, out environmentValue);
 
                     if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
                     {
@@ -1009,14 +1009,14 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
                         {
                             if (_updateEnvironmentAndLog)
                             {
-                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentVariable", variable, newValue, environmentValue ?? String.Empty);
+                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentVariable", variable.Key, newValue, environmentValue ?? String.Empty);
                             }
 
-                            updatedEnvironment[variable] = newValue;
+                            updatedEnvironment[variable.Key] = newValue;
                         }
                         else
                         {
-                            updatedEnvironment.Remove(variable);
+                            updatedEnvironment.Remove(variable.Key);
                         }
                     }
                 }
@@ -1045,35 +1045,32 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
 
             if (_updateEnvironment)
             {
-                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
+                foreach (KeyValuePair<string, KeyValuePair<string, string>> variable in s_mismatchedEnvironmentValues)
                 {
                     // Since this is munging the property list for returning to the parent process,
                     // then the value we wish to replace is the one that is in this process, and the
                     // replacement value is the one that originally came from the parent process,
                     // instead of the other way around.
-                    string oldValue = s_mismatchedEnvironmentValues[variable].Value;
-                    string newValue = s_mismatchedEnvironmentValues[variable].Key;
+                    string oldValue = variable.Value.Value;
+                    string newValue = variable.Value.Key;
 
                     // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
-                    environment.TryGetValue(variable, out environmentValue);
+                    environment.TryGetValue(variable.Key, out environmentValue);
 
                     if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
                     {
-                        if (updatedEnvironment == null)
-                        {
-                            updatedEnvironment = new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
-                        }
+                        updatedEnvironment ??= new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
 
                         if (newValue != null)
                         {
-                            updatedEnvironment[variable] = newValue;
+                            updatedEnvironment[variable.Key] = newValue;
                         }
                         else
                         {
-                            updatedEnvironment.Remove(variable);
+                            updatedEnvironment.Remove(variable.Key);
                         }
                     }
                 }
@@ -1106,36 +1103,36 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
                 // after the node is launched.
                 s_mismatchedEnvironmentValues = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.OrdinalIgnoreCase);
 
-                foreach (string variable in _savedEnvironment.Keys)
+                foreach (KeyValuePair<string, string> variable in _savedEnvironment)
                 {
-                    string oldValue = _savedEnvironment[variable];
+                    string oldValue = variable.Value;
                     string newValue;
-                    if (!environment.TryGetValue(variable, out newValue))
+                    if (!environment.TryGetValue(variable.Key, out newValue))
                     {
-                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(null, oldValue);
+                        s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(null, oldValue);
                     }
                     else
                     {
                         if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
                         {
-                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
+                            s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, oldValue);
                         }
                     }
                 }
 
-                foreach (string variable in environment.Keys)
+                foreach (KeyValuePair<string, string> variable in environment)
                 {
-                    string newValue = environment[variable];
+                    string newValue = variable.Value;
                     string oldValue;
-                    if (!_savedEnvironment.TryGetValue(variable, out oldValue))
+                    if (!_savedEnvironment.TryGetValue(variable.Key, out oldValue))
                     {
-                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, null);
+                        s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, null);
                     }
                     else
                     {
                         if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
                         {
-                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
+                            s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, oldValue);
                         }
                     }
                 }
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 5d678351dc0..e923426f326 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1348,6 +1348,9 @@
   <data name="MSBuildDebugPath" Visibility="Public">
     <value>MSBuild logs and debug information will be at "{0}"</value>
   </data>
+  <data name="DeferredResponseFile" Visibility="Public">
+    <value>Included response file: {0}</value>
+  </data>
   <data name="SwitchErrorWithArguments" Visibility="Public">
     <value>{0}
     Full command line: '{1}'
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 2240434f381..b4fbb8dcedd 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: PÅ™epÃ­naÄ -noAutoResponse nelze zadat v souboru automatickÃ½ch odpovÄ›dÃ­ MSBuild.rsp ani v Å¾Ã¡dnÃ©m jinÃ©m souboru odpovÄ›dÃ­, na kterÃ½ se v souboru automatickÃ½ch odpovÄ›dÃ­ odkazuje.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     ZpÅ¯sobÃ­, Å¾e MSBuild sestavÃ­ jednotlivÃ© projekty izolovanÄ›.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Jde o omezenÄ›jÅ¡Ã­ reÅ¾im nÃ¡stroje MSBuild, protoÅ¾e vyÅ¾aduje,
-                     aby byl graf projektu staticky zjistitelnÃ½ v okamÅ¾iku
-                     vyhodnocenÃ­, mÅ¯Å¾e ale vylepÅ¡it plÃ¡novÃ¡nÃ­ a snÃ­Å¾it
-                     reÅ¾ii pamÄ›ti pÅ™i sestavovÃ¡nÃ­ velkÃ© sady projektÅ¯.
-                     (KrÃ¡tkÃ½ tvar: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Tento pÅ™Ã­znak je experimentÃ¡lnÃ­ a nemusÃ­ fungovat tak, jak byl zamÃ½Å¡len.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -365,9 +379,9 @@
         <target state="translated">  @&lt;soubor&gt;            VloÅ¾enÃ­ nastavenÃ­ pÅ™Ã­kazovÃ©ho Å™Ã¡dku z textovÃ©ho souboru. Chcete-li zadat
                      vÃ­ce souborÅ¯ odpovÄ›dÃ­, uveÄte kaÅ¾dÃ½ soubor
                      odpovÄ›dÃ­ zvlÃ¡Å¡Å¥.
-
-                     Automaticky jsou pouÅ¾ity vÅ¡echny soubory s nÃ¡zvem msbuild.rsp
-                     nachÃ¡zejÃ­cÃ­ se v nÃ¡sledujÃ­cÃ­ch umÃ­stÄ›nÃ­ch:
+                     
+                     Automaticky jsou pouÅ¾ity vÅ¡echny soubory s nÃ¡zvem msbuild.rsp 
+                     nachÃ¡zejÃ­cÃ­ se v nÃ¡sledujÃ­cÃ­ch umÃ­stÄ›nÃ­ch: 
                      (1) adresÃ¡Å™ nÃ¡stroje msbuild.exe
                      (2) adresÃ¡Å™ prvnÃ­ho sestavenÃ©ho projektu nebo Å™eÅ¡enÃ­
 </target>
@@ -428,7 +442,7 @@
 </source>
         <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  NastavenÃ­ nebo potlaÄenÃ­ danÃ½ch vlastnostÃ­ na Ãºrovni
                      projektu. &lt;n&gt; je nÃ¡zev vlastnosti a &lt;v&gt; je jejÃ­ hodnota. VÃ­ce
-                     vlastnostÃ­ oddÄ›lte stÅ™ednÃ­kem Äi ÄÃ¡rkou nebo zadejte
+                     vlastnostÃ­ oddÄ›lte stÅ™ednÃ­kem Äi ÄÃ¡rkou nebo zadejte 
                      kaÅ¾dou vlastnost zvlÃ¡Å¡Å¥. (KrÃ¡tkÃ½ tvar: -p)
                      PÅ™Ã­klad:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -469,7 +483,7 @@
                      Syntaxe hodnoty &lt;sestavenÃ­_protok_nÃ¡st&gt;:
                         {&lt;nÃ¡zev_sestavenÃ­&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavenÃ­&gt;}
                      Parametry protokolovacÃ­ho nÃ¡stroje urÄujÃ­, jak MSBuild vytvoÅ™Ã­ protokolovacÃ­ nÃ¡stroj.
-                     Parametry &lt;param_protok_nÃ¡st&gt; jsou volitelnÃ© a pÅ™edÃ¡vajÃ­ se
+                     Parametry &lt;param_protok_nÃ¡st&gt; jsou volitelnÃ© a pÅ™edÃ¡vajÃ­ se 
                      protokolovacÃ­mu nÃ¡stroji pÅ™esnÄ› v tom tvaru, v jakÃ©m
                      byly zadÃ¡ny. (KrÃ¡tkÃ½ tvar: -l)
                      PÅ™Ã­klady:
@@ -616,10 +630,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          OvÄ›Å™it projekt podle vÃ½chozÃ­ho schÃ©matu.
+        <target state="translated">  -validate          OvÄ›Å™it projekt podle vÃ½chozÃ­ho schÃ©matu. 
                      (KrÃ¡tkÃ½ tvar: -val)
 
-  -validate:&lt;schÃ©ma&gt; OvÄ›Å™it projekt podle zadanÃ©ho schÃ©matu.
+  -validate:&lt;schÃ©ma&gt; OvÄ›Å™it projekt podle zadanÃ©ho schÃ©matu. 
                      (KrÃ¡tkÃ½ tvar: -val)
                      PÅ™Ã­klad:
                        -validate:MyExtendedBuildSchema.xsd
@@ -679,11 +693,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Seznam stÅ™ednÃ­kem oddÄ›lenÃ½ch vstupnÃ­ch souborÅ¯ mezipamÄ›ti, ze kterÃ½ch
-                     MSBuild pÅ™eÄte vÃ½sledky sestavenÃ­.
-                     NastavenÃ­ tohoto atributu zÃ¡roveÅˆ zapne izolovanÃ© buildy (-isolate).
-                     (KrÃ¡tkÃ½ tvar: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -697,11 +710,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[souborMezipamÄ›ti]...
-                     VÃ½stupnÃ­ soubor mezipamÄ›ti, do nÄ›hoÅ¾ bude MSBuild
-                     zapisovat obsah svÃ½ch mezipamÄ›tÃ­ vÃ½sledkÅ¯ sestavenÃ­.
-                     NastavenÃ­m tÃ©to moÅ¾nosti zapnete takÃ© izolovanÃ© buildy (-isolate).
-                     (krÃ¡tkÃ½ tvar: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -733,11 +746,11 @@
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_nÃ¡st&gt;*&lt;pÅ™edÃ¡v_protok_nÃ¡st&gt;
+        <target state="translated">  -distributedlogger:&lt;centr_protok_nÃ¡st&gt;*&lt;pÅ™edÃ¡v_protok_nÃ¡st&gt;                     
                      PouÅ¾Ã­t zadanÃ½ protokolovacÃ­ nÃ¡stroj pro protokolovÃ¡nÃ­ udÃ¡lostÃ­
-                     z nÃ¡stroje MSBuild; ke kaÅ¾dÃ©mu uzlu pÅ™ipojit jinou instanci
-                     protokolovacÃ­ho nÃ¡stroje. Chcete-li zadat vÃ­ce
-                     protokolovacÃ­ch nÃ¡strojÅ¯, uveÄte je jednotlivÄ›.
+                     z nÃ¡stroje MSBuild; ke kaÅ¾dÃ©mu uzlu pÅ™ipojit jinou instanci 
+                     protokolovacÃ­ho nÃ¡stroje. Chcete-li zadat vÃ­ce 
+                     protokolovacÃ­ch nÃ¡strojÅ¯, uveÄte je jednotlivÄ›. 
                      (KrÃ¡tkÃ½ tvar: -dl)
                      Syntaxe hodnoty &lt;protok_nÃ¡st&gt;:
                         [&lt;tÅ™Ã­da_protok_nÃ¡st&gt;,]&lt;sestav_protok_nÃ¡st&gt;
@@ -801,7 +814,7 @@
         <target state="translated">  -toolsversion:&lt;verze&gt;
                      Verze sady nÃ¡strojÅ¯ MSBuild (Ãºloh, cÃ­lÅ¯ apod.), kterÃ¡ mÃ¡ bÃ½t
                      pouÅ¾ita pÅ™i sestavenÃ­. Tato verze mÃ¡ pÅ™ednost pÅ™ed verzemi
-                     uvedenÃ½mi v jednotlivÃ½ch projektech.
+                     uvedenÃ½mi v jednotlivÃ½ch projektech. 
                      (KrÃ¡tkÃ½ tvar: -tv)
                      PÅ™Ã­klad:
                        -toolsversion:3.5
@@ -919,25 +932,25 @@
                      popis pÅ™epÃ­naÄe -distributedFileLogger.
                      (KrÃ¡tkÃ½ tvar: -flp[n])
                      K dispozici jsou stejnÃ© parametry jako ty,
-                     kterÃ© jsou uvedeny u protokolovacÃ­ho nÃ¡stroje
+                     kterÃ© jsou uvedeny u protokolovacÃ­ho nÃ¡stroje 
                      konzoly. NÄ›kterÃ© dalÅ¡Ã­ dostupnÃ© parametry:
                        LogFile â€“ cesta k souboru protokolu, do nÄ›jÅ¾ bude zapsÃ¡n
-                                  protokol sestavenÃ­
+                                  protokol sestavenÃ­ 
                        Append  â€“ urÄuje, zda bude protokol sestavenÃ­ pÅ™ipojen
-                                  k souboru protokolu, nebo jej pÅ™epÃ­Å¡e. PÅ™i nastavenÃ­
+                                  k souboru protokolu, nebo jej pÅ™epÃ­Å¡e. PÅ™i nastavenÃ­ 
                                   pÅ™epÃ­naÄe bude protokol sestavenÃ­ pÅ™ipojen k souboru
-                                  protokolu. NenÃ­-li pÅ™epÃ­naÄ nastaven, bude obsah
-                                  existujÃ­cÃ­ho souboru protokolu pÅ™epsÃ¡n.
+                                  protokolu. NenÃ­-li pÅ™epÃ­naÄ nastaven, bude obsah 
+                                  existujÃ­cÃ­ho souboru protokolu pÅ™epsÃ¡n. 
                                   Podle vÃ½chozÃ­ho nastavenÃ­ je soubor protokolu pÅ™epsÃ¡n.
-                       Encoding â€“ urÄuje kÃ³dovÃ¡nÃ­ souboru, napÅ™Ã­klad
+                       Encoding â€“ urÄuje kÃ³dovÃ¡nÃ­ souboru, napÅ™Ã­klad 
                      UTF-8, Unicode nebo ASCII.
                        VÃ½chozÃ­ ÃºroveÅˆ podrobnostÃ­ je Detailed.
                      PÅ™Ã­klady:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                              Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1060,7 +1073,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Hodnota izolace projektÅ¯ nenÃ­ platnÃ¡. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Hodnota izolace projektÅ¯ nenÃ­ platnÃ¡. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 90efc62dcd2..30622ac9e89 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: Der Schalter "-noAutoResponse" kann weder in der automatischen Antwortdatei "MSBuild.rsp" noch in einer anderen Antwortdatei verwendet werden, auf die die automatische Antwortdatei verweist.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -137,7 +142,7 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     Weist darauf hin, dass fÃ¼r Aktionen im Build eine
+                     Weist darauf hin, dass fÃ¼r Aktionen im Build eine 
                      Interaktion mit dem Benutzer zugelassen ist. Verwenden Sie dieses Argument
                      in einem automatisierten Szenario, in dem keine InteraktivitÃ¤t
                      erwartet wird.
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     FÃ¼hrt dazu, dass MSBuild jedes Projekt isoliert erstellt.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Dies ist ein restriktiverer Modus von MSBuild, da er erfordert, dass
-                     der Projektgraph zur Auswertungszeit statisch ermittelbar ist. Er kann jedoch
-                     die Planung verbessern und den Speichermehraufwand
-                     beim Erstellen einer groÃŸen Anzahl von Projekten verringern.
-                     (Kurzform: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Dieses Flag ist experimentell und funktioniert mÃ¶glicherweise nicht wie vorgesehen.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -366,8 +380,8 @@ Beispiel:
                      Antwortdateien anzugeben, geben Sie jede Antwortdatei
                      gesondert an.
 
-                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch
-                     in den folgenden Speicherorten verwendet:
+                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch 
+                     in den folgenden Speicherorten verwendet: 
                      (1) Verzeichnis von "msbuild.exe"
                      (2) Verzeichnis des ersten erstellten Projekts oder Projektmappe
 </target>
@@ -458,7 +472,7 @@ Beispiel:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben,
+        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax fÃ¼r die &lt;Protokollierung&gt; lautet:
                        [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
@@ -467,7 +481,7 @@ Beispiel:
                      Die Syntax fÃ¼r die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung Ã¼bergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -676,11 +690,10 @@ Beispiel:
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Durch Semikolons getrennte Liste von Eingabecachedateien, aus denen MSBuild
-                     Buildergebnisse liest.
-                     Durch Festlegen dieser Option werden auch isolierte Builds aktiviert (-isolate).
-                     (Kurzform: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -694,11 +707,11 @@ Beispiel:
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[Cachedatei]
-                     Ausgabecachedateien, in die MSBuild am Ende des Buildvorgangs die Inhalte
-                     der zugehÃ¶rigen Caches mit Buildergebnissen schreibt.
-                     Durch Festlegung dieser Option werden auÃŸerdem isolierte Builds aktiviert (-isolate).
-                     (Kurzform: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -731,8 +744,8 @@ Beispiel:
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
         <target state="translated">  -distributedlogger:&lt;Zentrale Protokollierung&gt;*&lt;Weiterleitende Protokollierung&gt;
-                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere
-                     Protokollierungsinstanz angefÃ¼gt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung
+                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere 
+                     Protokollierungsinstanz angefÃ¼gt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung 
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax fÃ¼r die &lt;Protokollierung&gt; lautet:
@@ -742,7 +755,7 @@ Beispiel:
                      Die Syntax fÃ¼r die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung Ã¼bergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -767,8 +780,8 @@ Beispiel:
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreprojectextensions:&lt;Erweiterungen&gt;
-                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende
-                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma,
+                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende 
+                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma, 
                      um mehrere Erweiterungen voneinander zu trennen.
                      (Kurzform: -ignore)
                      Beispiel:
@@ -794,8 +807,8 @@ Beispiel:
    </source>
         <target state="translated">  -toolsversion:&lt;Version&gt;
                      Die Version des MSBuild-Toolsets (Aufgaben, Ziele usw.),
-                     die wÃ¤hrend des Erstellens zu verwenden ist. Diese Version Ã¼berschreibt die
-                     von einzelnen Projekten angegebenen Versionen. (Kurzform:
+                     die wÃ¤hrend des Erstellens zu verwenden ist. Diese Version Ã¼berschreibt die 
+                     von einzelnen Projekten angegebenen Versionen. (Kurzform: 
                      -tv)
                      Beispiel:
                        -toolsversion:3.5
@@ -854,14 +867,14 @@ Beispiel:
         <target state="translated">  -distributedFileLogger
                      Protokolliert die Erstellungsausgabe in mehrere Dateien, eine Protokolldatei
                      pro MSBuild-Knoten. Der anfÃ¤ngliche Speicherort fÃ¼r diese Dateien ist
-                     das aktuelle Verzeichnis. StandardmÃ¤ÃŸig werden die Dateien
+                     das aktuelle Verzeichnis. StandardmÃ¤ÃŸig werden die Dateien 
                      "MSBuild&lt;Knoten-ID&gt;.log" benannt. Der Speicherort der Datei und
-                     andere Parameter fÃ¼r fileLogger kÃ¶nnen durch das HinzufÃ¼gen
+                     andere Parameter fÃ¼r fileLogger kÃ¶nnen durch das HinzufÃ¼gen 
                      des Schalters "-fileLoggerParameters" angegeben werden.
 
                      Wenn mithilfe des fileLoggerParameters-Parameters ein Protokolldateiname festgelegt wurde,
-                     verwendet die verteilte Protokollierung den Dateinamen als
-                     Vorlage und fÃ¼gt die Knoten-ID an diesen Dateinamen an,
+                     verwendet die verteilte Protokollierung den Dateinamen als 
+                     Vorlage und fÃ¼gt die Knoten-ID an diesen Dateinamen an, 
                      um fÃ¼r jeden Knoten eine Protokolldatei zu erstellen.
     </target>
         <note>
@@ -905,31 +918,31 @@ Beispiel:
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;Parameter&gt;
                      Gibt zusÃ¤tzliche Parameter fÃ¼r Dateiprotokollierungen an.
-                     Dieser Schalter bedeutet, dass der entsprechende
+                     Dieser Schalter bedeutet, dass der entsprechende 
                      Schalter "-fileLogger[n]" ebenfalls vorhanden ist.
                      "n" (optional) kann eine Zahl von 1â€“9 sein.
-                     "-fileLoggerParameters" wird auch von verteilten
+                     "-fileLoggerParameters" wird auch von verteilten 
                      Dateiprotokollierungen verwendet (siehe Beschreibung zu "-distributedFileLogger").
                      (Kurzform: -flp[n])
                      Es sind dieselben Parameter wie fÃ¼r die Konsolenprotokollierung
                      verfÃ¼gbar. Einige zusÃ¤tzliche Parameter:
-                        LogFile: Pfad der Protokolldatei, in die das
+                        LogFile: Pfad der Protokolldatei, in die das 
                             Buildprotokoll geschrieben wird.
-                        Append: Gibt an, ob das Buildprotokoll erweitert oder
+                        Append: Gibt an, ob das Buildprotokoll erweitert oder 
                             oder Ã¼berschrieben wird. Mit diesem Schalter
                             wird das Buildprotokoll an die Protokolldatei angefÃ¼gt;
-                            Ohne diesen Schalter wird der Inhalt
-                            der vorhandenen Protokolldatei Ã¼berschrieben.
+                            Ohne diesen Schalter wird der Inhalt 
+                            der vorhandenen Protokolldatei Ã¼berschrieben. 
                             StandardmÃ¤ÃŸig wird die Protokolldatei nicht erweitert.
-                        Encoding: Gibt die Codierung der Datei an,
+                        Encoding: Gibt die Codierung der Datei an, 
                             z. B. UTF-8, Unicode oder ASCII.
                      Die Standardeinstellung fÃ¼r "verbosity" ist "Detailed".
                      Beispiele:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -955,7 +968,7 @@ Beispiel:
         <target state="translated">  -nodeReuse:&lt;Parameter&gt;
                      Aktiviert oder deaktiviert die Wiederverwendung von MSBuild-Knoten.
                      Die Parameter lauten:
-                     True: Knoten bleiben nach dem Abschluss der Erstellung
+                     True: Knoten bleiben nach dem Abschluss der Erstellung 
                      erhalten und werden bei folgenden Erstellungen wiederverwendet (Standardeinstellung).
                      False: Knoten bleiben nach dem Abschluss der Erstellung nicht erhalten.
                      (Kurzform: -nr)
@@ -1052,7 +1065,7 @@ Beispiel:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Der Wert fÃ¼r das Isolieren von Projekten ist nicht gÃ¼ltig. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Der Wert fÃ¼r das Isolieren von Projekten ist nicht gÃ¼ltig. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 21744c6bbe8..8d22bc8c809 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: El modificador -noAutoResponse no puede especificarse en el archivo de respuesta automÃ¡tica MSBuild.rsp ni en ningÃºn archivo de respuesta al que el archivo de respuesta automÃ¡tica haga referencia.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Hace que MSBuild compile cada proyecto en aislamiento.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Este es un modo de MSBuild mÃ¡s restrictivo ya que requiere
-                     que el grafo de proyecto se pueda detectar estÃ¡ticamente en el
-                     momento de evaluaciÃ³n, pero puede mejorar la programaciÃ³n y reducir
-                     la sobrecarga de memoria al compilar un gran conjunto de proyectos.
-                     (Forma corta: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Este indicador es experimental y puede que no funcione como se espera.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -680,11 +694,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;archivoCachÃ©&gt;...
-                     Lista de archivos de cachÃ© de entrada, separados por punto y coma, de la que MSBuild
-                     leerÃ¡ los resultados de la compilaciÃ³n.
-                     Si se establece esta opciÃ³n, se activan tambiÃ©n las compilaciones aisladas (-isolate).
-                     (Forma corta: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -698,13 +711,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[archivo-de-cachÃ©]
-                     Archivo de cachÃ© de salida donde MSBuild escribe
-                     el contenido de las memorias cachÃ© de resultados
-                     de compilaciÃ³n cuando esta acaba.
-                     Si se establece esta opciÃ³n, se activan tambiÃ©n las
-                     compilaciones aisladas (-isolate).
-                     (Forma corta: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -776,8 +787,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensiones&gt;
-                     Lista de extensiones que se omiten al determinar el
-                     archivo del proyecto que se va a compilar. Use el carÃ¡cter de
+                     Lista de extensiones que se omiten al determinar el 
+                     archivo del proyecto que se va a compilar. Use el carÃ¡cter de 
                      punto y coma o coma para separar varias extensiones.
                     (Forma corta: -ignore)
                      Ejemplo:
@@ -928,9 +939,9 @@
                             sobrescribirÃ¡ el archivo de registro. Si se establece el
                             modificador, se adjunta el registro de compilaciÃ³n al archivo de registro;
                             Si no se especifica el modificador, se sobrescribe
-                            el contenido del archivo de registro existente.
+                            el contenido del archivo de registro existente. 
                             El valor predeterminado es adjuntar el archivo de registro.
-                        Encoding: especifica la codificaciÃ³n del archivo,
+                        Encoding: especifica la codificaciÃ³n del archivo, 
                             por ejemplo, UTF-8, Unicode o ASCII
                      El nivel de detalle predeterminado es Detailed.
                      Ejemplos:
@@ -1061,7 +1072,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: El valor de los proyectos aislados no es vÃ¡lido. {0}.</target>
+        <target state="translated">MSBUILD : error MSB1056: El valor de los proyectos aislados no es vÃ¡lido. {0}.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 053a767c46a..9cce4115e83 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: Impossible de spÃ©cifier le commutateur -noAutoResponse dans le fichier rÃ©ponse automatique MSBuild.rsp, ni dans aucun autre fichier rÃ©ponse rÃ©fÃ©rencÃ© par le fichier rÃ©ponse automatique.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Force MSBuild Ã  gÃ©nÃ©rer chaque projet de maniÃ¨re isolÃ©e.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Ce mode de MSBuild est plus restrictif car il nÃ©cessite
-                     que le graphe du projet soit statiquement dÃ©couvrable au
-                     moment de l'Ã©valuation, mais il peut amÃ©liorer la planification et rÃ©duire
-                     la surcharge de mÃ©moire lors de la gÃ©nÃ©ration d'un grand nombre de projets.
-                     (Forme abrÃ©gÃ©eÂ : -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Cet indicateur est expÃ©rimental et peut ne pas fonctionner comme prÃ©vu.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -676,11 +690,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;fichierCache&gt;...
-         Liste de fichiers cache d'entrÃ©e sÃ©parÃ©s par des points-virgules, Ã 
-         partir desquels MSBuild va lire les rÃ©sultats de la build.
-         Ce paramÃ¨tre active Ã©galement les builds isolÃ©es (-isolate).
-         (Forme abrÃ©gÃ©eÂ : -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -694,11 +707,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     Fichier cache de sortie dans lequel MSBuild Ã©crit le contenu de
-                     ses caches de rÃ©sultats de la build Ã  la fin de la build.
-                     Ce paramÃ¨tre active Ã©galement les builds isolÃ©es (-isolate).
-                     (forme abrÃ©gÃ©eÂ : -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1052,7 +1065,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: La valeur dâ€™isolation des projets n'est pas valide. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: La valeur dâ€™isolation des projets n'est pas valide. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1781,7 +1794,7 @@ fois plus petit que le journal
         <target state="translated">  -profileEvaluation:&lt;fichier&gt;
          Profile l'Ã©valuation MSBuild et Ã©crit le rÃ©sultat
          dans le fichier spÃ©cifiÃ©. Si l'extension du fichier spÃ©cifiÃ©
-         est '.md', le rÃ©sultat est gÃ©nÃ©rÃ© au format Markdown.
+         est '.md', le rÃ©sultat est gÃ©nÃ©rÃ© au format Markdown. 
          Sinon, un fichier de valeurs sÃ©parÃ©es par des tabulations est gÃ©nÃ©rÃ©.
     </target>
         <note />
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 72b5666d501..a94da3091cc 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: non Ã¨ possibile specificare l'opzione -noAutoResponse nel file di risposta automatica MSBuild.rsp o in file di risposta a cui il file di risposta automatica fa riferimento.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -172,19 +177,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Fa in modo che MSBuild compili ogni progetto in modalitÃ 
-                     isolamento.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Si tratta di una modalitÃ  piÃ¹ restrittiva di
-                     MSBuild perchÃ© richiede che il grafico del progetto sia
-                     rilevabile staticamente in fase di valutazione, ma puÃ²
-                     migliorare la pianificazione e ridurre il sovraccarico
-                     della memoria quando si compila un set esteso di progetti.
-                     Forma breve: -isolate.
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Questo flag Ã¨ sperimentale e potrebbe non funzionare come
-                     previsto.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -377,7 +388,7 @@ Esempio:
                      separatamente.
 
                      Qualsiasi file di risposta denominato "msbuild.rsp" viene usato
-                     automaticamente dai percorsi seguenti:
+                     automaticamente dai percorsi seguenti: 
                      (1) la directory di msbuild.exe
                      (2) la directory della prima compilazione di soluzione o progetto
 </target>
@@ -686,11 +697,10 @@ Esempio:
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;fileCache&gt;...
-                     Elenco di file di cache di input delimitati da punto e virgola da cui MSBuild
-                     leggerÃ  i risultati della compilazione.
-                     Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
-                     Forma breve: -irc
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -704,11 +714,11 @@ Esempio:
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[fileCache]
-                     File di cache di output in cui MSBuild scriverÃ  il contenuto delle
-                     cache dei risultati della compilazione al termine della compilazione.
-                     Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
-                     Forma breve: -orc
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1066,7 +1076,7 @@ Esempio:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: il valore di isolateProjects non Ã¨ valido. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: il valore di isolateProjects non Ã¨ valido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 58415640848..909ce96e62d 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp è‡ªå‹•å¿œç­”ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ã€è‡ªå‹•å¿œç­”ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ˆã£ã¦å‚ç…§ã•ã‚Œã‚‹å¿œç­”ãƒ•ã‚¡ã‚¤ãƒ«ã« -noAutoResponse ã‚¹ã‚¤ãƒƒãƒã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuild ã¯ã€å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ†é›¢ã—ã¦ãƒ“ãƒ«ãƒ‰ã—ã¾ã™ã€‚
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     ã“ã‚Œã¯ MSBuild ã®ã‚ˆã‚Šåˆ¶é™çš„ãªãƒ¢ãƒ¼ãƒ‰ã§ã™ã€‚
-                     è©•ä¾¡æ™‚ã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ã‚°ãƒ©ãƒ•ãŒé™çš„ã«æ¤œå‡ºã§ããªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã§ã™ã€‚
-                     ã—ã‹ã—ã€å¤§ããªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ ã‚»ãƒƒãƒˆã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã¨ãã«ã€
-                     ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®šã‚’å‘ä¸Šã•ã›ã€ãƒ¡ãƒ¢ãƒª ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’å‰Šæ¸›ã§ãã¾ã™ã€‚
-                     (çŸ­ã„å½¢å¼: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     ã“ã®ãƒ•ãƒ©ã‚°ã¯å®Ÿé¨“çš„ã§ã€æ„å›³ã©ãŠã‚Šã«æ©Ÿèƒ½ã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -235,7 +249,7 @@
     </source>
         <target state="translated">  -targets[:file]
                      ä½¿ç”¨å¯èƒ½ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä¸€è¦§ã‚’ã€å®Ÿéš›ã®ãƒ“ãƒ«ãƒ‰å‡¦ç†ã‚’
-                     å®Ÿè¡Œã›ãšã«å‡ºåŠ›ã—ã¾ã™ã€‚æ—¢å®šã§ã¯ã€å‡ºåŠ›ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«
+                     å®Ÿè¡Œã›ãšã«å‡ºåŠ›ã—ã¾ã™ã€‚æ—¢å®šã§ã¯ã€å‡ºåŠ›ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ« 
                      ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«æ›¸ãè¾¼ã¾ã‚Œã¾ã™ã€‚å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã‚’
                      æŒ‡å®šã—ãŸå ´åˆã¯ã€ä»£ã‚ã‚Šã«ãã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
                      (çŸ­ã„å½¢å¼:-ts)
@@ -676,11 +690,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     MSBuild ãŒãƒ“ãƒ«ãƒ‰çµæžœã‚’èª­ã¿è¾¼ã‚€ã€å…¥åŠ›ã‚­ãƒ£ãƒƒã‚·ãƒ¥ ãƒ•ã‚¡ã‚¤ãƒ«ã®
-                     ã‚»ãƒŸã‚³ãƒ­ãƒ³ã§åŒºåˆ‡ã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆã€‚
-                     ã“ã‚Œã‚’è¨­å®šã™ã‚‹ã¨ã€åˆ†é›¢ã•ã‚ŒãŸãƒ“ãƒ«ãƒ‰ (-isolate) ã‚‚æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚
-                     (çŸ­ç¸®å½¢: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -694,11 +707,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuild ãŒãƒ“ãƒ«ãƒ‰ã®æœ€å¾Œã«ãƒ“ãƒ«ãƒ‰çµæžœã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®
-                     å†…å®¹ã‚’æ›¸ãè¾¼ã‚€å‡ºåŠ›ã‚­ãƒ£ãƒƒã‚·ãƒ¥ ãƒ•ã‚¡ã‚¤ãƒ«ã€‚
-                     è¨­å®šã™ã‚‹ã¨ã€åˆ†é›¢ã•ã‚ŒãŸãƒ“ãƒ«ãƒ‰ã‚‚æœ‰åŠ¹ã«ãªã‚Šã¾ã™ (-isolate)ã€‚
-                     (çŸ­ã„å½¢å¼: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1052,7 +1065,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Isolate projects å€¤ãŒç„¡åŠ¹ã§ã™ã€‚{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Isolate projects å€¤ãŒç„¡åŠ¹ã§ã™ã€‚{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1720,7 +1733,7 @@
                      (Short form: -r)
     </source>
         <target state="translated">  -restore[:True|False]
-                     ä»–ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹å‰ã« Restore
+                     ä»–ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹å‰ã« Restore 
                      ã¨ã„ã†åå‰ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å®Ÿè¡Œã—ã€ã“ã‚Œã‚‰ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ“ãƒ«ãƒ‰ãŒ
                      æœ€æ–°ã®å¾©å…ƒãƒ“ãƒ«ãƒ‰ ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
                      ã“ã‚Œã¯ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ ãƒ„ãƒªãƒ¼ã§ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ãƒ“ãƒ«ãƒ‰
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 4cdc5a9bdef..9265420c6e3 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp ìžë™ ì§€ì‹œ íŒŒì¼ê³¼ ìžë™ ì§€ì‹œ íŒŒì¼ì—ì„œ ì°¸ì¡°í•˜ëŠ” ëª¨ë“  ì§€ì‹œ íŒŒì¼ì—ëŠ” -noAutoResponse ìŠ¤ìœ„ì¹˜ë¥¼ ì§€ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -137,12 +142,12 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     ë¹Œë“œì˜ ìž‘ì—…ì´ ì‚¬ìš©ìžì™€ ìƒí˜¸ ìž‘ìš©í•  ìˆ˜
-                     ìžˆìŒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ìƒí˜¸ ìž‘ìš©ì´ í•„ìš”í•˜ì§€
-                     ì•Šì€ ìžë™í™”ëœ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œëŠ” ì´ ì¸ìˆ˜ë¥¼
+                     ë¹Œë“œì˜ ìž‘ì—…ì´ ì‚¬ìš©ìžì™€ ìƒí˜¸ ìž‘ìš©í•  ìˆ˜ 
+                     ìžˆìŒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ìƒí˜¸ ìž‘ìš©ì´ í•„ìš”í•˜ì§€ 
+                     ì•Šì€ ìžë™í™”ëœ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œëŠ” ì´ ì¸ìˆ˜ë¥¼ 
                      ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”.
                      -interactiveë¥¼ ì§€ì •í•˜ëŠ” ê²ƒì€ -interactive:trueë¥¼
-                     ì§€ì •í•˜ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤. ë§¤ê°œ ë³€ìˆ˜ë¥¼
+                     ì§€ì •í•˜ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤. ë§¤ê°œ ë³€ìˆ˜ë¥¼ 
                      ì‚¬ìš©í•˜ì—¬ ì§€ì‹œ íŒŒì¼ì—ì„œ ê°€ì ¸ì˜¤ëŠ” ê°’ì„ ìž¬ì •ì˜í•©ë‹ˆë‹¤.
     </target>
         <note>
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuildê°€ ê²©ë¦¬ ëª¨ë“œì—ì„œ ê° í”„ë¡œì íŠ¸ë¥¼ ë¹Œë“œí•˜ë„ë¡ í•©ë‹ˆë‹¤.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     ì´ ëª¨ë“œëŠ” í”„ë¡œì íŠ¸ ê·¸ëž˜í”„ê°€ í‰ê°€ ì‹œê°„ì— ì •ì ìœ¼ë¡œ
-                     ê²€ìƒ‰ ê°€ëŠ¥í•´ì•¼ í•˜ë¯€ë¡œ ë” ì œí•œì ì¸ MSBuild ëª¨ë“œì´ë‚˜,
-                     ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ë¥¼ ë¹Œë“œí•  ê²½ìš° ì˜ˆì•½ì„ ê°œì„ í•˜ê³ 
-                     ë©”ëª¨ë¦¬ ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì¼ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
-                     (ì•½ì‹: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     ì´ í”Œëž˜ê·¸ëŠ” ì‹¤í—˜ì ì´ë©° ì˜ˆìƒëŒ€ë¡œ ìž‘ë™í•˜ì§€ ì•Šì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -203,9 +217,9 @@
         <target state="translated">  -graphBuild[:True|False]
                      MSBuildê°€ í”„ë¡œì íŠ¸ ê·¸ëž˜í”„ë¥¼ ìƒì„± ë° ë¹Œë“œí•˜ë„ë¡ í•©ë‹ˆë‹¤.
 
-                     ê·¸ëž˜í”„ ìƒì„±ì—ëŠ” ì¢…ì†ì„±ì„ í˜•ì„±í•˜ê¸° ìœ„í•œ í”„ë¡œì íŠ¸
-                     ì°¸ì¡° ì‹ë³„ì´ ê´€ë ¨ë©ë‹ˆë‹¤. í•´ë‹¹ ê·¸ëž˜í”„ ë¹Œë“œì—ëŠ” í”„ë¡œì íŠ¸
-                     ì°¸ì¡°ë¥¼ ì°¸ì¡°í•˜ëŠ” í”„ë¡œì íŠ¸ ì „ì— í”„ë¡œì íŠ¸ ì°¸ì¡°ë¥¼
+                     ê·¸ëž˜í”„ ìƒì„±ì—ëŠ” ì¢…ì†ì„±ì„ í˜•ì„±í•˜ê¸° ìœ„í•œ í”„ë¡œì íŠ¸ 
+                     ì°¸ì¡° ì‹ë³„ì´ ê´€ë ¨ë©ë‹ˆë‹¤. í•´ë‹¹ ê·¸ëž˜í”„ ë¹Œë“œì—ëŠ” í”„ë¡œì íŠ¸ 
+                     ì°¸ì¡°ë¥¼ ì°¸ì¡°í•˜ëŠ” í”„ë¡œì íŠ¸ ì „ì— í”„ë¡œì íŠ¸ ì°¸ì¡°ë¥¼ 
                      ë¹Œë“œí•˜ëŠ” ì‹œë„ê°€ ê´€ë ¨ë˜ë©°, ì´ëŠ” ê¸°ì¡´ MSBuild
                      ì˜ˆì•½ê³¼ ë‹¤ë¦…ë‹ˆë‹¤.
                      (ì•½ì‹: -graph)
@@ -259,7 +273,7 @@
         <target state="translated">  -lowPriority[:True|False]
                      MSBuildê°€ ë‚®ì€ í”„ë¡œì„¸ìŠ¤ ìš°ì„  ìˆœìœ„ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.
 
-                     -lowPriorityë¥¼ ì§€ì •í•˜ëŠ” ê²ƒì€
+                     -lowPriorityë¥¼ ì§€ì •í•˜ëŠ” ê²ƒì€ 
                      -lowPriority:Trueë¥¼ ì§€ì •í•˜ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤.
                      (ì•½ì‹: -low)
     </target>
@@ -362,11 +376,11 @@
                      (1) the directory of msbuild.exe
                      (2) the directory of the first project or solution built
 </source>
-        <target state="translated">  @&lt;file&gt;            í…ìŠ¤íŠ¸ íŒŒì¼ì—ì„œ ëª…ë ¹ì¤„ ì„¤ì •ì„ ì‚½ìž…í•©ë‹ˆë‹¤.
-                     ì—¬ëŸ¬ ì§€ì‹œ íŒŒì¼ì„ ì§€ì •í•˜ë ¤ë©´ ê° ì§€ì‹œ íŒŒì¼ì„ ê°œë³„ì ìœ¼ë¡œ
+        <target state="translated">  @&lt;file&gt;            í…ìŠ¤íŠ¸ íŒŒì¼ì—ì„œ ëª…ë ¹ì¤„ ì„¤ì •ì„ ì‚½ìž…í•©ë‹ˆë‹¤. 
+                     ì—¬ëŸ¬ ì§€ì‹œ íŒŒì¼ì„ ì§€ì •í•˜ë ¤ë©´ ê° ì§€ì‹œ íŒŒì¼ì„ ê°œë³„ì ìœ¼ë¡œ 
                      ì§€ì •í•©ë‹ˆë‹¤.
 
-                     "msbuild.rsp"ë¼ëŠ” ì§€ì‹œ íŒŒì¼ì´ ë‹¤ìŒ ìœ„ì¹˜ì—ì„œ
+                     "msbuild.rsp"ë¼ëŠ” ì§€ì‹œ íŒŒì¼ì´ ë‹¤ìŒ ìœ„ì¹˜ì—ì„œ 
                      ìžë™ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.
                      (1) msbuild.exeì˜ ë””ë ‰í„°ë¦¬
                      (2) ë¹Œë“œëœ ì²« ë²ˆì§¸ í”„ë¡œì íŠ¸ ë˜ëŠ” ì†”ë£¨ì…˜ì˜ ë””ë ‰í„°ë¦¬
@@ -403,8 +417,8 @@
                      Example:
                        -target:Resources;Compile
 </source>
-        <target state="translated">  -target:&lt;targets&gt;  ì´ í”„ë¡œì íŠ¸ì—ì„œ ëŒ€ìƒì„ ë¹Œë“œí•©ë‹ˆë‹¤. ì„¸ë¯¸ì½œë¡  ë˜ëŠ” ì‰¼í‘œë¥¼ ì‚¬ìš©í•˜ì—¬
-                     ì—¬ëŸ¬ ëŒ€ìƒì„ êµ¬ë¶„í•˜ê±°ë‚˜, ê° ëŒ€ìƒì„
+        <target state="translated">  -target:&lt;targets&gt;  ì´ í”„ë¡œì íŠ¸ì—ì„œ ëŒ€ìƒì„ ë¹Œë“œí•©ë‹ˆë‹¤. ì„¸ë¯¸ì½œë¡  ë˜ëŠ” ì‰¼í‘œë¥¼ ì‚¬ìš©í•˜ì—¬ 
+                     ì—¬ëŸ¬ ëŒ€ìƒì„ êµ¬ë¶„í•˜ê±°ë‚˜, ê° ëŒ€ìƒì„ 
                      ê°œë³„ì ìœ¼ë¡œ ì§€ì •í•©ë‹ˆë‹¤. (ì•½ì‹: -t)
                      ì˜ˆ:
                        -target:Resources;Compile
@@ -426,9 +440,9 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  í”„ë¡œì íŠ¸ ìˆ˜ì¤€ ì†ì„±ì„ ì„¤ì •í•˜ê±°ë‚˜ ìž¬ì •ì˜í•©ë‹ˆë‹¤. &lt;n&gt;ì€
-                     ì†ì„± ì´ë¦„ì´ê³  &lt;v&gt;ëŠ” ì†ì„± ê°’ìž…ë‹ˆë‹¤.
-                     ì„¸ë¯¸ì½œë¡  ë˜ëŠ” ì‰¼í‘œë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ì†ì„±ì„ êµ¬ë¶„í•˜ê±°ë‚˜,
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  í”„ë¡œì íŠ¸ ìˆ˜ì¤€ ì†ì„±ì„ ì„¤ì •í•˜ê±°ë‚˜ ìž¬ì •ì˜í•©ë‹ˆë‹¤. &lt;n&gt;ì€ 
+                     ì†ì„± ì´ë¦„ì´ê³  &lt;v&gt;ëŠ” ì†ì„± ê°’ìž…ë‹ˆë‹¤. 
+                     ì„¸ë¯¸ì½œë¡  ë˜ëŠ” ì‰¼í‘œë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ì†ì„±ì„ êµ¬ë¶„í•˜ê±°ë‚˜, 
                      ê° ì†ì„±ì„ ê°œë³„ì ìœ¼ë¡œ ì§€ì •í•©ë‹ˆë‹¤. (ì•½ì‹: -p)
                      ì˜ˆ:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -613,10 +627,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          ê¸°ë³¸ ìŠ¤í‚¤ë§ˆë¥¼ ê¸°ì¤€ìœ¼ë¡œ í”„ë¡œì íŠ¸ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•©ë‹ˆë‹¤.
+        <target state="translated">  -validate          ê¸°ë³¸ ìŠ¤í‚¤ë§ˆë¥¼ ê¸°ì¤€ìœ¼ë¡œ í”„ë¡œì íŠ¸ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•©ë‹ˆë‹¤. 
                      (ì•½ì‹: -val)
 
-  -validate:&lt;schema&gt; ì§€ì •ëœ ìŠ¤í‚¤ë§ˆë¥¼ ê¸°ì¤€ìœ¼ë¡œ í”„ë¡œì íŠ¸ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•©ë‹ˆë‹¤.
+  -validate:&lt;schema&gt; ì§€ì •ëœ ìŠ¤í‚¤ë§ˆë¥¼ ê¸°ì¤€ìœ¼ë¡œ í”„ë¡œì íŠ¸ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•©ë‹ˆë‹¤. 
                      (ì•½ì‹: -val)
                      ì˜ˆ:
                        -validate:MyExtendedBuildSchema.xsd
@@ -676,11 +690,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     MSBuildê°€ ë¹Œë“œ ê²°ê³¼ë¥¼ ì½ëŠ” ì†ŒìŠ¤ ìž…ë ¥ ìºì‹œ íŒŒì¼ì˜
-                     ì„¸ë¯¸ì½œë¡ ìœ¼ë¡œ êµ¬ë¶„ëœ ëª©ë¡ìž…ë‹ˆë‹¤.
-                     ì´ ìŠ¤ìœ„ì¹˜ë¥¼ ì„¤ì •í•˜ë©´ ê²©ë¦¬ëœ ë¹Œë“œ(-isolate)ë„ ì¼œì§‘ë‹ˆë‹¤.
-                     (ì•½ì‹: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -694,10 +707,10 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuildì—ì„œ ë¹Œë“œ ë§ˆì§€ë§‰ì— ë¹Œë“œ ê²°ê³¼ ìºì‹œì˜
-                     ì½˜í…ì¸ ë¥¼ ì“°ëŠ” ì¶œë ¥ ìºì‹œ íŒŒì¼ìž…ë‹ˆë‹¤.
-                     ì„¤ì •í•˜ë©´ ê²©ë¦¬ëœ ë¹Œë“œì—ì„œë„ ì„¤ì •ë©ë‹ˆë‹¤(-isolate).
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </target>
         <note>
@@ -767,8 +780,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensions&gt;
-                     ë¹Œë“œí•  í”„ë¡œì íŠ¸ íŒŒì¼ì„ ê²°ì •í•  ë•Œ
-                     ë¬´ì‹œí•  í™•ìž¥ ëª©ë¡ìž…ë‹ˆë‹¤. ì—¬ëŸ¬ í™•ìž¥ì„ êµ¬ë¶„í•˜ëŠ” ë°ëŠ”
+                     ë¹Œë“œí•  í”„ë¡œì íŠ¸ íŒŒì¼ì„ ê²°ì •í•  ë•Œ 
+                     ë¬´ì‹œí•  í™•ìž¥ ëª©ë¡ìž…ë‹ˆë‹¤. ì—¬ëŸ¬ í™•ìž¥ì„ êµ¬ë¶„í•˜ëŠ” ë°ëŠ” 
                      ì„¸ë¯¸ì½œë¡  ë˜ëŠ” ì‰¼í‘œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
                      (ì•½ì‹: -ignore)
                      ì˜ˆ:
@@ -794,7 +807,7 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;version&gt;
                      ë¹Œë“œ ì¤‘ì— ì‚¬ìš©í•  MSBuild ë„êµ¬ ì„¸íŠ¸(ìž‘ì—…, ëŒ€ìƒ ë“±)ì˜ ë²„ì „ìž…ë‹ˆë‹¤.
-                     ì´ ë²„ì „ì€ ê°œë³„ í”„ë¡œì íŠ¸ì—ì„œ ì§€ì •í•œ ë²„ì „ì„
+                     ì´ ë²„ì „ì€ ê°œë³„ í”„ë¡œì íŠ¸ì—ì„œ ì§€ì •í•œ ë²„ì „ì„ 
                      ìž¬ì •ì˜í•©ë‹ˆë‹¤. (ì•½ì‹:
                      -tv)
                      ì˜ˆ:
@@ -823,9 +836,9 @@
                      íŒŒì¼ì€ í˜„ìž¬ ë””ë ‰í„°ë¦¬ì— ìžˆê³ 
                      "msbuild[n].log"ë¡œ ì´ë¦„ì´ ì§€ì •ë˜ì–´ ìžˆìŠµë‹ˆë‹¤. ëª¨ë“  ë…¸ë“œì˜ ì´ë²¤íŠ¸ëŠ” ë‹¨ì¼ ë¡œê·¸ë¡œ
                      ê²°í•©ë©ë‹ˆë‹¤. íŒŒì¼ì˜ ìœ„ì¹˜ ë° fileLoggerì˜
-                     ë‹¤ë¥¸ ë§¤ê°œ ë³€ìˆ˜ëŠ” "-fileLoggerParameters[n]" ìŠ¤ìœ„ì¹˜ë¥¼
+                     ë‹¤ë¥¸ ë§¤ê°œ ë³€ìˆ˜ëŠ” "-fileLoggerParameters[n]" ìŠ¤ìœ„ì¹˜ë¥¼ 
                      ì¶”ê°€í•˜ì—¬ ì§€ì •í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
-                     "n"ì€ 1-9 ì‚¬ì´ì˜ ìˆ«ìžì¼ ìˆ˜ ìžˆìœ¼ë©° ìµœëŒ€ 10ê°œì˜
+                     "n"ì€ 1-9 ì‚¬ì´ì˜ ìˆ«ìžì¼ ìˆ˜ ìžˆìœ¼ë©° ìµœëŒ€ 10ê°œì˜ 
                      íŒŒì¼ ë¡œê±°ê°€ ì¶”ê°€ë  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. (ì•½ì‹: -fl[n])
     </target>
         <note>
@@ -852,16 +865,16 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     MSBuild ë…¸ë“œë‹¹ ë¡œê·¸ íŒŒì¼ í•˜ë‚˜ì”©, ì—¬ëŸ¬ ë¡œê·¸ íŒŒì¼ì— ë¹Œë“œ ì¶œë ¥ì„
-                     ê¸°ë¡í•©ë‹ˆë‹¤. í•´ë‹¹ íŒŒì¼ì˜ ì´ˆê¸° ìœ„ì¹˜ëŠ”
-                     í˜„ìž¬ ë””ë ‰í„°ë¦¬ìž…ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ í•´ë‹¹ íŒŒì¼ì„
-                     "MSBuild&lt;nodeid&gt;.log"ë¼ê³  í•©ë‹ˆë‹¤. íŒŒì¼ ìœ„ì¹˜ ë° fileLoggerì˜ ê¸°íƒ€ ë§¤ê°œ ë³€ìˆ˜ëŠ”
-                     "-fileLoggerParameters" ìŠ¤ìœ„ì¹˜ë¥¼ ì¶”ê°€í•´ì„œ
+                     MSBuild ë…¸ë“œë‹¹ ë¡œê·¸ íŒŒì¼ í•˜ë‚˜ì”©, ì—¬ëŸ¬ ë¡œê·¸ íŒŒì¼ì— ë¹Œë“œ ì¶œë ¥ì„ 
+                     ê¸°ë¡í•©ë‹ˆë‹¤. í•´ë‹¹ íŒŒì¼ì˜ ì´ˆê¸° ìœ„ì¹˜ëŠ” 
+                     í˜„ìž¬ ë””ë ‰í„°ë¦¬ìž…ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ í•´ë‹¹ íŒŒì¼ì„ 
+                     "MSBuild&lt;nodeid&gt;.log"ë¼ê³  í•©ë‹ˆë‹¤. íŒŒì¼ ìœ„ì¹˜ ë° fileLoggerì˜ ê¸°íƒ€ ë§¤ê°œ ë³€ìˆ˜ëŠ” 
+                     "-fileLoggerParameters" ìŠ¤ìœ„ì¹˜ë¥¼ ì¶”ê°€í•´ì„œ 
                      ì§€ì •í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
 
-                     ë¡œê·¸ íŒŒì¼ ì´ë¦„ì´ fileLoggerParameters ìŠ¤ìœ„ì¹˜ë¥¼ í†µí•´ ì„¤ì •ë˜ë©´
-                     ë°°í¬ëœ ë¡œê±°ê°€ fileNameì„ í…œí”Œë¦¿ìœ¼ë¡œ ì‚¬ìš©í•˜ê³ 
-                     ë…¸ë“œ IDë¥¼ ì´ fileNameì— ì¶”ê°€í•˜ì—¬
+                     ë¡œê·¸ íŒŒì¼ ì´ë¦„ì´ fileLoggerParameters ìŠ¤ìœ„ì¹˜ë¥¼ í†µí•´ ì„¤ì •ë˜ë©´ 
+                     ë°°í¬ëœ ë¡œê±°ê°€ fileNameì„ í…œí”Œë¦¿ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  
+                     ë…¸ë“œ IDë¥¼ ì´ fileNameì— ì¶”ê°€í•˜ì—¬ 
                      ê° ë…¸ë“œì˜ ë¡œê·¸ íŒŒì¼ì„ ë§Œë“­ë‹ˆë‹¤.
     </target>
         <note>
@@ -905,20 +918,20 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parameters&gt;
                      íŒŒì¼ ë¡œê±°ì˜ ì¶”ê°€ ë§¤ê°œ ë³€ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
-                     ì´ ìŠ¤ìœ„ì¹˜ê°€ ìžˆë‹¤ëŠ” ê²ƒì€
+                     ì´ ìŠ¤ìœ„ì¹˜ê°€ ìžˆë‹¤ëŠ” ê²ƒì€ 
                      í•´ë‹¹ fileLogger[n] ìŠ¤ìœ„ì¹˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
                      "n"(ìžˆëŠ” ê²½ìš°)ì€ 1~9ì˜ ìˆ«ìžì¼ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
-                     -fileLoggerParametersëŠ” ë°°í¬ëœ íŒŒì¼ ë¡œê±°ì—ì„œë„
+                     -fileLoggerParametersëŠ” ë°°í¬ëœ íŒŒì¼ ë¡œê±°ì—ì„œë„ 
                      ì‚¬ìš©ë©ë‹ˆë‹¤. -distributedFileLoggerì— ëŒ€í•œ ì„¤ëª…ì„ ì°¸ì¡°í•˜ì„¸ìš”.
                      (ì•½ì‹: -flp[n])
                      ì½˜ì†” ë¡œê±°ìš©ìœ¼ë¡œ ë‚˜ì—´ëœ ë™ì¼í•œ ë§¤ê°œ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
                      ë‹¤ìŒê³¼ ê°™ì€ ëª‡ ê°€ì§€ ì¶”ê°€ ë§¤ê°œ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
-                        LogFile--ë¹Œë“œ ë¡œê·¸ê°€ ê¸°ë¡ë˜ëŠ”
+                        LogFile--ë¹Œë“œ ë¡œê·¸ê°€ ê¸°ë¡ë˜ëŠ” 
                             ë¡œê·¸ íŒŒì¼ì˜ ê²½ë¡œìž…ë‹ˆë‹¤.
-                        Append--ë¹Œë“œ ë¡œê·¸ê°€ ë¡œê·¸ íŒŒì¼ì— ì¶”ê°€ë˜ëŠ”ì§€,
-                            ì•„ë‹ˆë©´ ë¡œê·¸ íŒŒì¼ì„ ë®ì–´ì“°ëŠ”ì§€ ì—¬ë¶€ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
+                        Append--ë¹Œë“œ ë¡œê·¸ê°€ ë¡œê·¸ íŒŒì¼ì— ì¶”ê°€ë˜ëŠ”ì§€, 
+                            ì•„ë‹ˆë©´ ë¡œê·¸ íŒŒì¼ì„ ë®ì–´ì“°ëŠ”ì§€ ì—¬ë¶€ë¥¼ ê²°ì •í•©ë‹ˆë‹¤. 
                             ìŠ¤ìœ„ì¹˜ë¥¼ ì„¤ì •í•˜ë©´ ë¹Œë“œ ë¡œê·¸ê°€ ë¡œê·¸ íŒŒì¼ì— ì¶”ê°€ë©ë‹ˆë‹¤.
-                            ìŠ¤ìœ„ì¹˜ë¥¼ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ì¡´ ë¡œê·¸ íŒŒì¼ì˜
+                            ìŠ¤ìœ„ì¹˜ë¥¼ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ì¡´ ë¡œê·¸ íŒŒì¼ì˜ 
                             ì½˜í…ì¸ ë¥¼ ë®ì–´ì”ë‹ˆë‹¤.
                             ê¸°ë³¸ê°’ì€ ë¡œê·¸ íŒŒì¼ì— ì¶”ê°€í•˜ì§€ ì•ŠëŠ” ê²ƒìž…ë‹ˆë‹¤.
                         Encoding--íŒŒì¼ì˜ ì¸ì½”ë”©ì„ ì§€ì •í•©ë‹ˆë‹¤
@@ -955,7 +968,7 @@
         <target state="translated">  -nodeReuse:&lt;parameters&gt;
                      MSBuild ë…¸ë“œë¥¼ ë‹¤ì‹œ ì‚¬ìš©í•˜ê±°ë‚˜ ë‹¤ì‹œ ì‚¬ìš©í•˜ì§€ ì•Šë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤.
                      ë§¤ê°œ ë³€ìˆ˜ëŠ” ë‹¤ìŒê°€ ê°™ìŠµë‹ˆë‹¤.
-                     True --ë¹Œë“œ ì™„ë£Œ í›„ ë…¸ë“œê°€ ìœ ì§€ë˜ê³ 
+                     True --ë¹Œë“œ ì™„ë£Œ í›„ ë…¸ë“œê°€ ìœ ì§€ë˜ê³  
                             í›„ì† ë¹Œë“œì—ì„œ ë‹¤ì‹œ ì‚¬ìš©ë©ë‹ˆë‹¤(ê¸°ë³¸ê°’).
                      False--ë¹Œë“œ ì™„ë£Œ í›„ ë…¸ë“œê°€ ìœ ì§€ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                      (ì•½ì‹: -nr)
@@ -1052,7 +1065,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: í”„ë¡œì íŠ¸ ê²©ë¦¬ ê°’ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: í”„ë¡œì íŠ¸ ê²©ë¦¬ ê°’ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1721,10 +1734,10 @@
     </source>
         <target state="translated">  -restore[:True|False]
                      ë‹¤ë¥¸ ëŒ€ìƒì„ ë¹Œë“œí•˜ê¸° ì „ì— Restoreë¼ëŠ” ëŒ€ìƒì„
-                     ì‹¤í–‰í•˜ê³  ì´ëŸ¬í•œ ëŒ€ìƒì˜ ë¹Œë“œì— ìµœì‹  ë³µì›ëœ
-                     ë¹Œë“œ ë…¼ë¦¬ê°€ ì‚¬ìš©ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
-                     í”„ë¡œì íŠ¸ íŠ¸ë¦¬ë¥¼ ë¹Œë“œí•˜ê¸° ì „ì—
-                     í”„ë¡œì íŠ¸ íŠ¸ë¦¬ì—ì„œ íŒ¨í‚¤ì§€ë¥¼ ë³µì›í•´ì•¼ í•˜ëŠ”
+                     ì‹¤í–‰í•˜ê³  ì´ëŸ¬í•œ ëŒ€ìƒì˜ ë¹Œë“œì— ìµœì‹  ë³µì›ëœ 
+                     ë¹Œë“œ ë…¼ë¦¬ê°€ ì‚¬ìš©ë˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. 
+                     í”„ë¡œì íŠ¸ íŠ¸ë¦¬ë¥¼ ë¹Œë“œí•˜ê¸° ì „ì— 
+                     í”„ë¡œì íŠ¸ íŠ¸ë¦¬ì—ì„œ íŒ¨í‚¤ì§€ë¥¼ ë³µì›í•´ì•¼ í•˜ëŠ” 
                      ê²½ìš°ì— ìœ ìš©í•©ë‹ˆë‹¤. -restoreë¥¼ ì§€ì •í•˜ëŠ” ê²ƒì€
                      -restore:Trueë¥¼ ì§€ì •í•˜ëŠ” ê²ƒê³¼ ë™ì¼í•©ë‹ˆë‹¤. ì´ ë§¤ê°œ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬
                      ì§€ì‹œ íŒŒì¼ì—ì„œ ê°€ì ¸ì˜¤ëŠ” ê°’ì„ ìž¬ì •ì˜í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
@@ -1762,7 +1775,7 @@
     </source>
         <target state="translated">  -profileEvaluation:&lt;file&gt;
                      MSBuild í‰ê°€ë¥¼ í”„ë¡œíŒŒì¼ë§í•˜ê³  ê²°ê³¼ë¥¼ ì§€ì •ëœ íŒŒì¼ì— ê¸°ë¡í•©ë‹ˆë‹¤.
-                     ì§€ì •ëœ íŒŒì¼ì˜ í™•ìž¥ëª…ì´ '.md'ì´ë©´
+                     ì§€ì •ëœ íŒŒì¼ì˜ í™•ìž¥ëª…ì´ '.md'ì´ë©´ 
                      ê²°ê³¼ê°€ Markdown í˜•ì‹ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤.
                      ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ íƒ­ìœ¼ë¡œ êµ¬ë¶„ëœ íŒŒì¼ì´ ìƒì„±ë©ë‹ˆë‹¤.
     </target>
@@ -1781,9 +1794,9 @@
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                     ë³µì›í•˜ëŠ” ë™ì•ˆ í”„ë¡œì íŠ¸ ìˆ˜ì¤€ ì†ì„±ë§Œ ì„¤ì •í•˜ê±°ë‚˜
-                     ìž¬ì •ì˜í•˜ê³ , -property ì¸ìˆ˜ë¡œ ì§€ì •ëœ ì†ì„±ì„
-                     ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. &lt;n&gt;ì€ ì†ì„± ì´ë¦„ì´ê³ 
+                     ë³µì›í•˜ëŠ” ë™ì•ˆ í”„ë¡œì íŠ¸ ìˆ˜ì¤€ ì†ì„±ë§Œ ì„¤ì •í•˜ê±°ë‚˜ 
+                     ìž¬ì •ì˜í•˜ê³ , -property ì¸ìˆ˜ë¡œ ì§€ì •ëœ ì†ì„±ì„ 
+                     ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. &lt;n&gt;ì€ ì†ì„± ì´ë¦„ì´ê³  
                      &lt;v&gt;ëŠ” ì†ì„± ê°’ìž…ë‹ˆë‹¤.
                      ì„¸ë¯¸ì½œë¡  ë˜ëŠ” ì‰¼í‘œë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ì†ì„±ì„ êµ¬ë¶„í•˜ê±°ë‚˜,
                      ê° ì†ì„±ì„ ê°œë³„ì ìœ¼ë¡œ ì§€ì •í•©ë‹ˆë‹¤.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 7936ee85979..004ab82ee63 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: przeÅ‚Ä…cznika -noAutoResponse nie moÅ¼na okreÅ›liÄ‡ w pliku autoodpowiedzi MSBuild.rsp ani w Å¼adnym pliku odpowiedzi, do ktÃ³rego odwoÅ‚uje siÄ™ plik autoodpowiedzi.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -143,7 +148,7 @@
                      interakcyjnoÅ›Ä‡ nie jest oczekiwana.
                      Podanie parametru -interactive jest rÃ³wnoznaczne
                      z podaniem parametru -interactive:true. UÅ¼yj tego
-                     parametru, aby przesÅ‚oniÄ‡ wartoÅ›Ä‡ pochodzÄ…cÄ… z pliku
+                     parametru, aby przesÅ‚oniÄ‡ wartoÅ›Ä‡ pochodzÄ…cÄ… z pliku 
                      odpowiedzi.
     </target>
         <note>
@@ -172,19 +177,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Powoduje, Å¼e program MSBuild kompiluje kaÅ¼dy projekt
-                     w sposÃ³b izolowany.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Jest to bardziej restrykcyjny tryb programu MSBuild, poniewaÅ¼
-                     wymaga, aby graf projektu byÅ‚ statycznie wykrywalny podczas
-                     oceny, ale moÅ¼e usprawniÄ‡ planowanie i zmniejszyÄ‡
-                     obciÄ…Å¼enie pamiÄ™ci podczas kompilowania duÅ¼ego zestawu
-                     projektÃ³w.
-                     (KrÃ³tka wersja: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Ta flaga jest eksperymentalna i moÅ¼e nie dziaÅ‚aÄ‡ w oczekiwany
-                     sposÃ³b.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -205,7 +216,7 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -graphBuild[:True|False]
-                     Powoduje, Å¼e program MSBuild tworzy i kompiluje graf
+                     Powoduje, Å¼e program MSBuild tworzy i kompiluje graf                 
                      projektu.
 
                      Tworzenie grafu obejmuje identyfikowanie odwoÅ‚aÅ„ do
@@ -304,7 +315,7 @@
     </source>
         <target state="needs-review-translation">
  -warnNotAsError[:code[;code2]]
- Lista kodÃ³w ostrzeÅ¼eÅ„, ktÃ³re majÄ… byÄ‡ traktowane jako bÅ‚Ä™dy.
+ Lista kodÃ³w ostrzeÅ¼eÅ„, ktÃ³re majÄ… byÄ‡ traktowane jako bÅ‚Ä™dy. 
  Rozdziel Å›rednik lub przecinek
  wiele kodÃ³w ostrzeÅ¼eÅ„. Nie ma Å¼adnego efektu, jeÅ›li przeÅ‚Ä…cznik -warnaserror
                      switch is not set.
@@ -374,7 +385,7 @@
                      osobno.
 
                      Wszelkie pliki odpowiedzi o nazwie â€žmsbuild.rspâ€ bÄ™dÄ… automatycznie
-                     wykorzystywane z nastÄ™pujÄ…cych lokalizacji:
+                     wykorzystywane z nastÄ™pujÄ…cych lokalizacji: 
                      (1) katalog programu msbuild.exe
                      (2) katalog pierwszej kompilacji projektu lub rozwiÄ…zania
 </target>
@@ -686,11 +697,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;plik pamiÄ™ci podrÄ™cznej&gt;...
-                     Rozdzielana Å›rednikami lista wejÅ›ciowych plikÃ³w pamiÄ™ci podrÄ™cznej, z ktÃ³rych program MSBuild
-                     bÄ™dzie odczytywaÄ‡ wyniki kompilacji.
-                     Ustawienie tej opcji wÅ‚Ä…cza teÅ¼ kompilacje izolowane (-isolate).
-                     (KrÃ³tka wersja: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -704,11 +714,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[plik pamiÄ™ci podrÄ™cznej]
-                     Plik pamiÄ™ci podrÄ™cznej, w ktÃ³rym program MSBuild zapisze zawartoÅ›Ä‡
-                     swoich pamiÄ™ci podrÄ™cznych wynikÃ³w kompilacji po zakoÅ„czeniu kompilacji.
-                     Ustawienie tej opcji wÅ‚Ä…cza teÅ¼ kompilacje izolowane (-isolate).
-                     (KrÃ³tka wersja: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -926,7 +936,7 @@
                      DostÄ™pne sÄ… parametry takie same, jak podane dla rejestratora
                      konsoli. DostÄ™pne sÄ… rÃ³wnieÅ¼ dodatkowe parametry:
                        LogFile â€” Å›cieÅ¼ka do pliku dziennika, w ktÃ³rym bÄ™dzie
-                                 zapisywany dziennik kompilacji.
+                                 zapisywany dziennik kompilacji. 
                        Append â€” okreÅ›la, czy plik dziennika kompilacji zostanie
                                 doÅ‚Ä…czony do pliku dziennika, czy go zastÄ…pi.
                                 Ustawienie tego przeÅ‚Ä…cznika powoduje doÅ‚Ä…czenie dziennika kompilacji
@@ -940,8 +950,8 @@
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1064,7 +1074,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: WartoÅ›Ä‡ projektÃ³w izolacji jest nieprawidÅ‚owa. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: WartoÅ›Ä‡ projektÃ³w izolacji jest nieprawidÅ‚owa. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1733,10 +1743,10 @@ dziennikÃ³w                     tekstowych i wykorzystaÄ‡ w innych narzÄ™dziach
     </source>
         <target state="translated">  -restore[:True|False]
                      Uruchamia element docelowy o nazwie Restore przed skompilowaniem
-                     innych elementÃ³w docelowych i zapewnia, Å¼e kompilacja tych
-                     elementÃ³w docelowych korzysta z najnowszej logiki przywrÃ³conej
-                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga
-                     przywrÃ³cenia pakietÃ³w przed ich skompilowaniem. Podanie parametru
+                     innych elementÃ³w docelowych i zapewnia, Å¼e kompilacja tych 
+                     elementÃ³w docelowych korzysta z najnowszej logiki przywrÃ³conej 
+                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga 
+                     przywrÃ³cenia pakietÃ³w przed ich skompilowaniem. Podanie parametru 
                      -restore jest rÃ³wnoznaczne z podaniem parametru -restore:True.
                      Za pomocÄ… tego parametru moÅ¼na przesÅ‚oniÄ‡ wartoÅ›Ä‡ pochodzÄ…cÄ…
                      z pliku odpowiedzi.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 45ea90cb386..e2532f03bad 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: A opÃ§Ã£o /noAutoResponse nÃ£o pode ser especificada no arquivo de resposta automÃ¡tica MSBuild.rsp nem em qualquer arquivo de resposta usado como referÃªncia para o arquivo de resposta automÃ¡tica.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -172,16 +177,25 @@ arquivo de resposta.
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Faz o MSBuild compilar cada projeto
-isoladamente.
-                     Esse Ã© um modo mais restritivo do MSBuild, pois requer
-                     que o grÃ¡fico do projeto seja estatisticamente detectÃ¡vel no
-                     tempo de avaliaÃ§Ã£o, mas pode melhorar o agendamento e reduzir
-                     a sobrecarga de memÃ³ria ao compilar um grande conjunto de projetos.
-                     (Forma abreviada: -isolate)
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
+
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Esse sinalizador Ã© experimental e pode nÃ£o funcionar como pretendido.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -638,10 +652,10 @@ isoladamente.
                      MSBuild will use up to the number of processors on the
                      computer. (Short form: -m[:n])
       </source>
-        <target state="translated">  -maxCpuCount[:n] Especifica o nÃºmero mÃ¡ximo de processos simultÃ¢neos a serem
+        <target state="translated">  -maxCpuCount[:n] Especifica o nÃºmero mÃ¡ximo de processos simultÃ¢neos a serem 
                      compilados. Se a opÃ§Ã£o nÃ£o for usada, o valor padrÃ£o
                      usado serÃ¡ 1. Se a opÃ§Ã£o for usada sem um valor, o
-                     MSBuild usarÃ¡ o nÃºmero de processadores do
+                     MSBuild usarÃ¡ o nÃºmero de processadores do 
                      computador. (Forma abreviada: -m[:n])
       </target>
         <note>
@@ -659,7 +673,7 @@ isoladamente.
         <target state="translated">Exemplos:
 
         MSBuild MyApp.sln -t:Rebuild -p:Configuration=Release
-        MSBuild MyApp.csproj -t:Clean
+        MSBuild MyApp.csproj -t:Clean 
                              -p:Configuration=Debug;TargetFrameworkVersion=v3.5
     </target>
         <note>
@@ -677,11 +691,10 @@ isoladamente.
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Lista separada por ponto e vÃ­rgula de arquivos de cache de entrada dos quais o MSBuild
-                     lerÃ¡ os resultados do build.
-                     A definiÃ§Ã£o dessa opÃ§Ã£o tambÃ©m habilita os builds isolados (-isolate).
-                     (forma abreviada: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -695,11 +708,11 @@ isoladamente.
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     Arquivo de cache de saÃ­da no qual o MSBuild gravarÃ¡ o conteÃºdo
-                     dos caches de resultado do build no final do build.
-                     A configuraÃ§Ã£o dessa opÃ§Ã£o tambÃ©m habilita builds isolado (-isolate).
-                     (forma abreviada: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -821,12 +834,12 @@ isoladamente.
                      10 file loggers to be attached. (Short form: -fl[n])
     </source>
         <target state="translated">  -fileLogger[n] Registra a saÃ­da do build em um arquivo. Por padrÃ£o,
-                     o arquivo estÃ¡ no diretÃ³rio atual e tem o nome
+                     o arquivo estÃ¡ no diretÃ³rio atual e tem o nome 
                      "msbuild[n].log". Os eventos de todos os nÃ³s sÃ£o combinados em
                      um Ãºnico log. A localizaÃ§Ã£o do arquivo e outros
-                     parÃ¢metros do fileLogger pode ser especificada por meio
+                     parÃ¢metros do fileLogger pode ser especificada por meio 
                      do acrÃ©scimo da opÃ§Ã£o "-fileLoggerParameters[n]".
-                     "n", se presente, pode ser um dÃ­gito de 1 a 9, permitindo que atÃ©
+                     "n", se presente, pode ser um dÃ­gito de 1 a 9, permitindo que atÃ© 
                      10 agentes de arquivo sejam anexados. (Forma abreviada: -fl[n])
     </target>
         <note>
@@ -979,14 +992,14 @@ isoladamente.
                      Example:
                        -pp:out.txt
     </source>
-        <target state="translated">  -preprocess[:arquivo]
+        <target state="translated">  -preprocess[:arquivo] 
                      Cria um arquivo de projeto Ãºnico e agregado
                      embutindo todos os arquivos que poderiam ser importados durante um
                      build, com seus limites marcados. Isso pode ser
                      Ãºtil para descobrir quais arquivos sÃ£o importados,
                      de qual localizaÃ§Ã£o e como contribuirÃ£o para
                      o build. Por padrÃ£o, a saÃ­da Ã© gravada na
-                     janela do console. Se o caminho de um arquivo de saÃ­da
+                     janela do console. Se o caminho de um arquivo de saÃ­da 
                      for fornecido, ele serÃ¡ usado.
                      (Forma abreviada: -pp)
                      Exemplo:
@@ -1053,7 +1066,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: O valor de projetos isolados nÃ£o Ã© vÃ¡lido. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: O valor de projetos isolados nÃ£o Ã© vÃ¡lido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1567,7 +1580,7 @@ isoladamente.
                        -warnAsError:MSB4130
 
                      Quando um aviso for tratado como um erro, o destino continuarÃ¡
-                     a ser executado como se ele fosse um aviso, mas o
+                     a ser executado como se ele fosse um aviso, mas o 
                      build geral falharÃ¡.
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index d1419f29c22..320c30cce2f 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: ÐºÐ»ÑŽÑ‡ noAutoResponse Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ ÑƒÐºÐ°Ð·Ð°Ð½ Ð² Ñ„Ð°Ð¹Ð»Ðµ Ð°Ð²Ñ‚Ð¾Ð¾Ñ‚Ð²ÐµÑ‚Ð° MSBuild.rsp Ð¸Ð»Ð¸ Ð² Ð»ÑŽÐ±Ð¾Ð¼ Ð´Ñ€ÑƒÐ³Ð¾Ð¼ Ñ„Ð°Ð¹Ð»Ðµ Ð¾Ñ‚Ð²ÐµÑ‚Ð°, Ð½Ð° ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ñ„Ð°Ð¹Ð» Ð°Ð²Ñ‚Ð¾Ð¾Ñ‚Ð²ÐµÑ‚Ð° ÑÑÑ‹Ð»Ð°ÐµÑ‚ÑÑ.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -170,16 +175,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Ð¡Ð¾Ð¾Ð±Ñ‰Ð°ÐµÑ‚ MSBuild, Ñ‡Ñ‚Ð¾ Ð½ÑƒÐ¶Ð½Ð¾ ÑÐ¾Ð±Ð¸Ñ€Ð°Ñ‚ÑŒ ÐºÐ°Ð¶Ð´Ñ‹Ð¹ Ð¿Ñ€Ð¾ÐµÐºÑ‚ Ð¿Ð¾ Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Ð­Ñ‚Ð¾ Ð±Ð¾Ð»ÐµÐµ ÑÑ‚Ñ€Ð¾Ð³Ð¸Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ MSBuild, Ñ‚Ð°Ðº ÐºÐ°Ðº Ð¾Ð½ Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚,
-                     Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð³Ñ€Ð°Ñ„ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° Ð¼Ð¾Ð¶Ð½Ð¾ Ð±Ñ‹Ð»Ð¾ ÑÑ‚Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð¾Ð±Ð½Ð°Ñ€ÑƒÐ¶Ð¸Ñ‚ÑŒ
-                     Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¾Ñ†ÐµÐ½ÐºÐ¸, Ð½Ð¾ Ð¾Ð½ Ð¼Ð¾Ð¶ÐµÑ‚ ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ñ‚ÑŒ Ð¿Ð»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¸ ÑÐ¾ÐºÑ€Ð°Ñ‚Ð¸Ñ‚ÑŒ
-                     Ð¸Ð·Ð´ÐµÑ€Ð¶ÐºÐ¸ Ð¿Ð°Ð¼ÑÑ‚Ð¸ Ð¿Ñ€Ð¸ ÑÐ±Ð¾Ñ€ÐºÐµ Ð±Ð¾Ð»ÑŒÑˆÐ¸Ñ… Ð½Ð°Ð±Ð¾Ñ€Ð¾Ð² Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð¾Ð².
-                     (ÐšÑ€Ð°Ñ‚ÐºÐ°Ñ Ñ„Ð¾Ñ€Ð¼Ð°: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Ð­Ñ‚Ð¾ ÑÐºÑÐ¿ÐµÑ€Ð¸Ð¼ÐµÐ½Ñ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ñ„Ð»Ð°Ð³. ÐœÐ¾Ð¶ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð½Ðµ Ñ‚Ð°Ðº, ÐºÐ°Ðº Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -675,11 +689,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;Ñ„Ð°Ð¹Ð»_ÐºÑÑˆÐ°&gt;...
-                     Ð Ð°Ð·Ð´ÐµÐ»ÐµÐ½Ð½Ñ‹Ð¹ Ñ‚Ð¾Ñ‡ÐºÐ°Ð¼ Ñ Ð·Ð°Ð¿ÑÑ‚Ð¾Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ñ… Ñ„Ð°Ð¹Ð»Ð¾Ð² ÐºÑÑˆÐ°, Ð¾Ñ‚ÐºÑƒÐ´Ð° MSBuild
-                     Ð±ÑƒÐ´ÐµÑ‚ ÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°Ñ‚ÑŒ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹.
-                     Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ ÑÑ‚Ð¾Ð³Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð° Ñ‚Ð°ÐºÐ¶Ðµ Ð²ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ Ð¸Ð·Ð¾Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÑÐ±Ð¾Ñ€ÐºÐ¸ (-isolate).
-                     (ÐšÑ€Ð°Ñ‚ÐºÐ°Ñ Ñ„Ð¾Ñ€Ð¼Ð°: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -693,11 +706,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[Ñ„Ð°Ð¹Ð»_ÐºÑÑˆÐ°]
-                     Ð’Ñ‹Ñ…Ð¾Ð´Ð½Ð¾Ð¹ Ñ„Ð°Ð¹Ð» ÐºÑÑˆÐ°, Ð³Ð´Ðµ MSBuild Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°Ð¿Ð¸ÑÑ‹Ð²Ð°Ñ‚ÑŒ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ
-                     Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð° ÐºÑÑˆÐ° ÑÐ±Ð¾Ñ€ÐºÐ¸ Ð² ÐºÐ¾Ð½Ñ†Ðµ.
-                     ÐŸÑ€Ð¸ Ð·Ð°Ð´Ð°Ð½Ð¸Ð¸ ÑÑ‚Ð¾Ð³Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð° Ñ‚Ð°ÐºÐ¶Ðµ Ð²ÐºÐ»ÑŽÑ‡Ð°ÑŽÑ‚ÑÑ Ð¸Ð·Ð¾Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÑÐ±Ð¾Ñ€ÐºÐ¸ (-isolate).
-                     (ÐšÑ€Ð°Ñ‚ÐºÐ°Ñ Ñ„Ð¾Ñ€Ð¼Ð°: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1051,7 +1064,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¸Ð·Ð¾Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð¾Ð² ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð½ÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ñ‹Ð¼. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¸Ð·Ð¾Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð¾Ð² ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð½ÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ñ‹Ð¼. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index e022aa20e63..d5c6710a77d 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse anahtarÄ±, MSBuild.rsp otomatik yanÄ±t dosyasÄ±nda ve bu dosyanÄ±n baÅŸvuruda bulunduÄŸu herhangi bir yanÄ±t dosyasÄ±nda belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -141,7 +146,7 @@
                      izin verildiÄŸini gÃ¶sterir.  EtkileÅŸimin beklenmediÄŸi
                      otomatik bir senaryoda bu baÄŸÄ±msÄ±z deÄŸiÅŸkeni
                      kullanmayÄ±n.
-                     -interactive deÄŸerinin belirtilmesi, -interactive:true
+                     -interactive deÄŸerinin belirtilmesi, -interactive:true 
                      deÄŸerinin belirtilmesiyle aynÄ±dÄ±r.  Parametreyi, yanÄ±t
                      dosyasÄ±ndan gelen bir deÄŸeri geÃ§ersiz kÄ±lmak iÃ§in kullanÄ±n.
     </target>
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuild tarafÄ±ndan her projenin yalÄ±tÄ±lmÄ±ÅŸ olarak oluÅŸturulmasÄ±na yol aÃ§ar.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Bu mod, deÄŸerlendirme sÄ±rasÄ±nda proje grafiÄŸinin
-                     istatistiksel olarak keÅŸfedilebilmesini gerektirdiÄŸinden
-                     nispeten daha kÄ±sÄ±tlayÄ±cÄ± bir MSBuild modudur, ancak Ã§ok sayÄ±da
-                     proje oluÅŸturulurken zamanlamayÄ± geliÅŸtirebilir ve bellek ek yÃ¼kÃ¼nÃ¼ azaltabilir.
-                     (KÄ±sa biÃ§im: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Bu bayrak deneme amaÃ§lÄ±dÄ±r ve amaÃ§landÄ±ÄŸÄ± gibi Ã§alÄ±ÅŸmayabilir.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -426,7 +440,7 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje dÃ¼zeyi Ã¶zellikleri ayarlayÄ±n veya geÃ§ersiz kÄ±lÄ±n. &lt;n&gt;
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje dÃ¼zeyi Ã¶zellikleri ayarlayÄ±n veya geÃ§ersiz kÄ±lÄ±n. &lt;n&gt; 
                      Ã¶zelliÄŸin adÄ± ve &lt;v&gt; Ã¶zelliÄŸin deÄŸeridir. Birden Ã§ok
                      Ã¶zelliÄŸi birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya virgÃ¼l
                      kullanÄ±n veya her Ã¶zelliÄŸi ayrÄ± ayrÄ± belirtin. (KÄ±sa biÃ§im: -p)
@@ -467,7 +481,7 @@
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ derlemesi&gt; sÃ¶z dizimi ÅŸÃ¶yledir:
                        {&lt;derleme adÄ±&gt;[,&lt;strong name&gt;] | &lt;derleme dosyasÄ±&gt;}
                      GÃ¼nlÃ¼kÃ§Ã¼ seÃ§enekleri, MSBuild'in gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ oluÅŸturma biÃ§imini belirtir.
-                     &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri &gt; isteÄŸe baÄŸlÄ±dÄ±r ve tam olarak
+                     &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri &gt; isteÄŸe baÄŸlÄ±dÄ±r ve tam olarak 
                      yazdÄ±ÄŸÄ±nÄ±z ÅŸekliyle gÃ¼nlÃ¼kÃ§Ã¼ye geÃ§irilir. (KÄ±sa biÃ§im: -l)
                      Ã–rnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -676,11 +690,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;Ã¶nbellekDosyasÄ±&gt;...
-                     MSBuild'in derleme sonuÃ§larÄ±nÄ± okuyacaÄŸÄ± giriÅŸ
-                     Ã¶nbellek dosyalarÄ±nÄ±n noktalÄ± virgÃ¼lle ayrÄ±lmÄ±ÅŸ listesi.
-                     AyarlandÄ±ÄŸÄ±nda yalÄ±tÄ±lmÄ±ÅŸ derlemeler de aÃ§Ä±lÄ±r (-isolate).
-                     (kÄ±sa biÃ§im: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -694,11 +707,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[Ã¶nbellekDosyasÄ±]
-                     MSBuildâ€™in derleme sonunda derleme sonucu Ã¶nbelleklerinin
-                     iÃ§eriÄŸini yazacaÄŸÄ± Ã§Ä±kÄ±ÅŸ Ã¶nbellek dosyasÄ±.
-                     Bu aÃ§Ä±ldÄ±ÄŸÄ±nda yalÄ±tÄ±lmÄ±ÅŸ derlemeler (-isolate) de aÃ§Ä±lÄ±r.
-                     (kÄ±sa biÃ§im: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -767,9 +780,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantÄ±lar&gt;
-                     Hangi proje dosyasÄ±nÄ±n oluÅŸturulacaÄŸÄ± belirlenirken
-                     yoksayÄ±lacak uzantÄ±larÄ±n listesi. Birden Ã§ok uzantÄ±yÄ±
-                     birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya
+                     Hangi proje dosyasÄ±nÄ±n oluÅŸturulacaÄŸÄ± belirlenirken 
+                     yoksayÄ±lacak uzantÄ±larÄ±n listesi. Birden Ã§ok uzantÄ±yÄ± 
+                     birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya 
                      virgÃ¼l kullanÄ±n.
                      (KÄ±sa biÃ§im: -ignore)
                      Ã–rnek:
@@ -795,8 +808,8 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;sÃ¼rÃ¼m&gt;
                      Derleme sÄ±rasÄ±nda kullanÄ±lacak MSBuild AraÃ§ KÃ¼mesinin
-                     (gÃ¶revler, hedefler vb.) sÃ¼rÃ¼mÃ¼. Bu sÃ¼rÃ¼m, tek tek projelerde
-                     belirtilen sÃ¼rÃ¼mleri geÃ§ersiz kÄ±lar. (KÄ±sa biÃ§im:
+                     (gÃ¶revler, hedefler vb.) sÃ¼rÃ¼mÃ¼. Bu sÃ¼rÃ¼m, tek tek projelerde 
+                     belirtilen sÃ¼rÃ¼mleri geÃ§ersiz kÄ±lar. (KÄ±sa biÃ§im: 
                      -tv)
                      Ã–rnek:
                        -toolsVersion:3.5
@@ -855,14 +868,14 @@
         <target state="translated">  -distributedFileLogger
                      Derleme Ã§Ä±kÄ±ÅŸÄ±nÄ±, her MSBuild dÃ¼ÄŸÃ¼mÃ¼ iÃ§in bir gÃ¼nlÃ¼k
                      dosyasÄ± olmak Ã¼zere birden Ã§ok gÃ¼nlÃ¼k dosyasÄ±na kaydeder. Bu
-                     dosyalarÄ±n ilk konumu geÃ§erli dizindir. DosyalarÄ±n
-                     varsayÄ±lan adÄ± "MSBuild&lt;dÃ¼ÄŸÃ¼mkimliÄŸi&gt;.log"dur.
-                     DosyalarÄ±n konumu ve fileLogger'Ä±n diÄŸer parametreleri
+                     dosyalarÄ±n ilk konumu geÃ§erli dizindir. DosyalarÄ±n 
+                     varsayÄ±lan adÄ± "MSBuild&lt;dÃ¼ÄŸÃ¼mkimliÄŸi&gt;.log"dur. 
+                     DosyalarÄ±n konumu ve fileLogger'Ä±n diÄŸer parametreleri 
                      "/fileLoggerParameters" anahtarÄ±nÄ±n eklenmesi yoluyla
                      belirtilebilir.
 
                      GÃ¼nlÃ¼k dosyasÄ± adÄ± fileLoggerParameters anahtarÄ±
-                     aracÄ±lÄ±ÄŸÄ±yla ayarlanÄ±rsa daÄŸÄ±tÄ±lmÄ±ÅŸ gÃ¼nlÃ¼kÃ§Ã¼ fileName
+                     aracÄ±lÄ±ÄŸÄ±yla ayarlanÄ±rsa daÄŸÄ±tÄ±lmÄ±ÅŸ gÃ¼nlÃ¼kÃ§Ã¼ fileName 
                      deÄŸerini ÅŸablon olarak kullanÄ±p her dÃ¼ÄŸÃ¼mÃ¼n gÃ¼nlÃ¼k dosyasÄ±nÄ±
                      oluÅŸturmak iÃ§in bu fileName deÄŸerine dÃ¼ÄŸÃ¼m kimliÄŸini ekler.
     </target>
@@ -907,32 +920,32 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya gÃ¼nlÃ¼kÃ§Ã¼leri iÃ§in ek parametreler saÄŸlar.
-                     Bu anahtarÄ±n olmasÄ± karÅŸÄ±lÄ±k gelen -fileLogger[n]
+                     Bu anahtarÄ±n olmasÄ± karÅŸÄ±lÄ±k gelen -fileLogger[n] 
                      anahtarÄ±nÄ±n olduÄŸu anlamÄ±na gelir.
                      "n" varsa, 1-9 arasÄ±nda bir rakam olabilir.
-                     DaÄŸÄ±tÄ±lmÄ±ÅŸ dosya gÃ¼nlÃ¼kÃ§Ã¼leri varsa -fileLoggerParameters
-                     bunlar tarafÄ±ndan da kullanÄ±lÄ±r; -distributedFileLogger
+                     DaÄŸÄ±tÄ±lmÄ±ÅŸ dosya gÃ¼nlÃ¼kÃ§Ã¼leri varsa -fileLoggerParameters 
+                     bunlar tarafÄ±ndan da kullanÄ±lÄ±r; -distributedFileLogger 
                      aÃ§Ä±klamasÄ±na bakÄ±n.
                      (KÄ±sa biÃ§im: -flp[n])
-                     Konsol gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in listelenenlerle aynÄ± parametreler
+                     Konsol gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in listelenenlerle aynÄ± parametreler 
                      kullanÄ±labilir. KullanÄ±labilecek bazÄ± ek parametreler:
-                        LogFile--OluÅŸturma gÃ¼nlÃ¼ÄŸÃ¼nÃ¼n yazÄ±lacaÄŸÄ± gÃ¼nlÃ¼k
+                        LogFile--OluÅŸturma gÃ¼nlÃ¼ÄŸÃ¼nÃ¼n yazÄ±lacaÄŸÄ± gÃ¼nlÃ¼k 
                             dosyasÄ±nÄ±n yolu.
-                        Append--Derleme gÃ¼nlÃ¼ÄŸÃ¼nÃ¼n gÃ¼n dosyasÄ±nÄ±n sonuna mÄ±
-                            ekleneceÄŸini yoksa Ã¼zerine mi yazÄ±lacaÄŸÄ±nÄ±
-                            belirler. Anahtar ayarlandÄ±ÄŸÄ±nda oluÅŸturma gÃ¼nlÃ¼ÄŸÃ¼
-                            dosyanÄ±n sonuna eklenir. Anahtar ayarlanmadÄ±ÄŸÄ±nda
-                            varolan gÃ¼nlÃ¼k dosyasÄ±nÄ±n Ã¼zerine yazÄ±lÄ±r.
+                        Append--Derleme gÃ¼nlÃ¼ÄŸÃ¼nÃ¼n gÃ¼n dosyasÄ±nÄ±n sonuna mÄ± 
+                            ekleneceÄŸini yoksa Ã¼zerine mi yazÄ±lacaÄŸÄ±nÄ± 
+                            belirler. Anahtar ayarlandÄ±ÄŸÄ±nda oluÅŸturma gÃ¼nlÃ¼ÄŸÃ¼ 
+                            dosyanÄ±n sonuna eklenir. Anahtar ayarlanmadÄ±ÄŸÄ±nda 
+                            varolan gÃ¼nlÃ¼k dosyasÄ±nÄ±n Ã¼zerine yazÄ±lÄ±r. 
                             VarsayÄ±lan: gÃ¼nlÃ¼k dosyasÄ±nÄ±n sonuna eklenmez.
-                        Encoding--DosyanÄ±n kodlamasÄ±nÄ± belirtir; Ã¶rneÄŸin,
+                        Encoding--DosyanÄ±n kodlamasÄ±nÄ± belirtir; Ã¶rneÄŸin, 
                             UTF-8, Unicode veya ASCII
                      VarsayÄ±lan ayrÄ±ntÄ± dÃ¼zeyi ayarÄ± Detailed'dÄ±r.
                      Ã–rnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1056,7 +1069,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Projeleri yalÄ±tma deÄŸeri geÃ§erli deÄŸil. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Projeleri yalÄ±tma deÄŸeri geÃ§erli deÄŸil. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 7ebc8a9527c..35be029857f 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: ä¸èƒ½åœ¨ MSBuild.rsp è‡ªåŠ¨å“åº”æ–‡ä»¶ä¸­æˆ–ç”±è¯¥è‡ªåŠ¨å“åº”æ–‡ä»¶å¼•ç”¨çš„ä»»ä½•å“åº”æ–‡ä»¶ä¸­æŒ‡å®š -noAutoResponse å¼€å…³ã€‚</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     ä½¿ MSBuild ç‹¬ç«‹ç”Ÿæˆæ¯ä¸ªé¡¹ç›®ã€‚
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     è¿™æ˜¯ MSBuild æ›´å…·é™åˆ¶æ€§çš„æ¨¡å¼ï¼Œå› ä¸ºå®ƒè¦æ±‚
-                     å¯åœ¨è¯„ä¼°æ—¶é™æ€åœ°å‘çŽ°é¡¹ç›®
-                     å…³ç³»å›¾ï¼Œä½†å¯åœ¨ç”Ÿæˆå¤§åž‹é¡¹ç›®é›†æ—¶
-                     æ”¹å–„è®¡åˆ’å¹¶é™ä½Žå†…å­˜å¼€é”€ã€‚
-                     (ç¼©å†™: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     æ­¤æ ‡è®°å¤„äºŽè¯•éªŒé˜¶æ®µï¼Œå¯èƒ½æ— æ³•æŒ‰é¢„æœŸå·¥ä½œã€‚
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -613,10 +627,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate     ä¾æ®é»˜è®¤æž¶æž„éªŒè¯é¡¹ç›®ã€‚(ç¼©å†™:
+        <target state="translated">  -validate     ä¾æ®é»˜è®¤æž¶æž„éªŒè¯é¡¹ç›®ã€‚(ç¼©å†™: 
            -val)
 
- -validate:&lt;schema&gt; ä¾æ®æŒ‡å®šçš„æž¶æž„éªŒè¯é¡¹ç›®ã€‚(ç¼©å†™:
+ -validate:&lt;schema&gt; ä¾æ®æŒ‡å®šçš„æž¶æž„éªŒè¯é¡¹ç›®ã€‚(ç¼©å†™: 
            -val)
            ç¤ºä¾‹:
             -validate:MyExtendedBuildSchema.xsd
@@ -676,11 +690,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     è¾“å…¥ç¼“å­˜æ–‡ä»¶çš„åˆ†å·åˆ†éš”åˆ—è¡¨ï¼ŒMSBuild
-                     å°†ä»Žè¿™äº›æ–‡ä»¶ä¸­è¯»å–ç”Ÿæˆç»“æžœã€‚
-                     è®¾ç½®æ­¤åˆ—è¡¨è¿˜å°†æ‰“å¼€åˆ†éš”çš„ç”Ÿæˆ(-isolate)ã€‚
-                     (ç¼©å†™: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -694,10 +707,10 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     è¾“å‡ºç¼“å­˜æ–‡ä»¶ï¼ŒMSBuild å°†åœ¨
-                     ç”Ÿæˆç»“æŸæ—¶å†™å…¥å…¶ç”Ÿæˆç»“æžœç¼“å­˜çš„å†…å®¹ã€‚
-                     è®¾ç½®å®ƒä¹Ÿä¼šæ‰“å¼€éš”ç¦»çš„ç”Ÿæˆ (-isolate).
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </target>
         <note>
@@ -795,7 +808,7 @@
         <target state="translated">  -toolsversion:&lt;version&gt;
            è¦åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­ä½¿ç”¨çš„ MSBuild å·¥å…·é›†
            (ä»»åŠ¡ã€ç›®æ ‡ç­‰)çš„ç‰ˆæœ¬ã€‚æ­¤ç‰ˆæœ¬å°†é‡å†™
-           å„ä¸ªé¡¹ç›®æŒ‡å®šçš„ç‰ˆæœ¬ã€‚(ç¼©å†™:
+           å„ä¸ªé¡¹ç›®æŒ‡å®šçš„ç‰ˆæœ¬ã€‚(ç¼©å†™: 
            -tv)
            ç¤ºä¾‹:
             -toolsversion:3.5
@@ -851,17 +864,17 @@
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger
+        <target state="translated">  -distributedFileLogger                            
            å°†ç”Ÿæˆè¾“å‡ºè®°å½•åˆ°å¤šä¸ªæ—¥å¿—æ–‡ä»¶ï¼Œæ¯ä¸ª MSBuild èŠ‚ç‚¹
            ä¸€ä¸ªæ—¥å¿—æ–‡ä»¶ã€‚è¿™äº›æ–‡ä»¶çš„åˆå§‹ä½ç½®ä¸º
            å½“å‰ç›®å½•ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™äº›æ–‡ä»¶åä¸º
            â€œMSBuild&lt;nodeid&gt;.logâ€ã€‚å¯é€šè¿‡æ·»åŠ 
-           â€œ-fileLoggerParametersâ€å¼€å…³æ¥æŒ‡å®š
+           â€œ-fileLoggerParametersâ€å¼€å…³æ¥æŒ‡å®š 
            è¿™äº›æ–‡ä»¶çš„ä½ç½®å’Œ fileLogger çš„å…¶ä»–å‚æ•°ã€‚
 
            å¦‚æžœæ—¥å¿—æ–‡ä»¶åæ˜¯é€šè¿‡ fileLoggerParameters
            å¼€å…³è®¾ç½®çš„ï¼Œåˆ†å¸ƒå¼è®°å½•å™¨å°†ä½¿ç”¨ fileName ä½œä¸º
-           æ¨¡æ¿å¹¶å°†èŠ‚ç‚¹ ID é™„åŠ åˆ°æ­¤ fileName
+           æ¨¡æ¿å¹¶å°†èŠ‚ç‚¹ ID é™„åŠ åˆ°æ­¤ fileName 
            ä»¥ä¾¿ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»ºä¸€ä¸ªæ—¥å¿—æ–‡ä»¶ã€‚
     </target>
         <note>
@@ -903,12 +916,12 @@
                        -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </source>
-        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;
+        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;                
            ä¸ºæ–‡ä»¶è®°å½•å™¨æä¾›ä»»ä½•é¢å¤–çš„å‚æ•°ã€‚
            å­˜åœ¨æ­¤å¼€å…³æ„å‘³ç€
            å­˜åœ¨å¯¹åº”çš„ -filelogger[n] å¼€å…³ã€‚
           â€œnâ€(å¦‚æžœå­˜åœ¨)å¯ä»¥ä¸º 1-9 çš„æ•°å­—ã€‚
-           ä»»ä½•åˆ†å¸ƒå¼æ–‡ä»¶è®°å½•å™¨ä¹Ÿå¯ä»¥ä½¿ç”¨
+           ä»»ä½•åˆ†å¸ƒå¼æ–‡ä»¶è®°å½•å™¨ä¹Ÿå¯ä»¥ä½¿ç”¨ 
            -fileloggerparametersï¼Œå…·ä½“å¯å‚é˜… -distributedFileLogger çš„è¯´æ˜Žã€‚
            (ç¼©å†™: -flp[n])
            ä¸ºæŽ§åˆ¶å°è®°å½•å™¨åˆ—å‡ºçš„ç›¸åŒå‚æ•°
@@ -928,8 +941,8 @@
             -fileLoggerParameters:LogFile=MyLog.log;Append;
                       Verbosity=diagnostic;Encoding=UTF-8
 
-            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-            -flp1:warningsonly;logfile=msbuild.wrn
+            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+            -flp1:warningsonly;logfile=msbuild.wrn 
             -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1052,7 +1065,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: ç‹¬ç«‹é¡¹ç›®å€¼æ— æ•ˆã€‚{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: ç‹¬ç«‹é¡¹ç›®å€¼æ— æ•ˆã€‚{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 69af1f4057a..5a5ddb1582c 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -28,6 +28,11 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse åƒæ•¸ä¸èƒ½åœ¨ MSBuild.rsp è‡ªå‹•å›žæ‡‰æª”ä¸­æŒ‡å®šï¼Œä¹Ÿä¸èƒ½åœ¨è‡ªå‹•å›žæ‡‰æª”æ‰€åƒè€ƒçš„ä»»ä½•å›žæ‡‰æª”ä¸­æŒ‡å®šã€‚</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DeferredResponseFile">
+        <source>Included response file: {0}</source>
+        <target state="new">Included response file: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -171,16 +176,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     å¼•ç™¼ MSBuild ç¨ç«‹å»ºç½®å„å€‹å°ˆæ¡ˆã€‚
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     é€™æ˜¯é™åˆ¶åº¦è¼ƒé«˜çš„ MSBuild æ¨¡å¼ï¼Œå› ç‚º
-                     å°ˆæ¡ˆåœ–å½¢æœƒéœ€è¦åœ¨è©•ä¼°éšŽæ®µå¯ä¾›éœæ…‹æŽ¢ç´¢ï¼Œ
-                     ä½†èƒ½åœ¨å»ºç½®ä¸€çµ„å¤§é‡å°ˆæ¡ˆæ™‚æ”¹å–„æŽ’ç¨‹
-                     åŠé™ä½Žè¨˜æ†¶é«”é¡å¤–è² è·ã€‚
-                     (ç°¡çŸ­å½¢å¼: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     é€™æ˜¯å¯¦é©—æ€§çš„æ——æ¨™ï¼Œé‹ä½œæƒ…å½¢å¯èƒ½ä¸å¦‚é æœŸã€‚
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -676,11 +690,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;å¿«å–æª”æ¡ˆ&gt;...
-                     ä»¥åˆ†è™Ÿåˆ†éš”çš„è¼¸å…¥å¿«å–æª”æ¡ˆ
-                      (MSBuild å°‡æœƒå¾žæ­¤æª”æ¡ˆè®€å–å»ºç½®çµæžœ) æ¸…å–®ã€‚
-                     è¨­å®šæ­¤é …ç›®ä¹Ÿæœƒé–‹å•Ÿéš”é›¢å¼å»ºç½® (-isolate)ã€‚
-                     (ç°¡çŸ­å½¢å¼: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -694,11 +707,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuild è¦åœ¨çµ„å»ºçµæŸæ™‚å¯«å…¥
-                     å…¶çµ„å»ºçµæžœå¿«å–å…§å®¹çš„ç›®æ¨™è¼¸å‡ºå¿«å–æª”æ¡ˆã€‚
-                     è¨­å®šæ­¤é …ä¹Ÿæœƒé–‹å•Ÿéš”é›¢çµ„å»º (-isolate)ã€‚
-                     (ç°¡çŸ­æ ¼å¼: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -794,8 +807,8 @@
    </source>
         <target state="translated">  -toolsversion:&lt;ç‰ˆæœ¬&gt;
                      å»ºç½®æœŸé–“æ‰€ä½¿ç”¨çš„ MSBuild å·¥å…·çµ„ (å·¥ä½œã€ç›®æ¨™ç­‰)
-                      ç‰ˆæœ¬ã€‚æ­¤ç‰ˆæœ¬å°‡æœƒè¦†å¯«
-                     å€‹åˆ¥å°ˆæ¡ˆæ‰€æŒ‡å®šçš„ç‰ˆæœ¬ã€‚(ç°¡çŸ­å½¢å¼:
+                      ç‰ˆæœ¬ã€‚æ­¤ç‰ˆæœ¬å°‡æœƒè¦†å¯« 
+                     å€‹åˆ¥å°ˆæ¡ˆæ‰€æŒ‡å®šçš„ç‰ˆæœ¬ã€‚(ç°¡çŸ­å½¢å¼: 
                      -tv)
                      ç¯„ä¾‹:
                        -toolsVersion:3.5
@@ -1052,7 +1065,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: ç¨ç«‹å¼å°ˆæ¡ˆå€¼ç„¡æ•ˆã€‚{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: ç¨ç«‹å¼å°ˆæ¡ˆå€¼ç„¡æ•ˆã€‚{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 07ca34ea071..e082ae28727 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1,4 +1,4 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -1324,8 +1324,6 @@ internal static bool BuildProject(
                         }
                     }
 
-                    // List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = null;
-
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
                     BuildResultCode? result = null;
@@ -1345,8 +1343,10 @@ internal static bool BuildProject(
                         {
                             messagesToLogInBuildLoggers.Add(
                                 new BuildManager.DeferredBuildMessage(
-                                    String.Format("Included response file: {0}", responseFilePath),
-                                    MessageImportance.Normal,
+                                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                                        "DeferredResponseFile",
+                                        responseFilePath),
+                                    MessageImportance.Low,
                                     responseFilePath));
                         }
                     }
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index a4c00b30b76..b2f5106d38d 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -599,7 +599,13 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
 
                 MSBuildToolsDirectory32 = MSBuildToolsDirectoryRoot;
                 MSBuildToolsDirectory64 = existsCheck(potentialAmd64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "amd64") : CurrentMSBuildToolsDirectory;
+#if RUNTIME_TYPE_NETCORE
+                // Fall back to "current" for any architecture since .NET SDK doesn't
+                // support cross-arch task invocations.
+                MSBuildToolsDirectoryArm64 = existsCheck(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : CurrentMSBuildToolsDirectory;
+#else
                 MSBuildToolsDirectoryArm64 = existsCheck(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
+#endif
             }
 
             MSBuildExtensionsPath = mode == BuildEnvironmentMode.VisualStudio
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index 1ff1e5b762b..6b2f8aed5c8 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -42,8 +42,10 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
             LoadedAssembly = loadedAssembly;
 
 #if !NET35
-            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the
+            // This block is reflection only loaded type implementation. Net35 does not support it, and fall backs to former implementation in #else
+            // Property `Properties` set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the
             // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.
+
             // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.
             Type t = type;
             while (t is not null)
@@ -104,6 +106,11 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
                     PropertyAssemblyQualifiedNames[i] = Properties[i].PropertyType.AssemblyQualifiedName;
                 }
             }
+#else
+            // For v3.5 fallback to old full type approach, as oppose to reflection only
+            HasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);
+            HasSTAThreadAttribute = this.Type.GetTypeInfo().IsDefined(typeof(RunInSTAAttribute), true /* inherited */);
+            IsMarshalByRef = this.Type.IsMarshalByRef;
 #endif
         }
 
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index 4a3faba5c34..226a7780017 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal static class PlatformNegotiation
     {
-        internal static string GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper? log = null)
+        internal static string GetNearestPlatform(string overridePlatformValue, string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper? log = null)
         {
             Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable, log);
 
@@ -41,9 +41,14 @@ internal static string GetNearestPlatform(string referencedProjectPlatform, stri
 
             string buildProjectReferenceAs = string.Empty;
 
+            // If an override value is set define that as the platform value as the top priority
+            if (!string.IsNullOrEmpty(overridePlatformValue))
+            {
+                buildProjectReferenceAs = overridePlatformValue;
+            }
             // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
             // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
-            if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
+            else if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
             {
                 log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
             }
diff --git a/src/Shared/SolutionConfiguration.cs b/src/Shared/SolutionConfiguration.cs
new file mode 100644
index 00000000000..99c5b0a33fc
--- /dev/null
+++ b/src/Shared/SolutionConfiguration.cs
@@ -0,0 +1,135 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using System.IO;
+using System.Xml;
+
+namespace Microsoft.Build.Shared
+{
+    internal sealed class SolutionConfiguration
+    {
+        public const string ProjectAttribute = "Project";
+
+        public const string AbsolutePathAttribute = "AbsolutePath";
+
+        public const string BuildProjectInSolutionAttribute = "BuildProjectInSolution";
+
+        // This field stores pre-cached project elements for project guids for quicker access by project guid
+        private readonly Dictionary<string, XmlElement> _cachedProjectElements = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
+
+        // This field stores pre-cached project elements for project guids for quicker access by project absolute path
+        private readonly Dictionary<string, XmlElement> _cachedProjectElementsByAbsolutePath = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
+
+        // This field stores the project absolute path for quicker access by project guid
+        private readonly Dictionary<string, string> _cachedProjectAbsolutePathsByGuid = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+        // This field stores the project guid for quicker access by project absolute path
+        private readonly Dictionary<string, string> _cachedProjectGuidsByAbsolutePath = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+        // This field stores the list of dependency project guids by depending project guid
+        private readonly Dictionary<string, List<string>> _cachedDependencyProjectGuidsByDependingProjectGuid = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+
+        public SolutionConfiguration(string xmlString)
+        {
+            // Example:
+            //
+            // <SolutionConfiguration>
+            //  <ProjectConfiguration Project="{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}" AbsolutePath="c:foo\Project1\A.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
+            //  <ProjectConfiguration Project="{881C1674-4ECA-451D-85B6-D7C59B7F16FA}" AbsolutePath="c:foo\Project2\B.csproj" BuildProjectInSolution="True">Debug|AnyCPU<ProjectDependency Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" /></ProjectConfiguration>
+            //  <ProjectConfiguration Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" AbsolutePath="c:foo\Project3\C.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
+            // </SolutionConfiguration>
+            //
+            XmlNodeList? projectConfigurationElements = GetProjectConfigurations(xmlString);
+            if (projectConfigurationElements != null)
+            {
+                foreach (XmlElement xmlElement in projectConfigurationElements)
+                {
+                    string projectGuid = xmlElement.GetAttribute(ProjectAttribute);
+                    string projectAbsolutePath = xmlElement.GetAttribute(AbsolutePathAttribute);
+
+                    // What we really want here is the normalized path, like we'd get with an item's "FullPath" metadata.  However, 
+                    // if there's some bogus full path in the solution configuration (e.g. a website with a "full path" of c:\solutiondirectory\http://localhost) 
+                    // we do NOT want to throw -- chances are extremely high that that's information that will never actually be used.  So resolve the full path 
+                    // but just swallow any IO-related exceptions that result.  If the path is bogus, the method will return null, so we'll just quietly fail 
+                    // to cache it below. 
+                    projectAbsolutePath = FileUtilities.GetFullPathNoThrow(projectAbsolutePath);
+
+                    if (!string.IsNullOrEmpty(projectGuid))
+                    {
+                        _cachedProjectElements[projectGuid] = xmlElement;
+                        if (!string.IsNullOrEmpty(projectAbsolutePath))
+                        {
+                            _cachedProjectElementsByAbsolutePath[projectAbsolutePath] = xmlElement;
+                            _cachedProjectAbsolutePathsByGuid[projectGuid] = projectAbsolutePath;
+                            _cachedProjectGuidsByAbsolutePath[projectAbsolutePath] = projectGuid;
+                        }
+
+                        foreach (XmlNode dependencyNode in xmlElement.ChildNodes)
+                        {
+                            if (dependencyNode.NodeType != XmlNodeType.Element)
+                            {
+                                continue;
+                            }
+
+                            XmlElement dependencyElement = ((XmlElement)dependencyNode);
+
+                            if (!String.Equals(dependencyElement.Name, "ProjectDependency", StringComparison.Ordinal))
+                            {
+                                continue;
+                            }
+
+                            string dependencyGuid = dependencyElement.GetAttribute("Project");
+
+                            if (dependencyGuid.Length == 0)
+                            {
+                                continue;
+                            }
+
+                            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out List<string>? list))
+                            {
+                                list = new List<string>();
+                                _cachedDependencyProjectGuidsByDependingProjectGuid.Add(projectGuid, list);
+                            }
+
+                            list.Add(dependencyGuid);
+                        }
+                    }
+                }
+            }
+        }
+
+        public static SolutionConfiguration Empty { get; } = new SolutionConfiguration(string.Empty);
+
+        public ICollection<XmlElement> ProjectConfigurations => _cachedProjectElements.Values;
+
+        public static XmlNodeList? GetProjectConfigurations(string xmlString)
+        {
+            XmlDocument? doc = null;
+
+            if (!string.IsNullOrEmpty(xmlString))
+            {
+                doc = new XmlDocument();
+                var settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                using (XmlReader reader = XmlReader.Create(new StringReader(xmlString), settings))
+                {
+                    doc.Load(reader);
+                }
+            }
+
+            return doc?.DocumentElement?.ChildNodes;
+        }
+
+        public bool TryGetProjectByGuid(string projectGuid, [NotNullWhen(true)] out XmlElement? projectElement) => _cachedProjectElements.TryGetValue(projectGuid, out projectElement);
+
+        public bool TryGetProjectByAbsolutePath(string projectFullPath, [NotNullWhen(true)] out XmlElement? projectElement) => _cachedProjectElementsByAbsolutePath.TryGetValue(projectFullPath, out projectElement);
+
+        public bool TryGetProjectGuidByAbsolutePath(string projectFullPath, [NotNullWhen(true)] out string? projectGuid) => _cachedProjectGuidsByAbsolutePath.TryGetValue(projectFullPath, out projectGuid);
+
+        public bool TryGetProjectDependencies(string projectGuid, [NotNullWhen(true)] out List<string>? dependencyProjectGuids) => _cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out dependencyProjectGuids);
+
+        public bool TryGetProjectPathByGuid(string projectGuid, [NotNullWhen(true)] out string? projectPath) => _cachedProjectAbsolutePathsByGuid.TryGetValue(projectGuid, out projectPath);
+    }
+}
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 9ca06387a18..0832273c79b 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -2255,6 +2255,87 @@ public void InvalidErrorIfLinkFailed()
             Assert.False(result);
             engine.AssertLogContains("MSB3892");
         }
+
+        /// <summary>
+        /// An existing link source should not be modified.
+        /// </summary>
+        /// <remarks>
+        /// Related to issue [#8273](https://github.com/dotnet/msbuild/issues/8273)
+        /// </remarks>
+        [Theory]
+        [InlineData(false, false)]
+        [InlineData(false, true)]
+        [InlineData(true, false)]
+        public void DoNotCorruptSourceOfLink(bool useHardLink, bool useSymbolicLink)
+        {
+            string sourceFile1 = FileUtilities.GetTemporaryFile();
+            string sourceFile2 = FileUtilities.GetTemporaryFile();
+            string temp = Path.GetTempPath();
+            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
+            string destFile = Path.Combine(destFolder, "The Destination");
+
+            try
+            {
+                File.WriteAllText(sourceFile1, "This is the first source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+                File.WriteAllText(sourceFile2, "This is the second source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+
+                // Don't create the dest folder, let task do that
+
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile1) };
+                ITaskItem[] destinationFiles = { new TaskItem(destFile) };
+
+                var me = new MockEngine(true);
+                var t = new Copy
+                {
+                    RetryDelayMilliseconds = 1, // speed up tests!
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = useHardLink,
+                    UseSymboliclinksIfPossible = useSymbolicLink,
+                };
+
+                bool success = t.Execute();
+
+                Assert.True(success); // "success"
+                Assert.True(File.Exists(destFile)); // "destination exists"
+
+                string destinationFileContents = File.ReadAllText(destFile);
+                Assert.Equal("This is the first source temp file.", destinationFileContents);
+
+                sourceFiles = new TaskItem[] { new TaskItem(sourceFile2) };
+
+                t = new Copy
+                {
+                    RetryDelayMilliseconds = 1, // speed up tests!
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = false,
+                    UseSymboliclinksIfPossible = false,
+                };
+
+                success = t.Execute();
+
+                Assert.True(success); // "success"
+                Assert.True(File.Exists(destFile)); // "destination exists"
+
+                destinationFileContents = File.ReadAllText(destFile);
+                Assert.Equal("This is the second source temp file.", destinationFileContents);
+
+                // Read the source file (it should not have been overwritten)
+                string sourceFileContents = File.ReadAllText(sourceFile1);
+                Assert.Equal("This is the first source temp file.", sourceFileContents);
+
+                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+            }
+            finally
+            {
+                Helpers.DeleteFiles(sourceFile1, sourceFile2, destFile);
+            }
+        }
     }
 
     public class CopyHardLink_Tests : Copy_Tests
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
index 6c3861314bd..d9359ef1a6c 100644
--- a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -40,6 +40,29 @@ public void ResolvesViaPlatformLookupTable()
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x64");
         }
 
+
+        [Fact]
+        public void ResolvesViaOverride()
+        {
+            // OverridePlatformNegotiationValue always takes priority over everything. It is typically user-defined.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;x86;AnyCPU");
+            projectReference.SetMetadata("platform", "x86");
+            projectReference.SetMetadata("OverridePlatformNegotiationValue", "x86");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x64",
+                PlatformLookupTable = "win32=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("");
+        }
+
         [Fact]
         public void ResolvesViaProjectReferencesPlatformLookupTable()
         {
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index a92f5e148dc..ef1b944e160 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -80,5 +80,29 @@ public void AssemblyAttributesLocation()
             bool result = project.Build(logger);
             Assert.True(result, "Output:" + Environment.NewLine + logger.FullLog);
         }
+
+        /// <summary>
+        /// Test for https://github.com/dotnet/msbuild/issues/8153
+        /// </summary>
+        [Fact]
+        public void IsWellKnownAttributeValuePreserved()
+        {
+            ObjectModelHelpers.DeleteTempProjectDirectory();
+
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("Myapp.proj", @"
+                <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                  <Target Name =`Repro`>
+                    <CreateItem Include=`*.txt` AdditionalMetadata=`MyProperty=Identity`>
+                      <Output TaskParameter=`Include` ItemName=`TestItem`/>
+                    </CreateItem>
+                    <Error Text=`@(TestItem)` Condition=""'%(MyProperty)' != 'Identity' ""/>
+                  </Target>
+                </Project>
+                ");
+
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("Foo.txt", "foo");
+            MockLogger logger = new MockLogger(_output);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess("Myapp.proj", logger);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 94131f1e4b6..f704ef169a1 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -1940,6 +1940,48 @@ public void InvalidStateFile()
             }
         }
 
+        [Fact]
+        public void GenerateResourceWarnsWhenUsingBinaryFormatter()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile resource = env.CreateFile(".resx", @"<?xml version=""1.0"" encoding=""utf-8""?>
+<root>
+  <data name=""$this.Icon"" type=""System.Drawing.Icon, System.Drawing"" mimetype=""application/x-microsoft.net.object.binary.base64"">
+    <value>
+        AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAA
+        AAD///8BoqKiDaKiotmioqL5oqKiK////wH///8B////Af///wH///8B////AaKioiGioqLxoqKi5aKi
+        ohn///8B////AbS0tBW0tLTz29vb/7Ozsu18Wi+Be1gswXtYLO17WCzte1gswXtYLIGzs7Lz2dnZ/7S0
+        tPu0tLQj////Af///wH///8BxsbGQdPT0//Cv739nGs7/6ZsNf+ubzf/rm83/6ZsNf+hdkr/xcTD/8bG
+        xf/GxsY/////Af///wH///8B////AYxlNmejiGn1r3hE/7uMXv/Ck3H/xJF0/8OPcf+/kGz/uIpd/7SG
+        Wf+hhWT1jGU2Z////wH///8B////AZZtOzWWbTvVs31G/8KZcf/Yqon/79/P//r28//69fP/79/R/9en
+        hf++lGz/s31G/5ZtO9WWbTs1////Af///wGhdUGBsIBK/8abb//Zqoj///7r///67v///fL///7y///8
+        7////ev/2aN6/8KZbP+wgEr/oXVBgf///wH///8BrH5Iwb+PWP/No4H/8NvB///35v/68uP/xcC2//Ht
+        3v///Oj///Xf/+/Ur//ImXL/v49Y/6x+SMH///8B////AbeHTu3JnGb/z5+A//rz4v/99un/8vDj/42M
+        hP+Bf3f/0s/C///76//67Mz/x5Bt/8mcZv+3h07t////Af///wHCkFTtzqZx/9Glif/69un//fju////
+        +f+BgHn/sa6k/4F/d//Jxrr/+vDT/8mWcv/OpnH/wpBU7f///wH///8BzZlbwdOsdf/Zt5j/8ePW//77
+        9f/19fP/n56V//Dw6f/4+PL/vrmt//Dawv/Sqof/06x1/82ZW8H///8B////AbOddIvTrXf/38Sa/969
+        qv//////8PDu/+fl2v////f////3///+8//ctJj/28CW/8Kqfv/Gn2qF////AQCZ3T0KmtjZLpzF9d6/
+        iv/iyaf/37+u//Hj3P/z8ez/9PHr//Hi2f/cuqP/38Oe/4yxqf84ptH5DprWzwCZ3ScAoON9fNHy7WHD
+        6O86pMb74seS/+bRqf/gwqb/1a6W/9Wrkv/evaD/5M+m/7/Bnv9Hstf9q+P2/Smw6NkAoOMnAKfpe13J
+        8eW16Pn/Ycfr7zqqzPPsxIj/6cuU/+fQnf/n0J3/6cuU/97Cjv8yqtD1gdPw9XPQ8+sAp+nNAKfpBQCu
+        7wUAru+LW8v05b/s+v9cy/HpTbLJxfq8dMH6vHTt+rx07fq8dMFRssjDac/y7XzW9u0Aru/JAK7vHf//
+        /wH///8BALX0AwC19IEAtfTRALX0ywC19Af///8B////Af///wH///8BALX0FwC19NEAtfTJALX0J///
+        /wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA
+        //8AAP//AAD//w==
+</value>
+  </data>
+</root>
+");
+
+            GenerateResource gr = Utilities.CreateTask(_output, usePreserialized: true, env: env);
+            gr.Sources = new ITaskItem[] { new TaskItem(resource.Path) };
+            gr.WarnOnBinaryFormatterUse = true;
+
+            gr.Execute().ShouldBeTrue();
+
+            Utilities.AssertLogContainsResource(gr, "GenerateResource.BinaryFormatterUse", "$this.Icon", "System.Drawing.Icon, System.Drawing");
+        }
+
         /// <summary>
         ///  Cause failures in ResourceReader
         /// </summary>
diff --git a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
index d1c0b84fdc0..c161b862071 100644
--- a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
@@ -32,7 +32,7 @@ public void ParsesSingleStringAsString()
                     @"<data name=""StringResource"" xml:space=""preserve"">
     <value>StringValue</value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "StringValue");
         }
@@ -45,7 +45,7 @@ public void ParsesSingleStringWithoutPreserveAsString()
                     @"<data name=""StringResource"">
     <value> StringValue </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", " StringValue ");
         }
@@ -58,7 +58,7 @@ public void ParsesSingleWhitespaceStringAsString()
                     @"<data name=""StringResource"" xml:space=""preserve"">
     <value> </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", " ");
         }
@@ -71,7 +71,7 @@ public void ParsesSingleWhitespaceStringWithNoPreserveAsEmptyString()
                     @"<data name=""StringResource"">
     <value> </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "");
         }
@@ -83,7 +83,7 @@ public void ParsesSingleStringWithPartialTypeName()
                 ResXHelper.SurroundWithBoilerplate(
                     @"<data name=""StringResource"" type=""System.String"">
     <value>StringValue</value>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "StringValue");
         }
@@ -100,7 +100,7 @@ public void LoadsMultipleStringsPreservingOrder()
   </data>
   <data name=""2StringResource2"" xml:space=""preserve"">
     <value>2StringValue2</value>
-  </data>"));
+  </data>"), null, false);
 
             resxWithTwoStrings.Count.ShouldBe(2);
 
@@ -121,7 +121,7 @@ public void ResXNullRefProducesNullLiveObject()
 @"  <assembly alias=""System.Windows.Forms"" name=""System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"" />
   <data name=""$this.AccessibleDescription"" type=""System.Resources.ResXNullRef, System.Windows.Forms, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"">
     <value />
-  </data>"));
+  </data>"), null, false);
 
             resxWithNullRef.ShouldHaveSingleItem();
 
@@ -143,7 +143,7 @@ public void LoadsStringFromFileRefAsString(string stringType)
 $@"  <assembly alias=""System.Windows.Forms"" name=""System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"" />
   <data name=""TextFile1"" type=""System.Resources.ResXFileRef, System.Windows.Forms"">
     <value>ResourceHandling\TextFile1.txt;{stringType};utf-8</value>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithLinkedString, "TextFile1", "Contents of TextFile1");
         }
@@ -174,6 +174,8 @@ public void LoadsStringFromFileRefAsStringWithShiftJISEncoding()
   <data name=""TextFile1"" type=""System.Resources.ResXFileRef, System.Windows.Forms"">
     <value>ResourceHandling\TextFileInShiftJIS.txt;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;shift_jis</value>
   </data>"),
+                    null,
+                    false,
                     Path.Combine(baseDir.Path, nameof(LoadsStringFromFileRefAsStringWithShiftJISEncoding) + ".resx"),
                     useRelativePath: true);
 
@@ -210,7 +212,7 @@ public void PassesThroughBitmapInResx()
         b7eblRw4yy8Ta2GCpaZp1sIzz2LfCMS+EYh9401iw/gG1gYfvzjQIXcAAAAASUVORK5CYII=
 </value>
   </data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterByteArrayResource));
 
@@ -228,7 +230,7 @@ public void TypeConverterStringWellFormatted()
     <data name=""color"" type=""System.Drawing.Color, System.Drawing"">
       <value>Blue</value>
     </data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
@@ -252,7 +254,7 @@ public void TypeConverterStringDirectValue()
                 ResXHelper.SurroundWithBoilerplate(
 @"  <assembly alias=""System.Drawing"" name=""System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"" />
     <data name=""Color1"" type=""System.Drawing.Color, System.Drawing"">Blue</data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
@@ -272,7 +274,7 @@ public void ResXFileRefToBitmap()
 $@"  <data name='Image1' type='System.Resources.ResXFileRef, System.Windows.Forms'>
     <value>{bitmapPath};System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
   </data>
-"));
+"), null, false);
             resxWithLinkedBitmap.ShouldHaveSingleItem();
             resxWithLinkedBitmap[0].ShouldBeOfType(typeof(FileStreamResource));
 
@@ -301,7 +303,7 @@ public void ResXFileRefToMemoryStream(string typeNameInResx)
 $@"  <data name='Image1' type='System.Resources.ResXFileRef, System.Windows.Forms'>
     <value>{linkedTextFile.Path};{typeNameInResx}</value>
   </data>
-"));
+"), null, false);
 
             var resource = resources.ShouldHaveSingleItem()
                 .ShouldBeOfType<LiveObjectResource>();
@@ -321,7 +323,7 @@ public void AssemblyElementWithNoAliasInfersSimpleName()
                 ResXHelper.SurroundWithBoilerplate(
 @"  <assembly name=""System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"" />
     <data name=""Color1"" type=""System.Drawing.Color, System.Drawing""><value>Blue</value></data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
index d8462b8017b..6538fef25df 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
@@ -40,7 +40,7 @@ public void DirtyCleanScenario(bool useMSBuildResXReader)
                 cache.IsDirty.ShouldBeFalse();
 
                 // Getting a file that wasn't in the cache is a write operation.
-                cache.GetResXFileInfo(resx, useMSBuildResXReader);
+                cache.GetResXFileInfo(resx, useMSBuildResXReader, null, false);
                 cache.IsDirty.ShouldBeTrue();
 
                 // Add linkedFiles to further test serialization and deserialization.
@@ -72,7 +72,7 @@ public void DirtyCleanScenario(bool useMSBuildResXReader)
                 resX2.linkedFiles[1].ShouldBe(resX.linkedFiles[1]);
 
                 // Asking for a file that's in the cache should not dirty the cache.
-                cache2.GetResXFileInfo(resx, useMSBuildResXReader);
+                cache2.GetResXFileInfo(resx, useMSBuildResXReader, null, false);
                 cache2.IsDirty.ShouldBeFalse();
 
                 // Changing UseSourcePath to false should dirty the cache.
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index a538b371cf3..e4ce0c64991 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -90,6 +90,51 @@ public void CombineFileDirectory()
             string file = Path.Combine(Path.GetTempPath(), "CombineFileDirectory.tmp");
             Assert.Equal(file, task.OutputFile.ItemSpec);
             Assert.True(File.Exists(file));
+
+            File.Delete(task.OutputFile.ItemSpec);
+        }
+
+        /// <summary>
+        /// Combine file and directory where the directory does not already exist
+        /// </summary>
+        [Fact]
+        public void CombineFileDirectoryAndDirectoryDoesNotExist()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+
+            TaskItem folder = new TaskItem(env.CreateFolder(folderPath: null, createFolder: false).Path);
+
+            TaskItem file = new TaskItem("CombineFileDirectory.tmp");
+
+            string expectedFile = Path.Combine(folder.ItemSpec, file.ItemSpec);
+            WriteCodeFragment task = CreateTask("c#", folder, file, new TaskItem[] { new TaskItem("aa") });
+            MockEngine engine = new MockEngine(true);
+            task.BuildEngine = engine;
+            bool result = task.Execute();
+
+            Assert.True(result);
+            Assert.Equal(expectedFile, task.OutputFile.ItemSpec);
+            Assert.True(File.Exists(expectedFile));
+        }
+
+        /// <summary>
+        /// Combine file and directory where the directory does not already exist
+        /// </summary>
+        [Fact]
+        public void FileWithPathAndDirectoryDoesNotExist()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+
+            TaskItem file = new TaskItem(Path.Combine(env.CreateFolder(folderPath: null, createFolder: false).Path, "File.tmp"));
+
+            WriteCodeFragment task = CreateTask("c#", null, file, new TaskItem[] { new TaskItem("aa") });
+            MockEngine engine = new MockEngine(true);
+            task.BuildEngine = engine;
+            bool result = task.Execute();
+
+            Assert.True(result);
+            Assert.Equal(file.ItemSpec, task.OutputFile.ItemSpec);
+            Assert.True(File.Exists(task.OutputFile.ItemSpec));
         }
 
         /// <summary>
@@ -176,7 +221,7 @@ public void NoAttributesShouldEmitNoFile2()
         /// <summary>
         /// Bad file path
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "No invalid characters on Unix.")]
         public void InvalidFilePath()
         {
             WriteCodeFragment task = new WriteCodeFragment();
@@ -317,6 +362,27 @@ public void ToDirectory()
             File.Delete(task.OutputFile.ItemSpec);
         }
 
+        /// <summary>
+        /// Specify directory where the directory does not already exist
+        /// </summary>
+        [Fact]
+        public void ToDirectoryAndDirectoryDoesNotExist()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+
+            TaskItem folder = new TaskItem(env.CreateFolder(folderPath: null, createFolder: false).Path);
+
+            WriteCodeFragment task = CreateTask("c#", folder, null, new TaskItem[] { new TaskItem("System.AssemblyTrademarkAttribute") });
+            MockEngine engine = new MockEngine(true);
+            task.BuildEngine = engine;
+            bool result = task.Execute();
+
+            Assert.True(result);
+            Assert.True(File.Exists(task.OutputFile.ItemSpec));
+            Assert.Equal(folder.ItemSpec, task.OutputFile.ItemSpec.Substring(0, folder.ItemSpec.Length));
+            Assert.Equal(".cs", task.OutputFile.ItemSpec.Substring(task.OutputFile.ItemSpec.Length - 3));
+        }
+
         /// <summary>
         /// Regular case
         /// </summary>
@@ -874,7 +940,7 @@ public void InferredTypeForNamedParameter()
         }
 
         /// <summary>
-        /// For backward-compatibility, if multiple constructors are found with the same number 
+        /// For backward-compatibility, if multiple constructors are found with the same number
         /// of position arguments that was specified in the metadata, then the constructor that
         /// has strings for every parameter should be used.
         /// </summary>
@@ -985,11 +1051,18 @@ public void UsingInferredDeclaredTypesAndLiteralsInSameAttribute()
 
         private WriteCodeFragment CreateTask(string language, params TaskItem[] attributes)
         {
-            WriteCodeFragment task = new();
-            task.Language = language;
-            task.OutputDirectory = new TaskItem(Path.GetTempPath());
-            task.AssemblyAttributes = attributes;
-            return task;
+            return CreateTask(language, new TaskItem(Path.GetTempPath()), null, attributes);
+        }
+
+        private WriteCodeFragment CreateTask(string language, TaskItem outputDirectory, TaskItem outputFile, params TaskItem[] attributes)
+        {
+            return new WriteCodeFragment()
+            {
+                Language = language,
+                OutputDirectory = outputDirectory,
+                OutputFile = outputFile,
+                AssemblyAttributes = attributes
+            };
         }
 
         private void ExecuteAndVerifySuccess(WriteCodeFragment task, params string[] expectedAttributes)
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index 85449beccfc..0b3d12f099e 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -154,6 +154,28 @@ public void WriteLinesWriteOnlyWhenDifferentTest()
             }
         }
 
+        [Fact]
+        public void RedundantParametersAreLogged()
+        {
+            using TestEnvironment testEnv = TestEnvironment.Create(_output);
+
+            MockEngine engine = new(_output);
+
+            string file = testEnv.ExpectFile().Path;
+
+            WriteLinesToFile task = new()
+            {
+                BuildEngine = engine,
+                File = new TaskItem(file),
+                Lines = new ITaskItem[] { new TaskItem($"{nameof(RedundantParametersAreLogged)} Test") },
+                WriteOnlyWhenDifferent = true,
+                Overwrite = false,
+            };
+
+            task.Execute().ShouldBeTrue();
+            engine.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", file);
+        }
+
         /// <summary>
         /// Question WriteLines to return false when a write will be required.
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 00e9c2c6103..4272a5e149e 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -1331,9 +1331,10 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                 }
 
                 // Go through each of the references, we go through this table because in general it will be considerably smaller than the blacklist. (10's of references vs 100's of black list items)
-                foreach (AssemblyNameExtension assemblyName in References.Keys)
+                foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
                 {
-                    Reference assemblyReference = References[assemblyName];
+                    AssemblyNameExtension assemblyName = assembly.Key;
+                    Reference assemblyReference = assembly.Value;
 
                     AddToDependencyGraph(dependencyGraph, assemblyName, assemblyReference);
 
@@ -1495,12 +1496,12 @@ private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason
         /// </summary>
         internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
         {
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
-                Reference assemblyReference = References[assemblyName];
+                Reference assemblyReference = assembly.Value;
                 if (assemblyReference.IsPrimary && assemblyReference.PrimarySourceItem.ItemSpec.Equals(itemSpec, StringComparison.OrdinalIgnoreCase))
                 {
-                    return assemblyName;
+                    return assembly.Key;
                 }
             }
 
@@ -1731,14 +1732,14 @@ private bool FindAssociatedFiles()
         /// </summary>
         private void ResolveAssemblyFilenames()
         {
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
-                Reference reference = GetReference(assemblyName);
+                Reference reference = assembly.Value;
 
                 // Has this reference been resolved to a file name?
                 if (!reference.IsResolved && !reference.IsUnresolvable)
                 {
-                    ResolveReference(assemblyName, null, reference);
+                    ResolveReference(assembly.Key, null, reference);
                 }
             }
         }
@@ -2153,16 +2154,19 @@ private Dictionary<string, List<AssemblyNameReference>> BuildSimpleNameTable()
         private static void RemoveReferencesWithoutConflicts(
             Dictionary<string, List<AssemblyNameReference>> baseNameToReferences)
         {
-            string[] baseNames = new string[baseNameToReferences.Count];
-            baseNameToReferences.Keys.CopyTo(baseNames, 0);
-
-            foreach (string baseName in baseNames)
+            List<string> toRemove = new(baseNameToReferences.Count);
+            foreach (KeyValuePair<string, List<AssemblyNameReference>> kvp in baseNameToReferences)
             {
-                if (baseNameToReferences[baseName].Count == 1)
+                if (kvp.Value.Count == 1)
                 {
-                    baseNameToReferences.Remove(baseName);
+                    toRemove.Add(kvp.Key);
                 }
             }
+
+            foreach (string key in toRemove)
+            {
+                baseNameToReferences.Remove(key);
+            }
         }
 
         // TODO: Verify correctness of this implementation and extend to more cases.
@@ -3095,10 +3099,11 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
             bool anyMarkedReference = false;
             ListOfExcludedAssemblies = new List<string>();
 
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
+                AssemblyNameExtension assemblyName = assembly.Key;
+                Reference reference = assembly.Value;
                 string assemblyFullName = assemblyName.FullName;
-                Reference reference = GetReference(assemblyName);
                 reference.ReferenceVersion = assemblyName.Version;
 
                 MarkReferenceWithHighestVersionInCurrentRedistList(assemblyName, reference);
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index bbd677c7cb9..afdde42ef14 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1069,10 +1069,11 @@ quiet at the engine level.
                 if (!Silent)
                 {
                     // First, loop over primaries and display information.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference primaryCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference primaryCandidate = assembly.Value;
 
                         if (primaryCandidate.IsPrimary && !(primaryCandidate.IsConflictVictim && primaryCandidate.IsCopyLocal))
                         {
@@ -1081,10 +1082,11 @@ quiet at the engine level.
                     }
 
                     // Second, loop over dependencies and display information.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference dependencyCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference dependencyCandidate = assembly.Value;
 
                         if (!dependencyCandidate.IsPrimary && !(dependencyCandidate.IsConflictVictim && dependencyCandidate.IsCopyLocal))
                         {
@@ -1093,10 +1095,11 @@ quiet at the engine level.
                     }
 
                     // Third, show conflicts and their resolution.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference conflictCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference conflictCandidate = assembly.Value;
 
                         if (conflictCandidate.IsConflictVictim)
                         {
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 287ddf6fa41..2a47fce7737 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -152,7 +152,6 @@ public string VcxToDefaultPlatformMapping
         private const string attrFullConfiguration = "FullConfiguration";
         private const string buildReferenceMetadataName = "BuildReference";
         private const string referenceOutputAssemblyMetadataName = "ReferenceOutputAssembly";
-        private const string buildProjectInSolutionAttribute = "BuildProjectInSolution";
         private const string attrConfiguration = "Configuration";
         private const string attrPlatform = "Platform";
         private const string attrSetConfiguration = "SetConfiguration";
@@ -337,7 +336,7 @@ internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool on
             if (projectConfigurationElement != null && resolvedProjectWithConfiguration != null && onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)
             {
                 // The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value. 
-                string buildProjectInSolution = projectConfigurationElement.GetAttribute(buildProjectInSolutionAttribute);
+                string buildProjectInSolution = projectConfigurationElement.GetAttribute(SolutionConfiguration.BuildProjectInSolutionAttribute);
 
                 // We could not parse out what was in the attribute, act as if it was not set in the first place. 
                 if (bool.TryParse(buildProjectInSolution, out bool buildProject))
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 24921740b27..979c9652291 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -228,8 +228,6 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             FileState sourceFileState,      // The source file
             FileState destinationFileState)  // The destination file
         {
-            bool destinationFileExists = false;
-
             if (destinationFileState.DirectoryExists)
             {
                 Log.LogErrorWithCodeFromResources("Copy.DestinationIsDirectory", sourceFileState.Name, destinationFileState.Name);
@@ -287,7 +285,14 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             if (OverwriteReadOnlyFiles)
             {
                 MakeFileWriteable(destinationFileState, true);
-                destinationFileExists = destinationFileState.FileExists;
+            }
+
+            // If the destination file is a hard or symbolic link, File.Copy would overwrite the source.
+            // To prevent this, we need to delete the existing entry before we Copy or create a link.
+            // We could try to figure out if the file is a link, but I can't think of a reason to not simply delete it always.
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && destinationFileState.FileExists && !destinationFileState.IsReadOnly)
+            {
+                FileUtilities.DeleteNoThrow(destinationFileState.Name);
             }
 
             bool symbolicLinkCreated = false;
@@ -297,7 +302,7 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             // Create hard links if UseHardlinksIfPossible is true
             if (UseHardlinksIfPossible)
             {
-                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out hardLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage, Log));
+                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, out hardLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage, Log));
                 if (!hardLinkCreated)
                 {
                     if (UseSymboliclinksIfPossible)
@@ -315,13 +320,14 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             // Create symbolic link if UseSymboliclinksIfPossible is true and hard link is not created
             if (!hardLinkCreated && UseSymboliclinksIfPossible)
             {
-                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out symbolicLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethodsShared.MakeSymbolicLink(destination, source, ref errorMessage));
-                if (!NativeMethodsShared.IsWindows)
-                {
-                    errorMessage = Log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "symlink()", errorMessage);
-                }
+                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, out symbolicLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethodsShared.MakeSymbolicLink(destination, source, ref errorMessage));
                 if (!symbolicLinkCreated)
                 {
+                    if (!NativeMethodsShared.IsWindows)
+                    {
+                        errorMessage = Log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "symlink()", errorMessage);
+                    }
+
                     Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
                 }
             }
@@ -342,41 +348,28 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                 Log.LogMessage(MessageImportance.Normal, FileComment, sourceFilePath, destinationFilePath);
 
                 File.Copy(sourceFileState.Name, destinationFileState.Name, true);
+
+                // If the destinationFile file exists, then make sure it's read-write.
+                // The File.Copy command copies attributes, but our copy needs to
+                // leave the file writeable.
+                if (sourceFileState.IsReadOnly)
+                {
+                    destinationFileState.Reset();
+                    MakeFileWriteable(destinationFileState, false);
+                }
             }
 
             // Files were successfully copied or linked. Those are equivalent here.
             WroteAtLeastOneFile = true;
 
-            destinationFileState.Reset();
-
-            // If the destinationFile file exists, then make sure it's read-write.
-            // The File.Copy command copies attributes, but our copy needs to
-            // leave the file writeable.
-            if (sourceFileState.IsReadOnly)
-            {
-                MakeFileWriteable(destinationFileState, false);
-            }
-
             return true;
         }
 
-        private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, ref bool destinationFileExists, out bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
+        private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, out bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
         {
             // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
             Log.LogMessage(MessageImportance.Normal, linkComment, sourceFileState.Name, destinationFileState.Name);
 
-            if (!OverwriteReadOnlyFiles)
-            {
-                destinationFileExists = destinationFileState.FileExists;
-            }
-
-            // CreateHardLink and CreateSymbolicLink cannot overwrite an existing file or link
-            // so we need to delete the existing entry before we create the hard or symbolic link.
-            if (destinationFileExists)
-            {
-                FileUtilities.DeleteNoThrow(destinationFileState.Name);
-            }
-
             linkCreated = createLink(sourceFileState.Name, destinationFileState.Name, errorMessage);
         }
 
@@ -854,6 +847,11 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                                     LogDiagnostic("Retrying on ERROR_ACCESS_DENIED because MSBUILDALWAYSRETRY = 1");
                                 }
                             }
+                            else if (code == NativeMethods.ERROR_INVALID_FILENAME)
+                            {
+                                // Invalid characters used in file name, no point retrying.
+                                throw;
+                            }
 
                             if (e is UnauthorizedAccessException)
                             {
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 010f32eba07..8119588a35f 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -5,6 +5,7 @@
 using System.IO;
 using System.Net;
 using System.Net.Http;
+using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
@@ -127,7 +128,15 @@ private async Task<bool> ExecuteAsync()
                     }
                     else
                     {
-                        Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, actualException.ToString());
+                        StringBuilder flattenedMessage = new StringBuilder(actualException.Message);
+                        Exception excep = actualException;
+                        while (excep.InnerException != null)
+                        {
+                            excep = excep.InnerException;
+                            flattenedMessage.Append(" ---> ").Append(excep.Message);
+                        }
+                        Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, flattenedMessage.ToString());
+                        Log.LogMessage(MessageImportance.Low, actualException.ToString());
                         break;
                     }
                 }
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index 5403c9137f8..7ae0228c8e5 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -150,9 +150,9 @@ public override bool Execute()
                         }
                         else
                         {
-                            if (WriteOnlyWhenDifferent && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                            if (WriteOnlyWhenDifferent)
                             {
-                                Log.LogWarningWithCodeFromResources("WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
+                                Log.LogMessageFromResources(MessageImportance.Normal, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
                             }
 
                             Directory.CreateDirectory(directoryPath);
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 42832f620c7..6ff6c0a5dff 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -274,6 +274,12 @@ public string StronglyTypedLanguage
             }
         }
 
+        // Indicates whether any BinaryFormatter use should lead to a warning.
+        public bool WarnOnBinaryFormatterUse
+        {
+            get; set;
+        }
+
         /// <summary>
         /// Specifies the namespace to use for the generated class source for the
         /// strongly typed resource. If left blank, no namespace is used.
@@ -814,7 +820,8 @@ public override bool Execute()
                                         StronglyTypedClassName,
                                         PublicClass,
                                         ExtractResWFiles,
-                                        OutputDirectory);
+                                        OutputDirectory,
+                                        WarnOnBinaryFormatterUse);
 
                             this.StronglyTypedClassName = process.StronglyTypedClassName; // in case a default was chosen
                             this.StronglyTypedFileName = process.StronglyTypedFilename;   // in case a default was chosen
@@ -1516,7 +1523,7 @@ private bool ShouldRebuildResgenOutputFile(string sourceFilePath, string outputF
             ResGenDependencies.ResXFile resxFileInfo;
             try
             {
-                resxFileInfo = _cache.GetResXFileInfo(sourceFilePath, UsePreserializedResources);
+                resxFileInfo = _cache.GetResXFileInfo(sourceFilePath, UsePreserializedResources, Log, WarnOnBinaryFormatterUse);
             }
             catch (Exception e) when (!ExceptionHandling.NotExpectedIoOrXmlException(e) || e is MSBuildResXException)
             {
@@ -1977,7 +1984,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
         {
             byte[] serializedData = ByteArrayFromBase64WrappedString(data);
 
-            BinaryFormatter binaryFormatter = new BinaryFormatter();
+            BinaryFormatter binaryFormatter = new();
 
             using (MemoryStream memoryStream = new MemoryStream(serializedData))
             {
@@ -2343,6 +2350,8 @@ internal bool StronglyTypedResourceSuccessfullyCreated
         /// </summary>
         private bool _useSourcePath = false;
 
+        private bool _logWarningForBinaryFormatter = false;
+
         #endregion
 
         /// <summary>
@@ -2363,7 +2372,8 @@ internal void Run(
             string classname,
             bool publicClass,
             bool extractingResWFiles,
-            string resWOutputDirectory)
+            string resWOutputDirectory,
+            bool logWarningForBinaryFormatter)
         {
             _logger = log;
             _assemblyFiles = assemblyFilesList;
@@ -2382,6 +2392,7 @@ internal void Run(
             _resWOutputDirectory = resWOutputDirectory;
             _portableLibraryCacheInfo = new List<ResGenDependencies.PortableLibraryFile>();
             _usePreserializedResources = usePreserializedResources;
+            _logWarningForBinaryFormatter = logWarningForBinaryFormatter;
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
             // If references were passed in, we will have to give the ResxResourceReader an object
@@ -2986,7 +2997,7 @@ private void ReadResources(String filename, bool shouldUseSourcePath, String out
                             }
                             else
                             {
-                                foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, shouldUseSourcePath))
+                                foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, shouldUseSourcePath, _logger, _logWarningForBinaryFormatter))
                                 {
                                     AddResource(reader, resource, filename, 0, 0);
                                 }
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index 2b81a9dca99..daec24f865d 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -59,8 +59,9 @@ public override bool Execute()
                 string referencedProjectPlatform = AssignedProjectsWithPlatform[i].GetMetadata("Platform");
                 string projectReferencePlatformsMetadata = AssignedProjectsWithPlatform[i].GetMetadata("Platforms");
                 string projectReferenceLookupTableMetadata = AssignedProjectsWithPlatform[i].GetMetadata("PlatformLookupTable");
+                string projectReferenceOverridePlatformNegotiationMetadata = AssignedProjectsWithPlatform[i].GetMetadata("OverridePlatformNegotiationValue");
 
-                string? buildProjectReferenceAs = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, PlatformLookupTable, AssignedProjectsWithPlatform[i].ItemSpec, CurrentProjectPlatform, Log);
+                string? buildProjectReferenceAs = PlatformNegotiation.GetNearestPlatform(projectReferenceOverridePlatformNegotiationMetadata, referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, PlatformLookupTable, AssignedProjectsWithPlatform[i].ItemSpec, CurrentProjectPlatform, Log);
 
                 AssignedProjectsWithPlatform[i].SetMetadata("NearestPlatform", buildProjectReferenceAs);
                 Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.DisplayChosenPlatform", AssignedProjectsWithPlatform[i].ItemSpec, buildProjectReferenceAs);
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index f3ff18c2862..a7ab39b6a7e 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -102,6 +102,9 @@
     <Compile Include="..\Shared\StrongNameHelpers.cs">
       <Link>StrongNameHelpers.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\SolutionConfiguration.cs">
+      <Link>SolutionConfiguration.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\TaskLoggingHelperExtension.cs">
       <Link>TaskLoggingHelperExtension.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
@@ -147,9 +150,6 @@
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 11fc346caa4..f36e079ea3b 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1632,11 +1632,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <UseDefaultPlatformLookupTables Condition="'$(UseDefaultPlatformLookupTables)' == ''">true</UseDefaultPlatformLookupTables>
   </PropertyGroup>
 
-  <!-- This target skips VS builds because they already supply Platform and
-       Configuration information. -->
+  <!-- This target skips sln-based builds because they already supply Platform and
+       Configuration information. See AssignProjectConfiguration -->
   <Target Name="_GetProjectReferencePlatformProperties"
           Condition="'$(EnableDynamicPlatformResolution)' == 'true'
-                     and '$(BuildingInsideVisualStudio)' != 'true'
+                     and '$(CurrentSolutionConfigurationContents)' == ''
                      and '@(_MSBuildProjectReferenceExistent)' != ''">
 
     <!-- Allow preset SetPlatform to override this operation -->
@@ -2465,7 +2465,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ====================================================================================================
   -->
   <Target Name="GenerateBindingRedirects"
-    Inputs="$(MSBuildAllProjects);@(AppConfigFile);$(ResolveAssemblyReferencesStateFile);$(SuggestedBindingRedirectsCacheFile)"
+    Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(ResolveAssemblyReferencesStateFile);$(SuggestedBindingRedirectsCacheFile)"
     Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)"
     Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != ''"
     DependsOnTargets="_GenerateSuggestedBindingRedirectsCache">
@@ -3328,8 +3328,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         SdkToolsPath="$(ResgenToolPath)"
         ExecuteAsTool="$(ResGenExecuteAsTool)"
         EnvironmentVariables="$(ResGenEnvironment)"
+        WarnOnBinaryFormatterUse="$(GenerateResourceWarnOnBinaryFormatterUse)"
         MSBuildRuntime="$(GenerateResourceMSBuildRuntime)"
-        MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
+        MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)"
+        >
 
       <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>
       <Output TaskParameter="StronglyTypedFileName" ItemName="Compile"/>
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index a55f04aa68c..86faefd4fb7 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -537,6 +537,7 @@ internal static class NativeMethods
 
         internal const int HRESULT_E_CLASSNOTREGISTERED = -2147221164;
 
+        internal const int ERROR_INVALID_FILENAME = -2147024773; // Illegal characters in name
         internal const int ERROR_ACCESS_DENIED = -2147024891; // ACL'd or r/o
         internal const int ERROR_SHARING_VIOLATION = -2147024864; // File locked by another use
 
@@ -809,7 +810,7 @@ internal static bool MakeHardLink(string newFileName, string exitingFileName, re
             else
             {
                 hardLinkCreated = link(exitingFileName, newFileName) == 0;
-                errorMessage = hardLinkCreated ? null : log.FormatResourceString("Copy.LinklibraryFailedPrefix", "link()", Marshal.GetLastWin32Error());
+                errorMessage = hardLinkCreated ? null : log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "link()", Marshal.GetLastWin32Error());
             }
 
             return hardLinkCreated;
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index ea0be01f3fa..2a3c042cff0 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -125,13 +125,13 @@ public override void Translate(ITranslator translator)
             translator.Translate(ref baseLinkedFileDirectory);
         }
 
-        internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
+        internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             // First, try to retrieve the resx information from our hashtable.
             if (!resXFiles.TryGetValue(resxFile, out ResXFile retVal))
             {
                 // Ok, the file wasn't there.  Add it to our cache and return it to the caller.  
-                retVal = AddResxFile(resxFile, useMSBuildResXReader);
+                retVal = AddResxFile(resxFile, useMSBuildResXReader, log, logWarningForBinaryFormatter);
             }
             else
             {
@@ -141,19 +141,19 @@ internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
                 {
                     resXFiles.Remove(resxFile);
                     _isDirty = true;
-                    retVal = AddResxFile(resxFile, useMSBuildResXReader);
+                    retVal = AddResxFile(resxFile, useMSBuildResXReader, log, logWarningForBinaryFormatter);
                 }
             }
 
             return retVal;
         }
 
-        private ResXFile AddResxFile(string file, bool useMSBuildResXReader)
+        private ResXFile AddResxFile(string file, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             // This method adds a .resx file "file" to our .resx cache.  The method causes the file
             // to be cracked for contained files.
 
-            var resxFile = new ResXFile(file, BaseLinkedFileDirectory, useMSBuildResXReader);
+            var resxFile = new ResXFile(file, BaseLinkedFileDirectory, useMSBuildResXReader, log, logWarningForBinaryFormatter);
             resXFiles.Add(file, resxFile);
             _isDirty = true;
             return resxFile;
@@ -230,7 +230,7 @@ internal sealed class ResXFile : DependencyFile, ITranslatable
 
             internal string[] LinkedFiles => linkedFiles;
 
-            internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader) : base(filename)
+            internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter) : base(filename)
             {
                 // Creates a new ResXFile object and populates the class member variables
                 // by computing a list of linked files within the .resx that was passed in.
@@ -239,7 +239,7 @@ internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBui
 
                 if (FileSystems.Default.FileExists(FileName))
                 {
-                    linkedFiles = GetLinkedFiles(filename, baseLinkedFileDirectory, useMSBuildResXReader);
+                    linkedFiles = GetLinkedFiles(filename, baseLinkedFileDirectory, useMSBuildResXReader, log, logWarningForBinaryFormatter);
                 }
             }
 
@@ -260,7 +260,7 @@ public void Translate(ITranslator translator)
             /// </summary>
             /// <exception cref="ArgumentException">May be thrown if Resx is invalid. May contain XmlException.</exception>
             /// <exception cref="XmlException">May be thrown if Resx is invalid</exception>
-            private static string[] GetLinkedFiles(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader)
+            private static string[] GetLinkedFiles(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
             {
                 // This method finds all linked .resx files for the .resx file that is passed in.
                 // filename is the filename of the .resx file that is to be examined.
@@ -270,7 +270,7 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
 
                 if (useMSBuildResXReader)
                 {
-                    foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, pathsRelativeToBasePath: baseLinkedFileDirectory == null))
+                    foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, pathsRelativeToBasePath: baseLinkedFileDirectory == null, log, logWarningForBinaryFormatter))
                     {
                         if (resource is FileStreamResource linkedResource)
                         {
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index be85bca1a5f..deade89479b 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -158,7 +158,7 @@ private bool ResolveAssemblyKey()
                             fs?.Close();
                         }
 #else
-                        Log.LogError("PFX signing not supported on .NET Core");
+                        Log.LogErrorWithCodeFromResources("ResolveKeySource.PfxUnsupported");
                         pfxSuccess = false;
 #endif
                     }
@@ -266,7 +266,7 @@ private bool ResolveManifestKey()
                     }
                 }
 #else
-                Log.LogError("Certificate signing not supported on .NET Core");
+                Log.LogErrorWithCodeFromResources("ResolveKeySource.PfxUnsupported");
 #endif
             }
             else if (!certInStore && !string.IsNullOrEmpty(CertificateFile) && !string.IsNullOrEmpty(CertificateThumbprint))
diff --git a/src/Tasks/ResolveProjectBase.cs b/src/Tasks/ResolveProjectBase.cs
index 7be78aa7458..d70b7805f11 100644
--- a/src/Tasks/ResolveProjectBase.cs
+++ b/src/Tasks/ResolveProjectBase.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.IO;
 using System.Xml;
 
 using Microsoft.Build.Framework;
@@ -42,25 +41,10 @@ public ITaskItem[] ProjectReferences
         // This field stores all the distinct project references by project absolute path
         private readonly HashSet<string> _cachedProjectReferencesByAbsolutePath = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
-        // This field stores pre-cached project elements for project guids for quicker access by project guid
-        private readonly Dictionary<string, XmlElement> _cachedProjectElements = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
-
-        // This field stores pre-cached project elements for project guids for quicker access by project absolute path
-        private readonly Dictionary<string, XmlElement> _cachedProjectElementsByAbsolutePath = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
-
-        // This field stores the project absolute path for quicker access by project guid
-        private readonly Dictionary<string, string> _cachedProjectAbsolutePathsByGuid = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
-        // This field stores the project guid for quicker access by project absolute path
-        private readonly Dictionary<string, string> _cachedProjectGuidsByAbsolutePath = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
-        // This field stores the list of dependency project guids by depending project guid
-        private readonly Dictionary<string, List<string>> _cachedDependencyProjectGuidsByDependingProjectGuid = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+        private SolutionConfiguration _solutionConfiguration = SolutionConfiguration.Empty;
 
         private const string attributeProject = "Project";
 
-        private const string attributeAbsolutePath = "AbsolutePath";
-
         #endregion
 
         #region Methods
@@ -121,86 +105,7 @@ internal bool VerifyProjectReferenceItems(ITaskItem[] references, bool treatAsEr
         /// <summary>
         /// Pre-cache individual project elements from the XML string in a hashtable for quicker access.
         /// </summary>
-        internal void CacheProjectElementsFromXml(string xmlString)
-        {
-            // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
-            XmlDocument doc = null;
-
-            if (!string.IsNullOrEmpty(xmlString))
-            {
-                doc = new XmlDocument();
-                var settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                using (XmlReader reader = XmlReader.Create(new StringReader(xmlString), settings))
-                {
-                    doc.Load(reader);
-                }
-            }
-
-            // Example:
-            //
-            // <SolutionConfiguration>
-            //  <ProjectConfiguration Project="{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}" AbsolutePath="c:foo\Project1\A.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
-            //  <ProjectConfiguration Project="{881C1674-4ECA-451D-85B6-D7C59B7F16FA}" AbsolutePath="c:foo\Project2\B.csproj" BuildProjectInSolution="True">Debug|AnyCPU<ProjectDependency Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" /></ProjectConfiguration>
-            //  <ProjectConfiguration Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" AbsolutePath="c:foo\Project3\C.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
-            // </SolutionConfiguration>
-            //
-            if (doc?.DocumentElement != null)
-            {
-                foreach (XmlElement xmlElement in doc.DocumentElement.ChildNodes)
-                {
-                    string projectGuid = xmlElement.GetAttribute(attributeProject);
-                    string projectAbsolutePath = xmlElement.GetAttribute(attributeAbsolutePath);
-
-                    // What we really want here is the normalized path, like we'd get with an item's "FullPath" metadata.  However, 
-                    // if there's some bogus full path in the solution configuration (e.g. a website with a "full path" of c:\solutiondirectory\http://localhost) 
-                    // we do NOT want to throw -- chances are extremely high that that's information that will never actually be used.  So resolve the full path 
-                    // but just swallow any IO-related exceptions that result.  If the path is bogus, the method will return null, so we'll just quietly fail 
-                    // to cache it below. 
-                    projectAbsolutePath = FileUtilities.GetFullPathNoThrow(projectAbsolutePath);
-
-                    if (!string.IsNullOrEmpty(projectGuid))
-                    {
-                        _cachedProjectElements[projectGuid] = xmlElement;
-                        if (!string.IsNullOrEmpty(projectAbsolutePath))
-                        {
-                            _cachedProjectElementsByAbsolutePath[projectAbsolutePath] = xmlElement;
-                            _cachedProjectAbsolutePathsByGuid[projectGuid] = projectAbsolutePath;
-                            _cachedProjectGuidsByAbsolutePath[projectAbsolutePath] = projectGuid;
-                        }
-
-                        foreach (XmlNode dependencyNode in xmlElement.ChildNodes)
-                        {
-                            if (dependencyNode.NodeType != XmlNodeType.Element)
-                            {
-                                continue;
-                            }
-
-                            XmlElement dependencyElement = ((XmlElement)dependencyNode);
-
-                            if (!String.Equals(dependencyElement.Name, "ProjectDependency", StringComparison.Ordinal))
-                            {
-                                continue;
-                            }
-
-                            string dependencyGuid = dependencyElement.GetAttribute("Project");
-
-                            if (dependencyGuid.Length == 0)
-                            {
-                                continue;
-                            }
-
-                            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out List<string> list))
-                            {
-                                list = new List<string>();
-                                _cachedDependencyProjectGuidsByDependingProjectGuid.Add(projectGuid, list);
-                            }
-
-                            list.Add(dependencyGuid);
-                        }
-                    }
-                }
-            }
-        }
+        internal void CacheProjectElementsFromXml(string xmlString) => _solutionConfiguration = new SolutionConfiguration(xmlString);
 
         /// <summary>
         /// Helper method for retrieving whatever was stored in the XML string for the given project
@@ -219,7 +124,7 @@ protected XmlElement GetProjectElement(ITaskItem projectRef)
         {
             string projectGuid = projectRef.GetMetadata(attributeProject);
 
-            if ((_cachedProjectElements.TryGetValue(projectGuid, out XmlElement projectElement)) && (projectElement != null))
+            if (_solutionConfiguration.TryGetProjectByGuid(projectGuid, out XmlElement projectElement))
             {
                 return projectElement;
             }
@@ -228,7 +133,7 @@ protected XmlElement GetProjectElement(ITaskItem projectRef)
             // next we'll try a lookup by the absolute path of the project
             string projectFullPath = projectRef.GetMetadata("FullPath"); // reserved metadata "FullPath" is used at it will cache the value
 
-            if ((_cachedProjectElementsByAbsolutePath.TryGetValue(projectFullPath, out projectElement)) && (projectElement != null))
+            if (_solutionConfiguration.TryGetProjectByAbsolutePath(projectFullPath, out projectElement))
             {
                 return projectElement;
             }
@@ -243,14 +148,14 @@ protected XmlElement GetProjectElement(ITaskItem projectRef)
         protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath)
         {
             // Get the guid for this project
-            if (!_cachedProjectGuidsByAbsolutePath.TryGetValue(currentProjectAbsolutePath, out string projectGuid))
+            if (!_solutionConfiguration.TryGetProjectGuidByAbsolutePath(currentProjectAbsolutePath, out string projectGuid))
             {
                 // We were passed a blob, but we weren't listed in it. Odd. Return.
                 return;
             }
 
             // Use the guid to look up the dependencies for it
-            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out List<string> guids))
+            if (!_solutionConfiguration.TryGetProjectDependencies(projectGuid, out List<string> guids))
             {
                 // We didn't have dependencies listed in the blob
                 return;
@@ -262,7 +167,7 @@ protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath)
             foreach (string guid in guids)
             {
                 // Get the absolute path of the dependency, using the blob
-                if (!_cachedProjectAbsolutePathsByGuid.TryGetValue(guid, out string path))
+                if (!_solutionConfiguration.TryGetProjectPathByGuid(guid, out string path))
                 {
                     // We had a dependency listed in the blob that wasn't itself in the blob. Odd. Return.
                     continue;
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index e8ea34b2e30..d279d8fd9e2 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -1037,11 +1037,11 @@ private void GetSDKManifestAttributes()
                 {
                     if (_sdkManifest.FrameworkIdentities != null)
                     {
-                        foreach (string key in _sdkManifest.FrameworkIdentities.Keys)
+                        foreach (KeyValuePair<string, string> kvp in _sdkManifest.FrameworkIdentities)
                         {
-                            if (!FrameworkIdentitiesFromManifest.ContainsKey(key))
+                            if (!FrameworkIdentitiesFromManifest.ContainsKey(kvp.Key))
                             {
-                                FrameworkIdentitiesFromManifest.Add(key, _sdkManifest.FrameworkIdentities[key]);
+                                FrameworkIdentitiesFromManifest.Add(kvp.Key, kvp.Value);
                             }
                         }
                     }
@@ -1054,11 +1054,11 @@ private void GetSDKManifestAttributes()
                 {
                     if (_sdkManifest.AppxLocations != null)
                     {
-                        foreach (string key in _sdkManifest.AppxLocations.Keys)
+                        foreach (KeyValuePair<string, string> kvp in _sdkManifest.AppxLocations)
                         {
-                            if (!AppxLocationsFromManifest.ContainsKey(key))
+                            if (!AppxLocationsFromManifest.ContainsKey(kvp.Key))
                             {
-                                AppxLocationsFromManifest.Add(key, _sdkManifest.AppxLocations[key]);
+                                AppxLocationsFromManifest.Add(kvp.Key, kvp.Value);
                             }
                         }
                     }
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 765a023a102..664927523f3 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -9,6 +9,7 @@
 using System.Xml;
 using System.Xml.Linq;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -16,7 +17,7 @@ namespace Microsoft.Build.Tasks.ResourceHandling
 {
     internal class MSBuildResXReader
     {
-        public static IReadOnlyList<IResource> ReadResources(Stream s, string filename, bool pathsRelativeToBasePath)
+        public static IReadOnlyList<IResource> ReadResources(Stream s, string filename, bool pathsRelativeToBasePath, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             var resources = new List<IResource>();
             var aliases = new Dictionary<string, string>();
@@ -38,7 +39,7 @@ public static IReadOnlyList<IResource> ReadResources(Stream s, string filename,
                             case "resheader":
                                 break;
                             case "data":
-                                ParseData(filename, pathsRelativeToBasePath, resources, aliases, elem);
+                                ParseData(filename, pathsRelativeToBasePath, resources, aliases, elem, log, logWarningForBinaryFormatter);
                                 break;
                         }
                     }
@@ -101,7 +102,14 @@ private static string GetFullTypeNameFromAlias(string aliasedTypeName, Dictionar
             return aliasedTypeName;
         }
 
-        private static void ParseData(string resxFilename, bool pathsRelativeToBasePath, List<IResource> resources, Dictionary<string, string> aliases, XElement elem)
+        private static void ParseData(
+            string resxFilename,
+            bool pathsRelativeToBasePath,
+            List<IResource> resources,
+            Dictionary<string, string> aliases,
+            XElement elem,
+            TaskLoggingHelper log,
+            bool logWarningForBinaryFormatter)
         {
             string name = elem.Attribute("name").Value;
             string value;
@@ -186,6 +194,12 @@ private static void ParseData(string resxFilename, bool pathsRelativeToBasePath,
                     case BinSerializedObjectMimeType:
                     case Beta2CompatSerializedObjectMimeType:
                     case CompatBinSerializedObjectMimeType:
+                        // Warn of BinaryFormatter exposure (SDK should turn this on by default in .NET 8+)
+                        if (logWarningForBinaryFormatter)
+                        {
+                            log?.LogWarningWithCodeFromResources(null, resxFilename, ((IXmlLineInfo)elem).LineNumber, ((IXmlLineInfo)elem).LinePosition, 0, 0, "GenerateResource.BinaryFormatterUse", name, typename);
+                        }
+
                         // BinaryFormatter from byte array
                         byte[] binaryFormatterBytes = Convert.FromBase64String(value);
 
@@ -284,19 +298,19 @@ internal static bool IsMemoryStream(string fileRefType)
         /// <summary>
         /// Extract <see cref="IResource"/>s from a given file on disk.
         /// </summary>
-        public static IReadOnlyList<IResource> GetResourcesFromFile(string filename, bool pathsRelativeToBasePath)
+        public static IReadOnlyList<IResource> GetResourcesFromFile(string filename, bool pathsRelativeToBasePath, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             using (var x = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
-                return ReadResources(x, filename, pathsRelativeToBasePath);
+                return ReadResources(x, filename, pathsRelativeToBasePath, log, logWarningForBinaryFormatter);
             }
         }
 
-        public static IReadOnlyList<IResource> GetResourcesFromString(string resxContent, string basePath = null, bool? useRelativePath = null)
+        public static IReadOnlyList<IResource> GetResourcesFromString(string resxContent, TaskLoggingHelper log, bool logWarningForBinaryFormatter, string basePath = null, bool? useRelativePath = null)
         {
             using (var x = new MemoryStream(Encoding.UTF8.GetBytes(resxContent)))
             {
-                return ReadResources(x, basePath, useRelativePath.GetValueOrDefault(basePath != null));
+                return ReadResources(x, basePath, useRelativePath.GetValueOrDefault(basePath != null), log, logWarningForBinaryFormatter);
             }
         }
 
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 4e11332ddd7..c9326aeb55c 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1164,6 +1164,11 @@
     <value>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</value>
     <comment>{StrBegin="MSB3824: "}</comment>
   </data>
+  <data name="GenerateResource.BinaryFormatterUse">
+    <value>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</value>
+    <comment>{StrBegin="MSB3825: "}</comment>
+  </data>
 
 
   <!--
@@ -2970,6 +2975,9 @@
   <data name="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
     <value>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</value>
   </data>
+  <data name="ResolveKeySource.PfxUnsupported" xml:space="preserve">
+    <value>PFX signing not supported on .NET Core.</value>
+  </data>
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 96f99318e42..bca774edb0c 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: Funkce ClickOnce nepodporuje poÅ¾adovanou ÃºroveÅˆ provedenÃ­ {0}.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Aby bylo moÅ¾nÃ© provÃ©st sestavenÃ­ pomocÃ­ .NET Core, musÃ­ bÃ½t vstupy prostÅ™edkÅ¯ ve formÃ¡tu .txt nebo .resx.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: NÃ¡sledujÃ­cÃ­ soubor klÃ­ÄÅ¯ nelze importovat: {0}. Soubor klÃ­ÄÅ¯ mÅ¯Å¾e bÃ½t chrÃ¡nÄ›n heslem. Chcete-li problÃ©m vyÅ™eÅ¡it, naimportujte certifikÃ¡t znovu nebo certifikÃ¡t naimportujte ruÄnÄ› do osobnÃ­ho ÃºloÅ¾iÅ¡tÄ› certifikÃ¡tÅ¯ aktuÃ¡lnÃ­ho uÅ¾ivatele.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: V ÃºloÅ¾iÅ¡ti certifikÃ¡tÅ¯ Windows aktuÃ¡lnÃ­ho uÅ¾ivatele se nedÃ¡ najÃ­t certifikÃ¡t pro podpis kÃ³du. Pokud chcete tento problÃ©m opravit, zakaÅ¾te podepisovÃ¡nÃ­ manifestu ClickOnce, nebo do ÃºloÅ¾iÅ¡tÄ› certifikÃ¡tÅ¯ nainstalujte certifikÃ¡t.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 75ded2f6afe..02fc298ff4d 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: Die AnforderungsausfÃ¼hrungsebene "{0}" wird von ClickOnce nicht unterstÃ¼tzt.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: FÃ¼r die Kompilierung mit .NET Core mÃ¼ssen Ressourceneingaben im TXT- oder RESX-Format vorliegen.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: Die folgende SchlÃ¼sseldatei kann nicht importiert werden: {0}. Die SchlÃ¼sseldatei ist mÃ¶glicherweise kennwortgeschÃ¼tzt. Importieren Sie das Zertifikat erneut, oder importieren Sie das Zertifikat manuell in den persÃ¶nlichen Zertifikatspeicher des aktuellen Benutzers, um das Problem zu beheben.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Das Codesignaturzertifikat wurde im Windows-Zertifikatspeicher des aktuellen Benutzers nicht gefunden. Deaktivieren Sie entweder das Signieren des ClickOnce-Manifests, oder installieren Sie das Zertifikat im Zertifikatspeicher, um das Problem zu beheben.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 54b8a2fc33e..e1d93e25454 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce no admite el nivel de ejecuciÃ³n de solicitudes '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Para compilar con .NET Core, las entradas de recursos deben estar en formato .txt o .resx.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: No se puede importar el archivo de clave siguiente: {0}. Puede que estÃ© protegido mediante contraseÃ±a. Para solucionar este problema, intente importar de nuevo el certificado o impÃ³rtelo manualmente en el almacÃ©n de certificados personales del usuario.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: No se puede encontrar el certificado de firma de cÃ³digo en el almacÃ©n de certificados de Windows del usuario actual. Para solucionarlo, deshabilite la firma del manifiesto de ClickOnce o instale el certificado en el almacÃ©n de certificados.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 5a9103e81e3..3d90e34c124 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce ne prend pas en charge le niveau d'exÃ©cution de la requÃªte '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Pour pouvoir gÃ©nÃ©rer avec .NET Core, les entrÃ©es de ressource doivent Ãªtre au format .txt ou .resx.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: Impossible d'importer le fichier de clÃ© suivantÂ : {0}. Le fichier de clÃ© est peut-Ãªtre protÃ©gÃ© par mot de passe. Pour corriger ce problÃ¨me, essayez de rÃ©importer le certificat, ou importez manuellement le certificat dans le magasin de certificats personnel de l'utilisateur actuel.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Le certificat de signature de code est introuvable dans le magasin de certificats Windows de l'utilisateur actuel. Pour corriger ce problÃ¨me, dÃ©sactivez la signature du manifeste ClickOnce ou installez le certificat dans le magasin de certificats.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 3984920bafb..6f5a9844c92 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce non supporta il livello di esecuzione richieste '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: per compilare con .NET Core, gli input delle risorse devono essere in formato. txt o. resx.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: non Ã¨ possibile importare il seguente file di chiave: {0}. Il file di chiave potrebbe essere protetto da password. Per risolvere il problema, provare a importare di nuovo il certificato oppure importarlo manualmente nell'archivio certificati personale dell'utente corrente.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: il certificato di firma del codice non Ã¨ stato trovato nell'archivio certificati Windows dell'utente corrente. Per risolvere il problema, disabilitare la firma del manifesto ClickOnce o installare il certificato nell'archivio certificati.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index add44ed6905..c6e45115596 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce ã§ã¯ã€è¦æ±‚ã®å®Ÿè¡Œãƒ¬ãƒ™ãƒ« '{0}' ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET Core ã‚’ä½¿ç”¨ã—ã¦ãƒ“ãƒ«ãƒ‰ã™ã‚‹ã«ã¯ã€ãƒªã‚½ãƒ¼ã‚¹ã®å…¥åŠ›ã‚’ .txt å½¢å¼ã¾ãŸã¯ .resx å½¢å¼ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: æ¬¡ã®ã‚­ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã¾ã›ã‚“: {0}ã€‚ã‚­ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«ã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ä¿è­·ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®çŠ¶æ³ã‚’è§£æ±ºã™ã‚‹ã«ã¯ã€è¨¼æ˜Žæ›¸ã‚’ã‚‚ã†ä¸€åº¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã‹ã€ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å€‹äººè¨¼æ˜Žæ›¸ã‚¹ãƒˆã‚¢ã«è¨¼æ˜Žæ›¸ã‚’æ‰‹å‹•ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã® Windows è¨¼æ˜Žæ›¸ã‚¹ãƒˆã‚¢ã«ã‚³ãƒ¼ãƒ‰ç½²åè¨¼æ˜Žæ›¸ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã‚’ä¿®æ­£ã™ã‚‹ã«ã¯ã€ClickOnce ãƒžãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã®ç½²åã‚’ç„¡åŠ¹ã«ã™ã‚‹ã‹ã€è¨¼æ˜Žæ›¸ã‚¹ãƒˆã‚¢ã«è¨¼æ˜Žæ›¸ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãã ã•ã„ã€‚</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 48899fff5c2..247e0bd0d38 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnceëŠ” ìš”ì²­ ì‹¤í–‰ ìˆ˜ì¤€ '{0}'ì„(ë¥¼) ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET Coreë¡œ ë¹Œë“œí•˜ë ¤ë©´ ë¦¬ì†ŒìŠ¤ ìž…ë ¥ì´ .txt ë˜ëŠ” .resx í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: í‚¤ íŒŒì¼ {0}ì„(ë¥¼) ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í•´ë‹¹ í‚¤ íŒŒì¼ì´ ì•”í˜¸ë¡œ ë³´í˜¸ë˜ì–´ ìžˆì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ë ¤ë©´ ì¸ì¦ì„œë¥¼ ë‹¤ì‹œ ê°€ì ¸ì˜¤ê±°ë‚˜ í˜„ìž¬ ì‚¬ìš©ìžì˜ ê°œì¸ ì¸ì¦ì„œ ì €ìž¥ì†Œë¡œ ì¸ì¦ì„œë¥¼ ì§ì ‘ ê°€ì ¸ì˜¤ì„¸ìš”.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: í˜„ìž¬ ì‚¬ìš©ìžì˜ Windows ì¸ì¦ì„œ ì €ìž¥ì†Œì—ì„œ ì½”ë“œ ì„œëª… ì¸ì¦ì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ë ¤ë©´ ClickOnce ë§¤ë‹ˆíŽ˜ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šë„ë¡ ì„¤ì •í•˜ê±°ë‚˜ ì¸ì¦ì„œë¥¼ ì¸ì¦ì„œ ì €ìž¥ì†Œì— ì„¤ì¹˜í•˜ì„¸ìš”.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index cc3d37d5b02..556b24e7acc 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: Funkcja ClickOnce nie obsÅ‚uguje poziomu wykonania Å¼Ä…dania â€ž{0}â€.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Aby kompilowaÄ‡ przy uÅ¼yciu platformy .NET Core, dane wejÅ›ciowe zasobÃ³w muszÄ… byÄ‡ w formacie txt lub resx.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: Nie moÅ¼na zaimportowaÄ‡ nastÄ™pujÄ…cego pliku klucza: {0}. Plik klucza moÅ¼e byÄ‡ chroniony hasÅ‚em. Aby rozwiÄ…zaÄ‡ ten problem, sprÃ³buj ponownie zaimportowaÄ‡ certyfikat lub zaimportuj certyfikat rÄ™cznie do osobistego magazynu certyfikatÃ³w bieÅ¼Ä…cego uÅ¼ytkownika.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Nie moÅ¼na znaleÅºÄ‡ certyfikatu podpisywania kodu w magazynie certyfikatÃ³w bieÅ¼Ä…cego uÅ¼ytkownika systemu Windows. Aby naprawiÄ‡ ten bÅ‚Ä…d, wyÅ‚Ä…cz podpisywanie manifestu ClickOnce lub zainstaluj certyfikat w magazynie certyfikatÃ³w.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index f9f814a7a0a..ff5f0631ac6 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: O ClickOnce nÃ£o dÃ¡ suporte ao nÃ­vel de execuÃ§Ã£o de solicitaÃ§Ã£o "{0}".</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Para compilar com o .NET Core, as entradas de recurso devem estar em formato .txt ou .resx.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: NÃ£o Ã© possÃ­vel importar o seguinte arquivo de chave: {0}. Talvez esse arquivo de chave esteja protegido por senha. Para corrigir isso, tente importar o certificado de novo ou importe-o manualmente para o repositÃ³rio de certificados pessoal do usuÃ¡rio atual.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: NÃ£o foi possÃ­vel encontrar o certificado de assinatura de cÃ³digo no repositÃ³rio de certificados do Windows do usuÃ¡rio atual. Para corrigir isso, desabilite a assinatura do manifesto ClickOnce ou instale o certificado no repositÃ³rio de certificados.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 3dffae2d5d2..b5f6f6d6e45 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce Ð½Ðµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° "{0}".</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Ð´Ð»Ñ ÑÐ±Ð¾Ñ€ÐºÐ¸ Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ .NETÂ Core Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ñ€ÐµÑÑƒÑ€ÑÐ¾Ð² Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð±Ñ‹Ñ‚ÑŒ Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ TXT Ð¸Ð»Ð¸ RESX.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: Ð½ÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹ Ñ„Ð°Ð¹Ð» ÐºÐ»ÑŽÑ‡Ð°: {0}. Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾, Ñ„Ð°Ð¹Ð» ÐºÐ»ÑŽÑ‡Ð° Ð·Ð°Ñ‰Ð¸Ñ‰ÐµÐ½ Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼. Ð§Ñ‚Ð¾Ð±Ñ‹ ÑƒÑÑ‚Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÑÑ‚Ñƒ Ð¾ÑˆÐ¸Ð±ÐºÑƒ, Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÑƒ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð° ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð° Ð¸Ð»Ð¸ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚ Ð² Ð»Ð¸Ñ‡Ð½Ð¾Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ð² Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Ð½Ðµ ÑƒÐ´Ð°ÐµÑ‚ÑÑ Ð½Ð°Ð¹Ñ‚Ð¸ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐ¸ ÐºÐ¾Ð´Ð° Ð² Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ð² Windows Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ. Ð§Ñ‚Ð¾Ð±Ñ‹ Ð¸ÑÐ¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ ÑÑ‚Ð¾, Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ðµ Ð¿Ð¾Ð´Ð¿Ð¸ÑÑ‹Ð²Ð°Ð½Ð¸Ðµ Ð¼Ð°Ð½Ð¸Ñ„ÐµÑÑ‚Ð° ClickOnce Ð¸Ð»Ð¸ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚Ðµ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚ Ð² Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ð².</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 60d73e52bd0..a3895944b7c 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce, '{0}' istek yÃ¼rÃ¼tme dÃ¼zeyini desteklemiyor.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET Core ile derlemek iÃ§in kaynak giriÅŸleri .txt veya .resx biÃ§iminde olmalÄ±dÄ±r.</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: Åžu anahtar dosyasÄ± iÃ§eri aktarÄ±lamÄ±yor: {0}. Anahtar dosyasÄ± parola korumalÄ± olabilir. Bunu dÃ¼zeltmek iÃ§in, sertifikayÄ± yeniden iÃ§eri aktarmayÄ± deneyin veya sertifikayÄ± el ile geÃ§erli kullanÄ±cÄ±nÄ±n kiÅŸisel sertifika deposuna aktarÄ±n.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: GeÃ§erli kullanÄ±cÄ±nÄ±n Windows sertifika deposunda kod imzalama sertifikasÄ± bulunamadÄ±. Bunu dÃ¼zeltmek iÃ§in, ClickOnce bildiriminin imzalanmasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±n veya sertifikayÄ± sertifika deposuna yÃ¼kleyin.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index f9e81643eb2..90455729587 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce ä¸æ”¯æŒè¯·æ±‚æ‰§è¡Œçº§åˆ«â€œ{0}â€ã€‚</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: è¦ä½¿ç”¨ .NET Core è¿›è¡Œç”Ÿæˆï¼Œèµ„æºè¾“å…¥å¿…é¡»ä¸º .txt æˆ– .resx æ ¼å¼ã€‚</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: æ— æ³•å¯¼å…¥ä»¥ä¸‹å¯†é’¥æ–‡ä»¶: {0}ã€‚è¯¥å¯†é’¥æ–‡ä»¶å¯èƒ½å—å¯†ç ä¿æŠ¤ã€‚è‹¥è¦æ›´æ­£æ­¤é—®é¢˜ï¼Œè¯·å°è¯•å†æ¬¡å¯¼å…¥è¯ä¹¦ï¼Œæˆ–æ‰‹åŠ¨å°†è¯ä¹¦å¯¼å…¥å½“å‰ç”¨æˆ·çš„ä¸ªäººè¯ä¹¦å­˜å‚¨ä¸­ã€‚</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: æ— æ³•åœ¨å½“å‰ç”¨æˆ·çš„ Windows è¯ä¹¦å­˜å‚¨ä¸­æ‰¾åˆ°ä»£ç ç­¾åè¯ä¹¦ã€‚è‹¥è¦æ›´æ­£æ­¤é—®é¢˜ï¼Œè¯·ç¦ç”¨ ClickOnce æ¸…å•çš„ç­¾åæˆ–å°†è¯ä¹¦å®‰è£…åˆ°è¯ä¹¦å­˜å‚¨ä¸­ã€‚</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 424ff758e82..7b9058dccae 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1044,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce ä¸æ”¯æ´è¦æ±‚åŸ·è¡Œå±¤ç´š '{0}'ã€‚</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: è‹¥è¦ä½¿ç”¨ .NET Core å»ºç½®ï¼Œè³‡æºè¼¸å…¥å¿…é ˆæŽ¡ç”¨ .txt æˆ– .resx æ ¼å¼ã€‚</target>
@@ -2363,6 +2370,11 @@
         <target state="translated">MSB3326: ç„¡æ³•åŒ¯å…¥ä¸‹åˆ—é‡‘é‘°æª”: {0}ã€‚æ­¤é‡‘é‘°æª”å¯èƒ½æœ‰å¯†ç¢¼ä¿è­·ã€‚è‹¥è¦æ”¹æ­£é€™ç¨®æƒ…æ³ï¼Œè«‹å˜—è©¦å†æ¬¡åŒ¯å…¥æ†‘è­‰ï¼Œæˆ–æ‰‹å‹•å°‡æ†‘è­‰åŒ¯å…¥åˆ°ç›®å‰ä½¿ç”¨è€…çš„å€‹äººæ†‘è­‰å­˜æ”¾å€ã€‚</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current userâ€™s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: åœ¨ç›®å‰ä½¿ç”¨è€…çš„ Windows æ†‘è­‰å­˜æ”¾å€ä¸­ï¼Œæ‰¾ä¸åˆ°ç¨‹å¼ç¢¼ç°½ç½²æ†‘è­‰ã€‚è‹¥è¦æ›´æ­£æ­¤å•é¡Œï¼Œè«‹åœç”¨ ClickOnce è³‡è¨Šæ¸…å–®çš„ç°½ç½²ï¼Œæˆ–å°‡æ†‘è­‰å®‰è£åˆ°æ†‘è­‰å­˜æ”¾å€ã€‚</target>
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 6f53fd01eba..77128537b7a 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -67,7 +67,7 @@ public class WriteCodeFragment : TaskExtension
         /// The path to the file that was generated.
         /// If this is set, and a file name, the destination folder will be prepended.
         /// If this is set, and is rooted, the destination folder will be ignored.
-        /// If this is not set, the destination folder will be used, an arbitrary file name will be used, and 
+        /// If this is not set, the destination folder will be used, an arbitrary file name will be used, and
         /// the default extension for the language selected.
         /// </summary>
         [Output]
@@ -113,6 +113,8 @@ public override bool Execute()
 
                 OutputFile ??= new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, null, extension));
 
+                FileUtilities.EnsureDirectoryExists(Path.GetDirectoryName(OutputFile.ItemSpec));
+
                 File.WriteAllText(OutputFile.ItemSpec, code); // Overwrites file if it already exists (and can be overwritten)
             }
             catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
@@ -481,7 +483,7 @@ private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<At
                     Log.LogMessageFromResources("WriteCodeFragment.MultipleConstructorsFound");
 
                     // Before parameter types could be specified, all parameter values were
-                    // treated as strings. To be backward-compatible, we need to prefer 
+                    // treated as strings. To be backward-compatible, we need to prefer
                     // the constructor that has all string parameters, if it exists.
                     var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));
 
@@ -551,7 +553,7 @@ private bool TryConvertParameterValue(string typeName, string rawValue, out Code
         /// </summary>
         private CodeExpression ConvertParameterValueToInferredType(Type inferredType, string rawValue, string parameterName)
         {
-            // If we don't know what type the parameter should be, then we 
+            // If we don't know what type the parameter should be, then we
             // can't convert the type. We'll just treat is as a string.
             if (inferredType is null)
             {
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 64fa68b16e5..d06b02ad782 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -72,9 +72,6 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Shared\CopyOnWriteDictionary.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>Shared\EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <Link>Shared\ErrorUtilities.cs</Link>
     </Compile>
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 82ed1626244..f687076fbfb 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -884,11 +884,12 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     if (!_maintainCompositeRootingMarkers)
                     {
-                        foreach (string primaryFile in DependencyTable.Keys)
+                        foreach (KeyValuePair<string, Dictionary<string, string>> dependency in DependencyTable)
                         {
+                            string primaryFile = dependency.Key;
                             if (!primaryFile.Contains("|")) // composite roots are not needed
                             {
-                                Dictionary<string, string> dependencies = DependencyTable[primaryFile];
+                                Dictionary<string, string> dependencies = dependency.Value;
                                 inputs.WriteLine("^" + primaryFile);
                                 foreach (string file in dependencies.Keys)
                                 {
@@ -906,10 +907,10 @@ public void SaveTlog(DependencyFilter includeInTLog)
                     {
                         // Just output the rooting markers and their dependencies -- we don't want to
                         // compact out the composite ones.
-                        foreach (string rootingMarker in DependencyTable.Keys)
+                        foreach (KeyValuePair<string, Dictionary<string, string>> dependency in DependencyTable)
                         {
-                            Dictionary<string, string> dependencies = DependencyTable[rootingMarker];
-                            inputs.WriteLine("^" + rootingMarker);
+                            Dictionary<string, string> dependencies = dependency.Value;
+                            inputs.WriteLine("^" + dependency.Key);
                             foreach (string file in dependencies.Keys)
                             {
                                 // Give the task a chance to filter dependencies out of the written TLog
@@ -1060,8 +1061,9 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                 var dependenciesWithoutMissingFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 int keyIndex = 0;
 
-                foreach (string file in dependencies.Keys)
+                foreach (KeyValuePair<string, string> kvp in dependencies)
                 {
+                    string file = kvp.Key;
                     if (keyIndex++ > 0)
                     {
                         // Record whether or not each file exists and cache it.
@@ -1078,7 +1080,7 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                         // Does the cached file exist?
                         if (fileExists)
                         {
-                            dependenciesWithoutMissingFiles.Add(file, dependencies[file]);
+                            dependenciesWithoutMissingFiles.Add(file, kvp.Value);
                         }
                     }
                     else
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 1c19b7868df..ef1ad5bfa5e 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -594,9 +594,10 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 // Write out the dependency information as a new tlog
                 using (StreamWriter outputs = FileUtilities.OpenWrite(firstTlog, false, System.Text.Encoding.Unicode))
                 {
-                    foreach (string rootingMarker in DependencyTable.Keys)
+                    foreach (KeyValuePair<string, Dictionary<string, DateTime>> kvp in DependencyTable)
                     {
-                        Dictionary<string, DateTime> dependencies = DependencyTable[rootingMarker];
+                        string rootingMarker = kvp.Key;
+                        Dictionary<string, DateTime> dependencies = kvp.Value;
                         outputs.WriteLine("^" + rootingMarker);
                         foreach (string file in dependencies.Keys)
                         {
@@ -754,8 +755,9 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                 var dependenciesWithoutMissingFiles = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
                 int keyIndex = 0;
 
-                foreach (string file in dependencies.Keys)
+                foreach (KeyValuePair<string, DateTime> kvp in dependencies)
                 {
+                    string file = kvp.Key;
                     if (keyIndex++ > 0)
                     {
                         // Record whether or not each file exists and cache it.
@@ -772,7 +774,7 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                         // Does the cached file exist?
                         if (fileExists)
                         {
-                            dependenciesWithoutMissingFiles.Add(file, dependencies[file]);
+                            dependenciesWithoutMissingFiles.Add(file, kvp.Value);
                         }
                     }
                     else
