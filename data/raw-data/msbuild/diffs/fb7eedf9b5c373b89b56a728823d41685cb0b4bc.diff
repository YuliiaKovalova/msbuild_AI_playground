diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 81b331862cc..2b80c13bf04 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -147,7 +147,7 @@ jobs:
 - job: CoreBootstrappedOnLinux
   displayName: "Linux Core"
   pool:
-    vmImage: 'ubuntu-16.04'
+    vmImage: 'ubuntu-latest'
   steps:
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh'
     displayName: CI Build
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 72c45c9b52f..dae4ff8d4aa 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -10,12 +10,28 @@ trigger:
 #   SignType: real
 #   SkipApplyOptimizationData: false
 
+parameters:
+- name: OptProfDropName
+  displayName: Optional OptProfDrop Override
+  type: string
+  default: 'default'
+
 variables:
+  # if OptProfDrop is not set, string '$(OptProfDrop)' will be passed to the build script.
+  - name: OptProfDrop
+    value: ''
   - name: SourceBranch
     value: $(IbcSourceBranchName)
-  - ${{ if startsWith(variables['Build.SourceBranch'], 'refs/heads/exp/') }}:
+  # If we're not on a vs* branch, use main as our optprof collection branch
+  - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
     - name: SourceBranch
       value: main
+  # if OptProfDropName is set as a parameter, set OptProfDrop to the parameter and unset SourceBranch
+  - ${{ if ne(parameters.OptProfDropName, 'default') }}:
+    - name: OptProfDrop
+      value: ${{parameters.OptProfDropName}}
+    - name: SourceBranch
+      value: ''
   - name: _DotNetArtifactsCategory
     value: .NETCore
   - name: _DotNetValidationArtifactsCategory
@@ -34,7 +50,7 @@ stages:
 
   - job: Windows_NT
     pool:
-      name: VSEng-MicroBuildVS2019
+      name: VSEngSS-MicroBuild2019
       demands:
       - agent.os -equals Windows_NT
 
@@ -47,7 +63,7 @@ stages:
     - name: TeamName
       value: MSBuild
     - name: VisualStudio.MajorVersion
-      value: 16
+      value: 17
     - name: VisualStudio.ChannelName
       value: 'int.main'
     - name: VisualStudio.DropName
@@ -72,11 +88,14 @@ stages:
         signType: $(SignType)
         zipSources: false
       condition: and(succeeded(), in(variables['SignType'], 'test', 'real'))
-
-    - task: ms-vseng.MicroBuildTasks.965C8DC6-1483-45C9-B384-5AC75DA1F1A4.MicroBuildOptProfPlugin@1
+      
+    - task: MicroBuildOptProfPlugin@6
       inputs:
-        skipRunOptimize: true
-      displayName: 'Install OptProf Plugin'
+        ProfilingInputsDropName: '$(VisualStudio.DropName)'
+        ShouldSkipOptimize: true
+        AccessToken: '$(System.AccessToken)'
+        feedSource: 'https://devdiv.pkgs.visualstudio.com/DefaultCollection/_packaging/MicroBuildToolset/nuget/v3/index.json'
+      displayName: 'Install OptProf Plugin'      
 
     # Required by MicroBuildBuildVSBootstrapper
     - task: ms-vseng.MicroBuildTasks.32f78468-e895-4f47-962c-58a699361df8.MicroBuildSwixPlugin@1
@@ -100,7 +119,7 @@ stages:
                 /p:DotNetSymbolServerTokenSymWeb=$(symweb-symbol-server-pat)
                 /p:TeamName=MSBuild
                 /p:DotNetPublishUsingPipelines=true
-                /p:VisualStudioIbcDrop=$(OptProfDropName)
+                /p:VisualStudioIbcDrop=$(OptProfDrop)
       displayName: Build
       condition: succeeded()
 
@@ -111,7 +130,7 @@ stages:
         buildNumber: 'ProfilingInputs/DevDiv/$(Build.Repository.Name)/$(Build.SourceBranchName)/$(Build.BuildNumber)'
         sourcePath: '$(Build.SourcesDirectory)\artifacts\OptProf\$(BuildConfiguration)\Data'
         toLowerCase: false
-        usePat: false
+        usePat: true
       displayName: 'OptProf - Publish to Artifact Services - ProfilingInputs'
       condition: succeeded()
 
@@ -162,11 +181,14 @@ stages:
 
     # Publishes setup VSIXes to a drop.
     # Note: The insertion tool looks for the display name of this task in the logs.
-    - task: ms-vseng.MicroBuildTasks.4305a8de-ba66-4d8b-b2d1-0dc4ecbbf5e8.MicroBuildUploadVstsDropFolder@1
+    - task: MicroBuildUploadVstsDropFolder@2
       displayName: Upload VSTS Drop
       inputs:
         DropName: $(VisualStudio.DropName)
         DropFolder: 'artifacts\VSSetup\$(BuildConfiguration)\Insertion'
+        AccessToken: '$(System.AccessToken)'
+        DropServiceUri: 'https://devdiv.artifacts.visualstudio.com'
+        VSDropServiceUri: 'https://vsdrop.corp.microsoft.com/file/v1'
       condition: succeeded()
 
     # Publish an artifact that the RoslynInsertionTool is able to find by its name.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index b5ec4e3736b..66b119cd485 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -27,7 +27,7 @@ The opt-out comes in the form of setting the environment variable `MSBuildDisabl
 - [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
 - [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
 - [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
-- [Fail restore operations when there is no `Restore` target or an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6312)
+- [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
 ### 17.0
 
 ## Change Waves No Longer In Rotation
diff --git a/eng/Packages.props b/eng/Packages.props
index d6917bd7207..bde4be1897c 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -40,7 +40,7 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(MonoBuild)' == 'true' or $([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp2.1'))">
-    <PackageReference Update="Microsoft.Extensions.DependencyModel" Version="5.0.0"/>
+    <PackageReference Update="Microsoft.Extensions.DependencyModel" Version="$(MicrosoftExtensionsDependencyModelVersion)"/>
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 6cfacc21041..8a5f0ed8f09 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,17 +1,21 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21226.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21281.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>c58c5dd7f2e9e106368caafb0d4a7a29f4b2e1e9</Sha>
+      <Sha>c7d6bd607715f334cda90e01967bb0c02dee09be</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="5.10.0-rc.7240">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-preview.1.66">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>dca1d060f38e1e02f6bfca41e25f081f19fd534b</Sha>
+      <Sha>e84a10e4b0e6bccce7421af020728d9bbc3e64e0</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="3.9.0-2.20574.26">
+    <Dependency Name="Microsoft.Extensions.DependencyModel" Version="6.0.0-preview.2.21154.6">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha />
+    </Dependency>
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.0.0-1.21277.15">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>e9fd4dc7d74932c0d4b042251bc5a88bb5b3c437</Sha>
+      <Sha>0adf94c625f834f1c89d11700621302b658a50ea</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index c0a0b1080e4..768180429cc 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -21,13 +21,17 @@
          Can be removed after Arcade moves up. -->
     <MicrosoftVSSDKBuildToolsVersion>16.7.13</MicrosoftVSSDKBuildToolsVersion>
   </PropertyGroup>
+  <!-- Production Dependencies -->
+  <PropertyGroup>
+  </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
-    <DotNetCliVersion>5.0.102</DotNetCliVersion>
-    <MicrosoftNetCompilersToolsetVersion>3.9.0-2.20574.26</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>5.10.0-rc.7240</NuGetBuildTasksVersion>
+    <DotNetCliVersion>6.0.100-preview.3.21202.5</DotNetCliVersion>
+    <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.0.0-1.21277.15</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.0.0-preview.1.66</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index 6e22aacb0d3..7c8162be341 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -96,8 +96,8 @@ try {
   else
   {
     $buildToolPath = $dotnetExePath
-    $buildToolCommand = Join-Path $bootstrapRoot "net5.0\MSBuild\MSBuild.dll"
-    $buildToolFramework = "netcoreapp2.1"
+    $buildToolCommand = Join-Path $bootstrapRoot "net6.0\MSBuild\MSBuild.dll"
+    $buildToolFramework = "netcoreapp3.1"
   }
 
   # Use separate artifacts folder for stage 2
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 26fe13a7c82..e5425507f47 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -63,8 +63,8 @@ bootstrapRoot="$Stage1Dir/bin/bootstrap"
 if [ $host_type = "core" ]
 then
   _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
-  _InitializeBuildToolCommand="$bootstrapRoot/net5.0/MSBuild/MSBuild.dll"
-  _InitializeBuildToolFramework="netcoreapp2.1"
+  _InitializeBuildToolCommand="$bootstrapRoot/net6.0/MSBuild/MSBuild.dll"
+  _InitializeBuildToolFramework="netcoreapp3.1"
 elif [ $host_type = "mono" ]
 then
   export _InitializeBuildTool="mono"
diff --git a/eng/common/build.ps1 b/eng/common/build.ps1
index 94a91c0817e..8943da242f6 100644
--- a/eng/common/build.ps1
+++ b/eng/common/build.ps1
@@ -25,6 +25,7 @@ Param(
   [switch] $prepareMachine,
   [string] $runtimeSourceFeed = '',
   [string] $runtimeSourceFeedKey = '',
+  [switch] $excludePrereleaseVS,
   [switch] $help,
   [Parameter(ValueFromRemainingArguments=$true)][String[]]$properties
 )
@@ -65,6 +66,7 @@ function Print-Usage() {
   Write-Host "  -prepareMachine         Prepare machine for CI run, clean up processes after build"
   Write-Host "  -warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
   Write-Host "  -msbuildEngine <value>  Msbuild engine to use to run build ('dotnet', 'vs', or unspecified)."
+  Write-Host "  -excludePrereleaseVS    Set to exclude build engines in prerelease versions of Visual Studio"
   Write-Host ""
 
   Write-Host "Command line arguments not listed above are passed thru to msbuild."
diff --git a/eng/common/build.sh b/eng/common/build.sh
index 252b63604e6..55b298f16cc 100755
--- a/eng/common/build.sh
+++ b/eng/common/build.sh
@@ -81,7 +81,7 @@ runtime_source_feed_key=''
 
 properties=''
 while [[ $# > 0 ]]; do
-  opt="$(echo "${1/#--/-}" | awk '{print tolower($0)}')"
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
   case "$opt" in
     -help|-h)
       usage
diff --git a/eng/common/cross/arm64/tizen-fetch.sh b/eng/common/cross/arm64/tizen-fetch.sh
index a48a6f51c49..16d1301f21e 100644
--- a/eng/common/cross/arm64/tizen-fetch.sh
+++ b/eng/common/cross/arm64/tizen-fetch.sh
@@ -157,7 +157,7 @@ fetch_tizen_pkgs()
 Inform "Initialize arm base"
 fetch_tizen_pkgs_init standard base
 Inform "fetch common packages"
-fetch_tizen_pkgs aarch64 gcc glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel
+fetch_tizen_pkgs aarch64 gcc glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
 Inform "fetch coreclr packages"
 fetch_tizen_pkgs aarch64 lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
 Inform "fetch corefx packages"
diff --git a/eng/common/cross/armel/armel.jessie.patch b/eng/common/cross/armel/armel.jessie.patch
new file mode 100644
index 00000000000..2d261561935
--- /dev/null
+++ b/eng/common/cross/armel/armel.jessie.patch
@@ -0,0 +1,43 @@
+diff -u -r a/usr/include/urcu/uatomic/generic.h b/usr/include/urcu/uatomic/generic.h
+--- a/usr/include/urcu/uatomic/generic.h	2014-10-22 15:00:58.000000000 -0700
++++ b/usr/include/urcu/uatomic/generic.h	2020-10-30 21:38:28.550000000 -0700
+@@ -69,10 +69,10 @@
+ #endif
+ #ifdef UATOMIC_HAS_ATOMIC_SHORT
+ 	case 2:
+-		return __sync_val_compare_and_swap_2(addr, old, _new);
++		return __sync_val_compare_and_swap_2((uint16_t*) addr, old, _new);
+ #endif
+ 	case 4:
+-		return __sync_val_compare_and_swap_4(addr, old, _new);
++		return __sync_val_compare_and_swap_4((uint32_t*) addr, old, _new);
+ #if (CAA_BITS_PER_LONG == 64)
+ 	case 8:
+ 		return __sync_val_compare_and_swap_8(addr, old, _new);
+@@ -109,7 +109,7 @@
+ 		return;
+ #endif
+ 	case 4:
+-		__sync_and_and_fetch_4(addr, val);
++		__sync_and_and_fetch_4((uint32_t*) addr, val);
+ 		return;
+ #if (CAA_BITS_PER_LONG == 64)
+ 	case 8:
+@@ -148,7 +148,7 @@
+ 		return;
+ #endif
+ 	case 4:
+-		__sync_or_and_fetch_4(addr, val);
++		__sync_or_and_fetch_4((uint32_t*) addr, val);
+ 		return;
+ #if (CAA_BITS_PER_LONG == 64)
+ 	case 8:
+@@ -187,7 +187,7 @@
+ 		return __sync_add_and_fetch_2(addr, val);
+ #endif
+ 	case 4:
+-		return __sync_add_and_fetch_4(addr, val);
++		return __sync_add_and_fetch_4((uint32_t*) addr, val);
+ #if (CAA_BITS_PER_LONG == 64)
+ 	case 8:
+ 		return __sync_add_and_fetch_8(addr, val);
diff --git a/eng/common/cross/armel/tizen-fetch.sh b/eng/common/cross/armel/tizen-fetch.sh
index 2776cbba4e4..64f0187e5aa 100755
--- a/eng/common/cross/armel/tizen-fetch.sh
+++ b/eng/common/cross/armel/tizen-fetch.sh
@@ -157,7 +157,7 @@ fetch_tizen_pkgs()
 Inform "Initialize arm base"
 fetch_tizen_pkgs_init standard base
 Inform "fetch common packages"
-fetch_tizen_pkgs armv7l gcc glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel
+fetch_tizen_pkgs armv7l gcc gcc-devel-static glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
 Inform "fetch coreclr packages"
 fetch_tizen_pkgs armv7l lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
 Inform "fetch corefx packages"
diff --git a/eng/common/cross/build-android-rootfs.sh b/eng/common/cross/build-android-rootfs.sh
index e7f12edb565..42516bbeebc 100755
--- a/eng/common/cross/build-android-rootfs.sh
+++ b/eng/common/cross/build-android-rootfs.sh
@@ -27,7 +27,7 @@ __AndroidToolchain=aarch64-linux-android
 
 for i in "$@"
     do
-        lowerI="$(echo $i | awk '{print tolower($0)}')"
+        lowerI="$(echo $i | tr "[:upper:]" "[:lower:]")"
         case $lowerI in
         -?|-h|--help)
             usage
diff --git a/eng/common/cross/build-rootfs.sh b/eng/common/cross/build-rootfs.sh
index ffdff38542e..591d8666a84 100755
--- a/eng/common/cross/build-rootfs.sh
+++ b/eng/common/cross/build-rootfs.sh
@@ -6,7 +6,7 @@ usage()
 {
     echo "Usage: $0 [BuildArch] [CodeName] [lldbx.y] [--skipunmount] --rootfsdir <directory>]"
     echo "BuildArch can be: arm(default), armel, arm64, x86"
-    echo "CodeName - optional, Code name for Linux, can be: trusty, xenial(default), zesty, bionic, alpine. If BuildArch is armel, LinuxCodeName is jessie(default) or tizen."
+    echo "CodeName - optional, Code name for Linux, can be: trusty, xenial(default), zesty, bionic, alpine, alpine3.9 or alpine3.13. If BuildArch is armel, LinuxCodeName is jessie(default) or tizen."
     echo "                              for FreeBSD can be: freebsd11 or freebsd12."
     echo "                              for illumos can be: illumos."
     echo "lldbx.y - optional, LLDB version, can be: lldb3.9(default), lldb4.0, lldb5.0, lldb6.0 no-lldb. Ignored for alpine and FReeBSD"
@@ -74,6 +74,10 @@ __IllumosPackages+=" mit-krb5-1.16.2nb4"
 __IllumosPackages+=" openssl-1.1.1e"
 __IllumosPackages+=" zlib-1.2.11"
 
+# ML.NET dependencies
+__UbuntuPackages+=" libomp5"
+__UbuntuPackages+=" libomp-dev"
+
 __UseMirror=0
 
 __UnprocessedBuildArgs=
@@ -82,7 +86,7 @@ while :; do
         break
     fi
 
-    lowerI="$(echo $1 | awk '{print tolower($0)}')"
+    lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
     case $lowerI in
         -?|-h|--help)
             usage
@@ -106,6 +110,13 @@ while :; do
             __UbuntuRepo="http://ftp.debian.org/debian/"
             __CodeName=jessie
             ;;
+        s390x)
+            __BuildArch=s390x
+            __UbuntuArch=s390x
+            __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            unset __LLDB_Package
+            ;;
         x86)
             __BuildArch=x86
             __UbuntuArch=i386
@@ -176,9 +187,20 @@ while :; do
             __UbuntuRepo=
             __Tizen=tizen
             ;;
-        alpine)
+        alpine|alpine3.9)
+            __CodeName=alpine
+            __UbuntuRepo=
+            __AlpineVersion=3.9
+            ;;
+        alpine3.13)
             __CodeName=alpine
             __UbuntuRepo=
+            __AlpineVersion=3.13
+            # Alpine 3.13 has all the packages we need in the 3.13 repository
+            __AlpinePackages+=$__AlpinePackagesEdgeCommunity
+            __AlpinePackagesEdgeCommunity=
+            __AlpinePackages+=$__AlpinePackagesEdgeMain
+            __AlpinePackagesEdgeMain=
             ;;
         freebsd11)
             __FreeBSDBase="11.3-RELEASE"
@@ -236,7 +258,6 @@ __RootfsDir="$( cd "$__RootfsDir" && pwd )"
 
 if [[ "$__CodeName" == "alpine" ]]; then
     __ApkToolsVersion=2.9.1
-    __AlpineVersion=3.9
     __ApkToolsDir=$(mktemp -d)
     wget https://github.com/alpinelinux/apk-tools/releases/download/v$__ApkToolsVersion/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz -P $__ApkToolsDir
     tar -xf $__ApkToolsDir/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz -C $__ApkToolsDir
@@ -249,15 +270,19 @@ if [[ "$__CodeName" == "alpine" ]]; then
       -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
       add $__AlpinePackages
 
-    $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
-      -X http://dl-cdn.alpinelinux.org/alpine/edge/main \
-      -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
-      add $__AlpinePackagesEdgeMain
+    if [[ -n "$__AlpinePackagesEdgeMain" ]]; then
+      $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
+        -X http://dl-cdn.alpinelinux.org/alpine/edge/main \
+        -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
+        add $__AlpinePackagesEdgeMain
+    fi
 
-    $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
-      -X http://dl-cdn.alpinelinux.org/alpine/edge/community \
-      -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
-      add $__AlpinePackagesEdgeCommunity
+    if [[ -n "$__AlpinePackagesEdgeCommunity" ]]; then
+      $__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk \
+        -X http://dl-cdn.alpinelinux.org/alpine/edge/community \
+        -U --allow-untrusted --root $__RootfsDir --arch $__AlpineArch --initdb \
+        add $__AlpinePackagesEdgeCommunity
+    fi
 
     rm -r $__ApkToolsDir
 elif [[ "$__CodeName" == "freebsd" ]]; then
@@ -329,6 +354,7 @@ elif [[ -n $__CodeName ]]; then
     chroot $__RootfsDir apt-get -f -y install
     chroot $__RootfsDir apt-get -y install $__UbuntuPackages
     chroot $__RootfsDir symlinks -cr /usr
+    chroot $__RootfsDir apt-get clean
 
     if [ $__SkipUnmount == 0 ]; then
         umount $__RootfsDir/* || true
@@ -340,6 +366,12 @@ elif [[ -n $__CodeName ]]; then
         patch -p1 < $__CrossDir/$__BuildArch/trusty-lttng-2.4.patch
         popd
     fi
+
+    if [[ "$__BuildArch" == "armel" && "$__CodeName" == "jessie" ]]; then
+        pushd $__RootfsDir
+        patch -p1 < $__CrossDir/$__BuildArch/armel.jessie.patch
+        popd
+    fi
 elif [[ "$__Tizen" == "tizen" ]]; then
     ROOTFS_DIR=$__RootfsDir $__CrossDir/$__BuildArch/tizen-build-rootfs.sh
 else
diff --git a/eng/common/cross/s390x/sources.list.bionic b/eng/common/cross/s390x/sources.list.bionic
new file mode 100644
index 00000000000..21095574095
--- /dev/null
+++ b/eng/common/cross/s390x/sources.list.bionic
@@ -0,0 +1,11 @@
+deb http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted universe
+deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted universe
+
+deb http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted
+deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted
+
+deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted universe multiverse
+deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted universe multiverse
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index 137736c0a27..fc11001aa76 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -36,6 +36,9 @@ elseif(TARGET_ARCH_NAME STREQUAL "arm64")
   if("$ENV{__DistroRid}" MATCHES "tizen.*")
     set(TIZEN_TOOLCHAIN "aarch64-tizen-linux-gnu/9.2.0")
   endif()
+elseif(TARGET_ARCH_NAME STREQUAL "s390x")
+  set(CMAKE_SYSTEM_PROCESSOR s390x)
+  set(TOOLCHAIN "s390x-linux-gnu")
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
   set(CMAKE_SYSTEM_PROCESSOR i686)
   set(TOOLCHAIN "i686-linux-gnu")
@@ -46,7 +49,7 @@ elseif (ILLUMOS)
   set(CMAKE_SYSTEM_PROCESSOR "x86_64")
   set(TOOLCHAIN "x86_64-illumos")
 else()
-  message(FATAL_ERROR "Arch is ${TARGET_ARCH_NAME}. Only armel, arm, arm64 and x86 are supported!")
+  message(FATAL_ERROR "Arch is ${TARGET_ARCH_NAME}. Only armel, arm, arm64, s390x and x86 are supported!")
 endif()
 
 if(DEFINED ENV{TOOLCHAIN})
@@ -139,6 +142,10 @@ function(add_toolchain_linker_flag Flag)
   set("CMAKE_SHARED_LINKER_FLAGS${CONFIG_SUFFIX}" "${CMAKE_SHARED_LINKER_FLAGS${CONFIG_SUFFIX}} ${Flag}" PARENT_SCOPE)
 endfunction()
 
+if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
+  add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/lib/${TOOLCHAIN}")
+  add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/usr/lib/${TOOLCHAIN}")
+endif()
 
 if(TARGET_ARCH_NAME STREQUAL "armel")
   if(DEFINED TIZEN_TOOLCHAIN) # For Tizen only
@@ -167,7 +174,7 @@ endif()
 
 # Specify compile options
 
-if((TARGET_ARCH_NAME MATCHES "^(arm|armel|arm64)$" AND NOT "$ENV{__DistroRid}" MATCHES "android.*") OR ILLUMOS)
+if((TARGET_ARCH_NAME MATCHES "^(arm|armel|arm64|s390x)$" AND NOT "$ENV{__DistroRid}" MATCHES "android.*") OR ILLUMOS)
   set(CMAKE_C_COMPILER_TARGET ${TOOLCHAIN})
   set(CMAKE_CXX_COMPILER_TARGET ${TOOLCHAIN})
   set(CMAKE_ASM_COMPILER_TARGET ${TOOLCHAIN})
diff --git a/eng/common/darc-init.sh b/eng/common/darc-init.sh
index d981d7bbf38..39abdbecdcf 100755
--- a/eng/common/darc-init.sh
+++ b/eng/common/darc-init.sh
@@ -6,7 +6,7 @@ versionEndpoint='https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc
 verbosity='minimal'
 
 while [[ $# > 0 ]]; do
-  opt="$(echo "$1" | awk '{print tolower($0)}')"
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
   case "$opt" in
     --darcversion)
       darcVersion=$2
diff --git a/eng/common/dotnet-install.sh b/eng/common/dotnet-install.sh
index ead6a1d9a24..d6efeb44340 100755
--- a/eng/common/dotnet-install.sh
+++ b/eng/common/dotnet-install.sh
@@ -19,7 +19,7 @@ runtime='dotnet'
 runtimeSourceFeed=''
 runtimeSourceFeedKey=''
 while [[ $# > 0 ]]; do
-  opt="$(echo "$1" | awk '{print tolower($0)}')"
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
   case "$opt" in
     -version|-v)
       shift
@@ -49,13 +49,8 @@ while [[ $# > 0 ]]; do
   shift
 done
 
-# Use uname to determine what the CPU is.
-cpuname=$(uname -p)
-# Some Linux platforms report unknown for platform, but the arch for machine.
-if [[ "$cpuname" == "unknown" ]]; then
-  cpuname=$(uname -m)
-fi
-
+# Use uname to determine what the CPU is, see https://en.wikipedia.org/wiki/Uname#Examples
+cpuname=$(uname -m)
 case $cpuname in
   aarch64)
     buildarch=arm64
diff --git a/eng/common/generate-locproject.ps1 b/eng/common/generate-locproject.ps1
index 2907f916d6f..de348a2e225 100644
--- a/eng/common/generate-locproject.ps1
+++ b/eng/common/generate-locproject.ps1
@@ -14,7 +14,7 @@ $ErrorActionPreference = "Stop"
 
 Import-Module -Name (Join-Path $PSScriptRoot 'native\CommonLibrary.psm1')
 
-$exclusionsFilePath = "$SourcesDirectory\Localize\LocExclusions.json"
+$exclusionsFilePath = "$SourcesDirectory\eng\Localize\LocExclusions.json"
 $exclusions = @{ Exclusions = @() }
 if (Test-Path -Path $exclusionsFilePath)
 {
@@ -38,7 +38,7 @@ if ($allXlfFiles) {
     $langXlfFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory\*\*.$firstLangCode.xlf"
 }
 $langXlfFiles | ForEach-Object {
-    $null = $_.Name -Match "(.+)\.[\w-]+\.xlf" # matches '[filename].[langcode].xlf'
+    $null = $_.Name -Match "(.+)\.[\w-]+\.xlf" # matches '[filename].[langcode].xlf
     
     $destinationFile = "$($_.Directory.FullName)\$($Matches.1).xlf"
     $xlfFiles += Copy-Item "$($_.FullName)" -Destination $destinationFile -PassThru
@@ -92,14 +92,14 @@ Write-Host "LocProject.json generated:`n`n$json`n`n"
 Pop-Location
 
 if (!$UseCheckedInLocProjectJson) {
-    New-Item "$SourcesDirectory\Localize\LocProject.json" -Force # Need this to make sure the Localize directory is created
-    Set-Content "$SourcesDirectory\Localize\LocProject.json" $json
+    New-Item "$SourcesDirectory\eng\Localize\LocProject.json" -Force # Need this to make sure the Localize directory is created
+    Set-Content "$SourcesDirectory\eng\Localize\LocProject.json" $json
 }
 else {
-    New-Item "$SourcesDirectory\Localize\LocProject-generated.json" -Force # Need this to make sure the Localize directory is created
-    Set-Content "$SourcesDirectory\Localize\LocProject-generated.json" $json
+    New-Item "$SourcesDirectory\eng\Localize\LocProject-generated.json" -Force # Need this to make sure the Localize directory is created
+    Set-Content "$SourcesDirectory\eng\Localize\LocProject-generated.json" $json
 
-    if ((Get-FileHash "$SourcesDirectory\Localize\LocProject-generated.json").Hash -ne (Get-FileHash "$SourcesDirectory\Localize\LocProject.json").Hash) {
+    if ((Get-FileHash "$SourcesDirectory\eng\Localize\LocProject-generated.json").Hash -ne (Get-FileHash "$SourcesDirectory\eng\Localize\LocProject.json").Hash) {
         Write-PipelineTelemetryError -Category "OneLocBuild" -Message "Existing LocProject.json differs from generated LocProject.json. Download LocProject-generated.json and compare them."
         
         exit 1
diff --git a/eng/common/init-tools-native.sh b/eng/common/init-tools-native.sh
index 29fc5db8ae0..5bd205b5da3 100755
--- a/eng/common/init-tools-native.sh
+++ b/eng/common/init-tools-native.sh
@@ -16,7 +16,7 @@ declare -A native_assets
 . $scriptroot/native/common-library.sh
 
 while (($# > 0)); do
-  lowerI="$(echo $1 | awk '{print tolower($0)}')"
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
   case $lowerI in
     --baseuri)
       base_uri=$2
@@ -76,24 +76,89 @@ while (($# > 0)); do
 done
 
 function ReadGlobalJsonNativeTools {
-  # Get the native-tools section from the global.json.
-  local native_tools_section=$(cat $global_json_file | awk '/"native-tools"/,/}/')
-  # Only extract the contents of the object.
-  local native_tools_list=$(echo $native_tools_section | awk -F"[{}]" '{print $2}')
-  native_tools_list=${native_tools_list//[\" ]/}
-  native_tools_list=$( echo "$native_tools_list" | sed 's/\s//g' | sed 's/,/\n/g' )
-
-  local old_IFS=$IFS
-  while read -r line; do
-    # Lines are of the form: 'tool:version'
-    IFS=:
-    while read -r key value; do
-     native_assets[$key]=$value
-    done <<< "$line"
-  done <<< "$native_tools_list"
-  IFS=$old_IFS
-
-  return 0;
+  # happy path: we have a proper JSON parsing tool `jq(1)` in PATH!
+  if command -v jq &> /dev/null; then
+
+    # jq: read each key/value pair under "native-tools" entry and emit:
+    #   KEY="<entry-key>" VALUE="<entry-value>"
+    # followed by a null byte.
+    #
+    # bash: read line with null byte delimeter and push to array (for later `eval`uation).
+
+    while IFS= read -rd '' line; do
+      native_assets+=("$line")
+    done < <(jq -r '. |
+        select(has("native-tools")) |
+        ."native-tools" |
+        keys[] as $k |
+        @sh "KEY=\($k) VALUE=\(.[$k])\u0000"' "$global_json_file")
+
+    return
+  fi
+
+  # Warning: falling back to manually parsing JSON, which is not recommended.
+
+  # Following routine matches the output and escaping logic of jq(1)'s @sh formatter used above.
+  # It has been tested with several weird strings with escaped characters in entries (key and value)
+  # and results were compared with the output of jq(1) in binary representation using xxd(1);
+  # just before the assignment to 'native_assets' array (above and below).
+
+  # try to capture the section under "native-tools".
+  if [[ ! "$(cat "$global_json_file")" =~ \"native-tools\"[[:space:]\:\{]*([^\}]+) ]]; then
+    return
+  fi
+
+  section="${BASH_REMATCH[1]}"
+
+  parseStarted=0
+  possibleEnd=0
+  escaping=0
+  escaped=0
+  isKey=1
+
+  for (( i=0; i<${#section}; i++ )); do
+    char="${section:$i:1}"
+    if ! ((parseStarted)) && [[ "$char" =~ [[:space:],:] ]]; then continue; fi
+
+    if ! ((escaping)) && [[ "$char" == "\\" ]]; then
+      escaping=1
+    elif ((escaping)) && ! ((escaped)); then
+      escaped=1
+    fi
+
+    if ! ((parseStarted)) && [[ "$char" == "\"" ]]; then
+      parseStarted=1
+      possibleEnd=0
+    elif [[ "$char" == "'" ]]; then
+      token="$token'\\\''"
+      possibleEnd=0
+    elif ((escaping)) || [[ "$char" != "\"" ]]; then
+      token="$token$char"
+      possibleEnd=1
+    fi
+
+    if ((possibleEnd)) && ! ((escaping)) && [[ "$char" == "\"" ]]; then
+      # Use printf to unescape token to match jq(1)'s @sh formatting rules.
+      # do not use 'token="$(printf "$token")"' syntax, as $() eats the trailing linefeed.
+      printf -v token "'$token'"
+
+      if ((isKey)); then
+        KEY="$token"
+        isKey=0
+      else
+        line="KEY=$KEY VALUE=$token"
+        native_assets+=("$line")
+        isKey=1
+      fi
+
+      # reset for next token
+      parseStarted=0
+      token=
+    elif ((escaping)) && ((escaped)); then
+      escaping=0
+      escaped=0
+    fi
+  done
 }
 
 native_base_dir=$install_directory
@@ -111,14 +176,14 @@ if [[ ${#native_assets[@]} -eq 0 ]]; then
   exit 0;
 else
   native_installer_dir="$scriptroot/native"
-  for tool in "${!native_assets[@]}"
-  do
-    tool_version=${native_assets[$tool]}
-    installer_path="$native_installer_dir/install-$tool.sh"
+  for index in "${!native_assets[@]}"; do
+    eval "${native_assets["$index"]}"
+
+    installer_path="$native_installer_dir/install-$KEY.sh"
     installer_command="$installer_path"
     installer_command+=" --baseuri $base_uri"
     installer_command+=" --installpath $install_bin"
-    installer_command+=" --version $tool_version"
+    installer_command+=" --version $VALUE"
     echo $installer_command
 
     if [[ $force = true ]]; then
diff --git a/eng/common/internal-feed-operations.sh b/eng/common/internal-feed-operations.sh
index 343054b3ae9..e2233e78122 100755
--- a/eng/common/internal-feed-operations.sh
+++ b/eng/common/internal-feed-operations.sh
@@ -101,7 +101,7 @@ authToken=''
 repoName=''
 
 while [[ $# > 0 ]]; do
-  opt="$(echo "$1" | awk '{print tolower($0)}')"
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
   case "$opt" in
     --operation)
       operation=$2
diff --git a/eng/common/msbuild.ps1 b/eng/common/msbuild.ps1
index c6401230002..eea19cd8452 100644
--- a/eng/common/msbuild.ps1
+++ b/eng/common/msbuild.ps1
@@ -5,6 +5,7 @@ Param(
   [bool] $nodeReuse = $true,
   [switch] $ci,
   [switch] $prepareMachine,
+  [switch] $excludePrereleaseVS,
   [Parameter(ValueFromRemainingArguments=$true)][String[]]$extraArgs
 )
 
diff --git a/eng/common/msbuild.sh b/eng/common/msbuild.sh
index 8160cd5a59d..20d3dad5435 100755
--- a/eng/common/msbuild.sh
+++ b/eng/common/msbuild.sh
@@ -19,7 +19,7 @@ prepare_machine=false
 extra_args=''
 
 while (($# > 0)); do
-  lowerI="$(echo $1 | awk '{print tolower($0)}')"
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
   case $lowerI in
     --verbosity)
       verbosity=$2
diff --git a/eng/common/native/CommonLibrary.psm1 b/eng/common/native/CommonLibrary.psm1
index d7d1a651094..adf707c8fe7 100644
--- a/eng/common/native/CommonLibrary.psm1
+++ b/eng/common/native/CommonLibrary.psm1
@@ -48,7 +48,7 @@ function DownloadAndExtract {
                                            -Verbose:$Verbose
 
   if ($DownloadStatus -Eq $False) {
-    Write-Error "Download failed"
+    Write-Error "Download failed from $Uri"
     return $False
   }
 
diff --git a/eng/common/native/install-cmake-test.sh b/eng/common/native/install-cmake-test.sh
index 12339a40761..8a5e7cf0db5 100755
--- a/eng/common/native/install-cmake-test.sh
+++ b/eng/common/native/install-cmake-test.sh
@@ -14,7 +14,7 @@ download_retries=5
 retry_wait_time_seconds=30
 
 while (($# > 0)); do
-  lowerI="$(echo $1 | awk '{print tolower($0)}')"
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
   case $lowerI in
     --baseuri)
       base_uri=$2
@@ -63,7 +63,7 @@ done
 
 tool_name="cmake-test"
 tool_os=$(GetCurrentOS)
-tool_folder=$(echo $tool_os | awk '{print tolower($0)}')
+tool_folder="$(echo $tool_os | tr "[:upper:]" "[:lower:]")"
 tool_arch="x86_64"
 tool_name_moniker="$tool_name-$version-$tool_os-$tool_arch"
 tool_install_directory="$install_path/$tool_name/$version"
@@ -114,4 +114,4 @@ if [[ $? != 0 ]]; then
   exit 1
 fi
 
-exit 0
\ No newline at end of file
+exit 0
diff --git a/eng/common/native/install-cmake.sh b/eng/common/native/install-cmake.sh
index 18041be8763..de496beebc5 100755
--- a/eng/common/native/install-cmake.sh
+++ b/eng/common/native/install-cmake.sh
@@ -14,7 +14,7 @@ download_retries=5
 retry_wait_time_seconds=30
 
 while (($# > 0)); do
-  lowerI="$(echo $1 | awk '{print tolower($0)}')"
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
   case $lowerI in
     --baseuri)
       base_uri=$2
@@ -63,7 +63,7 @@ done
 
 tool_name="cmake"
 tool_os=$(GetCurrentOS)
-tool_folder=$(echo $tool_os | awk '{print tolower($0)}')
+tool_folder="$(echo $tool_os | tr "[:upper:]" "[:lower:]")"
 tool_arch="x86_64"
 tool_name_moniker="$tool_name-$version-$tool_os-$tool_arch"
 tool_install_directory="$install_path/$tool_name/$version"
@@ -114,4 +114,4 @@ if [[ $? != 0 ]]; then
   exit 1
 fi
 
-exit 0
\ No newline at end of file
+exit 0
diff --git a/eng/common/native/install-tool.ps1 b/eng/common/native/install-tool.ps1
index f397e1c75d4..78f2d84a4e4 100644
--- a/eng/common/native/install-tool.ps1
+++ b/eng/common/native/install-tool.ps1
@@ -105,7 +105,7 @@ try {
     Write-Error "There are multiple copies of $ToolName in $($ToolInstallDirectory): `n$(@($ToolFilePath | out-string))"
     exit 1
   } elseif (@($ToolFilePath).Length -Lt 1) {
-    Write-Host "$ToolName was not found in $ToolFilePath."
+    Write-Host "$ToolName was not found in $ToolInstallDirectory."
     exit 1
   }
 
diff --git a/eng/common/performance/blazor_perf.proj b/eng/common/performance/blazor_perf.proj
deleted file mode 100644
index 3b25359c438..00000000000
--- a/eng/common/performance/blazor_perf.proj
+++ /dev/null
@@ -1,30 +0,0 @@
-<Project Sdk="Microsoft.DotNet.Helix.Sdk" DefaultTargets="Test">
-  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT'">
-    <Python>python3</Python>
-    <HelixPreCommands>$(HelixPreCommands);chmod +x $HELIX_WORKITEM_PAYLOAD/SOD/SizeOnDisk</HelixPreCommands>
-  </PropertyGroup>
-
-  <ItemGroup>
-    <HelixCorrelationPayload Include="$(CorrelationPayloadDirectory)">
-      <PayloadDirectory>%(Identity)</PayloadDirectory>
-    </HelixCorrelationPayload>
-  </ItemGroup>
-
-  <PropertyGroup Condition="'$(AGENT_OS)' == 'Windows_NT'">
-    <ScenarioDirectory>%HELIX_CORRELATION_PAYLOAD%\performance\src\scenarios\</ScenarioDirectory>
-    <BlazorDirectory>$(ScenarioDirectory)blazor\</BlazorDirectory>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT'">
-    <ScenarioDirectory>$HELIX_CORRELATION_PAYLOAD/performance/src/scenarios/</ScenarioDirectory>
-    <BlazorDirectory>$(ScenarioDirectory)blazor/</BlazorDirectory>
-  </PropertyGroup>
-
-  <ItemGroup>
-    <HelixWorkItem Include="SOD - New Blazor Template - Publish">
-        <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
-        <PreCommands>cd $(BlazorDirectory);$(Python) pre.py publish --msbuild %27/p:_TrimmerDumpDependencies=true%27 --msbuild-static AdditionalMonoLinkerOptions=%27&quot;%24(AdditionalMonoLinkerOptions) --dump-dependencies&quot;%27 --binlog %27./traces/blazor_publish.binlog%27</PreCommands>
-        <Command>$(Python) test.py sod --scenario-name &quot;%(Identity)&quot;</Command>
-        <PostCommands>$(Python) post.py</PostCommands>
-    </HelixWorkItem>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/eng/common/performance/crossgen_perf.proj b/eng/common/performance/crossgen_perf.proj
deleted file mode 100644
index 4264920382e..00000000000
--- a/eng/common/performance/crossgen_perf.proj
+++ /dev/null
@@ -1,69 +0,0 @@
-<Project Sdk="Microsoft.DotNet.Helix.Sdk" DefaultTargets="Test">
-
-  <ItemGroup>
-    <HelixCorrelationPayload Include="$(CorrelationPayloadDirectory)">
-      <PayloadDirectory>%(Identity)</PayloadDirectory>
-    </HelixCorrelationPayload>
-  </ItemGroup>
-
-  <!-- 
-    Crossgen and Crossgen2 Scenario WorkItems 
-  -->
-  <PropertyGroup Condition="'$(AGENT_OS)' == 'Windows_NT'">
-    <Python>py -3</Python>
-    <HelixPreCommands>$(HelixPreCommands)</HelixPreCommands>
-    <CoreRoot>%HELIX_CORRELATION_PAYLOAD%\Core_Root</CoreRoot>
-    <ScenarioDirectory>%HELIX_CORRELATION_PAYLOAD%\performance\src\scenarios\</ScenarioDirectory>
-    <CrossgenDirectory>$(ScenarioDirectory)crossgen\</CrossgenDirectory>
-    <Crossgen2Directory>$(ScenarioDirectory)crossgen2\</Crossgen2Directory>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT'">
-    <Python>python3</Python>
-    <HelixPreCommands>$(HelixPreCommands);chmod +x $HELIX_WORKITEM_PAYLOAD/startup/Startup;chmod +x $HELIX_WORKITEM_PAYLOAD/startup/perfcollect;sudo apt update</HelixPreCommands>
-    <CoreRoot>$HELIX_CORRELATION_PAYLOAD/Core_Root</CoreRoot>
-    <ScenarioDirectory>$HELIX_CORRELATION_PAYLOAD/performance/src/scenarios/</ScenarioDirectory>
-    <CrossgenDirectory>$(ScenarioDirectory)crossgen/</CrossgenDirectory>
-    <Crossgen2Directory>$(ScenarioDirectory)crossgen2/</Crossgen2Directory>
-  </PropertyGroup>
-
-  <ItemGroup>
-    <SingleAssembly Include="System.Private.Xml.dll"/>
-    <SingleAssembly Include="System.Linq.Expressions.dll"/>
-    <SingleAssembly Include="Microsoft.CodeAnalysis.VisualBasic.dll"/>
-    <SingleAssembly Include="Microsoft.CodeAnalysis.CSharp.dll"/>
-    <SingleAssembly Include="System.Private.CoreLib.dll"/>
-  </ItemGroup>
-  <ItemGroup>
-    <Composite Include="framework-r2r.dll.rsp"/>
-  </ItemGroup>
-
-  <ItemGroup>
-    <CrossgenWorkItem Include="@(SingleAssembly)">
-      <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
-      <Command>$(Python) $(CrossgenDirectory)test.py crossgen --core-root $(CoreRoot) --test-name %(Identity)</Command>
-    </CrossgenWorkItem>
-  </ItemGroup>
-
-  <ItemGroup> 
-    <Crossgen2WorkItem Include="@(SingleAssembly)">
-      <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
-      <Command>$(Python) $(Crossgen2Directory)test.py crossgen2 --core-root $(CoreRoot) --single %(Identity)</Command>
-    </Crossgen2WorkItem>
-  </ItemGroup>
-
-  <ItemGroup>
-    <!-- Enable crossgen tests on Windows x64 and Windows x86 -->
-    <HelixWorkItem Include="@(CrossgenWorkItem -> 'Crossgen %(Identity)')" Condition="'$(AGENT_OS)' == 'Windows_NT'">
-      <Timeout>4:00</Timeout>
-    </HelixWorkItem>
-    <!-- Enable crossgen2 tests on Windows x64 and Linux x64 -->
-    <HelixWorkItem Include="@(Crossgen2WorkItem -> 'Crossgen2 %(Identity)')" Condition="'$(Architecture)' == 'x64'">
-      <Timeout>4:00</Timeout>
-    </HelixWorkItem>
-    <HelixWorkItem Include="Crossgen2 Composite Framework R2R" Condition="'$(Architecture)' == 'x64'">
-      <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>	
-      <Command>$(Python) $(Crossgen2Directory)test.py crossgen2 --core-root $(CoreRoot) --composite $(Crossgen2Directory)framework-r2r.dll.rsp</Command>
-      <Timeout>1:00</Timeout>  
-    </HelixWorkItem>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/eng/common/performance/microbenchmarks.proj b/eng/common/performance/microbenchmarks.proj
deleted file mode 100644
index 94b6efbc929..00000000000
--- a/eng/common/performance/microbenchmarks.proj
+++ /dev/null
@@ -1,144 +0,0 @@
-<Project Sdk="Microsoft.DotNet.Helix.Sdk" DefaultTargets="Test">
-
-  <PropertyGroup Condition="'$(AGENT_OS)' == 'Windows_NT'">
-    <WorkItemCommand>%HELIX_CORRELATION_PAYLOAD%\performance\scripts\benchmarks_ci.py --csproj %HELIX_CORRELATION_PAYLOAD%\performance\$(TargetCsproj)</WorkItemCommand>
-    <CliArguments>--dotnet-versions %DOTNET_VERSION% --cli-source-info args --cli-branch %PERFLAB_BRANCH% --cli-commit-sha %PERFLAB_HASH% --cli-repository https://github.com/%PERFLAB_REPO% --cli-source-timestamp %PERFLAB_BUILDTIMESTAMP%</CliArguments>
-    <Python>py -3</Python>
-    <CoreRun>%HELIX_CORRELATION_PAYLOAD%\Core_Root\CoreRun.exe</CoreRun>
-    <BaselineCoreRun>%HELIX_CORRELATION_PAYLOAD%\Baseline_Core_Root\CoreRun.exe</BaselineCoreRun>
-    
-    <HelixPreCommands>$(HelixPreCommands);call %HELIX_CORRELATION_PAYLOAD%\performance\tools\machine-setup.cmd;set PYTHONPATH=%HELIX_WORKITEM_PAYLOAD%\scripts%3B%HELIX_WORKITEM_PAYLOAD%</HelixPreCommands>
-    <ArtifactsDirectory>%HELIX_CORRELATION_PAYLOAD%\artifacts\BenchmarkDotNet.Artifacts</ArtifactsDirectory>
-    <BaselineArtifactsDirectory>%HELIX_CORRELATION_PAYLOAD%\artifacts\BenchmarkDotNet.Artifacts_Baseline</BaselineArtifactsDirectory>
-    <ResultsComparer>%HELIX_CORRELATION_PAYLOAD%\performance\src\tools\ResultsComparer\ResultsComparer.csproj</ResultsComparer>
-    <DotnetExe>%HELIX_CORRELATION_PAYLOAD%\performance\tools\dotnet\$(Architecture)\dotnet.exe</DotnetExe>
-    <Percent>%25%25</Percent>
-    <XMLResults>%HELIX_WORKITEM_ROOT%\testResults.xml</XMLResults>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT' and '$(RunFromPerfRepo)' == 'false'">
-    <BaseDirectory>$HELIX_CORRELATION_PAYLOAD</BaseDirectory>
-    <PerformanceDirectory>$(BaseDirectory)/performance</PerformanceDirectory>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT' and '$(RunFromPerfRepo)' == 'true'">
-    <BaseDirectory>$HELIX_WORKITEM_PAYLOAD</BaseDirectory>
-    <PerformanceDirectory>$(BaseDirectory)</PerformanceDirectory>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(AGENT_OS)' != 'Windows_NT'">
-    <WorkItemCommand>$(PerformanceDirectory)/scripts/benchmarks_ci.py --csproj $(PerformanceDirectory)/$(TargetCsproj)</WorkItemCommand>
-    <CliArguments>--dotnet-versions $DOTNET_VERSION --cli-source-info args --cli-branch $PERFLAB_BRANCH --cli-commit-sha $PERFLAB_HASH --cli-repository https://github.com/$PERFLAB_REPO --cli-source-timestamp $PERFLAB_BUILDTIMESTAMP</CliArguments>
-    <Python>python3</Python>
-    <CoreRun>$(BaseDirectory)/Core_Root/corerun</CoreRun>
-    <BaselineCoreRun>$(BaseDirectory)/Baseline_Core_Root/corerun</BaselineCoreRun>
-    <HelixPreCommands>$(HelixPreCommands);chmod +x $(PerformanceDirectory)/tools/machine-setup.sh;. $(PerformanceDirectory)/tools/machine-setup.sh</HelixPreCommands>
-    <ArtifactsDirectory>$(BaseDirectory)/artifacts/BenchmarkDotNet.Artifacts</ArtifactsDirectory>
-    <BaselineArtifactsDirectory>$(BaseDirectory)/artifacts/BenchmarkDotNet.Artifacts_Baseline</BaselineArtifactsDirectory>
-    <ResultsComparer>$(PerformanceDirectory)/src/tools/ResultsComparer/ResultsComparer.csproj</ResultsComparer>
-    <DotnetExe>$(PerformanceDirectory)/tools/dotnet/$(Architecture)/dotnet</DotnetExe>
-    <Percent>%25</Percent>
-    <XMLResults>$HELIX_WORKITEM_ROOT/testResults.xml</XMLResults>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(WasmDotnet)' == 'true'">
-    <CliArguments>$(CliArguments) --wasm</CliArguments>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(MonoDotnet)' == 'true' and '$(AGENT_OS)' == 'Windows_NT'">
-    <CoreRunArgument>--corerun %HELIX_CORRELATION_PAYLOAD%\dotnet-mono\shared\Microsoft.NETCore.App\6.0.0\corerun.exe</CoreRunArgument>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(MonoDotnet)' == 'true' and '$(AGENT_OS)' != 'Windows_NT'">
-    <CoreRunArgument>--corerun $(BaseDirectory)/dotnet-mono/shared/Microsoft.NETCore.App/6.0.0/corerun</CoreRunArgument>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(UseCoreRun)' == 'true'">
-    <CoreRunArgument>--corerun $(CoreRun)</CoreRunArgument>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(UseBaselineCoreRun)' == 'true'">
-    <BaselineCoreRunArgument>--corerun $(BaselineCoreRun)</BaselineCoreRunArgument>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(WorkItemCommand)' != ''">
-    <WorkItemCommand>$(Python) $(WorkItemCommand) --incremental no --architecture $(Architecture) -f $(_Framework) $(PerfLabArguments)</WorkItemCommand>
-  </PropertyGroup>
-
-  <PropertyGroup Condition="'$(_Framework)' != 'net461'">
-    <WorkItemCommand>$(WorkItemCommand) $(CliArguments)</WorkItemCommand>
-  </PropertyGroup>
-  
-  <PropertyGroup>
-    <WorkItemTimeout>2:30</WorkItemTimeout>
-    <WorkItemTimeout Condition="'$(HelixSourcePrefix)' != 'official'">0:15</WorkItemTimeout>
-  </PropertyGroup>
-
-  <ItemGroup>
-    <HelixCorrelationPayload Include="$(CorrelationPayloadDirectory)">
-      <PayloadDirectory>%(Identity)</PayloadDirectory>
-    </HelixCorrelationPayload>
-  </ItemGroup>
-
-  <PropertyGroup>
-    <PartitionCount>30</PartitionCount>
-  </PropertyGroup>
-  <ItemGroup>
-    <Partition Include="$(BuildConfig).Partition0" Index="0" />
-    <Partition Include="$(BuildConfig).Partition1" Index="1" />
-    <Partition Include="$(BuildConfig).Partition2" Index="2" />
-    <Partition Include="$(BuildConfig).Partition3" Index="3" />
-    <Partition Include="$(BuildConfig).Partition4" Index="4" />
-    <Partition Include="$(BuildConfig).Partition5" Index="5" />
-    <Partition Include="$(BuildConfig).Partition6" Index="6" />
-    <Partition Include="$(BuildConfig).Partition7" Index="7" />
-    <Partition Include="$(BuildConfig).Partition8" Index="8" />
-    <Partition Include="$(BuildConfig).Partition9" Index="9" />
-    <Partition Include="$(BuildConfig).Partition10" Index="10" />
-    <Partition Include="$(BuildConfig).Partition11" Index="11" />
-    <Partition Include="$(BuildConfig).Partition12" Index="12" />
-    <Partition Include="$(BuildConfig).Partition13" Index="13" />
-    <Partition Include="$(BuildConfig).Partition14" Index="14" />
-    <Partition Include="$(BuildConfig).Partition15" Index="15" />
-    <Partition Include="$(BuildConfig).Partition16" Index="16" />
-    <Partition Include="$(BuildConfig).Partition17" Index="17" />
-    <Partition Include="$(BuildConfig).Partition18" Index="18" />
-    <Partition Include="$(BuildConfig).Partition19" Index="19" />
-    <Partition Include="$(BuildConfig).Partition20" Index="20" />
-    <Partition Include="$(BuildConfig).Partition21" Index="21" />
-    <Partition Include="$(BuildConfig).Partition22" Index="22" />
-    <Partition Include="$(BuildConfig).Partition23" Index="23" />
-    <Partition Include="$(BuildConfig).Partition24" Index="24" />
-    <Partition Include="$(BuildConfig).Partition25" Index="25" />
-    <Partition Include="$(BuildConfig).Partition26" Index="26" />
-    <Partition Include="$(BuildConfig).Partition27" Index="27" />
-    <Partition Include="$(BuildConfig).Partition28" Index="28" />
-    <Partition Include="$(BuildConfig).Partition29" Index="29" />
-  </ItemGroup>
-
-  <PropertyGroup Condition="'$(Compare)' == 'true'">
-    <FailOnTestFailure>false</FailOnTestFailure>
-  </PropertyGroup>
-
-  <!-- 
-    Partition the Microbenchmarks project, but nothing else
-  -->
-  <ItemGroup Condition="$(TargetCsproj.Contains('MicroBenchmarks.csproj'))">
-    <HelixWorkItem Include="@(Partition)">
-      <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
-      <PreCommands Condition="'$(Compare)' == 'true'">$(WorkItemCommand) --bdn-artifacts $(BaselineArtifactsDirectory) --bdn-arguments="--anyCategories $(BDNCategories) $(ExtraBenchmarkDotNetArguments) $(BaselineCoreRunArgument) --partition-count $(PartitionCount) --partition-index %(HelixWorkItem.Index)"</PreCommands>
-      <Command>$(WorkItemCommand) --bdn-artifacts $(ArtifactsDirectory) --bdn-arguments="--anyCategories $(BDNCategories) $(ExtraBenchmarkDotNetArguments) $(CoreRunArgument) --partition-count $(PartitionCount) --partition-index %(HelixWorkItem.Index)"</Command>
-      <PostCommands Condition="'$(Compare)' == 'true'">$(DotnetExe) run -f $(_Framework) -p $(ResultsComparer) --base $(BaselineArtifactsDirectory) --diff $(ArtifactsDirectory) --threshold 2$(Percent) --xml $(XMLResults);$(FinalCommand)</PostCommands>
-      <Timeout>$(WorkItemTimeout)</Timeout>
-    </HelixWorkItem>
-  </ItemGroup>
-
-  <ItemGroup Condition="!$(TargetCsproj.Contains('MicroBenchmarks.csproj'))">
-    <HelixWorkItem Include="$(BuildConfig).WorkItem">
-      <PayloadDirectory>$(WorkItemDirectory)</PayloadDirectory>
-      <PreCommands Condition="'$(Compare)' == 'true'">$(WorkItemCommand) --bdn-artifacts $(BaselineArtifactsDirectory) --bdn-arguments="--anyCategories $(BDNCategories) $(ExtraBenchmarkDotNetArguments) $(BaselineCoreRunArgument)"</PreCommands>
-      <Command>$(WorkItemCommand) --bdn-artifacts $(ArtifactsDirectory) --bdn-arguments="--anyCategories $(BDNCategories) $(ExtraBenchmarkDotNetArguments) $(CoreRunArgument)"</Command>
-      <PostCommands Condition="'$(Compare)' == 'true'">$(DotnetExe) run -f $(_Framework) -p $(ResultsComparer) --base $(BaselineArtifactsDirectory) --diff $(ArtifactsDirectory) --threshold 2$(Percent) --xml $(XMLResults)</PostCommands>
-      <Timeout>4:00</Timeout>
-    </HelixWorkItem>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/eng/common/performance/performance-setup.ps1 b/eng/common/performance/performance-setup.ps1
deleted file mode 100644
index 656c0bd9022..00000000000
--- a/eng/common/performance/performance-setup.ps1
+++ /dev/null
@@ -1,147 +0,0 @@
-Param(
-    [string] $SourceDirectory=$env:BUILD_SOURCESDIRECTORY,
-    [string] $CoreRootDirectory,
-    [string] $BaselineCoreRootDirectory,
-    [string] $Architecture="x64",
-    [string] $Framework="net5.0",
-    [string] $CompilationMode="Tiered",
-    [string] $Repository=$env:BUILD_REPOSITORY_NAME,
-    [string] $Branch=$env:BUILD_SOURCEBRANCH,
-    [string] $CommitSha=$env:BUILD_SOURCEVERSION,
-    [string] $BuildNumber=$env:BUILD_BUILDNUMBER,
-    [string] $RunCategories="Libraries Runtime",
-    [string] $Csproj="src\benchmarks\micro\MicroBenchmarks.csproj",
-    [string] $Kind="micro",
-    [switch] $LLVM,
-    [switch] $MonoInterpreter,
-    [switch] $MonoAOT, 
-    [switch] $Internal,
-    [switch] $Compare,
-    [string] $MonoDotnet="",
-    [string] $Configurations="CompilationMode=$CompilationMode RunKind=$Kind"
-)
-
-$RunFromPerformanceRepo = ($Repository -eq "dotnet/performance") -or ($Repository -eq "dotnet-performance")
-$UseCoreRun = ($CoreRootDirectory -ne [string]::Empty)
-$UseBaselineCoreRun = ($BaselineCoreRootDirectory -ne [string]::Empty)
-
-$PayloadDirectory = (Join-Path $SourceDirectory "Payload")
-$PerformanceDirectory = (Join-Path $PayloadDirectory "performance")
-$WorkItemDirectory = (Join-Path $SourceDirectory "workitem")
-$ExtraBenchmarkDotNetArguments = "--iterationCount 1 --warmupCount 0 --invocationCount 1 --unrollFactor 1 --strategy ColdStart --stopOnFirstError true"
-$Creator = $env:BUILD_DEFINITIONNAME
-$PerfLabArguments = ""
-$HelixSourcePrefix = "pr"
-
-$Queue = "Windows.10.Amd64.ClientRS4.DevEx.15.8.Open"
-
-# TODO: Implement a better logic to determine if Framework is .NET Core or >= .NET 5.
-if ($Framework.StartsWith("netcoreapp") -or ($Framework -eq "net5.0")) {
-    $Queue = "Windows.10.Amd64.ClientRS5.Open"
-}
-
-if ($Compare) {
-    $Queue = "Windows.10.Amd64.19H1.Tiger.Perf.Open"
-    $PerfLabArguments = ""
-    $ExtraBenchmarkDotNetArguments = ""
-}
-
-if ($Internal) {
-    $Queue = "Windows.10.Amd64.19H1.Tiger.Perf"
-    $PerfLabArguments = "--upload-to-perflab-container"
-    $ExtraBenchmarkDotNetArguments = ""
-    $Creator = ""
-    $HelixSourcePrefix = "official"
-}
-
-if($MonoInterpreter)
-{
-    $ExtraBenchmarkDotNetArguments = "--category-exclusion-filter NoInterpreter"
-}
-
-if($MonoDotnet -ne "")
-{
-    $Configurations += " LLVM=$LLVM MonoInterpreter=$MonoInterpreter MonoAOT=$MonoAOT"
-    if($ExtraBenchmarkDotNetArguments -eq "")
-    {
-        #FIX ME: We need to block these tests as they don't run on mono for now
-        $ExtraBenchmarkDotNetArguments = "--exclusion-filter *Perf_Image* *Perf_NamedPipeStream*"
-    }
-    else
-    {
-        #FIX ME: We need to block these tests as they don't run on mono for now
-        $ExtraBenchmarkDotNetArguments += " --exclusion-filter *Perf_Image* *Perf_NamedPipeStream*"
-    }
-}
-
-# FIX ME: This is a workaround until we get this from the actual pipeline
-$CommonSetupArguments="--channel master --queue $Queue --build-number $BuildNumber --build-configs $Configurations --architecture $Architecture"
-$SetupArguments = "--repository https://github.com/$Repository --branch $Branch --get-perf-hash --commit-sha $CommitSha $CommonSetupArguments"
-
-
-#This grabs the LKG version number of dotnet and passes it to our scripts
-$VersionJSON = Get-Content global.json | ConvertFrom-Json
-$DotNetVersion = $VersionJSON.tools.dotnet
-$SetupArguments = "--dotnet-versions $DotNetVersion $SetupArguments"
-
-
-if ($RunFromPerformanceRepo) {
-    $SetupArguments = "--perf-hash $CommitSha $CommonSetupArguments"
-    
-    robocopy $SourceDirectory $PerformanceDirectory /E /XD $PayloadDirectory $SourceDirectory\artifacts $SourceDirectory\.git
-}
-else {
-    git clone --branch master --depth 1 --quiet https://github.com/dotnet/performance $PerformanceDirectory
-}
-
-if($MonoDotnet -ne "")
-{
-    $UsingMono = "true"
-    $MonoDotnetPath = (Join-Path $PayloadDirectory "dotnet-mono")
-    Move-Item -Path $MonoDotnet -Destination $MonoDotnetPath
-}
-
-if ($UseCoreRun) {
-    $NewCoreRoot = (Join-Path $PayloadDirectory "Core_Root")
-    Move-Item -Path $CoreRootDirectory -Destination $NewCoreRoot
-}
-if ($UseBaselineCoreRun) {
-    $NewBaselineCoreRoot = (Join-Path $PayloadDirectory "Baseline_Core_Root")
-    Move-Item -Path $BaselineCoreRootDirectory -Destination $NewBaselineCoreRoot
-}
-
-$DocsDir = (Join-Path $PerformanceDirectory "docs")
-robocopy $DocsDir $WorkItemDirectory
-
-# Set variables that we will need to have in future steps
-$ci = $true
-
-. "$PSScriptRoot\..\pipeline-logging-functions.ps1"
-
-# Directories
-Write-PipelineSetVariable -Name 'PayloadDirectory' -Value "$PayloadDirectory" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'PerformanceDirectory' -Value "$PerformanceDirectory" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'WorkItemDirectory' -Value "$WorkItemDirectory" -IsMultiJobVariable $false
-
-# Script Arguments
-Write-PipelineSetVariable -Name 'Python' -Value "py -3" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'ExtraBenchmarkDotNetArguments' -Value "$ExtraBenchmarkDotNetArguments" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'SetupArguments' -Value "$SetupArguments" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'PerfLabArguments' -Value "$PerfLabArguments" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'BDNCategories' -Value "$RunCategories" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'TargetCsproj' -Value "$Csproj" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'Kind' -Value "$Kind" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'Architecture' -Value "$Architecture" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'UseCoreRun' -Value "$UseCoreRun" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'UseBaselineCoreRun' -Value "$UseBaselineCoreRun" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'RunFromPerfRepo' -Value "$RunFromPerformanceRepo" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'Compare' -Value "$Compare" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'MonoDotnet' -Value "$UsingMono" -IsMultiJobVariable $false
-
-# Helix Arguments
-Write-PipelineSetVariable -Name 'Creator' -Value "$Creator" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'Queue' -Value "$Queue" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name 'HelixSourcePrefix' -Value "$HelixSourcePrefix" -IsMultiJobVariable $false
-Write-PipelineSetVariable -Name '_BuildConfig' -Value "$Architecture.$Kind.$Framework" -IsMultiJobVariable $false
-
-exit 0
\ No newline at end of file
diff --git a/eng/common/performance/performance-setup.sh b/eng/common/performance/performance-setup.sh
deleted file mode 100755
index 99d1b7bc1fc..00000000000
--- a/eng/common/performance/performance-setup.sh
+++ /dev/null
@@ -1,289 +0,0 @@
-#!/usr/bin/env bash
-
-source_directory=$BUILD_SOURCESDIRECTORY
-core_root_directory=
-baseline_core_root_directory=
-architecture=x64
-framework=net5.0
-compilation_mode=tiered
-repository=$BUILD_REPOSITORY_NAME
-branch=$BUILD_SOURCEBRANCH
-commit_sha=$BUILD_SOURCEVERSION
-build_number=$BUILD_BUILDNUMBER
-internal=false
-compare=false
-mono_dotnet=
-kind="micro"
-llvm=false
-monointerpreter=false
-monoaot=false
-run_categories="Libraries Runtime"
-csproj="src\benchmarks\micro\MicroBenchmarks.csproj"
-configurations="CompliationMode=$compilation_mode RunKind=$kind"
-run_from_perf_repo=false
-use_core_run=true
-use_baseline_core_run=true
-using_mono=false
-wasm_runtime_loc=
-using_wasm=false
-use_latest_dotnet=false
-
-while (($# > 0)); do
-  lowerI="$(echo $1 | awk '{print tolower($0)}')"
-  case $lowerI in
-    --sourcedirectory)
-      source_directory=$2
-      shift 2
-      ;;
-    --corerootdirectory)
-      core_root_directory=$2
-      shift 2
-      ;;
-    --baselinecorerootdirectory)
-      baseline_core_root_directory=$2
-      shift 2
-      ;;
-    --architecture)
-      architecture=$2
-      shift 2
-      ;;
-    --framework)
-      framework=$2
-      shift 2
-      ;;
-    --compilationmode)
-      compilation_mode=$2
-      shift 2
-      ;;
-    --repository)
-      repository=$2
-      shift 2
-      ;;
-    --branch)
-      branch=$2
-      shift 2
-      ;;
-    --commitsha)
-      commit_sha=$2
-      shift 2
-      ;;
-    --buildnumber)
-      build_number=$2
-      shift 2
-      ;;
-    --kind)
-      kind=$2
-      configurations="CompilationMode=$compilation_mode RunKind=$kind"
-      shift 2
-      ;;
-    --runcategories)
-      run_categories=$2
-      shift 2
-      ;;
-    --csproj)
-      csproj=$2
-      shift 2
-      ;;
-    --internal)
-      internal=true
-      shift 1
-      ;;
-    --llvm)
-      llvm=true
-      shift 1
-      ;;
-    --monointerpreter)
-      monointerpreter=true
-      shift 1
-      ;;
-    --monoaot)
-      monoaot=true
-      shift 1
-      ;;
-    --monodotnet)
-      mono_dotnet=$2
-      shift 2
-      ;;
-    --wasm)
-      wasm_runtime_loc=$2
-      shift 2
-      ;;
-    --compare)
-      compare=true
-      shift 1
-      ;;
-    --configurations)
-      configurations=$2
-      shift 2
-      ;;
-    --latestdotnet)
-      use_latest_dotnet=true
-      shift 1
-      ;;
-    *)
-      echo "Common settings:"
-      echo "  --corerootdirectory <value>    Directory where Core_Root exists, if running perf testing with --corerun"
-      echo "  --architecture <value>         Architecture of the testing being run"
-      echo "  --configurations <value>       List of key=value pairs that will be passed to perf testing infrastructure."
-      echo "                                 ex: --configurations \"CompilationMode=Tiered OptimzationLevel=PGO\""
-      echo "  --help                         Print help and exit"
-      echo ""
-      echo "Advanced settings:"
-      echo "  --framework <value>            The framework to run, if not running in master"
-      echo "  --compliationmode <value>      The compilation mode if not passing --configurations"
-      echo "  --sourcedirectory <value>      The directory of the sources. Defaults to env:BUILD_SOURCESDIRECTORY"
-      echo "  --repository <value>           The name of the repository in the <owner>/<repository name> format. Defaults to env:BUILD_REPOSITORY_NAME"
-      echo "  --branch <value>               The name of the branch. Defaults to env:BUILD_SOURCEBRANCH"
-      echo "  --commitsha <value>            The commit sha1 to run against. Defaults to env:BUILD_SOURCEVERSION"
-      echo "  --buildnumber <value>          The build number currently running. Defaults to env:BUILD_BUILDNUMBER"
-      echo "  --csproj                       The relative path to the benchmark csproj whose tests should be run. Defaults to src\benchmarks\micro\MicroBenchmarks.csproj"
-      echo "  --kind <value>                 Related to csproj. The kind of benchmarks that should be run. Defaults to micro"
-      echo "  --runcategories <value>        Related to csproj. Categories of benchmarks to run. Defaults to \"coreclr corefx\""
-      echo "  --internal                     If the benchmarks are running as an official job."
-      echo "  --monodotnet                   Pass the path to the mono dotnet for mono performance testing."
-      echo "  --wasm                         Path to the unpacked wasm runtime pack."
-      echo "  --latestdotnet                 --dotnet-versions will not be specified. --dotnet-versions defaults to LKG version in global.json "
-      echo ""
-      exit 0
-      ;;
-  esac
-done
-
-if [ "$repository" == "dotnet/performance" ] || [ "$repository" == "dotnet-performance" ]; then
-    run_from_perf_repo=true
-fi
-
-if [ -z "$configurations" ]; then
-    configurations="CompilationMode=$compilation_mode"
-fi
-
-if [ -z "$core_root_directory" ]; then
-    use_core_run=false
-fi
-
-if [ -z "$baseline_core_root_directory" ]; then
-    use_baseline_core_run=false
-fi
-
-payload_directory=$source_directory/Payload
-performance_directory=$payload_directory/performance
-workitem_directory=$source_directory/workitem
-extra_benchmark_dotnet_arguments="--iterationCount 1 --warmupCount 0 --invocationCount 1 --unrollFactor 1 --strategy ColdStart --stopOnFirstError true"
-perflab_arguments=
-queue=Ubuntu.1804.Amd64.Open
-creator=$BUILD_DEFINITIONNAME
-helix_source_prefix="pr"
-
-if [[ "$compare" == true ]]; then
-  extra_benchmark_dotnet_arguments=
-  perflab_arguments=
-
-  # No open queues for arm64
-  if [[ "$architecture" = "arm64" ]]; then
-    echo "Compare not available for arm64"
-    exit 1
-  fi
-
-  queue=Ubuntu.1804.Amd64.Tiger.Perf.Open
-fi
-
-if [[ "$internal" == true ]]; then
-    perflab_arguments="--upload-to-perflab-container"
-    helix_source_prefix="official"
-    creator=
-    extra_benchmark_dotnet_arguments=
-    
-    if [[ "$architecture" = "arm64" ]]; then
-        queue=Ubuntu.1804.Arm64.Perf
-    else
-        queue=Ubuntu.1804.Amd64.Tiger.Perf
-    fi
-fi
-
-if [[ "$mono_dotnet" != "" ]] && [[ "$monointerpreter" == "false" ]]; then
-    extra_benchmark_dotnet_arguments="$extra_benchmark_dotnet_arguments --category-exclusion-filter NoMono"
-fi
-
-if [[ "$wasm_runtime_loc" != "" ]]; then
-    configurations="CompilationMode=wasm RunKind=$kind"
-    extra_benchmark_dotnet_arguments="$extra_benchmark_dotnet_arguments --category-exclusion-filter NoInterpreter NoWASM NoMono"
-fi
-
-if [[ "$mono_dotnet" != "" ]] && [[ "$monointerpreter" == "true" ]]; then
-    configurations="$configurations LLVM=$llvm MonoInterpreter=$monointerpreter MonoAOT=$monoaot"
-    extra_benchmark_dotnet_arguments="$extra_benchmark_dotnet_arguments --category-exclusion-filter NoInterpreter NoMono"
-fi
-
-common_setup_arguments="--channel master --queue $queue --build-number $build_number --build-configs $configurations --architecture $architecture"
-setup_arguments="--repository https://github.com/$repository --branch $branch --get-perf-hash --commit-sha $commit_sha $common_setup_arguments"
-
-
-if [[ "$use_latest_dotnet" = false ]]; then
-    # Get the tools section from the global.json.
-    # This grabs the LKG version number of dotnet and passes it to our scripts
-    dotnet_version=`cat global.json | python3 -c 'import json,sys;obj=json.load(sys.stdin);print(obj["tools"]["dotnet"])'`
-    setup_arguments="--dotnet-versions $dotnet_version $setup_arguments"
-fi
-
-if [[ "$run_from_perf_repo" = true ]]; then
-    payload_directory=
-    workitem_directory=$source_directory
-    performance_directory=$workitem_directory
-    setup_arguments="--perf-hash $commit_sha $common_setup_arguments"
-else
-    git clone --branch master --depth 1 --quiet https://github.com/dotnet/performance $performance_directory
-    
-    docs_directory=$performance_directory/docs
-    mv $docs_directory $workitem_directory
-fi
-
-if [[ "$wasm_runtime_loc" != "" ]]; then
-    using_wasm=true
-    wasm_dotnet_path=$payload_directory/dotnet-wasm
-    mv $wasm_runtime_loc $wasm_dotnet_path
-    extra_benchmark_dotnet_arguments="$extra_benchmark_dotnet_arguments --wasmMainJS \$HELIX_CORRELATION_PAYLOAD/dotnet-wasm/runtime-test.js --wasmEngine /home/helixbot/.jsvu/v8 --customRuntimePack \$HELIX_CORRELATION_PAYLOAD/dotnet-wasm"
-fi
-
-if [[ "$mono_dotnet" != "" ]]; then
-    using_mono=true
-    mono_dotnet_path=$payload_directory/dotnet-mono
-    mv $mono_dotnet $mono_dotnet_path
-fi
-
-if [[ "$use_core_run" = true ]]; then
-    new_core_root=$payload_directory/Core_Root
-    mv $core_root_directory $new_core_root
-fi
-
-if [[ "$use_baseline_core_run" = true ]]; then
-  new_baseline_core_root=$payload_directory/Baseline_Core_Root
-  mv $baseline_core_root_directory $new_baseline_core_root
-fi
-
-ci=true
-
-_script_dir=$(pwd)/eng/common
-. "$_script_dir/pipeline-logging-functions.sh"
-
-# Make sure all of our variables are available for future steps
-Write-PipelineSetVariable -name "UseCoreRun" -value "$use_core_run" -is_multi_job_variable false
-Write-PipelineSetVariable -name "UseBaselineCoreRun" -value "$use_baseline_core_run" -is_multi_job_variable false
-Write-PipelineSetVariable -name "Architecture" -value "$architecture" -is_multi_job_variable false
-Write-PipelineSetVariable -name "PayloadDirectory" -value "$payload_directory" -is_multi_job_variable false
-Write-PipelineSetVariable -name "PerformanceDirectory" -value "$performance_directory" -is_multi_job_variable false
-Write-PipelineSetVariable -name "WorkItemDirectory" -value "$workitem_directory" -is_multi_job_variable false
-Write-PipelineSetVariable -name "Queue" -value "$queue" -is_multi_job_variable false
-Write-PipelineSetVariable -name "SetupArguments" -value "$setup_arguments" -is_multi_job_variable false
-Write-PipelineSetVariable -name "Python" -value "python3" -is_multi_job_variable false
-Write-PipelineSetVariable -name "PerfLabArguments" -value "$perflab_arguments" -is_multi_job_variable false
-Write-PipelineSetVariable -name "ExtraBenchmarkDotNetArguments" -value "$extra_benchmark_dotnet_arguments" -is_multi_job_variable false
-Write-PipelineSetVariable -name "BDNCategories" -value "$run_categories" -is_multi_job_variable false
-Write-PipelineSetVariable -name "TargetCsproj" -value "$csproj" -is_multi_job_variable false
-Write-PipelineSetVariable -name "RunFromPerfRepo" -value "$run_from_perf_repo" -is_multi_job_variable false
-Write-PipelineSetVariable -name "Creator" -value "$creator" -is_multi_job_variable false
-Write-PipelineSetVariable -name "HelixSourcePrefix" -value "$helix_source_prefix" -is_multi_job_variable false
-Write-PipelineSetVariable -name "Kind" -value "$kind" -is_multi_job_variable false
-Write-PipelineSetVariable -name "_BuildConfig" -value "$architecture.$kind.$framework" -is_multi_job_variable false
-Write-PipelineSetVariable -name "Compare" -value "$compare" -is_multi_job_variable false
-Write-PipelineSetVariable -name "MonoDotnet" -value "$using_mono" -is_multi_job_variable false
-Write-PipelineSetVariable -name "WasmDotnet" -value "$using_wasm" -is_multi_job_variable false
diff --git a/eng/common/pipeline-logging-functions.ps1 b/eng/common/pipeline-logging-functions.ps1
index 8484451f3a5..8e422c561e4 100644
--- a/eng/common/pipeline-logging-functions.ps1
+++ b/eng/common/pipeline-logging-functions.ps1
@@ -29,14 +29,14 @@ function Write-PipelineTelemetryError {
         [switch]$AsOutput,
         [switch]$Force)
 
-        $PSBoundParameters.Remove('Category') | Out-Null
+    $PSBoundParameters.Remove('Category') | Out-Null
 
-        if($Force -Or ((Test-Path variable:ci) -And $ci)) {
-            $Message = "(NETCORE_ENGINEERING_TELEMETRY=$Category) $Message"
-        }
-        $PSBoundParameters.Remove('Message') | Out-Null
-        $PSBoundParameters.Add('Message', $Message)
-        Write-PipelineTaskError @PSBoundParameters
+    if ($Force -Or ((Test-Path variable:ci) -And $ci)) {
+        $Message = "(NETCORE_ENGINEERING_TELEMETRY=$Category) $Message"
+    }
+    $PSBoundParameters.Remove('Message') | Out-Null
+    $PSBoundParameters.Add('Message', $Message)
+    Write-PipelineTaskError @PSBoundParameters
 }
 
 # Specify "-Force" to force pipeline formatted output even if "$ci" is false or not set
@@ -55,8 +55,8 @@ function Write-PipelineTaskError {
         [switch]$Force
     )
 
-    if(!$Force -And (-Not (Test-Path variable:ci) -Or !$ci)) {
-        if($Type -eq 'error') {
+    if (!$Force -And (-Not (Test-Path variable:ci) -Or !$ci)) {
+        if ($Type -eq 'error') {
             Write-Host $Message -ForegroundColor Red
             return
         }
@@ -66,47 +66,61 @@ function Write-PipelineTaskError {
         }
     }
 
-    if(($Type -ne 'error') -and ($Type -ne 'warning')) {
+    if (($Type -ne 'error') -and ($Type -ne 'warning')) {
         Write-Host $Message
         return
     }
     $PSBoundParameters.Remove('Force') | Out-Null      
-    if(-not $PSBoundParameters.ContainsKey('Type')) {
+    if (-not $PSBoundParameters.ContainsKey('Type')) {
         $PSBoundParameters.Add('Type', 'error')
     }
     Write-LogIssue @PSBoundParameters
-  }
+}
   
-  function Write-PipelineSetVariable {
+function Write-PipelineSetVariable {
     [CmdletBinding()]
     param(
-      [Parameter(Mandatory = $true)]
-      [string]$Name,
-      [string]$Value,
-      [switch]$Secret,
-      [switch]$AsOutput,
-      [bool]$IsMultiJobVariable=$true)
-
-      if((Test-Path variable:ci) -And $ci) {
+        [Parameter(Mandatory = $true)]
+        [string]$Name,
+        [string]$Value,
+        [switch]$Secret,
+        [switch]$AsOutput,
+        [bool]$IsMultiJobVariable = $true)
+
+    if ((Test-Path variable:ci) -And $ci) {
         Write-LoggingCommand -Area 'task' -Event 'setvariable' -Data $Value -Properties @{
-          'variable' = $Name
-          'isSecret' = $Secret
-          'isOutput' = $IsMultiJobVariable
+            'variable' = $Name
+            'isSecret' = $Secret
+            'isOutput' = $IsMultiJobVariable
         } -AsOutput:$AsOutput
-      }
-  }
+    }
+}
   
-  function Write-PipelinePrependPath {
+function Write-PipelinePrependPath {
     [CmdletBinding()]
     param(
-      [Parameter(Mandatory=$true)]
-      [string]$Path,
-      [switch]$AsOutput)
+        [Parameter(Mandatory = $true)]
+        [string]$Path,
+        [switch]$AsOutput)
 
-      if((Test-Path variable:ci) -And $ci) {
+    if ((Test-Path variable:ci) -And $ci) {
         Write-LoggingCommand -Area 'task' -Event 'prependpath' -Data $Path -AsOutput:$AsOutput
-      }
-  }
+    }
+}
+
+function Write-PipelineSetResult {
+    [CmdletBinding()]
+    param(
+        [ValidateSet("Succeeded", "SucceededWithIssues", "Failed", "Cancelled", "Skipped")]
+        [Parameter(Mandatory = $true)]
+        [string]$Result,
+        [string]$Message)
+    if ((Test-Path variable:ci) -And $ci) {
+        Write-LoggingCommand -Area 'task' -Event 'complete' -Data $Message -Properties @{
+            'result' = $Result
+        }
+    }
+}
 
 <########################################
 # Private functions.
@@ -123,7 +137,8 @@ function Format-LoggingCommandData {
         foreach ($mapping in $script:loggingCommandEscapeMappings) {
             $Value = $Value.Replace($mapping.Token, $mapping.Replacement)
         }
-    } else {
+    }
+    else {
         for ($i = $script:loggingCommandEscapeMappings.Length - 1 ; $i -ge 0 ; $i--) {
             $mapping = $script:loggingCommandEscapeMappings[$i]
             $Value = $Value.Replace($mapping.Replacement, $mapping.Token)
@@ -156,7 +171,8 @@ function Format-LoggingCommand {
                 if ($first) {
                     $null = $sb.Append(' ')
                     $first = $false
-                } else {
+                }
+                else {
                     $null = $sb.Append(';')
                 }
 
@@ -193,7 +209,8 @@ function Write-LoggingCommand {
     $command = Format-LoggingCommand -Area $Area -Event $Event -Data $Data -Properties $Properties
     if ($AsOutput) {
         $command
-    } else {
+    }
+    else {
         Write-Host $command
     }
 }
@@ -212,12 +229,12 @@ function Write-LogIssue {
         [switch]$AsOutput)
 
     $command = Format-LoggingCommand -Area 'task' -Event 'logissue' -Data $Message -Properties @{
-            'type' = $Type
-            'code' = $ErrCode
-            'sourcepath' = $SourcePath
-            'linenumber' = $LineNumber
-            'columnnumber' = $ColumnNumber
-        }
+        'type'         = $Type
+        'code'         = $ErrCode
+        'sourcepath'   = $SourcePath
+        'linenumber'   = $LineNumber
+        'columnnumber' = $ColumnNumber
+    }
     if ($AsOutput) {
         return $command
     }
@@ -229,7 +246,8 @@ function Write-LogIssue {
             $foregroundColor = [System.ConsoleColor]::Red
             $backgroundColor = [System.ConsoleColor]::Black
         }
-    } else {
+    }
+    else {
         $foregroundColor = $host.PrivateData.WarningForegroundColor
         $backgroundColor = $host.PrivateData.WarningBackgroundColor
         if ($foregroundColor -isnot [System.ConsoleColor] -or $backgroundColor -isnot [System.ConsoleColor]) {
diff --git a/eng/common/pipeline-logging-functions.sh b/eng/common/pipeline-logging-functions.sh
index 6cd0a3400e6..6a0b2255e91 100755
--- a/eng/common/pipeline-logging-functions.sh
+++ b/eng/common/pipeline-logging-functions.sh
@@ -6,7 +6,7 @@ function Write-PipelineTelemetryError {
   local function_args=()
   local message=''
   while [[ $# -gt 0 ]]; do
-    opt="$(echo "${1/#--/-}" | awk '{print tolower($0)}')"
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
     case "$opt" in
       -category|-c)
         telemetry_category=$2
@@ -48,7 +48,7 @@ function Write-PipelineTaskError {
   local force=false
 
   while [[ $# -gt 0 ]]; do
-    opt="$(echo "${1/#--/-}" | awk '{print tolower($0)}')"
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
     case "$opt" in
       -type|-t)
         message_type=$2
@@ -122,7 +122,7 @@ function Write-PipelineSetVariable {
   local is_multi_job_variable=true
 
   while [[ $# -gt 0 ]]; do
-    opt="$(echo "${1/#--/-}" | awk '{print tolower($0)}')"
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
     case "$opt" in
       -name|-n)
         name=$2
@@ -164,7 +164,7 @@ function Write-PipelinePrependPath {
   local prepend_path=''
 
   while [[ $# -gt 0 ]]; do
-    opt="$(echo "${1/#--/-}" | awk '{print tolower($0)}')"
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
     case "$opt" in
       -path|-p)
         prepend_path=$2
@@ -179,4 +179,28 @@ function Write-PipelinePrependPath {
   if [[ "$ci" == true ]]; then
     echo "##vso[task.prependpath]$prepend_path"
   fi
-}
\ No newline at end of file
+}
+
+function Write-PipelineSetResult {
+  local result=''
+  local message=''
+
+  while [[ $# -gt 0 ]]; do
+    opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+    case "$opt" in
+      -result|-r)
+        result=$2
+        shift
+        ;;
+      -message|-m)
+        message=$2
+        shift
+        ;;
+    esac
+    shift
+  done
+
+  if [[ "$ci" == true ]]; then
+    echo "##vso[task.complete result=$result;]$message"
+  fi
+}
diff --git a/eng/common/post-build/post-build-utils.ps1 b/eng/common/post-build/post-build-utils.ps1
index 7d49744795f..534f6988d5b 100644
--- a/eng/common/post-build/post-build-utils.ps1
+++ b/eng/common/post-build/post-build-utils.ps1
@@ -69,9 +69,9 @@ function Trigger-Subscription([string]$SubscriptionId) {
 
 function Validate-MaestroVars {
   try {
-    Get-Variable MaestroApiEndPoint -Scope Global | Out-Null
-    Get-Variable MaestroApiVersion -Scope Global | Out-Null
-    Get-Variable MaestroApiAccessToken -Scope Global | Out-Null
+    Get-Variable MaestroApiEndPoint | Out-Null
+    Get-Variable MaestroApiVersion | Out-Null
+    Get-Variable MaestroApiAccessToken | Out-Null
 
     if (!($MaestroApiEndPoint -Match '^http[s]?://maestro-(int|prod).westus2.cloudapp.azure.com$')) {
       Write-PipelineTelemetryError -Category 'MaestroVars' -Message "MaestroApiEndPoint is not a valid Maestro URL. '$MaestroApiEndPoint'"
diff --git a/eng/common/post-build/publish-using-darc.ps1 b/eng/common/post-build/publish-using-darc.ps1
index a40ee827a43..2427ca6b6ae 100644
--- a/eng/common/post-build/publish-using-darc.ps1
+++ b/eng/common/post-build/publish-using-darc.ps1
@@ -10,21 +10,27 @@ param(
   [Parameter(Mandatory=$false)][string] $EnableNugetValidation,
   [Parameter(Mandatory=$false)][string] $PublishInstallersAndChecksums,
   [Parameter(Mandatory=$false)][string] $ArtifactsPublishingAdditionalParameters,
+  [Parameter(Mandatory=$false)][string] $SymbolPublishingAdditionalParameters,
   [Parameter(Mandatory=$false)][string] $SigningValidationAdditionalParameters
 )
 
 try {
   . $PSScriptRoot\post-build-utils.ps1
-  # Hard coding darc version till the next arcade-services roll out, cos this version has required API changes for darc add-build-to-channel
-  $darc = Get-Darc "1.1.0-beta.20418.1"
+
+  $darc = Get-Darc 
 
   $optionalParams = [System.Collections.ArrayList]::new()
 
   if ("" -ne $ArtifactsPublishingAdditionalParameters) {
-    $optionalParams.Add("artifact-publishing-parameters") | Out-Null
+    $optionalParams.Add("--artifact-publishing-parameters") | Out-Null
     $optionalParams.Add($ArtifactsPublishingAdditionalParameters) | Out-Null
   }
 
+  if ("" -ne $SymbolPublishingAdditionalParameters) {
+    $optionalParams.Add("--symbol-publishing-parameters") | Out-Null
+    $optionalParams.Add($SymbolPublishingAdditionalParameters) | Out-Null
+  }
+
   if ("false" -eq $WaitPublishingFinish) {
     $optionalParams.Add("--no-wait") | Out-Null
   }
diff --git a/eng/common/post-build/sourcelink-validation.ps1 b/eng/common/post-build/sourcelink-validation.ps1
index c7e7ae67d81..85c89861719 100644
--- a/eng/common/post-build/sourcelink-validation.ps1
+++ b/eng/common/post-build/sourcelink-validation.ps1
@@ -14,7 +14,9 @@ param(
 $global:RepoFiles = @{}
 
 # Maximum number of jobs to run in parallel
-$MaxParallelJobs = 6
+$MaxParallelJobs = 16
+
+$MaxRetries = 5
 
 # Wait time between check for system load
 $SecondsBetweenLoadChecks = 10
@@ -29,7 +31,10 @@ $ValidatePackage = {
   # Ensure input file exist
   if (!(Test-Path $PackagePath)) {
     Write-Host "Input file does not exist: $PackagePath"
-    return 1
+    return [pscustomobject]@{
+      result = 1
+      packagePath = $PackagePath
+    }
   }
 
   # Extensions for which we'll look for SourceLink information
@@ -59,7 +64,10 @@ $ValidatePackage = {
 
           # We ignore resource DLLs
           if ($FileName.EndsWith('.resources.dll')) {
-            return
+            return [pscustomobject]@{
+              result = 0
+              packagePath = $PackagePath
+            }
           }
 
           [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, $TargetFile, $true)
@@ -91,36 +99,49 @@ $ValidatePackage = {
                     $Status = 200
                     $Cache = $using:RepoFiles
 
-                    if ( !($Cache.ContainsKey($FilePath)) ) {
-                      try {
-                        $Uri = $Link -as [System.URI]
-                      
-                        # Only GitHub links are valid
-                        if ($Uri.AbsoluteURI -ne $null -and ($Uri.Host -match 'github' -or $Uri.Host -match 'githubusercontent')) {
-                          $Status = (Invoke-WebRequest -Uri $Link -UseBasicParsing -Method HEAD -TimeoutSec 5).StatusCode
+                    $totalRetries = 0
+
+                    while ($totalRetries -lt $using:MaxRetries) {
+                      if ( !($Cache.ContainsKey($FilePath)) ) {
+                        try {
+                          $Uri = $Link -as [System.URI]
+                        
+                          # Only GitHub links are valid
+                          if ($Uri.AbsoluteURI -ne $null -and ($Uri.Host -match 'github' -or $Uri.Host -match 'githubusercontent')) {
+                            $Status = (Invoke-WebRequest -Uri $Link -UseBasicParsing -Method HEAD -TimeoutSec 5).StatusCode
+                          }
+                          else {
+                            # If it's not a github link, we want to break out of the loop and not retry.
+                            $Status = 0
+                            $totalRetries = $using:MaxRetries
+                          }
                         }
-                        else {
+                        catch {
+                          Write-Host $_
                           $Status = 0
                         }
                       }
-                      catch {
-                        write-host $_
-                        $Status = 0
-                      }
-                    }
 
-                    if ($Status -ne 200) {
-                      if ($NumFailedLinks -eq 0) {
-                        if ($FailedFiles.Value -eq 0) {
-                          Write-Host
+                      if ($Status -ne 200) {
+                        $totalRetries++
+                        
+                        if ($totalRetries -ge $using:MaxRetries) {
+                          if ($NumFailedLinks -eq 0) {
+                            if ($FailedFiles.Value -eq 0) {
+                              Write-Host
+                            }
+  
+                            Write-Host "`tFile $RealPath has broken links:"
+                          }
+  
+                          Write-Host "`t`tFailed to retrieve $Link"
+  
+                          $NumFailedLinks++
                         }
-
-                        Write-Host "`tFile $RealPath has broken links:"
                       }
-
-                      Write-Host "`t`tFailed to retrieve $Link"
-
-                      $NumFailedLinks++
+                      else {
+                        break
+                      }
                     }
                   }
               }
@@ -136,7 +157,7 @@ $ValidatePackage = {
         }
   }
   catch {
-  
+    Write-Host $_
   }
   finally {
     $zip.Dispose() 
@@ -161,9 +182,12 @@ $ValidatePackage = {
 function CheckJobResult(
     $result, 
     $packagePath,
-    [ref]$ValidationFailures) {
-  if ($jobResult.result -ne '0') {
-    Write-PipelineTelemetryError -Category 'SourceLink' -Message "$packagePath has broken SourceLink links."
+    [ref]$ValidationFailures,
+    [switch]$logErrors) {
+  if ($result -ne '0') {
+    if ($logErrors) {
+      Write-PipelineTelemetryError -Category 'SourceLink' -Message "$packagePath has broken SourceLink links."
+    }
     $ValidationFailures.Value++
   }
 }
@@ -217,6 +241,7 @@ function ValidateSourceLinkLinks {
   # Process each NuGet package in parallel
   Get-ChildItem "$InputPath\*.symbols.nupkg" |
     ForEach-Object {
+      Write-Host "Starting $($_.FullName)"
       Start-Job -ScriptBlock $ValidatePackage -ArgumentList $_.FullName | Out-Null
       $NumJobs = @(Get-Job -State 'Running').Count
       
@@ -228,16 +253,14 @@ function ValidateSourceLinkLinks {
 
       foreach ($Job in @(Get-Job -State 'Completed')) {
         $jobResult = Wait-Job -Id $Job.Id | Receive-Job
-        CheckJobResult $jobResult.result $jobResult.packagePath ([ref]$ValidationFailures)
+        CheckJobResult $jobResult.result $jobResult.packagePath ([ref]$ValidationFailures) -LogErrors
         Remove-Job -Id $Job.Id
       }
     }
 
   foreach ($Job in @(Get-Job)) {
     $jobResult = Wait-Job -Id $Job.Id | Receive-Job
-    if ($jobResult -ne '0') {
-      $ValidationFailures++
-    }
+    CheckJobResult $jobResult.result $jobResult.packagePath ([ref]$ValidationFailures)
     Remove-Job -Id $Job.Id
   }
   if ($ValidationFailures -gt 0) {
@@ -266,6 +289,10 @@ function InstallSourcelinkCli {
 try {
   InstallSourcelinkCli
 
+  foreach ($Job in @(Get-Job)) {
+    Remove-Job -Id $Job.Id
+  }
+
   ValidateSourceLinkLinks 
 }
 catch {
diff --git a/eng/common/post-build/symbols-validation.ps1 b/eng/common/post-build/symbols-validation.ps1
index fcc6019b495..a5af041ba77 100644
--- a/eng/common/post-build/symbols-validation.ps1
+++ b/eng/common/post-build/symbols-validation.ps1
@@ -1,30 +1,49 @@
 param(
-  [Parameter(Mandatory=$true)][string] $InputPath,              # Full path to directory where NuGet packages to be checked are stored
-  [Parameter(Mandatory=$true)][string] $ExtractPath,            # Full path to directory where the packages will be extracted during validation
-  [Parameter(Mandatory=$true)][string] $DotnetSymbolVersion,    # Version of dotnet symbol to use
-  [Parameter(Mandatory=$false)][switch] $ContinueOnError,       # If we should keep checking symbols after an error
-  [Parameter(Mandatory=$false)][switch] $Clean                  # Clean extracted symbols directory after checking symbols
+  [Parameter(Mandatory = $true)][string] $InputPath, # Full path to directory where NuGet packages to be checked are stored
+  [Parameter(Mandatory = $true)][string] $ExtractPath, # Full path to directory where the packages will be extracted during validation
+  [Parameter(Mandatory = $true)][string] $DotnetSymbolVersion, # Version of dotnet symbol to use
+  [Parameter(Mandatory = $false)][switch] $CheckForWindowsPdbs, # If we should check for the existence of windows pdbs in addition to portable PDBs
+  [Parameter(Mandatory = $false)][switch] $ContinueOnError, # If we should keep checking symbols after an error
+  [Parameter(Mandatory = $false)][switch] $Clean                  # Clean extracted symbols directory after checking symbols
 )
 
 # Maximum number of jobs to run in parallel
-$MaxParallelJobs = 6
+$MaxParallelJobs = 16
+
+# Max number of retries
+$MaxRetry = 5
 
 # Wait time between check for system load
 $SecondsBetweenLoadChecks = 10
 
+# Set error codes
+Set-Variable -Name "ERROR_BADEXTRACT" -Option Constant -Value -1
+Set-Variable -Name "ERROR_FILEDOESNOTEXIST" -Option Constant -Value -2
+
+$WindowsPdbVerificationParam = ""
+if ($CheckForWindowsPdbs) {
+  $WindowsPdbVerificationParam = "--windows-pdbs"
+}
+
 $CountMissingSymbols = {
   param( 
-    [string] $PackagePath          # Path to a NuGet package
+    [string] $PackagePath, # Path to a NuGet package
+    [string] $WindowsPdbVerificationParam # If we should check for the existence of windows pdbs in addition to portable PDBs
   )
 
   . $using:PSScriptRoot\..\tools.ps1
 
   Add-Type -AssemblyName System.IO.Compression.FileSystem
 
+  Write-Host "Validating $PackagePath "
+
   # Ensure input file exist
   if (!(Test-Path $PackagePath)) {
     Write-PipelineTaskError "Input file does not exist: $PackagePath"
-    return -2
+    return [pscustomobject]@{
+      result      = $using:ERROR_FILEDOESNOTEXIST
+      packagePath = $PackagePath
+    }
   }
   
   # Extensions for which we'll look for symbols
@@ -45,24 +64,25 @@ $CountMissingSymbols = {
     Write-Host "Something went wrong extracting $PackagePath"
     Write-Host $_
     return [pscustomobject]@{
-      result = -1
+      result      = $using:ERROR_BADEXTRACT
       packagePath = $PackagePath
     }
   }
 
   Get-ChildItem -Recurse $ExtractPath |
-    Where-Object {$RelevantExtensions -contains $_.Extension} |
-    ForEach-Object {
-      $FileName = $_.FullName
-      if ($FileName -Match '\\ref\\') {
-        Write-Host "`t Ignoring reference assembly file " $FileName
-        return
-      }
+  Where-Object { $RelevantExtensions -contains $_.Extension } |
+  ForEach-Object {
+    $FileName = $_.FullName
+    if ($FileName -Match '\\ref\\') {
+      Write-Host "`t Ignoring reference assembly file " $FileName
+      return
+    }
 
-      $FirstMatchingSymbolDescriptionOrDefault = {
+    $FirstMatchingSymbolDescriptionOrDefault = {
       param( 
-        [string] $FullPath,                  # Full path to the module that has to be checked
-        [string] $TargetServerParam,         # Parameter to pass to `Symbol Tool` indicating the server to lookup for symbols
+        [string] $FullPath, # Full path to the module that has to be checked
+        [string] $TargetServerParam, # Parameter to pass to `Symbol Tool` indicating the server to lookup for symbols
+        [string] $WindowsPdbVerificationParam, # Parameter to pass to potential check for windows-pdbs.
         [string] $SymbolsPath
       )
 
@@ -87,56 +107,76 @@ $CountMissingSymbols = {
 
       # DWARF file for a .dylib
       $DylibDwarf = $SymbolPath.Replace($Extension, '.dylib.dwarf')
-    
+
       $dotnetSymbolExe = "$env:USERPROFILE\.dotnet\tools"
       $dotnetSymbolExe = Resolve-Path "$dotnetSymbolExe\dotnet-symbol.exe"
 
-      & $dotnetSymbolExe --symbols --modules --windows-pdbs $TargetServerParam $FullPath -o $SymbolsPath | Out-Null
+      $totalRetries = 0
 
-      if (Test-Path $PdbPath) {
-        return 'PDB'
-      }
-      elseif (Test-Path $NGenPdb) {
-        return 'NGen PDB'
-      }
-      elseif (Test-Path $SODbg) {
-        return 'DBG for SO'
-      }  
-      elseif (Test-Path $DylibDwarf) {
-        return 'Dwarf for Dylib'
-      }  
-      elseif (Test-Path $SymbolPath) {
-        return 'Module'
-      }
-      else {
-        return $null
+      while ($totalRetries -lt $using:MaxRetry) {
+
+        # Save the output and get diagnostic output
+        $output = & $dotnetSymbolExe --symbols --modules $WindowsPdbVerificationParam $TargetServerParam $FullPath -o $SymbolsPath --diagnostics | Out-String
+
+        if (Test-Path $PdbPath) {
+          return 'PDB'
+        }
+        elseif (Test-Path $NGenPdb) {
+          return 'NGen PDB'
+        }
+        elseif (Test-Path $SODbg) {
+          return 'DBG for SO'
+        }  
+        elseif (Test-Path $DylibDwarf) {
+          return 'Dwarf for Dylib'
+        }  
+        elseif (Test-Path $SymbolPath) {
+          return 'Module'
+        }
+        else
+        {
+          $totalRetries++
+        }
       }
+      
+      return $null
     }
 
-      $SymbolsOnMSDL = & $FirstMatchingSymbolDescriptionOrDefault $FileName '--microsoft-symbol-server' $SymbolsPath
-      $SymbolsOnSymWeb = & $FirstMatchingSymbolDescriptionOrDefault $FileName '--internal-server' $SymbolsPath
-
-      Write-Host -NoNewLine "`t Checking file " $FileName "... "
+    $FileGuid = New-Guid
+    $ExpandedSymbolsPath = Join-Path -Path $SymbolsPath -ChildPath $FileGuid
+
+    $SymbolsOnMSDL = & $FirstMatchingSymbolDescriptionOrDefault `
+        -FullPath $FileName `
+        -TargetServerParam '--microsoft-symbol-server' `
+        -SymbolsPath "$ExpandedSymbolsPath-msdl" `
+        -WindowsPdbVerificationParam $WindowsPdbVerificationParam
+    $SymbolsOnSymWeb = & $FirstMatchingSymbolDescriptionOrDefault `
+        -FullPath $FileName `
+        -TargetServerParam '--internal-server' `
+        -SymbolsPath "$ExpandedSymbolsPath-symweb" `
+        -WindowsPdbVerificationParam $WindowsPdbVerificationParam
+
+    Write-Host -NoNewLine "`t Checking file " $FileName "... "
   
-      if ($SymbolsOnMSDL -ne $null -and $SymbolsOnSymWeb -ne $null) {
-        Write-Host "Symbols found on MSDL ($SymbolsOnMSDL) and SymWeb ($SymbolsOnSymWeb)"
+    if ($SymbolsOnMSDL -ne $null -and $SymbolsOnSymWeb -ne $null) {
+      Write-Host "Symbols found on MSDL ($SymbolsOnMSDL) and SymWeb ($SymbolsOnSymWeb)"
+    }
+    else {
+      $MissingSymbols++
+
+      if ($SymbolsOnMSDL -eq $null -and $SymbolsOnSymWeb -eq $null) {
+        Write-Host 'No symbols found on MSDL or SymWeb!'
       }
       else {
-        $MissingSymbols++
-
-        if ($SymbolsOnMSDL -eq $null -and $SymbolsOnSymWeb -eq $null) {
-          Write-Host 'No symbols found on MSDL or SymWeb!'
+        if ($SymbolsOnMSDL -eq $null) {
+          Write-Host 'No symbols found on MSDL!'
         }
         else {
-          if ($SymbolsOnMSDL -eq $null) {
-            Write-Host 'No symbols found on MSDL!'
-          }
-          else {
-            Write-Host 'No symbols found on SymWeb!'
-          }
+          Write-Host 'No symbols found on SymWeb!'
         }
       }
     }
+  }
   
   if ($using:Clean) {
     Remove-Item $ExtractPath -Recurse -Force
@@ -145,24 +185,31 @@ $CountMissingSymbols = {
   Pop-Location
 
   return [pscustomobject]@{
-      result = $MissingSymbols
-      packagePath = $PackagePath
-    }
+    result      = $MissingSymbols
+    packagePath = $PackagePath
+  }
 }
 
 function CheckJobResult(
-    $result, 
-    $packagePath,
-    [ref]$DupedSymbols,
-    [ref]$TotalFailures) {
-  if ($result -eq '-1') {
+  $result, 
+  $packagePath,
+  [ref]$DupedSymbols,
+  [ref]$TotalFailures) {
+  if ($result -eq $ERROR_BADEXTRACT) {
     Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "$packagePath has duplicated symbol files"
     $DupedSymbols.Value++
   } 
-  elseif ($jobResult.result -ne '0') {
+  elseif ($result -eq $ERROR_FILEDOESNOTEXIST) {
+    Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "$packagePath does not exist"
+    $TotalFailures.Value++
+  }
+  elseif ($result -gt '0') {
     Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "Missing symbols for $result modules in the package $packagePath"
     $TotalFailures.Value++
   }
+  else {
+    Write-Host "All symbols verified for package $packagePath"
+  }
 }
 
 function CheckSymbolsAvailable {
@@ -170,6 +217,7 @@ function CheckSymbolsAvailable {
     Remove-Item $ExtractPath -Force  -Recurse -ErrorAction SilentlyContinue
   }
 
+  $TotalPackages = 0
   $TotalFailures = 0
   $DupedSymbols = 0
 
@@ -192,9 +240,9 @@ function CheckSymbolsAvailable {
         return
       }
 
-      Write-Host "Validating $FileName "
+      $TotalPackages++
 
-      Start-Job -ScriptBlock $CountMissingSymbols -ArgumentList $FullName | Out-Null
+      Start-Job -ScriptBlock $CountMissingSymbols -ArgumentList @($FullName,$WindowsPdbVerificationParam) | Out-Null
 
       $NumJobs = @(Get-Job -State 'Running').Count
 
@@ -219,11 +267,11 @@ function CheckSymbolsAvailable {
 
   if ($TotalFailures -gt 0 -or $DupedSymbols -gt 0) {
     if ($TotalFailures -gt 0) {
-      Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "Symbols missing for $TotalFailures packages"
+      Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "Symbols missing for $TotalFailures/$TotalPackages packages"
     }
 
     if ($DupedSymbols -gt 0) {
-      Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "$DupedSymbols packages had duplicated symbol files"
+      Write-PipelineTelemetryError -Category 'CheckSymbols' -Message "$DupedSymbols/$TotalPackages packages had duplicated symbol files and could not be extracted"
     }
     
     ExitWithExitCode 1
diff --git a/eng/common/sdk-task.ps1 b/eng/common/sdk-task.ps1
index f55c43c6f47..65f1d75f3d3 100644
--- a/eng/common/sdk-task.ps1
+++ b/eng/common/sdk-task.ps1
@@ -53,7 +53,7 @@ try {
   }
 
   if ($task -eq "") {
-    Write-PipelineTelemetryError -Category 'Build' -Message "Missing required parameter '-task <value>'" -ForegroundColor Red
+    Write-PipelineTelemetryError -Category 'Build' -Message "Missing required parameter '-task <value>'"
     Print-Usage
     ExitWithExitCode 1
   }
@@ -78,7 +78,7 @@ try {
 
   $taskProject = GetSdkTaskProject $task
   if (!(Test-Path $taskProject)) {
-    Write-PipelineTelemetryError -Category 'Build' -Message "Unknown task: $task" -ForegroundColor Red
+    Write-PipelineTelemetryError -Category 'Build' -Message "Unknown task: $task"
     ExitWithExitCode 1
   }
 
diff --git a/eng/common/sdl/execute-all-sdl-tools.ps1 b/eng/common/sdl/execute-all-sdl-tools.ps1
index b681d797cda..81b729f74a4 100644
--- a/eng/common/sdl/execute-all-sdl-tools.ps1
+++ b/eng/common/sdl/execute-all-sdl-tools.ps1
@@ -87,10 +87,6 @@ try {
     & $(Join-Path $PSScriptRoot 'run-sdl.ps1') -GuardianCliLocation $guardianCliLocation -WorkingDirectory $workingDirectory -TargetDirectory $SourceDirectory -GdnFolder $gdnFolder -ToolsList $SourceToolsList -AzureDevOpsAccessToken $AzureDevOpsAccessToken -UpdateBaseline $UpdateBaseline -GuardianLoggerLevel $GuardianLoggerLevel -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams
   }
 
-  if ($UpdateBaseline) {
-    & (Join-Path $PSScriptRoot 'push-gdn.ps1') -Repository $RepoName -BranchName $BranchName -GdnFolder $GdnFolder -AzureDevOpsAccessToken $AzureDevOpsAccessToken -PushReason 'Update baseline'
-  }
-
   if ($TsaPublish) {
     if ($TsaBranchName -and $BuildNumber) {
       if (-not $TsaRepositoryName) {
diff --git a/eng/common/sdl/init-sdl.ps1 b/eng/common/sdl/init-sdl.ps1
index bb6a4297110..1fe9271193c 100644
--- a/eng/common/sdl/init-sdl.ps1
+++ b/eng/common/sdl/init-sdl.ps1
@@ -46,7 +46,6 @@ try {
     Write-PipelineTelemetryError -Force -Category 'Build' -Message "Guardian baseline failed with exit code $LASTEXITCODE."
     ExitWithExitCode $LASTEXITCODE
   }
-  & $(Join-Path $PSScriptRoot 'push-gdn.ps1') -Repository $Repository -BranchName $BranchName -GdnFolder $gdnFolder -AzureDevOpsAccessToken $AzureDevOpsAccessToken -PushReason 'Initialize gdn folder'
   ExitWithExitCode 0
 }
 catch {
diff --git a/eng/common/sdl/push-gdn.ps1 b/eng/common/sdl/push-gdn.ps1
deleted file mode 100644
index d8fd2d82a68..00000000000
--- a/eng/common/sdl/push-gdn.ps1
+++ /dev/null
@@ -1,69 +0,0 @@
-Param(
-  [string] $Repository,
-  [string] $BranchName='master',
-  [string] $GdnFolder,
-  [string] $AzureDevOpsAccessToken,
-  [string] $PushReason
-)
-
-$ErrorActionPreference = 'Stop'
-Set-StrictMode -Version 2.0
-$disableConfigureToolsetImport = $true
-$LASTEXITCODE = 0
-
-try {
-  # `tools.ps1` checks $ci to perform some actions. Since the SDL
-  # scripts don't necessarily execute in the same agent that run the
-  # build.ps1/sh script this variable isn't automatically set.
-  $ci = $true
-  . $PSScriptRoot\..\tools.ps1
-
-  # We create the temp directory where we'll store the sdl-config repository
-  $sdlDir = Join-Path $env:TEMP 'sdl'
-  if (Test-Path $sdlDir) {
-    Remove-Item -Force -Recurse $sdlDir
-  }
-
-  Write-Host "git clone https://dnceng:`$AzureDevOpsAccessToken@dev.azure.com/dnceng/internal/_git/sdl-tool-cfg $sdlDir"
-  git clone https://dnceng:$AzureDevOpsAccessToken@dev.azure.com/dnceng/internal/_git/sdl-tool-cfg $sdlDir
-  if ($LASTEXITCODE -ne 0) {
-    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Git clone failed with exit code $LASTEXITCODE."
-    ExitWithExitCode $LASTEXITCODE
-  }
-  # We copy the .gdn folder from our local run into the git repository so it can be committed
-  $sdlRepositoryFolder = Join-Path (Join-Path (Join-Path $sdlDir $Repository) $BranchName) '.gdn'
-  if (Get-Command Robocopy) {
-    Robocopy /S $GdnFolder $sdlRepositoryFolder
-  } else {
-    rsync -r $GdnFolder $sdlRepositoryFolder
-  }
-  # cd to the sdl-config directory so we can run git there
-  Push-Location $sdlDir
-  # git add . --> git commit --> git push
-  Write-Host 'git add .'
-  git add .
-  if ($LASTEXITCODE -ne 0) {
-    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Git add failed with exit code $LASTEXITCODE."
-    ExitWithExitCode $LASTEXITCODE
-  }
-  Write-Host "git -c user.email=`"dn-bot@microsoft.com`" -c user.name=`"Dotnet Bot`" commit -m `"$PushReason for $Repository/$BranchName`""
-  git -c user.email="dn-bot@microsoft.com" -c user.name="Dotnet Bot" commit -m "$PushReason for $Repository/$BranchName"
-  if ($LASTEXITCODE -ne 0) {
-    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Git commit failed with exit code $LASTEXITCODE."
-    ExitWithExitCode $LASTEXITCODE
-  }
-  Write-Host 'git push'
-  git push
-  if ($LASTEXITCODE -ne 0) {
-    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Git push failed with exit code $LASTEXITCODE."
-    ExitWithExitCode $LASTEXITCODE
-  }
-
-  # Return to the original directory
-  Pop-Location
-}
-catch {
-  Write-Host $_.ScriptStackTrace
-  Write-PipelineTelemetryError -Category 'Sdl' -Message $_
-  ExitWithExitCode 1
-}
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index 53c100222b2..4a32181fd8f 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -45,6 +45,7 @@ jobs:
             buildId: $(AzDOBuildId)
             artifactName: ${{ artifactName }}
             downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
+            checkDownloadedFiles: true
     - ${{ if eq(parameters.artifactNames, '') }}:
       - task: DownloadBuildArtifacts@0
         displayName: Download Build Artifacts
@@ -57,6 +58,7 @@ jobs:
           downloadType: specific files
           itemPattern: "**"
           downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
+          checkDownloadedFiles: true
   - powershell: eng/common/sdl/extract-artifact-packages.ps1
       -InputPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
       -ExtractPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index 8b81a7e5143..86696793480 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -24,9 +24,9 @@ parameters:
   enablePublishBuildAssets: false
   enablePublishTestResults: false
   enablePublishUsingPipelines: false
-  useBuildManifest: false
   mergeTestResults: false
   testRunTitle: ''
+  testResultsFormat: ''
   name: ''
   preSteps: []
   runAsPublic: false
@@ -131,8 +131,8 @@ jobs:
     - task: RichCodeNavIndexer@0
       displayName: RichCodeNav Upload
       inputs:
-        languages: 'csharp'
-        environment: ${{ coalesce(parameters.richCodeNavigationEnvironment, 'prod') }}
+        languages: ${{ coalesce(parameters.richCodeNavigationLanguage, 'csharp') }}
+        environment: ${{ coalesce(parameters.richCodeNavigationEnvironment, 'production') }}
         richNavLogOutputDirectory: $(Build.SourcesDirectory)/artifacts/bin
       continueOnError: true
 
@@ -202,7 +202,7 @@ jobs:
       continueOnError: true
       condition: always()
 
-  - ${{ if eq(parameters.enablePublishTestResults, 'true') }}:
+  - ${{ if or(and(eq(parameters.enablePublishTestResults, 'true'), eq(parameters.testResultsFormat, '')), eq(parameters.testResultsFormat, 'xunit')) }}:
     - task: PublishTestResults@2
       displayName: Publish XUnit Test Results
       inputs:
@@ -213,6 +213,7 @@ jobs:
         mergeTestResults: ${{ parameters.mergeTestResults }}
       continueOnError: true
       condition: always()
+  - ${{ if or(and(eq(parameters.enablePublishTestResults, 'true'), eq(parameters.testResultsFormat, '')), eq(parameters.testResultsFormat, 'vstest')) }}:
     - task: PublishTestResults@2
       displayName: Publish TRX Test Results
       inputs:
@@ -241,12 +242,3 @@ jobs:
         ArtifactName: AssetManifests
       continueOnError: ${{ parameters.continueOnError }}
       condition: and(succeeded(), eq(variables['_DotNetPublishToBlobFeed'], 'true'))
-
-  - ${{ if eq(parameters.useBuildManifest, true) }}:
-    - task: PublishBuildArtifacts@1
-      displayName: Publish Build Manifest
-      inputs:
-        PathToPublish: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/manifest.props'
-        PublishLocation: Container
-        ArtifactName: BuildManifests
-      continueOnError: ${{ parameters.continueOnError }}
diff --git a/eng/common/templates/job/onelocbuild.yml b/eng/common/templates/job/onelocbuild.yml
index b27d6faf303..2acdd5256dd 100644
--- a/eng/common/templates/job/onelocbuild.yml
+++ b/eng/common/templates/job/onelocbuild.yml
@@ -12,6 +12,7 @@ parameters:
   SourcesDirectory: $(Build.SourcesDirectory)
   CreatePr: true
   AutoCompletePr: false
+  UseLfLineEndings: true
   UseCheckedInLocProjectJson: false
   LanguageSet: VS_Main_Languages
   LclSource: lclFilesInRepo
@@ -52,13 +53,14 @@ jobs:
       env:
         SYSTEM_ACCESSTOKEN: $(System.AccessToken)
       inputs:
-        locProj: Localize/LocProject.json
+        locProj: eng/Localize/LocProject.json
         outDir: $(Build.ArtifactStagingDirectory)
         lclSource: ${{ parameters.LclSource }}
         lclPackageId: ${{ parameters.LclPackageId }}
         isCreatePrSelected: ${{ parameters.CreatePr }}
         ${{ if eq(parameters.CreatePr, true) }}:
           isAutoCompletePrSelected: ${{ parameters.AutoCompletePr }}
+          isUseLfLineEndingsSelected: ${{ parameters.UseLfLineEndings }}
         packageSourceAuth: patAuth
         patVariable: ${{ parameters.CeapexPat }}
         ${{ if eq(parameters.RepoType, 'gitHub') }}:
@@ -77,7 +79,7 @@ jobs:
     - task: PublishBuildArtifacts@1
       displayName: Publish LocProject.json
       inputs:
-        PathtoPublish: '$(Build.SourcesDirectory)/Localize/'
+        PathtoPublish: '$(Build.SourcesDirectory)/eng/Localize/'
         PublishLocation: Container
         ArtifactName: Loc
       condition: ${{ parameters.condition }}
\ No newline at end of file
diff --git a/eng/common/templates/job/performance.yml b/eng/common/templates/job/performance.yml
deleted file mode 100644
index f877fd7a898..00000000000
--- a/eng/common/templates/job/performance.yml
+++ /dev/null
@@ -1,95 +0,0 @@
-parameters:
-  steps: []                       # optional -- any additional steps that need to happen before pulling down the performance repo and sending the performance benchmarks to helix (ie building your repo)
-  variables: []                   # optional -- list of additional variables to send to the template
-  jobName: ''                     # required -- job name
-  displayName: ''                 # optional -- display name for the job. Will use jobName if not passed
-  pool: ''                        # required -- name of the Build pool
-  container: ''                   # required -- name of the container
-  osGroup: ''                     # required -- operating system for the job
-  extraSetupParameters: ''        # optional -- extra arguments to pass to the setup script
-  frameworks: ['netcoreapp3.0']   # optional -- list of frameworks to run against
-  continueOnError: 'false'        # optional -- determines whether to continue the build if the step errors
-  dependsOn: ''                   # optional -- dependencies of the job
-  timeoutInMinutes: 320           # optional -- timeout for the job
-  enableTelemetry: false          # optional -- enable for telemetry
-
-jobs:
-- template: ../jobs/jobs.yml
-  parameters:
-    dependsOn: ${{ parameters.dependsOn }}
-    enableTelemetry: ${{ parameters.enableTelemetry }}
-    enablePublishBuildArtifacts: true
-    continueOnError: ${{ parameters.continueOnError }}
-    
-    jobs:
-      - job: '${{ parameters.jobName }}'
-
-        ${{ if ne(parameters.displayName, '') }}:
-          displayName: '${{ parameters.displayName }}'
-        ${{ if eq(parameters.displayName, '') }}:
-          displayName: '${{ parameters.jobName }}'
-
-        timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
-
-        variables:
-
-        - ${{ each variable in parameters.variables }}:
-          - ${{ if ne(variable.name, '') }}:
-            - name: ${{ variable.name }}
-              value: ${{ variable.value }}
-          - ${{ if ne(variable.group, '') }}:
-            - group: ${{ variable.group }}
-
-        - IsInternal: ''
-        - HelixApiAccessToken: ''
-        - HelixPreCommand: ''
-
-        - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-          - ${{ if eq( parameters.osGroup, 'Windows_NT') }}:
-            - HelixPreCommand: 'set "PERFLAB_UPLOAD_TOKEN=$(PerfCommandUploadToken)"'
-            - IsInternal: -Internal
-          - ${{ if ne(parameters.osGroup, 'Windows_NT') }}:
-            - HelixPreCommand: 'export PERFLAB_UPLOAD_TOKEN="$(PerfCommandUploadTokenLinux)"'
-            - IsInternal: --internal
-            
-          - group: DotNet-HelixApi-Access
-          - group: dotnet-benchview
-
-        workspace:
-          clean: all
-        pool:
-          ${{ parameters.pool }}
-        container: ${{ parameters.container }}
-        strategy:
-          matrix:
-            ${{ each framework in parameters.frameworks }}:
-              ${{ framework }}:
-                _Framework: ${{ framework }}
-        steps:
-        - checkout: self
-          clean: true
-        # Run all of the steps to setup repo
-        - ${{ each step in parameters.steps }}:
-          - ${{ step }}
-        - powershell: $(Build.SourcesDirectory)\eng\common\performance\performance-setup.ps1 $(IsInternal) -Framework $(_Framework) ${{ parameters.extraSetupParameters }}
-          displayName: Performance Setup (Windows)
-          condition: and(succeeded(), eq(variables['Agent.Os'], 'Windows_NT'))
-          continueOnError: ${{ parameters.continueOnError }}
-        - script: $(Build.SourcesDirectory)/eng/common/performance/performance-setup.sh $(IsInternal) --framework $(_Framework) ${{ parameters.extraSetupParameters }}
-          displayName: Performance Setup (Unix)
-          condition: and(succeeded(), ne(variables['Agent.Os'], 'Windows_NT'))
-          continueOnError: ${{ parameters.continueOnError }}
-        - script: $(Python) $(PerformanceDirectory)/scripts/ci_setup.py $(SetupArguments)
-          displayName: Run ci setup script
-        # Run perf testing in helix
-        - template: /eng/common/templates/steps/perf-send-to-helix.yml
-          parameters:
-            HelixSource: '$(HelixSourcePrefix)/$(Build.Repository.Name)/$(Build.SourceBranch)' # sources must start with pr/, official/, prodcon/, or agent/
-            HelixType: 'test/performance/$(Kind)/$(_Framework)/$(Architecture)'
-            HelixAccessToken: $(HelixApiAccessToken)
-            HelixTargetQueues: $(Queue)
-            HelixPreCommands: $(HelixPreCommand)
-            Creator: $(Creator)
-            WorkItemTimeout: 4:00 # 4 hours
-            WorkItemDirectory: '$(WorkItemDirectory)' # WorkItemDirectory can not be empty, so we send it some docs to keep it happy
-            CorrelationPayloadDirectory: '$(PayloadDirectory)' # it gets checked out to a folder with shorter path than WorkItemDirectory so we can avoid file name too long exceptions
\ No newline at end of file
diff --git a/eng/common/templates/job/publish-build-assets.yml b/eng/common/templates/job/publish-build-assets.yml
index d0c3cc2b3ba..3b9e2524ff3 100644
--- a/eng/common/templates/job/publish-build-assets.yml
+++ b/eng/common/templates/job/publish-build-assets.yml
@@ -37,6 +37,7 @@ jobs:
     - name: _BuildConfig
       value: ${{ parameters.configuration }}
     - group: Publish-Build-Assets
+    - group: AzureDevOps-Artifact-Feeds-Pats
     # Skip component governance and codesign validation for SDL. These jobs
     # create no content.
     - name: skipComponentGovernanceDetection
@@ -51,12 +52,19 @@ jobs:
       inputs:
         artifactName: AssetManifests
         downloadPath: '$(Build.StagingDirectory)/Download'
+        checkDownloadedFiles: true
       condition: ${{ parameters.condition }}
       continueOnError: ${{ parameters.continueOnError }}
     
     - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
       - task: NuGetAuthenticate@0
 
+      - task: PowerShell@2 
+        displayName: Enable cross-org NuGet feed authentication 
+        inputs: 
+          filePath: $(Build.SourcesDirectory)/eng/common/enable-cross-org-publishing.ps1 
+          arguments: -token $(dn-bot-all-orgs-artifact-feeds-rw) 
+
     - task: PowerShell@2
       displayName: Publish Build Assets
       inputs:
diff --git a/eng/common/templates/job/source-build.yml b/eng/common/templates/job/source-build.yml
index 9332f5ecc38..5023d36dcb3 100644
--- a/eng/common/templates/job/source-build.yml
+++ b/eng/common/templates/job/source-build.yml
@@ -15,6 +15,9 @@ parameters:
   # nonPortable: false
   #   Enables non-portable mode. This means a more specific RID (e.g. fedora.32-x64 rather than
   #   linux-x64), and compiling against distro-provided packages rather than portable ones.
+  # skipPublishValidation: false
+  #   Disables publishing validation.  By default, a check is performed to ensure no packages are
+  #   published by source-build.
   # container: ''
   #   A container to use. Runs in docker.
   # pool: {}
@@ -28,6 +31,11 @@ parameters:
   #   container and pool.
   platform: {}
 
+  # The default VM host AzDO pool. This should be capable of running Docker containers: almost all
+  # source-build builds run in Docker, including the default managed platform.
+  defaultContainerHostPool:
+    vmImage: ubuntu-20.04
+
 jobs:
 - job: ${{ parameters.jobNamePrefix }}_${{ parameters.platform.name }}
   displayName: Source-Build (${{ parameters.platform.name }})
@@ -37,6 +45,9 @@ jobs:
 
   ${{ if ne(parameters.platform.container, '') }}:
     container: ${{ parameters.platform.container }}
+
+  ${{ if eq(parameters.platform.pool, '') }}:
+    pool: ${{ parameters.defaultContainerHostPool }}
   ${{ if ne(parameters.platform.pool, '') }}:
     pool: ${{ parameters.platform.pool }}
 
diff --git a/eng/common/templates/job/source-index-stage1.yml b/eng/common/templates/job/source-index-stage1.yml
new file mode 100644
index 00000000000..a649d2b5990
--- /dev/null
+++ b/eng/common/templates/job/source-index-stage1.yml
@@ -0,0 +1,58 @@
+parameters:
+  runAsPublic: false
+  sourceIndexPackageVersion: 1.0.1-20210421.1
+  sourceIndexPackageSource: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json
+  sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
+  preSteps: []
+  binlogPath: artifacts/log/Debug/Build.binlog
+  pool:
+    vmImage: vs2017-win2016
+
+jobs:
+- job: SourceIndexStage1
+  variables:
+  - name: SourceIndexPackageVersion
+    value: ${{ parameters.sourceIndexPackageVersion }}
+  - name: SourceIndexPackageSource
+    value: ${{ parameters.sourceIndexPackageSource }}
+  - name: BinlogPath
+    value: ${{ parameters.binlogPath }}
+  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - group: source-dot-net stage1 variables
+
+  pool: ${{ parameters.pool }}
+  steps:
+  - ${{ each preStep in parameters.preSteps }}:
+    - ${{ preStep }}
+
+  - task: UseDotNet@2
+    displayName: Use .NET Core sdk 3.1
+    inputs:
+      packageType: sdk
+      version: 3.1.x
+
+  - task: UseDotNet@2
+    displayName: Use .NET Core sdk
+    inputs:
+      useGlobalJson: true
+
+  - script: |
+      dotnet tool install BinLogToSln --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path .source-index/tools
+      dotnet tool install UploadIndexStage1 --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path .source-index/tools
+      echo ##vso[task.prependpath]$(Build.SourcesDirectory)/.source-index/tools
+    displayName: Download Tools
+
+  - script: ${{ parameters.sourceIndexBuildCommand }}
+    displayName: Build Repository
+
+  - script: BinLogToSln -i $(BinlogPath) -r $(Build.SourcesDirectory) -n $(Build.Repository.Name) -o .source-index/stage1output
+    displayName: Process Binlog into indexable sln
+    env:
+      DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX: 2
+
+  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - script: UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name)
+      displayName: Upload stage1 artifacts to source index
+      env:
+        BLOB_CONTAINER_URL: $(source-dot-net-stage1-blob-container-url)
+        DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX: 2
diff --git a/eng/common/templates/jobs/jobs.yml b/eng/common/templates/jobs/jobs.yml
index 08845950f44..a1f8fce96ca 100644
--- a/eng/common/templates/jobs/jobs.yml
+++ b/eng/common/templates/jobs/jobs.yml
@@ -7,7 +7,14 @@ parameters:
 
   # Optional: Enable publishing using release pipelines
   enablePublishUsingPipelines: false
-  
+
+  # Optional: Enable running the source-build jobs to build repo from source
+  enableSourceBuild: false
+
+  # Optional: Parameters for source-build template.
+  #           See /eng/common/templates/jobs/source-build.yml for options
+  sourceBuildParameters: []
+
   graphFileGeneration:
     # Optional: Enable generating the graph files at the end of the build
     enabled: false
@@ -24,12 +31,8 @@ parameters:
   #           if 'true', the build won't run any of the internal only steps, even if it is running in non-public projects.
   runAsPublic: false
 
-  # Optional: Enable running the source-build jobs to build repo from source
-  runSourceBuild: false
-
-  # Optional: Parameters for source-build template.
-  #           See /eng/common/templates/jobs/source-build.yml for options
-  sourceBuildParameters: []
+  enableSourceIndex: false
+  sourceIndexParams: {}
 
 # Internal resources (telemetry, microbuild) can only be accessed from non-public projects,
 # and some (Microbuild) should only be applied to non-PR cases for internal builds.
@@ -50,14 +53,22 @@ jobs:
 
       name: ${{ job.job }}
 
-- ${{ if eq(parameters.runSourceBuild, true) }}:
+- ${{ if eq(parameters.enableSourceBuild, true) }}:
   - template: /eng/common/templates/jobs/source-build.yml
     parameters:
       allCompletedJobId: Source_Build_Complete
       ${{ each parameter in parameters.sourceBuildParameters }}:
         ${{ parameter.key }}: ${{ parameter.value }}
 
+- ${{ if eq(parameters.enableSourceIndex, 'true') }}:
+  - template: ../job/source-index-stage1.yml
+    parameters:
+      runAsPublic: ${{ parameters.runAsPublic }}
+      ${{ each parameter in parameters.sourceIndexParams }}:
+        ${{ parameter.key }}: ${{ parameter.value }}
+
 - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+  
   - ${{ if or(eq(parameters.enablePublishBuildAssets, true), eq(parameters.artifacts.publish.manifests, 'true'), ne(parameters.artifacts.publish.manifests, '')) }}:
     - template: ../job/publish-build-assets.yml
       parameters:
@@ -69,7 +80,7 @@ jobs:
         - ${{ if eq(parameters.publishBuildAssetsDependsOn, '') }}:
           - ${{ each job in parameters.jobs }}:
             - ${{ job.job }}
-        - ${{ if eq(parameters.runSourceBuild, true) }}:
+        - ${{ if eq(parameters.enableSourceBuild, true) }}:
           - Source_Build_Complete
         pool:
           vmImage: vs2017-win2016
diff --git a/eng/common/templates/jobs/source-build.yml b/eng/common/templates/jobs/source-build.yml
index f463011e793..00aa98eb3bf 100644
--- a/eng/common/templates/jobs/source-build.yml
+++ b/eng/common/templates/jobs/source-build.yml
@@ -11,16 +11,14 @@ parameters:
   # See /eng/common/templates/job/source-build.yml
   jobNamePrefix: 'Source_Build'
 
-  # If changed to true, causes this template to include the default platform for a managed-only
-  # repo. The exact Docker image used for this build will be provided by Arcade. This has some risk,
-  # but since the repo is supposed to be managed-only, the risk should be very low.
-  includeDefaultManagedPlatform: false
+  # This is the default platform provided by Arcade, intended for use by a managed-only repo.
   defaultManagedPlatform:
     name: 'Managed'
     container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7-3e800f1-20190501005343'
 
   # Defines the platforms on which to run build jobs. One job is created for each platform, and the
-  # object in this array is sent to the job template as 'platform'.
+  # object in this array is sent to the job template as 'platform'. If no platforms are specified,
+  # one job runs on 'defaultManagedPlatform'.
   platforms: []
 
 jobs:
@@ -32,7 +30,7 @@ jobs:
     dependsOn:
     - ${{ each platform in parameters.platforms }}:
       - ${{ parameters.jobNamePrefix }}_${{ platform.name }}
-    - ${{ if eq(parameters.includeDefaultManagedPlatform, true) }}:
+    - ${{ if eq(length(parameters.platforms), 0) }}:
       - ${{ parameters.jobNamePrefix }}_${{ parameters.defaultManagedPlatform.name }}
 
 - ${{ each platform in parameters.platforms }}:
@@ -41,7 +39,7 @@ jobs:
       jobNamePrefix: ${{ parameters.jobNamePrefix }}
       platform: ${{ platform }}
 
-- ${{ if eq(parameters.includeDefaultManagedPlatform, true) }}:
+- ${{ if eq(length(parameters.platforms), 0) }}:
   - template: /eng/common/templates/job/source-build.yml
     parameters:
       jobNamePrefix: ${{ parameters.jobNamePrefix }}
diff --git a/eng/common/templates/phases/publish-build-assets.yml b/eng/common/templates/phases/publish-build-assets.yml
index a0a8074282a..4e51e472e2b 100644
--- a/eng/common/templates/phases/publish-build-assets.yml
+++ b/eng/common/templates/phases/publish-build-assets.yml
@@ -20,6 +20,7 @@ phases:
           inputs:
             artifactName: AssetManifests
             downloadPath: '$(Build.StagingDirectory)/Download'
+            checkDownloadedFiles: true
           condition: ${{ parameters.condition }}
           continueOnError: ${{ parameters.continueOnError }}
         - task: AzureKeyVault@1
diff --git a/eng/common/templates/post-build/channels/generic-internal-channel.yml b/eng/common/templates/post-build/channels/generic-internal-channel.yml
index 7ae5255921a..8990dfc8c87 100644
--- a/eng/common/templates/post-build/channels/generic-internal-channel.yml
+++ b/eng/common/templates/post-build/channels/generic-internal-channel.yml
@@ -40,6 +40,9 @@ stages:
     pool:
       vmImage: 'windows-2019'
     steps:
+      - script: echo "##vso[task.logissue type=warning]Going forward, v2 Arcade publishing is no longer supported. Please read https://github.com/dotnet/arcade/blob/main/Documentation/CorePackages/Publishing.md for details, then contact dnceng if you have further questions."
+        displayName: Warn about v2 Arcade Publishing Usage
+
       # This is necessary whenever we want to publish/restore to an AzDO private feed
       - task: NuGetAuthenticate@0
         displayName: 'Authenticate to AzDO Feeds'
@@ -58,6 +61,7 @@ stages:
             PdbArtifacts/**
             BlobArtifacts/**
           downloadPath: '$(Build.ArtifactStagingDirectory)'
+          checkDownloadedFiles: true
 
       # This is necessary whenever we want to publish/restore to an AzDO private feed
       # Since sdk-task.ps1 tries to restore packages we need to do this authentication here
@@ -109,6 +113,9 @@ stages:
     pool:
       vmImage: 'windows-2019'
     steps:
+      - script: echo "##vso[task.logissue type=warning]Going forward, v2 Arcade publishing is no longer supported. Please read https://github.com/dotnet/arcade/blob/main/Documentation/CorePackages/Publishing.md for details, then contact dnceng if you have further questions."
+        displayName: Warn about v2 Arcade Publishing Usage
+
       - task: DownloadBuildArtifacts@0
         displayName: Download Build Assets
         continueOnError: true
@@ -124,6 +131,7 @@ stages:
             BlobArtifacts/**
             AssetManifests/**
           downloadPath: '$(Build.ArtifactStagingDirectory)'
+          checkDownloadedFiles: true
 
       - task: NuGetToolInstaller@1
         displayName: 'Install NuGet.exe'
diff --git a/eng/common/templates/post-build/channels/generic-public-channel.yml b/eng/common/templates/post-build/channels/generic-public-channel.yml
index 6cf39dbb290..3220c6a4f92 100644
--- a/eng/common/templates/post-build/channels/generic-public-channel.yml
+++ b/eng/common/templates/post-build/channels/generic-public-channel.yml
@@ -42,6 +42,9 @@ stages:
     pool:
       vmImage: 'windows-2019'
     steps:
+      - script: echo "##vso[task.logissue type=warning]Going forward, v2 Arcade publishing is no longer supported. Please read https://github.com/dotnet/arcade/blob/main/Documentation/CorePackages/Publishing.md for details, then contact dnceng if you have further questions."
+        displayName: Warn about v2 Arcade Publishing Usage
+
       - task: DownloadBuildArtifacts@0
         displayName: Download Build Assets
         continueOnError: true
@@ -56,6 +59,7 @@ stages:
             PdbArtifacts/**
             BlobArtifacts/**
           downloadPath: '$(Build.ArtifactStagingDirectory)'
+          checkDownloadedFiles: true
 
       # This is necessary whenever we want to publish/restore to an AzDO private feed
       # Since sdk-task.ps1 tries to restore packages we need to do this authentication here
@@ -108,6 +112,9 @@ stages:
     pool:
       vmImage: 'windows-2019'
     steps:
+      - script: echo "##vso[task.logissue type=warning]Going forward, v2 Arcade publishing is no longer supported. Please read https://github.com/dotnet/arcade/blob/main/Documentation/CorePackages/Publishing.md for details, then contact dnceng if you have further questions."
+        displayName: Warn about v2 Arcade Publishing Usage
+
       - task: DownloadBuildArtifacts@0
         displayName: Download Build Assets
         continueOnError: true
@@ -123,6 +130,7 @@ stages:
             BlobArtifacts/**
             AssetManifests/**
           downloadPath: '$(Build.ArtifactStagingDirectory)'
+          checkDownloadedFiles: true
 
       - task: NuGetToolInstaller@1
         displayName: 'Install NuGet.exe'
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index 1b0af40d52f..4f79cf0f337 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -32,7 +32,6 @@ parameters:
   symbolPublishingAdditionalParameters: ''
   artifactsPublishingAdditionalParameters: ''
   signingValidationAdditionalParameters: ''
-  useBuildManifest: false
 
   # Which stages should finish execution before post-build stages start
   validateDependsOn:
@@ -54,9 +53,6 @@ parameters:
   NETCoreExperimentalChannelId: 562
   NetEngServicesIntChannelId: 678
   NetEngServicesProdChannelId: 679
-  Net5Preview8ChannelId: 1155
-  Net5RC1ChannelId: 1157
-  Net5RC2ChannelId: 1329
   NetCoreSDK313xxChannelId: 759
   NetCoreSDK313xxInternalChannelId: 760
   NetCoreSDK314xxChannelId: 921
@@ -96,7 +92,8 @@ stages:
             inputs:
               filePath: $(Build.SourcesDirectory)/eng/common/post-build/check-channel-consistency.ps1
               arguments: -PromoteToChannels "$(TargetChannels)"
-                -AvailableChannelIds ${{parameters.NetEngLatestChannelId}},${{parameters.NetEngValidationChannelId}},${{parameters.NetDev5ChannelId}},${{parameters.NetDev6ChannelId}},${{parameters.GeneralTestingChannelId}},${{parameters.NETCoreToolingDevChannelId}},${{parameters.NETCoreToolingReleaseChannelId}},${{parameters.NETInternalToolingChannelId}},${{parameters.NETCoreExperimentalChannelId}},${{parameters.NetEngServicesIntChannelId}},${{parameters.NetEngServicesProdChannelId}},${{parameters.Net5Preview8ChannelId}},${{parameters.Net5RC1ChannelId}},${{parameters.Net5RC2ChannelId}},${{parameters.NetCoreSDK313xxChannelId}},${{parameters.NetCoreSDK313xxInternalChannelId}},${{parameters.NetCoreSDK314xxChannelId}},${{parameters.NetCoreSDK314xxInternalChannelId}},${{parameters.VS166ChannelId}},${{parameters.VS167ChannelId}},${{parameters.VS168ChannelId}},${{parameters.VSMasterChannelId}},${{parameters.VS169ChannelId}},${{parameters.VS1610ChannelId}}                
+                -AvailableChannelIds ${{parameters.NetEngLatestChannelId}},${{parameters.NetEngValidationChannelId}},${{parameters.NetDev5ChannelId}},${{parameters.NetDev6ChannelId}},${{parameters.GeneralTestingChannelId}},${{parameters.NETCoreToolingDevChannelId}},${{parameters.NETCoreToolingReleaseChannelId}},${{parameters.NETInternalToolingChannelId}},${{parameters.NETCoreExperimentalChannelId}},${{parameters.NetEngServicesIntChannelId}},${{parameters.NetEngServicesProdChannelId}},${{parameters.NetCoreSDK313xxChannelId}},${{parameters.NetCoreSDK313xxInternalChannelId}},${{parameters.NetCoreSDK314xxChannelId}},${{parameters.NetCoreSDK314xxInternalChannelId}},${{parameters.VS166ChannelId}},${{parameters.VS167ChannelId}},${{parameters.VS168ChannelId}},${{parameters.VSMasterChannelId}},${{parameters.VS169ChannelId}},${{parameters.VS1610ChannelId}}
+
     - job:
       displayName: NuGet Validation
       dependsOn: setupMaestroVars
@@ -120,6 +117,7 @@ stages:
             pipeline: $(AzDOPipelineId)
             buildId: $(AzDOBuildId)
             artifactName: PackageArtifacts
+            checkDownloadedFiles: true
 
         - task: PowerShell@2
           displayName: Validate
@@ -131,7 +129,7 @@ stages:
     - job:
       displayName: Signing Validation
       dependsOn: setupMaestroVars
-      condition: eq( ${{ parameters.enableSigningValidation }}, 'true')
+      condition: and( eq( ${{ parameters.enableSigningValidation }}, 'true'), ne( variables['PostBuildSign'], 'true'))
       variables:
         - template: common-variables.yml
         - name: AzDOProjectName
@@ -143,16 +141,6 @@ stages:
       pool:
         vmImage: 'windows-2019'
       steps:
-        - ${{ if eq(parameters.useBuildManifest, true) }}:
-          - task: DownloadBuildArtifacts@0
-            displayName: Download build manifest
-            inputs:
-              buildType: specific
-              buildVersionToDownload: specific
-              project: $(AzDOProjectName)
-              pipeline: $(AzDOPipelineId)
-              buildId: $(AzDOBuildId)
-              artifactName: BuildManifests
         - task: DownloadBuildArtifacts@0
           displayName: Download Package Artifacts
           inputs:
@@ -162,6 +150,10 @@ stages:
             pipeline: $(AzDOPipelineId)
             buildId: $(AzDOBuildId)
             artifactName: PackageArtifacts
+            checkDownloadedFiles: true
+            itemPattern: |
+              **
+              !**/Microsoft.SourceBuild.Intermediate.*.nupkg
 
         # This is necessary whenever we want to publish/restore to an AzDO private feed
         # Since sdk-task.ps1 tries to restore packages we need to do this authentication here
@@ -215,6 +207,7 @@ stages:
             pipeline: $(AzDOPipelineId)
             buildId: $(AzDOBuildId)
             artifactName: BlobArtifacts
+            checkDownloadedFiles: true
 
         - task: PowerShell@2
           displayName: Validate
@@ -239,7 +232,7 @@ stages:
 - ${{ if or(ge(parameters.publishingInfraVersion, 3), eq(parameters.inline, 'false')) }}:
   - stage: publish_using_darc
     ${{ if or(eq(parameters.enableNugetValidation, 'true'), eq(parameters.enableSigningValidation, 'true'), eq(parameters.enableSourceLinkValidation, 'true'), eq(parameters.SDLValidationParameters.enable, 'true')) }}:
-      dependsOn: Validate
+      dependsOn: ${{ parameters.publishDependsOn }}
     ${{ if and(ne(parameters.enableNugetValidation, 'true'), ne(parameters.enableSigningValidation, 'true'), ne(parameters.enableSourceLinkValidation, 'true'), ne(parameters.SDLValidationParameters.enable, 'true')) }}:
       dependsOn: ${{ parameters.validateDependsOn }}
     displayName: Publish using Darc
@@ -254,6 +247,7 @@ stages:
     - job:
       displayName: Publish Using Darc
       dependsOn: setupMaestroVars
+      timeoutInMinutes: 120
       variables:
         - name: BARBuildId
           value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.BARBuildId'] ]
@@ -270,6 +264,8 @@ stages:
               -MaestroToken '$(MaestroApiAccessToken)'
               -WaitPublishingFinish ${{ parameters.waitPublishingFinish }}
               -PublishInstallersAndChecksums ${{ parameters.publishInstallersAndChecksums }}
+              -ArtifactsPublishingAdditionalParameters '${{ parameters.artifactsPublishingAdditionalParameters }}'
+              -SymbolPublishingAdditionalParameters '${{ parameters.symbolPublishingAdditionalParameters }}'
 
 - ${{ if and(le(parameters.publishingInfraVersion, 2), eq(parameters.inline, 'true')) }}:
   - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
@@ -304,54 +300,6 @@ stages:
       shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json'
       symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6-symbols/nuget/v3/index.json'
 
-  - template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
-    parameters:
-      BARBuildId: ${{ parameters.BARBuildId }}
-      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}    
-      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-      dependsOn: ${{ parameters.publishDependsOn }}
-      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-      stageName: 'Net5_Preview8_Publish'
-      channelName: '.NET 5 Preview 8'
-      akaMSChannelName: 'net5/preview8'
-      channelId: ${{ parameters.Net5Preview8ChannelId }}
-      transportFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-transport/nuget/v3/index.json'
-      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal/nuget/v3/index.json'
-      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-symbols/nuget/v3/index.json'
-
-  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-    parameters:
-      BARBuildId: ${{ parameters.BARBuildId }}
-      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
-      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-      dependsOn: ${{ parameters.publishDependsOn }}
-      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-      stageName: 'Net5_RC1_Publish'
-      channelName: '.NET 5 RC 1'
-      akaMSChannelName: 'net5/rc1'
-      channelId: ${{ parameters.Net5RC1ChannelId }}
-      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-transport/nuget/v3/index.json'
-      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json'
-      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-symbols/nuget/v3/index.json'
-
-  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
-    parameters:
-      BARBuildId: ${{ parameters.BARBuildId }}
-      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
-      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
-      dependsOn: ${{ parameters.publishDependsOn }}
-      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
-      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
-      stageName: 'Net5_RC2_Publish'
-      channelName: '.NET 5 RC 2'
-      akaMSChannelName: 'net5/rc2'
-      channelId: ${{ parameters.Net5RC2ChannelId }}
-      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-transport/nuget/v3/index.json'
-      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json'
-      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5-symbols/nuget/v3/index.json'
-
   - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
     parameters:
       BARBuildId: ${{ parameters.BARBuildId }}
diff --git a/eng/common/templates/post-build/setup-maestro-vars.yml b/eng/common/templates/post-build/setup-maestro-vars.yml
index d0cbfb6c6ff..4a22b2e6f6d 100644
--- a/eng/common/templates/post-build/setup-maestro-vars.yml
+++ b/eng/common/templates/post-build/setup-maestro-vars.yml
@@ -18,6 +18,7 @@ jobs:
         inputs:
           buildType: current
           artifactName: ReleaseConfigs
+          checkDownloadedFiles: true
 
     - task: PowerShell@2
       name: setReleaseVars
diff --git a/eng/common/templates/steps/perf-send-to-helix.yml b/eng/common/templates/steps/perf-send-to-helix.yml
deleted file mode 100644
index a468e92ce44..00000000000
--- a/eng/common/templates/steps/perf-send-to-helix.yml
+++ /dev/null
@@ -1,50 +0,0 @@
-# Please remember to update the documentation if you make changes to these parameters!
-parameters:
-  ProjectFile: ''                        # required -- project file that specifies the helix workitems
-  HelixSource: 'pr/default'              # required -- sources must start with pr/, official/, prodcon/, or agent/
-  HelixType: 'tests/default/'            # required -- Helix telemetry which identifies what type of data this is; should include "test" for clarity and must end in '/'
-  HelixBuild: $(Build.BuildNumber)       # required -- the build number Helix will use to identify this -- automatically set to the AzDO build number
-  HelixTargetQueues: ''                  # required -- semicolon delimited list of Helix queues to test on; see https://helix.dot.net/ for a list of queues
-  HelixAccessToken: ''                   # required -- access token to make Helix API requests; should be provided by the appropriate variable group
-  HelixPreCommands: ''                   # optional -- commands to run before Helix work item execution
-  HelixPostCommands: ''                  # optional -- commands to run after Helix work item execution
-  WorkItemDirectory: ''                  # optional -- a payload directory to zip up and send to Helix; requires WorkItemCommand; incompatible with XUnitProjects
-  CorrelationPayloadDirectory: ''        # optional -- a directory to zip up and send to Helix as a correlation payload
-  IncludeDotNetCli: false                # optional -- true will download a version of the .NET CLI onto the Helix machine as a correlation payload; requires DotNetCliPackageType and DotNetCliVersion
-  DotNetCliPackageType: ''               # optional -- either 'sdk', 'runtime' or 'aspnetcore-runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
-  DotNetCliVersion: ''                   # optional -- version of the CLI to send to Helix; based on this: https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases.json
-  EnableXUnitReporter: false             # optional -- true enables XUnit result reporting to Mission Control
-  WaitForWorkItemCompletion: true        # optional -- true will make the task wait until work items have been completed and fail the build if work items fail. False is "fire and forget."
-  Creator: ''                            # optional -- if the build is external, use this to specify who is sending the job
-  DisplayNamePrefix: 'Send job to Helix' # optional -- rename the beginning of the displayName of the steps in AzDO 
-  condition: succeeded()                 # optional -- condition for step to execute; defaults to succeeded()
-  continueOnError: false                 # optional -- determines whether to continue the build if the step errors; defaults to false
-  osGroup: ''                            # required -- operating system for the job
-            
-
-steps:
-- template: /eng/pipelines/common/templates/runtimes/send-to-helix-inner-step.yml
-  parameters:
-    osGroup: ${{ parameters.osGroup }}
-    sendParams: $(Build.SourcesDirectory)/eng/common/performance/${{ parameters.ProjectFile }} /restore /t:Test /bl:$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)/SendToHelix.binlog
-    displayName: ${{ parameters.DisplayNamePrefix }}
-    condition: ${{ parameters.condition }}
-    continueOnError: ${{ parameters.continueOnError }}
-    environment:
-      BuildConfig: $(_BuildConfig)
-      HelixSource: ${{ parameters.HelixSource }}
-      HelixType: ${{ parameters.HelixType }}
-      HelixBuild: ${{ parameters.HelixBuild }}
-      HelixTargetQueues: ${{ parameters.HelixTargetQueues }}
-      HelixAccessToken: ${{ parameters.HelixAccessToken }}
-      HelixPreCommands: ${{ parameters.HelixPreCommands }}
-      HelixPostCommands: ${{ parameters.HelixPostCommands }}
-      WorkItemDirectory: ${{ parameters.WorkItemDirectory }}
-      CorrelationPayloadDirectory: ${{ parameters.CorrelationPayloadDirectory }}
-      IncludeDotNetCli: ${{ parameters.IncludeDotNetCli }}
-      DotNetCliPackageType: ${{ parameters.DotNetCliPackageType }}
-      DotNetCliVersion: ${{ parameters.DotNetCliVersion }}
-      EnableXUnitReporter: ${{ parameters.EnableXUnitReporter }}
-      WaitForWorkItemCompletion: ${{ parameters.WaitForWorkItemCompletion }}
-      Creator: ${{ parameters.Creator }}
-      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
diff --git a/eng/common/templates/steps/send-to-helix.yml b/eng/common/templates/steps/send-to-helix.yml
index bb5f1a92938..cd02ae1607f 100644
--- a/eng/common/templates/steps/send-to-helix.yml
+++ b/eng/common/templates/steps/send-to-helix.yml
@@ -18,8 +18,8 @@ parameters:
   XUnitRuntimeTargetFramework: ''        # optional -- framework to use for the xUnit console runner
   XUnitRunnerVersion: ''                 # optional -- version of the xUnit nuget package you wish to use on Helix; required for XUnitProjects
   IncludeDotNetCli: false                # optional -- true will download a version of the .NET CLI onto the Helix machine as a correlation payload; requires DotNetCliPackageType and DotNetCliVersion
-  DotNetCliPackageType: ''               # optional -- either 'sdk', 'runtime' or 'aspnetcore-runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases-index.json
-  DotNetCliVersion: ''                   # optional -- version of the CLI to send to Helix; based on this: https://raw.githubusercontent.com/dotnet/core/master/release-notes/releases-index.json
+  DotNetCliPackageType: ''               # optional -- either 'sdk', 'runtime' or 'aspnetcore-runtime'; determines whether the sdk or runtime will be sent to Helix; see https://raw.githubusercontent.com/dotnet/core/main/release-notes/releases-index.json
+  DotNetCliVersion: ''                   # optional -- version of the CLI to send to Helix; based on this: https://raw.githubusercontent.com/dotnet/core/main/release-notes/releases-index.json
   EnableXUnitReporter: false             # optional -- true enables XUnit result reporting to Mission Control
   WaitForWorkItemCompletion: true        # optional -- true will make the task wait until work items have been completed and fail the build if work items fail. False is "fire and forget."
   IsExternal: false                      # [DEPRECATED] -- doesn't do anything, jobs are external if HelixAccessToken is empty and Creator is set
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
index 8e336b7d16b..e20637ed6a1 100644
--- a/eng/common/templates/steps/source-build.yml
+++ b/eng/common/templates/steps/source-build.yml
@@ -34,9 +34,14 @@ steps:
       targetRidArgs='/p:TargetRid=${{ parameters.platform.targetRID }}'
     fi
 
+    publishArgs=
+    if [ '${{ parameters.platform.skipPublishValidation }}' != 'true' ]; then
+      publishArgs='--publish'
+    fi
+
     ${{ coalesce(parameters.platform.buildScript, './build.sh') }} --ci \
       --configuration $buildConfig \
-      --restore --build --pack --publish \
+      --restore --build --pack $publishArgs -bl \
       $officialBuildArgs \
       $targetRidArgs \
       /p:SourceBuildNonPortable=${{ parameters.platform.nonPortable }} \
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 60eb601c8f3..2d8a74f7d9e 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -48,6 +48,9 @@
 # True to use global NuGet cache instead of restoring packages to repository-local directory.
 [bool]$useGlobalNuGetCache = if (Test-Path variable:useGlobalNuGetCache) { $useGlobalNuGetCache } else { !$ci }
 
+# True to exclude prerelease versions Visual Studio during build
+[bool]$excludePrereleaseVS = if (Test-Path variable:excludePrereleaseVS) { $excludePrereleaseVS } else { $false }
+
 # An array of names of processes to stop on script exit if prepareMachine is true.
 $processesToStopOnExit = if (Test-Path variable:processesToStopOnExit) { $processesToStopOnExit } else { @('msbuild', 'dotnet', 'vbcscompiler') }
 
@@ -57,7 +60,7 @@ set-strictmode -version 2.0
 $ErrorActionPreference = 'Stop'
 [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
 
-# If specified, provides an alternate path for getting .NET Core SDKs and Runtimes. This script will still try public sources first.
+# If specifies, provides an alternate path for getting .NET Core SDKs and Runtimes. This script will still try public sources first.
 [string]$runtimeSourceFeed = if (Test-Path variable:runtimeSourceFeed) { $runtimeSourceFeed } else { $null }
 # Base-64 encoded SAS token that has permission to storage container described by $runtimeSourceFeed
 [string]$runtimeSourceFeedKey = if (Test-Path variable:runtimeSourceFeedKey) { $runtimeSourceFeedKey } else { $null }
@@ -141,7 +144,7 @@ function InitializeDotNetCli([bool]$install, [bool]$createSdkLocationFile) {
 
   # Use dotnet installation specified in DOTNET_INSTALL_DIR if it contains the required SDK version,
   # otherwise install the dotnet CLI and SDK to repo local .dotnet directory to avoid potential permission issues.
-  if ((-not $globalJsonHasRuntimes) -and ($env:DOTNET_INSTALL_DIR -ne $null) -and (Test-Path(Join-Path $env:DOTNET_INSTALL_DIR "sdk\$dotnetSdkVersion"))) {
+  if ((-not $globalJsonHasRuntimes) -and (-not [string]::IsNullOrEmpty($env:DOTNET_INSTALL_DIR)) -and (Test-Path(Join-Path $env:DOTNET_INSTALL_DIR "sdk\$dotnetSdkVersion"))) {
     $dotnetRoot = $env:DOTNET_INSTALL_DIR
   } else {
     $dotnetRoot = Join-Path $RepoRoot '.dotnet'
@@ -169,7 +172,7 @@ function InitializeDotNetCli([bool]$install, [bool]$createSdkLocationFile) {
     Set-Content -Path $sdkCacheFileTemp -Value $dotnetRoot
 
     try {
-      Rename-Item -Force -Path $sdkCacheFileTemp 'sdk.txt'
+      Move-Item -Force $sdkCacheFileTemp (Join-Path $ToolsetDir 'sdk.txt')
     } catch {
       # Somebody beat us
       Remove-Item -Path $sdkCacheFileTemp
@@ -439,16 +442,35 @@ function LocateVisualStudio([object]$vsRequirements = $null){
   if (!(Test-Path $vsWhereExe)) {
     Create-Directory $vsWhereDir
     Write-Host 'Downloading vswhere'
-    try {
-      Invoke-WebRequest "https://netcorenativeassets.blob.core.windows.net/resource-packages/external/windows/vswhere/$vswhereVersion/vswhere.exe" -OutFile $vswhereExe
-    }
-    catch {
-      Write-PipelineTelemetryError -Category 'InitializeToolset' -Message $_
+    $maxRetries = 5
+    $retries = 1
+
+    while($true) {
+      try {
+        Invoke-WebRequest "https://netcorenativeassets.blob.core.windows.net/resource-packages/external/windows/vswhere/$vswhereVersion/vswhere.exe" -OutFile $vswhereExe
+        break
+      }
+      catch{
+        Write-PipelineTelemetryError -Category 'InitializeToolset' -Message $_
+      }
+
+      if (++$retries -le $maxRetries) {
+        $delayInSeconds = [math]::Pow(2, $retries) - 1 # Exponential backoff
+        Write-Host "Retrying. Waiting for $delayInSeconds seconds before next attempt ($retries of $maxRetries)."
+        Start-Sleep -Seconds $delayInSeconds
+      }
+      else {
+        Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Unable to download file in $maxRetries attempts."
+      }
     }
   }
 
   if (!$vsRequirements) { $vsRequirements = $GlobalJson.tools.vs }
-  $args = @('-latest', '-prerelease', '-format', 'json', '-requires', 'Microsoft.Component.MSBuild', '-products', '*')
+  $args = @('-latest', '-format', 'json', '-requires', 'Microsoft.Component.MSBuild', '-products', '*')
+
+  if (!$excludePrereleaseVS) {
+    $args += '-prerelease'
+  }
 
   if (Get-Member -InputObject $vsRequirements -Name 'version') {
     $args += '-version'
@@ -474,7 +496,13 @@ function LocateVisualStudio([object]$vsRequirements = $null){
 
 function InitializeBuildTool() {
   if (Test-Path variable:global:_BuildTool) {
-    return $global:_BuildTool
+    # If the requested msbuild parameters do not match, clear the cached variables.
+    if($global:_BuildTool.Contains('ExcludePrereleaseVS') -and $global:_BuildTool.ExcludePrereleaseVS -ne $excludePrereleaseVS) {
+      Remove-Item variable:global:_BuildTool 
+      Remove-Item variable:global:_MSBuildExe
+    } else {
+      return $global:_BuildTool
+    }
   }
 
   if (-not $msbuildEngine) {
@@ -493,7 +521,7 @@ function InitializeBuildTool() {
       ExitWithExitCode 1
     }
     $dotnetPath = Join-Path $dotnetRoot (GetExecutableFileName 'dotnet')
-    $buildTool = @{ Path = $dotnetPath; Command = 'msbuild'; Tool = 'dotnet'; Framework = 'netcoreapp2.1' }
+    $buildTool = @{ Path = $dotnetPath; Command = 'msbuild'; Tool = 'dotnet'; Framework = 'netcoreapp3.1' }
   } elseif ($msbuildEngine -eq "vs") {
     try {
       $msbuildPath = InitializeVisualStudioMSBuild -install:$restore
@@ -502,7 +530,7 @@ function InitializeBuildTool() {
       ExitWithExitCode 1
     }
 
-    $buildTool = @{ Path = $msbuildPath; Command = ""; Tool = "vs"; Framework = "net472" }
+    $buildTool = @{ Path = $msbuildPath; Command = ""; Tool = "vs"; Framework = "net472"; ExcludePrereleaseVS = $excludePrereleaseVS }
   } else {
     Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Unexpected value of -msbuildEngine: '$msbuildEngine'."
     ExitWithExitCode 1
@@ -629,9 +657,26 @@ function MSBuild() {
     }
 
     $toolsetBuildProject = InitializeToolset
-    $path = Split-Path -parent $toolsetBuildProject
-    $path = Join-Path $path (Join-Path $buildTool.Framework 'Microsoft.DotNet.Arcade.Sdk.dll')
-    $args += "/logger:$path"
+    $basePath = Split-Path -parent $toolsetBuildProject
+    $possiblePaths = @(
+      # new scripts need to work with old packages, so we need to look for the old names/versions
+      (Join-Path $basePath (Join-Path $buildTool.Framework 'Microsoft.DotNet.ArcadeLogging.dll')),
+      (Join-Path $basePath (Join-Path $buildTool.Framework 'Microsoft.DotNet.Arcade.Sdk.dll')),
+      (Join-Path $basePath (Join-Path netcoreapp2.1 'Microsoft.DotNet.ArcadeLogging.dll')),
+      (Join-Path $basePath (Join-Path netcoreapp2.1 'Microsoft.DotNet.Arcade.Sdk.dll'))
+    )
+    $selectedPath = $null
+    foreach ($path in $possiblePaths) {
+      if (Test-Path $path -PathType Leaf) {
+        $selectedPath = $path
+        break
+      }
+    }
+    if (-not $selectedPath) {
+      Write-PipelineTelemetryError -Category 'Build' -Message 'Unable to find arcade sdk logger assembly.'
+      ExitWithExitCode 1
+    }
+    $args += "/logger:$selectedPath"
   }
 
   MSBuild-Core @args
@@ -677,14 +722,23 @@ function MSBuild-Core() {
   $exitCode = Exec-Process $buildTool.Path $cmdArgs
 
   if ($exitCode -ne 0) {
-    Write-PipelineTelemetryError -Category 'Build' -Message 'Build failed.'
+    # We should not Write-PipelineTaskError here because that message shows up in the build summary
+    # The build already logged an error, that's the reason it failed. Producing an error here only adds noise.
+    Write-Host "Build failed with exit code $exitCode. Check errors above." -ForegroundColor Red
 
     $buildLog = GetMSBuildBinaryLogCommandLineArgument $args
-    if ($buildLog -ne $null) {
+    if ($null -ne $buildLog) {
       Write-Host "See log: $buildLog" -ForegroundColor DarkGray
     }
 
-    ExitWithExitCode $exitCode
+    if ($ci) {
+      Write-PipelineSetResult -Result "Failed" -Message "msbuild execution failed."
+      # Exiting with an exit code causes the azure pipelines task to log yet another "noise" error
+      # The above Write-PipelineSetResult will cause the task to be marked as failure without adding yet another error
+      ExitWithExitCode 0
+    } else {
+      ExitWithExitCode $exitCode
+    }
   }
 }
 
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index 98186e78496..5fad1846e5a 100755
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -89,16 +89,16 @@ function ResolvePath {
 function ReadGlobalVersion {
   local key=$1
 
-  local line=$(awk "/$key/ {print; exit}" "$global_json_file")
-  local pattern="\"$key\" *: *\"(.*)\""
+  if command -v jq &> /dev/null; then
+    _ReadGlobalVersion="$(jq -r ".[] | select(has(\"$key\")) | .\"$key\"" "$global_json_file")"
+  elif [[ "$(cat "$global_json_file")" =~ \"$key\"[[:space:]\:]*\"([^\"]+) ]]; then
+    _ReadGlobalVersion=${BASH_REMATCH[1]}
+  fi
 
-  if [[ ! $line =~ $pattern ]]; then
+  if [[ -z "$_ReadGlobalVersion" ]]; then
     Write-PipelineTelemetryError -category 'Build' "Error: Cannot find \"$key\" in $global_json_file"
     ExitWithExitCode 1
   fi
-
-  # return value
-  _ReadGlobalVersion=${BASH_REMATCH[1]}
 }
 
 function InitializeDotNetCli {
@@ -249,7 +249,7 @@ function with_retries {
       return 0
     fi
 
-    timeout=$((2**$retries-1))
+    timeout=$((3**$retries-1))
     echo "Failed to execute '$@'. Waiting $timeout seconds before next attempt ($retries out of $maxRetries)." 1>&2
     sleep $timeout
   done
@@ -271,10 +271,18 @@ function GetDotNetInstallScript {
 
     # Use curl if available, otherwise use wget
     if command -v curl > /dev/null; then
-      with_retries curl "$install_script_url" -sSL --retry 10 --create-dirs -o "$install_script" || {
-        local exit_code=$?
-        Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to acquire dotnet install script (exit code '$exit_code')."
-        ExitWithExitCode $exit_code
+      # first, try directly, if this fails we will retry with verbose logging
+      curl "$install_script_url" -sSL --retry 10 --create-dirs -o "$install_script" || {
+        if command -v openssl &> /dev/null; then
+          echo "Curl failed; dumping some information about dotnet.microsoft.com for later investigation"
+          echo | openssl s_client -showcerts -servername dotnet.microsoft.com  -connect dotnet.microsoft.com:443
+        fi
+        echo "Will now retry the same URL with verbose logging."
+        with_retries curl "$install_script_url" -sSL --verbose --retry 10 --create-dirs -o "$install_script" || {
+          local exit_code=$?
+          Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to acquire dotnet install script (exit code '$exit_code')."
+          ExitWithExitCode $exit_code
+        }
       }
     else
       with_retries wget -v -O "$install_script" "$install_script_url" || {
@@ -298,7 +306,7 @@ function InitializeBuildTool {
   # return values
   _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
   _InitializeBuildToolCommand="msbuild"
-  _InitializeBuildToolFramework="netcoreapp2.1"
+  _InitializeBuildToolFramework="netcoreapp3.1"
 }
 
 # Set RestoreNoCache as a workaround for https://github.com/NuGet/Home/issues/3116
@@ -405,8 +413,24 @@ function MSBuild {
     fi
 
     local toolset_dir="${_InitializeToolset%/*}"
-    local logger_path="$toolset_dir/$_InitializeBuildToolFramework/Microsoft.DotNet.Arcade.Sdk.dll"
-    args=( "${args[@]}" "-logger:$logger_path" )
+    # new scripts need to work with old packages, so we need to look for the old names/versions
+    local selectedPath=
+    local possiblePaths=()
+    possiblePaths+=( "$toolset_dir/$_InitializeBuildToolFramework/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/$_InitializeBuildToolFramework/Microsoft.DotNet.Arcade.Sdk.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp2.1/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp2.1/Microsoft.DotNet.Arcade.Sdk.dll" )
+    for path in "${possiblePaths[@]}"; do
+      if [[ -f $path ]]; then
+        selectedPath=$path
+        break
+      fi
+    done
+    if [[ -z "$selectedPath" ]]; then
+      Write-PipelineTelemetryError -category 'Build'  "Unable to find arcade sdk logger assembly."
+      ExitWithExitCode 1
+    fi
+    args+=( "-logger:$selectedPath" )
   fi
 
   MSBuild-Core ${args[@]}
@@ -437,8 +461,17 @@ function MSBuild-Core {
 
     "$_InitializeBuildTool" "$@" || {
       local exit_code=$?
-      Write-PipelineTaskError "Build failed (exit code '$exit_code')."
-      ExitWithExitCode $exit_code
+      # We should not Write-PipelineTaskError here because that message shows up in the build summary
+      # The build already logged an error, that's the reason it failed. Producing an error here only adds noise.
+      echo "Build failed with exit code $exit_code. Check errors above."
+      if [[ "$ci" == "true" ]]; then
+        Write-PipelineSetResult -result "Failed" -message "msbuild execution failed."
+        # Exiting with an exit code causes the azure pipelines task to log yet another "noise" error
+        # The above Write-PipelineSetResult will cause the task to be marked as failure without adding yet another error
+        ExitWithExitCode 0
+      else
+        ExitWithExitCode $exit_code
+      fi
     }
   }
 
@@ -461,8 +494,11 @@ temp_dir="$artifacts_dir/tmp/$configuration"
 global_json_file="$repo_root/global.json"
 # determine if global.json contains a "runtimes" entry
 global_json_has_runtimes=false
-dotnetlocal_key=$(awk "/runtimes/ {print; exit}" "$global_json_file") || true
-if [[ -n "$dotnetlocal_key" ]]; then
+if command -v jq &> /dev/null; then
+  if jq -er '. | select(has("runtimes"))' "$global_json_file" &> /dev/null; then
+    global_json_has_runtimes=true
+  fi
+elif [[ "$(cat "$global_json_file")" =~ \"runtimes\"[[:space:]\:]*\{ ]]; then
   global_json_has_runtimes=true
 fi
 
diff --git a/global.json b/global.json
index baac5529cfe..6e48829d044 100644
--- a/global.json
+++ b/global.json
@@ -1,6 +1,9 @@
 {
+  "sdk": {
+    "allowPrerelease": true
+  },
   "tools": {
-    "dotnet": "5.0.102",
+    "dotnet": "6.0.100-preview.3.21202.5",
     "runtimes": {
       "dotnet/x64": [
         "2.1.7"
@@ -12,6 +15,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21226.1"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21281.1"
   }
 }
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index d8a78e04125..a75f66a8753 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -70,6 +70,7 @@ public BuildEventContext(int submissionId, int nodeId, int evaluationId, int pro
         public override int GetHashCode() { throw null; }
         public static bool operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
         public static bool operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
+        public override string ToString() { throw null; }
     }
     public partial class BuildFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
@@ -580,11 +581,21 @@ public TargetSkippedEventArgs(string message, params object[] messageArgs) { }
         public string Condition { get { throw null; } set { } }
         public string EvaluatedCondition { get { throw null; } set { } }
         public override string Message { get { throw null; } }
+        public Microsoft.Build.Framework.BuildEventContext OriginalBuildEventContext { get { throw null; } set { } }
         public bool OriginallySucceeded { get { throw null; } set { } }
         public string ParentTarget { get { throw null; } set { } }
+        public Microsoft.Build.Framework.TargetSkipReason SkipReason { get { throw null; } set { } }
         public string TargetFile { get { throw null; } set { } }
         public string TargetName { get { throw null; } set { } }
     }
+    public enum TargetSkipReason
+    {
+        None = 0,
+        PreviouslyBuiltSuccessfully = 1,
+        PreviouslyBuiltUnsuccessfully = 2,
+        OutputsUpToDate = 3,
+        ConditionWasFalse = 4,
+    }
     public partial class TargetStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
         protected TargetStartedEventArgs() { }
@@ -652,6 +663,8 @@ public partial class TaskStartedEventArgs : Microsoft.Build.Framework.BuildStatu
         protected TaskStartedEventArgs() { }
         public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) { }
         public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) { }
+        public int ColumnNumber { get { throw null; } }
+        public int LineNumber { get { throw null; } }
         public override string Message { get { throw null; } }
         public string ProjectFile { get { throw null; } }
         public string TaskFile { get { throw null; } }
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 2fd1301abb1..b4eefc32fab 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -70,6 +70,7 @@ public BuildEventContext(int submissionId, int nodeId, int evaluationId, int pro
         public override int GetHashCode() { throw null; }
         public static bool operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
         public static bool operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
+        public override string ToString() { throw null; }
     }
     public partial class BuildFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
@@ -579,11 +580,21 @@ public TargetSkippedEventArgs(string message, params object[] messageArgs) { }
         public string Condition { get { throw null; } set { } }
         public string EvaluatedCondition { get { throw null; } set { } }
         public override string Message { get { throw null; } }
+        public Microsoft.Build.Framework.BuildEventContext OriginalBuildEventContext { get { throw null; } set { } }
         public bool OriginallySucceeded { get { throw null; } set { } }
         public string ParentTarget { get { throw null; } set { } }
+        public Microsoft.Build.Framework.TargetSkipReason SkipReason { get { throw null; } set { } }
         public string TargetFile { get { throw null; } set { } }
         public string TargetName { get { throw null; } set { } }
     }
+    public enum TargetSkipReason
+    {
+        None = 0,
+        PreviouslyBuiltSuccessfully = 1,
+        PreviouslyBuiltUnsuccessfully = 2,
+        OutputsUpToDate = 3,
+        ConditionWasFalse = 4,
+    }
     public partial class TargetStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
         protected TargetStartedEventArgs() { }
@@ -651,6 +662,8 @@ public partial class TaskStartedEventArgs : Microsoft.Build.Framework.BuildStatu
         protected TaskStartedEventArgs() { }
         public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) { }
         public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) { }
+        public int ColumnNumber { get { throw null; } }
+        public int LineNumber { get { throw null; } }
         public override string Message { get { throw null; } }
         public string ProjectFile { get { throw null; } }
         public string TaskFile { get { throw null; } }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 0c3ab22d801..5152392b1a3 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1048,8 +1048,7 @@ public enum BuildRequestDataFlags
         SkipNonexistentTargets = 16,
         ProvideSubsetOfStateAfterBuild = 32,
         IgnoreMissingEmptyAndInvalidImports = 64,
-        SkipNonexistentNonEntryTargets = 128,
-        FailOnUnresolvedSdk = 256,
+        FailOnUnresolvedSdk = 128,
     }
     public partial class BuildResult
     {
@@ -1499,18 +1498,18 @@ namespace Microsoft.Build.FileSystem
     public abstract partial class MSBuildFileSystemBase
     {
         protected MSBuildFileSystemBase() { }
-        public abstract bool DirectoryExists(string path);
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
-        public abstract bool FileExists(string path);
-        public abstract bool FileOrDirectoryExists(string path);
-        public abstract System.IO.FileAttributes GetAttributes(string path);
-        public abstract System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
-        public abstract System.DateTime GetLastWriteTimeUtc(string path);
-        public abstract System.IO.TextReader ReadFile(string path);
-        public abstract byte[] ReadFileAllBytes(string path);
-        public abstract string ReadFileAllText(string path);
+        public virtual bool DirectoryExists(string path) { throw null; }
+        public virtual System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
+        public virtual System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
+        public virtual System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
+        public virtual bool FileExists(string path) { throw null; }
+        public virtual bool FileOrDirectoryExists(string path) { throw null; }
+        public virtual System.IO.FileAttributes GetAttributes(string path) { throw null; }
+        public virtual System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) { throw null; }
+        public virtual System.DateTime GetLastWriteTimeUtc(string path) { throw null; }
+        public virtual System.IO.TextReader ReadFile(string path) { throw null; }
+        public virtual byte[] ReadFileAllBytes(string path) { throw null; }
+        public virtual string ReadFileAllText(string path) { throw null; }
     }
 }
 namespace Microsoft.Build.Globbing
@@ -1575,8 +1574,8 @@ protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) {
         public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
-        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
-        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
+        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
         protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
         public override string ToString() { throw null; }
         public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 9dc716a4007..cffbea13779 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1043,8 +1043,7 @@ public enum BuildRequestDataFlags
         SkipNonexistentTargets = 16,
         ProvideSubsetOfStateAfterBuild = 32,
         IgnoreMissingEmptyAndInvalidImports = 64,
-        SkipNonexistentNonEntryTargets = 128,
-        FailOnUnresolvedSdk = 256,
+        FailOnUnresolvedSdk = 128,
     }
     public partial class BuildResult
     {
@@ -1493,18 +1492,18 @@ namespace Microsoft.Build.FileSystem
     public abstract partial class MSBuildFileSystemBase
     {
         protected MSBuildFileSystemBase() { }
-        public abstract bool DirectoryExists(string path);
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
-        public abstract bool FileExists(string path);
-        public abstract bool FileOrDirectoryExists(string path);
-        public abstract System.IO.FileAttributes GetAttributes(string path);
-        public abstract System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
-        public abstract System.DateTime GetLastWriteTimeUtc(string path);
-        public abstract System.IO.TextReader ReadFile(string path);
-        public abstract byte[] ReadFileAllBytes(string path);
-        public abstract string ReadFileAllText(string path);
+        public virtual bool DirectoryExists(string path) { throw null; }
+        public virtual System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
+        public virtual System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
+        public virtual System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
+        public virtual bool FileExists(string path) { throw null; }
+        public virtual bool FileOrDirectoryExists(string path) { throw null; }
+        public virtual System.IO.FileAttributes GetAttributes(string path) { throw null; }
+        public virtual System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) { throw null; }
+        public virtual System.DateTime GetLastWriteTimeUtc(string path) { throw null; }
+        public virtual System.IO.TextReader ReadFile(string path) { throw null; }
+        public virtual byte[] ReadFileAllBytes(string path) { throw null; }
+        public virtual string ReadFileAllText(string path) { throw null; }
     }
 }
 namespace Microsoft.Build.Globbing
@@ -1569,8 +1568,8 @@ protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) {
         public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
-        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
-        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
+        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
         protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
         public override string ToString() { throw null; }
         public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index c9bc90217fe..ae7b4abd563 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -48,7 +48,7 @@ Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
 if ($runtime -eq "Desktop") {
     $targetFramework = "net472"
 } else {
-    $targetFramework = "net5.0"
+    $targetFramework = "net6.0"
 }
 
 $bootstrapBinDirectory = "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework"
@@ -60,6 +60,19 @@ $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.Utilities.Core.dll"
     FileToCopy "$bootstrapBinDirectory\Microsoft.NET.StringTools.dll"
 
+    FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Buffers.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Collections.Immutable.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Memory.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Numerics.Vectors.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Resources.Extensions.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Runtime.CompilerServices.Unsafe.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Text.Encodings.Web.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Text.Json.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Dataflow.dll"
+    FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Extensions.dll"
+    FileToCopy "$bootstrapBinDirectory\System.ValueTuple.dll"
+
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Tasks.Core.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Utilities.Core.resources.dll" "en"
@@ -87,6 +100,7 @@ $filesToCopyToBin = @(
 if ($runtime -eq "Desktop") {
     $runtimeSpecificFiles = @(
         FileToCopy "$bootstrapBinDirectory\MSBuild.exe"
+        FileToCopy "$bootstrapBinDirectory\MSBuild.exe.config"
         FileToCopy "artifacts\bin\Microsoft.Build.Conversion\$configuration\$targetFramework\Microsoft.Build.Conversion.Core.dll"
         FileToCopy "artifacts\bin\Microsoft.Build.Engine\$configuration\$targetFramework\Microsoft.Build.Engine.dll"
 
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 5be64a17d58..008efd6ab92 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -260,6 +260,51 @@ public void TestTranslation()
             Assert.Equal(config, deserializedConfig);
         }
 
+        [Fact]
+        public void TestTranslationWithEntireProjectState()
+        {
+            string projectBody = ObjectModelHelpers.CleanupFileContents(@"
+<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+<PropertyGroup>
+    <One>1</One>
+    <Two>2</Two>
+    <Three>$(ThreeIn)</Three>
+</PropertyGroup>
+<Target Name='Build'>
+    <CallTarget Targets='Foo'/>
+</Target>
+</Project>");
+
+            Dictionary<string, string> globalProperties = new (StringComparer.OrdinalIgnoreCase);
+            globalProperties["ThreeIn"] = "3";
+
+            Project project = new Project(
+                XmlReader.Create(new StringReader(projectBody)),
+                globalProperties,
+                ObjectModelHelpers.MSBuildDefaultToolsVersion,
+                new ProjectCollection());
+            project.FullPath = "foo";
+            ProjectInstance instance = project.CreateProjectInstance();
+
+            instance.TranslateEntireState = true;
+
+            BuildRequestConfiguration configuration = new BuildRequestConfiguration(new BuildRequestData(instance, new string[] { }, null), "2.0");
+            configuration.ConfigurationId = 1;
+
+            ((ITranslatable)configuration).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = BuildRequestConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            BuildRequestConfiguration deserializedConfig = packet as BuildRequestConfiguration;
+
+            deserializedConfig.ShouldNotBeNull();
+            deserializedConfig.ShouldBe(configuration);
+            deserializedConfig.Project.ShouldNotBeNull();
+
+            // Verify that at least some data from 'entire project state' has been deserialized.
+            deserializedConfig.Project.Directory.ShouldNotBeEmpty();
+            deserializedConfig.Project.Directory.ShouldBe(configuration.Project.Directory);
+        }
+
         [Fact]
         public void TestProperties()
         {
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index d428e3fdac6..ac9b733f8d2 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -553,7 +553,7 @@ public void LogTaskStarted(BuildEventContext targetBuildEventContext, string tas
         /// <param name="projectFile">The project file</param>
         /// <param name="projectFileOfTaskNode">The project file containing the task node.</param>
         /// <returns>The task logging context</returns>
-        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
+        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
         {
             return new BuildEventContext(0, 0, 0, 0);
         }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index a3137f5b399..78d73604056 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -52,6 +52,7 @@ public void VerifyEventType()
             BuildErrorEventArgs error = new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
             TargetStartedEventArgs targetStarted = new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile");
             TargetFinishedEventArgs targetFinished = new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true);
+            TargetSkippedEventArgs targetSkipped = CreateTargetSkipped();
             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null);
             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs("message", "help", "ProjectFile", true);
             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames");
@@ -69,6 +70,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(error, LoggingEventType.BuildErrorEvent);
             VerifyLoggingPacket(targetStarted, LoggingEventType.TargetStartedEvent);
             VerifyLoggingPacket(targetFinished, LoggingEventType.TargetFinishedEvent);
+            VerifyLoggingPacket(targetSkipped, LoggingEventType.TargetSkipped);
             VerifyLoggingPacket(projectStarted, LoggingEventType.ProjectStartedEvent);
             VerifyLoggingPacket(projectFinished, LoggingEventType.ProjectFinishedEvent);
             VerifyLoggingPacket(evaluationStarted, LoggingEventType.ProjectEvaluationStartedEvent);
@@ -158,6 +160,8 @@ private static TaskParameterEventArgs CreateTaskParameter()
                 items,
                 logItemMetadata: true,
                 DateTime.MinValue);
+            result.LineNumber = 30000;
+            result.ColumnNumber = 50;
 
             // normalize line endings as we can't rely on the line endings of NodePackets_Tests.cs
             Assert.Equal(@"Task Parameter:
@@ -174,6 +178,26 @@ private static TaskParameterEventArgs CreateTaskParameter()
             return result;
         }
 
+        private static TargetSkippedEventArgs CreateTargetSkipped()
+        {
+            var result = new TargetSkippedEventArgs(message: null)
+            {
+                BuildReason = TargetBuiltReason.DependsOn,
+                SkipReason = TargetSkipReason.PreviouslyBuiltSuccessfully,
+                BuildEventContext = CreateBuildEventContext(),
+                OriginalBuildEventContext = CreateBuildEventContext(),
+                Condition = "$(Condition) == 'true'",
+                EvaluatedCondition = "'true' == 'true'",
+                Importance = MessageImportance.Normal,
+                OriginallySucceeded = true,
+                ProjectFile = "1.proj",
+                TargetFile = "1.proj",
+                TargetName = "Build",
+                ParentTarget = "ParentTarget"
+            };
+            return result;
+        }
+
         /// <summary>
         /// Tests serialization of LogMessagePacket with each kind of event type.
         /// </summary>
@@ -195,7 +219,11 @@ public void TestTranslation()
                     new BuildFinishedEventArgs("Message", "Keyword", true),
                     new BuildStartedEventArgs("Message", "Help"),
                     new BuildMessageEventArgs("Message", "help", "sender", MessageImportance.Low),
-                    new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName"),
+                    new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName")
+                    {
+                        LineNumber = 345,
+                        ColumnNumber = 123
+                    },
                     new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true),
                     new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low),
                     CreateTaskParameter(),
@@ -207,7 +235,8 @@ public void TestTranslation()
                     new ProjectFinishedEventArgs("message", "help", "ProjectFile", true),
                     new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames"),
                     CreateProjectEvaluationStarted(),
-                    CreateProjectEvaluationFinished()
+                    CreateProjectEvaluationFinished(),
+                    CreateTargetSkipped()
                 };
 
                 foreach (BuildEventArgs arg in testArgs)
@@ -412,6 +441,23 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTargetStarted.TargetName, rightTargetStarted.TargetName);
                     break;
 
+                case LoggingEventType.TargetSkipped:
+                    TargetSkippedEventArgs leftTargetSkipped = left.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
+                    TargetSkippedEventArgs rightTargetSkipped = right.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
+                    Assert.Equal(leftTargetSkipped.BuildReason, rightTargetSkipped.BuildReason);
+                    Assert.Equal(leftTargetSkipped.SkipReason, rightTargetSkipped.SkipReason);
+                    Assert.Equal(leftTargetSkipped.BuildEventContext, rightTargetSkipped.BuildEventContext);
+                    Assert.Equal(leftTargetSkipped.OriginalBuildEventContext, rightTargetSkipped.OriginalBuildEventContext);
+                    Assert.Equal(leftTargetSkipped.Condition, rightTargetSkipped.Condition);
+                    Assert.Equal(leftTargetSkipped.EvaluatedCondition, rightTargetSkipped.EvaluatedCondition);
+                    Assert.Equal(leftTargetSkipped.Importance, rightTargetSkipped.Importance);
+                    Assert.Equal(leftTargetSkipped.OriginallySucceeded, rightTargetSkipped.OriginallySucceeded);
+                    Assert.Equal(leftTargetSkipped.ProjectFile, rightTargetSkipped.ProjectFile);
+                    Assert.Equal(leftTargetSkipped.TargetFile, rightTargetSkipped.TargetFile);
+                    Assert.Equal(leftTargetSkipped.TargetName, rightTargetSkipped.TargetName);
+                    Assert.Equal(leftTargetSkipped.ParentTarget, rightTargetSkipped.ParentTarget);
+                    break;
+
                 case LoggingEventType.TaskCommandLineEvent:
                     TaskCommandLineEventArgs leftCommand = left.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
                     TaskCommandLineEventArgs rightCommand = right.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
@@ -433,6 +479,8 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTaskParameter.Message, rightTaskParameter.Message);
                     Assert.Equal(leftTaskParameter.BuildEventContext, rightTaskParameter.BuildEventContext);
                     Assert.Equal(leftTaskParameter.Timestamp, rightTaskParameter.Timestamp);
+                    Assert.Equal(leftTaskParameter.LineNumber, rightTaskParameter.LineNumber);
+                    Assert.Equal(leftTaskParameter.ColumnNumber, rightTaskParameter.ColumnNumber);
                     break;
 
                 case LoggingEventType.TaskFinishedEvent:
@@ -454,6 +502,8 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTaskStarted.ProjectFile, rightTaskStarted.ProjectFile);
                     Assert.Equal(leftTaskStarted.TaskFile, rightTaskStarted.TaskFile);
                     Assert.Equal(leftTaskStarted.TaskName, rightTaskStarted.TaskName);
+                    Assert.Equal(leftTaskStarted.LineNumber, rightTaskStarted.LineNumber);
+                    Assert.Equal(leftTaskStarted.ColumnNumber, rightTaskStarted.ColumnNumber);
                     break;
 
                 default:
diff --git a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
index 346da6846b9..67950cf5716 100644
--- a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
@@ -89,8 +89,12 @@ public void TestTranslationNoException()
         {
             TaskItem item = new TaskItem("foo", "bar.proj");
             item.SetMetadata("a", "b");
+            var buildEventContext = new Framework.BuildEventContext(1, 2, 3, 4, 5, 6, 7);
 
-            TargetResult result = new TargetResult(new TaskItem[] { item }, BuildResultUtilities.GetStopWithErrorResult());
+            TargetResult result = new TargetResult(
+                new TaskItem[] { item },
+                BuildResultUtilities.GetStopWithErrorResult(),
+                buildEventContext);
 
             ((ITranslatable)result).Translate(TranslationHelpers.GetWriteTranslator());
             TargetResult deserializedResult = TargetResult.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -98,6 +102,7 @@ public void TestTranslationNoException()
             Assert.Equal(result.ResultCode, deserializedResult.ResultCode);
             Assert.True(TranslationHelpers.CompareCollections(result.Items, deserializedResult.Items, TaskItemComparer.Instance));
             Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.Equal(result.OriginalBuildEventContext, deserializedResult.OriginalBuildEventContext);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 3dd4465ed3a..d7e2b9b5d4b 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -1,7 +1,12 @@
 ﻿using System;
+using System.Collections.Generic;
 using System.Text;
+
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
+
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -155,6 +160,49 @@ public void BinaryLoggerShouldNotThrowWhenMetadataCannotBeExpanded()
             ObjectModelHelpers.BuildProjectExpectSuccess(project, binaryLogger);
         }
 
+        /// <summary>
+        /// Regression test for https://github.com/dotnet/msbuild/issues/6323.
+        /// </summary>
+        /// <remarks>
+        /// This isn't strictly a binlog test, but it fits here because
+        /// all log event types will be used when the binlog is attached.
+        /// </remarks>
+        [Fact]
+        public void MessagesCanBeLoggedWhenProjectsAreCached()
+        {
+            using var env = TestEnvironment.Create();
+
+            env.SetEnvironmentVariable("MSBUILDDEBUGFORCECACHING", "1");
+
+            using var buildManager = new BuildManager();
+
+            var binaryLogger = new BinaryLogger
+            {
+                Parameters = $"LogFile={_logFile}"
+            };
+
+            // To trigger #6323, there must be at least two project instances.
+            var referenceProject = _env.CreateTestProjectWithFiles("reference.proj", @"
+         <Project>
+            <Target Name='Target2'>
+               <Exec Command='echo a'/>
+            </Target>
+         </Project>");
+
+            var entryProject = _env.CreateTestProjectWithFiles("entry.proj", $@"
+         <Project>
+            <Target Name='BuildSelf'>
+               <Message Text='MessageOutputText'/>
+               <MSBuild Projects='{referenceProject.ProjectFile}' Targets='Target2' />
+               <MSBuild Projects='{referenceProject.ProjectFile}' Targets='Target2' /><!-- yes, again. That way it's a cached result -->
+            </Target>
+         </Project>");
+
+            buildManager.Build(new BuildParameters() { Loggers = new ILogger[] { binaryLogger } },
+                new BuildRequestData(entryProject.ProjectFile, new Dictionary<string, string>(), null, new string[] { "BuildSelf" }, null))
+                .OverallResult.ShouldBe(BuildResultCode.Success);
+        }
+
 
         public void Dispose()
         {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index f1b59b48e1f..e169cbfb8e2 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -160,11 +160,15 @@ public void RoundtripTaskStartedEventArgs()
                 projectFile: "C:\\project.proj",
                 taskFile: "C:\\common.targets",
                 taskName: "Csc");
+            args.LineNumber = 42;
+            args.ColumnNumber = 999;
 
             Roundtrip(args,
                 e => e.ProjectFile,
                 e => e.TaskFile,
-                e => e.TaskName);
+                e => e.TaskName,
+                e => e.LineNumber.ToString(),
+                e => e.ColumnNumber.ToString());
         }
 
         [Fact]
@@ -327,11 +331,15 @@ public void RoundtripTaskParameterEventArgs()
                 new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
             };
             var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ItemName", items, true, DateTime.MinValue);
+            args.LineNumber = 265;
+            args.ColumnNumber = 6;
 
             Roundtrip(args,
                 e => e.Kind.ToString(),
                 e => e.ItemType,
                 e => e.LogItemMetadata.ToString(),
+                e => e.LineNumber.ToString(),
+                e => e.ColumnNumber.ToString(),
                 e => TranslationHelpers.GetItemsString(e.Items));
         }
 
@@ -443,20 +451,31 @@ public void RoundtripTargetSkippedEventArgs()
                 ProjectFile = "foo.csproj",
                 TargetName = "target",
                 ParentTarget = "bar",
-                BuildReason = TargetBuiltReason.DependsOn
+                BuildReason = TargetBuiltReason.DependsOn,
+                SkipReason = TargetSkipReason.PreviouslyBuiltSuccessfully,
+                Condition = "$(condition) == true",
+                EvaluatedCondition = "true == true",
+                OriginalBuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7),
+                OriginallySucceeded = false,
+                TargetFile = "foo.csproj"
             };
 
             Roundtrip(args,
+                e => e.BuildEventContext.ToString(),
                 e => e.ParentTarget,
                 e => e.Importance.ToString(),
                 e => e.LineNumber.ToString(),
                 e => e.ColumnNumber.ToString(),
-                e => e.LineNumber.ToString(),
                 e => e.Message,
                 e => e.ProjectFile,
                 e => e.TargetFile,
                 e => e.TargetName,
-                e => e.BuildReason.ToString());
+                e => e.BuildReason.ToString(),
+                e => e.SkipReason.ToString(),
+                e => e.Condition,
+                e => e.EvaluatedCondition,
+                e => e.OriginalBuildEventContext.ToString(),
+                e => e.OriginallySucceeded.ToString());
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 5d536380d86..b75fa9b28be 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -175,6 +175,46 @@ public void SolutionFilterFiltersProjects()
             }
         }
 
+        [Fact]
+        public void BuildProjectAsTarget()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
+                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
+                    @"<Project>
+                  <Target Name=""ClassLibraryTarget"">
+                      <Message Text=""ClassLibraryBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
+                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
+                    @"<Project>
+                  <Target Name=""SimpleProjectTarget"">
+                      <Message Text=""SimpleProjectBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
+                    @"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.6.30114.105
+MinimumVisualStudioVersion = 10.0.40219.1
+Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
+EndProject
+Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
+EndProject
+                ");
+                RunnerUtilities.ExecMSBuild(solutionFile.Path + " /t:classlib", out bool success);
+                success.ShouldBeTrue();
+            }
+        }
+
         /// <summary>
         /// Verify the AddNewErrorWarningMessageElement method
         /// </summary>
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 00dc1bb6f61..a160284d78a 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -119,7 +119,7 @@ public void PassedInFileSystemShouldBeReusedInSharedContext()
                         {Path.Combine(_env.DefaultTestDirectory.Path, "2.file"), 1}
                     }.OrderBy(kvp => kvp.Key));
 
-            fileSystem.DirectoryEntryExistsCalls.ShouldBe(2);
+            fileSystem.FileOrDirectoryExistsCalls.ShouldBe(2);
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 76dd7380d59..71d15858f3c 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -2010,13 +2010,16 @@ public void PropertyFunctionNullArgument()
         public void PropertyFunctionNullReturn()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
-            pg.Set(ProjectPropertyInstance.Create("SomeStuff", "This IS SOME STUff"));
 
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
 
-            string result = expander.ExpandIntoStringLeaveEscaped("$([System.Convert]::ChangeType(,$(SomeStuff.GetType())))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
-
+            // The null-returning function is the only thing in the expression.
+            string result = expander.ExpandIntoStringLeaveEscaped("$([System.Environment]::GetEnvironmentVariable(`_NonExistentVar`))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
             Assert.Equal("", result);
+
+            // The result of the null-returning function is concatenated with a non-empty string.
+            result = expander.ExpandIntoStringLeaveEscaped("prefix_$([System.Environment]::GetEnvironmentVariable(`_NonExistentVar`))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            Assert.Equal("prefix_", result);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 52f699668fb..acd5ea588f2 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -43,7 +43,7 @@
     <ProjectReference Include="..\Samples\ProjectCachePlugin\ProjectCachePlugin.csproj" Private="false" ReferenceOutputAssembly="false">
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' == 'true'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
-      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=net5.0</SetTargetFramework>
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=net6.0</SetTargetFramework>
     </ProjectReference>
   </ItemGroup>
 
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ef032ea7791..45341070715 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -410,6 +410,8 @@ public void BeginBuild(BuildParameters parameters)
         {
             lock (_syncLock)
             {
+                AttachDebugger();
+
                 // Check for build in progress.
                 RequireState(BuildManagerState.Idle, "BuildInProgress");
 
@@ -558,6 +560,37 @@ void InitializeCaches()
             }
         }
 
+        private void AttachDebugger()
+        {
+            if (Debugger.IsAttached)
+            {
+                return;
+            }
+
+            var processNameToBreakInto = Environment.GetEnvironmentVariable("MSBuildDebugBuildManagerOnStartProcessName");
+            var thisProcessMatchesName = string.IsNullOrWhiteSpace(processNameToBreakInto) || Process.GetCurrentProcess().ProcessName.Contains(processNameToBreakInto);
+
+            if (!thisProcessMatchesName)
+            {
+                return;
+            }
+
+            switch (Environment.GetEnvironmentVariable("MSBuildDebugBuildManagerOnStart"))
+            {
+#if FEATURE_DEBUG_LAUNCH
+                case "1":
+                    Debugger.Launch();
+                    break;
+#endif
+                case "2":
+                    // Sometimes easier to attach rather than deal with JIT prompt
+                    Process currentProcess = Process.GetCurrentProcess();
+                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule.FileName} PID {currentProcess.Id}).  Press enter to continue...");
+                    Console.ReadLine();
+                    break;
+            }
+        }
+
         private void InitializeProjectCacheService(
             ProjectCacheDescriptor pluginDescriptor,
             CancellationToken cancellationToken)
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index 673ee5f0fdf..6f3a29a5765 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -76,20 +76,12 @@ public enum BuildRequestDataFlags
         /// </summary>
         IgnoreMissingEmptyAndInvalidImports = 1 << 6,
 
-        /// <summary>
-        /// When this flag is present, non entry target(s) in the build request will be skipped if those targets
-        /// are not defined in the Project to build. The build will still fail if an entry target does not exist.
-        /// This only applies to this build request (if another target calls the "missing target" at any other point
-        /// this will still result in an error).
-        /// </summary>
-        SkipNonexistentNonEntryTargets = 1 << 7,
-
         /// <summary>
         /// When this flag is present, an unresolved MSBuild project SDK will fail the build.  This flag is used to
         /// change the <see cref="IgnoreMissingEmptyAndInvalidImports" /> behavior to still fail when an SDK is missing
         /// because those are more fatal.
         /// </summary>
-        FailOnUnresolvedSdk = 1 << 8,
+        FailOnUnresolvedSdk = 1 << 7,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 4116039458a..f10fbf8dc50 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -4,10 +4,11 @@
 using System;
 using System.Collections.Concurrent;
 using System.Linq;
+using System.Reflection;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Reflection;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -103,5 +104,17 @@ public static T FactoryForDeserializingTypeWithName<T>(this ITranslator translat
 
             return (T) targetInstanceChild;
         }
+
+        public static void TranslateOptionalBuildEventContext(this ITranslator translator, ref BuildEventContext buildEventContext)
+        {
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                buildEventContext = translator.Reader.ReadOptionalBuildEventContext();
+            }
+            else
+            {
+                translator.Writer.WriteOptionalBuildEventContext(buildEventContext);
+            }
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 7d489ca8b21..86d4e070d33 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -525,8 +525,10 @@ void LogProjectEvaluationFinished(
         /// <param name="taskName">The name of the task</param>
         /// <param name="projectFile">The project file which is being built</param>
         /// <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
+        /// <param name="line">The line number in the file where the task invocation is located.</param>
+        /// <param name="column">The column number in the file where the task invocation is located.</param>
         /// <returns>The task build event context</returns>
-        BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
+        BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column);
 
         /// <summary>
         /// Log that a task has just completed
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 77de428ef63..13e70263473 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -754,9 +754,11 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN
         /// <param name="taskName">Task Name</param>
         /// <param name="projectFile">Project file being built</param>
         /// <param name="projectFileOfTaskNode">Project file which contains the task</param>
+        /// <param name="line">The line number in the file where the task invocation is located.</param>
+        /// <param name="column">The column number in the file where the task invocation is located.</param>
         /// <returns>The build event context for the task.</returns>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
+        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
         {
             lock (_lockObject)
             {
@@ -782,6 +784,8 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte
                             taskName
                         );
                     buildEvent.BuildEventContext = taskBuildEventContext;
+                    buildEvent.LineNumber = line;
+                    buildEvent.ColumnNumber = column;
                     ProcessLoggingEvent(buildEvent);
                 }
 
diff --git a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
index 05c5ae53708..6852343e9be 100644
--- a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
@@ -69,7 +69,13 @@ internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry)
         internal ProjectLoggingContext LogProjectStarted(BuildRequest request, BuildRequestConfiguration configuration)
         {
             ErrorUtilities.VerifyThrow(this.IsValid, "Build not started.");
-            return new ProjectLoggingContext(this, request, configuration.ProjectFullPath, configuration.ToolsVersion, request.ParentBuildEventContext, configuration.Project?.EvaluationId ?? BuildEventContext.InvalidEvaluationId);
+
+            // If we can retrieve the evaluationId from the project, do so. Don't if it's not available or
+            // if we'd have to retrieve it from the cache in order to access it.
+            // Order is important here because the Project getter will throw if IsCached.
+            int evaluationId = (configuration != null && !configuration.IsCached && configuration.Project != null) ? configuration.Project.EvaluationId : BuildEventContext.InvalidEvaluationId;
+
+            return new ProjectLoggingContext(this, request, configuration.ProjectFullPath, configuration.ToolsVersion, request.ParentBuildEventContext, evaluationId);
         }
 
         /// <summary>
@@ -80,18 +86,26 @@ internal void LogRequestHandledFromCache(BuildRequest request, BuildRequestConfi
         {
             ProjectLoggingContext projectLoggingContext = LogProjectStarted(request, configuration);
 
-            // When pulling a request from the cache, we want to make sure we log a task skipped message for any targets which 
-            // were used to build the request including default and inital targets.
+            // When pulling a request from the cache, we want to make sure we log a target skipped event for any targets which
+            // were used to build the request including default and initial targets.
             foreach (string target in configuration.GetTargetsUsedToBuildRequest(request))
             {
-                projectLoggingContext.LogComment
-                    (
-                        MessageImportance.Low,
-                        result[target].ResultCode == TargetResultCode.Failure ? "TargetAlreadyCompleteFailure" : "TargetAlreadyCompleteSuccess",
-                        target
-                    );
-
-                if (result[target].ResultCode == TargetResultCode.Failure)
+                var targetResult = result[target];
+                bool isFailure = targetResult.ResultCode == TargetResultCode.Failure;
+
+                var skippedTargetEventArgs = new TargetSkippedEventArgs(message: null)
+                {
+                    BuildEventContext = projectLoggingContext.BuildEventContext,
+                    TargetName = target,
+                    BuildReason = TargetBuiltReason.None,
+                    SkipReason = isFailure ? TargetSkipReason.PreviouslyBuiltUnsuccessfully : TargetSkipReason.PreviouslyBuiltSuccessfully,
+                    OriginallySucceeded = !isFailure,
+                    OriginalBuildEventContext = (targetResult as TargetResult)?.OriginalBuildEventContext
+                };
+
+                projectLoggingContext.LogBuildEvent(skippedTargetEventArgs);
+
+                if (targetResult.ResultCode == TargetResultCode.Failure)
                 {
                     break;
                 }
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index 6dc62c389ce..51c266e6485 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -69,7 +69,9 @@ internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string pr
                 targetLoggingContext.BuildEventContext,
                 _taskName,
                 projectFullPath,
-                task.Location.File
+                task.Location.File,
+                task.Location.Line,
+                task.Location.Column
                 );
             this.IsValid = true;
         }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index ad7259723ce..e889650e4ca 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -13,7 +13,6 @@
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
@@ -25,6 +24,13 @@ internal class ProjectCacheService
         private readonly CancellationToken _cancellationToken;
         private readonly ProjectCachePluginBase _projectCachePlugin;
 
+        /// <summary>
+        /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
+        /// i.e. falling back to FileSystem.Default.
+        /// </summary>
+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase
+        { }
+
         private ProjectCacheService(
             ProjectCachePluginBase projectCachePlugin,
             BuildManager buildManager,
@@ -59,7 +65,7 @@ public static async Task<ProjectCacheService> FromDescriptorAsync(
                 await plugin.BeginBuildAsync(
                     new CacheContext(
                         pluginDescriptor.PluginSettings,
-                        new IFileSystemAdapter(FileSystems.Default),
+                        new DefaultMSBuildFileSystem(),
                         pluginDescriptor.ProjectGraph,
                         pluginDescriptor.EntryPoints),
                     // TODO: Detect verbosity from logging service.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 66195775b22..109cb49b9bf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -218,7 +218,8 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     TaskParameterMessageKind.AddItem,
                     child.ItemType,
                     itemsToAdd,
-                    logItemMetadata: true);
+                    logItemMetadata: true,
+                    child.Location);
             }
 
             // Now add the items we created to the lookup.
@@ -261,7 +262,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                         TaskParameterMessageKind.RemoveItem,
                         child.ItemType,
                         itemsToRemove,
-                        logItemMetadata: true);
+                        logItemMetadata: true,
+                        child.Location);
                 }
 
                 bucket.Lookup.RemoveItems(itemsToRemove);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index 4f7440b61e3..b672732ee39 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -252,7 +252,8 @@ internal static void LogTaskParameter(
             TaskParameterMessageKind messageKind,
             string itemType,
             IList items,
-            bool logItemMetadata)
+            bool logItemMetadata,
+            IElementLocation location = null)
         {
             var args = CreateTaskParameterEventArgs(
                 loggingContext.BuildEventContext,
@@ -260,7 +261,10 @@ internal static void LogTaskParameter(
                 itemType,
                 items,
                 logItemMetadata,
-                DateTime.UtcNow);
+                DateTime.UtcNow,
+                location?.Line ?? 0,
+                location?.Column ?? 0);
+
             loggingContext.LogBuildEvent(args);
         }
 
@@ -270,7 +274,9 @@ internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
             string itemType,
             IList items,
             bool logItemMetadata,
-            DateTime timestamp)
+            DateTime timestamp,
+            int line = 0,
+            int column = 0)
         {
             // Only create a snapshot of items if we use AppDomains
 #if FEATURE_APPDOMAIN
@@ -284,6 +290,8 @@ internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
                 logItemMetadata,
                 timestamp);
             args.BuildEventContext = buildEventContext;
+            args.LineNumber = line;
+            args.ColumnNumber = column;
             return args;
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 617fea73b47..6b4b24dfa81 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -143,24 +143,15 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
             foreach (string targetName in targetNames)
             {
                 var targetExists = _projectInstance.Targets.TryGetValue(targetName, out ProjectTargetInstance targetInstance);
-                
-                if (!targetExists)
+                if (!targetExists && entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentTargets))
                 {
-                    // Ignore the missing target if:
-                    //  SkipNonexistentTargets is set
-                    //  -or-
-                    //  SkipNonexistentNonEntryTargets and the target is is not a top level target
-                    if (entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentTargets)
-                        || entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentNonEntryTargets) && !entry.Request.Targets.Contains(targetName))
-                    {
-                        _projectLoggingContext.LogComment(Framework.MessageImportance.Low,
-                            "TargetSkippedWhenSkipNonexistentTargets", targetName);
-
-                        continue;
-                    }
+                    _projectLoggingContext.LogComment(Framework.MessageImportance.Low,
+                        "TargetSkippedWhenSkipNonexistentTargets", targetName);
+                }
+                else
+                {
+                    targets.Add(new TargetSpecification(targetName, targetExists ? targetInstance.Location : _projectInstance.ProjectFileLocation));
                 }
-
-                targets.Add(new TargetSpecification(targetName, targetExists ? targetInstance.Location : _projectInstance.ProjectFileLocation));
             }
 
             // Push targets onto the stack.  This method will reverse their push order so that they
@@ -564,6 +555,7 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
                 {
                     // If we've already dealt with this target and it didn't skip, let's log appropriately
                     // Otherwise we don't want anything more to do with it.
+                    bool success = targetResult.ResultCode == TargetResultCode.Success;
                     var skippedTargetEventArgs = new TargetSkippedEventArgs(message: null)
                     {
                         BuildEventContext = _projectLoggingContext.BuildEventContext,
@@ -571,7 +563,9 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
                         TargetFile = currentTargetEntry.Target.Location.File,
                         ParentTarget = currentTargetEntry.ParentEntry?.Target.Name,
                         BuildReason = currentTargetEntry.BuildReason,
-                        OriginallySucceeded = targetResult.ResultCode == TargetResultCode.Success
+                        OriginallySucceeded = success,
+                        SkipReason = success ? TargetSkipReason.PreviouslyBuiltSuccessfully : TargetSkipReason.PreviouslyBuiltUnsuccessfully,
+                        OriginalBuildEventContext = targetResult.OriginalBuildEventContext
                     };
 
                     _projectLoggingContext.LogBuildEvent(skippedTargetEventArgs);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index f7543d5d91d..1314a3c173a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -354,7 +354,10 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
 
             if (!condition)
             {
-                _targetResult = new TargetResult(Array.Empty<TaskItem>(), new WorkUnitResult(WorkUnitResultCode.Skipped, WorkUnitActionCode.Continue, null));
+                _targetResult = new TargetResult(
+                    Array.Empty<TaskItem>(),
+                    new WorkUnitResult(WorkUnitResultCode.Skipped, WorkUnitActionCode.Continue, null),
+                    projectLoggingContext.BuildEventContext);
                 _state = TargetEntryState.Completed;
 
                 if (!projectLoggingContext.LoggingService.OnlyLogCriticalEvents)
@@ -375,6 +378,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                         TargetFile = _target.Location.File,
                         ParentTarget = ParentEntry?.Target?.Name,
                         BuildReason = BuildReason,
+                        SkipReason = TargetSkipReason.ConditionWasFalse,
                         Condition = _target.Condition,
                         EvaluatedCondition = expanded
                     };
@@ -640,14 +644,11 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 }
                 finally
                 {
-                       
-                    
-                        // log the last target finished since we now have the target outputs. 
-                        targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
-                    
+                    // log the last target finished since we now have the target outputs. 
+                    targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
                 }
 
-                _targetResult = new TargetResult(targetOutputItems.ToArray(), aggregateResult);
+                _targetResult = new TargetResult(targetOutputItems.ToArray(), aggregateResult, targetLoggingContext?.BuildEventContext);
 
                 if (aggregateResult.ResultCode == WorkUnitResultCode.Failed && aggregateResult.ActionCode == WorkUnitActionCode.Stop)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index 335dcf77097..9013bc11272 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -233,9 +233,17 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
 
                 if (result == DependencyAnalysisResult.SkipUpToDate)
                 {
-                    _loggingService.LogComment(_buildEventContext, MessageImportance.Normal,
-                        "SkipTargetBecauseOutputsUpToDate",
-                        TargetToAnalyze.Name);
+                    var skippedTargetEventArgs = new TargetSkippedEventArgs(message: null)
+                    {
+                        BuildEventContext = _buildEventContext,
+                        TargetName = TargetToAnalyze.Name,
+                        BuildReason = TargetBuiltReason.None,
+                        SkipReason = TargetSkipReason.OutputsUpToDate,
+                        OriginallySucceeded = true,
+                        Importance = MessageImportance.Normal
+                    };
+
+                    _loggingService.LogBuildEvent(skippedTargetEventArgs);
 
                     // Log the target inputs & outputs
                     if (!_loggingService.OnlyLogCriticalEvents)
@@ -337,7 +345,7 @@ private static string GetIncrementalBuildReason(DependencyAnalysisLogDetail logD
 
         /// <summary>
         /// Extract only the unique inputs and outputs from all the inputs and outputs gathered
-        /// during depedency analysis
+        /// during dependency analysis
         /// </summary>
         private void LogUniqueInputsAndOutputs()
         {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 5390d169443..85e71b2c2ba 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -847,7 +847,9 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     }
                     else if (type == typeof(ThreadAbortException))
                     {
+#if !NET6_0_OR_GREATER
                         Thread.ResetAbort();
+#endif
                         _continueOnError = ContinueOnError.ErrorAndStop;
 
                         // Cannot rethrow wrapped as ThreadAbortException is sealed and has no appropriate constructor
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 659066306cc..fa45800a6e9 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -131,8 +131,6 @@ internal class BuildRequestConfiguration : IEquatable<BuildRequestConfiguration>
         /// </summary>
         private string _savedCurrentDirectory;
 
-        private bool _translateEntireProjectInstanceState;
-
         #endregion
 
         /// <summary>
@@ -178,7 +176,6 @@ internal BuildRequestConfiguration(int configId, BuildRequestData data, string d
                 _project = data.ProjectInstance;
                 _projectInitialTargets = data.ProjectInstance.InitialTargets;
                 _projectDefaultTargets = data.ProjectInstance.DefaultTargets;
-                _translateEntireProjectInstanceState = data.ProjectInstance.TranslateEntireState;
 
                 if (data.PropertiesToTransfer != null)
                 {
@@ -216,7 +213,6 @@ internal BuildRequestConfiguration(int configId, ProjectInstance instance)
             _project = instance;
             _projectInitialTargets = instance.InitialTargets;
             _projectDefaultTargets = instance.DefaultTargets;
-            _translateEntireProjectInstanceState = instance.TranslateEntireState;
             IsCacheable = false;
         }
 
@@ -230,7 +226,6 @@ private BuildRequestConfiguration(int configId, BuildRequestConfiguration other)
             ErrorUtilities.VerifyThrow(other._transferredState == null, "Unexpected transferred state still set on other configuration.");
 
             _project = other._project;
-            _translateEntireProjectInstanceState = other._translateEntireProjectInstanceState;
             _transferredProperties = other._transferredProperties;
             _projectDefaultTargets = other._projectDefaultTargets;
             _projectInitialTargets = other._projectInitialTargets;
@@ -410,7 +405,6 @@ private void SetProjectBasedState(ProjectInstance project)
 
             ProjectDefaultTargets = _project.DefaultTargets;
             ProjectInitialTargets = _project.InitialTargets;
-            _translateEntireProjectInstanceState = _project.TranslateEntireState;
 
             if (IsCached)
             {
@@ -470,7 +464,6 @@ internal void LoadProjectIntoConfiguration(
                 {
                     projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
                 }
-
                 return new ProjectInstance(
                     ProjectFullPath,
                     globalProperties,
@@ -499,7 +492,7 @@ private void InitializeProject(BuildParameters buildParameters, Func<ProjectInst
             {
                 Project = loadProjectFromFile.Invoke();
             }
-            else if (_translateEntireProjectInstanceState)
+            else if (_project.TranslateEntireState)
             {
                 // projectInstance was serialized over. Finish initialization with node specific state
 
@@ -877,17 +870,14 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _toolsVersion);
             translator.Translate(ref _explicitToolsVersionSpecified);
             translator.TranslateDictionary(ref _globalProperties, ProjectPropertyInstance.FactoryForDeserialization);
-            translator.Translate(ref _translateEntireProjectInstanceState);
             translator.Translate(ref _transferredState, ProjectInstance.FactoryForDeserialization);
             translator.Translate(ref _transferredProperties, ProjectPropertyInstance.FactoryForDeserialization);
             translator.Translate(ref _resultsNodeId);
             translator.Translate(ref _savedCurrentDirectory);
             translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);
 
-            // if the entire state is translated, then the transferred state, if exists, represents the full evaluation data
-            if (_translateEntireProjectInstanceState &&
-                translator.Mode == TranslationDirection.ReadFromStream &&
-                _transferredState != null)
+            // if the  entire state is translated, then the transferred state represents the full evaluation data
+            if (translator.Mode == TranslationDirection.ReadFromStream && _transferredState?.TranslateEntireState == true)
             {
                 SetProjectBasedState(_transferredState);
             }
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 3eb907062e7..4969cdb7664 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -44,17 +44,30 @@ public class TargetResult : ITargetResult, ITranslatable
         /// </summary>
         private CacheInfo _cacheInfo;
 
+        /// <summary>
+        /// The (possibly null) <see cref="BuildEventContext"/> from the original target build
+        /// </summary>
+        private BuildEventContext _originalBuildEventContext;
+
         /// <summary>
         /// Initializes the results with specified items and result.
         /// </summary>
         /// <param name="items">The items produced by the target.</param>
         /// <param name="result">The overall result for the target.</param>
-        internal TargetResult(TaskItem[] items, WorkUnitResult result)
+        /// <param name="originalBuildEventContext">The original build event context from when the target was first built, if available.
+        /// Non-null when creating a <see cref="TargetResult"/> after building the target initially (or skipping due to false condition).
+        /// Null when the <see cref="TargetResult"/> is being created in other scenarios:
+        ///  * Target that never ran because a dependency had an error
+        ///  * in <see cref="ITargetBuilderCallback.LegacyCallTarget"/> when Cancellation was requested
+        ///  * in ProjectCache.CacheResult.ConstructBuildResult
+        /// </param>
+        internal TargetResult(TaskItem[] items, WorkUnitResult result, BuildEventContext originalBuildEventContext = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
             _items = items;
             _result = result;
+            _originalBuildEventContext = originalBuildEventContext;
         }
 
         /// <summary>
@@ -130,6 +143,11 @@ internal WorkUnitResult WorkUnitResult
             get => _result;
         }
 
+        /// <summary>
+        /// The (possibly null) <see cref="BuildEventContext"/> from the original target build
+        /// </summary>
+        internal BuildEventContext OriginalBuildEventContext => _originalBuildEventContext;
+
         /// <summary>
         /// Sets or gets a flag indicating whether or not a failure results should cause the build to fail.
         /// </summary>
@@ -253,6 +271,7 @@ private void InternalTranslate(ITranslator translator)
             translator.Translate(ref _result, WorkUnitResult.FactoryForDeserialization);
             translator.Translate(ref _targetFailureDoesntCauseBuildFailure);
             translator.Translate(ref _afterTargetsHaveFailed);
+            translator.TranslateOptionalBuildEventContext(ref _originalBuildEventContext);
             TranslateItems(translator);
         }
 
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 3888a265e50..bbd383cfe9b 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -66,7 +66,11 @@ internal class SolutionProjectGenerator
             "Build",
             "Clean",
             "Rebuild",
-            "Publish"
+            "Publish",
+            "ValidateSolutionConfiguration",
+            "ValidateToolsVersions",
+            "ValidateProjects",
+            "GetSolutionConfigurationContents"
             );
 
 #if FEATURE_ASPNET_COMPILER
@@ -781,8 +785,9 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
                 AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, "Rebuild", "BuildOutput", canBuildDirectly);
                 AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, "Publish", null, canBuildDirectly);
 
-                // Add any other targets specified by the user that were not already added
-                foreach (string targetName in _targetNames.Except(traversalInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
+                // Add any other targets specified by the user that were not already added. A target's presence or absence must be determined at the last
+                // minute because whether traversalInstance.Targets.ContainsKey(i) is true or not can change during the enumeration.
+                foreach (string targetName in _targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i)))
                 {
                     AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, targetName, null, canBuildDirectly);
                 }
@@ -796,7 +801,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
             }
 
             // Add any other targets specified by the user that were not already added
-            foreach (string targetName in _targetNames.Except(traversalInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
+            foreach (string targetName in _targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i)))
             {
                 AddTraversalReferencesTarget(traversalInstance, targetName, null);
             }
@@ -974,6 +979,10 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
                 _submissionId
                 );
 
+            // Traversal meta project entire state has to be serialized as it was generated and hence
+            // does not have disk representation to load project from.
+            traversalInstance.TranslateEntireState = true;
+
             // Make way for the real ones
             foreach (string targetName in dummyTargetsForEvaluationTime)
             {
@@ -1181,6 +1190,10 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
             // Create a new project instance with global properties and tools version from the existing project
             ProjectInstance metaprojectInstance = new ProjectInstance(EscapingUtilities.UnescapeAll(GetMetaprojectName(project)), traversalProject, GetMetaprojectGlobalProperties(traversalProject));
 
+            // Traversal meta project entire state has to be serialized as it was generated and hence
+            // does not have disk representation to load project from.
+            metaprojectInstance.TranslateEntireState = true;
+
             // Add the project references which must build before this one.
             AddMetaprojectReferenceItems(traversalProject, metaprojectInstance, project);
 
@@ -1201,7 +1214,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, "Rebuild");
                 AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, "Publish");
 
-                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
+                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
                 {
                     AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, targetName);
                 }
@@ -1221,7 +1234,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, "Rebuild", targetOutputItemName);
                 AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, "Publish", null);
 
-                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
+                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
                 {
                     AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, targetName, null);
                 }
@@ -1233,7 +1246,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, "Rebuild", unknownProjectTypeErrorMessage);
                 AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, "Publish", unknownProjectTypeErrorMessage);
 
-                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
+                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
                 {
                     AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, targetName, unknownProjectTypeErrorMessage);
                 }
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 470b4f0cb1e..827d9465d75 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -91,7 +91,7 @@ public static EvaluationContext Create(SharingPolicy policy, MSBuildFileSystemBa
         {
             var context = new EvaluationContext(
                 policy,
-                fileSystem == null ? null : new MSBuildFileSystemAdapter(fileSystem));
+                fileSystem);
 
             TestOnlyHookOnCreate?.Invoke(context);
 
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index c675c1108e8..d47f970c517 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1785,8 +1785,7 @@ static string EvaluateProperty(string value, IElementLocation location,
 
                 if (!sdkResult.Success)
                 {
-                    // Ignore the missing import if IgnoreMissingImports is set unless FailOnUnresolvedSdk is also set
-                    if (_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) && !_loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk))
+                    if (_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) && (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) || !_loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk)))
                     {
                         ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
                             importElement.Location.Line,
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 5fa15be5d91..80ddea0b0c2 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1200,19 +1200,22 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                             propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties);
                         }
 
-                        if (IsTruncationEnabled(options) && propertyValue != null)
+                        if (propertyValue != null)
                         {
-                            var value = propertyValue.ToString();
-                            if (value.Length > CharacterLimitPerExpansion)
+                            if (IsTruncationEnabled(options))
                             {
-                                propertyValue = value.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                                var value = propertyValue.ToString();
+                                if (value.Length > CharacterLimitPerExpansion)
+                                {
+                                    propertyValue = value.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                                }
                             }
-                        }
 
-                        // Record our result, and advance
-                        // our sourceIndex pointer to the character just after the closing
-                        // parenthesis.
-                        results.Add(propertyValue);
+                            // Record our result, and advance
+                            // our sourceIndex pointer to the character just after the closing
+                            // parenthesis.
+                            results.Add(propertyValue);
+                        }
                         sourceIndex = propertyEndIndex + 1;
                     }
 
diff --git a/src/Build/FileSystem/IFileSystemAdapter.cs b/src/Build/FileSystem/IFileSystemAdapter.cs
deleted file mode 100644
index dce1574702c..00000000000
--- a/src/Build/FileSystem/IFileSystemAdapter.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using Microsoft.Build.Shared.FileSystem;
-
-namespace Microsoft.Build.FileSystem
-{
-    internal class IFileSystemAdapter : MSBuildFileSystemBase
-    {
-        private readonly IFileSystem _wrappedFileSystem;
-
-        public IFileSystemAdapter(IFileSystem wrappedFileSystem)
-        {
-            _wrappedFileSystem = wrappedFileSystem;
-        }
-
-        public override TextReader ReadFile(string path)
-        {
-            return _wrappedFileSystem.ReadFile(path);
-        }
-
-        public override Stream GetFileStream(
-            string path,
-            FileMode mode,
-            FileAccess access,
-            FileShare share)
-        {
-            return _wrappedFileSystem.GetFileStream(
-                path,
-                mode,
-                access,
-                share);
-        }
-
-        public override string ReadFileAllText(string path)
-        {
-            return _wrappedFileSystem.ReadFileAllText(path);
-        }
-
-        public override byte[] ReadFileAllBytes(string path)
-        {
-            return _wrappedFileSystem.ReadFileAllBytes(path);
-        }
-
-        public override IEnumerable<string> EnumerateFiles(
-            string path,
-            string searchPattern = "*",
-            SearchOption searchOption = SearchOption.TopDirectoryOnly)
-        {
-            return _wrappedFileSystem.EnumerateFiles(path, searchPattern, searchOption);
-        }
-
-        public override IEnumerable<string> EnumerateDirectories(
-            string path,
-            string searchPattern = "*",
-            SearchOption searchOption = SearchOption.TopDirectoryOnly)
-        {
-            return _wrappedFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
-        }
-
-        public override IEnumerable<string> EnumerateFileSystemEntries(
-            string path,
-            string searchPattern = "*",
-            SearchOption searchOption = SearchOption.TopDirectoryOnly)
-        {
-            return _wrappedFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
-        }
-
-        public override FileAttributes GetAttributes(string path)
-        {
-            return _wrappedFileSystem.GetAttributes(path);
-        }
-
-        public override DateTime GetLastWriteTimeUtc(string path)
-        {
-            return _wrappedFileSystem.GetLastWriteTimeUtc(path);
-        }
-
-        public override bool DirectoryExists(string path)
-        {
-            return _wrappedFileSystem.DirectoryExists(path);
-        }
-
-        public override bool FileExists(string path)
-        {
-            return _wrappedFileSystem.FileExists(path);
-        }
-
-        public override bool FileOrDirectoryExists(string path)
-        {
-            return _wrappedFileSystem.DirectoryEntryExists(path);
-        }
-    }
-}
diff --git a/src/Build/FileSystem/MSBuildFileSystemAdapter.cs b/src/Build/FileSystem/MSBuildFileSystemAdapter.cs
deleted file mode 100644
index 4c69284d955..00000000000
--- a/src/Build/FileSystem/MSBuildFileSystemAdapter.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using Microsoft.Build.Shared.FileSystem;
-
-namespace Microsoft.Build.FileSystem
-{
-     internal class MSBuildFileSystemAdapter : IFileSystem
-    {
-        private readonly MSBuildFileSystemBase _msbuildFileSystem;
-        public MSBuildFileSystemAdapter(MSBuildFileSystemBase msbuildFileSystem)
-        {
-            _msbuildFileSystem = msbuildFileSystem;
-        }
-        public TextReader ReadFile(string path) => _msbuildFileSystem.ReadFile(path);
-
-        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => _msbuildFileSystem.GetFileStream(path, mode, access, share);
-
-        public string ReadFileAllText(string path) => _msbuildFileSystem.ReadFileAllText(path);
-
-        public byte[] ReadFileAllBytes(string path) => _msbuildFileSystem.ReadFileAllBytes(path);
-
-        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
-        {
-            return _msbuildFileSystem.EnumerateFiles(path, searchPattern, searchOption);
-        }
-
-        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
-        {
-            return _msbuildFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
-        }
-
-        public IEnumerable<string> EnumerateFileSystemEntries(
-            string path,
-            string searchPattern = "*",
-            SearchOption searchOption = SearchOption.TopDirectoryOnly)
-        {
-            return _msbuildFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
-        }
-
-        public FileAttributes GetAttributes(string path) => _msbuildFileSystem.GetAttributes(path);
-
-        public DateTime GetLastWriteTimeUtc(string path) => _msbuildFileSystem.GetLastWriteTimeUtc(path);
-
-        public bool DirectoryExists(string path) => _msbuildFileSystem.DirectoryExists(path);
-
-        public bool FileExists(string path) => _msbuildFileSystem.FileExists(path);
-
-        public bool DirectoryEntryExists(string path) => _msbuildFileSystem.FileOrDirectoryExists(path);
-    }
-}
diff --git a/src/Build/FileSystem/MSBuildFileSystemBase.cs b/src/Build/FileSystem/MSBuildFileSystemBase.cs
index 5383e717a9b..8855cd50da4 100644
--- a/src/Build/FileSystem/MSBuildFileSystemBase.cs
+++ b/src/Build/FileSystem/MSBuildFileSystemBase.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Shared.FileSystem;
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -14,66 +15,73 @@ namespace Microsoft.Build.FileSystem
     /// - must be thread safe
     /// - may cache some or all the calls.
     /// </summary>
-    public abstract class MSBuildFileSystemBase
+    public abstract class MSBuildFileSystemBase : IFileSystem
     {
+        #region IFileSystem implementation
+
         /// <summary>
         /// Use this for var sr = new StreamReader(path)
         /// </summary>
-        public abstract TextReader ReadFile(string path);
+        public virtual TextReader ReadFile(string path) => FileSystems.Default.ReadFile(path);
 
         /// <summary>
         /// Use this for new FileStream(path, mode, access, share)
         /// </summary>
-        public abstract Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
+        public virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => FileSystems.Default.GetFileStream(path, mode, access, share);
 
         /// <summary>
         /// Use this for File.ReadAllText(path)
         /// </summary>
-        public abstract string ReadFileAllText(string path);
+        public virtual string ReadFileAllText(string path) => FileSystems.Default.ReadFileAllText(path);
 
         /// <summary>
         /// Use this for File.ReadAllBytes(path)
         /// </summary>
-        public abstract byte[] ReadFileAllBytes(string path);
+        public virtual byte[] ReadFileAllBytes(string path) => FileSystems.Default.ReadFileAllBytes(path);
 
         /// <summary>
         /// Use this for Directory.EnumerateFiles(path, pattern, option)
         /// </summary>
-        public abstract IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+        public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+            => FileSystems.Default.EnumerateFiles(path, searchPattern, searchOption);
 
         /// <summary>
         /// Use this for Directory.EnumerateFolders(path, pattern, option)
         /// </summary>
-        public abstract IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+        public virtual IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+            => FileSystems.Default.EnumerateDirectories(path, searchPattern, searchOption);
 
         /// <summary>
         /// Use this for Directory.EnumerateFileSystemEntries(path, pattern, option)
         /// </summary>
-        public abstract IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+        public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+            => FileSystems.Default.EnumerateFileSystemEntries(path, searchPattern, searchOption);
 
         /// <summary>
         /// Use this for File.GetAttributes()
         /// </summary>
-        public abstract FileAttributes GetAttributes(string path);
+        public virtual FileAttributes GetAttributes(string path) => FileSystems.Default.GetAttributes(path);
 
         /// <summary>
         /// Use this for File.GetLastWriteTimeUtc(path)
         /// </summary>
-        public abstract DateTime GetLastWriteTimeUtc(string path);
+        public virtual DateTime GetLastWriteTimeUtc(string path) => FileSystems.Default.GetLastWriteTimeUtc(path);
 
         /// <summary>
         /// Use this for Directory.Exists(path)
         /// </summary>
-        public abstract bool DirectoryExists(string path);
+        public virtual bool DirectoryExists(string path) => FileSystems.Default.DirectoryExists(path);
 
         /// <summary>
         /// Use this for File.Exists(path)
         /// </summary>
-        public abstract bool FileExists(string path);
+        public virtual bool FileExists(string path) => FileSystems.Default.FileExists(path);
 
         /// <summary>
         /// Use this for File.Exists(path) || Directory.Exists(path)
         /// </summary>
-        public abstract bool FileOrDirectoryExists(string path);
+        public virtual bool FileOrDirectoryExists(string path) => FileSystems.Default.FileOrDirectoryExists(path);
+
+        #endregion
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index e29d3346621..b67aba3de21 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -564,8 +564,7 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
             _hostServices = that._hostServices;
             _isImmutable = isImmutable;
             _evaluationId = that.EvaluationId;
-
-            TranslateEntireState = that.TranslateEntireState;
+            _translateEntireState = that._translateEntireState;
 
             if (filter == null)
             {
@@ -849,23 +848,8 @@ public List<ProjectItemElement> EvaluatedItemElements
         /// </summary>
         public bool TranslateEntireState
         {
-            get
-            {
-                return Traits.Instance.EscapeHatches.ProjectInstanceTranslation switch
-                {
-                    EscapeHatches.ProjectInstanceTranslationMode.Full => true,
-                    EscapeHatches.ProjectInstanceTranslationMode.Partial => false,
-                    _ => _translateEntireState,
-                };
-            }
-
-            set
-            {
-                if (Traits.Instance.EscapeHatches.ProjectInstanceTranslation == null)
-                {
-                    _translateEntireState = value;
-                }
-            }
+            get => _translateEntireState;
+            set => _translateEntireState = value;
         }
 
         /// <summary>
@@ -899,8 +883,7 @@ public string Directory
         public string FullPath
         {
             [DebuggerStepThrough]
-            get
-            { return _projectFileLocation.File; }
+            get => _projectFileLocation?.File ?? string.Empty;
         }
 
         /// <summary>
@@ -2019,9 +2002,15 @@ internal void LateInitialize(ProjectRootElementCacheBase projectRootElementCache
         /// </summary>
         void ITranslatable.Translate(ITranslator translator)
         {
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                // When serializing into stream apply Traits.Instance.EscapeHatches.ProjectInstanceTranslation if defined.
+                MaybeForceTranslateEntireStateMode();
+            }
+
             translator.Translate(ref _translateEntireState);
 
-            if (TranslateEntireState)
+            if (_translateEntireState)
             {
                 TranslateAllState(translator);
             }
@@ -2031,6 +2020,27 @@ void ITranslatable.Translate(ITranslator translator)
             }
         }
 
+        private void MaybeForceTranslateEntireStateMode()
+        {
+            var forcedProjectInstanceTranslationMode = Traits.Instance.EscapeHatches.ProjectInstanceTranslation;
+            if (forcedProjectInstanceTranslationMode != null)
+            {
+                switch (forcedProjectInstanceTranslationMode)
+                {
+                    case EscapeHatches.ProjectInstanceTranslationMode.Full:
+                        _translateEntireState = true;
+                        break;
+                    case EscapeHatches.ProjectInstanceTranslationMode.Partial:
+                        _translateEntireState = false;
+                        break;
+                    default:
+                        // if EscapeHatches.ProjectInstanceTranslation has an unexpected value, do not force TranslateEntireStateMode.
+                        // Just leave it as is.
+                        break;
+                }
+            }
+        }
+
         internal void TranslateMinimalState(ITranslator translator)
         {
             translator.TranslateDictionary(ref _globalProperties, ProjectPropertyInstance.FactoryForDeserialization);
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 6bcd2951e2d..dac426db8b4 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -48,7 +48,10 @@ public sealed class BinaryLogger : ILogger
         // version 13:
         //   - don't log Message where it can be recovered
         //   - log arguments for LazyFormattedBuildEventArgs
-        internal const int FileFormatVersion = 13;
+        //   - TargetSkippedEventArgs: added OriginallySucceeded, Condition, EvaluatedCondition
+        // version 14:
+        //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext
+        internal const int FileFormatVersion = 14;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 47c1f6d8306..1d285b47c6b 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -297,6 +297,8 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
             string condition = null;
             string evaluatedCondition = null;
             bool originallySucceeded = false;
+            TargetSkipReason skipReason = TargetSkipReason.None;
+            BuildEventContext originalBuildEventContext = null;
             if (fileFormatVersion >= 13)
             {
                 condition = ReadOptionalString();
@@ -306,6 +308,12 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
 
             var buildReason = (TargetBuiltReason)ReadInt32();
 
+            if (fileFormatVersion >= 14)
+            {
+                skipReason = (TargetSkipReason)ReadInt32();
+                originalBuildEventContext = binaryReader.ReadOptionalBuildEventContext();
+            }
+
             var e = new TargetSkippedEventArgs(
                 fields.Message,
                 fields.Arguments);
@@ -320,6 +328,8 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
             e.Condition = condition;
             e.EvaluatedCondition = evaluatedCondition;
             e.OriginallySucceeded = originallySucceeded;
+            e.SkipReason = skipReason;
+            e.OriginalBuildEventContext = originalBuildEventContext;
 
             return e;
         }
@@ -535,6 +545,8 @@ private BuildEventArgs ReadTaskStartedEventArgs()
                 taskFile,
                 taskName,
                 fields.Timestamp);
+            e.LineNumber = fields.LineNumber;
+            e.ColumnNumber = fields.ColumnNumber;
             SetCommonFields(e, fields);
             return e;
         }
@@ -658,7 +670,9 @@ private BuildEventArgs ReadTaskParameterEventArgs()
                 itemType,
                 items,
                 logItemMetadata: true,
-                fields.Timestamp);
+                fields.Timestamp,
+                fields.LineNumber,
+                fields.ColumnNumber);
             e.ProjectFile = fields.ProjectFile;
             return e;
         }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 20cd4232cb2..f0de05860eb 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -370,7 +370,9 @@ private void Write(TargetFinishedEventArgs e)
         private void Write(TaskStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskStarted);
-            WriteBuildEventArgsFields(e, writeMessage: false);
+            WriteBuildEventArgsFields(e, writeMessage: false, writeLineAndColumn: true);
+            Write(e.LineNumber);
+            Write(e.ColumnNumber);
             WriteDeduplicatedString(e.TaskName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TaskFile);
@@ -445,6 +447,8 @@ private void Write(ProjectImportedEventArgs e)
 
         private void Write(TargetSkippedEventArgs e)
         {
+            ErrorUtilities.VerifyThrow(e.SkipReason != TargetSkipReason.None, "TargetSkippedEventArgs.SkipReason needs to be set");
+
             Write(BinaryLogRecordKind.TargetSkipped);
             WriteMessageFields(e, writeMessage: false);
             WriteDeduplicatedString(e.TargetFile);
@@ -454,6 +458,8 @@ private void Write(TargetSkippedEventArgs e)
             WriteDeduplicatedString(e.EvaluatedCondition);
             Write(e.OriginallySucceeded);
             Write((int)e.BuildReason);
+            Write((int)e.SkipReason);
+            binaryWriter.WriteOptionalBuildEventContext(e.OriginalBuildEventContext);
         }
 
         private void Write(CriticalBuildMessageEventArgs e)
@@ -512,9 +518,14 @@ private void Write(TaskParameterEventArgs e)
             WriteTaskItemList(e.Items, e.LogItemMetadata);
         }
 
-        private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true)
+        private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true, bool writeLineAndColumn = false)
         {
             var flags = GetBuildEventArgsFieldFlags(e, writeMessage);
+            if (writeLineAndColumn)
+            {
+                flags |= BuildEventArgsFieldFlags.LineNumber | BuildEventArgsFieldFlags.ColumnNumber;
+            }
+
             Write((int)flags);
             WriteBaseFields(e, flags);
         }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 43d9b794046..8b51e260d1f 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -4,8 +4,8 @@
   <Import Project="..\Shared\DebuggingSources.proj" />
 
   <PropertyGroup>
-    <TargetFrameworks>net5.0</TargetFrameworks>
-    <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);net5.0</TargetFrameworks>
+    <TargetFrameworks>net6.0</TargetFrameworks>
+    <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);net6.0</TargetFrameworks>
     <TargetFrameworks Condition="'$(MonoBuild)'=='true'">$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <RootNamespace>Microsoft.Build</RootNamespace>
     <AssemblyName>Microsoft.Build</AssemblyName>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index a005bbc5a4e..f223fa5d580 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
@@ -140,7 +140,7 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">Načítá se následující modul plug-in mezipaměti projektu:
+        <target state="translated">Načítá se následující modul plug-in mezipaměti projektu:
     {0}</target>
         <note />
       </trans-unit>
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: Mezipaměť projektu vyvolala neošetřenou výjimku z metody {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">Úloha {0} požadovala tento počet jader: {1}. Získala tento počet jader: {2}. Teď používá celkem tento počet jader: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">Úloha {0} uvolnila tento počet jader: {1}. Teď používá celkem tento počet jader: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">Úloha {0} požádala o uvolnění určitého počtu jader ({1}), když jich používala pouze {2}. Teď používá celkem tento počet jader: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 91850b56a54..14323a1cb89 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"Folgendes Projektcache-Plug-In wird geladen:
-    {0}"</target>
+        <target state="translated">Folgendes Projektcache-Plug-In wird geladen:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: Der Projektcache hat über die Methode {0} eine unbehandelte Ausnahme ausgelöst.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">Die Aufgabe "{0}" hat {1} Kerne angefordert und {2} Kerne erhalten und belegt jetzt insgesamt {3} Kerne.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">Die Aufgabe "{0}" hat {1} Kerne freigegeben und belegt jetzt insgesamt {2} Kerne.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">Die Aufgabe "{0}" hat die Freigabe von {1} Kernen angefordert, während sie nur {2} Kerne verwendet, und belegt jetzt insgesamt {3} Kerne.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 8e6962329b5..3ada5cb3c4a 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"Cargando el complemento de caché de proyectos siguiente:
-    {0} "</target>
+        <target state="translated">Cargando el complemento de caché de proyectos siguiente:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">Solo se puede hacer referencia a los objetos de tipo elemento al quitar con MatchOnMetadata</target>
+        <target state="translated">Solo se puede hacer referencia a los tipos de elemento al quitar con MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: la caché del proyecto inició una excepción no controlada desde el método {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">La tarea "{0}" solicitó {1} núcleos, adquirió {2} núcleos y ahora retiene un total de {3} núcleos.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">La tarea "{0}" liberó {1} núcleos y ahora retiene un total de {2} núcleos.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">La tarea "{0}" solicitó liberar {1} núcleos y retenía solo {2} y ahora retiene un total de {3} núcleos.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index b5ee6552148..90105ef4478 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"Chargement du plug-in de cache de projet suivant :
-    {0}"</target>
+        <target state="translated">Chargement du plug-in de cache de projet suivant:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">La tâche "{0}" a demandé {1} cœurs et a obtenu {2} cœurs. Elle détient désormais {3} cœurs au total.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">La tâche "{0}" a libéré {1} cœur. Elle détient désormais {2} cœurs au total.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">La tâche "{0}" a demandé à libérer {1} cœurs alors qu'elle n'en détient que {2}. Elle détient désormais {3} cœurs au total.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index dd24c5f953f..6711613ae06 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"Caricamento del plug-in seguente della cache del progetto:
-    {0}"</target>
+        <target state="translated">Caricamento del plug-in seguente della cache del progetto:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: la cache del progetto ha generato un'eccezione non gestita dal metodo {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">L'attività "{0}" ha richiesto {1} core, ha acquisito {2} core e ora contiene {3} core in totale.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">L'attività "{0}" ha rilasciato {1} core e ora contiene {2} core in totale.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">L'attività "{0}" ha chiesto il rilascio di {1} core contenendone solo {2} e ora contiene {3} core in totale.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 9bb48532bc8..aa758e3a206 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"次のプロジェクト キャッシュ プラグインを読み込んでいます。
-    {0}"</target>
+        <target state="translated">次のプロジェクト キャッシュ プラグインを読み込んでいます。
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: プロジェクト キャッシュが {0} メソッドで処理されていない例外が返されました。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">タスク "{0}" では、{1} 個のコアを要求し、{2} 個のコアを取得したため、現在合計 {3} 個のコアを保持しています。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">タスク "{0}" では、{1} 個のコアを解放したため、現在合計 {2} 個のコアを保持しています。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">タスク "{0}" では、{2} 個のコアのみを保持したまま {1} 個のコアを解放するよう要求したため、現在合計 {3} 個のコアを保持しています。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 5d7d4163bd2..af1e71f0f9a 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"다음 프로젝트 캐시 플러그 인을 로드하는 중:
-    {0}"</target>
+        <target state="translated">다음 프로젝트 캐시 플러그 인을 로드하는 중:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: 프로젝트 캐시는 {0} 메서드에서 처리되지 않은 예외를 발생시켰습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">"{0}" 작업에서 코어 {1}개를 요청했고 코어 {2}개를 획득했으며 지금 총 {3}개의 코어를 보유하고 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">"{0}" 작업에서 코어 {1}개를 해제했고 지금 총 {2}개의 코어를 보유하고 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">"{0}" 작업에서 코어 {2}개만 보유하고 있는 동안 코어 {1}개를 해제하도록 요청했고 지금 총 {3}개의 코어를 보유하고 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 1d00d687697..791c924d51e 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">„Ładowanie następującej wtyczki pamięci podręcznej projektu:
-    {0}”</target>
+        <target state="translated">Ładowanie następującej wtyczki pamięci podręcznej projektu: 
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: pamięć podręczna projektu zgłosiła nieobsługiwany wyjątek z metody {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">Zadanie „{0}” żądało {1} rdzeni, uzyskało {2} i teraz jego łączna liczba rdzeni to {3}.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">Zadanie „{0}” zwolniło rdzenie ({1}) i teraz jego łączna liczba rdzeni to {2}.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">Zadanie „{0}” poproszono o zwolnienie {1} rdzeni, gdy miało tylko {2}. Teraz jego łączna liczba rdzeni to {3}.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 423af0d4199..a3c9bafe4a3 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"Carregando o seguinte plug-in de cache do projeto:
-    {0}"</target>
+        <target state="translated">Carregando o seguinte plug-in do projeto:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: O cache do projeto lançou uma exceção sem tratamento do método {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">A tarefa "{0}" solicitou {1} núcleos, adquiriu {2} núcleos e agora contém {3} núcleos no total.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">A tarefa "{0}" liberou {1} núcleos e agora contém {2} núcleos no total.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">A tarefa "{0}" solicitou a liberação de {1} núcleos enquanto continha somente {2} e agora contém {3} núcleos no total.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 2381c6ed244..ea7ac3894a8 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"Идет загрузка следующего подключаемого модуля кэша проектов:
-    {0}"</target>
+        <target state="translated">Идет загрузка следующего подключаемого модуля кэша проектов:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: в кэше проектов возникло необработанное исключение из метода {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">Задача "{0}" запросила указанное число ядер ({1}) и получила указанное число ядер ({2}). Теперь общее число ядер, которыми располагает задача, равно {3}.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">Задача "{0}" освободила указанное число ядер ({1}). Теперь общее число ядер, которыми располагает задача, равно {2}.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">Задача "{0}" запросила освобождение указанного числа ядер ({1}) с текущим числом ядер {2}. Теперь общее число ядер, которыми располагает задача, равно {3}.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 51c4e1c7d52..095ce39a05d 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"Şu proje önbelleği eklentisi yükleniyor:
-    {0}"</target>
+        <target state="translated">Şu proje önbelleği eklentisi yükleniyor:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: Proje önbelleği {0} yönteminden yakalanamayan özel durum oluşturdu.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">"{0}" görevi {1} çekirdek istedi, {2} çekirdek aldı ve şu anda toplam {3} çekirdek tutuyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">"{0}" görevi {1} çekirdeği serbest bıraktı. Şu anda toplam {2} çekirdek tutuyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">"{0}" görevi yalnızca {2} tutarken {1} çekirdeği serbest bırakmak istedi. Şu anda toplam {3} çekirdek tutuyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 2bf484357b9..b976c8e4d9d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANS" original="../Strings.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
@@ -140,7 +140,7 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">“正在加载以下项目缓存插件:
+        <target state="translated">正在加载以下项目缓存插件: 
     {0}”</target>
         <note />
       </trans-unit>
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: 项目缓存从 {0} 方法引发了未经处理的异常。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">任务“{0}”请求了 {1} 个核心，已获取 {2} 个核心，现总共包含 {3} 个核心。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">任务“{0}”发布了 {1} 个核心，现总共包含 {2} 个核心。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">任务“{0}”要求在仅保留 {2} 时发布 {1} 个核心，它现总共包含 {3} 个核心。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index f4f05481636..ddebd381fbe 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANT" original="../Strings.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
@@ -140,8 +140,8 @@
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin:
     {0}</source>
-        <target state="needs-review-translation">"正在載入下列專案快取外掛程式:
-    {0}"</target>
+        <target state="translated">正在載入下列專案快取外掛程式:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: 專案快取從 {0} 方法擲回未處理的例外狀況。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -305,17 +305,17 @@
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <target state="translated">工作 "{0}" 已要求 {1} 個核心、已取得 {2} 個核心，現在共保留 {3} 個核心。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
-        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <target state="translated">工作 "{0}" 已發行 {1} 個核心，現在共保留 {2} 個核心。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCoresWarning">
         <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
-        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <target state="translated">工作 "{0}" 要求在僅保留 {2} 個核心的情況下發行 {1} 個核心，現在共保留 {3} 個核心。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 373a024e26c..3bb52fd3d73 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -32,11 +32,7 @@ public NuGetFrameworkWrapper()
                 BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
             try
             {
-#if FEATURE_ASSEMBLYLOADCONTEXT
-                var NuGetAssembly = Assembly.LoadFrom(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
-#else
                 var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
-#endif
                 var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
                 var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
                 var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
diff --git a/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hans.xlf b/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hans.xlf
index 9be41b54168..4134008b926 100644
--- a/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANS" original="../Strings.resx" build-num="-1522637684">
+  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx" build-num="-1522637684">
     <header>
       <count-group name="BlackBox wordcount">
         <count count-type="x-wordCount">231</count>
diff --git a/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hant.xlf b/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hant.xlf
index 6c6a6ffd474..c5ae79dc07c 100644
--- a/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANT" original="../Strings.resx" build-num="-1522637684">
+  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx" build-num="-1522637684">
     <header>
       <count-group name="BlackBox wordcount">
         <count count-type="x-wordCount">231</count>
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hans.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hans.xlf
index dbc31774594..031b8bc6e53 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANS" original="../Strings.resx" build-num="-1944534404">
+  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx" build-num="-1944534404">
     <header>
       <count-group name="BlackBox wordcount">
         <count count-type="x-wordCount">4013</count>
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
index b90dd842476..52c6f2222ec 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANT" original="../Strings.resx" build-num="-1944534404">
+  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx" build-num="-1944534404">
     <header>
       <count-group name="BlackBox wordcount">
         <count count-type="x-wordCount">4013</count>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 9bafce8e113..3eef42593b4 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -124,7 +124,7 @@
     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>
   </PropertyGroup>
 
-  <PropertyGroup Condition="'$(TargetFramework)' == 'netcoreapp2.1' or '$(TargetFramework)' == 'net5.0'">
+  <PropertyGroup Condition="'$(TargetFramework)' == 'netcoreapp2.1' or '$(TargetFramework)' == 'net6.0'">
     <DefineConstants>$(DefineConstants);FEATURE_PIPEOPTIONS_CURRENTUSERONLY</DefineConstants>
     <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_NODE_REUSE</DefineConstants>
   </PropertyGroup>
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index d91dd8521f6..b7413f2ced0 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -32,7 +32,7 @@
     <PlatformTarget>AnyCPU</PlatformTarget>
 
     <!-- Target frameworks for Exe and unit test projects (ie projects with runtime output) -->
-    <RuntimeOutputTargetFrameworks>net5.0</RuntimeOutputTargetFrameworks>
+    <RuntimeOutputTargetFrameworks>net6.0</RuntimeOutputTargetFrameworks>
     <RuntimeOutputTargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows')) and '$(DotNetBuildFromSource)' != 'true'">$(FullFrameworkTFM);$(RuntimeOutputTargetFrameworks)</RuntimeOutputTargetFrameworks>
     <RuntimeOutputTargetFrameworks Condition="'$(MonoBuild)' == 'true'">$(FullFrameworkTFM)</RuntimeOutputTargetFrameworks>
 
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 45bbe9dc150..8e0072633ea 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -78,10 +78,9 @@
   <PropertyGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
     <GenAPIAssemblyName>$(AssemblyName)</GenAPIAssemblyName>
     <GenAPIAssemblyName Condition="'$(GenAPIAssemblyName)' == ''">$(MSBuildProjectName)</GenAPIAssemblyName>
-    <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('net4'))">net</GenAPIShortFrameworkIdentifier>
+    <GenAPIShortFrameworkIdentifier Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework' ">net</GenAPIShortFrameworkIdentifier>
     <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('netstandard'))">netstandard</GenAPIShortFrameworkIdentifier>
-    <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('netcoreapp'))">netstandard</GenAPIShortFrameworkIdentifier>
-    <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('net5'))">netstandard</GenAPIShortFrameworkIdentifier>
+    <GenAPIShortFrameworkIdentifier Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp1.0'))">netstandard</GenAPIShortFrameworkIdentifier>
     <GenAPITargetPath>$(RepoRoot)ref\$(GenAPIAssemblyName)\$(GenAPIShortFrameworkIdentifier)\$(GenAPIAssemblyName).cs</GenAPITargetPath>
   </PropertyGroup>
 
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index edde77d5fbb..0cda93d76c6 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -306,5 +306,9 @@ private bool InternalEquals(BuildEventContext buildEventContext)
         }
         #endregion
 
+        public override string ToString()
+        {
+            return $"Node={NodeId} Submission={SubmissionId} ProjectContext={ProjectContextId} ProjectInstance={ProjectInstanceId} Eval={EvaluationId} Target={TargetId} Task={TaskId}";
+        }
     }
 }
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index 23282a1db87..e84c9ed6c02 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -302,7 +302,11 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// <summary>
         /// Importance of the message
         /// </summary>
-        public MessageImportance Importance => importance;
+        public MessageImportance Importance
+        {
+            get => importance;
+            internal set => importance = value;
+        }
 
         /// <summary>
         /// The custom sub-type of the event.
@@ -322,12 +326,20 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// <summary>
         /// Line number of interest in associated file. 
         /// </summary>
-        public int LineNumber => lineNumber;
+        public int LineNumber
+        {
+            get => lineNumber;
+            internal set => lineNumber = value;
+        }
 
         /// <summary>
         /// Column number of interest in associated file. 
         /// </summary>
-        public int ColumnNumber => columnNumber;
+        public int ColumnNumber
+        {
+            get => columnNumber;
+            internal set => columnNumber = value;
+        }
 
         /// <summary>
         /// Ending line number of interest in associated file. 
diff --git a/src/Framework/TargetSkippedEventArgs.cs b/src/Framework/TargetSkippedEventArgs.cs
index 5bad19a7251..d34e468ff32 100644
--- a/src/Framework/TargetSkippedEventArgs.cs
+++ b/src/Framework/TargetSkippedEventArgs.cs
@@ -7,6 +7,37 @@
 
 namespace Microsoft.Build.Framework
 {
+    /// <summary>
+    /// A reason why a target was skipped.
+    /// </summary>
+    public enum TargetSkipReason
+    {
+        /// <summary>
+        /// The target was not skipped or the skip reason was unknown.
+        /// </summary>
+        None,
+
+        /// <summary>
+        /// The target previously built successfully.
+        /// </summary>
+        PreviouslyBuiltSuccessfully,
+
+        /// <summary>
+        /// The target previously built unsuccessfully.
+        /// </summary>
+        PreviouslyBuiltUnsuccessfully,
+
+        /// <summary>
+        /// All the target outputs were up-to-date with respect to their inputs.
+        /// </summary>
+        OutputsUpToDate,
+
+        /// <summary>
+        /// The condition on the target was evaluated as false.
+        /// </summary>
+        ConditionWasFalse
+    }
+
     /// <summary>
     /// Arguments for the target skipped event.
     /// </summary>
@@ -45,6 +76,11 @@ params object[] messageArgs
         {
         }
 
+        /// <summary>
+        /// The reason why the target was skipped.
+        /// </summary>
+        public TargetSkipReason SkipReason { get; set; }
+
         /// <summary>
         /// Gets or sets the name of the target being skipped.
         /// </summary>
@@ -65,10 +101,24 @@ params object[] messageArgs
         /// </summary>
         public TargetBuiltReason BuildReason { get; set; }
 
+        /// <summary>
+        /// Whether the target succeeded originally.
+        /// </summary>
         public bool OriginallySucceeded { get; set; }
 
+        /// <summary>
+        /// <see cref="BuildEventContext"/> describing the original build of the target, or null if not available.
+        /// </summary>
+        public BuildEventContext OriginalBuildEventContext { get; set; }
+
+        /// <summary>
+        /// The condition expression on the target declaration.
+        /// </summary>
         public string Condition { get; set; }
 
+        /// <summary>
+        /// The value of the condition expression as it was evaluated.
+        /// </summary>
         public string EvaluatedCondition { get; set; }
 
         internal override void WriteToStream(BinaryWriter writer)
@@ -81,7 +131,9 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(Condition);
             writer.WriteOptionalString(EvaluatedCondition);
             writer.Write7BitEncodedInt((int)BuildReason);
+            writer.Write7BitEncodedInt((int)SkipReason);
             writer.Write(OriginallySucceeded);
+            writer.WriteOptionalBuildEventContext(OriginalBuildEventContext);
         }
 
         internal override void CreateFromStream(BinaryReader reader, int version)
@@ -94,7 +146,9 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             Condition = reader.ReadOptionalString();
             EvaluatedCondition = reader.ReadOptionalString();
             BuildReason = (TargetBuiltReason)reader.Read7BitEncodedInt();
+            SkipReason = (TargetSkipReason)reader.Read7BitEncodedInt();
             OriginallySucceeded = reader.ReadBoolean();
+            OriginalBuildEventContext = reader.ReadOptionalBuildEventContext();
         }
 
         public override string Message
@@ -107,22 +161,29 @@ public override string Message
                     {
                         if (RawMessage == null)
                         {
-                            if (Condition != null)
-                            {
-                                RawMessage = FormatResourceStringIgnoreCodeAndKeyword(
-                                    "TargetSkippedFalseCondition",
-                                    TargetName,
-                                    Condition,
-                                    EvaluatedCondition);
-                            }
-                            else
+                            RawMessage = SkipReason switch
                             {
-                                RawMessage = FormatResourceStringIgnoreCodeAndKeyword(
-                                    OriginallySucceeded
-                                    ? "TargetAlreadyCompleteSuccess"
-                                    : "TargetAlreadyCompleteFailure",
-                                    TargetName);
-                            }
+                                TargetSkipReason.PreviouslyBuiltSuccessfully or TargetSkipReason.PreviouslyBuiltUnsuccessfully =>
+                                    FormatResourceStringIgnoreCodeAndKeyword(
+                                        OriginallySucceeded
+                                        ? "TargetAlreadyCompleteSuccess"
+                                        : "TargetAlreadyCompleteFailure",
+                                        TargetName),
+
+                                TargetSkipReason.ConditionWasFalse =>
+                                    FormatResourceStringIgnoreCodeAndKeyword(
+                                        "TargetSkippedFalseCondition",
+                                        TargetName,
+                                        Condition,
+                                        EvaluatedCondition),
+
+                                TargetSkipReason.OutputsUpToDate =>
+                                    FormatResourceStringIgnoreCodeAndKeyword(
+                                        "SkipTargetBecauseOutputsUpToDate",
+                                        TargetName),
+
+                                _ => SkipReason.ToString()
+                            };
                         }
                     }
                 }
diff --git a/src/Framework/TaskParameterEventArgs.cs b/src/Framework/TaskParameterEventArgs.cs
index b4efc953e84..1ca1a55f7ad 100644
--- a/src/Framework/TaskParameterEventArgs.cs
+++ b/src/Framework/TaskParameterEventArgs.cs
@@ -87,6 +87,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             BuildEventContext = reader.ReadOptionalBuildEventContext();
             Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();
             ItemType = reader.ReadOptionalString();
+            LineNumber = reader.Read7BitEncodedInt();
+            ColumnNumber = reader.Read7BitEncodedInt();
             Items = ReadItems(reader);
         }
 
@@ -134,6 +136,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalBuildEventContext(BuildEventContext);
             writer.Write7BitEncodedInt((int)Kind);
             writer.WriteOptionalString(ItemType);
+            writer.Write7BitEncodedInt(LineNumber);
+            writer.Write7BitEncodedInt(ColumnNumber);
             WriteItems(writer, Items);
         }
 
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index ce50a3b7723..207d20472d2 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -91,6 +91,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(taskName);
             writer.WriteOptionalString(projectFile);
             writer.WriteOptionalString(taskFile);
+            writer.Write7BitEncodedInt(LineNumber);
+            writer.Write7BitEncodedInt(ColumnNumber);
         }
 
         /// <summary>
@@ -105,6 +107,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             taskName = reader.ReadByte() == 0 ? null : reader.ReadString();
             projectFile = reader.ReadByte() == 0 ? null : reader.ReadString();
             taskFile = reader.ReadByte() == 0 ? null : reader.ReadString();
+            LineNumber = reader.Read7BitEncodedInt();
+            ColumnNumber = reader.Read7BitEncodedInt();
         }
         #endregion
 
@@ -123,6 +127,16 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// </summary>
         public string TaskFile => taskFile;
 
+        /// <summary>
+        /// Line number of the task invocation in the project file
+        /// </summary>
+        public int LineNumber { get; internal set; }
+
+        /// <summary>
+        /// Column number of the task invocation in the project file
+        /// </summary>
+        public int ColumnNumber { get; internal set; }
+
         public override string Message
         {
             get
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index dd786dfbed2..af47eedfc65 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -48,7 +48,7 @@
   <Target Name="UpdateMSBuildDepsFile" AfterTargets="Build" Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp2.1')) or '$(TargetFramework)' == 'netstandard2.0')">
     <Copy SourceFiles="$(OutputPath)$(AssemblyName).deps.json" DestinationFiles="$(OutputPath)MSBuild.deps.json" />
   </Target>
-  <Target Name="UpdatePublishedMSBuildDepsFile" AfterTargets="Publish" Condition="'$(TargetFramework)' == 'net5.0'">
+  <Target Name="UpdatePublishedMSBuildDepsFile" AfterTargets="Publish" Condition="'$(TargetFramework)' == 'net6.0'">
     <Copy SourceFiles="$(PublishDir)$(AssemblyName).deps.json" DestinationFiles="$(PublishDir)MSBuild.deps.json" />
   </Target>
 
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index d84158d112e..be9203b581a 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -74,10 +74,4 @@
     <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
   </ItemGroup>
 
-  <Target Name="CreateTaskDir" AfterTargets="Build" Condition="'$(TargetFrameworkIdentifier)' != ''">
-    <ItemGroup>
-      <OutputAssemblyList Include="$(TargetDir)Microsoft.Build.CommandLine.UnitTests.dll" />
-    </ItemGroup>
-    <Copy SourceFiles="@(OutputAssemblyList)" DestinationFolder="$(TargetDir)Task" />
-  </Target>
 </Project>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 1513d20e3f9..8c918a9fda0 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -19,7 +19,6 @@
 using Shouldly;
 using System.IO.Compression;
 using System.Reflection;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -2128,105 +2127,6 @@ public void RestoreFailsOnUnresolvedSdk()
             logContents.ShouldContain("error MSB4236: The SDK 'UnresolvedSdk' specified could not be found.");
         }
 
-        /// <summary>
-        /// When specifying /t:restore under an old changewave, do not fail when an SDK can't be resolved.
-        /// Previous behavior was to try and continue anyway but then "restore" would succeed and build workflows continue on.
-        /// </summary>
-        [Fact]
-        public void RestorePassesOnUnresolvedSdkUnderChangewave()
-        {
-            string projectContents = ObjectModelHelpers.CleanupFileContents(
-$@"<Project>
-  <Sdk Name=""UnresolvedSdk"" />
-  <Target Name=""Restore"">
-    <Message Text=""Restore target ran"" />
-  </Target>
-</Project>");
-
-            using TestEnvironment env = Microsoft.Build.UnitTests.TestEnvironment.Create();
-
-            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents,
-                envsToCreate: new Dictionary<string, string>() { ["MSBUILDDISABLEFEATURESFROMVERSION"]=ChangeWaves.Wave16_10.ToString() },
-                arguments: " /t:restore");
-
-            logContents.ShouldNotContain("MSB4236");
-        }
-
-
-        /// <summary>
-        /// Verifies a non-existent target doesn't fail restore as long as its not considered an entry target, in this case Restore.
-        /// </summary>
-        [Fact]
-        public void RestoreSkipsNonExistentNonEntryTargets()
-        {
-            string restoreFirstProps = $"{Guid.NewGuid():N}.props";
-
-            string projectContents = ObjectModelHelpers.CleanupFileContents(
-$@"<Project DefaultTargets=""Build"" InitialTargets=""TargetThatComesFromRestore"">
-  <PropertyGroup>
-    <RestoreFirstProps>{restoreFirstProps}</RestoreFirstProps>
-  </PropertyGroup>
-  
-  <Import Project=""$(RestoreFirstProps)"" />
-  <Target Name=""Restore"">
-    <Message Text=""Restore target ran"" />
-    <ItemGroup>
-      <Lines Include=""&lt;Project&gt;&lt;Target Name=&quot;TargetThatComesFromRestore&quot;&gt;&lt;Message Text=&quot;Initial target ran&quot; /&gt;&lt;/Target&gt;&lt;/Project&gt;"" />
-    </ItemGroup>
-    
-    <WriteLinesToFile File=""$(RestoreFirstProps)"" Lines=""@(Lines)"" Overwrite=""true"" />
-  </Target>
-
-  <Target Name=""Build"">
-    <Message Text=""Build target ran&quot;"" />
-  </Target>
-</Project>");
-
-            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents, arguments: "/restore");
-
-            logContents.ShouldContain("Restore target ran");
-            logContents.ShouldContain("Build target ran");
-            logContents.ShouldContain("Initial target ran");
-        }
-
-        /// <summary>
-        /// Verifies restore will fail if the entry target doesn't exist, in this case Restore.
-        /// </summary>
-        [Fact]
-        public void RestoreFailsWhenEntryTargetIsNonExistent()
-        {
-            string projectContents = ObjectModelHelpers.CleanupFileContents(
-@"<Project DefaultTargets=""Build"">
-  <Target Name=""Build"">
-    <Message Text=""Build target ran&quot;"" />
-  </Target>
-</Project>");
-
-            string logContents = ExecuteMSBuildExeExpectFailure(projectContents, arguments: "/t:restore");
-            
-            logContents.ShouldContain("error MSB4057: The target \"Restore\" does not exist in the project.");
-        }
-
-        /// <summary>
-        /// Verifies restore will not fail if the entry target doesn't exist, when changewave applied.
-        /// </summary>
-        [Fact]
-        public void RestorePassesWhenEntryTargetIsNonExistentUnderChangewave()
-        {
-            string projectContents = ObjectModelHelpers.CleanupFileContents(
-@"<Project DefaultTargets=""Build"">
-  <Target Name=""Build"">
-    <Message Text=""Build target ran&quot;"" />
-  </Target>
-</Project>");
-
-            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents,
-                envsToCreate: new Dictionary<string, string>() { ["MSBUILDDISABLEFEATURESFROMVERSION"] = ChangeWaves.Wave16_10.ToString() },
-                arguments: "/t:restore");
-
-            logContents.ShouldNotContain("MSB4057");
-        }
-
         /// <summary>
         /// Verifies restore will run InitialTargets.
         /// </summary>
@@ -2238,11 +2138,9 @@ public void RestoreRunsInitialTargets()
   <Target Name=""InitialTarget"">
     <Message Text=""InitialTarget target ran&quot;"" />
   </Target>
-
   <Target Name=""Restore"">
     <Message Text=""Restore target ran&quot;"" />
   </Target>
-
   <Target Name=""Build"">
     <Message Text=""Build target ran&quot;"" />
   </Target>
@@ -2381,10 +2279,54 @@ public void EndToEndWarnAsErrors()
             success.ShouldBeFalse();
         }
 
+        [Trait("Category", "netcore-osx-failing")]
+        [Trait("Category", "netcore-linux-failing")]
+        [Fact]
+        public void BuildSlnOutOfProc()
+        {
+            using (TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create())
+            {
+                string solutionFileContents =
+                    @"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'TestProject', 'TestProject.proj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+EndProject
+Global
+    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+        Debug|Mixed Platforms = Debug|Mixed Platforms
+        Release|Any CPU = Release|Any CPU
+    EndGlobalSection
+    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.ActiveCfg = CSConfig1|Any CPU
+        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.Build.0 = CSConfig1|Any CPU
+    EndGlobalSection
+EndGlobal
+                    ".Replace("'", "\"");
+
+                var testSolution = testEnvironment.CreateFile("TestSolution.sln", ObjectModelHelpers.CleanupFileContents(solutionFileContents));
+
+                string testMessage = "Hello from TestProject!";
+                testEnvironment.CreateFile("TestProject.proj", @$"
+                <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+                  <Target Name=""Build"">
+                    <Message Text=""{testMessage}"" />
+                  </Target>
+                </Project>
+                ");
+
+                testEnvironment.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+
+                string output = RunnerUtilities.ExecMSBuild($"\"{testSolution.Path}\" /p:Configuration=Debug", out var success, _output);
+
+                success.ShouldBeTrue(output);
+                output.ShouldContain(testMessage);
+            }
+        }
+
 #if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
-        /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>
-        /// if they are in a directory other than the MSBuild directory.
+        /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>.
         /// </summary>
         /// <remarks>
         /// When loading a task from a test assembly in a test within that assembly, the assembly is already loaded
@@ -2394,10 +2336,7 @@ public void EndToEndWarnAsErrors()
         [Fact]
         public void TasksGetAssemblyLoadContexts()
         {
-            string customTaskPath = Path.Combine(
-                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
-                "Task",
-                Path.GetFileName(Assembly.GetExecutingAssembly().Location));
+            string customTaskPath = Assembly.GetExecutingAssembly().Location;
 
             string projectContents = $@"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <UsingTask TaskName=`ValidateAssemblyLoadContext` AssemblyFile=`{customTaskPath}` />
@@ -2409,6 +2348,7 @@ public void TasksGetAssemblyLoadContexts()
 
             ExecuteMSBuildExeExpectSuccess(projectContents);
         }
+
 #endif
 
         private string CopyMSBuild()
@@ -2500,7 +2440,7 @@ private string ExecuteMSBuildExeExpectFailure(string projectContents, IDictionar
                 bool success;
 
                 string output = RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" {String.Join(" ", arguments)}", out success, _output);
-                
+
                 return (success, output);
             }
         }
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index e68433da7b6..d1ce644a52e 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
@@ -945,7 +945,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
+        <target state="translated">  -detailedSummary[:True|False]
                      Při dokončení sestavení zobrazí podrobné informace
                      o sestavených konfiguracích a způsobu jejich
                      naplánování do uzlů.
@@ -967,7 +967,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: Podrobná souhrnná hodnota není platná. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1565,7 +1565,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializuje všechny události sestavení do komprimovaného
                      binárního souboru. Tento soubor se standardně nachází
                      v aktuálním adresáři a má název msbuild.binlog. Binární
@@ -1582,7 +1582,6 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                      importovaných projektů a cílových souborů zjištěných
                      při sestavování. Toto chování řídí volitelný parametr
                      ProjectImports:
-
                       ProjectImports=None     - Neshromažďovat importované
                                                 projekty
                       ProjectImports=Embed    - Vložit importované projekty
@@ -1592,27 +1591,23 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                                                 kde output je stejný název
                                                 jako název souboru binárního
                                                 protokolu
-
                      Výchozí nastavení pro ProjectImports je Embed.
                      Poznámka: Protokolovací nástroj neshromažďuje zdrojové
                      soubory nepatřící pod MSBuild, jako .cs, .cpp atd.
-
-                     Soubor .binlog se dá „znovu přehrát“ tak, že se předá
+                     Soubor .binlog se dá znovu přehrát“ tak, že se předá
                      souboru msbuild.exe jako argument místo projektu/řešení.
                      Jiné protokolovací nástroje obdrží informace obsažené
                      v souboru protokolu, jako by šlo o původní sestavení.
                      Více o binárním protokolu a jeho použití si můžete
                      přečíst na stránce:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
-
+                     https://aka.ms/msbuild/binlog
                      Příklady:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
                        -bl:output.binlog;ProjectImports=ZipFile
-                       -bl:..\..\custom.binlog
-                       -binaryLogger
-    </target>
+                       -bl:..\\..\\custom.binlog
+                       -binaryLogger    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a819eed6078..8284308c137 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
@@ -937,7 +937,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
+        <target state="translated">  -detailedSummary[:True|False]
                      Zeigt am Ende der Erstellung detaillierte Informationen
                      zu den erstellten Konfigurationen an und enthält eine Erläuterung, wie sie
                      in Knoten geplant wurden.
@@ -959,7 +959,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: Der detaillierte Zusammenfassungswert ist ungültig. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1557,10 +1557,10 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serialisiert alle Buildereignisse in eine komprimierte Binärdatei.
                      Standardmäßig befindet sich die Datei im aktuellen Verzeichnis und hat den Namen
-                     "msbuild.binlog". Das binäre Protokoll ist eine detaillierte Beschreibung
+                     „msbuild.binlog“. Das binäre Protokoll ist eine detaillierte Beschreibung
                      des Buildprozesses, der später zum Rekonstruieren von
                      Textprotokollen dient und der von anderen Analysetools verwendet wird. Detaillierte
                      Textprotokolle auf Diagnoseebene sind in der Regel 10–20-mal so groß wie
@@ -1572,25 +1572,25 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
                      Projekte und Zieldateien. Der optionale Schalter
                      ProjectImports steuert dieses Verhalten:
 
-                      ProjectImports=None:      Projektimporte nicht
+                      ProjectImports=None:      – Projektimporte nicht
                                                 erfassen
-                      ProjectImports=Embed:     Projektimporte in die
+                      ProjectImports=Embed:     – Projektimporte in die
                                                 Protokolldatei einbetten
-                      ProjectImports=ZipFile:   Projektdateien in
+                      ProjectImports=ZipFile:   – Projektdateien in
                                                 output.projectimports.zip
-                                                speichern, wobei "output" dem Namen
+                                                speichern, wobei „output“ dem Namen
                                                 der binären Protokolldatei entspricht.
 
-                     Die Standardeinstellung für "ProjectImports" ist "Embed".
+                     Die Standardeinstellung für „ProjectImports“ ist „Embed“.
                      Hinweis: Die Protokollierung erfasst nur MSBuild-Quelldateien.
                      Andere Dateien wie etwa CS, CPP usw. werden nicht erfasst.
 
-                     Eine BINLOG-Datei kann wiedergegeben werden, indem sie an
-                     "msbuild.exe" als Argument und nicht als Projekt/Projektmappe übergeben wird.
+                     Eine BINLOG-Datei kann „wiedergegeben“ werden, indem sie an
+                     „msbuild.exe“ als Argument und nicht als Projekt/Lösung übergeben wird.
                      Andere Protokollierungen erhalten die Informationen, die
                      wie beim ursprünglichen Buildvorgang in der Protokolldatei enthalten sind.
                      Weitere Informationen zu binären Protokollen und ihrer Verwendung erhalten Sie unter:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Beispiele:
                        -bl
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index cfa400ae22b..4b0ad7be159 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
@@ -946,7 +946,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
+        <target state="translated">  -detailedSummary[:True|False]
                      Muestra información detallada al final de la compilación
                      sobre las configuraciones compiladas y el modo en que
                      se programaron en los nodos.
@@ -968,7 +968,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: El valor de resumen detallado no es válido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1566,23 +1566,19 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializa todos los eventos de compilación en un archivo
-                     binario comprimido. De manera predeterminada,
-                     el archivo se encuentra en el directorio actual y tiene
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializa todos los eventos de compilación en un archivo                     binario comprimido.
+ De manera predeterminada, el archivo se encuentra en el directorio actual y tiene
                      el nombre "msbuild.binlog". El registro binario es una
                      descripción detallada del proceso de compilación que
                      se puede utilizar más adelante para reconstruir registros
-                     de texto y que otras herramientas de análisis pueden
-                     emplear. Un registro binario suele ser de 10 a 20 veces
-                     más pequeño que el registro de nivel de diagnóstico de
-                     texto más detallado, pero contiene más información
-                     (Forma corta: -bl).
+                     de texto y que otras herramientas de análisis pueden emplear. Un registro binario suele ser de 10 a 20 veces
+                     más pequeño que el registro de nivel de diagnóstico de texto más detallado, pero contiene más información
+                    (Forma corta: -bl).
 
                      De manera predeterminada, el registrador binario recopila
                      el texto de origen de los archivos del proyecto, incluidos
-                     todos los proyectos y archivos de destino importados
-                     que se encuentren durante la compilación. El modificador
+                     todos los proyectos y archivos de destino importados que se encuentren durante la compilación. El modificador
                      opcional ProjectImports controla este comportamiento:
 
                       ProjectImports=None     - No recopilar importaciones
@@ -1594,27 +1590,25 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
                                                 donde "salida" es el mismo nombre que
                                                 el del archivo de registro binario.
 
-                     La configuración predeterminada de ProjectImports es
-                     Embed.
+                     La configuración predeterminada de ProjectImports es Embed.
                      Nota: El registrador no recopila archivos de código fuente
                      que no sean de MSBuild, como .cs, .cpp, etc.
 
                      Un archivo .binlog se puede "reproducir" pasándolo a
-                     msbuild.exe como argumento en lugar de proyecto o
-                     solución. Otros registradores recibirán la información
+                     msbuild.exe como argumento en lugar de proyecto o                     solución.
+ Otros registradores recibirán la información
                      que contiene el archivo de registro como si se estuviera
-                     ejecutando la compilación original. Encontrará más
-                     información sobre el registro binario y su uso en:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     ejecutando la compilación original. Encontrará más información sobre el registro binario y su uso en:
+                     https://aka.ms/msbuild/binlog
 
                      Ejemplos:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
-                       -bl:output.binlog;ProjectImports=ZipFile
+                      -bl:output.binlog;ProjectImports=ZipFile
                        -bl:..\..\custom.binlog
-                       -binaryLogger
-    </target>
+                     -binaryLogger
+   </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 3b03ab5cec3..6c40786a49a 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
@@ -938,7 +938,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
+        <target state="translated">  -detailedSummary[:True|False]
                      À la fin de la build, affiche des informations détaillées
                      sur les configurations générées et la façon dont elles
                      étaient planifiées sur les nœuds.
@@ -960,7 +960,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: une valeur de résumé détaillée n’est pas valide. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1559,20 +1559,28 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Sérialise tous les événements de build dans un fichier binaire compressé.
                      Par défaut, le fichier se trouve dans le répertoire actif et se nomme
                      "msbuild.binlog". Le journal binaire est une description détaillée
                      du processus de génération, qui peut servir plus tard à reconstruire
                      les journaux texte et être utilisé par d'autres outils d'analyse. Un journal binaire
-                     est généralement 10 à 20 fois plus petit que le journal
+                     est généralement
+10 à 20
+fois plus petit que le journal
                      de diagnostic de type texte le plus détaillé, mais il contient plus d'informations.
-                     (Forme abrégée : -bl)
+                     (Forme abrégée
+: -bl)
+
 
                      Le journaliseur binaire par défaut collecte le texte source
+
                      des fichiers projet, notamment tous les projets importés et les
+
                      fichiers cibles rencontrés pendant la build. Le commutateur
-                     ProjectImports facultatif contrôle ce comportement :
+
+                     ProjectImports facultatif contrôle ce comportement
+:
 
                       ProjectImports=None     - Ne collecte pas les importations
                                                 du projet.
@@ -1584,24 +1592,33 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
                                                 le fichier journal binaire.
 
                      Le paramètre par défaut de ProjectImports est Embed.
-                     Remarque : Le journaliseur ne collecte pas les
+                     Remarque
+: Le journaliseur ne collecte pas les
+
                      fichiers sources non MSBuild tels que .cs, .cpp etc.
 
+
                      Vous pouvez "lire" un fichier .binlog en le passant à
+
                      msbuild.exe en tant qu'argument plutôt qu'en tant que projet/solution.
+
                      D'autres enregistreurs d'événements reçoivent les informations
+
                      contenues dans le fichier journal comme si la build d'origine était en cours de création.
-                     Pour plus d'informations sur le journal binaire et ses usages, consultez :
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
 
-                     Exemples :
+                     Pour plus d'informations sur le journal binaire et ses usages, consultez
+:
+                    https://aka.ms/msbuild/binlog
+
+                     Exemples
+:
+
                        -bl
+
                        -bl:output.binlog
+
                        -bl:output.binlog;ProjectImports=None
-                       -bl:output.binlog;ProjectImports=ZipFile
-                       -bl:..\..\custom.binlog
-                       -binaryLogger
-    </target>
+                       -bl:output.binlog;ProjectImports=ZipFile                       -bl:..\..\custom.binlog                       -binaryLogger    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index cef39369d45..6ebbdf7964f 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
@@ -958,9 +958,9 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
-                     Visualizza informazioni dettagliate al termine della
-                     compilazione relative alle configurazioni compilate e alla
+        <target state="translated">  -detailedSummary[:True|False]
+                     Al termine della compilazione visualizza informazioni
+                     dettagliate sulle configurazioni compilate e sulla
                      relativa modalità di pianificazione nei nodi. Forma breve:
                      -ds.
     </target>
@@ -980,7 +980,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: il valore del riepilogo dettagliato non è valido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1580,48 +1580,42 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializza tutti gli eventi di compilazione in un file
-                     binario compresso. Per impostazione predefinita, il file
-                     si trova nella directory corrente e si chiama
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializza tutti gli eventi di compilazione in un file binario compresso.
+                     Per impostazione predefinita, il file csi trova nella directory corrente e si chiama
                      "msbuild.binlog". Il log binario è una descrizione
                      dettagliata del processo di compilazione utilizzabile in
-                     seguito per ricostruire i log di testo e viene usato da
-                     altri strumenti di analisi. Un log binario è in genere
+                     seguito per ricostruire i log di testo e viene usato da altri strumenti di analisi. Un log binario è in genere
                      10-20 volte più piccolo del più dettagliato log di testo
                      di livello diagnostico, ma contiene maggiori informazioni.
-                     Forma breve: -bl.
-                     Per impostazione predefinita, il logger binario raccoglie
-                     il testo di origine di file di progetto, inclusi tutti i
-                     progetti importati e i file di destinazione rilevati
-                     durante la compilazione. L'opzione facoltativa
+                     (Froma breve: -bl)
+
+                     Per impostazione predefinita, il logger binario raccoglie il testo di origine di
+                     file di progetto, inclusi tutti i
+                     progetti importati e i file di destinazione rilevati durante la compilazione. L'opzione facoltativa
                      ProjectImports controlla questo comportamento:
 
-                      ProjectImports=None    - Non viene eseguita la raccolta
-                                               delle importazioni del progetto.
-                      ProjectImports=Embed   - Le importazioni del progetto
-                                               vengono incorporate nel file
-                                               di log.
-                      ProjectImports=ZipFile - I file del progetto vengono
-                                               salvati in 
-                                               output.projectimports.zip
-                                               dove output corrisponde allo
-                                               stesso nome del file di log
-                                               binario.
+                      ProjectImports=None     - Non viene eseguita la raccolta
+                                                delle importazioni del progetto.
+                      ProjectImports=Embed    - Le importazioni del progetto vengono incorporate nel
+                                                file di log.
+                      ProjectImports=ZipFile  - I file del progetto vengono salvati in
+                                                output.projectimports.zip
+                                                dove output corrisponde allo
+                                                as stesso nome del file di log binario.
 
                      L'impostazione predefinita di ProjectImports è Embed.
-                     Nota: il logger non raccoglie i file di origine non
-                     MSBuild, ad esempio quelli con estensione cs, cpp
-                     e così via.
+                     Nota: il logger non raccoglie i file di origine non-MSBuild,
+                     ad esempio quelli con estensione .cs, .cpp e così via.
+
                      È possibile riprodurre un file con estensione binlog
-                     passandolo a msbuild.exe come argomento invece di un
-                     progetto o di una soluzione. Altri logger riceveranno le
-                     informazioni contenute nel file di log come se fosse in
-                     corso la compilazione originale. Per maggiori informazioni
-                     sul file di log e su come usarlo, vedere:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     passandolo a msbuild.exe come argomento invece di un progetto o di una soluzione.
+                     Altri logger riceveranno le
+                     informazioni contenute nel file di log come se fosse in corso la compilazione originale.
+                     Per maggiori informazioni sul file di log e su come usarlo, vedere:
+                     https://aka.ms/msbuild/binlog
 
-                     Esempi: 
+                     Esempi:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 74c81572c46..089b3db5c9e 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
@@ -937,8 +937,8 @@ Copyright (C) Microsoft Corporation.All rights reserved.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
-                    ビルドの最後に、ビルド構成と、ノードに対して
+        <target state="translated">  -detailedSummary[:True|False]
+                     ビルドの最後に、ビルドした構成と、ノードに対して
                     どのようにスケジュールされたかについて、
                     詳細情報が表示されます。
                     (短い形式: -ds)
@@ -959,7 +959,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: 詳細な概要値が無効です。 {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1557,7 +1557,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      すべてのビルド イベントを圧縮バイナリ ファイルにシリアル化します。
                      既定では、このファイルは "msbuild.binlog" という名前で
                      現在のディレクトリに置かれます。バイナリ ログはビルド プロセスの
@@ -1590,7 +1590,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
                      他のロガーは、オリジナルのビルドが行われたときのように、
                      ログ ファイルに含まれる情報を受け取ることができます。
                      バイナリ ログとその使用法の詳細については、以下をお読みください。
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      例:
                        -bl
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 7860d7a0b71..2d320eb0ef0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
@@ -937,11 +937,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
-                     빌드 마지막에 구성 상태 및
-                     노드에 대한 해당 구성의 예약 상태와 관련한
-                     자세한 정보를 표시합니다.
-                     (약식: -ds)
+        <target state="translated">  -detailedSummary[:True|False]
+                     빌드가 끝날 때 자세한 정보 표시
+                     구성 및 노드 예약 방법에 대해
+                     설명합니다.
+                     (Short form: -ds)
     </target>
         <note>
       LOCALIZATION: "detailedSummary", "True" and "False" should not be localized.
@@ -959,7 +959,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: 자세한 요약 값이 잘못되었습니다. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1557,7 +1557,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      모든 빌드 이벤트를 압축된 이진 파일로 직렬화합니다.
                      기본적으로 이 파일은 현재 디렉터리에 있으며 이름은
                      "msbuild.binlog"입니다. 이진 로그는 빌드 프로세스를
@@ -1590,7 +1590,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 		     발생하고 있는 것처럼 로그 파일에 포함된 정보를 받게 됩니다.
                      이진 로그 및 해당 사용법에 대한 자세한 내용은
                      다음 위치에서 확인할 수 있습니다.
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      예:
                        -bl
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 1c89191640d..c14e0ffa53d 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
@@ -950,11 +950,11 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
-                     Powoduje wyświetlenie na zakończenie kompilacji
-                     szczegółowych informacji o utworzonych konfiguracjach
-                     i ich planowanym wykorzystaniu węzłów.
-                     (Krótka wersja: -ds)
+        <target state="translated">  -detailedSummary
+                     Pokazuje szczegółowe informacje na zakończenie kompilacji
+                     o utworzonych konfiguracjach i jak zostały one
+                     zaplanowane dla węzłów.
+                     (Krótka forma: -ds)
     </target>
         <note>
       LOCALIZATION: "detailedSummary", "True" and "False" should not be localized.
@@ -972,7 +972,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: wartość szczegółowego podsumowania jest nieprawidłowa. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1570,27 +1570,27 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]wyjście.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializuje wszystkie zdarzenia kompilacji do skompresowanego pliku
-                     binarnego. Domyślnie plik znajduje się w bieżącym katalogu i ma
-                     nazwę „msbuild.binlog”. Dziennik binarny to szczegółowy opis procesu
-                     kompilacji, którego można później użyć do odtworzenia dzienników
-                     tekstowych i wykorzystać w innych narzędziach do analizy. Dziennik
-                     binarny jest zwykle 10–20 razy mniejszy od najbardziej szczegółowych
-                     tekstowych dzienników na poziomie diagnostycznym, ale zawiera
-                     więcej informacji. (Krótka forma: -bl)
+        <target state="translated">  -binaryLogger[:[LogFile=]wyjście.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializuje wszystkie zdarzenia kompilacji do skompresowanego pliku binarnego.
+                     Domyślnie plik znajduje się w bieżącym katalogu i ma nazwę
+                     „msbuild.binlog”. Dziennik binarny to szczegółowy opis procesu
+                     kompilacji, którego można później użyć do odtworzenia
+dzienników                     tekstowych i wykorzystać w innych narzędziach do analizy. Dziennik binarny
+                     jest zwykle 10–20 razy mniejszy od najbardziej szczegółowych
+                     tekstowych dzienników na poziomie diagnostycznym, ale zawiera więcej informacji.
+                     (Krótka forma: -bl)
 
-                     Rejestrator binarny domyślnie zbiera tekst źródłowy plików
-                     projektu, w tym wszystkie zaimportowane projekty i pliki
+                     Rejestrator binarny domyślnie zbiera tekst źródłowy
+                     plików projektu, w tym wszystkie zaimportowane projekty i pliki
                      docelowe napotkane podczas kompilowania. Tym zachowaniem
                      steruje opcjonalny przełącznik ProjectImports:
 
                       ProjectImports=None     — Nie zbieraj importów
                                                 projektu.
-                      ProjectImports=Embed    — Osadź importy projektu
-                                                w pliku dziennika.
+                      ProjectImports=Embed    — Osadź importy projektu w
+                                                pliku dziennika.
                       ProjectImports=ZipFile  — Zapisz pliki projektu w pliku
-                                                wyjście.projectimports.zip,
+                                                output.projectimports.zip,
                                                 gdzie wyjście to ciąg podany
                                                 dla nazwy pliku dziennika binarnego.
 
@@ -1602,15 +1602,15 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
                      msbuild.exe jako argument zamiast projektu/rozwiązania.
                      Inne rejestratory otrzymają informacje zawarte w pliku
                      dziennika tak, jak podczas wykonywania pierwotnej kompilacji.
-                     Więcej informacji o dzienniku binarnym i jego zastosowaniach:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     Więcej informacji o dzienniku binarnym i jego zastosowaniach można uzyskać na stronie:
+                     https://aka.ms/msbuild/binlog
 
                      Przykłady:
                        -bl
-                       -bl:wyjście.binlog
-                       -bl:wyjście.binlog;ProjectImports=None
-                       -bl:wyjście.binlog;ProjectImports=ZipFile
-                       -bl:..\..\niestandardowy.binlog
+                       -bl:output.binlog
+                       -bl:output.binlog;ProjectImports=None
+                       -bl:output.binlog;ProjectImports=ZipFile
+                       -bl:..\..\custom.binlog
                        -binaryLogger
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 351d62f1568..751fc9b422d 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
@@ -938,10 +938,10 @@ isoladamente.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
-                     Mostra informações detalhadas ao final do build
-                     sobre as configurações compiladas e o modo como elas foram
-                     agendadas para nós. 
+        <target state="translated">  -detailedSummary[:True|False]
+                     Mostra informações detalhadas no final da compilação
+                     sobre as configurações compiladas e como elas foram
+                     agendadas para os nós.
                      (Forma abreviada: -ds)
     </target>
         <note>
@@ -960,7 +960,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: O valor do resumo detalhado é inválido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -970,7 +970,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="translated">MSBUILD : error MSB1057: o valor de build do grafo não é válido.</target>
+        <target state="translated">MSBUILD : error MSB1057: O valor de build do gráfico não é válido.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1558,40 +1558,40 @@ isoladamente.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializa todos os eventos de build para um arquivo binário compactado.
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializa todos os eventos da compilação em um arquivo binário compactado.
                      Por padrão, o arquivo está no diretório atual e é chamado de
-                     "msbuild.binlog". O log binário é uma descrição detalhada 
-                     do processo de build que pode mais tarde ser usado para reconstruir
-                     logs de texto e ser usado por outras ferramentas de análise. Um log binário
-                     normalmente é 10 a 20 vezes menor que a maioria dos logs de nível
-                     de diagnóstico de texto mais detalhado, mas contém mais informações.
+                     "msbuild.binlog". O log binário é uma descrição detalhada
+                     do processo de compilação que pode mais tarde ser usado para reconstruir
+                     logs de texto e usados por outras ferramentas de análise. Um log binário
+                     normalmente é 10 a 20x menor do que os log de nível
+                     de diagnóstico do texto mais detalhado, mas contém mais informações.
                      (Forma abreviada: -bl)
 
-                     O agente binário por padrão coleta o texto fonte dos
+                     O agente binário, por padrão, coleta o texto fonte dos
                      arquivos de projeto, incluindo todos os projetos importados e arquivos
-                     de destino encontrados durante o build. A opção
-                     ProjectImports opcional controla esse comportamento:
+                     de destino encontrados durante a compilação. A opção
+                     ProjectImports opcional controla este comportamento:
 
-                      ProjectImports=None     – Não coletar as importações 
+                      ProjectImports=None     - Não coletar as importações
                                                 do projeto.
-                      ProjectImports=Embed    – Inserir as importações do projeto
-                                                no arquivo de log.
-                      ProjectImports=ZipFile  – Salvar os arquivos de projeto no 
-                                                output.projectimports.zip,
+                      ProjectImports=Embed    - Inserir as importações do projeto no
+                                                arquivo de log.
+                      ProjectImports=ZipFile  - Salvar os arquivos de projeto em
+                                                output.projectimports.zip
                                                 em que a saída tem o mesmo nome que o
                                                 nome do arquivo de log binário.
 
                      A configuração padrão para ProjectImports é Embed.
-                     Nota: o agente não coleta arquivos de origem não MSBuild,
-                     como .cs, .cpp etc.
+                     Observação: o agente não coleta arquivos de origem não MSBuild
+                     tais como .cs, .cpp etc.
 
-                     Um arquivo .binlog pode ser "reproduzido novamente" passando-o para
-                     msbuild.exe como um argumento, em vez de como um projeto/solução.
-                     Outros agentes receberão as informações contidas no arquivo de log
-                     como se o build original estivesse acontecendo.
+                     Um arquivo .binlog pode ser "reproduzido novamente", passando-o para
+                     msbuild.exe como um argumento em vez de um projeto/solução.
+                     Outros agentes receberão as informações contidas
+                     no arquivo de log como se a compilação original estivesse acontecendo.
                      Você pode ler mais sobre o log binário e seus usos em:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Exemplos:
                        -bl
@@ -1707,4 +1707,4 @@ projeto precisar                                                   
       </trans-unit>
     </body>
   </file>
-</xliff>
\ No newline at end of file
+</xliff>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index e74451f9138..75212bac50f 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
@@ -937,7 +937,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
+        <target state="translated">  -detailedSummary[:True|False]
                      Показывает в конце сборки подробные сведения
                      о созданных конфигурациях и графике их передачи
                      на узлы.
@@ -959,7 +959,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: значение подробной сводки недопустимо. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1559,40 +1559,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Сериализует все события сборки в сжатый двоичный файл.
                      По умолчанию файл находится в текущем каталоге и называется
                      "msbuild.binlog". Двоичный журнал включает подробное описание
                      процесса сборки, которое затем можно использовать для воссоздания
                      текстовых журналов. Он также может использоваться другими средствами анализа. Двоичный журнал
-                     обычно в 10–20 раз меньше самого подробного текстового
+                     обычно в 10–20 раз меньше самого подробного текстового
                      журнала уровня диагностики, но содержит больше информации.
                      (Краткая форма: -bl)
 
                      Средство ведения двоичного журнала по умолчанию собирает исходный текст
                      файлов проекта, включая все импортированные проекты и целевые
                      файлы, найденные во время сборки. Дополнительный
-                     параметр ProjectImports управляет этим поведением.
+                     параметр ProjectImports управляет этим поведением:
 
-                      ProjectImports=None — не собирать импортированные файлы
+                      ProjectImports=None     — не собирать импортированные файлы
                                                 проекта.
-                      ProjectImports=Embed — внедрять импортированные файлы проекта в
+                      ProjectImports=Embed    — внедрять импортированные файлы проекта в
                                                 файл журнала.
-                      ProjectImports=ZipFile — сохранять файлы проекта в
-                                                &lt;вывод&gt;.projectimports.zip,
-                                                где &lt;вывод&gt; — это то же имя,
+                      ProjectImports=ZipFile  — сохранять файлы проекта в
+                                                вывод.projectimports.zip,
+                                                где вывод — это то же имя,
                                                 что и у двоичного файла журнала.
 
-                     Значение по умолчанию для ProjectImports — Embed.
-                     Примечание. Средство ведения журнала не собирает исходные файлы
-                     не от MSBuild, например с расширениями CS, CPP и др.
+                     Значение по умолчанию для ProjectImports — Embed.
+                     Примечание. Средство ведения журнала не собирает исходные файлы, не от MSBuild,
+                     например с расширениями CS, CPP и др.
 
                      BINLOG-файл можно "воспроизвести", передав его в
                      msbuild.exe в качестве аргумента вместо проекта или решения.
                      Другие средства ведения журнала получат содержащиеся
                      в файле журнала сведения, как если бы происходила собственно сборка.
                      Дополнительные сведения о двоичных журналах и их использовании:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Примеры:
                        -bl
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 6a7f4524732..f8ed2f2d849 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
@@ -941,10 +941,10 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
+        <target state="translated">  -detailedSummary[:True|False]
                      Derleme sonunda, derlenen yapılandırmalar ve
                      bu yapılandırmaların düğümlere nasıl zamanlandıkları
-                     hakkında ayrıntılı bilgi içerir.
+                     ile ilgili ayrıntılı bilgileri gösterir.
                      (Kısa biçim: -ds)
     </target>
         <note>
@@ -963,7 +963,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: Ayrıntılı özet değeri geçerli değil. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1561,7 +1561,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Tüm derleme olaylarını sıkıştırılmış bir ikili dosyada seri hale getirir.
                      Varsayılan olarak, dosya geçerli dizinde bulunur ve "msbuild.binlog"
                      olarak adlandırılır. Daha sonra metin günlüklerini yeniden
@@ -1594,7 +1594,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                      Diğer günlükçüler, günlük dosyasındaki bilgileri özgün
                      derleme gerçekleşiyormuş gibi alır.
                      İkili günlük ve kullanımı hakkında daha fazla bilgiyi aşağıdaki adreste bulabilirsiniz:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Örnekler:
                        -bl
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 31ae8aa1aa5..bf57d51080e 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANS" original="../Strings.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
       <trans-unit id="AmbiguousProjectError">
         <source>MSBUILD : error MSB1011: Specify which project or solution file to use because this folder contains more than one project or solution file.</source>
@@ -937,10 +937,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedSummary
+        <target state="translated">  -detailedSummary
                     在生成的结尾显示有关
-                    所生成的配置以及如何向节点安排
-                    这些配置的详细信息。
+                    所生成配置的详细信息，以及如何向节点安排
+                    这些配置。
                     (缩写: -ds)
     </target>
         <note>
@@ -959,7 +959,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: 详细汇总值无效。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1557,7 +1557,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      将所有生成事件序列化为压缩的二进制文件。
                      默认情况下该文件位于当前目录并且名为 "msbuild.binlog"。
                      二进制日志是生成过程的详细描述，
@@ -1571,27 +1571,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      包括生成期间所有导入的
                      项目和目标文件。可选的
                      ProjectImports 开关控制此行为:
-                     
 
                       ProjectImports=None     - 不收集项目
                                                 导入项。
-                      ProjectImports=Embed    - 在日志文件中
-                                                嵌入项目导入项。
-                      ProjectImports=ZipFile  - 将项目文件保存到
-                                                output.projectimports.zip，
+                     ProjectImports=Embed    - 在日志文件中
+                                                 嵌入项目导入项。
+                    ProjectImports=ZipFile  - 将项目文件保存到
+                                              output.projectimports.zip，
                                                 其中输出的名称
                                                 与二进制日志文件名称相同。
 
-                     ProjectImports 的默认设置为 Embed。
-                     注意: 记录器不会收集非 MSBuild 源文件，
-                     例如 .cs、.cpp 等。
+                    ProjectImports 的默认设置为 Embed。
+                    注意: 记录器不会收集非 MSBuild 源文件，
+                    例如 .cs、.cpp 等。
 
                      可将 .binlog 文件以参数(而不是项目/解决方案)的形式传递给
-                     msbuild.exe 对其进行“播放”。
+                   msbuild.exe 对其进行“播放”。
                      其他记录器将接收日志文件中的信息，
-                     就像原始的生成正在发生一样。
-                     你可以通过以下网址阅读有关二进制文件及其用法的详细信息:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                    就像原始的生成正在发生一样。
+                    你可以通过以下网址阅读有关二进制文件及其用法的详细信息:
+                    https://aka.ms/msbuild/binlog
 
                      示例:
                        -bl
@@ -1600,7 +1599,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -bl:output.binlog;ProjectImports=ZipFile
                        -bl:..\..\custom.binlog
                        -binaryLogger
-    </target>
+</target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 29e1a1b55d8..066da1aa35f 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANT" original="../Strings.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
       <trans-unit id="AmbiguousProjectError">
         <source>MSBUILD : error MSB1011: Specify which project or solution file to use because this folder contains more than one project or solution file.</source>
@@ -937,7 +937,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
                      scheduled to nodes.
                      (Short form: -ds)
     </source>
-        <target state="needs-review-translation">  -detailedsummary
+        <target state="translated">  -detailedSummary[:True|False]
                      在建置結束時顯示詳細資訊，
                      內容為建置的組態，
                      以及將組態排程到節點的方式。
@@ -959,7 +959,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="InvalidDetailedSummaryValue">
         <source>MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1061: Detailed summary value is not valid. {0}</target>
+        <target state="translated">MSBUILD : error MSB1061: 詳細摘要值無效。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1061: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1557,10 +1557,10 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                     將所有建置事件序列化成壓縮的二進位檔案。
-                     根據預設，此檔案存放在目前的目錄下，
-                     並會命名為 "msbuild.binlog"。此二進位記錄檔是
+                     根據預設，此檔案存放在目前的目錄下，並會命名為
+                     「msbuild.binlog」。此二進位記錄檔是
                      建置程序的詳細描述，之後可用於重建文字記錄，
                      以及供其他分析工具使用。二進位記錄檔
                      的大小通常會比大部分的詳細文字
@@ -1569,7 +1569,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
 
                      根據預設，二進位記錄器會收集專案檔的
                      原始程式文字，包括在建置期間遇到的
-                     匯入專案及目標檔案。選擇性的 ProjectImports 參數
+                     所有匯入專案及目標檔案。選擇性的 ProjectImports 參數
                      會控制此行為:
 
                       ProjectImports=None     - 不收集專案
@@ -1590,7 +1590,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
                      其他記錄器會收到記錄檔中包含的資訊，
                      就如同原始組建發生時的情況。
                      若要深入閱讀二進位記錄檔及其使用方式，請前往:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      範例:
                        -bl
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index b86c58acce1..09a0f38eaf3 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1440,31 +1440,19 @@ private static (BuildResultCode result, Exception exception) ExecuteRestore(stri
             restoreGlobalProperties["MSBuildRestoreSessionId"] = Guid.NewGuid().ToString("D");
 
             // Create a new request with a Restore target only and specify:
-            BuildRequestDataFlags flags;
-
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
-            {
-                flags =   BuildRequestDataFlags.ClearCachesAfterBuild                // ensure the projects will be reloaded from disk for subsequent builds
-                        | BuildRequestDataFlags.SkipNonexistentNonEntryTargets       // ignore missing non-entry targets since Restore does not require that all targets
-                                                                                     // exist, only top-level ones like Restore itself
-                        | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports  // ignore imports that don't exist, are empty, or are invalid because restore might
-                                                                                     // make available an import that doesn't exist yet and the <Import /> might be missing a condition.
-                        | BuildRequestDataFlags.FailOnUnresolvedSdk;                 // still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
-                                                                                     // fail the build.
-            }
-            else
-            {
-                // pre-16.10 flags allowed `-restore` to pass when there was no `Restore` target
-                flags = BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports;
-            }
-
+            //  - BuildRequestDataFlags.ClearCachesAfterBuild to ensure the projects will be reloaded from disk for subsequent builds
+            //  - BuildRequestDataFlags.SkipNonexistentTargets to ignore missing targets since Restore does not require that all targets exist
+            //  - BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports to ignore imports that don't exist, are empty, or are invalid because restore might
+            //     make available an import that doesn't exist yet and the <Import /> might be missing a condition.
+            //  - BuildRequestDataFlags.FailOnUnresolvedSdk to still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
+            //     fail the build.
             BuildRequestData restoreRequest = new BuildRequestData(
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
                 targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
                 hostServices: null,
-                flags);
+                flags: BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk);
 
             return ExecuteBuild(buildManager, restoreRequest);
         }
diff --git a/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs b/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
index 103061df36c..14949660eac 100644
--- a/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
+++ b/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
@@ -16,7 +16,7 @@ internal class MSBuildTaskHostFileSystem : IFileSystem
 
         public static MSBuildTaskHostFileSystem Singleton() => Instance;
 
-        public bool DirectoryEntryExists(string path)
+        public bool FileOrDirectoryExists(string path)
         {
             return NativeMethodsShared.FileOrDirectoryExists(path);
         }
diff --git a/src/Package/Localization/Localization.csproj b/src/Package/Localization/Localization.csproj
index 0326009105b..e15af6ed02a 100644
--- a/src/Package/Localization/Localization.csproj
+++ b/src/Package/Localization/Localization.csproj
@@ -1,6 +1,6 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
-    <TargetFramework Condition="$(MonoBuild) != 'true'">net5.0</TargetFramework>
+    <TargetFramework Condition="$(MonoBuild) != 'true'">net6.0</TargetFramework>
     <TargetFramework Condition="$(MonoBuild) == 'true'">net472</TargetFramework>
     <NuspecFile>Microsoft.Build.Localization.nuspec</NuspecFile>
     <IsShipping>false</IsShipping>
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index df35ae1ca6b..4f7a5e8d6ad 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -4,8 +4,8 @@
     <CopyNuGetImplementations>false</CopyNuGetImplementations>
     <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
 
-    <TargetFrameworks>net5.0</TargetFrameworks>
-    <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);net5.0</TargetFrameworks>
+    <TargetFrameworks>net6.0</TargetFrameworks>
+    <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);net6.0</TargetFrameworks>
     <TargetFrameworks Condition="'$(MonoBuild)'=='true'">$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
   </PropertyGroup>
   <ItemGroup>
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 6c2b6337393..74f46865a14 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -660,12 +660,31 @@ public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> obje
                 }
             }
 
-            /// <summary>
-            /// Reads in the boolean which says if this object is null or not.
-            /// </summary>
-            /// <typeparam name="T">The type of object to test.</typeparam>
-            /// <returns>True if the object should be read, false otherwise.</returns>
-            public bool TranslateNullable<T>(T value)
+            public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer)
+            {
+                if (!TranslateNullable(dictionary))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                dictionary = new(count, comparer);
+                string key = string.Empty;
+                DateTime val = DateTime.MinValue;
+                for (int i = 0; i < count; i++)
+                {
+                    Translate(ref key);
+                    Translate(ref val);
+                    dictionary.Add(key, val);
+                }
+            }
+
+        /// <summary>
+        /// Reads in the boolean which says if this object is null or not.
+        /// </summary>
+        /// <typeparam name="T">The type of object to test.</typeparam>
+        /// <returns>True if the object should be read, false otherwise.</returns>
+        public bool TranslateNullable<T>(T value)
             {
                 bool haveRef = _reader.ReadBoolean();
                 return haveRef;
@@ -1254,6 +1273,29 @@ public void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> obje
                 }
             }
 
+            /// <summary>
+            /// Translates a dictionary of { string, DateTime }.
+            /// </summary>
+            /// <param name="dictionary">The dictionary to be translated.</param>
+            /// <param name="comparer">Key comparer</param>
+            public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer)
+            {
+                if (!TranslateNullable(dictionary))
+                {
+                    return;
+                }
+
+                int count = dictionary.Count;
+                _writer.Write(count);
+                foreach (KeyValuePair<string, DateTime> kvp in dictionary)
+                {
+                    string key = kvp.Key;
+                    DateTime val = kvp.Value;
+                    Translate(ref key);
+                    Translate(ref val);
+                }
+            }
+
             /// <summary>
             /// Writes out the boolean which says if this object is null or not.
             /// </summary>
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 385c5c878e8..14cd04a244d 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -23,15 +23,8 @@ internal sealed class CoreClrAssemblyLoader
 
         private bool _resolvingHandlerHookedUp = false;
 
-        private static readonly string _msbuildDirPath;
         private static readonly Version _currentAssemblyVersion = new Version(Microsoft.Build.Shared.MSBuildConstants.CurrentAssemblyVersion);
 
-        static CoreClrAssemblyLoader()
-        {
-            _msbuildDirPath = FileUtilities.NormalizePath(typeof(CoreClrAssemblyLoader).Assembly.Location);
-            _msbuildDirPath = Path.GetDirectoryName(_msbuildDirPath);
-        }
-
         public void AddDependencyLocation(string fullPath)
         {
             if (fullPath == null)
@@ -59,12 +52,7 @@ public Assembly LoadFromPath(string fullPath)
             // folders in a NuGet package).
             fullPath = FileUtilities.NormalizePath(fullPath);
 
-            // If the requested load comes from the same directory as MSBuild, assume that
-            // the load is part of the platform, and load it using the Default ALC.
-            string assemblyDir = Path.GetDirectoryName(fullPath);
-
-            if (Traits.Instance.EscapeHatches.UseSingleLoadContext ||
-                FileUtilities.ComparePathsNoThrow(assemblyDir, _msbuildDirPath, string.Empty))
+            if (Traits.Instance.EscapeHatches.UseSingleLoadContext)
             {
                 return LoadUsingLegacyDefaultContext(fullPath);
             }
diff --git a/src/Shared/FileSystem/CachingFileSystemWrapper.cs b/src/Shared/FileSystem/CachingFileSystemWrapper.cs
index c3b3b141f20..b541f1b44f7 100644
--- a/src/Shared/FileSystem/CachingFileSystemWrapper.cs
+++ b/src/Shared/FileSystem/CachingFileSystemWrapper.cs
@@ -19,9 +19,9 @@ public CachingFileSystemWrapper(IFileSystem fileSystem)
             _fileSystem = fileSystem;
         }
 
-        public bool DirectoryEntryExists(string path)
+        public bool FileOrDirectoryExists(string path)
         {
-            return CachedExistenceCheck(path, p => _fileSystem.DirectoryEntryExists(p));
+            return CachedExistenceCheck(path, p => _fileSystem.FileOrDirectoryExists(p));
         }
 
         public FileAttributes GetAttributes(string path)
diff --git a/src/Shared/FileSystem/IFileSystem.cs b/src/Shared/FileSystem/IFileSystem.cs
index 0ef03e74c65..c5e32373eec 100644
--- a/src/Shared/FileSystem/IFileSystem.cs
+++ b/src/Shared/FileSystem/IFileSystem.cs
@@ -42,6 +42,6 @@ internal interface IFileSystem
 
         bool FileExists(string path);
 
-        bool DirectoryEntryExists(string path);
+        bool FileOrDirectoryExists(string path);
     }
 }
diff --git a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
index 188efaf27fa..e0be3971d7a 100644
--- a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
+++ b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
@@ -74,9 +74,9 @@ public bool FileExists(string path)
             return WindowsFileSystem.Singleton().FileExists(path);
         }
 
-        public bool DirectoryEntryExists(string path)
+        public bool FileOrDirectoryExists(string path)
         {
-            return WindowsFileSystem.Singleton().DirectoryEntryExists(path);
+            return WindowsFileSystem.Singleton().FileOrDirectoryExists(path);
         }
     }
 }
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 201a62e7436..6d8bd32fb4e 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -73,7 +73,7 @@ public virtual bool FileExists(string path)
             return File.Exists(path);
         }
 
-        public virtual bool DirectoryEntryExists(string path)
+        public virtual bool FileOrDirectoryExists(string path)
         {
             return FileExists(path) || DirectoryExists(path);
         }
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 9f4e3bf1dda..60b7d8ececa 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -59,7 +59,7 @@ public override bool FileExists(string path)
             return NativeMethodsShared.FileExistsWindows(path);
         }
 
-        public override bool DirectoryEntryExists(string path)
+        public override bool FileOrDirectoryExists(string path)
         {
             return NativeMethodsShared.FileOrDirectoryExistsWindows(path);
         }
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 707657933d1..cb3040b8642 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -586,7 +586,7 @@ internal static bool LooksLikeUnixFilePath(ReadOnlySpan<char> value, string base
             ReadOnlySpan<char> directory = value.Slice(0, directoryLength);
 
             return (shouldCheckDirectory && DefaultFileSystem.DirectoryExists(Path.Combine(baseDirectory, directory.ToString())))
-                || (shouldCheckFileOrDirectory && DefaultFileSystem.DirectoryEntryExists(value.ToString()));
+                || (shouldCheckFileOrDirectory && DefaultFileSystem.FileOrDirectoryExists(value.ToString()));
         }
 #endif
 
@@ -951,8 +951,8 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryEntryExists)
-                    : fileSystem.DirectoryEntryExists(fullPath);
+                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileOrDirectoryExists)
+                    : fileSystem.FileOrDirectoryExists(fullPath);
             }
             catch
             {
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index b1acb85ec2f..97ea429de96 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -301,6 +301,8 @@ void TranslateArray<T>(ref T[] array)
 
         void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> collectionCreator);
 
+        void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer);
+
         void TranslateDictionary<K, V>(ref IDictionary<K, V> dictionary, ObjectTranslator<K> keyTranslator, ObjectTranslator<V> valueTranslator, NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator);
 
         /// <summary>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 6f4bbec1431..248af5346b3 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANS" original="../Strings.shared.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.shared.resx">
     <body>
       <trans-unit id="BuildAborted">
         <source>MSB4188: Build was canceled.</source>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index b4cd2e2d549..dccd588bfc1 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANT" original="../Strings.shared.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.shared.resx">
     <body>
       <trans-unit id="BuildAborted">
         <source>MSB4188: Build was canceled.</source>
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index c3d200829e3..af8587de6af 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -2633,9 +2633,9 @@ public bool FileExists(string path)
                 return FileSystems.Default.FileExists(path);
             }
 
-            public bool DirectoryEntryExists(string path)
+            public bool FileOrDirectoryExists(string path)
             {
-                return FileSystems.Default.DirectoryEntryExists(path);
+                return FileSystems.Default.FileOrDirectoryExists(path);
             }
         }
     }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index a9bdd429d16..c5fc062eecd 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1971,44 +1971,38 @@ public void Dispose()
 
         internal class LoggingFileSystem : MSBuildFileSystemBase
         {
-            private readonly IFileSystem _wrappingFileSystem;
             private int _fileSystemCalls;
 
             public int FileSystemCalls => _fileSystemCalls;
 
             public ConcurrentDictionary<string, int> ExistenceChecks { get; } = new ConcurrentDictionary<string, int>();
 
-            public LoggingFileSystem(IFileSystem wrappingFileSystem = null)
-            {
-                _wrappingFileSystem = wrappingFileSystem ?? FileSystems.Default;
-            }
-
             public override TextReader ReadFile(string path)
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.ReadFile(path);
+                return base.ReadFile(path);
             }
 
             public override Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.GetFileStream(path, mode, access, share);
+                return base.GetFileStream(path, mode, access, share);
             }
 
             public override string ReadFileAllText(string path)
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.ReadFileAllText(path);
+                return base.ReadFileAllText(path);
             }
 
             public override byte[] ReadFileAllBytes(string path)
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.ReadFileAllBytes(path);
+                return base.ReadFileAllBytes(path);
             }
 
             public override IEnumerable<string> EnumerateFiles(
@@ -2019,7 +2013,7 @@ public override IEnumerable<string> EnumerateFiles(
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.EnumerateFiles(path, searchPattern, searchOption);
+                return base.EnumerateFiles(path, searchPattern, searchOption);
             }
 
             public override IEnumerable<string> EnumerateDirectories(
@@ -2030,7 +2024,7 @@ public override IEnumerable<string> EnumerateDirectories(
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+                return base.EnumerateDirectories(path, searchPattern, searchOption);
             }
 
             public override IEnumerable<string> EnumerateFileSystemEntries(
@@ -2041,21 +2035,21 @@ public override IEnumerable<string> EnumerateFileSystemEntries(
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+                return base.EnumerateFileSystemEntries(path, searchPattern, searchOption);
             }
 
             public override FileAttributes GetAttributes(string path)
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.GetAttributes(path);
+                return base.GetAttributes(path);
             }
 
             public override DateTime GetLastWriteTimeUtc(string path)
             {
                 IncrementCalls(ref _fileSystemCalls);
 
-                return _wrappingFileSystem.GetLastWriteTimeUtc(path);
+                return base.GetLastWriteTimeUtc(path);
             }
 
             public override bool DirectoryExists(string path)
@@ -2063,7 +2057,7 @@ public override bool DirectoryExists(string path)
                 IncrementCalls(ref _fileSystemCalls);
                 IncrementExistenceChecks(path);
 
-                return _wrappingFileSystem.DirectoryExists(path);
+                return base.DirectoryExists(path);
             }
 
             public override bool FileExists(string path)
@@ -2071,19 +2065,19 @@ public override bool FileExists(string path)
                 IncrementCalls(ref _fileSystemCalls);
                 IncrementExistenceChecks(path);
 
-                return _wrappingFileSystem.FileExists(path);
+                return base.FileExists(path);
             }
 
-            private int _directoryEntryExistsCalls;
-            public int DirectoryEntryExistsCalls => _directoryEntryExistsCalls;
+            private int _fileOrDirectoryExistsCalls;
+            public int FileOrDirectoryExistsCalls => _fileOrDirectoryExistsCalls;
 
             public override bool FileOrDirectoryExists(string path)
             {
                 IncrementCalls(ref _fileSystemCalls);
-                IncrementCalls(ref _directoryEntryExistsCalls);
+                IncrementCalls(ref _fileOrDirectoryExistsCalls);
                 IncrementExistenceChecks(path);
 
-                return _wrappingFileSystem.DirectoryEntryExists(path);
+                return base.FileOrDirectoryExists(path);
             }
 
             private void IncrementCalls(ref int incremented)
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
index 77a9bf0452a..7f55c5bcbd1 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
@@ -1,6 +1,9 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System;
+using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
 using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
@@ -12,10 +15,6 @@ namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
     public class ResolveAssemblyReferenceCacheSerialization : IDisposable
     {
-        // Maintain this two in sync with the constant in SystemState
-        private static readonly byte[] TranslateContractSignature = { (byte)'M', (byte)'B', (byte)'R', (byte)'S', (byte)'C' }; // Microsoft Build RAR State Cache
-        private static readonly byte TranslateContractVersion = 0x01;
-
         private readonly string _rarCacheFile;
         private readonly TaskLoggingHelper _taskLoggingHelper;
 
@@ -42,178 +41,81 @@ public void RoundTripEmptyState()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
 
-            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
 
             deserialized.ShouldNotBeNull();
         }
 
         [Fact]
-        public void WrongFileSignature()
-        {
-            SystemState systemState = new();
-
-            for (int i = 0; i < TranslateContractSignature.Length; i++)
-            {
-                systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-                using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
-                {
-                    cacheStream.Seek(i, SeekOrigin.Begin);
-                    cacheStream.WriteByte(0);
-                    cacheStream.Close();
-                }
-
-                var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-
-                deserialized.ShouldBeNull();
-            }
-        }
-
-        [Fact]
-        public void WrongFileVersion()
+        public void CorrectFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
-                cacheStream.Seek(TranslateContractSignature.Length, SeekOrigin.Begin);
-                cacheStream.WriteByte((byte) (TranslateContractVersion + 1));
+                cacheStream.Seek(0, SeekOrigin.Begin);
+                cacheStream.WriteByte(StateFileBase.CurrentSerializationVersion);
                 cacheStream.Close();
             }
 
-            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-
-            deserialized.ShouldBeNull();
-        }
-
-        [Fact]
-        public void CorrectFileSignature()
-        {
-            SystemState systemState = new();
-
-            for (int i = 0; i < TranslateContractSignature.Length; i++)
-            {
-                systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-                using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
-                {
-                    cacheStream.Seek(i, SeekOrigin.Begin);
-                    cacheStream.WriteByte(TranslateContractSignature[i]);
-                    cacheStream.Close();
-                }
-
-                var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
 
-                deserialized.ShouldNotBeNull();
-            }
+            deserialized.ShouldNotBeNull();
         }
 
         [Fact]
-        public void CorrectFileVersion()
+        public void WrongFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
-                cacheStream.Seek(TranslateContractSignature.Length, SeekOrigin.Begin);
-                cacheStream.WriteByte(TranslateContractVersion);
+                cacheStream.Seek(0, SeekOrigin.Begin);
+                cacheStream.WriteByte(StateFileBase.CurrentSerializationVersion - 1);
                 cacheStream.Close();
             }
 
-            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
 
-            deserialized.ShouldNotBeNull();
+            deserialized.ShouldBeNull();
         }
 
         [Fact]
-        public void VerifySampleStateDeserialization()
+        public void ValidateSerializationAndDeserialization()
         {
-            // This test might also fail when binary format is modified.
-            // Any change in SystemState and child class ITranslatable implementation will most probably make this fail.
-            // To fix it, file referred by 'sampleName' needs to be recaptured and constant bellow modified to reflect
-            // the content of that cache.
-            // This sample was captured by compiling https://github.com/dotnet/roslyn/commit/f8107de2a94a01e96ac3d7c1f225acbb61e18830
-            const string sampleName = "Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache";
-            const string expectedAssemblyPath = @"C:\Users\rokon\.nuget\packages\microsoft.visualstudio.codeanalysis.sdk.ui\15.8.27812-alpha\lib\net46\Microsoft.VisualStudio.CodeAnalysis.Sdk.UI.dll";
-            const long expectedAssemblyLastWriteTimeTicks = 636644382480000000;
-            const string expectedAssemblyName = "Microsoft.VisualStudio.CodeAnalysis.Sdk.UI, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
-            const string expectedFrameworkName = ".NETFramework,Version=v4.5";
-            var expectedDependencies = new[]
+            Dictionary<string, SystemState.FileState> cache = new() {
+                    { "path1", new SystemState.FileState(DateTime.Now) },
+                    { "path2", new SystemState.FileState(DateTime.Now) { Assembly = new AssemblyNameExtension("hi") } },
+                    { "dllName", new SystemState.FileState(DateTime.Now.AddSeconds(-10)) {
+                        Assembly = null,
+                        RuntimeVersion = "v4.0.30319",
+                        FrameworkNameAttribute = new FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
+                        scatterFiles = new string[] { "first", "second" } } } };
+            SystemState sysState = new();
+            sysState.instanceLocalFileStateCache = cache;
+            SystemState sysState2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
             {
-                "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.CodeAnalysis, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.DeveloperTools, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "Microsoft.VisualStudio.Shell.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "EnvDTE, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.CodeAnalysis.Sdk, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.Build.Framework, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Text.Logic, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Text.UI, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Text.Data, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Text.UI.Wpf, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.ComponentModelHost, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.VSHelp, Version=7.0.3300.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Shell.Interop.11.0, Version=11.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.VCProjectEngine, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Shell.15.0, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.OLE.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "Microsoft.VisualStudio.TextManager.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "EnvDTE80, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
-                "Microsoft.VisualStudio.VirtualTreeGrid, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Shell.Interop.8.0, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-                "Microsoft.VisualStudio.Editor, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
-            };
-
-
-            CopyResourceSampleFileIntoRarCacheFile($@"AssemblyDependency\CacheFileSamples\{sampleName}");
-
-            var deserializedByTranslator = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
-            deserializedByTranslator.ShouldNotBeNull();
-
-            deserializedByTranslator.SetGetLastWriteTime(path =>
-            {
-                if (path != expectedAssemblyPath)
-                    throw new InvalidOperationException("Unexpected file name for this test case");
-
-                return new DateTime(expectedAssemblyLastWriteTimeTicks, DateTimeKind.Utc);
-            });
-
-            GetAssemblyName getAssemblyName = deserializedByTranslator.CacheDelegate((GetAssemblyName)null);
-            GetAssemblyMetadata getAssemblyMetadata = deserializedByTranslator.CacheDelegate((GetAssemblyMetadata)null);
-
-            var assemblyName = getAssemblyName(expectedAssemblyPath);
-            getAssemblyMetadata(expectedAssemblyPath, null,
-                out AssemblyNameExtension[] dependencies,
-                out string[] scatterFiles,
-                out FrameworkName frameworkNameAttribute);
-
-
-            assemblyName.ShouldNotBeNull();
-            assemblyName.ShouldBe(new AssemblyNameExtension(expectedAssemblyName, false));
-            scatterFiles.ShouldBeEmpty();
-            frameworkNameAttribute.ShouldBe(new FrameworkName(expectedFrameworkName));
-            dependencies.ShouldNotBeNull();
-            expectedDependencies.ShouldBe(expectedDependencies, ignoreOrder: true);
-        }
-
-        private void CopyResourceSampleFileIntoRarCacheFile(string name)
-        {
-            Assembly asm = this.GetType().Assembly;
-            var resource = string.Format($"{asm.GetName().Name}.{name.Replace("\\", ".")}");
-            using Stream resourceStream = asm.GetManifestResourceStream(resource);
-            if (resourceStream == null)
-                throw new InvalidOperationException($"Resource '{resource}' has not been found.");
-
-            using FileStream rarCacheFile = new FileStream(_rarCacheFile, FileMode.CreateNew);
+                TransientTestFile file = env.CreateFile();
+                sysState.SerializeCache(file.Path, null);
+                sysState2 = SystemState.DeserializeCache(file.Path, null, typeof(SystemState)) as SystemState;
+            }
 
-            resourceStream.CopyTo(rarCacheFile);
+            Dictionary<string, SystemState.FileState> cache2 = sysState2.instanceLocalFileStateCache;
+            cache2.Count.ShouldBe(cache.Count);
+            cache2["path2"].Assembly.Name.ShouldBe(cache["path2"].Assembly.Name);
+            SystemState.FileState dll = cache["dllName"];
+            SystemState.FileState dll2 = cache2["dllName"];
+            dll2.Assembly.ShouldBe(dll.Assembly);
+            dll2.FrameworkNameAttribute.FullName.ShouldBe(dll.FrameworkNameAttribute.FullName);
+            dll2.LastModified.ShouldBe(dll.LastModified);
+            dll2.RuntimeVersion.ShouldBe(dll.RuntimeVersion);
+            dll2.scatterFiles.Length.ShouldBe(dll.scatterFiles.Length);
+            dll2.scatterFiles[1].ShouldBe(dll.scatterFiles[1]);
         }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs b/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
index d496e33ecf1..fc94fbb510c 100644
--- a/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Tasks;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -26,5 +27,24 @@ public void ExerciseCache()
             Assert.Equal("foo", assembly);
             Assert.Equal("bar", tlb);
         }
+
+        [Fact]
+        public void ExerciseCacheSerialization()
+        {
+            AssemblyRegistrationCache arc = new();
+            arc.AddEntry("foo", "bar");
+            AssemblyRegistrationCache arc2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                arc.SerializeCache(file.Path, null);
+                arc2 = StateFileBase.DeserializeCache(file.Path, null, typeof(AssemblyRegistrationCache)) as AssemblyRegistrationCache;
+            }
+
+            arc2._assemblies.Count.ShouldBe(arc._assemblies.Count);
+            arc2._assemblies[0].ShouldBe(arc._assemblies[0]);
+            arc2._typeLibraries.Count.ShouldBe(arc._typeLibraries.Count);
+            arc2._typeLibraries[0].ShouldBe(arc._typeLibraries[0]);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index 7af8f468716..6437663437c 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -259,6 +260,38 @@ public void GetSDKReferenceFolders()
             VerifySDKFolders(getReferenceFolders, getReferenceFolders2, "References", _sdkDirectory);
         }
 
+        [Fact]
+        public void VerifyGetSdkReferenceTranslator()
+        {
+            Dictionary<string, GetSDKReferenceFiles.SdkReferenceInfo> pathToReferenceMetadata = new();
+            pathToReferenceMetadata.Add("first", new("dat", "dat2", true, false));
+            pathToReferenceMetadata.Add("second", new("inf", "inf2", false, false));
+            Dictionary<string, List<string>> directoryToFileList = new();
+            directoryToFileList.Add("third", new List<string>() { "a", "b", "c" });
+            directoryToFileList.Add("fourth", new List<string>() { "1", "2", "3" });
+            GetSDKReferenceFiles.SDKInfo writeInfo = new(pathToReferenceMetadata, directoryToFileList, 47);
+            GetSDKReferenceFiles.SaveContext contextWriter = new("d", "n", writeInfo);
+            GetSDKReferenceFiles.SDKInfo readInfo = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = env.CreateFolder();
+                GetSDKReferenceFiles.SDKFilesCache cache = new(null, folder.Path, null, null, null);
+                cache.SaveAssemblyListToCacheFile(contextWriter);
+                GetSDKReferenceFiles.SDKFilesCache cache2 = new(null, folder.Path, null, null, null);
+                readInfo = cache2.LoadAssemblyListFromCacheFile("d", "n");
+            }
+            readInfo.DirectoryToFileList.Count.ShouldBe(2);
+            readInfo.DirectoryToFileList["fourth"].Count.ShouldBe(3);
+            readInfo.DirectoryToFileList["fourth"][1].ShouldBe("2");
+            readInfo.DirectoryToFileList["third"][0].ShouldBe("a");
+            readInfo.Hash.ShouldBe(47);
+            readInfo.PathToReferenceMetadata.Count.ShouldBe(2);
+            readInfo.PathToReferenceMetadata["first"].FusionName.ShouldBe("dat");
+            readInfo.PathToReferenceMetadata["first"].IsManagedWinmd.ShouldBeFalse();
+            readInfo.PathToReferenceMetadata["first"].IsWinMD.ShouldBeTrue();
+            readInfo.PathToReferenceMetadata["second"].ImageRuntime.ShouldBe("inf2");
+        }
+
         private static void VerifySDKFolders(GetSDKFolders singleParamDelegate, GetSDKFolders2 multiParamDelegate, string folderName, string sdkDirectory)
         {
             IList<string> sdkFolders = singleParamDelegate(sdkDirectory);
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index f8c1c4855f7..4e695b86a73 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -14,6 +14,9 @@
 using Microsoft.Build.Tasks;
 using Xunit;
 using Microsoft.Build.Shared;
+using System.IO;
+using Microsoft.Build.BackEnd;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -57,6 +60,29 @@ public void GetResolvedASsemblyReferenceSpecNotNull()
             Assert.NotNull(task.GetResolvedAssemblyReferenceItemSpecs());
         }
 
+        [Fact]
+        public void TestSerializationAndDeserialization()
+        {
+            ResolveComReferenceCache cache = new("path1", "path2");
+            cache.componentTimestamps = new()
+            {
+                { "first", DateTime.Now },
+                { "second", DateTime.FromBinary(10000) },
+            };
+            ResolveComReferenceCache cache2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                cache.SerializeCache(file.Path, null);
+                cache2 = StateFileBase.DeserializeCache(file.Path, null, typeof(ResolveComReferenceCache)) as ResolveComReferenceCache;
+            }
+
+            cache2.tlbImpLocation.ShouldBe(cache.tlbImpLocation);
+            cache2.axImpLocation.ShouldBe(cache.axImpLocation);
+            cache2.componentTimestamps.Count.ShouldBe(cache.componentTimestamps.Count);
+            cache2.componentTimestamps["second"].ShouldBe(cache.componentTimestamps["second"]);
+        }
+
         /*
          * Method:  CheckComReferenceAttributeVerificationForNameItems
          * 
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
index a48675078f4..fa4c5af5675 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
@@ -6,6 +6,8 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
+using Shouldly;
+using System;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -16,35 +18,64 @@ sealed public class ResGenDependencies_Tests
 
         public void DirtyCleanScenario(bool useMSBuildResXReader)
         {
-            ResGenDependencies cache = new ResGenDependencies();
-
+            ResGenDependencies cache = new();
             string resx = CreateSampleResx();
             string stateFile = FileUtilities.GetTemporaryFile();
 
             try
             {
                 // A newly created cache is not dirty.
-                Assert.False(cache.IsDirty);
+                cache.IsDirty.ShouldBeFalse();
+
+                ResGenDependencies.PortableLibraryFile libFile = new("otherFileName");
+                libFile.outputFiles = new string[] { "first", "second" };
+                libFile.assemblySimpleName = "simpleName";
+                libFile.lastModified = DateTime.Now.Subtract(TimeSpan.FromSeconds(10));
+                cache.portableLibraries.Add("fileName", libFile);
+
+                // Writing the file to disk should make the cache clean.
+                cache.SerializeCache(stateFile, /* Log */ null);
+                cache.IsDirty.ShouldBeFalse();
 
                 // Getting a file that wasn't in the cache is a write operation.
                 cache.GetResXFileInfo(resx, useMSBuildResXReader);
-                Assert.True(cache.IsDirty);
+                cache.IsDirty.ShouldBeTrue();
 
-                // Writing the file to disk should make the cache clean.
+                // Add linkedFiles to further test serialization and deserialization.
+                cache.resXFiles.TryGetValue(resx, out ResGenDependencies.ResXFile file).ShouldBeTrue();
+                file.linkedFiles = new string[] { "third", "fourth" };
+
+                // Writing the file to disk should make the cache clean again.
                 cache.SerializeCache(stateFile, /* Log */ null);
-                Assert.False(cache.IsDirty);
+                cache.IsDirty.ShouldBeFalse();
 
                 // Deserialize from disk. Result should not be dirty.
-                cache = ResGenDependencies.DeserializeCache(stateFile, true, /* Log */ null);
-                Assert.False(cache.IsDirty);
+                ResGenDependencies cache2 = ResGenDependencies.DeserializeCache(stateFile, true, /* Log */ null);
+                cache2.IsDirty.ShouldBeFalse();
+
+                // Validate that serialization worked
+                cache.portableLibraries.TryGetValue("fileName", out ResGenDependencies.PortableLibraryFile portableLibrary);
+                cache2.portableLibraries.TryGetValue("fileName", out ResGenDependencies.PortableLibraryFile portableLibrary2);
+                portableLibrary2.filename.ShouldBe(portableLibrary.filename);
+                portableLibrary2.exists.ShouldBe(portableLibrary.exists);
+                portableLibrary2.assemblySimpleName.ShouldBe(portableLibrary.assemblySimpleName);
+                portableLibrary2.lastModified.ShouldBe(portableLibrary.lastModified);
+                portableLibrary2.outputFiles.Length.ShouldBe(portableLibrary.outputFiles.Length);
+                portableLibrary2.outputFiles[1].ShouldBe(portableLibrary.outputFiles[1]);
+                cache.resXFiles.TryGetValue(resx, out ResGenDependencies.ResXFile resX);
+                cache2.resXFiles.TryGetValue(resx, out ResGenDependencies.ResXFile resX2);
+                resX2.filename.ShouldBe(resX.filename);
+                resX2.lastModified.ShouldBe(resX.lastModified);
+                resX2.linkedFiles.Length.ShouldBe(resX.linkedFiles.Length);
+                resX2.linkedFiles[1].ShouldBe(resX.linkedFiles[1]);
 
                 // Asking for a file that's in the cache should not dirty the cache.
-                cache.GetResXFileInfo(resx, useMSBuildResXReader);
-                Assert.False(cache.IsDirty);
+                cache2.GetResXFileInfo(resx, useMSBuildResXReader);
+                cache2.IsDirty.ShouldBeFalse();
 
                 // Changing UseSourcePath to false should dirty the cache.
-                cache.UseSourcePath = false;
-                Assert.True(cache.IsDirty);
+                cache2.UseSourcePath = false;
+                cache2.IsDirty.ShouldBeTrue();
             }
             finally
             {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 169eebec17a..ec3bf0b9d8b 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2003,12 +2003,12 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
         /// </summary>
         internal void ReadStateFile(FileExists fileExists)
         {
-            _cache = SystemState.DeserializeCacheByTranslator(_stateFile, Log);
+            _cache = SystemState.DeserializeCache(_stateFile, Log, typeof(SystemState)) as SystemState;
 
             // Construct the cache only if we can't find any caches.
             if (_cache == null && AssemblyInformationCachePaths != null && AssemblyInformationCachePaths.Length > 0)
             {
-                _cache = SystemState.DeserializePrecomputedCachesByTranslator(AssemblyInformationCachePaths, Log, fileExists);
+                _cache = SystemState.DeserializePrecomputedCaches(AssemblyInformationCachePaths, Log, fileExists);
             }
 
             if (_cache == null)
@@ -2024,11 +2024,11 @@ internal void WriteStateFile()
         {
             if (!String.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
             {
-                _cache.SerializePrecomputedCacheByTranslator(AssemblyInformationCacheOutputPath, Log);
+                _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log);
             }
             else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
             {
-                _cache.SerializeCacheByTranslator(_stateFile, Log);
+                _cache.SerializeCache(_stateFile, Log);
             }
         }
         #endregion
@@ -2265,7 +2265,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     // Cache delegates.
                     getAssemblyName = _cache.CacheDelegate(getAssemblyName);
                     getAssemblyMetadata = _cache.CacheDelegate(getAssemblyMetadata);
-                    fileExists = _cache.CacheDelegate(fileExists);
+                    fileExists = _cache.CacheDelegate();
                     directoryExists = _cache.CacheDelegate(directoryExists);
                     getDirectories = _cache.CacheDelegate(getDirectories);
                     getRuntimeVersion = _cache.CacheDelegate(getRuntimeVersion);
diff --git a/src/Tasks/AssemblyRegistrationCache.cs b/src/Tasks/AssemblyRegistrationCache.cs
index 63ae6fdd833..3877f422450 100644
--- a/src/Tasks/AssemblyRegistrationCache.cs
+++ b/src/Tasks/AssemblyRegistrationCache.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -10,18 +11,19 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// This class is a caching mechanism for the Register/UnregisterAssembly task to keep track of registered assemblies to clean up
     /// </remarks>
-    [Serializable()]
-    internal sealed class AssemblyRegistrationCache : StateFileBase
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
+    [Serializable]
+    internal sealed class AssemblyRegistrationCache : StateFileBase, ITranslatable
     {
         /// <summary>
         /// The list of registered assembly files.
         /// </summary>
-        private readonly List<string> _assemblies = new List<string>();
+        internal List<string> _assemblies = new List<string>();
 
         /// <summary>
         /// The list of registered type library files.
         /// </summary>
-        private readonly List<string> _typeLibraries = new List<string>();
+        internal List<string> _typeLibraries = new List<string>();
 
         /// <summary>
         /// The number of entries in the state file
@@ -53,5 +55,19 @@ internal void GetEntry(int index, out string assemblyPath, out string typeLibrar
             assemblyPath = _assemblies[index];
             typeLibraryPath = _typeLibraries[index];
         }
+
+        public AssemblyRegistrationCache(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        public AssemblyRegistrationCache() { }
+
+        public override void Translate(ITranslator translator)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(translator, nameof(translator));
+            translator.Translate(ref _assemblies);
+            translator.Translate(ref _typeLibraries);
+        }
     }
 }
diff --git a/src/Tasks/Dependencies.cs b/src/Tasks/Dependencies.cs
deleted file mode 100644
index 80761d7464f..00000000000
--- a/src/Tasks/Dependencies.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections;
-
-namespace Microsoft.Build.Tasks
-{
-    /// <summary>
-    /// Represents a cache of inputs to a compilation-style task.
-    /// </summary>
-    /// <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>
-    [Serializable]
-    internal class Dependencies
-    {
-        /// <summary>
-        /// Hashtable of other dependency files.
-        /// Key is filename and value is DependencyFile.
-        /// </summary>
-        private Hashtable dependencies = new Hashtable();
-
-        /// <summary>
-        /// Look up a dependency file. Return null if its not there.
-        /// </summary>
-        /// <param name="filename"></param>
-        /// <returns></returns>
-        internal DependencyFile GetDependencyFile(string filename)
-        {
-            return (DependencyFile)dependencies[filename];
-        }
-
-        /// <summary>
-        /// Add a new dependency file.
-        /// </summary>
-        internal void AddDependencyFile(string filename, DependencyFile file)
-        {
-            dependencies[filename] = file;
-        }
-
-        /// <summary>
-        /// Remove new dependency file.
-        /// </summary>
-        internal void RemoveDependencyFile(string filename)
-        {
-            dependencies.Remove(filename);
-        }
-
-        /// <summary>
-        /// Remove all entries from the dependency table.
-        /// </summary>
-        internal void Clear()
-        {
-            dependencies.Clear();
-        }
-    }
-}
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index f8306894c3b..d517f39a296 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -12,20 +12,19 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// Represents a single input to a compilation-style task.
     /// Keeps track of timestamp for later comparison.
-    /// 
-    /// On-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
     [Serializable]
     internal class DependencyFile
     {
         // Filename
-        private string filename;
+        internal string filename;
 
         // Date and time the file was last modified           
-        private DateTime lastModified;
+        internal DateTime lastModified;
 
         // Whether the file exists or not.
-        private bool exists = false;
+        internal bool exists = false;
 
         /// <summary>
         /// The name of the file.
@@ -70,6 +69,10 @@ internal DependencyFile(string filename)
             }
         }
 
+        internal DependencyFile()
+        {
+        }
+
         /// <summary>
         /// Checks whether the file has changed since the last time a timestamp was recorded.
         /// </summary>
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 43b7d8ffcd9..4468c610426 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -9,9 +9,9 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Runtime.Serialization.Formatters.Binary;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -877,7 +877,7 @@ public bool Equals(ResolvedRedistFile other)
         /// <summary>
         /// Methods which are used to save and read the cache files per sdk from and to disk.
         /// </summary>
-        private class SDKFilesCache
+        internal class SDKFilesCache
         {
             /// <summary>
             ///  Thread-safe queue which contains exceptions throws during cache file reading and writing.
@@ -927,16 +927,15 @@ internal SDKInfo LoadAssemblyListFromCacheFile(string sdkIdentity, string sdkRoo
                 {
                     if (!string.IsNullOrEmpty(cacheFile))
                     {
-                        return SDKInfo.Deserialize(cacheFile);
+                        using FileStream fs = new FileStream(cacheFile, FileMode.Open);
+                        var translator = BinaryTranslator.GetReadTranslator(fs, buffer: null);
+                        SDKInfo sdkInfo = new SDKInfo();
+                        sdkInfo.Translate(translator);
+                        return sdkInfo;
                     }
                 }
-                catch (Exception e)
+                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                 {
-                    if (ExceptionHandling.IsCriticalException(e))
-                    {
-                        throw;
-                    }
-
                     // Queue up for later logging, does not matter if the file is deleted or not
                     _exceptionMessages.Enqueue(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("GetSDKReferenceFiles.ProblemReadingCacheFile", cacheFile, e.ToString()));
                 }
@@ -965,31 +964,21 @@ internal void SaveAssemblyListToCacheFile(object data)
                         {
                             File.Delete(existingCacheFile);
                         }
-                        catch (Exception e)
+                        catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                         {
-                            if (ExceptionHandling.IsCriticalException(e))
-                            {
-                                throw;
-                            }
-
                             // Queue up for later logging, does not matter if the file is deleted or not
                             _exceptionMessages.Enqueue(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("GetSDKReferenceFiles.ProblemDeletingCacheFile", existingCacheFile, e.Message));
                         }
                     }
 
-                    var formatter = new BinaryFormatter();
                     using (var fs = new FileStream(referencesCacheFile, FileMode.Create))
                     {
-                        formatter.Serialize(fs, cacheFileInfo);
+                        var translator = BinaryTranslator.GetWriteTranslator(fs);
+                        cacheFileInfo.Translate(translator);
                     }
                 }
-                catch (Exception e)
+                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                 {
-                    if (ExceptionHandling.IsCriticalException(e))
-                    {
-                        throw;
-                    }
-
                     // Queue up for later logging, does not matter if the cache got written
                     _exceptionMessages.Enqueue(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("GetSDKReferenceFiles.ProblemWritingCacheFile", referencesCacheFile, e.Message));
                 }
@@ -1205,11 +1194,8 @@ private static IEnumerable<string> GetAllReferenceDirectories(string sdkRoot)
         /// </summary>
         /// <remarks>This is a serialization format. Do not change member naming.</remarks>
         [Serializable]
-        private class SdkReferenceInfo
+        internal class SdkReferenceInfo
         {
-            /// <summary>
-            /// Constructor
-            /// </summary>
             public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bool isManagedWinmd)
             {
                 FusionName = fusionName;
@@ -1219,25 +1205,11 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo
             }
 
             #region Properties
-            /// <summary>
-            /// The fusionName
-            /// </summary>
-            public string FusionName { get; }
 
-            /// <summary>
-            /// Is the file a winmd or not
-            /// </summary>
-            public bool IsWinMD { get; }
-
-            /// <summary>
-            /// Is the file a managed winmd or not
-            /// </summary>
-            public bool IsManagedWinmd { get; }
-
-            /// <summary>
-            /// What is the imageruntime information on it.
-            /// </summary>
-            public string ImageRuntime { get; }
+            public string FusionName { get; internal set; }
+            public bool IsWinMD { get; internal set; }
+            public bool IsManagedWinmd { get; internal set; }
+            public string ImageRuntime { get; internal set; }
 
             #endregion
         }
@@ -1245,64 +1217,75 @@ public SdkReferenceInfo(string fusionName, string imageRuntime, bool isWinMD, bo
         /// <summary>
         /// Structure that contains the on disk representation of the SDK in memory.
         /// </summary>
-        /// <remarks>This is a serialization format. Do not change member naming.</remarks>
-        [Serializable]
-        private class SDKInfo
+        internal class SDKInfo : ITranslatable
         {
-            // Current version for serialization. This should be changed when breaking changes
-            // are made to this class.
-            private const byte CurrentSerializationVersion = 1;
+            private IDictionary<string, SdkReferenceInfo> _pathToReferenceMetadata;
+            private IDictionary<string, List<string>> _directoryToFileList;
+            private int _hash;
 
-            // Version this instance is serialized with.
-            private byte _serializedVersion = CurrentSerializationVersion;
+            internal SDKInfo()
+            {
+                _pathToReferenceMetadata = new Dictionary<string, SdkReferenceInfo>(StringComparer.OrdinalIgnoreCase);
+                _directoryToFileList = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+                _hash = 0;
+            }
 
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            public SDKInfo(ConcurrentDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, ConcurrentDictionary<string, List<string>> directoryToFileList, int cacheHash)
+            public SDKInfo(ITranslator translator) : this()
+            {
+                Translate(translator);
+            }
+
+            public SDKInfo(IDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, IDictionary<string, List<string>> directoryToFileList, int cacheHash)
             {
-                PathToReferenceMetadata = pathToReferenceMetadata;
-                DirectoryToFileList = directoryToFileList;
-                Hash = cacheHash;
+                this._pathToReferenceMetadata = pathToReferenceMetadata;
+                this._directoryToFileList = directoryToFileList;
+                this._hash = cacheHash;
             }
 
             /// <summary>
             /// A dictionary which maps a file path to a structure that contain some metadata information about that file.
             /// </summary>
-            public ConcurrentDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get; }
+            public IDictionary<string, SdkReferenceInfo> PathToReferenceMetadata { get { return _pathToReferenceMetadata; } }
 
-            /// <summary>
-            /// Dictionary which maps a directory to a list of file names within that directory. This is used to shortcut hitting the disk for the list of files inside of it.
-            /// </summary>
-            public ConcurrentDictionary<string, List<string>> DirectoryToFileList { get; }
+            public IDictionary<string, List<string>> DirectoryToFileList { get { return _directoryToFileList; } }
 
             /// <summary>
             /// Hashset
             /// </summary>
-            public int Hash { get; }
+            public int Hash { get { return _hash; } }
 
-            public static SDKInfo Deserialize(string cacheFile)
+            public void Translate(ITranslator translator)
             {
-                using (var fs = new FileStream(cacheFile, FileMode.Open))
+                translator.TranslateDictionary(ref _pathToReferenceMetadata, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref SdkReferenceInfo info) =>
                 {
-                    var formatter = new BinaryFormatter();
-                    var info = (SDKInfo)formatter.Deserialize(fs);
-
-                    // If the serialization versions don't match, don't use the cache
-                    if (info != null && info._serializedVersion != CurrentSerializationVersion)
-                    {
-                        return null;
-                    }
+                    info ??= new SdkReferenceInfo(null, null, false, false);
+                    string fusionName = info.FusionName;
+                    string imageRuntime = info.ImageRuntime;
+                    bool isManagedWinmd = info.IsManagedWinmd;
+                    bool isWinmd = info.IsWinMD;
+                    t.Translate(ref fusionName);
+                    t.Translate(ref imageRuntime);
+                    t.Translate(ref isManagedWinmd);
+                    t.Translate(ref isWinmd);
+                    info.FusionName = fusionName;
+                    info.ImageRuntime = imageRuntime;
+                    info.IsManagedWinmd = isManagedWinmd;
+                    info.IsWinMD = isWinmd;
+                }, count => new Dictionary<string, SdkReferenceInfo>(count, StringComparer.OrdinalIgnoreCase));
+
+                translator.TranslateDictionary(ref _directoryToFileList, (ITranslator t, ref string s) => t.Translate(ref s), (ITranslator t, ref List<string> fileList) =>
+                {
+                    t.Translate(ref fileList, (ITranslator t, ref string str) => { t.Translate(ref str); });
+                }, count => new Dictionary<string, List<string>>(count, StringComparer.OrdinalIgnoreCase));
 
-                    return info;
-                }
+                translator.Translate(ref _hash);
             }
         }
 
         /// <summary>
         /// This class represents the context information used by the background cache serialization thread.
         /// </summary>
-        private class SaveContext
+        internal class SaveContext
         {
             /// <summary>
             /// Constructor
diff --git a/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hans.xlf b/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hans.xlf
index da31d6c6870..3c85e336dcc 100644
--- a/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hans.xlf
+++ b/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hans.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANS" original="../Strings.ManifestUtilities.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.ManifestUtilities.resx">
     <body>
       <trans-unit id="ComImporter.LocalServerNotSupported">
         <source>Out of process servers are not supported</source>
diff --git a/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hant.xlf b/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hant.xlf
index 66e11016717..a0726f458b3 100644
--- a/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hant.xlf
+++ b/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hant.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANT" original="../Strings.ManifestUtilities.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.ManifestUtilities.resx">
     <body>
       <trans-unit id="ComImporter.LocalServerNotSupported">
         <source>Out of process servers are not supported</source>
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index d4fe3572301..cf4b7cdebe7 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -854,19 +854,20 @@ private static bool IsCertInStore(X509Certificate2 cert)
 
         private static string GetVersionIndependentToolPath(string toolName)
         {
-            RegistryKey localMachineKey = Registry.LocalMachine;
             const string versionIndependentToolKeyName = @"Software\Microsoft\ClickOnce\SignTool";
-
-            using (RegistryKey versionIndependentToolKey = localMachineKey.OpenSubKey(versionIndependentToolKeyName, writable: false))
+            using (RegistryKey localMachineKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32))
             {
-                string versionIndependentToolPath = null;
-
-                if (versionIndependentToolKey != null)
+                using (RegistryKey versionIndependentToolKey = localMachineKey.OpenSubKey(versionIndependentToolKeyName, writable: false))
                 {
-                    versionIndependentToolPath = versionIndependentToolKey.GetValue("Path") as string;
-                }
+                    string versionIndependentToolPath = null;
 
-                return versionIndependentToolPath != null ? Path.Combine(versionIndependentToolPath, toolName) : null;
+                    if (versionIndependentToolKey != null)
+                    {
+                        versionIndependentToolPath = versionIndependentToolKey.GetValue("Path") as string;
+                    }
+
+                    return versionIndependentToolPath != null ? Path.Combine(versionIndependentToolPath, toolName) : null;
+                }
             }
         }
     }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index d24a745ce88..59a0224820f 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -551,7 +551,6 @@
     <Compile Include="CodeTaskFactory.cs" />
     <Compile Include="XamlTaskFactory\XamlTaskFactory.cs" />
     <Compile Include="StateFileBase.cs" />
-    <Compile Include="Dependencies.cs" />
     <Compile Include="SystemState.cs" />
     <Compile Include="DependencyFile.cs" />
     <Compile Include="ZipDirectory.cs" />
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index f5955642de1..0246dd8beda 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -190,7 +190,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                  @(CustomAdditionalCompileOutputs)"
         Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != ''"
         Returns=""
-        DependsOnTargets="$(CoreCompileDependsOn)"
+        DependsOnTargets="$(CoreCompileDependsOn);GenerateMSBuildEditorConfigFile"
     >
        <!-- These two compiler warnings are raised when a reference is bound to a different version
              than specified in the assembly reference version number.  MSBuild raises the same warning in this case,
@@ -239,6 +239,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               AddModules="@(AddModules)"
               AdditionalFiles="@(AdditionalFiles)"
               AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
+              AnalyzerConfigFiles="@(EditorConfigFiles)"
               Analyzers="@(Analyzer)"
               ApplicationConfiguration="$(AppConfigForCompiler)"
               BaseAddress="$(BaseAddress)"
diff --git a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
index 512fa288efc..45f937a1389 100644
--- a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
@@ -191,7 +191,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                  $(NonExistentFile);
                  @(CustomAdditionalCompileOutputs)"
         Returns=""
-        DependsOnTargets="$(CoreCompileDependsOn)"
+        DependsOnTargets="$(CoreCompileDependsOn);GenerateMSBuildEditorConfigFile"
         Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != ''"
     >
         <PropertyGroup>
@@ -232,6 +232,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               AdditionalLibPaths="$(AdditionalLibPaths)"
               AddModules="@(AddModules)"
               AdditionalFiles="@(AdditionalFiles)"
+              AnalyzerConfigFiles="@(EditorConfigFiles)"
+              Analyzers="@(Analyzer)"
               BaseAddress="$(BaseAddress)"
               CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)"
               CodePage="$(CodePage)"
@@ -277,6 +279,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               RootNamespace="$(RootNamespace)"
               PdbFile="$(PdbFile)"
               SdkPath="$(FrameworkPathOverride)"
+              SkipAnalyzers="$(_SkipAnalyzers)"
               Sources="@(Compile)"
               SubsystemVersion="$(SubsystemVersion)"
               TargetCompactFramework="$(TargetCompactFramework)"
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 3632a916d83..35b26a5e72f 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -8,7 +8,7 @@
 using System.IO;
 using System.Resources;
 using System.Xml;
-
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.ResourceHandling;
@@ -22,18 +22,19 @@ namespace Microsoft.Build.Tasks
     /// 
     /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
     [Serializable]
-    internal sealed class ResGenDependencies : StateFileBase
+    internal sealed class ResGenDependencies : StateFileBase, ITranslatable
     {
         /// <summary>
         /// The list of resx files.
         /// </summary>
-        private Dependencies resXFiles = new Dependencies();
+        internal IDictionary<string, ResXFile> resXFiles = new Dictionary<string, ResXFile>();
 
         /// <summary>
         /// A list of portable libraries and the ResW files they can produce.
         /// </summary>
-        private Dependencies portableLibraries = new Dependencies();
+        internal IDictionary<string, PortableLibraryFile> portableLibraries = new Dictionary<string, PortableLibraryFile>();
 
         /// <summary>
         /// A newly-created ResGenDependencies is not dirty.
@@ -47,7 +48,7 @@ internal sealed class ResGenDependencies : StateFileBase
         ///  If this is NULL then we use the directory in which the .resx is in (that should always
         ///  be the default!)
         /// </summary>
-        private string baseLinkedFileDirectory;
+        internal string baseLinkedFileDirectory;
 
         internal string BaseLinkedFileDirectory
         {
@@ -90,11 +91,38 @@ internal bool UseSourcePath
             }
         }
 
+        public ResGenDependencies() { }
+
+        public ResGenDependencies(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        public override void Translate(ITranslator translator)
+        {
+            translator.TranslateDictionary(ref resXFiles,
+                (ITranslator translator, ref string s) => translator.Translate(ref s),
+                (ITranslator translator, ref ResXFile resx) => {
+                    ResXFile temp = resx ?? new();
+                    temp.Translate(translator);
+                    resx = temp;
+                },
+                count => new Dictionary<string, ResXFile>(count));
+            translator.TranslateDictionary(ref portableLibraries,
+                (ITranslator translator, ref string s) => translator.Translate(ref s),
+                (ITranslator translator, ref PortableLibraryFile portableLibrary) => {
+                    PortableLibraryFile temp = portableLibrary ?? new();
+                    temp.Translate(translator);
+                    portableLibrary = temp;
+                },
+                count => new Dictionary<string, PortableLibraryFile>(count));
+            translator.Translate(ref baseLinkedFileDirectory);
+        }
+
         internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
         {
             // First, try to retrieve the resx information from our hashtable.
-            var retVal = (ResXFile)resXFiles.GetDependencyFile(resxFile);
-            if (retVal == null)
+            if (!resXFiles.TryGetValue(resxFile, out ResXFile retVal))
             {
                 // Ok, the file wasn't there.  Add it to our cache and return it to the caller.  
                 retVal = AddResxFile(resxFile, useMSBuildResXReader);
@@ -105,7 +133,7 @@ internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
                 // by removing it from the hashtable and readding it.
                 if (retVal.HasFileChanged())
                 {
-                    resXFiles.RemoveDependencyFile(resxFile);
+                    resXFiles.Remove(resxFile);
                     _isDirty = true;
                     retVal = AddResxFile(resxFile, useMSBuildResXReader);
                 }
@@ -120,7 +148,7 @@ private ResXFile AddResxFile(string file, bool useMSBuildResXReader)
             // to be cracked for contained files.
 
             var resxFile = new ResXFile(file, BaseLinkedFileDirectory, useMSBuildResXReader);
-            resXFiles.AddDependencyFile(file, resxFile);
+            resXFiles.Add(file, resxFile);
             _isDirty = true;
             return resxFile;
         }
@@ -128,13 +156,13 @@ private ResXFile AddResxFile(string file, bool useMSBuildResXReader)
         internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
         {
             // First, try to retrieve the portable library information from our hashtable.  
-            var retVal = (PortableLibraryFile)portableLibraries.GetDependencyFile(libraryPath);
+            portableLibraries.TryGetValue(libraryPath, out PortableLibraryFile retVal);
 
             // The file is in our cache.  Make sure it's up to date.  If not, discard
             // this entry from the cache and rebuild all the state at a later point.
             if (retVal?.HasFileChanged() == true)
             {
-                portableLibraries.RemoveDependencyFile(libraryPath);
+                portableLibraries.Remove(libraryPath);
                 _isDirty = true;
                 retVal = null;
             }
@@ -144,11 +172,10 @@ internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
 
         internal void UpdatePortableLibrary(PortableLibraryFile library)
         {
-            var cached = (PortableLibraryFile)portableLibraries.GetDependencyFile(library.FileName);
-            if (cached == null || !library.Equals(cached))
+            if (!portableLibraries.TryGetValue(library.FileName, out PortableLibraryFile cached) || !library.Equals(cached))
             {
                 // Add a new entry or replace the existing one.
-                portableLibraries.AddDependencyFile(library.FileName, library);
+                portableLibraries.Add(library.FileName, library);
                 _isDirty = true;
             }
         }
@@ -188,11 +215,12 @@ internal static ResGenDependencies DeserializeCache(string stateFile, bool useSo
         /// 
         /// This is an on-disk serialization format, don't change field names or types or use readonly.
         /// </remarks>
+        /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
         [Serializable]
-        internal sealed class ResXFile : DependencyFile
+        internal sealed class ResXFile : DependencyFile, ITranslatable
         {
             // Files contained within this resx file.
-            private string[] linkedFiles;
+            internal string[] linkedFiles;
 
             internal string[] LinkedFiles => linkedFiles;
 
@@ -209,6 +237,18 @@ internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBui
                 }
             }
 
+            internal ResXFile()
+            {
+            }
+
+            public void Translate(ITranslator translator)
+            {
+                translator.Translate(ref linkedFiles);
+                translator.Translate(ref filename);
+                translator.Translate(ref lastModified);
+                translator.Translate(ref exists);
+            }
+
             /// <summary>
             /// Given a .RESX file, returns all the linked files that are referenced within that .RESX.
             /// </summary>
@@ -281,12 +321,27 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
         /// 
         /// This is an on-disk serialization format, don't change field names or types or use readonly.
         /// </remarks>
+        /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
         [Serializable]
-        internal sealed class PortableLibraryFile : DependencyFile
+        internal sealed class PortableLibraryFile : DependencyFile, ITranslatable
         {
-            private string[] outputFiles;
-            private string neutralResourceLanguage;
-            private string assemblySimpleName;
+            internal string[] outputFiles;
+            internal string neutralResourceLanguage;
+            internal string assemblySimpleName;
+
+            internal PortableLibraryFile()
+            {
+            }
+
+            public void Translate(ITranslator translator)
+            {
+                translator.Translate(ref assemblySimpleName);
+                translator.Translate(ref outputFiles);
+                translator.Translate(ref neutralResourceLanguage);
+                translator.Translate(ref filename);
+                translator.Translate(ref lastModified);
+                translator.Translate(ref exists);
+            }
 
             internal PortableLibraryFile(string filename)
                 : base(filename)
diff --git a/src/Tasks/ResolveComReferenceCache.cs b/src/Tasks/ResolveComReferenceCache.cs
index d0f80dca18f..133acb02f6f 100644
--- a/src/Tasks/ResolveComReferenceCache.cs
+++ b/src/Tasks/ResolveComReferenceCache.cs
@@ -2,7 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -16,17 +17,18 @@ namespace Microsoft.Build.Tasks
     /// 
     /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
     [Serializable]
-    internal sealed class ResolveComReferenceCache : StateFileBase
+    internal sealed class ResolveComReferenceCache : StateFileBase, ITranslatable
     {
         /// <summary>
         /// Component timestamps. 
         /// Key: Component path on disk
         /// Value: DateTime struct
         /// </summary>
-        private Hashtable componentTimestamps;
-        private string tlbImpLocation;
-        private string axImpLocation;
+        internal Dictionary<string, DateTime> componentTimestamps;
+        internal string tlbImpLocation;
+        internal string axImpLocation;
 
         /// <summary>
         /// indicates whether the cache contents have changed since it's been created
@@ -46,7 +48,7 @@ internal ResolveComReferenceCache(string tlbImpPath, string axImpPath)
 
             tlbImpLocation = tlbImpPath;
             axImpLocation = axImpPath;
-            componentTimestamps = new Hashtable();
+            componentTimestamps = new();
         }
 
         /// <summary>
@@ -69,9 +71,9 @@ internal DateTime this[string componentPath]
         {
             get
             {
-                if (componentTimestamps.ContainsKey(componentPath))
+                if (componentTimestamps.TryGetValue(componentPath, out DateTime time))
                 {
-                    return (DateTime)componentTimestamps[componentPath];
+                    return time;
                 }
 
                 // If the entry is not present in the cache, return the current time. Since no component should be timestamped
@@ -81,12 +83,24 @@ internal DateTime this[string componentPath]
             set
             {
                 // only set the value and dirty the cache if the timestamp doesn't exist yet or is different than the current one
-                if (DateTime.Compare(this[componentPath], value) != 0)
+                if (!DateTime.Equals(this[componentPath], value))
                 {
                     componentTimestamps[componentPath] = value;
                     _dirty = true;
                 }
             }
         }
+
+        public ResolveComReferenceCache(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        public override void Translate(ITranslator translator)
+        {
+            translator.Translate(ref axImpLocation);
+            translator.Translate(ref tlbImpLocation);
+            translator.TranslateDictionary(ref componentTimestamps, StringComparer.Ordinal);
+        }
     }
 }
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 35da63a960a..47e2693228e 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">Hodnota parametru „{0}“ se nemohla převést na odvozený typ „{1}“. Hodnota se zpracuje jako řetězec. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: Hodnota parametru „{0}“ se nemohla převést na „{1}“. {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">Nepovedlo se odvodit typ parametru „{0}“, protože typ atributu je neznámý. Hodnota se zpracuje jako řetězec.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Pro typ odvození se našlo víc konstruktorů atributů.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: Typ „{0}“ ne nenašel.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 6c21e3d0602..2764a459b17 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">Der Wert für den Parameter "{0}" konnte nicht in den abgeleiteten Typ "{1}" konvertiert werden. Der Wert wird als Zeichenfolge behandelt. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: Der Parameterwert "{0}" konnte nicht in "{1}" konvertiert werden. {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">Der Typ des Parameters "{0}" konnte nicht rückgeschlossen werden, da der Attributtyp unbekannt ist. Der Wert wird als Zeichenfolge behandelt.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Für den Typ "Rückschließen" wurden mehrere Attribut-Konstruktoren gefunden.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: Der Typ "{0}" wurde nicht gefunden.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 3b174607b9e..abce121ff65 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">No se pudo convertir el valor del parámetro "{0}" al tipo deducido "{1}". El valor se tratará como una cadena. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: el valor de parámetro "{0}" no se pudo convertir en "{1}". {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">No se puede inferir el tipo de parámetro "{0}" porque el tipo de atributo es desconocido. El valor se tratará como una cadena.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Se encontraron varios constructores de atributos para la inferencia de tipos.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: no se encontró el tipo "{0}".</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 446990d0219..5796f3152fc 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">Impossible de convertir la valeur du paramètre « {0} » en type différé « {1} ». La valeur est traitée comme une chaîne. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: la valeur du paramètre « {0} » ne peut pas être convertie en « {1} ». {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">Impossible d’inférer le type de paramètre « {0} », car le type d’attribut est inconnu. La valeur sera considérée comme une chaîne.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Plusieurs constructeurs d’attributs ont été trouvées pour l’inférence de type.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: le type « {0} » est introuvable.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 46ca3855406..50aa55dd16b 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
@@ -511,7 +511,7 @@
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
         <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
-        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <target state="translated">MSB3667: alla posizione "{0}" esiste già un file. Se si prova a creare una cache precalcolata, assicurarsi di compilare un singolo progetto che dipende dagli assembly invece di compilare gli assembly stessi. Se si esegue normalmente l'attività ResolveAssemblyReference, non impostare il parametro "AssemblyInformationCacheOutputPath" dell'attività ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">Impossibile convertire il valore del parametro "{0}" nel tipo inferito "{1}". Il valore sarà trattato come una stringa. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: Il valore "{0}" del parametro non può essere convertito in "{1}". {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">Non è stato possibile inferire il tipo di parametro "{0}" perché il tipo di attributo è sconosciuto. Il valore sarà trattto come una stringa.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Sono stati trovati più costruttori di attributi per il tipo di inferenza.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: Il tipo "{0}" non è stato trovato.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index eb5aeb1b065..bf0e88d55ed 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">パラメーター "{0}" の値を推定型 "{1}" に変換できませんでした。この値は文字列として扱われます。{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: パラメーター値 "{0}" を "{1}" に変換できませんでした。{2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">属性の型が不明なため、パラメーター "{0}" の型を推測できませんでした。値は文字列として扱われます。</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">推論型に対して複数の属性のコンストラクターが見つかりました。</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: 型 "{0}" は見つかりませんでした。</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 6d49d15e1e8..0ffa4a11df8 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">매개 변수 "{0}"의 값을 유추된 유형 "{1}"(으)로 변환할 수 없습니다. 값이 문자열로 처리됩니다. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: 매개 변수 값 "{0}"(을)를 "{1}"(으)로 변환할 수 없습니다. {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">특성 유형을 알 수 없기 때문에 매개 변수 "{0}" 유형을 유추할 수 없습니다. 값이 문자열로 처리됩니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">유형 유추를 위해 여러 특성 생성자가 발견됨</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: "{0}" 형식을 찾을 수 없습니다.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index fb568f16651..0b07372babf 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">Nie można przekonwertować wartości parametru „{0}” na wywnioskowany typ „{1}. Wartość będzie traktowana jako ciąg. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: nie można przekonwertować wartości parametru „{0}” na „{1}”. {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">Nie można wywnioskować typu parametru „{0}”, ponieważ typ atrybutu jest nieznany. Wartość będzie traktowana jako ciąg.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Znaleziono wiele konstruktorów atrybutów w przypadku wnioskowania typu.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: nie znaleziono typu „{0}”.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 6e17e48ecc3..bff033eca29 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">Não foi possível converter o valor do parâmetro "{0}" no tipo inferido "{1}". O valor será tratado como uma cadeia de caracteres. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: não foi possível converter o valor de parâmetro "{0}" em "{1}". {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">Não foi possível deduzir o tipo de parâmetro "{0}" porque o tipo de atributo é desconhecido. O valor será tratado como uma cadeia de caracteres.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Foram encontrados vários construtores de atributos para a inferência de tipo.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: O tipo "{0}" não foi encontrado.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index ef92dc744b6..0319146c12b 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">Не удалось преобразовать значение параметра "{0}" в выведенный тип "{1}". Значение будет рассматриваться как строка. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: не удалось преобразовать значение параметра "{0}" в "{1}". {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">Не удалось вывести тип параметра "{0}", так как тип атрибута неизвестен. Значение будет рассматриваться как строка.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Для вывода типа обнаружено несколько конструкторов атрибутов.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: тип "{0}" не найден.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 582179e717c..d0d3f932959 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">"{0}" parametresinin değeri "{1}" çıkarsanan türe dönüştürülemedi. Değer bir dize olarak değerlendirilecek. {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: parametre değeri "{0}", "{1}" değerine dönüştürülemedi. {2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">Öznitelik türü bilinmediği için "{0}" parametresinin türü çıkarılamadı. Değer bir dizge olarak değerlendirilecektir.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">Tür çıkarımı için birden çok öznitelik oluşturucusu bulundu.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: "{0}" türü bulunamadı.</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 2d73459db6d..74e83975e40 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANS" original="../Strings.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
@@ -511,7 +511,7 @@
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
         <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
-        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <target state="translated">MSB3667: “{0}”处已存在文件。若要尝试创建预计算缓存，请务必生成单个依赖于程序集的项目，而不是生成程序集本身。如果在正常运行 ResolveAssemblyReference 任务，请不要设置 ResolveAssemblyReference 任务的 "AssemblyInformationCacheOutputPath" 参数。</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">无法将参数 "{0}" 的值转换为推断类型 "{1}"。该值将被视作字符串。{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: 参数值 "{0}" 无法转换为 "{1}"。{2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">由于属性类型未知，无法推断参数 "{0}" 的类型。该值将被视作字符串。</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">为类型推理找到了多个特性构造函数。</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: 未找到类型 "{0}"。</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 6d37bf3ca7d..337211ec03f 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANT" original="../Strings.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
       <trans-unit id="AppConfig.BindingRedirectMissingOldVersion">
         <source>BindingRedirect is missing required field 'oldVersion'.</source>
@@ -2557,27 +2557,27 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
         <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
-        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <target state="translated">無法將參數 "{0}" 的值轉換為推斷的類型 "{1}"。 該值將被視為字串。{2}</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
         <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
-        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <target state="translated">MSB3716: 無法將參數值 "{0}" 轉換為 "{1}"。{2}</target>
         <note>{StrBegin="MSB3716: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <target state="translated">由於屬性類型未知，因此無法推斷 "{0}" 的參數類型。該值將被視為字串。</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
         <source>Multiple attribute constructors were found for type inferencing.</source>
-        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <target state="translated">找到類型推斷的多屬性建構函式。</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
         <source>MSB3715: The type "{0}" was not found.</source>
-        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <target state="translated">MSB3715: 無法找到 "{0}" 類型。</target>
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index b5b34a31b0b..760fc3e83ec 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -3,18 +3,19 @@
 
 using System;
 using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.Tasks
 {
     /// <remarks>
     /// Base class for task state files.
     /// </remarks>
-    [Serializable()]
-    internal class StateFileBase
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
+    [Serializable]
+    internal abstract class StateFileBase
     {
         // Current version for serialization. This should be changed when breaking changes
         // are made to this class.
@@ -22,7 +23,7 @@ internal class StateFileBase
         // Version 4/5 - VS2017.7:
         //   Unify .NET Core + Full Framework. Custom serialization on some types that are no
         //   longer [Serializable].
-        private const byte CurrentSerializationVersion = 5;
+        internal const byte CurrentSerializationVersion = 6;
 
         // Version this instance is serialized with.
         private byte _serializedVersion = CurrentSerializationVersion;
@@ -43,24 +44,24 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
 
                     using (var s = new FileStream(stateFile, FileMode.CreateNew))
                     {
-                        var formatter = new BinaryFormatter();
-                        formatter.Serialize(s, this);
+                        var translator = BinaryTranslator.GetWriteTranslator(s);
+                        translator.Translate(ref _serializedVersion);
+                        Translate(translator);
                     }
                 }
             }
-            catch (Exception e)
+            // If there was a problem writing the file (like it's read-only or locked on disk, for
+            // example), then eat the exception and log a warning.  Otherwise, rethrow.
+            catch (Exception e) when (!ExceptionHandling.NotExpectedSerializationException(e))
             {
-                // If there was a problem writing the file (like it's read-only or locked on disk, for
-                // example), then eat the exception and log a warning.  Otherwise, rethrow.
-                if (ExceptionHandling.NotExpectedSerializationException(e))
-                    throw;
-
                 // Not being able to serialize the cache is not an error, but we let the user know anyway.
                 // Don't want to hold up processing just because we couldn't read the file.
                 log.LogWarningWithCodeFromResources("General.CouldNotWriteStateFile", stateFile, e.Message);
             }
         }
 
+        public abstract void Translate(ITranslator translator);
+
         /// <summary>
         /// Reads the specified file from disk into a StateFileBase derived object.
         /// </summary>
@@ -75,43 +76,40 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                 {
                     using (FileStream s = new FileStream(stateFile, FileMode.Open))
                     {
-                        var formatter = new BinaryFormatter();
-                        object deserializedObject = formatter.Deserialize(s);
-                        retVal = deserializedObject as StateFileBase;
+                        var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);
+                        byte version = 0;
+                        translator.Translate(ref version);
+                        var constructors = requiredReturnType.GetConstructors();
+                        foreach (var constructor in constructors)
+                        {
+                            var parameters = constructor.GetParameters();
+                            if (parameters.Length == 1 && parameters[0].ParameterType == typeof(ITranslator))
+                            {
+                                retVal = constructor.Invoke(new object[] { translator }) as StateFileBase;
+                            }
+                        }
 
-                        // If the deserialized object is null then there would be no cast error but retVal would still be null
-                        // only log the message if there would have been a cast error
-                        if (retVal == null && deserializedObject != null)
+                        // If retVal is still null or the version is wrong, log a message not a warning. This could be a valid cache with the wrong version preventing correct deserialization.
+                        // For the latter case, internals may be unexpectedly null.
+                        if (retVal == null || version != CurrentSerializationVersion)
                         {
                             // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due
                             // to a new version number on the tasks class. "Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase".
                             // If there is an invalid cast, a message rather than a warning should be emitted.
                             log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
+                            return null;
                         }
-
-                        if ((retVal != null) && (!requiredReturnType.IsInstanceOfType(retVal)))
+                        else if (!requiredReturnType.IsInstanceOfType(retVal))
                         {
                             log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile,
                                 log.FormatResourceString("General.IncompatibleStateFileType"));
                             retVal = null;
                         }
-
-                        // If we get back a valid object and internals were changed, things are likely to be null. Check the version before we use it.
-                        if (retVal != null && retVal._serializedVersion != CurrentSerializationVersion)
-                        {
-                            log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
-                            retVal = null;
-                        }
                     }
                 }
             }
-            catch (Exception e)
+            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                if (ExceptionHandling.IsCriticalException(e))
-                {
-                    throw;
-                }
-
                 // The deserialization process seems like it can throw just about 
                 // any exception imaginable.  Catch them all here.
                 // Not being able to deserialize the cache is not an error, but we let the user know anyway.
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 3f5ea428b0c..2992e07bc73 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
 using Microsoft.Build.Utilities;
 
@@ -21,12 +20,10 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Class is used to cache system state.
     /// </summary>
+    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
     [Serializable]
     internal sealed class SystemState : StateFileBase, ITranslatable
     {
-        private static readonly byte[] TranslateContractSignature = { (byte) 'M', (byte) 'B', (byte) 'R', (byte) 'S', (byte) 'C'}; // Microsoft Build RAR State Cache
-        private static readonly byte TranslateContractVersion = 0x01;
-
         /// <summary>
         /// Cache at the SystemState instance level. Has the same contents as <see cref="instanceLocalFileStateCache"/>.
         /// It acts as a flag to enforce that an entry has been checked for staleness only once.
@@ -89,11 +86,6 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// </summary>
         private GetAssemblyMetadata getAssemblyMetadata;
 
-        /// <summary>
-        /// Cached delegate.
-        /// </summary>
-        private FileExists fileExists;
-
         /// <summary>
         /// Cached delegate.
         /// </summary>
@@ -221,8 +213,13 @@ internal FrameworkName FrameworkNameAttribute
         /// <summary>
         /// Construct.
         /// </summary>
-        internal SystemState()
+        public SystemState()
+        {
+        }
+
+        public SystemState(ITranslator translator)
         {
+            Translate(translator);
         }
 
         /// <summary>
@@ -239,88 +236,11 @@ AssemblyTableInfo[] installedAssemblyTableInfos
             redistList = RedistList.GetRedistList(installedAssemblyTableInfos);
         }
 
-        /// <summary>
-        /// Writes the contents of this object out to the specified file.
-        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class
-        /// </summary>
-        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)
-        {
-            try
-            {
-                if (!string.IsNullOrEmpty(stateFile))
-                {
-                    if (FileSystems.Default.FileExists(stateFile))
-                    {
-                        File.Delete(stateFile);
-                    }
-
-                    using var s = new FileStream(stateFile, FileMode.CreateNew);
-                    var translator = BinaryTranslator.GetWriteTranslator(s);
-
-                    // write file signature
-                    translator.Writer.Write(TranslateContractSignature);
-                    translator.Writer.Write(TranslateContractVersion);
-
-                    Translate(translator);
-                    isDirty = false;
-                }
-            }
-            catch (Exception e) when (!ExceptionHandling.NotExpectedSerializationException(e))
-            {
-                // Not being able to serialize the cache is not an error, but we let the user know anyway.
-                // Don't want to hold up processing just because we couldn't read the file.
-                log.LogWarningWithCodeFromResources("General.CouldNotWriteStateFile", stateFile, e.Message);
-            }
-        }
-
-        /// <summary>
-        /// Read the contents of this object out to the specified file.
-        /// TODO: once all classes derived from StateFileBase adopt the new serialization, we should consider moving this into the base class
-        /// </summary>
-        internal static SystemState DeserializeCacheByTranslator(string stateFile, TaskLoggingHelper log)
-        {
-            // First, we read the cache from disk if one exists, or if one does not exist, we create one.
-            try
-            {
-                if (!string.IsNullOrEmpty(stateFile) && FileSystems.Default.FileExists(stateFile))
-                {
-                    using FileStream s = new FileStream(stateFile, FileMode.Open);
-                    var translator = BinaryTranslator.GetReadTranslator(s, buffer:null); // TODO: shared buffering?
-
-                    // verify file signature
-                    var contractSignature = translator.Reader.ReadBytes(TranslateContractSignature.Length);
-                    var contractVersion = translator.Reader.ReadByte();
-
-                    if (!contractSignature.SequenceEqual(TranslateContractSignature) || contractVersion != TranslateContractVersion)
-                    {
-                        log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
-                        return null;
-                    }
-
-                    SystemState systemState = new SystemState();
-                    systemState.Translate(translator);
-                    systemState.isDirty = false;
-
-                    return systemState;
-                }
-            }
-            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
-            {
-                // The deserialization process seems like it can throw just about 
-                // any exception imaginable.  Catch them all here.
-                // Not being able to deserialize the cache is not an error, but we let the user know anyway.
-                // Don't want to hold up processing just because we couldn't read the file.
-                log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, e.Message);
-            }
-
-            return null;
-        }
-
         /// <summary>
         /// Reads/writes this class.
         /// Used for serialization and deserialization of this class persistent cache.
         /// </summary>
-        public void Translate(ITranslator translator)
+        public override void Translate(ITranslator translator)
         {
             if (instanceLocalFileStateCache is null)
                 throw new NullReferenceException(nameof(instanceLocalFileStateCache));
@@ -329,6 +249,10 @@ public void Translate(ITranslator translator)
                 ref instanceLocalFileStateCache,
                 StringComparer.OrdinalIgnoreCase,
                 (ITranslator t) => new FileState(t));
+
+            // IsDirty should be false for either direction. Either this cache was brought
+            // up-to-date with the on-disk cache or vice versa. Either way, they agree.
+            IsDirty = false;
         }
 
         /// <summary>
@@ -375,11 +299,9 @@ internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetada
         /// <summary>
         /// Cache the results of a FileExists delegate. 
         /// </summary>
-        /// <param name="fileExistsValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
-        internal FileExists CacheDelegate(FileExists fileExistsValue)
+        internal FileExists CacheDelegate()
         {
-            fileExists = fileExistsValue;
             return FileExists;
         }
 
@@ -605,7 +527,7 @@ out fileState.frameworkName
         /// <param name="log">How to log</param>
         /// <param name="fileExists">Whether a file exists</param>
         /// <returns>A cache representing key aspects of file states.</returns>
-        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)
+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)
         {
             SystemState retVal = new SystemState();
             retVal.isDirty = stateFiles.Length > 0;
@@ -614,7 +536,7 @@ internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[]
             foreach (ITaskItem stateFile in stateFiles)
             {
                 // Verify that it's a real stateFile. Log message but do not error if not.
-                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log);
+                SystemState sysState = DeserializeCache(stateFile.ToString(), log, typeof(SystemState)) as SystemState;
                 if (sysState == null)
                 {
                     continue;
@@ -644,7 +566,7 @@ internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[]
         /// </summary>
         /// <param name="stateFile">Path to which to write the precomputed cache</param>
         /// <param name="log">How to log</param>
-        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)
+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
         {
             // Save a copy of instanceLocalFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
             // instanceLocalFileStateCache by default, so change that to the relativized form, then change it back.
@@ -657,7 +579,7 @@ internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggin
                 {
                     log.LogWarningWithCodeFromResources("General.StateFileAlreadyPresent", stateFile);
                 }
-                SerializeCacheByTranslator(stateFile, log);
+                SerializeCache(stateFile, log);
             }
             finally
             {
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index 6d0c99772eb..fce9024bbde 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANS" original="../Strings.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index 334b50fd622..7466d06bfc8 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,6 +1,6 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
-  <file datatype="xml" source-language="en" target-language="zh-HANT" original="../Strings.resx">
+  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
