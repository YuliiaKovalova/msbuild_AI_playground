diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index e133037726e..d69d42d632e 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -164,15 +164,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <remarks>
         /// { submissionId, BuildSubmission }
         /// </remarks>
-        private readonly Dictionary<int, BuildSubmission> _buildSubmissions;
-
-        /// <summary>
-        /// The current pending and active graph build submissions.
-        /// </summary>
-        /// <remarks>
-        /// { submissionId, GraphBuildSubmission }
-        /// </remarks>
-        private readonly Dictionary<int, GraphBuildSubmission> _graphBuildSubmissions;
+        private readonly Dictionary<int, BuildSubmissionBase> _buildSubmissions;
 
         /// <summary>
         /// Event signalled when all build submissions are complete.
@@ -301,8 +293,7 @@ public BuildManager(string hostName)
             ErrorUtilities.VerifyThrowArgumentNull(hostName, nameof(hostName));
             _hostName = hostName;
             _buildManagerState = BuildManagerState.Idle;
-            _buildSubmissions = new Dictionary<int, BuildSubmission>();
-            _graphBuildSubmissions = new Dictionary<int, GraphBuildSubmission>();
+            _buildSubmissions = new Dictionary<int, BuildSubmissionBase>();
             _noActiveSubmissionsEvent = new AutoResetEvent(true);
             _activeNodes = new HashSet<int>();
             _noNodesActiveEvent = new AutoResetEvent(true);
@@ -807,21 +798,15 @@ void Callback(object state)
 
                     _overallBuildSuccess = false;
 
-                    foreach (BuildSubmission submission in _buildSubmissions.Values)
-                    {
-                        if (submission.BuildRequest != null)
-                        {
-                            BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());
-                            _resultsCache.AddResult(result);
-                            submission.CompleteResults(result);
-                        }
-                    }
-
-                    foreach (GraphBuildSubmission submission in _graphBuildSubmissions.Values)
+                    foreach (BuildSubmissionBase submission in _buildSubmissions.Values)
                     {
                         if (submission.IsStarted)
                         {
-                            submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, new BuildAbortedException()));
+                            BuildResultBase buildResult = submission.CompleteResultsWithException(new BuildAbortedException());
+                            if (buildResult is BuildResult result)
+                            {
+                                _resultsCache.AddResult(result);
+                            }
                         }
                     }
 
@@ -880,27 +865,7 @@ public ProjectInstance GetProjectInstanceForBuild(Project project)
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
         public BuildSubmission PendBuildRequest(BuildRequestData requestData)
-        {
-            lock (_syncLock)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(requestData, nameof(requestData));
-                ErrorIfState(BuildManagerState.WaitingForBuildToComplete, "WaitingForEndOfBuild");
-                ErrorIfState(BuildManagerState.Idle, "NoBuildInProgress");
-                VerifyStateInternal(BuildManagerState.Building);
-
-                var newSubmission = new BuildSubmission(this, GetNextSubmissionId(), requestData, _buildParameters.LegacyThreadingSemantics);
-
-                if (_buildTelemetry != null)
-                {
-                    _buildTelemetry.Project ??= requestData.ProjectFullPath;
-                    _buildTelemetry.Target ??= string.Join(",", requestData.TargetNames);
-                }
-
-                _buildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
-                _noActiveSubmissionsEvent.Reset();
-                return newSubmission;
-            }
-        }
+            => (BuildSubmission) PendBuildRequest<BuildRequestData, BuildResult>(requestData);
 
         /// <summary>
         /// Submits a graph build request to the current build but does not start it immediately.  Allows the user to
@@ -908,6 +873,17 @@ public BuildSubmission PendBuildRequest(BuildRequestData requestData)
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
         public GraphBuildSubmission PendBuildRequest(GraphBuildRequestData requestData)
+            => (GraphBuildSubmission) PendBuildRequest<GraphBuildRequestData, GraphBuildResult>(requestData);
+
+        /// <summary>
+        /// Submits a build request to the current build but does not start it immediately.  Allows the user to
+        /// perform asynchronous execution or access the submission ID prior to executing the request.
+        /// </summary>
+        /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
+        private BuildSubmission<TRequestData, TResultData> PendBuildRequest<TRequestData, TResultData>(
+            TRequestData requestData)
+            where TRequestData : BuildRequestData<TRequestData, TResultData>
+            where TResultData : BuildResultBase
         {
             lock (_syncLock)
             {
@@ -916,39 +892,41 @@ public GraphBuildSubmission PendBuildRequest(GraphBuildRequestData requestData)
                 ErrorIfState(BuildManagerState.Idle, "NoBuildInProgress");
                 VerifyStateInternal(BuildManagerState.Building);
 
-                var newSubmission = new GraphBuildSubmission(this, GetNextSubmissionId(), requestData);
+                var newSubmission = requestData.CreateSubmission(this, GetNextSubmissionId(), requestData,
+                    _buildParameters.LegacyThreadingSemantics);
 
                 if (_buildTelemetry != null)
                 {
                     // Project graph can have multiple entry points, for purposes of identifying event for same build project,
                     // we believe that including only one entry point will provide enough precision.
-                    _buildTelemetry.Project ??= requestData.EntryProjectsFullPath.FirstOrDefault();
+                    _buildTelemetry.Project ??= requestData.EntryProjectsFullPath.First();
                     _buildTelemetry.Target ??= string.Join(",", requestData.TargetNames);
                 }
 
-                _graphBuildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
+                _buildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
                 _noActiveSubmissionsEvent.Reset();
                 return newSubmission;
             }
         }
 
+        private TResultData BuildRequest<TRequestData, TResultData>(TRequestData requestData)
+            where TRequestData : BuildRequestData<TRequestData, TResultData>
+            where TResultData : BuildResultBase
+            => PendBuildRequest<TRequestData, TResultData>(requestData).Execute();
+
         /// <summary>
         /// Convenience method. Submits a build request and blocks until the results are available.
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
         public BuildResult BuildRequest(BuildRequestData requestData)
-        {
-            BuildSubmission submission = PendBuildRequest(requestData);
-            BuildResult result = submission.Execute();
-
-            return result;
-        }
+            => BuildRequest<BuildRequestData, BuildResult>(requestData);
 
         /// <summary>
         /// Convenience method. Submits a graph build request and blocks until the results are available.
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
-        public GraphBuildResult BuildRequest(GraphBuildRequestData requestData) => PendBuildRequest(requestData).Execute();
+        public GraphBuildResult BuildRequest(GraphBuildRequestData requestData)
+            => BuildRequest<GraphBuildRequestData, GraphBuildResult>(requestData);
 
         /// <summary>
         /// Signals that no more build requests are expected (or allowed) and the BuildManager may clean up.
@@ -975,14 +953,8 @@ public void EndBuild()
                 lock (_syncLock)
                 {
                     // If there are any submissions which never started, remove them now.
-                    var submissionsToCheck = new List<BuildSubmission>(_buildSubmissions.Values);
-                    foreach (BuildSubmission submission in submissionsToCheck)
-                    {
-                        CheckSubmissionCompletenessAndRemove(submission);
-                    }
-
-                    var graphSubmissionsToCheck = new List<GraphBuildSubmission>(_graphBuildSubmissions.Values);
-                    foreach (GraphBuildSubmission submission in graphSubmissionsToCheck)
+                    var submissionsToCheck = new List<BuildSubmissionBase>(_buildSubmissions.Values);
+                    foreach (BuildSubmissionBase submission in submissionsToCheck)
                     {
                         CheckSubmissionCompletenessAndRemove(submission);
                     }
@@ -1001,7 +973,7 @@ public void EndBuild()
 
                 Task projectCacheDispose = _projectCacheService.DisposeAsync().AsTask();
 
-                ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0, "All submissions not yet complete.");
+                ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0, "All submissions not yet complete.");
                 ErrorUtilities.VerifyThrow(_activeNodes.Count == 0, "All nodes not yet shut down.");
 
                 if (_buildParameters.UsesOutputCache())
@@ -1139,13 +1111,15 @@ void SerializeCaches()
         /// Convenience method.  Submits a lone build request and blocks until results are available.
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
-        public BuildResult Build(BuildParameters parameters, BuildRequestData requestData)
+        private TResultData Build<TRequestData, TResultData>(BuildParameters parameters, TRequestData requestData)
+            where TRequestData : BuildRequestData<TRequestData, TResultData>
+            where TResultData : BuildResultBase
         {
-            BuildResult result;
+            TResultData result;
             BeginBuild(parameters);
             try
             {
-                result = BuildRequest(requestData);
+                result = BuildRequest<TRequestData, TResultData>(requestData);
                 if (result.Exception == null && _threadException != null)
                 {
                     result.Exception = _threadException.SourceException;
@@ -1160,30 +1134,19 @@ public BuildResult Build(BuildParameters parameters, BuildRequestData requestDat
             return result;
         }
 
+        /// <summary>
+        /// Convenience method.  Submits a lone build request and blocks until results are available.
+        /// </summary>
+        /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
+        public BuildResult Build(BuildParameters parameters, BuildRequestData requestData)
+            => Build<BuildRequestData, BuildResult>(parameters, requestData);
+
         /// <summary>
         /// Convenience method.  Submits a lone graph build request and blocks until results are available.
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public GraphBuildResult Build(BuildParameters parameters, GraphBuildRequestData requestData)
-        {
-            GraphBuildResult result;
-            BeginBuild(parameters);
-            try
-            {
-                result = BuildRequest(requestData);
-                if (result.Exception == null && _threadException != null)
-                {
-                    result.Exception = _threadException.SourceException;
-                    _threadException = null;
-                }
-            }
-            finally
-            {
-                EndBuild();
-            }
-
-            return result;
-        }
+            => Build<GraphBuildRequestData, GraphBuildResult>(parameters, requestData);
 
         /// <summary>
         /// Shuts down all idle MSBuild nodes on the machine
@@ -1254,7 +1217,7 @@ IBuildComponent IBuildComponentHost.GetComponent(BuildComponentType type)
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Standard ExpectedException pattern used")]
         [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Complex class might need refactoring to separate scheduling elements from submission elements.")]
-        internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThreadBuild)
+        private void ExecuteSubmission(BuildSubmission submission, bool allowMainThreadBuild)
         {
             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));
             ErrorUtilities.VerifyThrow(!submission.IsCompleted, "Submission already complete.");
@@ -1266,6 +1229,8 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
             {
                 lock (_syncLock)
                 {
+                    submission.IsStarted = true;
+
                     ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;
                     if (projectInstance != null)
                     {
@@ -1399,7 +1364,11 @@ internal void ExecuteSubmission<TRequestData, TResultData>(
             where TRequestData : BuildRequestDataBase
             where TResultData : BuildResultBase
         {
-            // TODO - unify the behavior in BuildManager as well
+            // TODO: here we should add BuildRequestStarted https://github.com/dotnet/msbuild/issues/10145
+            // BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            // ((IBuildComponentHost)this).LoggingService.LogBuildEvent()
+
+
             if (submission is BuildSubmission buildSubmission)
             {
                 ExecuteSubmission(buildSubmission, allowMainThreadBuild);
@@ -1413,13 +1382,13 @@ internal void ExecuteSubmission<TRequestData, TResultData>(
         /// <summary>
         /// This method adds the graph build request in the specified submission to the set of requests being handled by the scheduler.
         /// </summary>
-        internal void ExecuteSubmission(GraphBuildSubmission submission)
+        private void ExecuteSubmission(GraphBuildSubmission submission)
         {
-            lock (_syncLock)
-            {
-                VerifyStateInternal(BuildManagerState.Building);
+            VerifyStateInternal(BuildManagerState.Building);
 
-                try
+            try
+            {
+                lock (_syncLock)
                 {
                     submission.IsStarted = true;
 
@@ -1449,11 +1418,12 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
                         TaskCreationOptions.LongRunning,
                         TaskScheduler.Default);
                 }
-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
-                {
-                    HandleSubmissionException(submission, ex);
-                    throw;
-                }
+            }
+            // The handling of submission exception needs to be done outside of the lock
+            catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            {
+                HandleSubmissionException(submission, ex);
+                throw;
             }
         }
 
@@ -1672,73 +1642,10 @@ private void CompleteSubmissionWithException(BuildSubmission submission, BuildRe
         /// <remarks>
         /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
         /// </remarks>
-        private void HandleSubmissionException(BuildSubmission submission, Exception ex)
-        {
-            Debug.Assert(!Monitor.IsEntered(_syncLock));
-
-            if (ex is AggregateException ae && ae.InnerExceptions.Count == 1)
-            {
-                ex = ae.InnerExceptions.First();
-            }
-            if (ex is InvalidProjectFileException projectException)
-            {
-                if (!projectException.HasBeenLogged)
-                {
-                    BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                    ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
-                    projectException.HasBeenLogged = true;
-                }
-            }
-
-            bool submissionNeedsCompletion;
-            lock (_syncLock)
-            {
-                // BuildRequest may be null if the submission fails early on.
-                submissionNeedsCompletion = submission.BuildRequest != null;
-                if (submissionNeedsCompletion)
-                {
-                    var result = new BuildResult(submission.BuildRequest, ex);
-                    submission.CompleteResults(result);
-                }
-            }
-
-            if (submissionNeedsCompletion)
-            {
-                WaitForAllLoggingServiceEventsToBeProcessed();
-            }
-
-            lock (_syncLock)
-            {
-                if (submissionNeedsCompletion)
-                {
-                    submission.CompleteLogging();
-                }
-
-                _overallBuildSuccess = false;
-                CheckSubmissionCompletenessAndRemove(submission);
-            }
-        }
-
-        /// <summary>
-        /// Waits to drain all events of logging service.
-        /// This method shall be used carefully because during draining, LoggingService will block all incoming events.
-        /// </summary>
-        /// <remarks>
-        /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
-        /// </remarks>
-        private void WaitForAllLoggingServiceEventsToBeProcessed()
+        private void HandleSubmissionException(BuildSubmissionBase submission, Exception ex)
         {
-            // this has to be called out of the lock (_syncLock)
-            // because processing events can callback to 'this' instance and cause deadlock
             Debug.Assert(!Monitor.IsEntered(_syncLock));
-            ((LoggingService)((IBuildComponentHost)this).LoggingService).WaitForLoggingToProcessEvents();
-        }
 
-        /// <summary>
-        /// Deals with exceptions that may be thrown as a result of ExecuteSubmission.
-        /// </summary>
-        private void HandleSubmissionException(GraphBuildSubmission submission, Exception ex)
-        {
             if (ex is AggregateException ae)
             {
                 // If there's exactly 1, just flatten it
@@ -1748,7 +1655,7 @@ private void HandleSubmissionException(GraphBuildSubmission submission, Exceptio
                 }
                 else
                 {
-                    // Log each InvalidProjectFileException encountered during ProjectGraph creation
+                    // Log each InvalidProjectFileException encountered
                     foreach (Exception innerException in ae.InnerExceptions)
                     {
                         if (innerException is InvalidProjectFileException innerProjectException)
@@ -1769,11 +1676,27 @@ private void HandleSubmissionException(GraphBuildSubmission submission, Exceptio
                 LogInvalidProjectFileError(new InvalidProjectFileException(ex.Message, ex));
             }
 
+            bool submissionNeedsCompletion;
+            lock (_syncLock)
+            {
+                // BuildRequest may be null if the submission fails early on.
+                submissionNeedsCompletion = submission.IsStarted;
+                if (submissionNeedsCompletion)
+                {
+                    submission.CompleteResultsWithException(ex);
+                }
+            }
+
+            if (submissionNeedsCompletion)
+            {
+                WaitForAllLoggingServiceEventsToBeProcessed();
+            }
+
             lock (_syncLock)
             {
-                if (submission.IsStarted)
+                if (submissionNeedsCompletion)
                 {
-                    submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, ex));
+                    submission.CompleteLogging();
                 }
 
                 _overallBuildSuccess = false;
@@ -1791,6 +1714,21 @@ void LogInvalidProjectFileError(InvalidProjectFileException projectException)
             }
         }
 
+        /// <summary>
+        /// Waits to drain all events of logging service.
+        /// This method shall be used carefully because during draining, LoggingService will block all incoming events.
+        /// </summary>
+        /// <remarks>
+        /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
+        /// </remarks>
+        private void WaitForAllLoggingServiceEventsToBeProcessed()
+        {
+            // this has to be called out of the lock (_syncLock)
+            // because processing events can callback to 'this' instance and cause deadlock
+            Debug.Assert(!Monitor.IsEntered(_syncLock));
+            ((LoggingService)((IBuildComponentHost)this).LoggingService).WaitForLoggingToProcessEvents();
+        }
+
         private static void AddBuildRequestToSubmission(BuildSubmission submission, int configurationId, int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             submission.BuildRequest = new BuildRequest(
@@ -1904,7 +1842,7 @@ void IssueBuildSubmissionToSchedulerImpl(BuildSubmission submission, bool allowM
                     lock (_syncLock)
                     {
                         submission.CompleteLogging();
-                        ReportResultsToSubmission(new BuildResult(submission.BuildRequest, ex));
+                        ReportResultsToSubmission<BuildRequestData, BuildResult>(new BuildResult(submission.BuildRequest, ex));
                         _overallBuildSuccess = false;
                     }
                 }
@@ -1999,7 +1937,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                 "Exceptions only get set when the graph submission gets completed with an exception in OnThreadException. That should not happen during graph builds.");
 
             // The overall submission is complete, so report it as complete
-            ReportResultsToSubmission(
+            ReportResultsToSubmission<GraphBuildRequestData, GraphBuildResult>(
                 new GraphBuildResult(
                     submission.SubmissionId,
                     new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode ?? new Dictionary<ProjectGraphNode, BuildResult>())));
@@ -2182,7 +2120,6 @@ private void Reset()
             _executionCancellationTokenSource = null;
             _nodeConfiguration = null;
             _buildSubmissions.Clear();
-            _graphBuildSubmissions.Clear();
 
             _scheduler.Reset();
             _scheduler = null;
@@ -2345,7 +2282,7 @@ void HandleCacheResult()
 
                             _resultsCache.AddResult(result);
                             submission.CompleteLogging();
-                            ReportResultsToSubmission(result);
+                            ReportResultsToSubmission<BuildRequestData, BuildResult>(result);
                         }
                     }
                     catch (Exception e)
@@ -2461,7 +2398,7 @@ private void HandleResult(int node, BuildResult result)
             // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to
             // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that
             // would require moving the cache service interactions to the Scheduler.
-            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))
+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmissionBase buildSubmissionBase) && buildSubmissionBase is BuildSubmission buildSubmission)
             {
                 // The result may be associated with the build submission due to it being the submission which
                 // caused the build, but not the actual request which was originally used with the build submission.
@@ -2510,27 +2447,20 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
                 if (shutdownPacket.Reason == NodeShutdownReason.ConnectionFailed)
                 {
                     ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent(BuildComponentType.LoggingService) as ILoggingService;
-                    foreach (BuildSubmission submission in _buildSubmissions.Values)
-                    {
-                        BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, BuildEventContext.InvalidNodeId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                        string exception = ExceptionHandling.ReadAnyExceptionFromFile(_instantiationTimeUtc);
-                        loggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, exception);
-                    }
-
-                    foreach (GraphBuildSubmission submission in _graphBuildSubmissions.Values)
+                    foreach (BuildSubmissionBase submission in _buildSubmissions.Values)
                     {
                         BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, BuildEventContext.InvalidNodeId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                         string exception = ExceptionHandling.ReadAnyExceptionFromFile(_instantiationTimeUtc);
-                        loggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, exception);
+                        loggingService?.LogError(buildEventContext, new BuildEventFileInfo(string.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, exception);
                     }
                 }
-                else if (shutdownPacket.Reason == NodeShutdownReason.Error && _buildSubmissions.Values.Count == 0 && _graphBuildSubmissions.Values.Count == 0)
+                else if (shutdownPacket.Reason == NodeShutdownReason.Error && _buildSubmissions.Values.Count == 0)
                 {
                     // We have no submissions to attach any exceptions to, lets just log it here.
                     if (shutdownPacket.Exception != null)
                     {
                         ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent(BuildComponentType.LoggingService) as ILoggingService;
-                        loggingService.LogError(BuildEventContext.Invalid, new BuildEventFileInfo(String.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, shutdownPacket.Exception.ToString());
+                        loggingService?.LogError(BuildEventContext.Invalid, new BuildEventFileInfo(string.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, shutdownPacket.Exception.ToString());
                         OnThreadException(shutdownPacket.Exception);
                     }
                 }
@@ -2538,15 +2468,19 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
                 _nodeManager.ShutdownConnectedNodes(_buildParameters.EnableNodeReuse);
                 _taskHostNodeManager.ShutdownConnectedNodes(_buildParameters.EnableNodeReuse);
 
-                foreach (BuildSubmission submission in _buildSubmissions.Values)
+                foreach (BuildSubmissionBase submission in _buildSubmissions.Values)
                 {
                     // The submission has not started
-                    if (submission.BuildRequest == null)
+                    if (!submission.IsStarted)
                     {
                         continue;
                     }
 
-                    _resultsCache.AddResult(new BuildResult(submission.BuildRequest, shutdownPacket.Exception ?? new BuildAbortedException()));
+                    if (submission is BuildSubmission buildSubmission)
+                    {
+                        _resultsCache.AddResult(new BuildResult(buildSubmission.BuildRequest,
+                            shutdownPacket.Exception ?? new BuildAbortedException()));
+                    }
                 }
 
                 _scheduler.ReportBuildAborted(node);
@@ -2597,22 +2531,19 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
 
             if (_activeNodes.Count == 0)
             {
-                var submissions = new List<BuildSubmission>(_buildSubmissions.Values);
-                foreach (BuildSubmission submission in submissions)
+                var submissions = new List<BuildSubmissionBase>(_buildSubmissions.Values);
+                foreach (BuildSubmissionBase submission in submissions)
                 {
                     // The submission has not started do not add it to the results cache
-                    if (submission.BuildRequest == null)
+                    if (!submission.IsStarted)
                     {
                         continue;
                     }
 
-                    // UNDONE: (stability) It might be best to trigger the logging service to shut down here,
-                    //         since the full build is complete.  This would allow us to ensure all logging messages have been
-                    //         drained and all submissions can complete their logging requirements.
-                    BuildResult result = _resultsCache.GetResultsForConfiguration(submission.BuildRequest.ConfigurationId) ??
-                                         new BuildResult(submission.BuildRequest, new BuildAbortedException());
-
-                    submission.CompleteResults(result);
+                    if (!CompleteSubmissionFromCache(submission))
+                    {
+                        submission.CompleteResultsWithException(new BuildAbortedException());
+                    }
 
                     // If we never received a project started event, consider logging complete anyhow, since the nodes have
                     // shut down.
@@ -2621,21 +2552,23 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
 
-                var graphSubmissions = new List<GraphBuildSubmission>(_graphBuildSubmissions.Values);
-                foreach (GraphBuildSubmission submission in graphSubmissions)
-                {
-                    if (submission.IsStarted)
-                    {
-                        continue;
-                    }
-
-                    submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, new BuildAbortedException()));
+                _noNodesActiveEvent.Set();
+            }
+        }
 
-                    CheckSubmissionCompletenessAndRemove(submission);
+        private bool CompleteSubmissionFromCache(BuildSubmissionBase submissionBase)
+        {
+            if (submissionBase is BuildSubmission submission)
+            {
+                BuildResult result = _resultsCache.GetResultsForConfiguration(submission.BuildRequest.ConfigurationId);
+                if (result != null)
+                {
+                    submission.CompleteResults(result);
+                    return true;
                 }
-
-                _noNodesActiveEvent.Set();
             }
+
+            return false;
         }
 
         /// <summary>
@@ -2658,7 +2591,7 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                             _scheduler.WriteDetailedSummary(response.BuildResult.SubmissionId);
                         }
 
-                        ReportResultsToSubmission(response.BuildResult);
+                        ReportResultsToSubmission<BuildRequestData, BuildResult>(response.BuildResult);
                         break;
 
                     case ScheduleActionType.CircularDependency:
@@ -2715,15 +2648,15 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
             }
         }
 
-        /// <summary>
-        /// Completes a submission using the specified overall results.
-        /// </summary>
-        private void ReportResultsToSubmission(BuildResult result)
+        internal void ReportResultsToSubmission<TRequestData, TResultData>(TResultData result)
+            where TRequestData : BuildRequestDataBase
+            where TResultData : BuildResultBase
         {
             lock (_syncLock)
             {
                 // The build submission has not already been completed.
-                if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission submission))
+                if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmissionBase submissionBase) &&
+                    submissionBase is BuildSubmission<TRequestData, TResultData> submission)
                 {
                     /* If the request failed because we caught an exception from the loggers, we can assume we will receive no more logging messages for
                      * this submission, therefore set the logging as complete. InternalLoggerExceptions are unhandled exceptions from the logger. If the logger author does
@@ -2734,31 +2667,13 @@ private void ReportResultsToSubmission(BuildResult result)
                      *
                      * If any other exception happened and logging is not completed, then go ahead and complete it now since this is the last place to do it.
                      * Otherwise the submission would remain uncompleted, potentially causing hangs (EndBuild waiting on all BuildSubmissions, users waiting on BuildSubmission, or expecting a callback, etc)
-                    */
+                     */
                     if (!submission.LoggingCompleted && result.Exception != null)
                     {
                         submission.CompleteLogging();
                     }
 
                     submission.CompleteResults(result);
-
-                    CheckSubmissionCompletenessAndRemove(submission);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Completes a submission using the specified overall results.
-        /// </summary>
-        private void ReportResultsToSubmission(GraphBuildResult result)
-        {
-            lock (_syncLock)
-            {
-                // The build submission has not already been completed.
-                if (_graphBuildSubmissions.TryGetValue(result.SubmissionId, out GraphBuildSubmission submission))
-                {
-                    submission.CompleteResults(result);
-
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
             }
@@ -2767,42 +2682,21 @@ private void ReportResultsToSubmission(GraphBuildResult result)
         /// <summary>
         /// Determines if the submission is fully completed.
         /// </summary>
-        private void CheckSubmissionCompletenessAndRemove(BuildSubmission submission)
-        {
-            lock (_syncLock)
-            {
-                // If the submission has completed or never started, remove it.
-                if (submission.IsCompleted || submission.BuildRequest == null)
-                {
-                    _overallBuildSuccess &= (submission.BuildResult?.OverallResult == BuildResultCode.Success);
-                    _buildSubmissions.Remove(submission.SubmissionId);
-
-                    // Clear all cached SDKs for the submission
-                    SdkResolverService.ClearCache(submission.SubmissionId);
-                }
-
-                CheckAllSubmissionsComplete(submission.BuildRequestData?.Flags);
-            }
-        }
-
-        /// <summary>
-        /// Determines if the submission is fully completed.
-        /// </summary>
-        private void CheckSubmissionCompletenessAndRemove(GraphBuildSubmission submission)
+        private void CheckSubmissionCompletenessAndRemove(BuildSubmissionBase submission)
         {
             lock (_syncLock)
             {
                 // If the submission has completed or never started, remove it.
                 if (submission.IsCompleted || !submission.IsStarted)
                 {
-                    _overallBuildSuccess &= submission.BuildResult?.OverallResult == BuildResultCode.Success;
-                    _graphBuildSubmissions.Remove(submission.SubmissionId);
+                    _overallBuildSuccess &= (submission.BuildResultBase?.OverallResult == BuildResultCode.Success);
+                    _buildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
                     SdkResolverService.ClearCache(submission.SubmissionId);
                 }
 
-                CheckAllSubmissionsComplete(submission.BuildRequestData?.Flags);
+                CheckAllSubmissionsComplete(submission.BuildRequestDataBase?.Flags);
             }
         }
 
@@ -2810,7 +2704,7 @@ private void CheckAllSubmissionsComplete(BuildRequestDataFlags? flags)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
-            if (_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0)
+            if (_buildSubmissions.Count == 0)
             {
                 if (flags.HasValue && flags.Value.HasFlag(BuildRequestDataFlags.ClearCachesAfterBuild))
                 {
@@ -2876,40 +2770,30 @@ private void OnThreadException(Exception e)
                     }
 
                     _threadException = ExceptionDispatchInfo.Capture(e);
-                    var submissions = new List<BuildSubmission>(_buildSubmissions.Values);
-                    foreach (BuildSubmission submission in submissions)
+                    var submissions = new List<BuildSubmissionBase>(_buildSubmissions.Values);
+                    foreach (BuildSubmissionBase submission in submissions)
                     {
                         // Submission has not started
-                        if (submission.BuildRequest == null)
+                        if (!submission.IsStarted)
                         {
                             continue;
                         }
 
                         // Attach the exception to this submission if it does not already have an exception associated with it
-                        if (!submission.IsCompleted && submission.BuildResult != null && submission.BuildResult.Exception == null)
+                        if (!submission.IsCompleted && submission.BuildResultBase != null && submission.BuildResultBase.Exception == null)
                         {
-                            submission.BuildResult.Exception = e;
+                            submission.BuildResultBase.Exception = e;
                         }
                         submission.CompleteLogging();
-                        submission.CompleteResults(new BuildResult(submission.BuildRequest, e));
-
-                        CheckSubmissionCompletenessAndRemove(submission);
-                    }
 
-                    var graphSubmissions = new List<GraphBuildSubmission>(_graphBuildSubmissions.Values);
-                    foreach (GraphBuildSubmission submission in graphSubmissions)
-                    {
-                        if (!submission.IsStarted)
+                        if (submission.BuildResultBase != null)
                         {
-                            continue;
+                            submission.CheckForCompletion();
                         }
-
-                        // Attach the exception to this submission if it does not already have an exception associated with it
-                        if (!submission.IsCompleted && submission.BuildResult != null && submission.BuildResult.Exception == null)
+                        else
                         {
-                            submission.BuildResult.Exception = e;
+                            submission.CompleteResultsWithException(e);
                         }
-                        submission.CompleteResults(submission.BuildResult ?? new GraphBuildResult(submission.SubmissionId, e));
 
                         CheckSubmissionCompletenessAndRemove(submission);
                     }
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index 5dd3ea6dc2f..43653a1b442 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -89,9 +89,9 @@ public enum BuildRequestDataFlags
     }
 
     /// <summary>
-    /// BuildRequestData encapsulates all of the data needed to submit a build request.
+    /// BuildRequestData encapsulates all the data needed to submit a build request.
     /// </summary>
-    public sealed class BuildRequestData : BuildRequestDataBase
+    public sealed class BuildRequestData : BuildRequestData<BuildRequestData, BuildResult>
     {
         /// <summary>
         /// Constructs a BuildRequestData for build requests based on project instances.
@@ -252,6 +252,11 @@ public ProjectInstance? ProjectInstance
         /// <value>The project file to be built.</value>
         public string ProjectFullPath { get; internal set; }
 
+        internal override BuildSubmission<BuildRequestData, BuildResult> CreateSubmission(BuildManager buildManager,
+            int submissionId, BuildRequestData requestData,
+            bool legacyThreadingSemantics) =>
+            new BuildSubmission(buildManager, submissionId, requestData, legacyThreadingSemantics);
+
         public override IEnumerable<string> EntryProjectsFullPath => ProjectFullPath.AsSingleItemEnumerable();
 
         /// <summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestDataBase.cs b/src/Build/BackEnd/BuildManager/BuildRequestDataBase.cs
index c10a49b6fa4..51d35b8addf 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestDataBase.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestDataBase.cs
@@ -49,4 +49,19 @@ protected BuildRequestDataBase(
         /// </summary>
         public HostServices? HostServices { get; }
     }
+
+    public abstract class BuildRequestData<TRequestData, TResultData> : BuildRequestDataBase
+        where TRequestData : BuildRequestData<TRequestData, TResultData>
+        where TResultData : BuildResultBase
+    {
+        protected BuildRequestData(
+            ICollection<string> targetNames,
+            BuildRequestDataFlags flags,
+            HostServices? hostServices)
+            : base(targetNames, flags, hostServices)
+        { }
+
+        internal abstract BuildSubmission<TRequestData, TResultData> CreateSubmission(
+            BuildManager buildManager, int submissionId, TRequestData requestData, bool legacyThreadingSemantics);
+    }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index 5cb2aa24222..ecb9f7a1f99 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -5,11 +5,8 @@
 using System.Globalization;
 using System.Threading;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Execution
 {
     /// <summary>
@@ -23,21 +20,12 @@ public delegate void BuildSubmissionCompleteCallback<TRequestData, TResultData>(
         where TRequestData : BuildRequestDataBase
         where TResultData : BuildResultBase;
 
-    public abstract class BuildSubmissionBase { }
-
-    public abstract class BuildSubmission<TRequestData, TResultData> : BuildSubmissionBase
-        where TRequestData : BuildRequestDataBase
-        where TResultData : BuildResultBase
+    public abstract class BuildSubmissionBase
     {
-        /// <summary>
-        /// The callback to invoke when the submission is complete.
-        /// </summary>
-        private BuildSubmissionCompleteCallback<TRequestData, TResultData> _completionCallback;
-
         /// <summary>
         /// The completion event.
         /// </summary>
-        private readonly ManualResetEvent _completionEvent;
+        protected readonly ManualResetEvent CompletionEvent;
 
         /// <summary>
         /// Flag indicating if logging is done.
@@ -47,22 +35,27 @@ public abstract class BuildSubmission<TRequestData, TResultData> : BuildSubmissi
         /// <summary>
         /// True if it has been invoked
         /// </summary>
-        private int _completionInvoked;
+        protected int CompletionInvoked;
+
+        //
+        // Unfortunately covariant overrides are not available for .NET 472,
+        //  so we have to use two set of properties for derived classes.
+        internal abstract BuildRequestDataBase? BuildRequestDataBase { get; }
+
+        internal abstract BuildResultBase? BuildResultBase { get; }
 
         /// <summary>
         /// Constructor
         /// </summary>
-        protected internal BuildSubmission(BuildManager buildManager, int submissionId, TRequestData requestData)
+        protected internal BuildSubmissionBase(BuildManager buildManager, int submissionId)
         {
             ErrorUtilities.VerifyThrowArgumentNull(buildManager, nameof(buildManager));
-            ErrorUtilities.VerifyThrowArgumentNull(requestData, nameof(requestData));
 
             BuildManager = buildManager;
             SubmissionId = submissionId;
-            BuildRequestData = requestData;
-            _completionEvent = new ManualResetEvent(false);
+            CompletionEvent = new ManualResetEvent(false);
             LoggingCompleted = false;
-            _completionInvoked = 0;
+            CompletionInvoked = 0;
         }
 
         /// <summary>
@@ -78,12 +71,12 @@ protected internal BuildSubmission(BuildManager buildManager, int submissionId,
         /// <summary>
         /// The asynchronous context provided to <see cref="BuildSubmission{TRequestData,TResultData}.ExecuteAsync(BuildSubmissionCompleteCallback&lt;TRequestData, TResultData&gt;, object)"/>, if any.
         /// </summary>
-        public Object AsyncContext { get; private set; }
+        public object? AsyncContext { get; protected set; }
 
         /// <summary>
         /// A <see cref="System.Threading.WaitHandle"/> which will be signalled when the build is complete.  Valid after <see cref="BuildSubmission{TRequestData,TResultData}.Execute()"/> or <see cref="BuildSubmission{TRequestData,TResultData}.ExecuteAsync(BuildSubmissionCompleteCallback&lt;TRequestData, TResultData&gt;, object)"/> returns, otherwise null.
         /// </summary>
-        public WaitHandle WaitHandle => _completionEvent;
+        public WaitHandle WaitHandle => CompletionEvent;
 
         /// <summary>
         /// Returns true if this submission is complete.
@@ -91,19 +84,59 @@ protected internal BuildSubmission(BuildManager buildManager, int submissionId,
         public bool IsCompleted => WaitHandle.WaitOne(new TimeSpan(0));
 
         /// <summary>
-        /// The results of the build per graph node.  Valid only after WaitHandle has become signalled.
+        /// Whether the build has started.
         /// </summary>
-        public TResultData BuildResult { get; internal set; }
+        internal bool IsStarted { get; set; }
 
         /// <summary>
-        /// The BuildRequestData being used for this submission.
+        /// Indicates that all logging events for this submission are complete.
         /// </summary>
-        internal TRequestData BuildRequestData { get; }
+        internal void CompleteLogging()
+        {
+            LoggingCompleted = true;
+            CheckForCompletion();
+        }
+
+        protected internal virtual void OnCompletition() { }
+        protected internal abstract void CheckForCompletion();
+
+        internal abstract BuildResultBase CompleteResultsWithException(Exception exception);
+    }
 
+    public abstract class BuildSubmission<TRequestData, TResultData> : BuildSubmissionBase
+        where TRequestData : BuildRequestDataBase
+        where TResultData : BuildResultBase
+    {
         /// <summary>
-        /// Whether the graph build has started.
+        /// The callback to invoke when the submission is complete.
         /// </summary>
-        internal bool IsStarted { get; set; }
+        private BuildSubmissionCompleteCallback<TRequestData, TResultData>? _completionCallback;
+
+        /// <summary>
+        /// Constructor
+        /// </summary>
+        protected internal BuildSubmission(BuildManager buildManager, int submissionId, TRequestData requestData)
+            : base(buildManager, submissionId)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(requestData, nameof(requestData));
+            BuildRequestData = requestData;
+        }
+
+        //
+        // Unfortunately covariant overrides are not available for .NET 472,
+        //  so we have to use two set of properties for derived classes.
+        internal override BuildResultBase? BuildResultBase => BuildResult;
+        internal override BuildRequestDataBase? BuildRequestDataBase => BuildRequestData;
+
+        /// <summary>
+        /// The results of the build per graph node.  Valid only after WaitHandle has become signalled.
+        /// </summary>
+        public TResultData? BuildResult { get; private set; }
+
+        /// <summary>
+        /// The BuildRequestData being used for this submission.
+        /// </summary>
+        internal TRequestData? BuildRequestData { get; }
 
         /// <summary>
         /// Starts the request and blocks until results are available.
@@ -115,14 +148,14 @@ protected internal BuildSubmission(BuildManager buildManager, int submissionId,
         /// Starts the request asynchronously and immediately returns control to the caller.
         /// </summary>
         /// <exception cref="InvalidOperationException">The request has already been started or is already complete.</exception>
-        public void ExecuteAsync(BuildSubmissionCompleteCallback<TRequestData, TResultData> callback, object context)
+        public void ExecuteAsync(BuildSubmissionCompleteCallback<TRequestData, TResultData>? callback, object? context)
         {
             ExecuteAsync(callback, context, allowMainThreadBuild: false);
         }
 
         protected void ExecuteAsync(
-            BuildSubmissionCompleteCallback<TRequestData, TResultData> callback,
-            object context,
+            BuildSubmissionCompleteCallback<TRequestData, TResultData>? callback,
+            object? context,
             bool allowMainThreadBuild)
         {
             ErrorUtilities.VerifyThrowInvalidOperation(!IsCompleted, "SubmissionAlreadyComplete");
@@ -131,15 +164,6 @@ protected void ExecuteAsync(
             BuildManager.ExecuteSubmission(this, allowMainThreadBuild);
         }
 
-        /// <summary>
-        /// Indicates that all logging events for this submission are complete.
-        /// </summary>
-        internal void CompleteLogging()
-        {
-            LoggingCompleted = true;
-            CheckForCompletion();
-        }
-
         /// <summary>
         /// Sets the event signaling that the build is complete.
         /// </summary>
@@ -154,31 +178,35 @@ internal void CompleteResults(TResultData result)
             CheckForCompletion();
         }
 
-        protected internal virtual void OnCompletition() { }
+        protected internal abstract TResultData CreateFailedResult(Exception exception);
+
+        internal override BuildResultBase CompleteResultsWithException(Exception exception)
+            => CompleteResults(exception);
+
+        private TResultData CompleteResults(Exception exception)
+        {
+            TResultData result = CreateFailedResult(exception);
+            CompleteResults(result);
+            return result;
+        }
 
         /// <summary>
         /// Determines if we are completely done with this submission and can complete it so the user may access results.
         /// </summary>
-        private void CheckForCompletion()
+        protected internal override void CheckForCompletion()
         {
             if (BuildResult != null && LoggingCompleted)
             {
-                bool hasCompleted = (Interlocked.Exchange(ref _completionInvoked, 1) == 1);
+                bool hasCompleted = (Interlocked.Exchange(ref CompletionInvoked, 1) == 1);
                 if (!hasCompleted)
                 {
                     OnCompletition();
-                    ////// Did this submission have warnings elevated to errors? If so, mark it as
-                    ////// failed even though it succeeded (with warnings--but they're errors).
-                    ////if (((IBuildComponentHost)BuildManager).LoggingService.HasBuildSubmissionLoggedErrors(BuildResult.SubmissionId))
-                    ////{
-                    ////    BuildResult.SetOverallResult(overallResult: false);
-                    ////}
 
-                    _completionEvent.Set();
+                    CompletionEvent.Set();
 
                     if (_completionCallback != null)
                     {
-                        void Callback(object state)
+                        void Callback(object? state)
                         {
                             _completionCallback(this);
                         }
@@ -199,6 +227,13 @@ void Callback(object state)
     /// </remarks>
     public delegate void BuildSubmissionCompleteCallback(BuildSubmission submission);
 
+    /// <summary>
+    /// A BuildSubmission represents a build request which has been submitted to the BuildManager for processing.  It may be used to
+    /// execute synchronous or asynchronous build requests and provides access to the results upon completion.
+    /// </summary>
+    /// <remarks>
+    /// This class is thread-safe.
+    /// </remarks>
     public sealed class BuildSubmission : BuildSubmission<BuildRequestData, BuildResult>
     {
         /// <summary>
@@ -209,7 +244,7 @@ public sealed class BuildSubmission : BuildSubmission<BuildRequestData, BuildRes
         /// <summary>
         /// The build request for execution.
         /// </summary>
-        internal BuildRequest BuildRequest { get; set; }
+        internal BuildRequest? BuildRequest { get; set; }
 
         internal BuildSubmission(BuildManager buildManager, int submissionId, BuildRequestData requestData, bool legacyThreadingSemantics)
             : base(buildManager, submissionId, requestData)
@@ -223,12 +258,6 @@ internal BuildSubmission(BuildManager buildManager, int submissionId, BuildReque
         /// <exception cref="System.InvalidOperationException">The request has already been started or is already complete.</exception>
         public override BuildResult Execute()
         {
-            // TODO: here
-            // ((IBuildComponentHost)BuildManager).LoggingService.LogBuildEvent()
-            // BuildEventContext buildEventContext = new BuildEventContext(this.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-
-            // async as well !!
-
             LegacyThreadingData legacyThreadingData = ((IBuildComponentHost)BuildManager).LegacyThreadingData;
             legacyThreadingData.RegisterSubmissionForLegacyThread(SubmissionId);
 
@@ -244,14 +273,26 @@ public override BuildResult Execute()
 
             legacyThreadingData.UnregisterSubmissionForLegacyThread(SubmissionId);
 
-            return BuildResult;
+            ErrorUtilities.VerifyThrow(BuildResult != null,
+                "BuildResult is not populated after Execute is done.");
+
+            return BuildResult!;
+        }
+
+        protected internal override BuildResult CreateFailedResult(Exception exception)
+        {
+            ErrorUtilities.VerifyThrow(BuildResult != null,
+                "BuildResult is not populated after Execute is done.");
+            return new(BuildRequest!, exception);
         }
+        
 
         protected internal override void OnCompletition()
         {
             // Did this submission have warnings elevated to errors? If so, mark it as
             // failed even though it succeeded (with warnings--but they're errors).
-            if (((IBuildComponentHost)BuildManager).LoggingService.HasBuildSubmissionLoggedErrors(BuildResult.SubmissionId))
+            if (BuildResult != null &&
+                ((IBuildComponentHost)BuildManager).LoggingService.HasBuildSubmissionLoggedErrors(BuildResult.SubmissionId))
             {
                 BuildResult.SetOverallResult(overallResult: false);
             }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 69bbe1e0398..d573f4bdc74 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -454,7 +454,7 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
 
                 BuildRequestData buildRequest = new BuildRequestData(
                     cacheRequest.Configuration.Project,
-                    cacheRequest.Submission.BuildRequestData.TargetNames.ToArray());
+                    cacheRequest.Submission.BuildRequestData?.TargetNames.ToArray() ?? Array.Empty<string>());
                 BuildEventContext buildEventContext = _loggingService.CreateProjectCacheBuildEventContext(
                     cacheRequest.Submission.SubmissionId,
                     evaluationId: cacheRequest.Configuration.Project.EvaluationId,
@@ -477,13 +477,16 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
 
             void EvaluateProjectIfNecessary(BuildSubmission submission, BuildRequestConfiguration configuration)
             {
+                ErrorUtilities.VerifyThrow(submission.BuildRequestData != null,
+                    "Submission BuildRequestData is not populated.");
+
                 lock (configuration)
                 {
                     if (!configuration.IsLoaded)
                     {
                         configuration.LoadProjectIntoConfiguration(
                             _buildManager,
-                            submission.BuildRequestData.Flags,
+                            submission.BuildRequestData!.Flags,
                             submission.SubmissionId,
                             Scheduler.InProcNodeId);
 
diff --git a/src/Build/Graph/GraphBuildRequestData.cs b/src/Build/Graph/GraphBuildRequestData.cs
index 50ae4772c1d..3ad3660c2a9 100644
--- a/src/Build/Graph/GraphBuildRequestData.cs
+++ b/src/Build/Graph/GraphBuildRequestData.cs
@@ -8,9 +8,6 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Shared;
 
-#nullable disable
-#nullable enable
-
 namespace Microsoft.Build.Graph
 {
     public record GraphBuildOptions
@@ -24,7 +21,7 @@ public record GraphBuildOptions
     /// <summary>
     /// GraphBuildRequestData encapsulates all of the data needed to submit a graph build request.
     /// </summary>
-    public sealed class GraphBuildRequestData : BuildRequestDataBase
+    public sealed class GraphBuildRequestData : BuildRequestData<GraphBuildRequestData, GraphBuildResult>
     {
         /// <summary>
         /// Constructs a GraphBuildRequestData for build requests based on a project graph.
@@ -188,6 +185,10 @@ private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices?
         /// <value>The project graph entry points.</value>
         public IEnumerable<ProjectGraphEntryPoint>? ProjectGraphEntryPoints { get; }
 
+        internal override BuildSubmission<GraphBuildRequestData, GraphBuildResult> CreateSubmission(BuildManager buildManager, int submissionId, GraphBuildRequestData requestData,
+            bool legacyThreadingSemantics) =>
+            new GraphBuildSubmission(buildManager, submissionId, requestData);
+
         public override IEnumerable<string> EntryProjectsFullPath
         {
             get
diff --git a/src/Build/Graph/GraphBuildSubmission.cs b/src/Build/Graph/GraphBuildSubmission.cs
index a9b96008854..bd726f1bd6b 100644
--- a/src/Build/Graph/GraphBuildSubmission.cs
+++ b/src/Build/Graph/GraphBuildSubmission.cs
@@ -8,10 +8,23 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Graph
 {
+    /// <summary>
+    /// A callback used to receive notification that a build has completed.
+    /// </summary>
+    /// <remarks>
+    /// When this delegate is invoked, the WaitHandle on the BuildSubmission will have been be signalled and the OverallBuildResult will be valid.
+    /// </remarks>
+    public delegate void GraphBuildSubmissionCompleteCallback(GraphBuildSubmission submission);
+
+    /// <summary>
+    /// A GraphBuildSubmission represents a graph build request which has been submitted to the BuildManager for processing.  It may be used to
+    /// execute synchronous or asynchronous graph build requests and provides access to the results upon completion.
+    /// </summary>
+    /// <remarks>
+    /// This class is thread-safe.
+    /// </remarks>
     public class GraphBuildSubmission : BuildSubmission<GraphBuildRequestData, GraphBuildResult>
     {
         internal GraphBuildSubmission(BuildManager buildManager, int submissionId, GraphBuildRequestData requestData) :
@@ -29,15 +42,13 @@ public override GraphBuildResult Execute()
             ExecuteAsync(null, null);
             WaitHandle.WaitOne();
 
-            return BuildResult;
+            ErrorUtilities.VerifyThrow(BuildResult != null,
+                "BuildResult is not populated after Execute is done.");
+
+            return BuildResult!;
         }
-    }
 
-    /// <summary>
-    /// A callback used to receive notification that a build has completed.
-    /// </summary>
-    /// <remarks>
-    /// When this delegate is invoked, the WaitHandle on the BuildSubmission will have been be signalled and the OverallBuildResult will be valid.
-    /// </remarks>
-    public delegate void GraphBuildSubmissionCompleteCallback(GraphBuildSubmission submission);
+        protected internal override GraphBuildResult CreateFailedResult(Exception exception)
+            => new(SubmissionId, exception);
+    }
 }
