diff --git a/.config/git-merge-flow-config.jsonc b/.config/git-merge-flow-config.jsonc
index ddbff8a9297..0f5474173b2 100644
--- a/.config/git-merge-flow-config.jsonc
+++ b/.config/git-merge-flow-config.jsonc
@@ -30,8 +30,12 @@
         "vs17.12": {
             "MergeToBranch": "vs17.13"
         },
-        // MSBuild latest release to main
+        // Automate opening PRs to merge msbuild's vs17.13 (SDK 9.0.2xx) into vs17.14 (SDK 9.0.3xx)
         "vs17.13": {
+            "MergeToBranch": "vs17.14"
+        },
+        // MSBuild latest release to main
+        "vs17.14": {
             "MergeToBranch": "main"
         }
     }
diff --git a/.config/tsaoptions.json b/.config/tsaoptions.json
index 53a4a691178..3f3b1eb1cde 100644
--- a/.config/tsaoptions.json
+++ b/.config/tsaoptions.json
@@ -6,5 +6,6 @@
     "iterationPath": "DevDiv",
     "notificationAliases": [ "msbtm@microsoft.com" ],
     "repositoryName": "MSBuild",
-    "codebaseName": "MSBuild"
+    "codebaseName": "MSBuild",
+    "serviceTreeId": "d0ebbe59-0779-4466-8280-a0ff9cab5550"
 }
diff --git a/.exp-insertions.yml b/.exp-insertions.yml
deleted file mode 100644
index dac0bddd22a..00000000000
--- a/.exp-insertions.yml
+++ /dev/null
@@ -1,236 +0,0 @@
-# Pipeline creates experimental msbuild insertions.
-
-trigger: none # Prevents this pipeline from triggering on check-ins
-pr: none # don't run this on PR as well
-
-parameters:
-  # Dotnet installer channel from which to take the latest dotnet bits.
-  - name: DotnetInstallerChannel
-    displayName: Dotnet installer channel
-    type: string
-    default: 'none'
-  # VS version for which to take the latest Retail MSBuild bits.
-  - name: VSVersionName
-    displayName: VS Version
-    type: string
-    default: 'none'
-  # Branch from the MSBuild Build CI pipeline. Default: main
-  # Top run for the branch would be used to create an experimental insertion.
-  - name: MSBuildBranch
-    displayName: MSBuild Branch
-    type: string
-    default: 'refs/heads/main'
-  # BuildID from the MSBuild Build CI pipeline. Overrides the choice of MSBuildBranch parameter
-  - name: MSBuildBuildID
-    displayName: MSBuild CI Run Override
-    type: string
-    default: 'default'
-
-variables:
-  - name: _MsBuildCiPipelineId
-    value: 9434
-  - name: _MSBuildConfigFilePathRequestURL
-    value: 'https://dev.azure.com/cloudbuild/CloudBuild/_apis/git/repositories/CloudBuildConfig/items?versionDescriptor.version=main&path=config/batmon/Q-Prod-Co3/Coordinator/ToolsReleaseConfig-GeneralPublic.json&api-version=5.0'
-  - name: VSVersion
-    value: ${{parameters.VSVersionName}}
-
-pool:
-  vmImage: windows-latest
-
-jobs:
-- job: CreateExpDotnet
-  displayName: Create Experimental Dotnet
-  condition: ne('${{ parameters.DotnetInstallerChannel }}', 'none')
-  steps:
-  - powershell: |
-      mkdir '$(System.ArtifactsDirectory)/installer'
-
-      $dotnetChannel = '${{parameters.DotnetInstallerChannel}}'
-      $sdks = "dotnet-sdk-win-x64.zip", "dotnet-sdk-linux-x64.tar.gz"
-
-      foreach ($sdk in $sdks)
-      {
-        Write-Host "Downloading dotnet $sdk from channel $dotnetChannel"
-        Invoke-WebRequest `
-          -Uri "https://aka.ms/dotnet/$dotnetChannel/daily/$sdk" `
-          -OutFile "$(System.ArtifactsDirectory)/installer/$sdk"
-      }
-      mkdir '$(Pipeline.Workspace)/artifacts'
-    displayName: Download latest dotnet sdks
-
-  - task: DownloadBuildArtifacts@1
-    inputs:
-      buildType: specific
-      project: DevDiv
-      pipeline: $(_MsBuildCiPipelineId)
-      ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
-        buildVersionToDownload: latestFromBranch
-        branchName: '${{parameters.MSBuildBranch}}'
-      ${{ else }}:
-        buildVersionToDownload: specific
-        buildId: ${{parameters.MSBuildBuildID}}
-      artifactName: bin
-      itemPattern: 'MSBuild.Bootstrap/**'
-      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
-    displayName: Download msbuild artifacts
-
-  - powershell: |
-      $sdk = "dotnet-sdk-win-x64"
-
-      Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.zip"
-      Expand-Archive "$(System.ArtifactsDirectory)/installer/$sdk.zip" -DestinationPath "$(Pipeline.Workspace)/exp-dotnet/$sdk"
-
-      $dotnetDirectory = Get-ChildItem -Directory -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk"
-      $dotnetVersion = $dotnetDirectory.Name
-      Write-Host "Detected dotnet version: $dotnetVersion"
-
-      Write-Host "Updating MSBuild dlls."
-      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
-        -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
-        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
-        -configuration Release `
-        -makeBackup $false
-
-      Write-Host "Compressing dotnet sdk files"
-      Get-ChildItem -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/$sdk.zip"
-
-    displayName: Dogfood msbuild dlls to dotnet sdk win-x64
-
-  - powershell: |
-      $sdk = "dotnet-sdk-linux-x64"
-
-      mkdir "$(Pipeline.Workspace)/exp-dotnet/$sdk"
-
-      Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.tar.gz"
-      tar -xzvf "$(System.ArtifactsDirectory)/installer/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk"
-
-      $dotnetDirectory = Get-ChildItem -Directory -Path $(Pipeline.Workspace)/exp-dotnet/$sdk/sdk
-      $dotnetVersion = $dotnetDirectory.Name
-      Write-Host "Detected dotnet version: $dotnetVersion"
-
-      Write-Host "Updating MSBuild dlls."
-      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
-        -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
-        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
-        -configuration Release `
-        -makeBackup $false
-
-      Write-Host "Compressing dotnet sdk files"
-      tar -czvf "$(Pipeline.Workspace)/artifacts/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk" .
-    displayName: Dogfood msbuild dlls to dotnet sdk linux-x64
-
-  - task: PublishPipelineArtifact@1
-    inputs:
-      targetPath: '$(Pipeline.Workspace)/artifacts'
-      artifactName: ExperimentalDotnet
-      parallel: true
-    condition: always()
-    displayName: Publish crank assests artifacts
-
-
-- job: CreateExpMSBuild
-  displayName: "Create Experimental MSBuild"
-  condition: ne('${{ parameters.VSVersionName }}', 'none')
-  steps:
-  - powershell: |
-      $token = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes("PAT:$env:ACCESSTOKEN"))
-      $headers = @{ Authorization = "Basic $token" };
-      $response = Invoke-RestMethod -Uri "$(_MSBuildConfigFilePathRequestURL)" -Headers $headers -Method Get
-      $MSBuildDropPath = $response.Tools.MSBuild.Locations
-      Write-Host "##vso[task.setvariable variable=MSBuildDropPath]$MSBuildDropPath"
-      Write-Host "MSBuild Drop Path directory: $MSBuildDropPath"
-    displayName: Get Retail MSBuild Drop Path
-    env:
-      ACCESSTOKEN: $(cloudbuild-token)
-
-  - task: NuGetToolInstaller@1
-    displayName: 'Install NuGet.exe'
-
-  - task: NuGetCommand@2
-    displayName: Restore internal tools
-    inputs:
-      command: restore
-      feedsToUse: config
-      restoreSolution: '$(Build.SourcesDirectory)\eng\common\internal\Tools.csproj'
-      nugetConfigPath: '$(Build.SourcesDirectory)\eng\common\internal\NuGet.config'
-      restoreDirectory: '$(Build.SourcesDirectory)\.packages'
-
-  # https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/1es-security-configuration/configuration-guides/pat-burndown-guidance#authentication-from-pipelines
-  # Requires Azure client 2.x
-  - task: AzureCLI@2
-    displayName: 'Set AzDO.DotnetPerfStarToken'
-    enabled: true
-    inputs:
-      azureSubscription: 'dotnet-perfstar at app.vssps.visualstudio.com'   # Azure DevOps service connection
-      scriptType: 'pscore'
-      scriptLocation: 'inlineScript'
-      inlineScript: |
-        # '499b84ac-1321-427f-aa17-267ca6975798' for Azure DevOps
-        $token = az account get-access-token --query accessToken --resource 499b84ac-1321-427f-aa17-267ca6975798 -o tsv
-        Write-Host "Setting AzDO.DotnetPerfStarToken"
-        Write-Host "##vso[task.setvariable variable=AzDO.DotnetPerfStarToken]${token}"
-
-  - powershell: |
-      mkdir "$(Pipeline.Workspace)/artifacts"
-
-      $dropAppDirectory = Get-ChildItem -Directory -Path "$(Build.SourcesDirectory)/.packages/drop.app"
-      $dropAppVersion = $dropAppDirectory.Name
-      Write-Host "Detected drop.exe version: $dropAppVersion"
-
-      $dropExePath = "$(Build.SourcesDirectory)/.packages/drop.app/$dropAppVersion/lib/net45/drop.exe"
-      Write-Host "Detected drop.exe path: $dropExePath"
-
-      Write-Host "Downloading VS msbuild"
-      $patAuthEnvVar = "patVariable"
-      & "$dropExePath" get --patAuthEnvVar $patAuthEnvVar -u "$(MSBuildDropPath)\$(VSVersion)" -d "$(System.ArtifactsDirectory)/VSMSBuildDrop"
-      Write-Host "Download of VS msbuild finished"
-
-      Write-Host "Copying VS msbuild to $(Pipeline.Workspace)/VSMSBuild"
-      Copy-Item -Path "$(System.ArtifactsDirectory)/VSMSBuildDrop/*" -Destination "$(Pipeline.Workspace)/VSMSBuild" -Recurse
-      Write-Host "Copy of VS msbuild finished"
-    displayName: Download msbuild vs drop
-    env:
-      patVariable: $(AzDO.DotnetPerfStarToken)
-
-  - task: DownloadBuildArtifacts@1
-    inputs:
-      buildType: specific
-      project: DevDiv
-      pipeline: $(_MsBuildCiPipelineId)
-      ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
-        buildVersionToDownload: latestFromBranch
-        branchName: '${{parameters.MSBuildBranch}}'
-      ${{ else }}:
-        buildVersionToDownload: specific
-        buildId: ${{parameters.MSBuildBuildID}}
-      artifactName: bin
-      itemPattern: |
-        MSBuild.Bootstrap/*/net472/**
-        Microsoft.Build.Conversion/*/net472/Microsoft.Build.Conversion.Core.dll
-        Microsoft.Build.Engine/*/net472/Microsoft.Build.Engine.dll
-        MSBuildTaskHost/**/MSBuildTaskHost.exe
-        MSBuildTaskHost/**/MSBuildTaskHost.pdb
-        MSBuild/*/*/net472/MSBuild.exe*
-      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
-    displayName: Download msbuild artifacts
-
-  - powershell: |
-      Write-Host "Updating MSBuild dlls."
-      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
-        -destination "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)/MSBuild/Current/Bin" `
-        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
-        -configuration Release `
-        -makeBackup $false
-
-      ls "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)"
-      Write-Host "Compressing msbuild files"
-      Get-ChildItem -Path "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/MSBuild.zip"
-    displayName: Dogfood msbuild dlls
-
-  - task: PublishPipelineArtifact@1
-    inputs:
-      targetPath: '$(Pipeline.Workspace)/artifacts'
-      artifactName: ExperimentalMSBuild
-      parallel: true
-    condition: always()
-    displayName: Publish crank assests artifacts
diff --git a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
index 24498a60544..d70b263742e 100644
--- a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
+++ b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
@@ -142,14 +142,19 @@ jobs:
             const { data: pullRequests } = await github.rest.pulls.list({
               owner: context.repo.owner,
               repo: context.repo.repo,
-              head: newBranch,
+              head: `${context.repo.owner}:${newBranch}`,
               base: baseBranch,
               state: 'open',
             });
 
             if (pullRequests.length === 0) {
+               console.log(`No open pull requests found for branch ${newBranch} against ${baseBranch}.`);
               return true;
             } else {
+              // Log pull request details
+              pullRequests.forEach(pr => {
+                console.log(`Pull request #${pr.number}: ${pr.title} (created by ${pr.user.login})`);
+              });
               return false;
             }
           }
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 624666c9360..8b1834e9b25 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -14,40 +14,40 @@ variables:
   value: none
 
 jobs:
-- job: CheckVersionBumpOnReleaseBranches
-  displayName: "Check Version Bump On Release Branches"
-  steps:
-  - powershell: |
-      $versionsFile = "eng/Versions.props"
-      $changedFiles = git diff --name-only HEAD HEAD~1
-      $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
-      $isInitialCommit = $false
-      $isVersionBumped = $false
-      if ($changedVersionsFile -ne $null) {
-        $difference = git diff HEAD~1 $versionsFile
-        $changedContent = $difference -join "%"
-        # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
-        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
-        $isInitialCommit = $changedContent -match $initialCommitPattern
-        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
-        if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
-          try {
-            $previousPatch = [Convert]::ToInt32($Matches.previous)
-            $currentPatch = [Convert]::ToInt32($Matches.current)
-            if ($currentPatch -gt $previousPatch) {
-              $isVersionBumped = $true
-            }
-          } catch {
-            Write-Host "An error occurred during conversion: $_"
-          }
-        }
-      }
+# - job: CheckVersionBumpOnReleaseBranches
+#   displayName: "Check Version Bump On Release Branches"
+#   steps:
+#   - powershell: |
+#       $versionsFile = "eng/Versions.props"
+#       $changedFiles = git diff --name-only HEAD HEAD~1
+#       $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
+#       $isInitialCommit = $false
+#       $isVersionBumped = $false
+#       if ($changedVersionsFile -ne $null) {
+#         $difference = git diff HEAD~1 $versionsFile
+#         $changedContent = $difference -join "%"
+#         # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
+#         $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
+#         $isInitialCommit = $changedContent -match $initialCommitPattern
+#         $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
+#         if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
+#           try {
+#             $previousPatch = [Convert]::ToInt32($Matches.previous)
+#             $currentPatch = [Convert]::ToInt32($Matches.current)
+#             if ($currentPatch -gt $previousPatch) {
+#               $isVersionBumped = $true
+#             }
+#           } catch {
+#             Write-Host "An error occurred during conversion: $_"
+#           }
+#         }
+#       }
 
-      if (!($isInitialCommit -or $isVersionBumped)) {
-        throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
-      }
-    condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
-    displayName: "Check if patch version is bumped up"
+#       if (!($isInitialCommit -or $isVersionBumped)) {
+#         throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
+#       }
+#     condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
+#     displayName: "Check if patch version is bumped up"
 
 - job: IfOnlyDocumentionChanged
   displayName: "Check whether Test Results need to be executed"
diff --git a/NuGet.config b/NuGet.config
index 81181590594..a11137a9563 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -13,6 +13,7 @@
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
     <add key="dotnet9" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json" />
+    <add key="dotnet9-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet9-transport/nuget/v3/index.json" />
     <add key="vs-impl" value="https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json" />
     <!-- We don't want other than VS OpenTelemetry libraries from vs-impl -->
     <packageSourceMapping>
diff --git a/azure-pipelines/vs-insertion-experimental.yml b/azure-pipelines/vs-insertion-experimental.yml
index ab2ce364131..965ceb7d478 100644
--- a/azure-pipelines/vs-insertion-experimental.yml
+++ b/azure-pipelines/vs-insertion-experimental.yml
@@ -2,6 +2,16 @@
 trigger: none
 name: $(Date:yyyyMMdd).$(Rev:r)
 
+# Since our release branch is the one flowing into main
+# we will keep our main experimental insertions to make sure everything is alright
+schedules:
+  - cron: '0 3 * * 1,3,5' # Runs every Monday, Wednesday and Friday at 3AM UTC
+    displayName: Experimental VS insertion main
+    branches:
+      include:
+        - main
+    always: false # Don't run if there are no code changes
+    
 resources:
   pipelines:
   - pipeline: 'MSBuild'
diff --git a/azure-pipelines/vs-insertion.yml b/azure-pipelines/vs-insertion.yml
index 2f8d8732f04..2f2046c4687 100644
--- a/azure-pipelines/vs-insertion.yml
+++ b/azure-pipelines/vs-insertion.yml
@@ -12,13 +12,13 @@ trigger: none
 pr: none
 name: $(Date:yyyyMMdd).$(Rev:r)
 
-schedules:
-  - cron: '0 3 * * 1-5' # Runs every weekday at 3AM UTC
-    displayName: Daily VS insertion main
-    branches:
-      include:
-        - main
-    always: false # Don't run if there are no code changes
+# schedules:
+#   - cron: '0 3 * * 1-5' # Runs every weekday at 3AM UTC
+#     displayName: Daily VS insertion main
+#     branches:
+#       include:
+#         - main
+#     always: false # Don't run if there are no code changes
 
 resources:
   pipelines:
@@ -66,7 +66,7 @@ variables:
   # `auto` should work every time and selecting a branch in parameters is likely to fail due to incompatible versions in MSBuild and VS
   - name: AutoInsertTargetBranch
     ${{ if eq(variables['Build.SourceBranchName'], 'vs17.14') }}:
-      value: 'rel/d17.14'
+      value: 'main'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.13') }}:
       value: 'rel/d17.13'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.12') }}:
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index dcff8617638..d4330ba658d 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -35,7 +35,8 @@
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Newtonsoft.Json'))' == 'true'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGetSdkResolver'))' == 'true'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.Extensions.'))' == 'true'" />
-
+        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.VisualStudio.SolutionPersistence'))' == 'true'" />
+      
         <!-- NuGet.targets and NuGet.RestoreEx.targets will be in the RuntimeTargetsCopyLocalItems ItemGroup -->
         <_NuGetRuntimeDependencies Include="%(RuntimeTargetsCopyLocalItems.Identity)" Condition="'@(RuntimeTargetsCopyLocalItems->Contains('NuGet.'))' == 'true'" />
 
@@ -48,7 +49,7 @@
 
   <Target Name="RemoveExtraAssemblyReferences" BeforeTargets="ResolveAssemblyReferences">
     <!-- This is really hacky, but these references will cause issues when trying to 'build' this project.
-         To acquire the NuGet binaries we depend on for local run-time ('bootstrap'), we we are using a PackageReference (to
+         To acquire the NuGet binaries we depend on for local run-time ('bootstrap'), we are using a PackageReference (to
          'NuGet.Build.Tasks' and 'Microsoft.Build.NuGetSdkResolver'). This has the advantage of using NuGets compatibility
          check to ensure we choose the right version of those assemblies. But, at 'bootstrap' time these runtime dependencies
          need to be in a specific location that does not mesh with NuGet. To resolve this, we include the default
diff --git a/eng/Packages.props b/eng/Packages.props
index a677edd736e..6afcad00799 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -19,22 +19,32 @@
     <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
+    <PackageVersion Include="System.Diagnostics.DiagnosticSource" Version="$(SystemDiagnosticsDiagnosticSourceVersion)" />
+    <PackageVersion Include="System.Diagnostics.EventLog" Version="$(SystemDiagnosticsEventLogVersion)" />
     <PackageVersion Include="System.Formats.Asn1" Version="$(SystemFormatsAsn1Version)" />
+    <PackageVersion Include="System.Formats.Nrbf" Version="$(SystemFormatsNrbfVersion)" />
     <PackageVersion Include="System.Memory" Version="$(SystemMemoryVersion)" />
-    <PackageVersion Include="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageVersion Include="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
     <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsVersion)" />
     <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.ProtectedData" Version="$(SystemSecurityCryptographyProtectedDataVersion)" />
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
-    <PackageVersion Include="System.Text.RegularExpressions" Version="$(SystemTextRegularExpressionsVersion)" />
     <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
     <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
     <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
-    <PackageVersion Include="System.Diagnostics.DiagnosticSource" Version="$(SystemDiagnosticsDiagnosticSourceVersion)" />
+
+    <!-- maintained in eng/dependabot/Packages.props -->
+    <!--
+      System.CodeDom
+      System.Security.Cryptography.Pkcs
+      System.Security.Cryptography.Xml
+      Microsoft.Bcl.Cryptography
+      Microsoft.VisualStudio.SolutionPersistence
+    -->
   </ItemGroup>
 </Project>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 15779fde2b2..6bf7dfcbf3a 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -3,24 +3,29 @@
 
 <UsageData>
   <IgnorePatterns>
-    <!-- 8.0 packages are not allowed in the 8.0 build, because they're not "current", so baseline them. -->
-    <UsagePattern IdentityGlob="System.CodeDom/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Collections.Immutable/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
-    <UsagePattern IdentityGlob="System.Reflection.Metadata/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Resources.Extensions/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*8.0.5*" />
-    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
-    <UsagePattern IdentityGlob="Microsoft.VisualStudio.SolutionPersistence/*1.0.*" />
-    <!-- Defined in Version.Details.xml - live version used in SB. -->
-    <UsagePattern IdentityGlob="System.Diagnostics.DiagnosticSource/*8.0.1*" />
+    <!-- 9.0 packages are not allowed in the 9.0 build, because they're not "current", so baseline them. -->
+    <UsagePattern IdentityGlob="System.CodeDom/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Collections.Immutable/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.DiagnosticSource/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.Metadata/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Resources.Extensions/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Channels/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*9.0.0*" />
+
+    <!-- dependency of System.Configuration.ConfigurationManager -->
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*9.0.0*" />
+    <!-- dependency of System.Resources.Extensions -->
+    <UsagePattern IdentityGlob="System.Formats.Nrbf/*9.0.0*" />
+    <!-- dependency of System.Security.Cryptography.Pkcs -->
+    <UsagePattern IdentityGlob="Microsoft.Bcl.Cryptography/*9.0.0*" />
   </IgnorePatterns>
   <Usages>
   </Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index dae73a24232..b8beb5ef2f6 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -7,71 +7,119 @@
       <Sha>1cec3b4a8fb07138136a1ca1e04763bfcf7841db</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
+    <!-- Intermediate is necessary for source build. -->
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-externals" Version="9.0.0-alpha.1.25160.2">
+      <Uri>https://github.com/dotnet/source-build-externals</Uri>
+      <Sha>e2c3c1329ea432b36e4570d977271454e8abb0a0</Sha>
+      <SourceBuild RepoName="source-build-externals" ManagedOnly="true" />
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="Microsoft.Bcl.Cryptography" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.CodeDom" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Collections.Immutable" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Configuration.ConfigurationManager" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Diagnostics.DiagnosticSource" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.CodeDom" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.Diagnostics.EventLog" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
-      This allows the package to be retrieved from previously-source-built artifacts and flow in as dependencies
-      of the packages produced by msbuild. -->
-    <Dependency Name="System.Collections.Immutable" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Formats.Asn1" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Configuration.ConfigurationManager" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Formats.Nrbf" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.Metadata" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Reflection.Metadata" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.MetadataLoadContext" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Reflection.MetadataLoadContext" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Resources.Extensions" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.Resources.Extensions" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Security.Cryptography.Pkcs" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.ProtectedData" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Security.Cryptography.Xml" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.Security.Cryptography.Pkcs" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="8.0.5">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>81cabf2857a01351e5ab578947c7403a5b128ad1</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.Xml" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Text.Encoding.CodePages" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Threading.Channels" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Text.Json" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Formats.Asn1" Version="8.0.1">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Threading.Channels" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Diagnostics.DiagnosticSource" Version="8.0.1">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>2d7eea252964e69be94cb9c847b371b23e4dd470</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Threading.Tasks.Dataflow" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
@@ -89,17 +137,17 @@
       <Uri>https://github.com/dotnet/arcade</Uri>
       <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.53">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.66">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>9202ddad5fabd4d7737fa0c717524fbe2455c972</Sha>
+      <Sha>181b65dad9f440c7a31fe673abc59c258f224ada</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-2.25111.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25164.10">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>19c9b9eb00ae9afa7bedb10bd6be06bb41a880f6</Sha>
+      <Sha>517e95f9430d387e0e387a23fa2c8351a0863c4a</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-2.25111.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-3.25164.10">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>19c9b9eb00ae9afa7bedb10bd6be06bb41a880f6</Sha>
+      <Sha>517e95f9430d387e0e387a23fa2c8351a0863c4a</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25111.5">
diff --git a/eng/Versions.props b/eng/Versions.props
index b9431b26635..509057e0c15 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.14.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.13.0-preview-24611-01</PackageValidationBaselineVersion>
+    <VersionPrefix>17.15.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.14.0-preview-25161-14</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -39,23 +39,37 @@
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <PropertyGroup>
+    <!-- manually maintained versions -->
     <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
-    <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.28</MicrosoftVisualStudioSolutionPersistenceVersion>
-    <SystemCollectionsImmutableVersion>8.0.0</SystemCollectionsImmutableVersion>
-    <SystemConfigurationConfigurationManagerVersion>8.0.0</SystemConfigurationConfigurationManagerVersion>
-    <SystemFormatsAsn1Version>8.0.1</SystemFormatsAsn1Version>
-    <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
-    <SystemReflectionMetadataLoadContextVersion>8.0.0</SystemReflectionMetadataLoadContextVersion>
-    <SystemReflectionMetadataVersion>8.0.0</SystemReflectionMetadataVersion>
-    <SystemResourcesExtensionsVersion>8.0.0</SystemResourcesExtensionsVersion>
-    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
-    <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
-    <SystemTextRegularExpressionsVersion>4.3.1</SystemTextRegularExpressionsVersion>
-    <SystemTextJsonVersion>8.0.5</SystemTextJsonVersion>
-    <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
-    <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
-    <SystemDiagnosticsDiagnosticSourceVersion>8.0.1</SystemDiagnosticsDiagnosticSourceVersion>
     <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
+    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
+  </PropertyGroup>
+  <PropertyGroup>
+    <!-- dotnet/runtime packages -->
+    <SystemCollectionsImmutableVersion>9.0.0</SystemCollectionsImmutableVersion>
+    <SystemConfigurationConfigurationManagerVersion>9.0.0</SystemConfigurationConfigurationManagerVersion>
+    <SystemDiagnosticsDiagnosticSourceVersion>9.0.0</SystemDiagnosticsDiagnosticSourceVersion>
+    <SystemDiagnosticsEventLogVersion>9.0.0</SystemDiagnosticsEventLogVersion>
+    <SystemFormatsAsn1Version>9.0.0</SystemFormatsAsn1Version>
+    <SystemFormatsNrbfVersion>9.0.0</SystemFormatsNrbfVersion>
+    <SystemReflectionMetadataVersion>9.0.0</SystemReflectionMetadataVersion>
+    <SystemReflectionMetadataLoadContextVersion>9.0.0</SystemReflectionMetadataLoadContextVersion>
+    <SystemResourcesExtensionsVersion>9.0.0</SystemResourcesExtensionsVersion>
+    <SystemSecurityCryptographyProtectedDataVersion>9.0.0</SystemSecurityCryptographyProtectedDataVersion>
+    <SystemTextEncodingCodePagesVersion>9.0.0</SystemTextEncodingCodePagesVersion>
+    <SystemTextJsonVersion>9.0.0</SystemTextJsonVersion>
+    <SystemThreadingChannelsVersion>9.0.0</SystemThreadingChannelsVersion>
+    <SystemThreadingTasksDataflowVersion>9.0.0</SystemThreadingTasksDataflowVersion>
+  </PropertyGroup>
+  <PropertyGroup>
+    <!-- maintained in eng/dependabot/Packages.props -->
+    <!--
+    <SystemCodeDomVersion></SystemCodeDomVersion>
+    <SystemSecurityCryptographyPkcsVersion></SystemSecurityCryptographyPkcsVersion>
+    <SystemSecurityCryptographyXmlVersion></SystemSecurityCryptographyXmlVersion>
+    <MicrosoftBclCryptographyVersion></MicrosoftBclCryptographyVersion>
+    <MicrosoftVisualStudioSolutionPersistenceVersion></MicrosoftVisualStudioSolutionPersistenceVersion>
+    -->
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
@@ -64,8 +78,8 @@
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
     <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25111.5</MicrosoftDotNetXUnitExtensionsVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.14.0-2.25111.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.14.0-preview.1.53</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25164.10</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.14.0-preview.1.66</NuGetBuildTasksVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
     <BootstrapSdkVersion>9.0.200-preview.0.24603.3</BootstrapSdkVersion>
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 9760c0c6bc3..2c9a1ee8d64 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -13,8 +13,8 @@
     <PackageVersion Include="BenchmarkDotNet" Version="0.13.10" />
     <PackageVersion Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
 
-    <PackageVersion Include="FluentAssertions" Version="6.12.0" />
-    <PackageVersion Update="FluentAssertions" Condition="'$(FluentAssertionsVersion)' != ''" Version="$(FluentAssertionsVersion)" />
+    <PackageVersion Include="AwesomeAssertions" Version="8.0.2" />
+    <PackageVersion Update="AwesomeAssertions" Condition="'$(AwesomeAssertionsVersion)' != ''" Version="$(AwesomeAssertionsVersion)" />
 
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
@@ -40,28 +40,25 @@
     <PackageVersion Include="FakeItEasy" Version="8.1.0" />
     <PackageVersion Update="FakeItEasy" Condition="'$(FakeItEasyVersion)' != ''" Version="$(FakeItEasyVersion)" />
 
-    <PackageVersion Include="System.CodeDom" Version="8.0.0" />
+    <PackageVersion Include="System.CodeDom" Version="9.0.0" />
     <PackageVersion Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
 
-    <PackageVersion Include="System.Private.Uri" Version="4.3.2" />
-    <PackageVersion Update="System.Private.Uri" Condition="'$(SystemPrivateUriVersion)' != ''" Version="$(SystemPrivateUriVersion)" />
-
-    <PackageVersion Include="System.Runtime" Version="4.3.1" />
-    <PackageVersion Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
-
-    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="8.0.0" />
+    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="9.0.0" />
     <PackageVersion Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
-    <PackageVersion Include="System.Security.Cryptography.Xml" Version="8.0.0" />
+    <PackageVersion Include="System.Security.Cryptography.Xml" Version="9.0.0" />
     <PackageVersion Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
 
-    <PackageVersion Include="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
-    <PackageVersion Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
+    <PackageVersion Include="Microsoft.Bcl.Cryptography.Xml" Version="9.0.0" />
+    <PackageVersion Update="Microsoft.Bcl.Cryptography.Xml" Condition="'$(MicrosoftBclCryptographyVersion)' != ''" Version="$(MicrosoftBclCryptographyVersion)" />
+
+    <!-- when this is bumped the submodule in https://github.com/dotnet/source-build-externals needs to be bumped in sync -->
+    <PackageVersion Include="Microsoft.VisualStudio.SolutionPersistence" Version="1.0.52" />
+    <PackageVersion Update="Microsoft.VisualStudio.SolutionPersistence" Condition="'$(MicrosoftVisualStudioSolutionPersistenceVersion)' != ''" Version="$(MicrosoftVisualStudioSolutionPersistenceVersion)" />
 
     <PackageVersion Include="Verify.Xunit" Version="19.14.1" />
     <PackageVersion Update="Verify.XUnit" Condition="'$(VerifyXUnitVersion)' != ''" Version="$(VerifyXUnitVersion)" />
-	
-	<PackageVersion Include="Microsoft.VisualStudio.SolutionPersistence" Version="$(MicrosoftVisualStudioSolutionPersistenceVersion)" />
+
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index d6abd900521..cfd643aea0e 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -28,46 +29,50 @@ public class SolutionFile_Tests
         /// <summary>
         /// Test that a project with the C++ project guid and an extension of vcproj is seen as invalid.
         /// </summary>
-        [Fact]
-        public void ParseSolution_VC()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolution_VC(bool isOptInSlnParsingWithNewParser)
         {
+            string solutionFileContents =
+            """
+            Microsoft Visual Studio Solution File, Format Version 9.00
+            # Visual Studio 2005
+            Project('{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}') = 'Project name.vcproj', 'Relative path\to\Project name.vcproj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
+            EndProject
+            Global
+                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                    Debug|AnyCPU = Debug|AnyCPU
+                    Release|AnyCPU = Release|AnyCPU
+                EndGlobalSection
+                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                EndGlobalSection
+                GlobalSection(SolutionProperties) = preSolution
+                    HideSolutionNode = FALSE
+                EndGlobalSection
+            EndGlobalf
+            """;
+
             Assert.Throws<InvalidProjectFileException>(() =>
             {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}') = 'Project name.vcproj', 'Relative path\to\Project name.vcproj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|AnyCPU = Debug|AnyCPU
-                        Release|AnyCPU = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
+                ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
                 Assert.Fail("Should not get here");
             });
         }
+
         /// <summary>
         /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid --
         /// we assume that all C++ projects except .vcproj are MSBuild format.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolution_VC2(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolution_VC2(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -92,11 +97,11 @@ public void ParseSolution_VC2(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             string expectedProjectName = convertToSlnx ? "Project name" : "Project name.myvctype";
             Assert.Equal(expectedProjectName, solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal(ConvertToUnixPathIfNeeded("Relative path\\to\\Project name.myvctype", convertToSlnx), solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("Relative path\\to\\Project name.myvctype", convertToSlnx || isOptInSlnParsingWithNewParser), solution.ProjectsInOrder[0].RelativePath);
             if (!convertToSlnx)
             {
                 // When converting to SLNX, the project GUID is not preserved.
@@ -105,187 +110,51 @@ public void ParseSolution_VC2(bool convertToSlnx)
         }
 
         /// <summary>
-        /// A slightly more complicated test where there is some different whitespace.
-        /// </summary>
-        [Fact]
-        public void ParseSolutionWithDifferentSpacing()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project(' { Project GUID} ')  = ' Project name ',  ' Relative path to project file '    , ' {0ABED153-9451-483C-8140-9E8D7306B216} '
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|AnyCPU = Debug|AnyCPU
-                        Release|AnyCPU = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.Equal("Project name", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal("Relative path to project file", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
-        }
-
-        /// <summary>
-        /// Solution with an empty project name.  This is somewhat malformed, but we should
-        /// still behave reasonably instead of crashing.
-        /// </summary>
-        [Fact]
-        public void ParseSolution_EmptyProjectName()
-        {
-            string solutionFileContents =
-                           @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{Project GUID}') = '', 'src\.proj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|AnyCPU = Debug|AnyCPU
-                        Release|AnyCPU = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.StartsWith("EmptyProjectName", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal("src\\.proj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
-        }
-
-        /// <summary>
-        /// Test some characters that are valid in a file name but that also could be
-        /// considered a delimiter by a parser. Does quoting work for special characters?
-        /// </summary>
-        [Fact]
-        public void ParseSolutionWhereProjectNameHasSpecialCharacters()
-        {
-            string solutionFileContents =
-                           @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{Project GUID}')  = 'MyProject,(=IsGreat)',  'Relative path to project file'    , '{0ABED153-9451-483C-8140-9E8D7306B216}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|AnyCPU = Debug|AnyCPU
-                        Release|AnyCPU = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.Equal("MyProject,(=IsGreat)", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal("Relative path to project file", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
-        }
-
-        /// <summary>
-        /// Ensure that a bogus version stamp in the .SLN file results in an
-        /// InvalidProjectFileException.
-        /// </summary>
-        [Fact]
-        public void BadVersionStamp()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version a.b
-                # Visual Studio 2005
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-        /// <summary>
-        /// Expected version numbers less than 7 to cause an invalid project file exception.
-        /// </summary>
-        [Fact]
-        public void VersionTooLow()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 6.0
-                # Visual Studio 2005
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-        /// <summary>
-        /// Test to parse a very basic .sln file to validate that description property in a solution file
-        /// is properly handled.
+        /// Solution with an empty project name.  
+        // This is somewhat malformed, but with old parser we should still behave reasonably instead of crashing.
+        // The new parser throws an exception.
         /// </summary>
-        [Fact]
-        public void ParseSolutionFileWithDescriptionInformation()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolution_EmptyProjectName(bool isOptInSlnParsingWithNewParser)
         {
             string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'AnyProject', 'AnyProject\AnyProject.csproj', '{2CAB0FBD-15D8-458B-8E63-1B5B840E9798}'
-                EndProject
-                Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-		                Description = Some description of this solution
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {2CAB0FBD-15D8-458B-8E63-1B5B840E9798}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {2CAB0FBD-15D8-458B-8E63-1B5B840E9798}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {2CAB0FBD-15D8-458B-8E63-1B5B840E9798}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {2CAB0FBD-15D8-458B-8E63-1B5B840E9798}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(SolutionProperties) = preSolution
-		                HideSolutionNode = FALSE
-	                EndGlobalSection
-                EndGlobal
-                ";
-            try
+            """
+            Microsoft Visual Studio Solution File, Format Version 9.00
+            # Visual Studio 2005
+            Project('{Project GUID}') = '', 'src\.proj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
+            EndProject
+            Global
+                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                    Debug|AnyCPU = Debug|AnyCPU
+                    Release|AnyCPU = Release|AnyCPU
+                EndGlobalSection
+                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                EndGlobalSection
+                GlobalSection(SolutionProperties) = preSolution
+                    HideSolutionNode = FALSE
+                EndGlobalSection
+            EndGlobal
+            """;
+
+            if (isOptInSlnParsingWithNewParser)
             {
-                ParseSolutionHelper(solutionFileContents);
+                Assert.Throws<InvalidProjectFileException>(() =>
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
+                });
             }
-            catch (Exception ex)
+            else
             {
-                Assert.Fail("Failed to parse solution containing description information. Error: " + ex.Message);
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
+                Assert.StartsWith("EmptyProjectName", solution.ProjectsInOrder[0].ProjectName);
+                Assert.Equal("src\\.proj", solution.ProjectsInOrder[0].RelativePath);
+                Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
             }
         }
 
@@ -293,9 +162,10 @@ public void ParseSolutionFileWithDescriptionInformation()
         /// Tests the parsing of a very basic .SLN file with three independent projects.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void BasicSolution(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void BasicSolution(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -332,23 +202,24 @@ public void BasicSolution(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
             // When converting to slnx, the order of the projects is not preserved.
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
             ProjectInSolution consoleApplication1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ConsoleApplication1");
-            Assert.Equal(ConvertToUnixPathIfNeeded("ConsoleApplication1\\ConsoleApplication1.vbproj", convertToSlnx), consoleApplication1.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ConsoleApplication1\\ConsoleApplication1.vbproj", usesNewParser), consoleApplication1.RelativePath);
             Assert.Empty(consoleApplication1.Dependencies);
             Assert.Null(consoleApplication1.ParentProjectGuid);
 
             ProjectInSolution vbClassLibrary = solution.ProjectsInOrder.First(p => p.ProjectName == "vbClassLibrary");
-            Assert.Equal(ConvertToUnixPathIfNeeded("vbClassLibrary\\vbClassLibrary.vbproj", convertToSlnx), vbClassLibrary.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("vbClassLibrary\\vbClassLibrary.vbproj", usesNewParser), vbClassLibrary.RelativePath);
             Assert.Empty(vbClassLibrary.Dependencies);
             Assert.Null(vbClassLibrary.ParentProjectGuid);
 
             ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", convertToSlnx), classLibrary1.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser), classLibrary1.RelativePath);
             Assert.Empty(classLibrary1.Dependencies);
             Assert.Null(classLibrary1.ParentProjectGuid);
 
@@ -364,89 +235,12 @@ public void BasicSolution(bool convertToSlnx)
         /// Exercises solution folders, and makes sure that samely named projects in different
         /// solution folders will get correctly uniquified.
         /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
+        /// See the test with the same name in SolutionFile_Tests_OldParser.
         /// </summary>
-        [Fact]
-        public void SolutionFolders()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{34E0D07D-CF8F-459D-9449-C4188D8C5564}'
-                EndProject
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySlnFolder', 'MySlnFolder', '{E0F97730-25D2-418A-A7BD-02CAFDC6E470}'
-                EndProject
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj', '{A5EE8128-B08E-4533-86C5-E46714981680}'
-                EndProject
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySubSlnFolder', 'MySubSlnFolder', '{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}'
-                EndProject
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary2', 'ClassLibrary2\ClassLibrary2.csproj', '{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any CPU = Debug|Any CPU
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.Build.0 = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(NestedProjects) = preSolution
-                        {A5EE8128-B08E-4533-86C5-E46714981680} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
-                        {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4} = {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.Equal(5, solution.ProjectsInOrder.Count);
-
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", false), solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{34E0D07D-CF8F-459D-9449-C4188D8C5564}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
-
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
-
-            Assert.Equal(ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", false), solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{A5EE8128-B08E-4533-86C5-E46714981680}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[2].ParentProjectGuid);
-
-            Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", solution.ProjectsInOrder[3].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[3].ParentProjectGuid);
-
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", false), solution.ProjectsInOrder[4].RelativePath);
-            Assert.Equal("{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}", solution.ProjectsInOrder[4].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[4].Dependencies);
-            Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", solution.ProjectsInOrder[4].ParentProjectGuid);
-        }
-
-        /// <summary>
-        /// Exercises solution folders, and makes sure that samely named projects in different
-        /// solution folders will get correctly uniquified.
-        /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
-        /// </summary>
-        [Fact]
-        public void SolutionFoldersSlnx()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionFolders(bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -492,164 +286,40 @@ public void SolutionFoldersSlnx()
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, true);
+            bool isOptInSlnParsingWithNewParser = !convertToSlnx;
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
             var classLibrary1 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", true));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser));
             Assert.NotNull(classLibrary1);
             Assert.Empty(classLibrary1.Dependencies);
             Assert.Null(classLibrary1.ParentProjectGuid);
 
             var myPhysicalFolderClassLibrary1 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", true));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", usesNewParser));
             Assert.NotNull(myPhysicalFolderClassLibrary1);
             Assert.Empty(myPhysicalFolderClassLibrary1.Dependencies);
 
             var classLibrary2 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", true));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", usesNewParser));
             Assert.NotNull(classLibrary2);
             Assert.Empty(classLibrary2.Dependencies);
 
             // When converting to slnx, the guids are not preserved.
-            // try at list assert not null
-            Assert.NotNull(myPhysicalFolderClassLibrary1.ParentProjectGuid);
-            Assert.NotNull(classLibrary2.ParentProjectGuid);
-        }
-
-        /// <summary>
-        /// Exercises shared projects.
-        /// </summary>
-        [Fact]
-        public void SharedProjects()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 12.00
-                # Visual Studio 15
-                VisualStudioVersion = 15.0.27610.1
-                MinimumVisualStudioVersion = 10.0.40219.1
-                Project('{D954291E-2A0B-460D-934E-DC6B0785DB48}') = 'SharedProject1', 'SharedProject1\SharedProject1.shproj', '{14686F51-D0C2-4832-BBAA-6FBAEC676995}'
-                EndProject
-                Project('{D954291E-2A0B-460D-934E-DC6B0785DB48}') = 'SharedProject2', 'SharedProject2\SharedProject2.shproj', '{BAE750E8-4656-4947-B06B-3961E1051DF7}'
-                EndProject
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{3A0EC360-A42A-417F-BDEF-619682CF6119}'
-                EndProject
-                Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ClassLibrary2', 'ClassLibrary2\ClassLibrary2.vbproj', '{6DEF6DE8-FBF0-4240-B469-282DEE87899C}'
-                EndProject
-                Global
-                    GlobalSection(SharedMSBuildProjectFiles) = preSolution
-                        SharedProject1\SharedProject1.projitems*{14686f51-d0c2-4832-bbaa-6fbaec676995}*SharedItemsImports = 13
-                        SharedProject1\SharedProject1.projitems*{3a0ec360-a42a-417f-bdef-619682cf6119}*SharedItemsImports = 4
-                        SharedProject2\SharedProject2.projitems*{6def6de8-fbf0-4240-b469-282dee87899c}*SharedItemsImports = 4
-                        SharedProject2\SharedProject2.projitems*{bae750e8-4656-4947-b06b-3961e1051df7}*SharedItemsImports = 13
-                    EndGlobalSection
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any CPU = Debug|Any CPU
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {3A0EC360-A42A-417F-BDEF-619682CF6119}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {3A0EC360-A42A-417F-BDEF-619682CF6119}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {3A0EC360-A42A-417F-BDEF-619682CF6119}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {3A0EC360-A42A-417F-BDEF-619682CF6119}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {6DEF6DE8-FBF0-4240-B469-282DEE87899C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {6DEF6DE8-FBF0-4240-B469-282DEE87899C}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {6DEF6DE8-FBF0-4240-B469-282DEE87899C}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {6DEF6DE8-FBF0-4240-B469-282DEE87899C}.Release|Any CPU.Build.0 = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(ExtensibilityGlobals) = postSolution
-                        SolutionGuid = {1B671EF6-A62A-4497-8351-3EE8679CA86F}
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.Equal(4, solution.ProjectsInOrder.Count);
-
-            Assert.Equal(@"SharedProject1\SharedProject1.shproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{14686F51-D0C2-4832-BBAA-6FBAEC676995}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
-
-            Assert.Equal(@"SharedProject2\SharedProject2.shproj", solution.ProjectsInOrder[1].RelativePath);
-            Assert.Equal("{BAE750E8-4656-4947-B06B-3961E1051DF7}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
-
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{3A0EC360-A42A-417F-BDEF-619682CF6119}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
-
-            Assert.Equal(@"ClassLibrary2\ClassLibrary2.vbproj", solution.ProjectsInOrder[3].RelativePath);
-            Assert.Equal("{6DEF6DE8-FBF0-4240-B469-282DEE87899C}", solution.ProjectsInOrder[3].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[3].ParentProjectGuid);
-        }
-
-        /// <summary>
-        /// Tests situation where there's a nonexistent project listed in the solution folders.  We should
-        /// error with a useful message.
-        /// </summary>
-        [Fact]
-        public void MissingNestedProject()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySlnFolder', 'MySlnFolder', '{E0F97730-25D2-418A-A7BD-02CAFDC6E470}'
-                EndProject
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj', '{A5EE8128-B08E-4533-86C5-E46714981680}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any CPU = Debug|Any CPU
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.Build.0 = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(NestedProjects) = preSolution
-                        {A5EE8128-B08E-4533-86C5-E46714981680} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
-                        {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            try
+            if (!convertToSlnx)
             {
-                ParseSolutionHelper(solutionFileContents);
+                Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", myPhysicalFolderClassLibrary1.ParentProjectGuid);
+                Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", classLibrary2.ParentProjectGuid);
             }
-            catch (InvalidProjectFileException e)
+            else
             {
-                Assert.Equal("MSB5023", e.ErrorCode);
-                Assert.Contains("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", e.Message);
-                return;
+                // try at least assert not null
+                Assert.NotNull(myPhysicalFolderClassLibrary1.ParentProjectGuid);
+                Assert.NotNull(classLibrary2.ParentProjectGuid);
             }
-
-            // Should not get here
-            Assert.Fail();
         }
 
         /// <summary>
@@ -657,9 +327,10 @@ public void MissingNestedProject()
         /// are correctly recognized by the solution parser.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void SolutionDependencies(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void SolutionDependencies(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -703,7 +374,7 @@ public void SolutionDependencies(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
@@ -711,19 +382,20 @@ public void SolutionDependencies(bool convertToSlnx)
             var classLibrary2 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary2");
             var classLibrary3 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary3");
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", convertToSlnx), classLibrary1.RelativePath);
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser), classLibrary1.RelativePath);
             Assert.Single(classLibrary1.Dependencies);
             Assert.Equal(classLibrary3.ProjectGuid, classLibrary1.Dependencies[0]);
             Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", convertToSlnx), classLibrary2.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", usesNewParser), classLibrary2.RelativePath);
             Assert.Equal(2, classLibrary2.Dependencies.Count);
             // When converting to SLNX, the projects dependencies order is not preserved.
             Assert.Contains(classLibrary3.ProjectGuid, classLibrary2.Dependencies);
             Assert.Contains(classLibrary1.ProjectGuid, classLibrary2.Dependencies);
             Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary3\\ClassLibrary3.csproj", convertToSlnx), solution.ProjectsInOrder[2].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary3\\ClassLibrary3.csproj", usesNewParser), solution.ProjectsInOrder[2].RelativePath);
             Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
             Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
         }
@@ -732,9 +404,10 @@ public void SolutionDependencies(bool convertToSlnx)
         /// Make sure the solution configurations get parsed correctly for a simple mixed C#/VC solution
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolutionConfigurations(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolutionConfigurations(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -784,7 +457,7 @@ public void ParseSolutionConfigurations(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(7, solution.SolutionConfigurations.Count);
 
@@ -809,9 +482,10 @@ public void ParseSolutionConfigurations(bool convertToSlnx)
         /// Make sure the solution configurations get parsed correctly for a simple C# application
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolutionConfigurationsNoMixedPlatform(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -846,7 +520,7 @@ public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(6, solution.SolutionConfigurations.Count);
 
@@ -867,93 +541,15 @@ public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
             Assert.Equal("Any CPU", solution.GetDefaultPlatformName()); // "Default solution platform"
         }
 
-        /// <summary>
-        /// Test some invalid cases for solution configuration parsing.
-        /// There can be only one '=' character in a sln cfg entry, separating two identical names
-        /// </summary>
-        [Fact]
-        public void ParseInvalidSolutionConfigurations1()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any=CPU = Debug|Any=CPU
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-        /// <summary>
-        /// Test some invalid cases for solution configuration parsing
-        /// There can be only one '=' character in a sln cfg entry, separating two identical names
-        /// </summary>
-        [Fact]
-        public void ParseInvalidSolutionConfigurations2()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any CPU = Something|Else
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-        /// <summary>
-        /// Test some invalid cases for solution configuration parsing
-        /// Solution configurations must include the platform part
-        /// </summary>
-        [Fact]
-        public void ParseInvalidSolutionConfigurations3()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug = Debug
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-
         /// <summary>
         /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseProjectConfigurationsInSolutionConfigurations1(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -1000,7 +596,7 @@ public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSl
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             ProjectInSolution csharpProject = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
             ProjectInSolution vcProject = solution.ProjectsInOrder.First(p => p.ProjectName == "MainApp");
@@ -1046,69 +642,11 @@ public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSl
             Assert.True(vcProject.ProjectConfigurations["Release|Win32"].IncludeInBuild);
         }
 
-        /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly
-        /// for a more tricky solution
-        /// </summary>
-        [Fact]
-        public void ParseProjectConfigurationsInSolutionConfigurations2()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'C:\solutions\WebSite1\', '..\WebSite1\', '{E8E75132-67E4-4D6F-9CAE-8DA4C883F418}'
-                EndProject
-                Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'C:\solutions\WebSite2\', '..\WebSite2\', '{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}'
-                EndProject
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'NewFolder1', 'NewFolder1', '{54D20FFE-84BE-4066-A51E-B25D040A4235}'
-                EndProject
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'NewFolder2', 'NewFolder2', '{D2633E4D-46FF-4C4E-8340-4BC7CDF78615}'
-                EndProject
-                Project('{8BC9CEB9-8B4A-11D0-8D11-00A0C91BC942}') = 'MSBuild.exe', '..\..\dd\binaries.x86dbg\bin\i386\MSBuild.exe', '{25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|.NET = Debug|.NET
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {E8E75132-67E4-4D6F-9CAE-8DA4C883F418}.Debug|.NET.ActiveCfg = Debug|.NET
-                        {E8E75132-67E4-4D6F-9CAE-8DA4C883F418}.Debug|.NET.Build.0 = Debug|.NET
-                        {25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0}.Debug|.NET.ActiveCfg = Debug
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(NestedProjects) = preSolution
-                        {25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0} = {D2633E4D-46FF-4C4E-8340-4BC7CDF78615}
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            ProjectInSolution webProject = (ProjectInSolution)solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F418}"];
-            ProjectInSolution exeProject = (ProjectInSolution)solution.ProjectsByGuid["{25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0}"];
-            ProjectInSolution missingWebProject = (ProjectInSolution)solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}"];
-
-            Assert.Single(webProject.ProjectConfigurations);
-
-            Assert.Equal("Debug|.NET", webProject.ProjectConfigurations["Debug|.NET"].FullName);
-            Assert.True(webProject.ProjectConfigurations["Debug|.NET"].IncludeInBuild);
-
-            Assert.Single(exeProject.ProjectConfigurations);
-
-            Assert.Equal("Debug", exeProject.ProjectConfigurations["Debug|.NET"].FullName);
-            Assert.False(exeProject.ProjectConfigurations["Debug|.NET"].IncludeInBuild);
-
-            Assert.Empty(missingWebProject.ProjectConfigurations);
-
-            Assert.Equal("Debug", solution.GetDefaultConfigurationName()); // "Default solution configuration"
-            Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
-        }
-
-        [Fact]
-        public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
+        [Theory]
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseProjectConfigurationsInSolutionConfigurations2(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -1116,9 +654,9 @@ public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
                 # Visual Studio Version 17
                 VisualStudioVersion = 17.11.35111.106
                 MinimumVisualStudioVersion = 10.0.40219.1
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""WinFormsApp1"", ""WinFormsApp1\WinFormsApp1.csproj"", ""{3B592A6A-6215-4675-9237-7FEB36BDB4F1}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WinFormsApp1", "WinFormsApp1\WinFormsApp1.csproj", "{3B592A6A-6215-4675-9237-7FEB36BDB4F1}"
                 EndProject
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1\ClassLibrary1.csproj"", ""{C25056E0-405C-4476-9B22-839264A8530C}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1\ClassLibrary1.csproj", "{C25056E0-405C-4476-9B22-839264A8530C}"
                 EndProject
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -1144,7 +682,7 @@ public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, true);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             ProjectInSolution winFormsApp1 = solution.ProjectsInOrder.First(p => p.ProjectName == "WinFormsApp1");
             ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
@@ -1166,73 +704,21 @@ public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
             Assert.False(classLibrary1.ProjectConfigurations["Release|Any CPU"].IncludeInBuild);
         }
 
-        /// <summary>
-        /// Parse solution file with comments
-        /// </summary>
-        [Fact]
-        public void ParseSolutionWithComments()
-        {
-            const string solutionFileContent = @"
-                    Microsoft Visual Studio Solution File, Format Version 12.00
-                    # Visual Studio Version 16
-                    VisualStudioVersion = 16.0.29123.89
-                    MinimumVisualStudioVersion = 10.0.40219.1
-                    Project('{9A19103F-16F7-4668-BE54-9A1E7A4F7556}') = 'SlnCommentTest', 'SlnCommentTest.csproj', '{00000000-0000-0000-FFFF-FFFFFFFFFFFF}'
-                    EndProject
-                    Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'Solution Items', 'Solution Items', '{054DED3B-B890-4652-B449-839F581E5D86}'
-	                    ProjectSection(SolutionItems) = preProject
-		                    SlnFile.txt = SlnFile.txt
-	                    EndProjectSection
-                    EndProject
-                    Global
-	                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                    Debug|Any CPU = Debug|Any CPU
-		                    Release|Any CPU = Release|Any CPU
-	                    EndGlobalSection
-	                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.Build.0 = Release|Any CPU
-	                    EndGlobalSection
-	                    GlobalSection(SolutionProperties) = preSolution
-		                    HideSolutionNode = FALSE
-	                    EndGlobalSection
-	                    GlobalSection(ExtensibilityGlobals) = postSolution
-		                    SolutionGuid = {FFFFFFFF-FFFF-FFFF-0000-000000000000}
-	                    EndGlobalSection
-                    EndGlobal
-                    ";
-
-            StringBuilder stringBuilder = new StringBuilder();
-
-            // Put comment between all lines
-            const string comment = "\t# comment";
-            string[] lines = solutionFileContent.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
-            for (int i = 0; i < lines.Length; i++)
-            {
-                stringBuilder.AppendLine(comment);
-                stringBuilder.AppendLine(lines[i]);
-            }
-            stringBuilder.AppendLine(comment);
-
-            Should.NotThrow(() => ParseSolutionHelper(stringBuilder.ToString()));
-        }
-
         /// <summary>
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
         /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
         /// </summary>
-        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser, bool convertToSlnx = false)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
+                if (isOptInSlnParsingWithNewParser)
+                {
+                    testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
+                }
                 TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
-
                 string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
-
                 return SolutionFile.Parse(solutionPath);
             }
         }
@@ -1246,11 +732,10 @@ private static string ConvertToSlnx(string slnPath)
             return slnxPath;
         }
 
-        private static string ConvertToUnixPathIfNeeded(string path, bool isConvertedToSlnx)
+        private static string ConvertToUnixPathIfNeeded(string path, bool usesNewParser)
         {
             // In the new parser, ProjectModel.FilePath is converted to Unix-style.
-            // we are using the new parser only for slnx files.
-            return !NativeMethodsShared.IsWindows && isConvertedToSlnx ? path.Replace('\\', '/') : path;
+            return usesNewParser && !NativeMethodsShared.IsWindows ? path.Replace('\\', '/') : path;
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index df1c15ea5e6..dc35f5d7d0b 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -20,10 +20,11 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
 
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
     <PackageDownload Include="NuGet.CommandLine" Version="[$(NuGetCommandLinePackageVersion)]" />
   </ItemGroup>
 
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index bbe0f749387..488f5f8bfd9 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -33,10 +33,10 @@ public void NoCachesProducesEmptyCaches()
             var aggregation = aggregator.Aggregate();
 
             aggregation.ConfigCache.ShouldNotBeNull();
-            aggregation.ConfigCache.GetEnumerator().ToEnumerable().ShouldBeEmpty();
+            aggregation.ConfigCache.ShouldBeEmpty();
 
             aggregation.ResultsCache.ShouldNotBeNull();
-            aggregation.ResultsCache.GetEnumerator().ToEnumerable().ShouldBeEmpty();
+            aggregation.ResultsCache.ShouldBeEmpty();
 
             aggregation.LastConfigurationId.ShouldBe(0);
         }
@@ -246,9 +246,9 @@ private void AssertAggregation((ConfigCache configCache, ResultsCache resultsCac
             var currentConfigurationIndex = 0;
             var currentBuildResultIndex = 0;
 
-            var aggregatedConfigs = aggregation.ConfigCache.GetEnumerator().ToArray();
+            var aggregatedConfigs = aggregation.ConfigCache.ToArray();
 
-            var aggregatedResults = aggregation.ResultsCache.GetEnumerator().ToArray();
+            var aggregatedResults = aggregation.ResultsCache.ToArray();
 
             foreach (var (configCache, resultsCache) in inputCaches)
             {
diff --git a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
index 3ca18bc9832..bf40853c4e8 100644
--- a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
@@ -101,8 +101,8 @@ public void ConfigCacheShouldBeTranslatable(object obj)
             TranslationHelpers.GetReadTranslator().Translate(ref copy);
 
             // test _configurations
-            var initialConfigurations = initial.GetEnumerator().ToArray();
-            var copiedConfigurations = copy.GetEnumerator().ToArray();
+            var initialConfigurations = initial.ToArray();
+            var copiedConfigurations = copy.ToArray();
 
             Assert.Equal(copiedConfigurations, initialConfigurations, EqualityComparer<BuildRequestConfiguration>.Default);
 
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 3da36a531ab..74963e26794 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -331,12 +331,12 @@ public void TestTranslation()
                     LogMessagePacket deserializedPacket = tempPacket as LogMessagePacket;
 
                     packet.Should().BeEquivalentTo(deserializedPacket, options => options
-                        .RespectingRuntimeTypes());
+                        .PreferringRuntimeMemberTypes());
 
                     BuildEventArgs args = packet.NodeBuildEvent?.Value;
                     BuildEventArgs desArgs = deserializedPacket?.NodeBuildEvent?.Value;
                     desArgs.Should().BeEquivalentTo(args, options => options
-                        .RespectingRuntimeTypes()
+                        .PreferringRuntimeMemberTypes()
                         // Since we use struct DictionaryEntry of class TaskItemData, generated DictionaryEntry.Equals compare TaskItemData by references.
                         // Bellow will instruct equivalency test to not use DictionaryEntry.Equals but its public members for equivalency tests.
                         .ComparingByMembers<DictionaryEntry>()
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index 7fc43eccc59..eceb5123067 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -80,7 +80,7 @@ public void CacheCanBeEnumerated()
             result2.AddResultsForTarget("result2target1", BuildResultUtilities.GetEmptyFailingTargetResult());
             cache.AddResult(result2);
 
-            var results = cache.GetEnumerator().ToArray();
+            var results = cache.ToArray();
 
             results.Length.ShouldBe(2);
 
diff --git a/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
index 7f56b600dca..014b8521524 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
@@ -129,23 +129,22 @@ public void ProjectWithWebsiteProperties(bool convertToSlnx)
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
         /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
         /// </summary>
-        internal static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
+                solutionFileContents = solutionFileContents.Replace('\'', '"');
+                testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
                 TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
-
                 string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
-
                 SolutionFile solutionFile = new SolutionFile { FullPath = solutionPath };
                 solutionFile.ParseUsingNewParser();
                 return solutionFile;
             }
         }
 
-        private static string ConvertToSlnx(string slnPath)
+        internal static string ConvertToSlnx(string slnPath)
         {
             string slnxPath = slnPath + "x";
             ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_OldParser_Tests.cs
similarity index 95%
rename from src/Build.UnitTests/Construction/SolutionFile_Tests.cs
rename to src/Build.UnitTests/Construction/SolutionFile_OldParser_Tests.cs
index 79bb93a4703..ab51906b222 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_OldParser_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
+using System.Text;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
@@ -16,11 +17,11 @@
 
 namespace Microsoft.Build.UnitTests.Construction
 {
-    public class SolutionFile_Tests
+    public class SolutionFile_OldParser_Tests
     {
         public ITestOutputHelper TestOutputHelper { get; }
 
-        public SolutionFile_Tests(ITestOutputHelper testOutputHelper)
+        public SolutionFile_OldParser_Tests(ITestOutputHelper testOutputHelper)
         {
             TestOutputHelper = testOutputHelper;
         }
@@ -104,6 +105,42 @@ public void ParseFirstProjectLineWithDifferentSpacing()
             proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
+        /// <summary>
+        /// A slightly more complicated test where there is some different whitespace.
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWithDifferentSpacing()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project(' { Project GUID} ')  = ' Project name ',  ' Relative path to project file '    , ' {0ABED153-9451-483C-8140-9E8D7306B216} '
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|AnyCPU = Debug|AnyCPU
+                        Release|AnyCPU = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            Assert.Equal("Project name", solution.ProjectsInOrder[0].ProjectName);
+            Assert.Equal("Relative path to project file", solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+        }
+
         /// <summary>
         /// First project line with an empty project name.  This is somewhat malformed, but we should
         /// still behave reasonably instead of crashing.
@@ -687,6 +724,43 @@ public void ParseFirstProjectLineWhereProjectNameHasSpecialCharacters()
             proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
+        /// <summary>
+        /// Test some characters that are valid in a file name but that also could be
+        /// considered a delimiter by a parser. Does quoting work for special characters?
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWhereProjectNameHasSpecialCharacters()
+        {
+            string solutionFileContents =
+                           @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{Project GUID}')  = 'MyProject,(=IsGreat)',  'Relative path to project file'    , '{0ABED153-9451-483C-8140-9E8D7306B216}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|AnyCPU = Debug|AnyCPU
+                        Release|AnyCPU = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            Assert.Equal("MyProject,(=IsGreat)", solution.ProjectsInOrder[0].ProjectName);
+            Assert.Equal("Relative path to project file", solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+        }
+
         /// <summary>
         /// Test some characters that are valid in a file name but that also could be
         /// considered a delimiter by a parser. Does quoting work for special characters?
@@ -2355,5 +2429,58 @@ public void ParseSolutionWithParentedPaths()
             solution.ProjectsInOrder[0].AbsolutePath.ShouldBe(Path.GetFullPath(Path.Combine(Path.GetDirectoryName(solution.FullPath)!, expectedRelativePath)));
             solution.ProjectsInOrder[0].ProjectGuid.ShouldBe("{0ABED153-9451-483C-8140-9E8D7306B216}");
         }
+
+        /// <summary>
+        /// Parse solution file with comments
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWithComments()
+        {
+            const string solutionFileContent = @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29123.89
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project('{9A19103F-16F7-4668-BE54-9A1E7A4F7556}') = 'SlnCommentTest', 'SlnCommentTest.csproj', '{00000000-0000-0000-FFFF-FFFFFFFFFFFF}'
+                    EndProject
+                    Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'Solution Items', 'Solution Items', '{054DED3B-B890-4652-B449-839F581E5D86}'
+	                    ProjectSection(SolutionItems) = preProject
+		                    SlnFile.txt = SlnFile.txt
+	                    EndProjectSection
+                    EndProject
+                    Global
+	                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                    Debug|Any CPU = Debug|Any CPU
+		                    Release|Any CPU = Release|Any CPU
+	                    EndGlobalSection
+	                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.Build.0 = Release|Any CPU
+	                    EndGlobalSection
+	                    GlobalSection(SolutionProperties) = preSolution
+		                    HideSolutionNode = FALSE
+	                    EndGlobalSection
+	                    GlobalSection(ExtensibilityGlobals) = postSolution
+		                    SolutionGuid = {FFFFFFFF-FFFF-FFFF-0000-000000000000}
+	                    EndGlobalSection
+                    EndGlobal
+                    ";
+
+            StringBuilder stringBuilder = new StringBuilder();
+
+            // Put comment between all lines
+            const string comment = "\t# comment";
+            string[] lines = solutionFileContent.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
+            for (int i = 0; i < lines.Length; i++)
+            {
+                stringBuilder.AppendLine(comment);
+                stringBuilder.AppendLine(lines[i]);
+            }
+            stringBuilder.AppendLine(comment);
+
+            Should.NotThrow(() => ParseSolutionHelper(stringBuilder.ToString()));
+        }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
index 98f25d366cc..71a769aed3b 100644
--- a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
@@ -72,14 +72,14 @@ public void SolutionFilterFiltersProjects(bool graphBuild)
                     ");
                 // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
                 TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
-                    @"
+                    """
                     Microsoft Visual Studio Solution File, Format Version 12.00
                     # Visual Studio Version 16
                     VisualStudioVersion = 16.0.29326.124
                     MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", ""SimpleProject\SimpleProject.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SimpleProject", "SimpleProject\SimpleProject.csproj", "{79B5EBA6-5D27-4976-BC31-14422245A59A}"
                     EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", ""..\ClassLibrary\ClassLibrary\ClassLibrary.csproj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ClassLibrary", "..\ClassLibrary\ClassLibrary\ClassLibrary.csproj", "{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}"
                     EndProject
                     Global
                         GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -107,7 +107,7 @@ public void SolutionFilterFiltersProjects(bool graphBuild)
                             SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
                         EndGlobalSection
                     EndGlobal
-                ");
+                    """);
                 TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
                     /*lang=json*/
                                   """
@@ -284,6 +284,56 @@ public void ParseSolutionFilter(bool convertToSlnx)
             }
         }
 
+        [Fact]
+        public void SolutionFilterWithSpecialSymbolInThePath()
+        {
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+            // Create folder with special symbols in the name
+            folder = testEnvironment.CreateFolder(Path.Combine(folder.Path, $"test@folder%special$symbols"), createFolder: true);
+            // Create simple solution and simple solution filter
+            TransientTestFile sln = testEnvironment.CreateFile(folder, "SimpleSolution.sln",
+            """
+            Microsoft Visual Studio Solution File, Format Version 12.00
+            # Visual Studio Version 17
+            VisualStudioVersion = 17.0.31903.59
+            MinimumVisualStudioVersion = 10.0.40219.1
+            Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SolutionTest", "SolutionTest.csproj", "{767AA460-C33F-41C3-A8B6-4DA283263A51}"
+            EndProject
+            Global
+                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                    Debug|Any CPU = Debug|Any CPU
+                    Release|Any CPU = Release|Any CPU
+                EndGlobalSection
+                GlobalSection(SolutionProperties) = preSolution
+                    HideSolutionNode = FALSE
+                EndGlobalSection
+                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Release|Any CPU.Build.0 = Release|Any CPU
+                EndGlobalSection
+            EndGlobal
+            """);
+            TransientTestFile slnf = testEnvironment.CreateFile(folder, "SimpleSolution.slnf",
+            """
+            {
+                "solution": {
+                    "path": "SimpleSolution.sln",
+                    "projects": [
+                        "SolutionTest.csproj"
+                    ]
+                }
+            }
+            """);
+
+            SolutionFile sp = SolutionFile.Parse(slnf.Path);
+
+            // just assert that no error is thrown
+            Assert.True(sp.ProjectShouldBuild("SolutionTest.csproj"));
+        }
+
         private static string ConvertToSlnx(string slnPath)
         {
             string slnxPath = slnPath + "x";
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 8e28604557b..11179b170c6 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -38,6 +38,8 @@ public class SolutionProjectGenerator_Tests : IDisposable
 
         private static readonly BuildEventContext _buildEventContext = new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0);
 
+        private const string _longLineString = "a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-";
+
         public SolutionProjectGenerator_Tests(ITestOutputHelper output)
         {
             this.output = output;
@@ -65,12 +67,14 @@ public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
                 TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
-                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", @"Microsoft Visual Studio Solution File, Format Version 16.00");
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", "Microsoft Visual Studio Solution File, Format Version 12.00");
                 TransientTestFile targetsFile = testEnvironment.CreateFile(folder, name,
-                    @"<Project>
-                        <Target Name=""Build"" AfterTargets=""NonsenseTarget"">
+                      """
+                      <Project>
+                        <Target Name="Build" AfterTargets="NonsenseTarget">
                         </Target>
-                      </Project>");
+                      </Project>
+                      """);
                 ProjectInstance[] instances = SolutionProjectGenerator.Generate(SolutionFile.Parse(sln.Path), null, null, _buildEventContext, CreateMockLoggingService());
                 instances.ShouldHaveSingleItem();
                 instances[0].Targets["Build"].AfterTargets.ShouldBe(string.Empty);
@@ -79,6 +83,36 @@ public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
             }
         }
 
+        /// <summary>
+        /// Test that targets in before.{sln}.targets and after.{sln}.targets files are included in the project.
+        /// </summary>
+        [Theory]
+        [InlineData("before.MySln.sln.targets", false)]
+        [InlineData("before.MySln.sln.targets", true)]
+        [InlineData("after.MySln.sln.targets", false)]
+        [InlineData("after.MySln.sln.targets", true)]
+        public void SolutionProjectIncludesBeforeAndAfterTargets(string name, bool convertToSlnx)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                string solutionFileContents = "Microsoft Visual Studio Solution File, Format Version 12.00";
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", solutionFileContents);
+                string solutionPath = convertToSlnx ? SolutionFile_NewParser_Tests.ConvertToSlnx(sln.Path) : sln.Path;
+                testEnvironment.CreateFile(folder, name,
+                      """
+                      <Project>
+                          <Target Name="TestTarget" />
+                      </Project>
+                      """);
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(SolutionFile.Parse(solutionPath), null, null, _buildEventContext, CreateMockLoggingService());
+                instances.ShouldHaveSingleItem();
+                instances[0].Targets.ShouldContainKey("TestTarget");
+                MockLogger logger = new MockLogger(output);
+                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+            }
+        }
+
         [Fact]
         public void BuildProjectAsTarget()
         {
@@ -87,33 +121,35 @@ public void BuildProjectAsTarget()
                 TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
                 TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
                 TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
-                    @"<Project>
-                  <Target Name=""ClassLibraryTarget"">
-                      <Message Text=""ClassLibraryBuilt""/>
+                  """
+                  <Project>
+                  <Target Name="ClassLibraryTarget">
+                      <Message Text="ClassLibraryBuilt"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
                 TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
-                    @"<Project>
-                  <Target Name=""SimpleProjectTarget"">
-                      <Message Text=""SimpleProjectBuilt""/>
+                  """
+                  <Project>
+                  <Target Name="SimpleProjectTarget">
+                      <Message Text="SimpleProjectBuilt"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.6.30114.105
-MinimumVisualStudioVersion = 10.0.40219.1
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
-EndProject
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
-EndProject
-                ");
+                    """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.6.30114.105
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "simpleProject", "simpleProject\simpleProject.csproj", "{AA52A05F-A9C0-4C89-9933-BF976A304C91}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "classlib", "classlib\classlib.csproj", "{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}"
+                    EndProject
+                    """);
                 RunnerUtilities.ExecMSBuild(solutionFile.Path + " /t:classlib", out bool success);
                 success.ShouldBeTrue();
             }
@@ -130,56 +166,58 @@ public void BuildProjectWithMultipleTargets()
                 TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
                 TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
                 TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
-                    @"<Project>
-                  <Target Name=""Build"">
-                      <Message Text=""classlib.Build""/>
+                  """
+                  <Project>
+                  <Target Name="Build">
+                      <Message Text="classlib.Build"/>
                   </Target>
-                  <Target Name=""Clean"">
-                      <Message Text=""classlib.Clean""/>
+                  <Target Name="Clean">
+                      <Message Text="classlib.Clean"/>
                   </Target>
-                  <Target Name=""Custom"">
-                      <Message Text=""classlib.Custom""/>
+                  <Target Name="Custom">
+                      <Message Text="classlib.Custom"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
                 TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
-                    @"<Project>
-                  <Target Name=""Build"">
-                      <Message Text=""simpleProject.Build""/>
+                  """
+                  <Project>
+                  <Target Name="Build">
+                      <Message Text="simpleProject.Build"/>
                   </Target>
-                  <Target Name=""Clean"">
-                      <Message Text=""simpleProject.Clean""/>
+                  <Target Name="Clean">
+                      <Message Text="simpleProject.Clean"/>
                   </Target>
-                  <Target Name=""Custom"">
-                      <Message Text=""simpleProject.Custom""/>
+                  <Target Name="Custom">
+                      <Message Text="simpleProject.Custom"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.6.30114.105
-MinimumVisualStudioVersion = 10.0.40219.1
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
-EndProject
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|x86 = Debug|x86
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
-		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
-		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
-		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
-	EndGlobalSection
-EndGlobal
-                ");
+                    """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.6.30114.105
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "simpleProject", "simpleProject\simpleProject.csproj", "{AA52A05F-A9C0-4C89-9933-BF976A304C91}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "classlib", "classlib\classlib.csproj", "{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x86 = Debug|x86
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
+                            {AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
+                            {80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
+                            {80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
+                        EndGlobalSection
+                        EndGlobal
+                    """);
 
                 string output = RunnerUtilities.ExecMSBuild(solutionFile.Path + " /t:Clean;Build;Custom", out bool success);
                 success.ShouldBeTrue();
@@ -192,7 +230,6 @@ public void BuildProjectWithMultipleTargets()
             }
         }
 
-
         /// <summary>
         /// Build Solution with Multiple Targets (ex. Clean;Build;Custom).
         /// </summary>
@@ -204,56 +241,58 @@ public void BuildProjectWithMultipleTargetsInParallel()
                 TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
                 TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
                 TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
-                    @"<Project>
-                  <Target Name=""Build"">
-                      <Message Text=""classlib.Build""/>
+                  """
+                  <Project>
+                  <Target Name="Build">
+                      <Message Text="classlib.Build"/>
                   </Target>
-                  <Target Name=""Clean"">
-                      <Message Text=""classlib.Clean""/>
+                  <Target Name="Clean">
+                      <Message Text="classlib.Clean"/>
                   </Target>
-                  <Target Name=""Custom"">
-                      <Message Text=""classlib.Custom""/>
+                  <Target Name="Custom">
+                      <Message Text="classlib.Custom"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
                 TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
-                    @"<Project>
-                  <Target Name=""Build"">
-                      <Message Text=""simpleProject.Build""/>
+                  """
+                  <Project>
+                  <Target Name="Build">
+                      <Message Text="simpleProject.Build"/>
                   </Target>
-                  <Target Name=""Clean"">
-                      <Message Text=""simpleProject.Clean""/>
+                  <Target Name="Clean">
+                      <Message Text="simpleProject.Clean"/>
                   </Target>
-                  <Target Name=""Custom"">
-                      <Message Text=""simpleProject.Custom""/>
+                  <Target Name="Custom">
+                      <Message Text="simpleProject.Custom"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.6.30114.105
-MinimumVisualStudioVersion = 10.0.40219.1
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
-EndProject
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|x86 = Debug|x86
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
-		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
-		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
-		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
-	EndGlobalSection
-EndGlobal
-                ");
+                    """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.6.30114.105
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "simpleProject", "simpleProject\simpleProject.csproj", "{AA52A05F-A9C0-4C89-9933-BF976A304C91}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "classlib", "classlib\classlib.csproj", "{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x86 = Debug|x86
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
+                            {AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
+                            {80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
+                            {80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
+                        EndGlobalSection
+                    EndGlobal
+                    """);
 
                 try
                 {
@@ -331,10 +370,12 @@ public void AddNewErrorWarningMessageElement()
         /// Test to make sure we properly set the ToolsVersion attribute on the in-memory project based
         /// on the Solution File Format Version.
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void EmitToolsVersionAttributeToInMemoryProject9()
+        public void EmitToolsVersionAttributeToInMemoryProject9(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV35 == null)
             {
@@ -343,7 +384,7 @@ public void EmitToolsVersionAttributeToInMemoryProject9()
             }
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -353,23 +394,29 @@ public void EmitToolsVersionAttributeToInMemoryProject9()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal("3.5", instances[0].ToolsVersion);
+                Assert.Equal("3.5", instances[0].ToolsVersion);
+            }
         }
 
         /// <summary>
         /// Test to make sure we properly set the ToolsVersion attribute on the in-memory project based
         /// on the Solution File Format Version.
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void EmitToolsVersionAttributeToInMemoryProject10()
+        public void EmitToolsVersionAttributeToInMemoryProject10(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV35 == null)
             {
@@ -378,7 +425,7 @@ public void EmitToolsVersionAttributeToInMemoryProject10()
             }
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 10.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -388,13 +435,17 @@ public void EmitToolsVersionAttributeToInMemoryProject10()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal("3.5", instances[0].ToolsVersion);
+                Assert.Equal("3.5", instances[0].ToolsVersion);
+            }
         }
 
         /// <summary>
@@ -407,7 +458,7 @@ public void DefaultSubToolsetIfSolutionVersionSubToolsetDoesntExist()
             Environment.SetEnvironmentVariable("VisualStudioVersion", null);
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 10.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -417,9 +468,9 @@ public void DefaultSubToolsetIfSolutionVersionSubToolsetDoesntExist()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
 
@@ -443,13 +494,15 @@ public void DefaultSubToolsetIfSolutionVersionSubToolsetDoesntExist()
         /// Test to make sure that if the solution version corresponds to an existing sub-toolset version,
         /// barring other factors that might override, the sub-toolset will be based on the solution version.
         /// </summary>
-        [Fact]
-        public void SubToolsetSetBySolutionVersion()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SubToolsetSetBySolutionVersion(bool useNewParser)
         {
             Environment.SetEnvironmentVariable("VisualStudioVersion", null);
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 12.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -459,32 +512,38 @@ public void SubToolsetSetBySolutionVersion()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
+                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
 
-            // being cautious -- we can't expect the sub-toolset to be picked if it doesn't exist in the first place
-            if (instances[0].Toolset.SubToolsets.ContainsKey("11.0"))
-            {
-                Assert.Equal("11.0", instances[0].SubToolsetVersion);
-                Assert.Equal("11.0", instances[0].GetPropertyValue("VisualStudioVersion"));
+                // being cautious -- we can't expect the sub-toolset to be picked if it doesn't exist in the first place
+                if (instances[0].Toolset.SubToolsets.ContainsKey("11.0"))
+                {
+                    Assert.Equal("11.0", instances[0].SubToolsetVersion);
+                    Assert.Equal("11.0", instances[0].GetPropertyValue("VisualStudioVersion"));
+                }
             }
         }
 
         /// <summary>
         /// Test to make sure that even if the solution version corresponds to an existing sub-toolset version,
         /// </summary>
-        [Fact]
-        public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionBasedSubToolsetVersionOverriddenByEnvironment(bool useNewParser)
         {
             Environment.SetEnvironmentVariable("VisualStudioVersion", "ABC");
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 12.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -494,15 +553,19 @@ public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
-            Assert.Equal("ABC", instances[0].SubToolsetVersion);
-            Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
+                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
+                Assert.Equal("ABC", instances[0].SubToolsetVersion);
+                Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
+            }
         }
 
         /// <summary>
@@ -719,44 +782,45 @@ public void SolutionDoesntPassSubToolsetToChildProjects()
         /// Verify that we throw the appropriate error if the solution declares a dependency
         /// on a project that doesn't exist.
         /// </summary>
+        /// <remarks>This test would only work for the old parser. In the new parser the dependency is not added if it was not in the solution file.</remarks>
         [Fact]
         public void SolutionWithMissingDependencies()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
             {
                 string solutionFileContents =
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 11
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `B`, `Project2\B.csproj`, `{881C1674-4ECA-451D-85B6-D7C59B7F16FA}`
-    ProjectSection(ProjectDependencies) = postProject
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
-    EndProjectSection
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-        Debug|x64 = Debug|x64
-        Release|Any CPU = Release|Any CPU
-        Release|x64 = Release|x64
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = preSolution
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.Build.0 = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.ActiveCfg = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.Build.0 = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-".Replace("`", "\"");
+                    """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio 11
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "B", "Project2\B.csproj", "{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
+                        EndProjectSection
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Any CPU = Debug|Any CPU
+                            Debug|x64 = Debug|x64
+                            Release|Any CPU = Release|Any CPU
+                            Release|x64 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = preSolution
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.ActiveCfg = Debug|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.Build.0 = Debug|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.ActiveCfg = Release|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
 
-                SolutionFile sp = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+                SolutionFile sp = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
                 ProjectInstance[] instances = SolutionProjectGenerator.Generate(sp, null, null, _buildEventContext, CreateMockLoggingService());
             });
         }
@@ -764,62 +828,64 @@ public void SolutionWithMissingDependencies()
         /// Blob should contain dependency info
         /// Here B depends on C
         /// </summary>
-        [Fact]
-        public void SolutionConfigurationWithDependencies()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionConfigurationWithDependencies(bool useNewParser)
         {
             string solutionFileContents =
-                @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 11
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `A`, `Project1\A.csproj`, `{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}`
-EndProject
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `B`, `Project2\B.csproj`, `{881C1674-4ECA-451D-85B6-D7C59B7F16FA}`
-    ProjectSection(ProjectDependencies) = postProject
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
-    EndProjectSection
-EndProject
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `C`, `Project3\C.csproj`, `{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}`
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-        Debug|x64 = Debug|x64
-        Release|Any CPU = Release|Any CPU
-        Release|x64 = Release|x64
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = preSolution
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|x64.ActiveCfg = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|x64.Build.0 = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|Any CPU.Build.0 = Release|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|x64.ActiveCfg = Release|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|x64.Build.0 = Release|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|x64.ActiveCfg = Debug|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|x64.Build.0 = Debug|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|Any CPU.Build.0 = Release|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|x64.ActiveCfg = Release|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|x64.Build.0 = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.Build.0 = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.ActiveCfg = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.Build.0 = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-".Replace("`", "\"");
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 11
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "A", "Project1\A.csproj", "{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}"
+                EndProject
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "B", "Project2\B.csproj", "{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"
+                    ProjectSection(ProjectDependencies) = postProject
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
+                    EndProjectSection
+                EndProject
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "C", "Project3\C.csproj", "{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Debug|x64 = Debug|x64
+                        Release|Any CPU = Release|Any CPU
+                        Release|x64 = Release|x64
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = preSolution
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|x64.ActiveCfg = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|x64.Build.0 = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|x64.ActiveCfg = Release|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|x64.Build.0 = Release|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|x64.ActiveCfg = Debug|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|x64.Build.0 = Debug|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|x64.ActiveCfg = Release|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|x64.Build.0 = Release|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.ActiveCfg = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.Build.0 = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.ActiveCfg = Release|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectRootElement projectXml = ProjectRootElement.Create();
 
@@ -838,11 +904,14 @@ public void SolutionConfigurationWithDependencies()
             string solutionConfigurationContents = msbuildProject.GetPropertyValue("CurrentSolutionConfigurationContents");
 
             // Only the specified solution configuration is represented in THE BLOB: nothing for x64 in this case
-            string expected = $@"<SolutionConfiguration>
-  <ProjectConfiguration Project=`{{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}}` AbsolutePath=`##temp##{Path.Combine("Project1", "A.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
-  <ProjectConfiguration Project=`{{881C1674-4ECA-451D-85B6-D7C59B7F16FA}}` AbsolutePath=`##temp##{Path.Combine("Project2", "B.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU<ProjectDependency Project=`{{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}}` /></ProjectConfiguration>
-  <ProjectConfiguration Project=`{{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}}` AbsolutePath=`##temp##{Path.Combine("Project3", "C.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
-</SolutionConfiguration>".Replace("`", "\"").Replace("##temp##", FileUtilities.TempFileDirectory);
+            string expected =
+                $$"""
+                <SolutionConfiguration>
+                  <ProjectConfiguration Project="{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}" AbsolutePath="##temp##{{Path.Combine("Project1", "A.csproj")}}" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
+                  <ProjectConfiguration Project="{881C1674-4ECA-451D-85B6-D7C59B7F16FA}" AbsolutePath="##temp##{{Path.Combine("Project2", "B.csproj")}}" BuildProjectInSolution="True">Debug|AnyCPU<ProjectDependency Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" /></ProjectConfiguration>
+                  <ProjectConfiguration Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" AbsolutePath="##temp##{{Path.Combine("Project3", "C.csproj")}}" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
+                </SolutionConfiguration>
+                """.Replace("##temp##", FileUtilities.TempFileDirectory);
 
             Helpers.VerifyAssertLineByLine(expected, solutionConfigurationContents);
         }
@@ -860,19 +929,19 @@ public void SolutionGeneratingMetaproj()
                 TransientTestFile proj2 = env.CreateFile("B.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
                 TransientTestFile proj3 = env.CreateFile("C.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
                 TransientTestFile proj = env.CreateFile("mysln.sln",
-                @$"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 11
-Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `A`, `{proj1.Path}`, `{"{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}"}`
-EndProject
-Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `B`, `{proj2.Path}`, `{"{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"}`
-    ProjectSection(ProjectDependencies) = postProject
-        {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"} = {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}
-    EndProjectSection
-EndProject
-Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `C`, `{proj3.Path}`, `{"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}`
-EndProject
-".Replace("`", "\""));
+                    $$"""
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio 11
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "A", "{{proj1.Path}}", "{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "B", "{{proj2.Path}}", "{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"} = {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}
+                        EndProjectSection
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "C", "{{proj3.Path}}", "{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"
+                    EndProject
+                    """);
                 RunnerUtilities.ExecMSBuild("\"" + proj.Path + "\"", out bool successfulExit);
                 successfulExit.ShouldBeTrue();
             }
@@ -890,37 +959,37 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
         {
             #region Large strings representing solution & projects
             const string solutionFileContents =
-                @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 11
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `B`, `B.csproj`, `{881C1674-4ECA-451D-85B6-D7C59B7F16FA}`
-    ProjectSection(ProjectDependencies) = postProject
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
-    EndProjectSection
-EndProject
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `C`, `C.csproj`, `{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}`
-EndProject
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `D`, `D.csproj`, `{B6E7E06F-FC0B-48F1-911A-55E0E1566F00}`
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = preSolution
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {B6E7E06F-FC0B-48F1-911A-55E0E1566F00}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {B6E7E06F-FC0B-48F1-911A-55E0E1566F00}.Debug|Any CPU.Build.0 = Debug|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-";
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 11
+                Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `B`, `B.csproj`, `{881C1674-4ECA-451D-85B6-D7C59B7F16FA}`
+                    ProjectSection(ProjectDependencies) = postProject
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
+                    EndProjectSection
+                EndProject
+                Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `C`, `C.csproj`, `{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}`
+                EndProject
+                Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `D`, `D.csproj`, `{B6E7E06F-FC0B-48F1-911A-55E0E1566F00}`
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = preSolution
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {B6E7E06F-FC0B-48F1-911A-55E0E1566F00}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {B6E7E06F-FC0B-48F1-911A-55E0E1566F00}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
             const string projectBravoFileContents =
-                    @"
+                    """
                         <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                             <Target Name='Build' Outputs='@(ComputedQuestion)'>
                                 <ItemGroup>
@@ -934,9 +1003,9 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
                                 </ProjectReference>
                             </ItemGroup>
                         </Project>
-                    ";
+                    """;
             const string projectCharlieFileContents =
-                    @"
+                    """
                         <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                             <Target Name='Build' Outputs='@(ComputedAnswer)'>
                                 <ItemGroup>
@@ -944,9 +1013,9 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
                                 </ItemGroup>
                             </Target>
                         </Project>
-                    ";
+                    """;
             const string projectDeltaFileContents =
-                    @"
+                    """
                         <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                             <PropertyGroup>
                                 <ProjectGuid>{B6E7E06F-FC0B-48F1-911A-55E0E1566F00}</ProjectGuid>
@@ -957,60 +1026,62 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
                                 </ItemGroup>
                             </Target>
                         </Project>
-                    ";
-            const string automaticProjectFileContents = @"
-<Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='compile' xmlns='msbuildnamespace'>
-    <Target Name='compile'>
-        <!-- Build projects to get a baseline for their output -->
-        <MSBuild Projects='B.csproj' Targets='Build'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='BravoProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='BravoProjectOutputs: @(BravoProjectOutputs)' />
-
-        <MSBuild Projects='C.csproj' Targets='Build'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='CharlieProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='CharlieProjectOutputs: @(CharlieProjectOutputs)' />
-
-        <MSBuild Projects='D.csproj' Targets='Build'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='DeltaProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='DeltaProjectOutputs: @(DeltaProjectOutputs)' />
-
-        <PropertyGroup>
-            <StringifiedBravoProjectOutputs>@(BravoProjectOutputs)</StringifiedBravoProjectOutputs>
-            <StringifiedCharlieProjectOutputs>@(CharlieProjectOutputs)</StringifiedCharlieProjectOutputs>
-            <StringifiedDeltaProjectOutputs>@(DeltaProjectOutputs)</StringifiedDeltaProjectOutputs>
-        </PropertyGroup>
-
-        <!-- Explicitly build the metaproject generated for B -->
-        <MSBuild Projects='B.csproj.metaproj' Targets='Build'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='BravoMetaProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='BravoMetaProjectOutputs: @(BravoMetaProjectOutputs)' />
-        <Error Condition=` '@(BravoProjectOutputs)' != '@(BravoMetaProjectOutputs)' ` Text='Metaproj outputs must match outputs of normal project build.' />
-
-        <!-- Build the solution as a whole (which will build the metaproj and return overall outputs) -->
-        <MSBuild Projects='MSBuildIssue.sln'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='SolutionProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='SolutionProjectOutputs: @(SolutionProjectOutputs)' />
-        <Error Condition=` '@(SolutionProjectOutputs->Count())' != '3' ` Text='Overall sln outputs must include outputs of each referenced project (there should be 3).' />
-        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedBravoProjectOutputs)'))' != 'true'` Text='Overall sln outputs must include outputs of normal project build of project B.' />
-        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedCharlieProjectOutputs)'))' != 'true' ` Text='Overall sln outputs must include outputs of normal project build of project C.' />
-        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedDeltaProjectOutputs)'))' != 'true' ` Text='Overall sln outputs must include outputs of normal project build of project D.' />
-    </Target>
-</Project>";
+                    """;
+            const string automaticProjectFileContents =
+                """
+                <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='compile' xmlns='msbuildnamespace'>
+                    <Target Name='compile'>
+                        <!-- Build projects to get a baseline for their output -->
+                        <MSBuild Projects='B.csproj' Targets='Build'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='BravoProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='BravoProjectOutputs: @(BravoProjectOutputs)' />
+
+                        <MSBuild Projects='C.csproj' Targets='Build'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='CharlieProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='CharlieProjectOutputs: @(CharlieProjectOutputs)' />
+
+                        <MSBuild Projects='D.csproj' Targets='Build'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='DeltaProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='DeltaProjectOutputs: @(DeltaProjectOutputs)' />
+
+                        <PropertyGroup>
+                            <StringifiedBravoProjectOutputs>@(BravoProjectOutputs)</StringifiedBravoProjectOutputs>
+                            <StringifiedCharlieProjectOutputs>@(CharlieProjectOutputs)</StringifiedCharlieProjectOutputs>
+                            <StringifiedDeltaProjectOutputs>@(DeltaProjectOutputs)</StringifiedDeltaProjectOutputs>
+                        </PropertyGroup>
+
+                        <!-- Explicitly build the metaproject generated for B -->
+                        <MSBuild Projects='B.csproj.metaproj' Targets='Build'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='BravoMetaProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='BravoMetaProjectOutputs: @(BravoMetaProjectOutputs)' />
+                        <Error Condition=` '@(BravoProjectOutputs)' != '@(BravoMetaProjectOutputs)' ` Text='Metaproj outputs must match outputs of normal project build.' />
+
+                        <!-- Build the solution as a whole (which will build the metaproj and return overall outputs) -->
+                        <MSBuild Projects='MSBuildIssue.sln'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='SolutionProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='SolutionProjectOutputs: @(SolutionProjectOutputs)' />
+                        <Error Condition=` '@(SolutionProjectOutputs->Count())' != '3' ` Text='Overall sln outputs must include outputs of each referenced project (there should be 3).' />
+                        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedBravoProjectOutputs)'))' != 'true'` Text='Overall sln outputs must include outputs of normal project build of project B.' />
+                        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedCharlieProjectOutputs)'))' != 'true' ` Text='Overall sln outputs must include outputs of normal project build of project C.' />
+                        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedDeltaProjectOutputs)'))' != 'true' ` Text='Overall sln outputs must include outputs of normal project build of project D.' />
+                    </Target>
+                </Project>
+                """;
             #endregion
 
             var logger = new MockLogger(output);
@@ -1039,11 +1110,13 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
         /// <summary>
         /// Test the SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration method
         /// </summary>
-        [Fact]
-        public void TestAddPropertyGroupForSolutionConfiguration()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestAddPropertyGroupForSolutionConfiguration(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1063,9 +1136,9 @@ public void TestAddPropertyGroupForSolutionConfiguration()
                         {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|Mixed Platforms.Build.0 = VCConfig1|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectRootElement projectXml = ProjectRootElement.Create();
 
@@ -1112,11 +1185,13 @@ public void TestAddPropertyGroupForSolutionConfiguration()
         /// <summary>
         /// Make sure that BuildProjectInSolution is set to true of the Build.0 entry is in the solution configuration.
         /// </summary>
-        [Fact]
-        public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionSet()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionSet(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1131,9 +1206,9 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionSe
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.Build.0 = CSConfig1|Any CPU
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectRootElement projectXml = ProjectRootElement.Create();
 
@@ -1156,11 +1231,13 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionSe
         /// <summary>
         /// Make sure that BuildProjectInSolution is set to false of the Build.0 entry is in the solution configuration.
         /// </summary>
-        [Fact]
-        public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNotSet()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNotSet(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1174,9 +1251,9 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNo
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.ActiveCfg = CSConfig1|Any CPU
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectRootElement projectXml = ProjectRootElement.Create();
 
@@ -1200,10 +1277,12 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNo
         /// In this bug, SkipNonexistentProjects was always set to 'Build'. It should be 'Build' for metaprojects and 'True' for everything else.
         /// The repro below has one of each case. WebProjects can't build so they are set as SkipNonexistentProjects='Build'
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void Regress751742_SkipNonexistentProjects()
+        public void Regress751742_SkipNonexistentProjects(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1212,7 +1291,7 @@ public void Regress751742_SkipNonexistentProjects()
             }
 
             var solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1232,39 +1311,43 @@ public void Regress751742_SkipNonexistentProjects()
                         {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|Mixed Platforms.Build.0 = VCConfig1|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            var solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            var instance = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService())[0];
+                var instance = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService())[0];
 
-            foreach (ITaskItem item in instance.Items)
-            {
-                string skipNonexistentProjects = item.GetMetadata("SkipNonexistentProjects");
-                if (item.ItemSpec.EndsWith("ClassLibrary1.csproj"))
-                {
-                    Assert.Equal("False", skipNonexistentProjects);
-                }
-                else if (item.ItemSpec.EndsWith("MainApp.metaproj"))
-                {
-                    Assert.Equal("Build", skipNonexistentProjects);
-                }
-                else if (item.ItemSpec == "Debug|Mixed Platforms")
-                {
-                    Assert.Equal("Debug", item.GetMetadata("Configuration"));
-                    Assert.Equal("Mixed Platforms", item.GetMetadata("Platform"));
-                    Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
-                }
-                else if (item.ItemSpec == "Release|Any CPU")
-                {
-                    Assert.Equal("Release", item.GetMetadata("Configuration"));
-                    Assert.Equal("Any CPU", item.GetMetadata("Platform"));
-                    Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
-                }
-                else
+                foreach (ITaskItem item in instance.Items)
                 {
-                    Assert.Fail("Unexpected project seen:" + item.ItemSpec);
+                    string skipNonexistentProjects = item.GetMetadata("SkipNonexistentProjects");
+                    if (item.ItemSpec.EndsWith("ClassLibrary1.csproj"))
+                    {
+                        Assert.Equal("False", skipNonexistentProjects);
+                    }
+                    else if (item.ItemSpec.EndsWith("MainApp.metaproj"))
+                    {
+                        Assert.Equal("Build", skipNonexistentProjects);
+                    }
+                    else if (item.ItemSpec == "Debug|Mixed Platforms")
+                    {
+                        Assert.Equal("Debug", item.GetMetadata("Configuration"));
+                        Assert.Equal("Mixed Platforms", item.GetMetadata("Platform"));
+                        Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
+                    }
+                    else if (item.ItemSpec == "Release|Any CPU")
+                    {
+                        Assert.Equal("Release", item.GetMetadata("Configuration"));
+                        Assert.Equal("Any CPU", item.GetMetadata("Platform"));
+                        Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
+                    }
+                    else
+                    {
+                        Assert.Fail("Unexpected project seen:" + item.ItemSpec);
+                    }
                 }
             }
         }
@@ -1274,11 +1357,13 @@ public void Regress751742_SkipNonexistentProjects()
         /// if set when building a solution, will be specified as the ToolsVersion on the MSBuild task when
         /// building the projects contained within the solution.
         /// </summary>
-        [Fact]
-        public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1298,41 +1383,45 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
                         {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|Mixed Platforms.Build.0 = VCConfig1|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService());
 
-            int i = 0;
-            foreach (ProjectInstance instance in instances)
-            {
-                if (i == 0)
+                int i = 0;
+                foreach (ProjectInstance instance in instances)
                 {
-                    continue;
-                }
+                    if (i == 0)
+                    {
+                        continue;
+                    }
 
-                foreach (ProjectTargetInstance target in instance.Targets.Values)
-                {
-                    foreach (ProjectTaskInstance childNode in target.Tasks)
+                    foreach (ProjectTargetInstance target in instance.Targets.Values)
                     {
-                        if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                        foreach (ProjectTaskInstance childNode in target.Tasks)
                         {
-                            string projectsParameter = childNode.GetParameter("Projects");
-                            if (projectsParameter != "@(ProjectReference)")
+                            if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
                             {
-                                // we found an MSBuild task invocation, now let's verify that it has the correct
-                                // ToolsVersion parameter set
-                                string toolsVersionParameter = childNode.GetParameter("ToolsVersion");
-
-                                Assert.Equal(toolsVersionParameter, instances[0].GetPropertyValue("ProjectToolsVersion"));
+                                string projectsParameter = childNode.GetParameter("Projects");
+                                if (projectsParameter != "@(ProjectReference)")
+                                {
+                                    // we found an MSBuild task invocation, now let's verify that it has the correct
+                                    // ToolsVersion parameter set
+                                    string toolsVersionParameter = childNode.GetParameter("ToolsVersion");
+
+                                    Assert.Equal(toolsVersionParameter, instances[0].GetPropertyValue("ProjectToolsVersion"));
+                                }
                             }
                         }
                     }
-                }
 
-                i++;
+                    i++;
+                }
             }
         }
 
@@ -1340,68 +1429,74 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
         /// <summary>
         /// Make sure that whatever the solution ToolsVersion is, it gets mapped to all its metaprojs, too.
         /// </summary>
-        [Fact]
-        public void SolutionWithDependenciesHasCorrectToolsVersionInMetaprojs()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionWithDependenciesHasCorrectToolsVersionInMetaprojs(bool useNewParser)
         {
             string solutionFileContents =
-                @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ConsoleApplication2', 'ConsoleApplication2\ConsoleApplication2.csproj', '{5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}'
-    ProjectSection(ProjectDependencies) = postProject
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C} = {E0D295A1-CAFA-4E68-9929-468657DAAC6C}
-    EndProjectSection
-EndProject
-Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{E0D295A1-CAFA-4E68-9929-468657DAAC6C}'
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-        Release|Any CPU = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Release|Any CPU.Build.0 = Release|Any CPU
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Release|Any CPU.Build.0 = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-                ";
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ConsoleApplication2', 'ConsoleApplication2\ConsoleApplication2.csproj', '{5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}'
+                    ProjectSection(ProjectDependencies) = postProject
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C} = {E0D295A1-CAFA-4E68-9929-468657DAAC6C}
+                    EndProjectSection
+                EndProject
+                Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{E0D295A1-CAFA-4E68-9929-468657DAAC6C}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            string[] solutionToolsVersions = { "4.0", ObjectModelHelpers.MSBuildDefaultToolsVersion };
+                string[] solutionToolsVersions = { "4.0", ObjectModelHelpers.MSBuildDefaultToolsVersion };
 
-            foreach (string solutionToolsVersion in solutionToolsVersions)
-            {
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, solutionToolsVersion, _buildEventContext, CreateMockLoggingService());
+                foreach (string solutionToolsVersion in solutionToolsVersions)
+                {
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, solutionToolsVersion, _buildEventContext, CreateMockLoggingService());
 
-                Assert.Equal(2, instances.Length);
+                    Assert.Equal(2, instances.Length);
 
-                // Solution metaproj
-                Assert.Equal(solutionToolsVersion, instances[0].ToolsVersion);
+                    // Solution metaproj
+                    Assert.Equal(solutionToolsVersion, instances[0].ToolsVersion);
 
-                ICollection<ProjectItemInstance> projectReferences = instances[0].GetItems("ProjectReference");
+                    ICollection<ProjectItemInstance> projectReferences = instances[0].GetItems("ProjectReference");
 
-                foreach (ProjectItemInstance projectReference in projectReferences)
-                {
-                    // If this is the reference to the metaproj, its ToolsVersion metadata needs to match
-                    // the solution ToolsVersion -- that's how the build knows which ToolsVersion to use.
-                    if (projectReference.EvaluatedInclude.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase))
+                    foreach (ProjectItemInstance projectReference in projectReferences)
                     {
-                        Assert.Equal(solutionToolsVersion, projectReference.GetMetadataValue("ToolsVersion"));
+                        // If this is the reference to the metaproj, its ToolsVersion metadata needs to match
+                        // the solution ToolsVersion -- that's how the build knows which ToolsVersion to use.
+                        if (projectReference.EvaluatedInclude.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase))
+                        {
+                            Assert.Equal(solutionToolsVersion, projectReference.GetMetadataValue("ToolsVersion"));
+                        }
                     }
-                }
 
-                // Project metaproj for project with dependencies
-                Assert.Equal(solutionToolsVersion, instances[1].ToolsVersion);
+                    // Project metaproj for project with dependencies
+                    Assert.Equal(solutionToolsVersion, instances[1].ToolsVersion);
+                }
             }
         }
 #endif
@@ -1409,11 +1504,13 @@ public void SolutionWithDependenciesHasCorrectToolsVersionInMetaprojs()
         /// <summary>
         /// Test the SolutionProjectGenerator.Generate method has its toolset redirected correctly.
         /// </summary>
-        [Fact]
-        public void ToolsVersionOverrideCausesToolsetRedirect()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ToolsVersionOverrideCausesToolsetRedirect(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1433,8 +1530,10 @@ public void ToolsVersionOverrideCausesToolsetRedirect()
                         {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|Mixed Platforms.Build.0 = VCConfig1|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+                """;
+
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
             bool caughtException = false;
 
             try
@@ -1454,11 +1553,13 @@ public void ToolsVersionOverrideCausesToolsetRedirect()
         /// <summary>
         /// Test the SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration method
         /// </summary>
-        [Fact]
-        public void TestDisambiguateProjectTargetName()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestDisambiguateProjectTargetName(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Build', 'Build\Build.csproj', '{21397922-C38F-4A0E-B950-77B3FBD51881}'
@@ -1478,55 +1579,59 @@ public void TestDisambiguateProjectTargetName()
                                 HideSolutionNode = FALSE
                         EndGlobalSection
                 EndGlobal
-                ";
-
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
-
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
-
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
-
-            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
-
-            // Check that the appropriate target is being passed to the child projects
-            Assert.Null(buildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
+                """;
 
-            Assert.Equal("Clean", cleanTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            Assert.Equal("Rebuild", rebuildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            Assert.Equal("Publish", publishTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            // Check that the child projects in question are the members of the "ProjectReference" item group
-            Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
-
-            Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
+
+                ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
+
+                // Check that the appropriate target is being passed to the child projects
+                Assert.Null(buildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Clean", cleanTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Rebuild", rebuildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Publish", publishTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                // Check that the child projects in question are the members of the "ProjectReference" item group
+                Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+            }
 
             // We should have only the four standard targets plus the two validation targets (ValidateSolutionConfiguration and ValidateToolsVersions).
         }
@@ -1534,11 +1639,13 @@ public void TestDisambiguateProjectTargetName()
         /// <summary>
         /// Tests the algorithm for choosing default configuration/platform values for solutions
         /// </summary>
+        /// <remarks>This test would only work for the old parser. In the new parser SolutionConfigurations are not available,
+        /// and constructed from projects configurations.</remarks>
         [Fact]
         public void TestConfigurationPlatformDefaults1()
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -1550,9 +1657,9 @@ public void TestConfigurationPlatformDefaults1()
                         Release|Win32 = Release|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
 
             // These used to exist on the engine, but now need to be passed in explicitly
             IDictionary<string, string> globalProperties = new Dictionary<string, string>();
@@ -1572,11 +1679,13 @@ public void TestConfigurationPlatformDefaults1()
         /// <summary>
         /// Tests the algorithm for choosing default configuration/platform values for solutions
         /// </summary>
+        /// <remarks>This test would only work for the old parser. In the new parser SolutionConfigurations are not available,
+        /// and constructed from projects configurations.</remarks>
         [Fact]
         public void TestConfigurationPlatformDefaults2()
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -1586,9 +1695,9 @@ public void TestConfigurationPlatformDefaults2()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
@@ -1602,10 +1711,12 @@ public void TestConfigurationPlatformDefaults2()
         /// <summary>
         /// Tests the algorithm for choosing default Venus configuration values for solutions
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestVenusConfigurationDefaults()
+        public void TestVenusConfigurationDefaults(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1615,13 +1726,13 @@ public void TestVenusConfigurationDefaults()
 
             Dictionary<string, string> globalProperties = new Dictionary<string, string>();
             globalProperties["Configuration"] = "Debug";
-            ProjectInstance msbuildProject = CreateVenusSolutionProject(globalProperties);
+            ProjectInstance msbuildProject = CreateVenusSolutionProject(globalProperties, useNewParser);
 
             // ASP.NET configuration should match the selected solution configuration
             Assert.Equal("Debug", msbuildProject.GetPropertyValue("AspNetConfiguration"));
 
             globalProperties["Configuration"] = "Release";
-            msbuildProject = CreateVenusSolutionProject(globalProperties);
+            msbuildProject = CreateVenusSolutionProject(globalProperties, useNewParser);
             Assert.Equal("Release", msbuildProject.GetPropertyValue("AspNetConfiguration"));
 
             // Check that the two standard Asp.net configurations are represented on the targets
@@ -1632,10 +1743,12 @@ public void TestVenusConfigurationDefaults()
         /// <summary>
         /// Tests that the correct value for TargetFrameworkVersion gets set when creating Venus solutions
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void VenusSolutionDefaultTargetFrameworkVersion()
+        public void VenusSolutionDefaultTargetFrameworkVersion(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1644,7 +1757,7 @@ public void VenusSolutionDefaultTargetFrameworkVersion()
             }
 
             // v4.0 by default
-            ProjectInstance msbuildProject = CreateVenusSolutionProject();
+            ProjectInstance msbuildProject = CreateVenusSolutionProject(useNewParser);
             Assert.Equal("v4.0", msbuildProject.GetPropertyValue("TargetFrameworkVersion"));
 
             if (FrameworkLocationHelper.PathToDotNetFrameworkV35 == null)
@@ -1654,34 +1767,36 @@ public void VenusSolutionDefaultTargetFrameworkVersion()
             }
 
             // v3.5 if MSBuildToolsVersion is 3.5
-            msbuildProject = CreateVenusSolutionProject("3.5");
+            msbuildProject = CreateVenusSolutionProject("3.5", useNewParser);
             Assert.Equal("v3.5", msbuildProject.GetPropertyValue("TargetFrameworkVersion"));
 
             // v2.0 if MSBuildToolsVersion is 2.0
-            msbuildProject = CreateVenusSolutionProject("2.0");
+            msbuildProject = CreateVenusSolutionProject("2.0", useNewParser);
             Assert.Equal("v2.0", msbuildProject.GetPropertyValue("TargetFrameworkVersion"));
 
             // may be user defined
             IDictionary<string, string> globalProperties = new Dictionary<string, string>();
             globalProperties.Add("TargetFrameworkVersion", "userdefined");
-            msbuildProject = CreateVenusSolutionProject(globalProperties);
+            msbuildProject = CreateVenusSolutionProject(globalProperties, useNewParser);
             Assert.Equal("userdefined", msbuildProject.GetPropertyValue("TargetFrameworkVersion"));
         }
 
         /// <summary>
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestTargetFrameworkPaths0()
+        public void TestTargetFrameworkPaths0(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkSdkV20 != null)
             {
                 IDictionary<string, string> globalProperties = new Dictionary<string, string>();
                 globalProperties.Add("TargetFrameworkVersion", "v2.0");
 
-                ProjectInstance msbuildProject = CreateVenusSolutionProject("2.0");
+                ProjectInstance msbuildProject = CreateVenusSolutionProject("2.0", useNewParser);
 
                 // ToolsVersion is 2.0, TargetFrameworkVersion is v2.0 --> one item pointing to v2.0
                 Assert.Equal("2.0", msbuildProject.ToolsVersion);
@@ -1696,10 +1811,12 @@ public void TestTargetFrameworkPaths0()
         /// <summary>
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestTargetFrameworkPaths1()
+        public void TestTargetFrameworkPaths1(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1707,7 +1824,7 @@ public void TestTargetFrameworkPaths1()
                 return;
             }
 
-            ProjectInstance msbuildProject = CreateVenusSolutionProject();
+            ProjectInstance msbuildProject = CreateVenusSolutionProject(useNewParser);
 
             // ToolsVersion is 4.0, TargetFrameworkVersion is v2.0 --> one item pointing to v2.0
             msbuildProject.SetProperty("TargetFrameworkVersion", "v2.0");
@@ -1722,10 +1839,12 @@ public void TestTargetFrameworkPaths1()
         /// <summary>
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestTargetFrameworkPaths2()
+        public void TestTargetFrameworkPaths2(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1733,7 +1852,7 @@ public void TestTargetFrameworkPaths2()
                 return;
             }
 
-            ProjectInstance msbuildProject = CreateVenusSolutionProject();
+            ProjectInstance msbuildProject = CreateVenusSolutionProject(useNewParser);
 
             // ToolsVersion is 4.0, TargetFrameworkVersion is v4.0 --> items for v2.0 and v4.0
             msbuildProject.SetProperty("TargetFrameworkVersion", "v4.0");
@@ -1771,11 +1890,13 @@ public void TestTargetFrameworkPaths2()
         /// <summary>
         /// Test the PredictActiveSolutionConfigurationName method
         /// </summary>
+        /// <remarks>This test would only work for the old parser.
+        /// In the new parser SolutionConfigurations are not available, and constructed from projects configurations.</remarks>
         [Fact]
         public void TestPredictSolutionConfigurationName()
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -1785,9 +1906,9 @@ public void TestPredictSolutionConfigurationName()
                         Debug|Win32 = Debug|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
 
             IDictionary<string, string> globalProperties = new Dictionary<string, string>();
 
@@ -1806,11 +1927,13 @@ public void TestPredictSolutionConfigurationName()
         /// <summary>
         /// Verifies that the SolutionProjectGenerator will correctly escape project file paths
         /// </summary>
-        [Fact]
-        public void SolutionGeneratorEscapingProjectFilePaths()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionGeneratorEscapingProjectFilePaths(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', '%abtest\ConsoleApplication1.vbproj', '{AB3413A6-D689-486D-B7F0-A095371B3F13}'
@@ -1830,27 +1953,33 @@ public void SolutionGeneratorEscapingProjectFilePaths()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
-            Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
+                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-            // Ensure that the value has been correctly stored in the ProjectReference item list
-            // Since there is only one project in the solution, there will be only one project reference
-            Assert.Contains("%abtest", instances[0].GetItems("ProjectReference").ElementAt(0).EvaluatedInclude);
+                // Ensure that the value has been correctly stored in the ProjectReference item list
+                // Since there is only one project in the solution, there will be only one project reference
+                Assert.Contains("%abtest", instances[0].GetItems("ProjectReference").ElementAt(0).EvaluatedInclude);
+            }
         }
 
         /// <summary>
         /// Verifies that the SolutionProjectGenerator will emit a solution file.
         /// </summary>
-        [Fact]
-        public void SolutionGeneratorCanEmitSolutions()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionGeneratorCanEmitSolutions(bool useNewParser)
         {
             string oldValueForMSBuildEmitSolution = Environment.GetEnvironmentVariable("MSBuildEmitSolution");
 
@@ -1858,7 +1987,7 @@ public void SolutionGeneratorCanEmitSolutions()
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{AB3413A6-D689-486D-B7F0-A095371B3F13}'
@@ -1878,7 +2007,7 @@ public void SolutionGeneratorCanEmitSolutions()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
             SolutionFile solution = null;
             using ProjectCollection collection = new ProjectCollection();
@@ -1887,12 +2016,16 @@ public void SolutionGeneratorCanEmitSolutions()
             {
                 Environment.SetEnvironmentVariable("MSBuildEmitSolution", "1");
 
-                solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-                // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
-                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                    // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
+                    Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                }
 
                 // Instantiating the
                 Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
@@ -1919,16 +2052,18 @@ public void SolutionGeneratorCanEmitSolutions()
         /// Make sure that we output a warning and don't build anything when we're given an invalid
         /// solution configuration and SkipInvalidConfigurations is set to true.
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestSkipInvalidConfigurationsCase()
+        public void TestSkipInvalidConfigurationsCase(bool useNewParser)
         {
             string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
-            string solutionContents =
-                @"
+            string solutionFileContents =
+                """
                 Microsoft Visual Studio Solution File, Format Version 11.00
                 # Visual Studio 2005
                 Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'C:\solutions\WebSite2\', '..\..\solutions\WebSite2\', '{F90528C4-6989-4D33-AFE8-F53173597CC2}'
@@ -1959,7 +2094,8 @@ public void TestSkipInvalidConfigurationsCase()
                         {F90528C4-6989-4D33-AFE8-F53173597CC2}.Debug|Any CPU.ActiveCfg = Debug|.NET
                         {F90528C4-6989-4D33-AFE8-F53173597CC2}.Debug|Any CPU.Build.0 = Debug|.NET
                     EndGlobalSection
-                EndGlobal";
+                EndGlobal
+                """;
 
             try
             {
@@ -1969,12 +2105,16 @@ public void TestSkipInvalidConfigurationsCase()
                 globalProperties["Configuration"] = "Nonexistent";
                 globalProperties["SkipInvalidConfigurations"] = "true";
 
-                SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionContents.Replace('\'', '"'));
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService());
-                ProjectInstance msbuildProject = instances[0];
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                    ProjectInstance msbuildProject = instances[0];
 
-                // Build should complete successfully even with an invalid solution config if SkipInvalidConfigurations is true
-                Assert.True(msbuildProject.Build(new ILogger[] { logger }));
+                    // Build should complete successfully even with an invalid solution config if SkipInvalidConfigurations is true
+                    Assert.True(msbuildProject.Build(new ILogger[] { logger }));
+                }
 
                 // We should get the invalid solution configuration warning
                 Assert.Single(logger.Warnings);
@@ -2173,50 +2313,52 @@ public void BadFrameworkMonkierExpectBuildToFail2()
         /// Bug indicated that when a target framework version greater than 4.0 was used then the solution project generator would crash.
         /// this test is to make sure the fix is not regressed.
         /// </summary>
-        [Fact]
-        public void TestTargetFrameworkVersionGreaterThan4()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestTargetFrameworkVersionGreaterThan4(bool useNewParser)
         {
             string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionFileContents =
-               @"
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual Studio 2010
-Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'WebSite1', '..\WebSite1\', '{6B8F98F2-C976-4029-9321-5CCD73A174DA}'
-    ProjectSection(WebsiteProperties) = preProject
-        TargetFrameworkMoniker = '.NETFramework,Version=v4.34'
-        Debug.AspNetCompiler.VirtualPath = '/WebSite1'
-        Debug.AspNetCompiler.PhysicalPath = '..\WebSite1\'
-        Debug.AspNetCompiler.TargetPath = 'PrecompiledWeb\WebSite1\'
-        Debug.AspNetCompiler.Updateable = 'true'
-        Debug.AspNetCompiler.ForceOverwrite = 'true'
-        Debug.AspNetCompiler.FixedNames = 'false'
-        Debug.AspNetCompiler.Debug = 'True'
-        Release.AspNetCompiler.VirtualPath = '/WebSite1'
-        Release.AspNetCompiler.PhysicalPath = '..\WebSite1\'
-        Release.AspNetCompiler.TargetPath = 'PrecompiledWeb\WebSite1\'
-        Release.AspNetCompiler.Updateable = 'true'
-        Release.AspNetCompiler.ForceOverwrite = 'true'
-        Release.AspNetCompiler.FixedNames = 'false'
-        Release.AspNetCompiler.Debug = 'False'
-        VWDPort = '45602'
-        DefaultWebSiteLanguage = 'Visual Basic'
-    EndProjectSection
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-        {6B8F98F2-C976-4029-9321-5CCD73A174DA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {6B8F98F2-C976-4029-9321-5CCD73A174DA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-                ";
+               """
+                Microsoft Visual Studio Solution File, Format Version 11.00
+                # Visual Studio 2010
+                Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'WebSite1', '..\WebSite1\', '{6B8F98F2-C976-4029-9321-5CCD73A174DA}'
+                    ProjectSection(WebsiteProperties) = preProject
+                        TargetFrameworkMoniker = '.NETFramework,Version=v4.34'
+                        Debug.AspNetCompiler.VirtualPath = '/WebSite1'
+                        Debug.AspNetCompiler.PhysicalPath = '..\WebSite1\'
+                        Debug.AspNetCompiler.TargetPath = 'PrecompiledWeb\WebSite1\'
+                        Debug.AspNetCompiler.Updateable = 'true'
+                        Debug.AspNetCompiler.ForceOverwrite = 'true'
+                        Debug.AspNetCompiler.FixedNames = 'false'
+                        Debug.AspNetCompiler.Debug = 'True'
+                        Release.AspNetCompiler.VirtualPath = '/WebSite1'
+                        Release.AspNetCompiler.PhysicalPath = '..\WebSite1\'
+                        Release.AspNetCompiler.TargetPath = 'PrecompiledWeb\WebSite1\'
+                        Release.AspNetCompiler.Updateable = 'true'
+                        Release.AspNetCompiler.ForceOverwrite = 'true'
+                        Release.AspNetCompiler.FixedNames = 'false'
+                        Release.AspNetCompiler.Debug = 'False'
+                        VWDPort = '45602'
+                        DefaultWebSiteLanguage = 'Visual Basic'
+                    EndProjectSection
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6B8F98F2-C976-4029-9321-5CCD73A174DA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6B8F98F2-C976-4029-9321-5CCD73A174DA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
 
             try
             {
@@ -2226,18 +2368,22 @@ public void TestTargetFrameworkVersionGreaterThan4()
                 globalProperties["Configuration"] = "Release";
                 globalProperties["SkipInvalidConfigurations"] = "true";
 
-                SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents.Replace('\'', '"'));
-                using ProjectCollection collection = new ProjectCollection();
-                collection.RegisterLogger(logger);
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
+
+                    using ProjectCollection collection = new ProjectCollection();
+                    collection.RegisterLogger(logger);
 
 #pragma warning disable format
 #if !FEATURE_ASPNET_COMPILER
-                Assert.Throws<InvalidProjectFileException>(() =>
-                {
+                    Assert.Throws<InvalidProjectFileException>(() =>
+                    {
 #endif
-                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, collection.LoggingService);
+                        ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, collection.LoggingService);
 #if !FEATURE_ASPNET_COMPILER
-                });
+                    });
 #endif
 #pragma warning restore format
 
@@ -2246,6 +2392,7 @@ public void TestTargetFrameworkVersionGreaterThan4()
                 string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("AspNetCompiler.TargetingHigherFrameworksDefaultsTo40", solution.ProjectsInOrder[0].ProjectName, ver.ToString());
                 logger.AssertLogContains(message);
 #endif
+                }
             }
             finally
             {
@@ -2256,14 +2403,16 @@ public void TestTargetFrameworkVersionGreaterThan4()
         /// <summary>
         /// Verifies that when target names are specified they end up in the metaproj.
         /// </summary>
-        [Fact]
-        public void CustomTargetNamesAreInInMetaproj()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void CustomTargetNamesAreInInMetaproj(bool useNewParser)
         {
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(
-            @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -2275,43 +2424,51 @@ public void CustomTargetNamesAreInInMetaproj()
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = CSConfig2|Any CPU
                     EndGlobalSection
                 EndGlobal
-            ");
+                """;
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
+        
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
+            }
         }
 
         /// <summary>
         /// Verifies that disambiguated target names are used when a project name matches a standard solution entry point.
         /// </summary>
-        [Fact]
-        public void DisambiguatedTargetNamesAreInInMetaproj()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void DisambiguatedTargetNamesAreInMetaproj(bool useNewParser)
         {
-            foreach(string projectName in ProjectInSolution.projectNamesToDisambiguate)
+            foreach (string projectName in ProjectInSolution.projectNamesToDisambiguate)
             {
-                SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(
-                $$"""
-                    Microsoft Visual Studio Solution File, Format Version 14.00
+                string solutionFileContents =
+                    $$"""
+                    Microsoft Visual Studio Solution File, Format Version 12.00
                     # Visual Studio 2015
                     Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "{{projectName}}", "{{projectName}}.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                     EndProject
@@ -2326,21 +2483,27 @@ public void DisambiguatedTargetNamesAreInInMetaproj()
                             {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
                         EndGlobalSection
                     EndGlobal
-                """);
+                    """;
 
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), null);
-
-                foreach (string targetName in ProjectInSolution.projectNamesToDisambiguate)
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
                 {
-                    // The entry point still exists normally.
-                    Assert.True(instances[0].Targets.ContainsKey(targetName));
-
-                    // The traversal target should be disambiguated with a "Solution:" prefix.
-                    // Note: The default targets are used instead of "Build".
-                    string traversalTargetName = targetName.Equals("Build", StringComparison.OrdinalIgnoreCase)
-                        ? $"Solution:{projectName}"
-                        : $"Solution:{projectName}:{targetName}";
-                    Assert.True(instances[0].Targets.ContainsKey(traversalTargetName));
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
+
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), null);
+
+                    foreach (string targetName in ProjectInSolution.projectNamesToDisambiguate)
+                    {
+                        // The entry point still exists normally.
+                        Assert.True(instances[0].Targets.ContainsKey(targetName));
+
+                        // The traversal target should be disambiguated with a "Solution:" prefix.
+                        // Note: The default targets are used instead of "Build".
+                        string traversalTargetName = targetName.Equals("Build", StringComparison.OrdinalIgnoreCase)
+                            ? $"Solution:{projectName}"
+                            : $"Solution:{projectName}:{targetName}";
+                        Assert.True(instances[0].Targets.ContainsKey(traversalTargetName));
+                    }
                 }
             }
         }
@@ -2349,73 +2512,81 @@ public void DisambiguatedTargetNamesAreInInMetaproj()
         /// Verifies that illegal user target names (the ones already used internally) don't crash the SolutionProjectGenerator
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void IllegalUserTargetNamesDoNotThrow(bool forceCaseDifference)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        [InlineData(true, true)]
+        public void IllegalUserTargetNamesDoNotThrow(bool forceCaseDifference, bool useNewParser)
         {
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(
-            @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
                 EndGlobal
-            ");
+                """;
 
-            ProjectInstance[] instances;
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            // Avoid any unexpected targets getting pulled in
-            var globalProperties = new Dictionary<string, string> { { "ImportByWildcardBeforeSolution", "false" } };
+                ProjectInstance[] instances;
 
-            foreach (string builtInTargetName in new[]
-            {
-                null,
-                "Build",
-                "Rebuild",
-                "Clean",
-                "Publish",
-                "ClassLibrary1",
-                "ClassLibrary1:Clean",
-                "ClassLibrary1:Rebuild",
-                "GetSolutionConfigurationContents",
-                "ValidateProjects",
-            })
-            {
-                string[] targetNames;
+                // Avoid any unexpected targets getting pulled in
+                var globalProperties = new Dictionary<string, string> { { "ImportByWildcardBeforeSolution", "false" } };
 
-                if (builtInTargetName == null)
+                foreach (string builtInTargetName in new[]
                 {
-                    targetNames = null;
-                }
-                else
+                    null,
+                    "Build",
+                    "Rebuild",
+                    "Clean",
+                    "Publish",
+                    "ClassLibrary1",
+                    "ClassLibrary1:Clean",
+                    "ClassLibrary1:Rebuild",
+                    "GetSolutionConfigurationContents",
+                    "ValidateProjects",
+                })
                 {
-                    string targetName = forceCaseDifference ? builtInTargetName.ToUpperInvariant() : builtInTargetName;
-                    targetNames = new[] { targetName };
-                }
+                    string[] targetNames;
 
-                instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), targetNames);
+                    if (builtInTargetName == null)
+                    {
+                        targetNames = null;
+                    }
+                    else
+                    {
+                        string targetName = forceCaseDifference ? builtInTargetName.ToUpperInvariant() : builtInTargetName;
+                        targetNames = new[] { targetName };
+                    }
 
-                Assert.Single(instances);
+                    instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), targetNames);
 
-                Assert.Equal(12, instances[0].TargetsCount);
-            }
+                    Assert.Single(instances);
 
-            instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
+                    Assert.Equal(12, instances[0].TargetsCount);
+                }
+
+                instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
 
-            Assert.Single(instances);
+                Assert.Single(instances);
 
-            Assert.Equal(14, instances[0].TargetsCount);
+                Assert.Equal(14, instances[0].TargetsCount);
+            }
         }
 
         /// <summary>
@@ -2426,31 +2597,34 @@ public void AfterTargetsComeFromImport()
         {
             string baseDirectory = Guid.NewGuid().ToString("N");
 
-            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"), @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"),
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
                 EndGlobal
-            ");
+                """);
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"after.{Path.GetFileName(solutionFilePath)}.targets"), @"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
-                    <Target Name=""MyTarget"">
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"after.{Path.GetFileName(solutionFilePath)}.targets"),
+                """
+                <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                    <Target Name="MyTarget">
                         <MyTask />
                     </Target>
-                </Project>");
+                </Project>
+                """);
 
             try
             {
@@ -2482,31 +2656,34 @@ public void BeforeTargetsFromImportCanHookDynamicTarget()
         {
             string baseDirectory = Guid.NewGuid().ToString("N");
 
-            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"), @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"),
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
                 EndGlobal
-            ");
+                """);
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"after.{Path.GetFileName(solutionFilePath)}.targets"), @"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
-                    <Target Name=""MyTarget"" BeforeTargets=""DynamicTraversalTarget"">
-                        <Warning Text=""Message from MyTarget"" />
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"after.{Path.GetFileName(solutionFilePath)}.targets"),
+                """
+                <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                    <Target Name="MyTarget" BeforeTargets="DynamicTraversalTarget">
+                        <Warning Text="Message from MyTarget" />
                     </Target>
-                </Project>");
+                </Project>
+                """);
 
             try
             {
@@ -2557,48 +2734,55 @@ public void DirectorySolutionPropsTest(string projectName, bool enable)
 
             string baseDirectory = Guid.NewGuid().ToString("N");
 
-            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"), @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"),
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
                 EndGlobal
-            ");
+                """);
 
-            string projectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, projectName), $@"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
+            string projectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, projectName),
+                $$"""
+                <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
                     <PropertyGroup>
-                        <PropertyA>{expectedPropertyValue}</PropertyA>
+                        <PropertyA>{{expectedPropertyValue}}</PropertyA>
                     </PropertyGroup>
-                </Project>");
+                </Project>
+                """);
 
             if (projectPath.StartsWith("Custom", StringComparison.OrdinalIgnoreCase))
             {
                 // If a custom file name was given, create a Directory.Solution.props and Directory.Build.targets to ensure that they aren't imported
-                ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, "Directory.Solution.props"), $@"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
-                    <PropertyGroup>
-                        <PropertyA>This file should not be imported</PropertyA>
-                    </PropertyGroup>
-                </Project>");
-
-                ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, "Directory.Solution.targets"), $@"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
-                    <PropertyGroup>
-                        <PropertyA>This file should not be imported</PropertyA>
-                    </PropertyGroup>
-                </Project>");
+                ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, "Directory.Solution.props"),
+                    """
+                    <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                        <PropertyGroup>
+                            <PropertyA>This file should not be imported</PropertyA>
+                        </PropertyGroup>
+                    </Project>
+                    """);
+
+                ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, "Directory.Solution.targets"),
+                    """
+                    <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                        <PropertyGroup>
+                            <PropertyA>This file should not be imported</PropertyA>
+                        </PropertyGroup>
+                    </Project>
+                    """);
             }
 
             try
@@ -2640,20 +2824,23 @@ public void DirectorySolutionPropsTest(string projectName, bool enable)
         /// Regression test for https://github.com/dotnet/msbuild/issues/6236
         /// </summary>
         [Theory]
-        [InlineData("http://localhost:8080")]
-        [InlineData("a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-")]
-        public void AbsolutePathWorksForUnsupportedPaths(string relativePath)
+        [InlineData("http://localhost:8080", false)]
+        [InlineData("http://localhost:8080", true)]
+        [InlineData(_longLineString, false)]
+        [InlineData(_longLineString, true)]
+        public void AbsolutePathWorksForUnsupportedPaths(string relativePath, bool useNewParser)
         {
             string solutionFileContents =
-                $@"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.0.31025.194
-MinimumVisualStudioVersion = 10.0.40219.1
-Project(""{{E24C65DC-7377-472B-9ABA-BC803B73C61A}}"") = ""WebSite1"", ""{relativePath}"", ""{{{{96E0707C-2E9C-4704-946F-FA583147737F}}}}""
-EndProject";
+                $$"""
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio Version 16
+                VisualStudioVersion = 16.0.31025.194
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project("{E24C65DC-7377-472B-9ABA-BC803B73C61A}") = "WebSite1", "{{relativePath}}", "{96E0707C-2E9C-4704-946F-FA583147737F}"
+                EndProject
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectInSolution projectInSolution = solution.ProjectsInOrder.ShouldHaveSingleItem();
 
@@ -2665,25 +2852,25 @@ public void AbsolutePathWorksForUnsupportedPaths(string relativePath)
         /// <summary>
         /// Create a Project derived from a Venus solution
         /// </summary>
-        private ProjectInstance CreateVenusSolutionProject()
+        private ProjectInstance CreateVenusSolutionProject(bool useNewParser)
         {
-            return CreateVenusSolutionProject(null, null);
+            return CreateVenusSolutionProject(null, null, useNewParser);
         }
 
         /// <summary>
         /// Create a Project derived from a Venus solution
         /// </summary>
-        private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> globalProperties)
+        private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> globalProperties, bool useNewParser)
         {
-            return CreateVenusSolutionProject(globalProperties, null);
+            return CreateVenusSolutionProject(globalProperties, null, useNewParser);
         }
 
         /// <summary>
         /// Create a Project derived from a Venus solution
         /// </summary>
-        private ProjectInstance CreateVenusSolutionProject(string toolsVersion)
+        private ProjectInstance CreateVenusSolutionProject(string toolsVersion, bool useNewParser)
         {
-            return CreateVenusSolutionProject(null, toolsVersion);
+            return CreateVenusSolutionProject(null, toolsVersion, useNewParser);
         }
 
         /// <summary>
@@ -2692,10 +2879,10 @@ private ProjectInstance CreateVenusSolutionProject(string toolsVersion)
         /// </summary>
         /// <param name="globalProperties">The dictionary of global properties.  May be null.</param>
         /// <param name="toolsVersion">The ToolsVersion override value.  May be null.</param>
-        private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> globalProperties, string toolsVersion)
+        private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> globalProperties, string toolsVersion, bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'C:\solutions\WebSite2\', '..\..\solutions\WebSite2\', '{F90528C4-6989-4D33-AFE8-F53173597CC2}'
@@ -2727,14 +2914,18 @@ private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> g
                         {F90528C4-6989-4D33-AFE8-F53173597CC2}.Debug|Any CPU.Build.0 = Debug|.NET
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, toolsVersion, BuildEventContext.Invalid, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, toolsVersion, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            // Index 0 is the traversal project, which will reference the sole Venus project.
-            return instances[1];
+                // Index 0 is the traversal project, which will reference the sole Venus project.
+                return instances[1];
+            }
         }
 
         private ILoggingService CreateMockLoggingService()
@@ -2776,6 +2967,25 @@ private void AssertProjectItemNameCount(ProjectInstance msbuildProject, string i
             Assert.Equal(count, itemGroup.Count());
         }
 
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                return ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, testEnvironment);
+            }
+        }
+
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser, TestEnvironment testEnvironment)
+        {
+            solutionFileContents = solutionFileContents.Replace('\'', '"');
+            if (isOptInSlnParsingWithNewParser)
+            {
+                testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
+            }
+            TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
+            return SolutionFile.Parse(sln.Path);
+        }
+
         #endregion // Helper Functions
     }
 }
diff --git a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
index 72a46b6d23b..80781a43671 100644
--- a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
+++ b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
@@ -532,7 +532,6 @@ public void PatternEmptyString_LegacyRegex()
         {
             UncPattern.IsMatch(string.Empty).ShouldBeFalse();
             StartsWithUncPattern.IsMatch(string.Empty).ShouldBeFalse();
-            StartsWithUncPattern.Match(string.Empty).Success.ShouldBeFalse();
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
index cc551762e11..8156ed4fb52 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -70,9 +71,12 @@ public void GlobFromRelativeGlobRootNormalizesRootAgainstCurrentDirectory()
         [Fact]
         public void GlobFromRootWithInvalidPathThrows()
         {
-            foreach (var invalidPathChar in FileUtilities.InvalidPathChars)
+            for (int i = 0; i < 128; i++)
             {
-                Assert.Throws<ArgumentException>(() => MSBuildGlob.Parse(invalidPathChar.ToString(), "*"));
+                if (FileUtilities.InvalidPathChars.Contains((char)i))
+                {
+                    Assert.Throws<ArgumentException>(() => MSBuildGlob.Parse(((char)i).ToString(), "*"));
+                }
             }
         }
 
@@ -182,12 +186,15 @@ public void GlobMatchShouldReturnFalseIfArgumentContainsInvalidPathOrFileCharact
         {
             var glob = MSBuildGlob.Parse("*");
 
-            foreach (var invalidPathChar in FileUtilities.InvalidPathChars)
+            for (int i = 0; i < 128; i++)
             {
-                Assert.False(glob.IsMatch(invalidPathChar.ToString()));
+                if (FileUtilities.InvalidPathChars.Contains((char)i))
+                {
+                    Assert.False(glob.IsMatch(((char)i).ToString()));
+                }
             }
 
-            foreach (var invalidFileChar in FileUtilities.InvalidFileNameChars)
+            foreach (var invalidFileChar in FileUtilities.InvalidFileNameCharsArray)
             {
                 if (invalidFileChar == '\\' || invalidFileChar == '/')
                 {
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index b941649ad74..d6344240f1a 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -402,14 +402,14 @@ public void SolutionWithoutAllConfigurations()
 
                 // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
                 TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "SimpleProject.sln",
-                    @"
+                    """
                     Microsoft Visual Studio Solution File, Format Version 12.00
                     # Visual Studio Version 16
                     VisualStudioVersion = 16.0.29326.124
                     MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Project1"", ""1\1\1.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Project1", "1\1\1.csproj", "{79B5EBA6-5D27-4976-BC31-14422245A59A}"
                     EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""2"", ""2\2\2.proj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "2", "2\2\2.proj", "{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}"
                     EndProject
                     Global
                         GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -434,7 +434,7 @@ public void SolutionWithoutAllConfigurations()
                             SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
                         EndGlobalSection
                     EndGlobal
-                ");
+                    """);
 
                 ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
                 MockLogger logger = new();
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 431ea412875..6d535479b1e 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -59,7 +59,8 @@ public void GraphConstructionFailsOnNonExistentSolution()
                     new ProjectGraph("nonExistent.sln");
                 });
 
-            exception.Message.ShouldContain("The project file could not be loaded. Could not find file");
+            exception.Message.ShouldContain("The project file could not be loaded.");
+            exception.Message.ShouldContain("Could not find file");
         }
 
         [Fact]
@@ -646,28 +647,6 @@ IEnumerable<ProjectItemInstance> GetIncomingEdgeItemsToNode(ProjectGraphNode nod
             }
         }
 
-        [Fact]
-        public void GraphConstructionShouldThrowOnMissingSolutionDependencies()
-        {
-            var solutionContents = SolutionFileBuilder.FromGraphEdges(
-                _env,
-                new Dictionary<int, int[]> { { 1, null }, { 2, null } },
-                new[] { ("1", new[] { Guid.NewGuid().ToString("B") }) }).BuildSolution();
-
-            var solutionFile = _env.CreateFile(
-                "solution.sln",
-                solutionContents)
-                .Path;
-
-            var exception = Should.Throw<InvalidProjectFileException>(
-                () =>
-                {
-                    new ProjectGraph(solutionFile);
-                });
-
-            exception.Message.ShouldContain("but a project with this GUID was not found in the .SLN file");
-        }
-
         private static bool IsSolutionItemReference(ProjectItemInstance edgeItem)
         {
             return edgeItem.ItemType == GraphBuilder.SolutionItemReference;
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 063df0be739..d799c4267b1 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -338,8 +338,8 @@ public void UndeclaredReferenceBuildResultNotPresentInOutputCache()
             var deserializedOutputCacheRoot = CacheSerialization.DeserializeCaches(outputCaches[topoSortedProjectGraphNodes[1]]);
             deserializedOutputCacheDeclaredReference.exception.ShouldBeNull();
             deserializedOutputCacheRoot.exception.ShouldBeNull();
-            BuildResult[] declaredReferenceBuildResults = deserializedOutputCacheDeclaredReference.ResultsCache.GetEnumerator().ToArray();
-            BuildResult[] rootBuildResults = deserializedOutputCacheRoot.ResultsCache.GetEnumerator().ToArray();
+            BuildResult[] declaredReferenceBuildResults = deserializedOutputCacheDeclaredReference.ResultsCache.ToArray();
+            BuildResult[] rootBuildResults = deserializedOutputCacheRoot.ResultsCache.ToArray();
 
             // Both the root and declared reference projects should only have one build result.
             declaredReferenceBuildResults.Length.ShouldBe(1);
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index b1a0b664c80..8ff5f52352f 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -356,13 +356,13 @@ public void OutputCacheShouldNotContainInformationFromInputCaches()
 
             deserializationInfo.exception.ShouldBeNull();
 
-            var buildResults = deserializationInfo.ResultsCache.GetEnumerator().ToArray();
+            var buildResults = deserializationInfo.ResultsCache.ToArray();
             buildResults.ShouldHaveSingleItem();
 
             var rootNodeBuildResult = buildResults.First();
             rootNodeBuildResult.ResultsByTarget["Build"].Items.Select(i => i.ItemSpec).ToArray().ShouldBe(expectedOutput[rootNode]);
 
-            var configEntries = deserializationInfo.ConfigCache.GetEnumerator().ToArray();
+            var configEntries = deserializationInfo.ConfigCache.ToArray();
             configEntries.ShouldHaveSingleItem();
 
             configEntries.First().ConfigurationId.ShouldBe(rootNodeBuildResult.ConfigurationId);
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 7653366ce4c..e1bab7e113d 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,11 +16,12 @@
 
   <ItemGroup>
     <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    <PackageReference Include="FluentAssertions" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
+    <PackageReference Include="AwesomeAssertions" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="FakeItEasy" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
     <PackageReference Include="Verify.Xunit" />
     <PackageReference Include="NuGet.Frameworks">
@@ -29,7 +30,7 @@
 
     <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    
+
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
@@ -38,7 +39,7 @@
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
     <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
-    
+
     <ProjectReference Include="..\Samples\TaskWithDependency\TaskWithDependency.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="TaskWithDependencyResolvedProjectReferencePath">
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
@@ -49,7 +50,7 @@
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
     </ProjectReference>
-    
+
     <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' " />
   </ItemGroup>
 
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 4dbf79918ac..78f96a187df 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2801,12 +2801,11 @@ private NodeConfiguration GetNodeConfiguration()
             {
                 // Get the remote loggers
                 ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent<ILoggingService>(BuildComponentType.LoggingService);
-                var remoteLoggers = new List<LoggerDescription>(loggingService.LoggerDescriptions);
 
                 _nodeConfiguration = new NodeConfiguration(
                 -1, /* must be assigned by the NodeManager */
                 _buildParameters,
-                remoteLoggers.ToArray()
+                loggingService.LoggerDescriptions.ToArray()
 #if FEATURE_APPDOMAIN
                 , AppDomain.CurrentDomain.SetupInformation
 #endif
diff --git a/src/Build/BackEnd/BuildManager/CacheAggregator.cs b/src/Build/BackEnd/BuildManager/CacheAggregator.cs
index aca3b8ef9c7..ddbe4524e06 100644
--- a/src/Build/BackEnd/BuildManager/CacheAggregator.cs
+++ b/src/Build/BackEnd/BuildManager/CacheAggregator.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
@@ -55,8 +56,8 @@ public CacheAggregation Aggregate()
 
         private void InsertCaches(IConfigCache configCache, IResultsCache resultsCache)
         {
-            var configs = configCache.GetEnumerator().ToArray();
-            var results = resultsCache.GetEnumerator().ToArray();
+            var configs = configCache.ToArray();
+            var results = resultsCache.ToArray();
 
             ErrorUtilities.VerifyThrow(configs.Length == results.Length, "Assuming 1-to-1 mapping between configs and results. Otherwise it means the caches are either not minimal or incomplete");
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index e3b0a6d069e..a87175b7936 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -1433,7 +1433,7 @@ private void TraceEngine(string format, params object[] stuff)
                     using (StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, @"EngineTrace_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true))
                     {
                         string message = String.Format(CultureInfo.CurrentCulture, format, stuff);
-                        file.WriteLine("{0}({1})-{2}: {3}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, DateTime.UtcNow.Ticks, message);
+                        file.WriteLine("{0}({1})-{2}: {3}", Thread.CurrentThread.Name, Environment.CurrentManagedThreadId, DateTime.UtcNow.Ticks, message);
                         file.Flush();
                     }
                 }
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 28466f039ca..2450c2debfd 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -511,12 +511,13 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
                     ErrorUtilities.VerifyThrow(addToIssueList, "Requests with unresolved configurations should always be added to the issue list.");
                     _unresolvedConfigurations ??= new Dictionary<int, List<BuildRequest>>();
 
-                    if (!_unresolvedConfigurations.ContainsKey(newRequest.ConfigurationId))
+                    if (!_unresolvedConfigurations.TryGetValue(newRequest.ConfigurationId, out List<BuildRequest> value))
                     {
-                        _unresolvedConfigurations.Add(newRequest.ConfigurationId, new List<BuildRequest>());
+                        value = new List<BuildRequest>();
+                        _unresolvedConfigurations.Add(newRequest.ConfigurationId, value);
                     }
 
-                    _unresolvedConfigurations[newRequest.ConfigurationId].Add(newRequest);
+                    value.Add(newRequest);
                 }
 
                 if (addToIssueList)
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 6fdad8b8128..2c90dda389c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -29,7 +29,7 @@ internal class NodeEndpointInProc : INodeEndpoint
         /// <summary>
         /// An object for the two inproc endpoints to synchronize on.
         /// </summary>
-        private static Object s_locker = new Object();
+        private static readonly Object s_locker = new Object();
 
         /// <summary>
         /// The current communication status of the node.
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index ebff305e5ab..a2709281af4 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -383,7 +383,7 @@ private bool InstantiateNode(INodePacketFactory factory)
                 InProcNodeThreadProc();
             });
 #endif
-            _inProcNodeThread.Name = String.Format(CultureInfo.CurrentCulture, "In-proc Node ({0})", _componentHost.Name);
+            _inProcNodeThread.Name = $"In-proc Node ({_componentHost.Name})";
             _inProcNodeThread.IsBackground = true;
 #if FEATURE_THREAD_CULTURE
             _inProcNodeThread.CurrentCulture = _componentHost.BuildParameters.Culture;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 1f69d1b6699..d346a6f3fe6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -395,7 +395,11 @@ void CreateNodeContext(int nodeId, Process nodeToReuse, NodePipeClient pipeClien
         /// </summary>
         private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessId)
         {
-            return hostHandshake.ToString() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
+#if NET
+            return string.Create(CultureInfo.InvariantCulture, $"{hostHandshake}|{nodeProcessId}");
+#else
+            return $"{hostHandshake}|{nodeProcessId.ToString(CultureInfo.InvariantCulture)}";
+#endif
         }
 
         /// <summary>
@@ -646,8 +650,17 @@ public async Task WaitForExitAsync(ILoggingService loggingService)
                 {
                     // Wait up to 100ms until all remaining packets are sent.
                     // We don't need to wait long, just long enough for the Task to start running on the ThreadPool.
-                    await Task.WhenAny(_packetWriteDrainTask, Task.Delay(100));
+#if NET
+                    await _packetWriteDrainTask.WaitAsync(TimeSpan.FromMilliseconds(100)).ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing);
+#else
+                    using (var cts = new CancellationTokenSource(100))
+                    {
+                        await Task.WhenAny(_packetWriteDrainTask, Task.Delay(100, cts.Token));
+                        cts.Cancel();
+                    }
+#endif
                 }
+
                 if (_exitPacketState == ExitPacketState.ExitPacketSent)
                 {
                     CommunicationsUtilities.Trace("Waiting for node with pid = {0} to exit", _process.Id);
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 912c37ee0ca..ab2b1bb2da0 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal static class TranslatorExtensions
     {
-        private static Lazy<ConcurrentDictionary<Type, ConstructorInfo>> parameterlessConstructorCache = new Lazy<ConcurrentDictionary<Type, ConstructorInfo>>(() => new ConcurrentDictionary<Type, ConstructorInfo>());
+        private static readonly Lazy<ConcurrentDictionary<Type, ConstructorInfo>> parameterlessConstructorCache = new Lazy<ConcurrentDictionary<Type, ConstructorInfo>>(() => new ConcurrentDictionary<Type, ConstructorInfo>());
 
         /// <summary>
         /// Translates a PropertyDictionary of ProjectPropertyInstances.
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
index de28c100d1d..5936bf90ac5 100644
--- a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
@@ -22,7 +22,7 @@ private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, A
         // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen
         // and the build result is reported can plugins be notified about project completion.
         // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.
-        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @":\{MSBuildFileAccessCompletion}\";
+        private static readonly string FileAccessCompletionPrefix = $@"{BuildParameters.StartupDirectory[0]}:\{{MSBuildFileAccessCompletion}}\";
 
         private IScheduler? _scheduler;
         private IConfigCache? _configCache;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index c08622d49eb..1e4121594e2 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -94,7 +94,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// We use a BindingFlags.Public flag here because the getter is public, so although the setter is internal,
         /// it is only discoverable with Reflection using the Public flag (go figure!)
         /// </remarks>
-        private static Lazy<PropertyInfo> s_projectStartedEventArgsGlobalProperties = new Lazy<PropertyInfo>(() => typeof(ProjectStartedEventArgs).GetProperty("GlobalProperties", BindingFlags.Public | BindingFlags.Instance), LazyThreadSafetyMode.PublicationOnly);
+        private static readonly Lazy<PropertyInfo> s_projectStartedEventArgsGlobalProperties = new Lazy<PropertyInfo>(() => typeof(ProjectStartedEventArgs).GetProperty("GlobalProperties", BindingFlags.Public | BindingFlags.Instance), LazyThreadSafetyMode.PublicationOnly);
 
         /// <summary>
         /// A cached reflection accessor for an internal member.
@@ -103,7 +103,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// We use a BindingFlags.Public flag here because the getter is public, so although the setter is internal,
         /// it is only discoverable with Reflection using the Public flag (go figure!)
         /// </remarks>
-        private static Lazy<PropertyInfo> s_projectStartedEventArgsToolsVersion = new Lazy<PropertyInfo>(() => typeof(ProjectStartedEventArgs).GetProperty("ToolsVersion", BindingFlags.Public | BindingFlags.Instance), LazyThreadSafetyMode.PublicationOnly);
+        private static readonly Lazy<PropertyInfo> s_projectStartedEventArgsToolsVersion = new Lazy<PropertyInfo>(() => typeof(ProjectStartedEventArgs).GetProperty("ToolsVersion", BindingFlags.Public | BindingFlags.Instance), LazyThreadSafetyMode.PublicationOnly);
 
         #region Data
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index bd1cb0fd8d7..8906f10ba5a 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -32,7 +32,7 @@ internal sealed class ProjectCacheService : IAsyncDisposable
     {
         private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };
 
-        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
+        private static readonly HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
         private readonly BuildManager _buildManager;
         private readonly IBuildComponentHost _componentHost;
@@ -115,8 +115,7 @@ public void InitializePluginsForGraph(
                             foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
                             {
                                 // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, requestedTargets, cancellationToken)
-                                    .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, requestedTargets, cancellationToken);
                             }
                         });
                 },
@@ -149,8 +148,7 @@ public void InitializePluginsForVsScenario(
                         projectCacheDescriptor =>
                         {
                             // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, requestedTargets, cancellationToken)
-                                .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, requestedTargets, cancellationToken);
                         });
                 },
                 cancellationToken);
@@ -449,7 +447,7 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
                 },
                 cancellationToken);
 
-            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequestAsync()
+            async ValueTask<(CacheResult Result, int ProjectContextId)> ProcessCacheRequestAsync()
             {
                 EvaluateProjectIfNecessary(cacheRequest.Submission, cacheRequest.Configuration);
 
@@ -499,7 +497,7 @@ void EvaluateProjectIfNecessary(BuildSubmission submission, BuildRequestConfigur
             }
         }
 
-        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext, CancellationToken cancellationToken)
+        private async ValueTask<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext, CancellationToken cancellationToken)
         {
             ErrorUtilities.VerifyThrowInternalNull(buildRequest.ProjectInstance, nameof(buildRequest.ProjectInstance));
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 423679a1f6e..c33c0ab6563 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -186,7 +186,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     if (// If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
                         bucket.BucketSequenceNumber == 0 &&
                         // Referring to unqualified metadata of other item (transform) is fine.
-                        child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
+                        !child.Include.Contains("@("))
                     {
                         expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
                     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index 73f84dd94a0..9c2271ff635 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -259,7 +259,7 @@ public async Task<bool> ExecuteInternal()
                 undefinePropertiesArray = RemoveProperties.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
                 foreach (string property in undefinePropertiesArray)
                 {
-                    Log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}", property), MessageImportance.Low);
+                    Log.LogMessageFromText($"  {property}", MessageImportance.Low);
                 }
             }
 
@@ -296,10 +296,7 @@ public async Task<bool> ExecuteInternal()
             if (BuildInParallel)
             {
                 skipProjects = new bool[Projects.Length];
-                for (int i = 0; i < skipProjects.Length; i++)
-                {
-                    skipProjects[i] = true;
-                }
+                skipProjects.AsSpan().Fill(true);
             }
             else
             {
@@ -594,7 +591,7 @@ internal static async Task<bool> ExecuteTargets(
                             foreach (string property in propertiesToUndefine)
                             {
                                 undefinePropertiesPerProject[i].Add(property);
-                                log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}", property), MessageImportance.Low);
+                                log.LogMessageFromText($"  {property}", MessageImportance.Low);
                             }
                         }
                     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 6a882eb87f0..c2b180dd2b9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -1373,7 +1373,7 @@ internal Scope(Lookup lookup, string description, IItemDictionary<ProjectItemIns
                 _modifies = null;
                 _properties = properties;
                 _propertySets = null;
-                _threadIdThatEnteredScope = Thread.CurrentThread.ManagedThreadId;
+                _threadIdThatEnteredScope = Environment.CurrentManagedThreadId;
                 _truncateLookupsAtThisScope = false;
             }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index e53b39a032f..1adad068292 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -242,7 +242,7 @@ public void ContinueRequestWithResources(ResourceResponse response)
         {
             ErrorUtilities.VerifyThrow(HasActiveBuildRequest, "Request not building");
             ErrorUtilities.VerifyThrow(!_terminateEvent.WaitOne(0), "Request already terminated");
-            ErrorUtilities.VerifyThrow(_pendingResourceRequests.Any(), "No pending resource requests");
+            ErrorUtilities.VerifyThrow(!_pendingResourceRequests.IsEmpty, "No pending resource requests");
             VerifyEntryInActiveOrWaitingState();
 
             _pendingResourceRequests.Dequeue()(response);
@@ -1032,22 +1032,9 @@ private BuildResult[] GetResultsForContinuation(FullyQualifiedBuildRequest[] req
 
             // The build results will have node request IDs in the same order as the requests were issued,
             // which is in the array order above.
-            List<BuildResult> resultsList = new List<BuildResult>(results.Values);
-            resultsList.Sort(delegate (BuildResult left, BuildResult right)
-            {
-                if (left.NodeRequestId < right.NodeRequestId)
-                {
-                    return -1;
-                }
-                else if (left.NodeRequestId == right.NodeRequestId)
-                {
-                    return 0;
-                }
-
-                return 1;
-            });
-
-            return resultsList.ToArray();
+            BuildResult[] resultsArray = results.Values.ToArray();
+            Array.Sort(resultsArray, (left, right) => left.NodeRequestId.CompareTo(right.NodeRequestId));
+            return resultsArray;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index aab4fb6d344..65b6903876a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -412,7 +412,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                 (
                 !_cancellationToken.IsCancellationRequested &&
                 !stopProcessingStack &&
-                _targetsToBuild.Any())
+                !_targetsToBuild.IsEmpty)
             {
                 TargetEntry currentTargetEntry = _targetsToBuild.Peek();
                 switch (currentTargetEntry.State)
@@ -621,7 +621,7 @@ private void PopDependencyTargetsOnTargetFailure(TargetEntry topEntry, TargetRes
                 // Pop down to our parent, since any other dependencies our parent had should no longer
                 // execute.  If we encounter an error target on the way down, also stop since the failure
                 // of one error target in a set declared in OnError should not cause the others to stop running.
-                while ((_targetsToBuild.Any()) && (_targetsToBuild.Peek() != topEntry.ParentEntry) && !_targetsToBuild.Peek().ErrorTarget)
+                while ((!_targetsToBuild.IsEmpty) && (_targetsToBuild.Peek() != topEntry.ParentEntry) && !_targetsToBuild.Peek().ErrorTarget)
                 {
                     TargetEntry entry = _targetsToBuild.Pop();
                     entry.LeaveLegacyCallTargetScopes();
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index c85b4f41f54..30179f2e7a9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -810,7 +810,7 @@ internal void LeaveLegacyCallTargetScopes()
         /// <returns>
         /// The result of the tasks, based on the last task which ran.
         /// </returns>
-        private async Task<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, TargetLoggingContext targetLoggingContext, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution)
+        private async ValueTask<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, TargetLoggingContext targetLoggingContext, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution)
         {
             WorkUnitResultCode aggregatedTaskResult = WorkUnitResultCode.Success;
             WorkUnitActionCode finalActionCode = WorkUnitActionCode.Continue;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index a75c73a91ae..58e250f6c97 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -838,15 +839,14 @@ private void SeparateItemVectorsFromDiscreteItems(
                         }
 
                         // Do we already have a partition for this?
-                        if (!itemVectorCollection.ContainsKey(itemVectorType))
+                        if (!itemVectorCollection.TryGetValue(itemVectorType, out ItemVectorPartition itemVectorPartition))
                         {
                             // Nope, create one.
-                            itemVectorCollection[itemVectorType] = new ItemVectorPartition(MSBuildNameIgnoreCaseComparer.Default);
+                            itemVectorPartition = new ItemVectorPartition(MSBuildNameIgnoreCaseComparer.Default);
+                            itemVectorCollection[itemVectorType] = itemVectorPartition;
                         }
 
-                        ItemVectorPartition itemVectorPartition = itemVectorCollection[itemVectorType];
-
-                        ErrorUtilities.VerifyThrow(!itemVectorCollection[itemVectorType].ContainsKey(item), "ItemVectorPartition already contains a vector for items with the expression '{0}'", item);
+                        ErrorUtilities.VerifyThrow(!itemVectorPartition.ContainsKey(item), "ItemVectorPartition already contains a vector for items with the expression '{0}'", item);
                         itemVectorPartition[item] = itemVectorContents;
 
                         ErrorUtilities.VerifyThrow((itemVectorTransforms == null) || (itemVectorCollection.Equals(itemVectorTransforms)) || (itemVectorPartition.Count == 1),
@@ -1129,8 +1129,8 @@ private bool IsOutOfDate(string input, string output, string inputItemName, stri
         {
             input = EscapingUtilities.UnescapeAll(FileUtilities.FixFilePath(input));
             output = EscapingUtilities.UnescapeAll(FileUtilities.FixFilePath(output));
-            ProjectErrorUtilities.VerifyThrowInvalidProject(input.IndexOfAny(Path.GetInvalidPathChars()) == -1, _project.ProjectFileLocation, "IllegalCharactersInFileOrDirectory", input, inputItemName);
-            ProjectErrorUtilities.VerifyThrowInvalidProject(output.IndexOfAny(Path.GetInvalidPathChars()) == -1, _project.ProjectFileLocation, "IllegalCharactersInFileOrDirectory", output, outputItemName);
+            ProjectErrorUtilities.VerifyThrowInvalidProject(input.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) < 0, _project.ProjectFileLocation, "IllegalCharactersInFileOrDirectory", input, inputItemName);
+            ProjectErrorUtilities.VerifyThrowInvalidProject(output.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) < 0, _project.ProjectFileLocation, "IllegalCharactersInFileOrDirectory", output, outputItemName);
             bool outOfDate = (CompareLastWriteTimes(input, output, out bool inputDoesNotExist, out bool outputDoesNotExist) == 1) || inputDoesNotExist;
 
             // Only if we are not logging just critical events should we be gathering full details
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 3a406115fce..36b4af7301f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -291,7 +291,7 @@ private List<string> CreateListOfParameterValues()
         /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <returns>true, if successful</returns>
-        private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup)
+        private async ValueTask<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup)
         {
             ErrorUtilities.VerifyThrowArgumentNull(lookup);
 
@@ -366,7 +366,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
         /// Execute a single bucket
         /// </summary>
         /// <returns>true if execution succeeded</returns>
-        private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary<string, string> lookupHash)
+        private async ValueTask<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary<string, string> lookupHash)
         {
             // On Intrinsic tasks, we do not allow batchable params, therefore metadata is excluded.
             ParserOptions parserOptions = (_taskNode == null) ? ParserOptions.AllowPropertiesAndItemLists : ParserOptions.AllowAll;
@@ -738,7 +738,7 @@ private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost)
         /// <param name="bucket">The batching bucket</param>
         /// <param name="howToExecuteTask">The task execution mode</param>
         /// <returns>The result of running the task.</returns>
-        private async Task<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)
+        private async ValueTask<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)
         {
             UpdateContinueOnError(bucket, taskHost);
 
@@ -859,7 +859,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost tas
                     }
                     else if (type == typeof(ThreadAbortException))
                     {
-#if !NET6_0_OR_GREATER && !NET6_0 // This is redundant but works around https://github.com/dotnet/sdk/issues/20700
+#if !NET
                         Thread.ResetAbort();
 #endif
                         _continueOnError = ContinueOnError.ErrorAndStop;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 45414d7cf5c..0c4bb721766 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -42,7 +42,7 @@ internal class TaskHost :
         /// <summary>
         /// Help diagnose tasks that log after they return.
         /// </summary>
-        private static bool s_breakOnLogAfterTaskReturns = Environment.GetEnvironmentVariable("MSBUILDBREAKONLOGAFTERTASKRETURNS") == "1";
+        private static readonly bool s_breakOnLogAfterTaskReturns = Environment.GetEnvironmentVariable("MSBUILDBREAKONLOGAFTERTASKRETURNS") == "1";
 
         /// <summary>
         /// The build component host
@@ -357,7 +357,7 @@ public void Yield()
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
                 ErrorUtilities.VerifyThrow(_yieldThreadId == -1, "Cannot call Yield() while yielding.");
-                _yieldThreadId = Thread.CurrentThread.ManagedThreadId;
+                _yieldThreadId = Environment.CurrentManagedThreadId;
                 MSBuildEventSource.Log.ExecuteTaskYieldStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 builderCallback.Yield();
             }
@@ -386,7 +386,7 @@ public void Reacquire()
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
                 ErrorUtilities.VerifyThrow(_yieldThreadId != -1, "Cannot call Reacquire() before Yield().");
-                ErrorUtilities.VerifyThrow(_yieldThreadId == Thread.CurrentThread.ManagedThreadId, "Cannot call Reacquire() on thread {0} when Yield() was called on thread {1}", Thread.CurrentThread.ManagedThreadId, _yieldThreadId);
+                ErrorUtilities.VerifyThrow(_yieldThreadId == Environment.CurrentManagedThreadId, "Cannot call Reacquire() on thread {0} when Yield() was called on thread {1}", Environment.CurrentManagedThreadId, _yieldThreadId);
                 MSBuildEventSource.Log.ExecuteTaskYieldStop(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 MSBuildEventSource.Log.ExecuteTaskReacquireStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 builderCallback.Reacquire();
diff --git a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
index bc5e8f86256..c335c2cebf1 100644
--- a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
+++ b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
@@ -237,26 +237,26 @@ public override string ToString()
             {
                 case ScheduleActionType.ReportResults:
                 case ScheduleActionType.ResumeExecution:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Node: {1} Request: {2}", Action, NodeId, Unblocker.BlockedRequestId);
+                    return $"Act: {Action} Node: {NodeId} Request: {Unblocker.BlockedRequestId}";
 
                 case ScheduleActionType.Schedule:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Node: {1} Request: {2} Parent {3}", Action, NodeId, BuildRequest.GlobalRequestId, BuildRequest.ParentGlobalRequestId);
+                    return $"Act: {Action} Node: {NodeId} Request: {BuildRequest.GlobalRequestId} Parent {BuildRequest.ParentGlobalRequestId}";
 
                 case ScheduleActionType.ScheduleWithConfiguration:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Node: {1} Request: {2} Parent {3} Configuration: {4}", Action, NodeId, BuildRequest.GlobalRequestId, BuildRequest.ParentGlobalRequestId, BuildRequest.ConfigurationId);
+                    return $"Act: {Action} Node: {NodeId} Request: {BuildRequest.GlobalRequestId} Parent {BuildRequest.ParentGlobalRequestId} Configuration: {BuildRequest.ConfigurationId}";
 
                 case ScheduleActionType.CircularDependency:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Node: {1} Request: {2} Parent {3} Configuration: {4}", Action, NodeId, BuildRequest.GlobalRequestId, BuildRequest.ParentGlobalRequestId, BuildRequest.ConfigurationId);
+                    return $"Act: {Action} Node: {NodeId} Request: {BuildRequest.GlobalRequestId} Parent {BuildRequest.ParentGlobalRequestId} Configuration: {BuildRequest.ConfigurationId}";
 
                 case ScheduleActionType.SubmissionComplete:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Submission: {1}", Action, BuildResult.SubmissionId);
+                    return $"Act: {Action} Submission: {BuildResult.SubmissionId}";
 
                 case ScheduleActionType.CreateNode:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Count: {1}", Action, NumberOfNodesToCreate);
+                    return $"Act: {Action} Count: {NumberOfNodesToCreate}";
 
                 case ScheduleActionType.NoAction:
                 default:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0}", Action);
+                    return $"Act: {Action}";
             }
         }
     }
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 0e8b74863be..5911b984a72 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -2431,7 +2431,7 @@ private void WriteNodeUtilizationGraphLine(ILoggingService loggingService, Build
 
             bool haveNonIdleNode = false;
             StringBuilder stringBuilder = new StringBuilder(64);
-            stringBuilder.AppendFormat("{0}:   ", previousEventTime.Ticks);
+            stringBuilder.Append(previousEventTime.Ticks).Append(":   ");
             for (int i = 0; i < currentWork.Length; i++)
             {
                 if (currentWork[i] == invalidWorkId)
@@ -2567,7 +2567,7 @@ private void TraceScheduler(string format, params object[] stuff)
                     FileUtilities.EnsureDirectoryExists(_debugDumpPath);
 
                     using StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerTrace_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true);
-                    file.Write("{0}({1})-{2}: ", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, _schedulingData.EventTime.Ticks);
+                    file.Write("{0}({1})-{2}: ", Thread.CurrentThread.Name, Environment.CurrentManagedThreadId, _schedulingData.EventTime.Ticks);
                     file.WriteLine(format, stuff);
                     file.Flush();
                 }
@@ -2814,7 +2814,7 @@ private void DumpRequestSpec(StreamWriter file, SchedulableRequest request, int
                 request.State,
                 buildRequest.ConfigurationId,
                 _configCache[buildRequest.ConfigurationId].ProjectFullPath,
-                string.Join(", ", buildRequest.Targets.ToArray()));
+                string.Join(", ", buildRequest.Targets));
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index c15b5a25063..19a63a6eb5f 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -363,9 +363,8 @@ private void DetermineExpensiveConfigs()
         /// </summary>
         private void ReadHierarchy(StreamReader file)
         {
-            while (!file.EndOfStream)
+            while (file.ReadLine() is string line)
             {
-                string line = file.ReadLine();
                 if (line.Length == 0)
                 {
                     return;
@@ -394,9 +393,8 @@ private void ReadHierarchy(StreamReader file)
         /// </summary>
         private void ReadTimes(StreamReader file)
         {
-            while (!file.EndOfStream)
+            while (file.ReadLine() is string line)
             {
-                string line = file.ReadLine();
                 if (line.Length == 0)
                 {
                     return;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index a9ea6b37548..1d6ec92f64c 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -136,7 +136,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
             //
             // Overall, while Sdk resolvers look like a general plug-in system, there are good reasons why some of the logic is hard-coded.
             // It's not really meant to be modified outside of very special/internal scenarios.
-#if NETCOREAPP
+#if NET
             if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
             {
                 if (TryResolveSdkUsingSpecifiedResolvers(
@@ -479,7 +479,7 @@ private void RegisterResolversManifests(ElementLocation location)
                 _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
 
                 SdkResolverManifest sdkDefaultResolversManifest = null;
-#if NETCOREAPP
+#if NET
                 if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
 #endif
                 {
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index f90f99d14d3..d2c22d49f76 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -869,7 +869,7 @@ public override int GetHashCode()
         /// <returns>String representation of the object</returns>
         public override string ToString()
         {
-            return String.Format(CultureInfo.CurrentCulture, "{0} {1} {2} {3}", _configId, _projectFullPath, _toolsVersion, _globalProperties);
+            return $"{_configId} {_projectFullPath} {_toolsVersion} {_globalProperties}";
         }
 
         /// <summary>
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index ccedf3bab7f..286e1bf9073 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -40,8 +40,8 @@ public List<CheckFactory> CreateCheckFactories(
             assembly = Assembly.LoadFrom(checkAcquisitionData.AssemblyPath);
 #endif
 
-            IList<Type> availableTypes = assembly.GetExportedTypes();
-            IList<Type> checkTypes = availableTypes.Where(t => typeof(Check).IsAssignableFrom(t)).ToArray();
+            Type[] availableTypes = assembly.GetExportedTypes();
+            Type[] checkTypes = availableTypes.Where(t => typeof(Check).IsAssignableFrom(t)).ToArray();
 
             foreach (Type checkCandidate in checkTypes)
             {
@@ -49,7 +49,7 @@ public List<CheckFactory> CreateCheckFactories(
                 checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckRegistered", checkCandidate.Name, checkCandidate.Assembly);
             }
 
-            if (availableTypes.Count != checkTypes.Count)
+            if (availableTypes.Length != checkTypes.Length)
             {
                 availableTypes.Except(checkTypes).ToList()
                     .ForEach(t => checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckBaseTypeNotAssignable", t.Name, t.Assembly));
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
index e40d33efb34..1039bfa67cc 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -23,23 +23,16 @@ internal partial class EditorConfigFile
     // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
     private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
 
-#if NETCOREAPP
-
+#if NET
     [GeneratedRegex(s_sectionMatcherPattern)]
-    private static partial Regex GetSectionMatcherRegex();
+    private static partial Regex SectionMatcherRegex { get; }
 
     [GeneratedRegex(s_propertyMatcherPattern)]
-    private static partial Regex GetPropertyMatcherRegex();
-
+    private static partial Regex PropertyMatcherRegex { get; }
 #else
-    private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
-
-    private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
-
-    private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
-
-    private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
+    private static Regex SectionMatcherRegex { get; } = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
 
+    private static Regex PropertyMatcherRegex { get; } = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
 #endif
 
     internal Section GlobalSection { get; }
@@ -90,12 +83,12 @@ internal static EditorConfigFile Parse(string text)
                 continue;
             }
 
-            var sectionMatches = GetSectionMatcherRegex().Matches(line);
-            if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
+            var sectionMatch = SectionMatcherRegex.Match(line);
+            if (sectionMatch.Success && sectionMatch.Groups.Count > 0)
             {
                 addNewSection();
 
-                var sectionName = sectionMatches[0].Groups[1].Value;
+                var sectionName = sectionMatch.Groups[1].Value;
                 Debug.Assert(!string.IsNullOrEmpty(sectionName));
 
                 activeSectionName = sectionName;
@@ -103,11 +96,11 @@ internal static EditorConfigFile Parse(string text)
                 continue;
             }
 
-            var propMatches = GetPropertyMatcherRegex().Matches(line);
-            if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
+            var propMatch = PropertyMatcherRegex.Match(line);
+            if (propMatch.Success && propMatch.Groups.Count > 1)
             {
-                var key = propMatches[0].Groups[1].Value.ToLower();
-                var value = propMatches[0].Groups[2].Value;
+                var key = propMatch.Groups[1].Value.ToLower();
+                var value = propMatch.Groups[2].Value;
 
                 Debug.Assert(!string.IsNullOrEmpty(key));
                 Debug.Assert(key == key.Trim());
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
index 56b0842acf7..393a9f7612c 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -41,12 +41,7 @@ internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
         {
             var editorConfig = _editorConfigFileCache.GetOrAdd(editorConfigFilePath, (key) =>
             {
-                using (FileStream stream = new FileStream(editorConfigFilePath, FileMode.Open, System.IO.FileAccess.Read, FileShare.Read))
-                {
-                    using StreamReader sr = new StreamReader(editorConfigFilePath);
-                    var editorConfigfileContent = sr.ReadToEnd();
-                    return EditorConfigFile.Parse(editorConfigfileContent);
-                }
+                return EditorConfigFile.Parse(File.ReadAllText(editorConfigFilePath));
             });
 
             editorConfigDataFromFilesList.Add(editorConfig);
diff --git a/src/Build/Collections/CopyOnReadEnumerable.cs b/src/Build/Collections/CopyOnReadEnumerable.cs
index 6ed48e0eed1..056f5804cfd 100644
--- a/src/Build/Collections/CopyOnReadEnumerable.cs
+++ b/src/Build/Collections/CopyOnReadEnumerable.cs
@@ -62,7 +62,7 @@ public IEnumerator<TResult> GetEnumerator()
         {
             List<TResult> list;
 
-#if NETCOREAPP
+#if NET
             if (_backingEnumerable.TryGetNonEnumeratedCount(out int count))
             {
 #else
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index c8fabf3559e..6c6584e52c7 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -584,7 +584,7 @@ private static string GetElementIndentation(XmlElementWithLocation xmlElement)
 
             var leadingWhiteSpace = xmlElement.PreviousSibling.Value;
 
-            var lastIndexOfNewLine = leadingWhiteSpace.LastIndexOf("\n", StringComparison.Ordinal);
+            var lastIndexOfNewLine = leadingWhiteSpace.LastIndexOf('\n');
 
             if (lastIndexOfNewLine == -1)
             {
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index eee48e9f667..903de887aac 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -43,7 +43,7 @@ namespace Microsoft.Build.Construction
     /// to control its lifetime and not be surprised by edits via another project collection.
     /// </summary>
     [DebuggerDisplay("{FullPath} #Children={Count} DefaultTargets={DefaultTargets} ToolsVersion={ToolsVersion} InitialTargets={InitialTargets} ExplicitlyLoaded={IsExplicitlyLoaded}")]
-    public class ProjectRootElement : ProjectElementContainer
+    public partial class ProjectRootElement : ProjectElementContainer
     {
         // Constants for default (empty) project file.
         private const string EmptyProjectFileContent = "{0}<Project{1}{2}>\r\n</Project>";
@@ -58,10 +58,18 @@ public class ProjectRootElement : ProjectElementContainer
 
         private static readonly ProjectRootElementCacheBase.OpenProjectRootElement s_openLoaderPreserveFormattingDelegate = OpenLoaderPreserveFormatting;
 
+        private const string XmlDeclarationPattern = @"\A\s*\<\?\s*xml.*\?\>\s*\Z";
+
         /// <summary>
         /// Used to determine if a file is an empty XML file if it ONLY contains an XML declaration like &lt;?xml version="1.0" encoding="utf-8"?&gt;.
         /// </summary>
-        private static readonly Lazy<Regex> XmlDeclarationRegEx = new Lazy<Regex>(() => new Regex(@"\A\s*\<\?\s*xml.*\?\>\s*\Z"), isThreadSafe: true);
+#if NET
+        [GeneratedRegex(XmlDeclarationPattern)]
+        private static partial Regex XmlDeclarationRegex { get; }
+#else
+        private static Regex XmlDeclarationRegex => s_xmlDeclarationRegex ??= new Regex(XmlDeclarationPattern);
+        private static Regex s_xmlDeclarationRegex;
+#endif
 
         /// <summary>
         /// The default encoding to use / assume for a new project.
@@ -1988,9 +1996,9 @@ internal static bool IsEmptyXmlFile(string path)
 
                 string contents = File.ReadAllText(path);
 
-                // If the file is only whitespace or the XML declaration then it empty
+                // If the file is only whitespace or the XML declaration then it is empty
                 //
-                return String.IsNullOrEmpty(contents) || XmlDeclarationRegEx.Value.IsMatch(contents);
+                return String.IsNullOrEmpty(contents) || XmlDeclarationRegex.IsMatch(contents);
             }
             catch (Exception)
             {
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index db079f86773..4fdf9c21495 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -106,7 +106,7 @@ public string Name
 
                 string unescapedValue = EscapingUtilities.UnescapeAll(value);
 
-                int indexOfSpecialCharacter = unescapedValue.IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
+                int indexOfSpecialCharacter = unescapedValue.AsSpan().IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
                 if (indexOfSpecialCharacter >= 0)
                 {
                     ErrorUtilities.ThrowArgument("OM_NameInvalid", unescapedValue, unescapedValue[indexOfSpecialCharacter]);
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 60f69b97b54..4eb3b5e82bd 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -2,9 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
 using System.IO;
+using System.Linq;
 using System.Security;
 using System.Text;
 using System.Xml;
@@ -16,8 +19,6 @@
 using ProjectFileErrorUtilities = Microsoft.Build.Shared.ProjectFileErrorUtilities;
 using BuildEventFileInfo = Microsoft.Build.Shared.BuildEventFileInfo;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
-using System.Collections.ObjectModel;
-using System.Linq;
 
 #nullable disable
 
@@ -83,7 +84,12 @@ public sealed class ProjectInSolution
         /// <summary>
         /// Characters that need to be cleansed from a project name.
         /// </summary>
-        private static readonly char[] s_charsToCleanse = { '%', '$', '@', ';', '.', '(', ')', '\'' };
+#if NET
+        private static readonly SearchValues<char> s_charsToCleanse = SearchValues.Create(
+#else
+        private static readonly char[] s_charsToCleanse = (
+#endif
+             ['%', '$', '@', ';', '.', '(', ')', '\'']);
 
         /// <summary>
         /// Project names that need to be disambiguated when forming a target name
@@ -501,12 +507,25 @@ private static string CleanseProjectName(string projectName)
 
             // If there are no special chars, just return the original string immediately.
             // Don't even instantiate the StringBuilder.
-            int indexOfChar = projectName.IndexOfAny(s_charsToCleanse);
+            int indexOfChar = projectName.AsSpan().IndexOfAny(s_charsToCleanse);
             if (indexOfChar == -1)
             {
                 return projectName;
             }
 
+#if NET
+            return string.Create(projectName.Length, (projectName, indexOfChar), static (dest, state) =>
+            {
+                state.projectName.AsSpan().CopyTo(dest);
+                int pos = state.indexOfChar;
+                do
+                {
+                    dest[pos] = cleanCharacter;
+                    dest = dest.Slice(pos + 1);
+                }
+                while ((pos = dest.IndexOfAny(s_charsToCleanse)) >= 0);
+            });
+#else
             // This is where we're going to work on the final string to return to the caller.
             var cleanProjectName = new StringBuilder(projectName);
 
@@ -517,6 +536,7 @@ private static string CleanseProjectName(string projectName)
             }
 
             return cleanProjectName.ToString();
+#endif
         }
 
         /// <summary>
@@ -561,7 +581,7 @@ private static bool ElementContainsInvalidNamespaceDefitions(XmlElement mainProj
             return false;
         }
 
-        #endregion
+#endregion
 
         #region Constants
 
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index b549e97da5a..01ece85d306 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -35,38 +35,47 @@ namespace Microsoft.Build.Construction
     /// This class contains the functionality to parse a solution file and return a corresponding
     /// MSBuild project file containing the projects and dependencies defined in the solution.
     /// </remarks>
-    public sealed class SolutionFile
+    public sealed partial class SolutionFile
     {
         #region Solution specific constants
 
         // An example of a project line looks like this:
         //  Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1\ClassLibrary1.csproj", "{05A5AD00-71B5-4612-AF2F-9EA9121C4111}"
-        private static readonly Lazy<Regex> s_crackProjectLine = new Lazy<Regex>(
-            () => new Regex(
-                "^" // Beginning of line
-                + "Project\\(\"(?<PROJECTTYPEGUID>.*)\"\\)"
-                + "\\s*=\\s*" // Any amount of whitespace plus "=" plus any amount of whitespace
-                + "\"(?<PROJECTNAME>.*)\""
-                + "\\s*,\\s*" // Any amount of whitespace plus "," plus any amount of whitespace
-                + "\"(?<RELATIVEPATH>.*)\""
-                + "\\s*,\\s*" // Any amount of whitespace plus "," plus any amount of whitespace
-                + "\"(?<PROJECTGUID>.*)\""
-                + "$", // End-of-line
-                RegexOptions.Compiled));
+        private const string CrackProjectLinePattern =
+            "^" // Beginning of line
+            + "Project\\(\"(?<PROJECTTYPEGUID>.*)\"\\)"
+            + "\\s*=\\s*" // Any amount of whitespace plus "=" plus any amount of whitespace
+            + "\"(?<PROJECTNAME>.*)\""
+            + "\\s*,\\s*" // Any amount of whitespace plus "," plus any amount of whitespace
+            + "\"(?<RELATIVEPATH>.*)\""
+            + "\\s*,\\s*" // Any amount of whitespace plus "," plus any amount of whitespace
+            + "\"(?<PROJECTGUID>.*)\""
+            + "$"; // End-of-line
 
         // An example of a property line looks like this:
         //      AspNetCompiler.VirtualPath = "/webprecompile"
         // Because website projects now include the target framework moniker as
         // one of their properties, <PROPERTYVALUE> may now have '=' in it.
-
-        private static readonly Lazy<Regex> s_crackPropertyLine = new Lazy<Regex>(
-            () => new Regex(
-                "^" // Beginning of line
-                + "(?<PROPERTYNAME>[^=]*)"
-                + "\\s*=\\s*" // Any amount of whitespace plus "=" plus any amount of whitespace
-                + "(?<PROPERTYVALUE>.*)"
-                + "$", // End-of-line
-                RegexOptions.Compiled));
+        private const string CrackPropertyLinePattern =
+            "^" // Beginning of line
+            + "(?<PROPERTYNAME>[^=]*)"
+            + "\\s*=\\s*" // Any amount of whitespace plus "=" plus any amount of whitespace
+            + "(?<PROPERTYVALUE>.*)"
+            + "$"; // End-of-line
+
+#if NET
+        [GeneratedRegex(CrackProjectLinePattern)]
+        private static partial Regex CrackProjectLineRegex { get; }
+
+        [GeneratedRegex(CrackPropertyLinePattern)]
+        private static partial Regex CrackPropertyLineRegex { get; }
+#else
+        private static Regex CrackProjectLineRegex => s_crackProjectLineRegex ??= new Regex(CrackProjectLinePattern, RegexOptions.Compiled);
+        private static Regex CrackPropertyLineRegex => s_crackPropertyLineRegex ??= new Regex(CrackPropertyLinePattern, RegexOptions.Compiled);
+
+        private static Regex s_crackProjectLineRegex;
+        private static Regex s_crackPropertyLineRegex;
+#endif
 
         internal const int slnFileMinUpgradableVersion = 7; // Minimum version for MSBuild to give a nice message
         internal const int slnFileMinVersion = 9; // Minimum version for MSBuild to actually do anything useful
@@ -89,7 +98,7 @@ public sealed class SolutionFile
         private const string sharedProjectGuid = "{D954291E-2A0B-460D-934E-DC6B0785DB48}";
 
         private const char CommentStartChar = '#';
-        #endregion
+#endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
         private string _solutionFilterFile;          // Could be absolute or relative path to the .SLNF file.
@@ -121,7 +130,7 @@ public sealed class SolutionFile
 
         // TODO: Unify to NativeMethodsShared.OSUsesCaseSensitive paths
         // when possible.
-        private static StringComparer _pathComparer = RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
+        private static readonly StringComparer _pathComparer = RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
             ? StringComparer.Ordinal
             : StringComparer.OrdinalIgnoreCase;
 
@@ -193,7 +202,7 @@ internal int VisualStudioVersion
 
         internal bool UseNewParser => ShouldUseNewParser(_solutionFile);
 
-        internal static bool ShouldUseNewParser(string solutionFile) => FileUtilities.IsSolutionXFilename(solutionFile);
+        internal static bool ShouldUseNewParser(string solutionFile) => Traits.Instance.SlnParsingWithSolutionPersistenceOptIn || FileUtilities.IsSolutionXFilename(solutionFile);
 
         /// <summary>
         /// All projects in this solution, in the order they appeared in the solution file
@@ -221,6 +230,10 @@ internal string FullPath
 
             set
             {
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14) && string.IsNullOrEmpty(value))
+                {
+                    throw new ArgumentNullException(nameof(FullPath));
+                }
                 // Should already be canonicalized to a full path
                 ErrorUtilities.VerifyThrowInternalRooted(value);
                 // To reduce code duplication, this should be
@@ -557,7 +570,12 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
                     if (line.Trim().StartsWith(slnFileHeaderNoVersion, StringComparison.Ordinal))
                     {
                         // Found it.  Validate the version.
-                        string fileVersionFromHeader = line.Substring(slnFileHeaderNoVersion.Length);
+                        var fileVersionFromHeader =
+#if NET
+                            line.AsSpan(slnFileHeaderNoVersion.Length);
+#else
+                            line.Substring(slnFileHeaderNoVersion.Length);
+#endif
 
                         if (!System.Version.TryParse(fileVersionFromHeader, out Version version))
                         {
@@ -654,7 +672,8 @@ internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile
                 JsonDocumentOptions options = new JsonDocumentOptions() { AllowTrailingCommas = true, CommentHandling = JsonCommentHandling.Skip };
                 JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile), options);
                 solution = text.RootElement.GetProperty("solution");
-                return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile));
+                // We do NOT want to escape in order to preserve symbols like @, %, $ etc.
+                return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile), escape: false);
             }
             catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
             {
@@ -1056,7 +1075,7 @@ private void ParseProject(string firstLine)
                     {
                         // This should be a dependency.  The GUID identifying the parent project should
                         // be both the property name and the property value.
-                        Match match = s_crackPropertyLine.Value.Match(line);
+                        Match match = CrackPropertyLineRegex.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                             new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseProjectDepGuidError", proj.ProjectName);
 
@@ -1074,7 +1093,7 @@ private void ParseProject(string firstLine)
                     line = ReadLine();
                     while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
-                        Match match = s_crackPropertyLine.Value.Match(line);
+                        Match match = CrackPropertyLineRegex.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                             new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseWebProjectPropertiesError", proj.ProjectName);
 
@@ -1285,7 +1304,7 @@ private void ValidateProjectRelativePath(ProjectInSolution proj)
             ErrorUtilities.VerifyThrow(proj.RelativePath != null, "Project relative path cannot be null.");
 
             // Verify the relative path does not contain invalid characters
-            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj.RelativePath.IndexOfAny(Path.GetInvalidPathChars()) == -1,
+            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj.RelativePath.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) < 0,
               "SubCategoryForSolutionParsingErrors",
               new BuildEventFileInfo(FullPath, _currentLineNumber, 0),
               "SolutionParseInvalidProjectFileNameCharacters",
@@ -1352,7 +1371,13 @@ private static void ParseAspNetCompilerProperty(
                 string configurationName = propertyName.Substring(0, indexOfFirstDot);
 
                 // The rest of it is the actual property name.
-                string aspNetPropertyName = ((propertyName.Length - indexOfFirstDot) > 0) ? propertyName.Substring(indexOfFirstDot + 1, propertyName.Length - indexOfFirstDot - 1) : "";
+                var aspNetPropertyName = ((propertyName.Length - indexOfFirstDot) > 0) ?
+#if NET
+                    propertyName.AsSpan(indexOfFirstDot + 1) :
+#else
+                    propertyName.Substring(indexOfFirstDot + 1) :
+#endif
+                    "";
 
                 // And the part after the <equals> sign is the property value (which was parsed out for us prior
                 // to calling this method).
@@ -1387,49 +1412,19 @@ private static void ParseAspNetCompilerProperty(
                 }
 
                 // Update the appropriate field within the parameters struct.
-                if (aspNetPropertyName == "AspNetCompiler.VirtualPath")
-                {
-                    aspNetCompilerParameters.aspNetVirtualPath = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.PhysicalPath")
-                {
-                    aspNetCompilerParameters.aspNetPhysicalPath = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.TargetPath")
-                {
-                    aspNetCompilerParameters.aspNetTargetPath = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.ForceOverwrite")
-                {
-                    aspNetCompilerParameters.aspNetForce = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.Updateable")
-                {
-                    aspNetCompilerParameters.aspNetUpdateable = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.Debug")
-                {
-                    aspNetCompilerParameters.aspNetDebug = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.KeyFile")
-                {
-                    aspNetCompilerParameters.aspNetKeyFile = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.KeyContainer")
-                {
-                    aspNetCompilerParameters.aspNetKeyContainer = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.DelaySign")
-                {
-                    aspNetCompilerParameters.aspNetDelaySign = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.AllowPartiallyTrustedCallers")
-                {
-                    aspNetCompilerParameters.aspNetAPTCA = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.FixedNames")
-                {
-                    aspNetCompilerParameters.aspNetFixedNames = propertyValue;
+                switch (aspNetPropertyName)
+                {
+                    case "AspNetCompiler.VirtualPath": aspNetCompilerParameters.aspNetVirtualPath = propertyValue; break;
+                    case "AspNetCompiler.PhysicalPath": aspNetCompilerParameters.aspNetPhysicalPath = propertyValue; break;
+                    case "AspNetCompiler.TargetPath": aspNetCompilerParameters.aspNetTargetPath = propertyValue; break;
+                    case "AspNetCompiler.ForceOverwrite": aspNetCompilerParameters.aspNetForce = propertyValue; break;
+                    case "AspNetCompiler.Updateable": aspNetCompilerParameters.aspNetUpdateable = propertyValue; break;
+                    case "AspNetCompiler.Debug": aspNetCompilerParameters.aspNetDebug = propertyValue; break;
+                    case "AspNetCompiler.KeyFile": aspNetCompilerParameters.aspNetKeyFile = propertyValue; break;
+                    case "AspNetCompiler.KeyContainer": aspNetCompilerParameters.aspNetKeyContainer = propertyValue; break;
+                    case "AspNetCompiler.DelaySign": aspNetCompilerParameters.aspNetDelaySign = propertyValue; break;
+                    case "AspNetCompiler.AllowPartiallyTrustedCallers": aspNetCompilerParameters.aspNetAPTCA = propertyValue; break;
+                    case "AspNetCompiler.FixedNames": aspNetCompilerParameters.aspNetFixedNames = propertyValue; break;
                 }
 
                 // Store the updated parameters struct back into the hashtable by configuration name.
@@ -1506,7 +1501,7 @@ internal void ParseFirstProjectLine(
             string firstLine,
             ProjectInSolution proj)
         {
-            Match match = s_crackProjectLine.Value.Match(firstLine);
+            Match match = CrackProjectLineRegex.Match(firstLine);
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                 new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseProjectError");
 
@@ -1519,7 +1514,7 @@ internal void ParseFirstProjectLine(
             // This allows us to at least generate reasonable target names etc. instead of crashing.
             if (String.IsNullOrEmpty(proj.ProjectName))
             {
-                proj.ProjectName = "EmptyProjectName." + Guid.NewGuid();
+                proj.ProjectName = $"EmptyProjectName.{Guid.NewGuid()}";
             }
 
             // Validate project relative path
@@ -1606,7 +1601,7 @@ internal void ParseNestedProjects()
                     continue;
                 }
 
-                Match match = s_crackPropertyLine.Value.Match(str);
+                Match match = CrackPropertyLineRegex.Match(str);
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseNestedProjectError");
 
@@ -1765,16 +1760,14 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
                     {
                         // The "ActiveCfg" entry defines the active project configuration in the given solution configuration
                         // This entry must be present for every possible solution configuration/project combination.
-                        string entryNameActiveConfig = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.ActiveCfg",
-                            project.ProjectGuid, solutionConfiguration.FullName);
+                        string entryNameActiveConfig = $"{project.ProjectGuid}.{solutionConfiguration.FullName}.ActiveCfg";
 
                         // The "Build.0" entry tells us whether to build the project configuration in the given solution configuration.
                         // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial,
                         // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used).
                         // The configuration name is not used, and the whole entry means "build the project configuration"
                         // if it's present in the solution file, and "don't build" if it's not.
-                        string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0",
-                            project.ProjectGuid, solutionConfiguration.FullName);
+                        string entryNameBuild = $"{project.ProjectGuid}.{solutionConfiguration.FullName}.Build.0";
 
                         if (rawProjectConfigurationsEntries.TryGetValue(entryNameActiveConfig, out string configurationPlatform))
                         {
@@ -1900,6 +1893,6 @@ internal string GetProjectRelativePathByGuid(string projectGuid)
             return null;
         }
 
-        #endregion
+#endregion
     } // class SolutionFile
 } // namespace Microsoft.Build.Construction
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 760fcb390f3..e51789bbb38 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -860,7 +860,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             traversalProject.ToolsVersion = wrapperProjectToolsVersion;
             traversalProject.DefaultTargets = "Build";
             traversalProject.InitialTargets = "ValidateSolutionConfiguration;ValidateToolsVersions;ValidateProjects";
-            traversalProject.FullPath = _solutionFile.FullPath + ".metaproj";
+            traversalProject.FullPath = $"{_solutionFile.FullPath}.metaproj";
 
             // Add default solution configuration/platform names in case the user doesn't specify them on the command line
             AddConfigurationPlatformDefaults(traversalProject);
@@ -948,15 +948,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             // Add our local extensibility points to the project representing the solution
             // Imported at the top: before.mysolution.sln.targets
             // Imported at the bottom: after.mysolution.sln.targets
-            string escapedSolutionFile = EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath));
-            string escapedSolutionDirectory = EscapingUtilities.Escape(_solutionFile.SolutionFileDirectory);
-            string localFile = Path.Combine(escapedSolutionDirectory, "before." + escapedSolutionFile + ".targets");
-            ProjectImportElement importBeforeLocal = traversalProject.CreateImportElement(localFile);
-            importBeforeLocal.Condition = @"exists('" + localFile + "')";
-
-            localFile = Path.Combine(escapedSolutionDirectory, "after." + escapedSolutionFile + ".targets");
-            ProjectImportElement importAfterLocal = traversalProject.CreateImportElement(localFile);
-            importAfterLocal.Condition = @"exists('" + localFile + "')";
+            (ProjectImportElement importBeforeLocal, ProjectImportElement importAfterLocal) = CreateBeforeAndAfterSolutionImports(traversalProject);
 
             // Put locals second so they can override globals if they want
             traversalProject.PrependChild(importBeforeLocal);
@@ -990,7 +982,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             // For debugging purposes: some information is lost when evaluating into a project instance,
             // so make it possible to see what we have at this point.
             string path = traversalProject.FullPath;
-            string metaprojectPath = _solutionFile.FullPath + ".metaproj.tmp";
+            string metaprojectPath = $"{_solutionFile.FullPath}.metaproj.tmp";
             EmitMetaproject(traversalProject, metaprojectPath);
             traversalProject.FullPath = path;
 
@@ -1025,6 +1017,27 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             return traversalInstance;
         }
 
+        private (ProjectImportElement ImportBeforeSln, ProjectImportElement ImportAfterSln) CreateBeforeAndAfterSolutionImports(ProjectRootElement traversalProject)
+        {
+            string escapedSolutionFileName = EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath));
+            if (escapedSolutionFileName.EndsWith(".slnx"))
+            {
+                // We want to load only after.{solutionFileName}.sln.targets for solution files with .slnx extension
+                escapedSolutionFileName = escapedSolutionFileName.Substring(0, escapedSolutionFileName.Length - 1);
+            }
+
+            string escapedSolutionDirectory = EscapingUtilities.Escape(_solutionFile.SolutionFileDirectory);
+            string localFile = Path.Combine(escapedSolutionDirectory, $"before.{escapedSolutionFileName}.targets");
+            ProjectImportElement importBeforeLocal = traversalProject.CreateImportElement(localFile);
+            importBeforeLocal.Condition = $"exists('{localFile}')";
+
+            localFile = Path.Combine(escapedSolutionDirectory, $"after.{escapedSolutionFileName}.targets");
+            ProjectImportElement importAfterLocal = traversalProject.CreateImportElement(localFile);
+            importAfterLocal.Condition = $"exists('{localFile}')";
+
+            return (importBeforeLocal, importAfterLocal);
+        }
+
         private void EmitMetaproject(ProjectRootElement metaproject, string path)
         {
             if (Traits.Instance.EmitSolutionMetaproj)
@@ -1336,7 +1349,7 @@ private static void AddMetaprojectTargetForManagedProject(ProjectInstance traver
             string outputItemAsItem = null;
             if (!String.IsNullOrEmpty(outputItem))
             {
-                outputItemAsItem = "@(" + outputItem + ")";
+                outputItemAsItem = $"@({outputItem})";
             }
 
             ProjectTargetInstance target = metaprojectInstance.AddTarget(targetName ?? "Build", String.Empty, String.Empty, outputItemAsItem, null, String.Empty, String.Empty, String.Empty, String.Empty, false /* legacy target returns behaviour */);
@@ -1383,7 +1396,7 @@ private static void AddProjectBuildTask(ProjectInstance traversalProject, Projec
         /// </summary>
         private void AddMetaprojectBuildTask(ProjectInSolution project, ProjectTargetInstance target, string targetToBuild, string outputItem)
         {
-            ProjectTaskInstance task = target.AddTask("MSBuild", Strings.WeakIntern("'%(ProjectReference.Identity)' == '" + GetMetaprojectName(project) + "'"), String.Empty);
+            ProjectTaskInstance task = target.AddTask("MSBuild", Strings.WeakIntern($"'%(ProjectReference.Identity)' == '{GetMetaprojectName(project)}'"), String.Empty);
             task.SetParameter("Projects", "@(ProjectReference)");
 
             if (targetToBuild != null)
@@ -1966,7 +1979,7 @@ private static void AddTraversalReferencesTarget(ProjectInstance traversalProjec
             string outputItemAsItem = null;
             if (!String.IsNullOrEmpty(outputItem))
             {
-                outputItemAsItem = "@(" + outputItem + ")";
+                outputItemAsItem = $"@({outputItem})";
             }
 
             string correctedTargetName = targetName ?? "Build";
@@ -2039,13 +2052,13 @@ private void AddTraversalTargetForProject(ProjectInstance traversalProject, Proj
             if (!String.IsNullOrEmpty(outputItem))
             {
                 outputItemName = MakeIntoSafeItemName(baseProjectName) + outputItem;
-                outputItemAsItem = "@(" + outputItemName + ")";
+                outputItemAsItem = $"@({outputItemName})";
             }
 
             ProjectTargetInstance targetElement = traversalProject.AddTarget(actualTargetName, null, null, outputItemAsItem, null, null, null, null, null, false /* legacy target returns behaviour */);
             if (canBuildDirectly)
             {
-                AddProjectBuildTask(traversalProject, projectConfiguration, targetElement, targetToBuild, "@(ProjectReference)", "'%(ProjectReference.Identity)' == '" + EscapingUtilities.Escape(project.AbsolutePath) + "'", outputItemName);
+                AddProjectBuildTask(traversalProject, projectConfiguration, targetElement, targetToBuild, "@(ProjectReference)", $"'%(ProjectReference.Identity)' == '{EscapingUtilities.Escape(project.AbsolutePath)}'", outputItemName);
             }
             else
             {
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 2401d4935a1..23b235e5ad0 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Diagnostics;
@@ -56,7 +57,12 @@ public class Project : ILinkableObject
         /// <summary>
         /// * and ? are invalid file name characters, but they occur in globs as wild cards.
         /// </summary>
-        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c != '/' && c != '\\' && c != ':').ToArray();
+#if NET
+        private static readonly SearchValues<char> s_invalidGlobChars = SearchValues.Create(
+#else
+        private static readonly char[] s_invalidGlobChars = (
+#endif
+            FileUtilities.InvalidFileNameCharsArray.Where(c => c is not ('*' or '?' or '/' or '\\' or ':')).ToArray());
 
         /// <summary>
         /// Context to log messages and events in.
@@ -2618,7 +2624,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
             {
                 var includeItemspec = new EvaluationItemSpec(itemElement.Include, _data.Expander, itemElement.IncludeLocation, itemElement.ContainingProject.DirectoryPath);
 
-                ImmutableArray<ItemSpecFragment> includeGlobFragments = includeItemspec.Fragments.Where(f => f is GlobFragment && f.TextFragment.IndexOfAny(s_invalidGlobChars) == -1).ToImmutableArray();
+                ItemSpecFragment[] includeGlobFragments = includeItemspec.Fragments.Where(f => f is GlobFragment && f.TextFragment.AsSpan().IndexOfAny(s_invalidGlobChars) < 0).ToArray();
                 if (includeGlobFragments.Length == 0)
                 {
                     return null;
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index eb461785d00..204de4952f8 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -207,7 +207,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyD
         protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os)
         {
             Dictionary<string, ProjectImportPathMatch> kindToPathsCache;
-            var key = toolsVersion + ":" + os;
+            var key = $"{toolsVersion}:{os}";
             if (_projectImportSearchPathsCache.TryGetValue(key, out kindToPathsCache))
             {
                 return kindToPathsCache;
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index fdc817b930c..2f3ca882084 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -686,22 +686,26 @@ private MSBuildExtensionsPathReferenceKind(string value)
         /// </summary>
         public static MSBuildExtensionsPathReferenceKind FindIn(string expression)
         {
-            if (expression.IndexOf("$(MSBuildExtensionsPath)") >= 0)
+            const string PathBase = "$(MSBuildExtensionsPath";
+            int pos = expression.IndexOf(PathBase, StringComparison.Ordinal);
+            if (pos >= 0)
             {
-                return MSBuildExtensionsPathReferenceKind.Default;
-            }
-
-            if (expression.IndexOf("$(MSBuildExtensionsPath32)") >= 0)
-            {
-                return MSBuildExtensionsPathReferenceKind.Path32;
-            }
-
-            if (expression.IndexOf("$(MSBuildExtensionsPath64)") >= 0)
-            {
-                return MSBuildExtensionsPathReferenceKind.Path64;
+                ReadOnlySpan<char> remainder = expression.AsSpan(pos + PathBase.Length);
+                if (remainder.StartsWith(")".AsSpan()))
+                {
+                    return Default;
+                }
+                else if (remainder.StartsWith("32)".AsSpan()))
+                {
+                    return Path32;
+                }
+                else if (remainder.StartsWith("64)".AsSpan()))
+                {
+                    return Path64;
+                }
             }
 
-            return MSBuildExtensionsPathReferenceKind.None;
+            return None;
         }
     }
 }
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 8ca5594c946..29879ac6180 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -25,7 +25,7 @@ public abstract class ElementLocation : IElementLocation, ITranslatable, IImmuta
         /// <summary>
         /// The singleton empty element location.
         /// </summary>
-        private static ElementLocation s_emptyElementLocation = new SmallElementLocation(null, 0, 0);
+        private static readonly ElementLocation s_emptyElementLocation = new SmallElementLocation(null, 0, 0);
 
         /// <summary>
         /// The file from which this particular element originated.  It may
@@ -214,7 +214,7 @@ private static string GetLocationString(string file, int line, int column)
             }
             else if (line != 0)
             {
-                locationString = file + " (" + line + ")";
+                locationString = $"{file} ({line})";
             }
             else
             {
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index cfa910da6a8..eb8c3356873 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -27,7 +27,7 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// <summary>
         /// Used to cache tag names in loaded files.
         /// </summary>
-        private static NameTable s_nameTable = new XmlNameTableThreadSafe();
+        private static readonly NameTable s_nameTable = new XmlNameTableThreadSafe();
 
         /// <summary>
         /// Whether we can selectively load as read-only (eg just when in program files directory)
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 67455f8b4c4..f6a5f70330f 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -166,7 +166,7 @@ public ConcurrentStack<GenericExpressionNode> GetOrAdd(string condition, Func<st
         }
 
         // Cached expression trees for all the combinations of condition strings and parser options
-        private static volatile ConcurrentDictionary<int, ExpressionTreeForCurrentOptionsWithSize> s_cachedExpressionTrees = new ConcurrentDictionary<int, ExpressionTreeForCurrentOptionsWithSize>();
+        private static readonly ConcurrentDictionary<int, ExpressionTreeForCurrentOptionsWithSize> s_cachedExpressionTrees = new ConcurrentDictionary<int, ExpressionTreeForCurrentOptionsWithSize>();
 
         /// <summary>
         /// For debugging leaks, a way to disable caching expression trees, to reduce noise
diff --git a/src/Build/Evaluation/Conditionals/CharacterUtilities.cs b/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
index 06e7345b1b0..ed5502e91ca 100644
--- a/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
+++ b/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
@@ -22,15 +22,9 @@ internal static bool IsSimpleStringChar(char candidate)
             return IsSimpleStringStart(candidate) || char.IsDigit(candidate);
         }
 
-        internal static bool IsHexAlphabetic(char candidate)
-        {
-            return candidate == 'a' || candidate == 'b' || candidate == 'c' || candidate == 'd' || candidate == 'e' || candidate == 'f' ||
-                candidate == 'A' || candidate == 'B' || candidate == 'C' || candidate == 'D' || candidate == 'E' || candidate == 'F';
-        }
-
         internal static bool IsHexDigit(char candidate)
         {
-            return char.IsDigit(candidate) || IsHexAlphabetic(candidate);
+            return char.IsDigit(candidate) || ((uint)((candidate | 0x20) - 'a') <= 'f' - 'a');
         }
     }
 }
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index a9d31698a28..718ae73d23d 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -692,11 +692,11 @@ private bool ParseRemaining()
         private bool ParseSimpleStringOrFunction(int start)
         {
             SkipSimpleStringChars();
-            if (string.Equals(_expression.Substring(start, _parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
+            if (_expression.AsSpan(start, _parsePoint - start).Equals("and".AsSpan(), StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.And;
             }
-            else if (string.Equals(_expression.Substring(start, _parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
+            else if (_expression.AsSpan(start, _parsePoint - start).Equals("or".AsSpan(), StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.Or;
             }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index cba4152a3fc..598c949ec54 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -809,7 +809,7 @@ private void Evaluate()
                             {
                                 if (!String.Equals(entry.Name, "currentsolutionconfigurationcontents", StringComparison.OrdinalIgnoreCase))
                                 {
-                                    propertyDump += entry.Name + "=" + entry.EvaluatedValue + "\n";
+                                    propertyDump += $"{entry.Name}={entry.EvaluatedValue}\n";
                                 }
                             }
 
@@ -1886,19 +1886,17 @@ static string EvaluateProperty(string value, IElementLocation location,
         // Creates a project to set the properties and include the items from an SdkResult
         private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
         {
-            int propertiesAndItemsHash;
-
-#if NETCOREAPP
-            HashCode hash = new HashCode();
+#if NET
+            HashCode hash = default;
 #else
-            propertiesAndItemsHash = -849885975;
+            int propertiesAndItemsHash = -849885975;
 #endif
 
             if (sdkResult.PropertiesToAdd != null)
             {
                 foreach (var property in sdkResult.PropertiesToAdd)
                 {
-#if NETCOREAPP
+#if NET
                     hash.Add(property.Key);
                     hash.Add(property.Value);
 #else
@@ -1911,7 +1909,7 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
             {
                 foreach (var item in sdkResult.ItemsToAdd)
                 {
-#if NETCOREAPP
+#if NET
                     hash.Add(item.Key);
                     hash.Add(item.Value);
 #else
@@ -1922,12 +1920,12 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
                 }
             }
 
-#if NETCOREAPP
-            propertiesAndItemsHash = hash.ToHashCode();
+#if NET
+            int propertiesAndItemsHash = hash.ToHashCode();
 #endif
 
             // Generate a unique filename for the generated project for each unique set of properties and items.
-            string projectPath = _projectRootElement.FullPath + ".SdkResolver." + propertiesAndItemsHash + ".proj";
+            string projectPath = $"{_projectRootElement.FullPath}.SdkResolver.{propertiesAndItemsHash}.proj";
 
             ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
             {
@@ -2136,7 +2134,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                         // If neither file involved is the project itself, append its path in square brackets
                         if (previouslyImportedAt.ContainingProject != _projectRootElement && importElement.ContainingProject != _projectRootElement)
                         {
-                            parenthesizedProjectLocation = "[" + _projectRootElement.FullPath + "]";
+                            parenthesizedProjectLocation = $"[{_projectRootElement.FullPath}]";
                         }
                         // TODO: Detect if the duplicate import came from an SDK attribute
                         _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(importLocationInProject), "DuplicateImport", importFileUnescaped, previouslyImportedAt.Location.LocationString, parenthesizedProjectLocation);
@@ -2577,7 +2575,7 @@ private void SetAllProjectsProperty()
             if (_lastModifiedProject != null)
             {
                 P oldValue = _data.GetProperty(Constants.MSBuildAllProjectsPropertyName);
-                string streamImports = string.Join(";", _streamImports.ToArray());
+                string streamImports = string.Join(";", _streamImports);
                 _data.SetProperty(
                     Constants.MSBuildAllProjectsPropertyName,
                     oldValue == null
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 84b34d5c67a..7397dee024f 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -28,6 +28,7 @@
 using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
+using System.Buffers;
 
 #nullable disable
 
@@ -279,17 +280,11 @@ private void FlushFirstValueIfNeeded()
         private static readonly char[] s_backtickChar = { '`' };
         private static readonly char[] s_doubleQuoteChar = { '"' };
 
-        /// <summary>
-        /// Those characters which indicate that an expression may contain expandable
-        /// expressions.
-        /// </summary>
-        private static char[] s_expandableChars = { '$', '%', '@' };
-
         /// <summary>
         /// The CultureInfo from the invariant culture. Used to avoid allocations for
         /// performing IndexOf etc.
         /// </summary>
-        private static CompareInfo s_invariantCompareInfo = CultureInfo.InvariantCulture.CompareInfo;
+        private static readonly CompareInfo s_invariantCompareInfo = CultureInfo.InvariantCulture.CompareInfo;
 
         /// <summary>
         /// Properties to draw on for expansion.
@@ -454,7 +449,7 @@ internal PropertiesUseTracker PropertiesUseTracker
         /// </summary>
         internal static bool ExpressionMayContainExpandableExpressions(string expression)
         {
-            return expression.IndexOfAny(s_expandableChars) > -1;
+            return expression.AsSpan().IndexOfAny('$', '%', '@') >= 0;
         }
 
         /// <summary>
@@ -1110,7 +1105,12 @@ _metadata is IItemTypeDefinition itemMetadata &&
 
                         if (IsTruncationEnabled(_options) && metadataValue.Length > CharacterLimitPerExpansion)
                         {
-                            metadataValue = metadataValue.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                            metadataValue =
+#if NET
+                                $"{metadataValue.AsSpan(0, CharacterLimitPerExpansion - 3)}...";
+#else
+                                $"{metadataValue.Substring(0, CharacterLimitPerExpansion - 3)}...";
+#endif
                         }
                     }
 
@@ -1313,7 +1313,12 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                                 var value = propertyValue.ToString();
                                 if (value.Length > CharacterLimitPerExpansion)
                                 {
-                                    propertyValue = value.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                                    propertyValue =
+#if NET
+                                        $"{value.AsSpan(0, CharacterLimitPerExpansion - 3)}...";
+#else
+                                        $"{value.Substring(0, CharacterLimitPerExpansion - 3)}...";
+#endif
                                 }
                             }
 
@@ -1730,7 +1735,7 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
                     }
                     catch (Exception ex) when (!ExceptionHandling.NotExpectedRegistryException(ex))
                     {
-                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidRegistryPropertyExpression", "$(" + registryExpression + ")", ex.Message);
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidRegistryPropertyExpression", $"$({registryExpression})", ex.Message);
                     }
                 }
 
@@ -1858,7 +1863,7 @@ internal static ExpressionShredder.ItemExpressionCapture ExpandSingleItemVectorE
                 }
 
                 List<ExpressionShredder.ItemExpressionCapture> matches;
-                if (expression.IndexOf('@') == -1)
+                if (!expression.Contains('@'))
                 {
                     return null;
                 }
@@ -2239,7 +2244,7 @@ internal static class IntrinsicItemFunctions<S>
                 /// <summary>
                 /// A cache of previously created item function delegates.
                 /// </summary>
-                private static ConcurrentDictionary<string, ItemTransformFunction> s_transformFunctionDelegateCache = new ConcurrentDictionary<string, ItemTransformFunction>(StringComparer.OrdinalIgnoreCase);
+                private static readonly ConcurrentDictionary<string, ItemTransformFunction> s_transformFunctionDelegateCache = new ConcurrentDictionary<string, ItemTransformFunction>(StringComparer.OrdinalIgnoreCase);
 
                 /// <summary>
                 /// Delegate that represents the signature of all item transformation functions
@@ -2254,7 +2259,7 @@ internal static class IntrinsicItemFunctions<S>
                 internal static ItemTransformFunction GetItemTransformFunction(IElementLocation elementLocation, string functionName, Type itemType)
                 {
                     ItemTransformFunction transformFunction = null;
-                    string qualifiedFunctionName = itemType.FullName + "::" + functionName;
+                    string qualifiedFunctionName = $"{itemType.FullName}::{functionName}";
 
                     // We may have seen this delegate before, if so grab the one we already created
                     if (!s_transformFunctionDelegateCache.TryGetValue(qualifiedFunctionName, out transformFunction))
@@ -2631,7 +2636,7 @@ internal static IEnumerable<KeyValuePair<string, S>> Metadata(Expander<P, I> exp
                             {
                                 // It may be that the itemspec has unescaped ';'s in it so we need to split here to handle
                                 // that case.
-                                if (metadataValue.IndexOf(';') >= 0)
+                                if (metadataValue.Contains(';'))
                                 {
                                     var splits = ExpressionShredder.SplitSemiColonSeparatedList(metadataValue);
 
@@ -3095,36 +3100,23 @@ private static partial class RegularExpressions
             * description of an item vector changes, the expressions must be updated in both places.
             *************************************************************************************************************************/
 
-
-
-#if NET7_0_OR_GREATER
+#if NET
             [GeneratedRegex(ItemMetadataSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture)]
-            internal static partial Regex ItemMetadataPattern();
+            internal static partial Regex ItemMetadataRegex { get; }
 #else
             /// <summary>
             /// Regular expression used to match item metadata references embedded in strings.
             /// For example, %(Compile.DependsOn) or %(DependsOn).
             /// </summary>
-            internal static readonly Lazy<Regex> ItemMetadataPattern = new Lazy<Regex>(
-                () => new Regex(ItemMetadataSpecification,
-                    RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
-#endif
+            internal static Regex ItemMetadataRegex => s_itemMetadataRegex ??=
+                new Regex(ItemMetadataSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
 
-            internal static Regex ItemMetadataRegex
-            {
-                get
-                {
-#if NET7_0_OR_GREATER
-                    return ItemMetadataPattern();
-#else
-                    return ItemMetadataPattern.Value;
+            internal static Regex s_itemMetadataRegex;
 #endif
-                }
-            }
 
-                /// <summary>
-                /// Name of the group matching the "name" of a metadatum.
-                /// </summary>
+            /// <summary>
+            /// Name of the group matching the "name" of a metadatum.
+            /// </summary>
             internal const string NameGroup = "NAME";
 
             /// <summary>
@@ -3143,29 +3135,19 @@ internal static Regex ItemMetadataRegex
                                                                 ItemVectorWithTransformLHS + @")" + ItemMetadataSpecification + @"(?!" +
                                                                 ItemVectorWithTransformRHS + @"))";
 
-#if NET7_0_OR_GREATER
+#if NET
             [GeneratedRegex(NonTransformItemMetadataSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture)]
-            internal static partial Regex NonTransformItemMetadataPattern();
+            internal static partial Regex NonTransformItemMetadataRegex { get; }
 #else
             /// <summary>
             /// regular expression used to match item metadata references outside of item vector transforms.
             /// </summary>
             /// <remarks>PERF WARNING: this Regex is complex and tends to run slowly.</remarks>
-            internal static readonly Lazy<Regex> NonTransformItemMetadataPattern = new Lazy<Regex>(
-                () => new Regex(NonTransformItemMetadataSpecification,
-                                RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
-#endif
-            internal static Regex NonTransformItemMetadataRegex
-            {
-                get
-                {
-#if NET7_0_OR_GREATER
-                    return NonTransformItemMetadataPattern();
-#else
-                    return NonTransformItemMetadataPattern.Value;
+            private static Regex s_nonTransformItemMetadataPattern;
+
+            internal static Regex NonTransformItemMetadataRegex => s_nonTransformItemMetadataPattern ??=
+                new Regex(NonTransformItemMetadataSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
 #endif
-                }
-            }
 
             /// <summary>
             /// Complete description of an item metadata reference, including the optional qualifying item type.
@@ -4114,8 +4096,8 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                         else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains("."))
                         {
                             Type enumType = parameters[n].ParameterType;
-                            string typeLeafName = enumType.Name + ".";
-                            string typeFullName = enumType.FullName + ".";
+                            string typeLeafName = $"{enumType.Name}.";
+                            string typeFullName = $"{enumType.FullName}.";
 
                             // Enum.parse expects commas between enum components
                             // We'll support the C# type | syntax too
@@ -4200,11 +4182,11 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
                     }
                     if ((_bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                     {
-                        return "[" + typeName + "]::" + name + "(" + parameters + ")";
+                        return $"[{typeName}]::{name}({parameters})";
                     }
                     else
                     {
-                        return "[" + typeName + "]::" + name;
+                        return $"[{typeName}]::{name}";
                     }
                 }
                 else
@@ -4213,11 +4195,11 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
 
                     if ((_bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                     {
-                        return propertyValue + "." + name + "(" + parameters + ")";
+                        return $"{propertyValue}.{name}({parameters})";
                     }
                     else
                     {
-                        return propertyValue + "." + name;
+                        return $"{propertyValue}.{name}";
                     }
                 }
             }
diff --git a/src/Build/Evaluation/Expander/WellKnownFunctions.cs b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
index 72f8b247933..bc7a74e0a74 100644
--- a/src/Build/Evaluation/Expander/WellKnownFunctions.cs
+++ b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
@@ -236,7 +236,7 @@ internal static bool TryExecuteStringFunction(string methodName, out object? ret
             {
                 if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
                 {
-                    returnVal = text.IndexOfAny(arg0.ToCharArray());
+                    returnVal = text.AsSpan().IndexOfAny(arg0.AsSpan());
                     return true;
                 }
             }
@@ -262,7 +262,7 @@ internal static bool TryExecuteStringFunction(string methodName, out object? ret
             {
                 if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
                 {
-                    returnVal = text.LastIndexOfAny(arg0.ToCharArray());
+                    returnVal = text.AsSpan().LastIndexOfAny(arg0.AsSpan());
                     return true;
                 }
             }
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index fd102dff143..a7d9e48b9a5 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -428,7 +428,7 @@ private static void GetReferencedItemNamesAndMetadata(string expression, int sta
 
                         itemName = firstPart;
                         metadataName = expression.Substring(startOfText, i - startOfText);
-                        qualifiedMetadataName = itemName + "." + metadataName;
+                        qualifiedMetadataName = $"{itemName}.{metadataName}";
                     }
                     else
                     {
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 032f95a251c..7d6b051cf99 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -22,6 +22,8 @@
 
 // Needed for DoesTaskHostExistForParameters
 using NodeProviderOutOfProcTaskHost = Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost;
+using System.Security.Cryptography;
+using System.Buffers.Text;
 
 #nullable disable
 
@@ -40,25 +42,14 @@ internal static partial class IntrinsicFunctions
         private static readonly object[] DefaultRegistryViews = [RegistryView.Default];
 #pragma warning restore CA1416
 
-#if NET7_0_OR_GREATER
+#if NET
         [GeneratedRegex(RegistrySdkSpecification, RegexOptions.IgnoreCase)]
-        private static partial Regex RegistrySdkPattern();
+        private static partial Regex RegistrySdkRegex { get; }
 #else
-        private static readonly Lazy<Regex> RegistrySdkPattern = new Lazy<Regex>(() => new Regex(RegistrySdkSpecification, RegexOptions.IgnoreCase));
+        private static Regex s_registrySdkRegex;
+        private static Regex RegistrySdkRegex => s_registrySdkRegex ??= new Regex(RegistrySdkSpecification, RegexOptions.IgnoreCase);
 #endif
 
-        private static Regex RegistrySdkRegex
-        {
-            get
-            {
-#if NET7_0_OR_GREATER
-                return RegistrySdkPattern();
-#else
-                return RegistrySdkPattern.Value;
-#endif
-            }
-        }
-
         private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => NuGetFrameworkWrapper.CreateInstance());
 
         /// <summary>
@@ -284,8 +275,8 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
             {
                 if (viewObject is string viewAsString)
                 {
-                    string typeLeafName = typeof(RegistryView).Name + ".";
-                    string typeFullName = typeof(RegistryView).FullName + ".";
+                    string typeLeafName = $"{typeof(RegistryView).Name}.";
+                    string typeFullName = $"{typeof(RegistryView).FullName}.";
 
                     // We'll allow the user to specify the leaf or full type name on the RegistryView enum
                     viewAsString = viewAsString.Replace(typeFullName, "").Replace(typeLeafName, "");
@@ -466,7 +457,12 @@ internal static object StableStringHash(string toHash, StringHashingAlgorithm al
 
         private static string CalculateSha256(string toHash)
         {
-            using var sha = System.Security.Cryptography.SHA256.Create();
+#if NET
+            Span<byte> hash = stackalloc byte[SHA256.HashSizeInBytes];
+            SHA256.HashData(Encoding.UTF8.GetBytes(toHash), hash);
+            return Convert.ToHexStringLower(hash);
+#else
+            using var sha = SHA256.Create();
             var hashResult = new StringBuilder();
             foreach (byte theByte in sha.ComputeHash(Encoding.UTF8.GetBytes(toHash)))
             {
@@ -474,6 +470,7 @@ private static string CalculateSha256(string toHash)
             }
 
             return hashResult.ToString();
+#endif
         }
 
         /// <summary>
@@ -651,14 +648,15 @@ internal static string SubstringByAsciiChars(string input, int start, int length
             {
                 return string.Empty;
             }
+
             if (start + length > input.Length)
             {
                 length = input.Length - start;
             }
+
             StringBuilder sb = new StringBuilder();
-            for (int i = start; i < start + length; i++)
+            foreach (char c in input.AsSpan(start, length))
             {
-                char c = input[i];
                 if (c >= 32 && c <= 126 && !FileUtilities.InvalidFileNameChars.Contains(c))
                 {
                     sb.Append(c);
@@ -668,6 +666,7 @@ internal static string SubstringByAsciiChars(string input, int start, int length
                     sb.Append('_');
                 }
             }
+
             return sb.ToString();
         }
 
@@ -804,7 +803,7 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
             }
             else
             {
-                subKeyName = keyName.Substring(i + 1, keyName.Length - i - 1);
+                subKeyName = keyName.Substring(i + 1);
             }
 
             return basekey;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index 771b0e6ce40..51d91cce6d7 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -29,7 +29,7 @@ public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToReferencedItems");
 
-                if (_matchOnMetadata.Any())
+                if (!_matchOnMetadata.IsEmpty)
                 {
                     _metadataSet = new MetadataTrie<P, I>(builder.MatchOnMetadataOptions, _matchOnMetadata, _itemSpec);
                 }
@@ -48,7 +48,7 @@ protected override void ApplyImpl(OrderedItemDataCollection.Builder listBuilder,
                     return;
                 }
 
-                bool matchingOnMetadata = _matchOnMetadata.Any();
+                bool matchingOnMetadata = !_matchOnMetadata.IsEmpty;
                 if (!matchingOnMetadata)
                 {
                     if (ItemspecContainsASingleBareItemReference(_itemSpec, _itemElement.ItemType))
diff --git a/src/Build/Evaluation/Preprocessor.cs b/src/Build/Evaluation/Preprocessor.cs
index 0d38472e450..d70e8327285 100644
--- a/src/Build/Evaluation/Preprocessor.cs
+++ b/src/Build/Evaluation/Preprocessor.cs
@@ -26,6 +26,9 @@ namespace Microsoft.Build.Evaluation
     /// </remarks>
     internal class Preprocessor
     {
+        /// <summary>140 equal signs.</summary>
+        private const string Equals140 = "============================================================================================================================================";
+
         /// <summary>
         /// Project to preprocess
         /// </summary>
@@ -99,7 +102,7 @@ private XmlDocument Preprocess()
 
             if (!String.IsNullOrEmpty(_project.FullPath)) // Ignore in-memory projects
             {
-                destinationDocument.AppendChild(destinationDocument.CreateComment("\r\n" + new String('=', 140) + "\r\n" + _project.FullPath.Replace("--", "__") + "\r\n" + new String('=', 140) + "\r\n"));
+                destinationDocument.AppendChild(destinationDocument.CreateComment($"\r\n{Equals140}\r\n{_project.FullPath.Replace("--", "__")}\r\n{Equals140}\r\n"));
             }
 
             CloneChildrenResolvingImports(outerDocument, destinationDocument);
@@ -310,7 +313,7 @@ private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination)
                         }
 
                         destination.AppendChild(destinationDocument.CreateComment(
-                            $"\r\n{new String('=', 140)}\r\n{importTag}\r\n\r\n{resolved.FullPath.Replace("--", "__")}\r\n{new String('=', 140)}\r\n"));
+                            $"\r\n{Equals140}\r\n{importTag}\r\n\r\n{resolved.FullPath.Replace("--", "__")}\r\n{Equals140}\r\n"));
 
                         _filePaths.Push(resolved.FullPath);
                         CloneChildrenResolvingImports(innerDocument, destination);
@@ -318,11 +321,11 @@ private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination)
 
                         if (i < resolvedList.Count - 1)
                         {
-                            destination.AppendChild(destinationDocument.CreateComment("\r\n" + new String('=', 140) + "\r\n  </Import>\r\n" + new String('=', 140) + "\r\n"));
+                            destination.AppendChild(destinationDocument.CreateComment($"\r\n{Equals140}\r\n  </Import>\r\n{Equals140}\r\n"));
                         }
                         else
                         {
-                            destination.AppendChild(destinationDocument.CreateComment("\r\n" + new String('=', 140) + "\r\n  </Import>\r\n\r\n" + _filePaths.Peek()?.Replace("--", "__") + "\r\n" + new String('=', 140) + "\r\n"));
+                            destination.AppendChild(destinationDocument.CreateComment($"\r\n{Equals140}\r\n  </Import>\r\n\r\n{_filePaths.Peek()?.Replace("--", "__")}\r\n{Equals140}\r\n"));
                         }
                     }
 
@@ -339,7 +342,7 @@ private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination)
 
                     CloneChildrenResolvingImports(child, destination);
 
-                    destination.AppendChild(destinationDocument.CreateComment("</" + XMakeElements.importGroup + ">"));
+                    destination.AppendChild(destinationDocument.CreateComment($"</{XMakeElements.importGroup}>"));
 
                     continue;
                 }
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs b/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
index 065f756fede..99f4bfdf8c6 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
@@ -38,14 +38,19 @@ protected override string NormalizeExpression(string description, EvaluationLoca
                 return null;
             }
 
-            text = text.Replace(Separator, "\\" + Separator);
+            text = text.Replace(Separator, $"\\{Separator}");
 
             if (text.Length > 100)
             {
-                text = text.Remove(100) + "...";
+                text =
+#if NET
+                    $"{text.AsSpan(0, 100)}...";
+#else
+                    $"{text.Remove(100)}...";
+#endif
             }
 
-            return '`' + text + '`';
+            return $"`{text}`";
         }
     }
 }
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
index a1e8dc7f30d..ea8876e874f 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
@@ -65,7 +65,7 @@ protected static string GetElementOrConditionText(string description, Evaluation
             var outerXml = description;
             outerXml = outerXml.Replace(@"xmlns=""http://schemas.microsoft.com/developer/msbuild/2003""", "");
 
-            var newLineIndex = outerXml.IndexOfAny(['\r', '\n']);
+            var newLineIndex = outerXml.AsSpan().IndexOfAny('\r', '\n');
             return newLineIndex == -1 ? outerXml : outerXml.Remove(newLineIndex);
         }
 
@@ -74,9 +74,19 @@ protected static string GetElementOrConditionText(string description, Evaluation
         /// </summary>
         protected void AppendDefaultHeaderWithSeparator(StringBuilder stringBuilder, string separator)
         {
-            stringBuilder.AppendLine(
-                string.Join(separator, "Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
-                        "Exc (%)", "#", "Kind", "Bug"));
+            stringBuilder.Append("Id").Append(separator)
+                         .Append("ParentId").Append(separator)
+                         .Append("Pass").Append(separator)
+                         .Append("File").Append(separator)
+                         .Append("Line #").Append(separator)
+                         .Append("Expression").Append(separator)
+                         .Append("Inc (ms)").Append(separator)
+                         .Append("Inc (%)").Append(separator)
+                         .Append("Exc (ms)").Append(separator)
+                         .Append("Exc (%)").Append(separator)
+                         .Append('#').Append(separator)
+                         .Append("Kind").Append(separator)
+                         .Append("Bug").AppendLine();
         }
 
         /// <summary>
@@ -92,9 +102,9 @@ protected void AppendDefaultLocationWithSeparator(StringBuilder stringBuilder, T
                 evaluationLocation.Line?.ToString() ?? string.Empty,
                 NormalizeExpression(evaluationLocation.ElementDescription, evaluationLocation.Kind) ?? string.Empty,
                 GetMilliseconds(profiledLocation.InclusiveTime),
-                GetPercentage(totalTime, profiledLocation.InclusiveTime) + "%",
+                $"{GetPercentage(totalTime, profiledLocation.InclusiveTime)}%",
                 GetMilliseconds(profiledLocation.ExclusiveTime),
-                GetPercentage(totalTime, profiledLocation.ExclusiveTime) + "%",
+                $"{GetPercentage(totalTime, profiledLocation.ExclusiveTime)}%",
                 profiledLocation.NumberOfHits,
                 evaluationLocation.Kind + separator));
         }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 3427a49260d..a71a572677d 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -577,7 +577,7 @@ private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation el
             // Orcas compat: all target names are automatically unescaped
             string targetName = EscapingUtilities.UnescapeAll(ProjectXmlUtilities.GetAttributeValue(element, XMakeAttributes.name));
 
-            int indexOfSpecialCharacter = targetName.IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
+            int indexOfSpecialCharacter = targetName.AsSpan().IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
             if (indexOfSpecialCharacter >= 0)
             {
                 ProjectErrorUtilities.ThrowInvalidProject(element.GetAttributeLocation(XMakeAttributes.name), "NameInvalid", targetName, targetName[indexOfSpecialCharacter]);
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index d70e5648f3e..30e364ae5bd 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -79,7 +79,7 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// <summary>
         /// Whether the cache should log activity to the Debug.Out stream
         /// </summary>
-        private static bool s_debugLogCacheActivity = Environment.GetEnvironmentVariable("MSBUILDDEBUGXMLCACHE") == "1";
+        private static readonly bool s_debugLogCacheActivity = Environment.GetEnvironmentVariable("MSBUILDDEBUGXMLCACHE") == "1";
 
         /// <summary>
         /// Whether the cache should check file content for cache entry invalidation.
@@ -87,7 +87,7 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// <remarks>
         /// Value shall be true only in case of testing. Outside QA tests it shall be false.
         /// </remarks>
-        private static bool s_heckFileContent = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDCACHECHECKFILECONTENT"));
+        private static readonly bool s_heckFileContent = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDCACHECHECKFILECONTENT"));
 
 #if DEBUG
         /// <summary>
@@ -100,7 +100,7 @@ private struct ReentrancyGuard : IDisposable
             /// Shall be always 0 or 1. Reentrance to the Get function (value > 1) could lead to race condition.
             /// </summary>
             [ThreadStatic]
-            private static int s_getEntriesNumber = 0;
+            private static int s_getEntriesNumber;
 
             public ReentrancyGuard()
             {
@@ -674,7 +674,7 @@ private void DebugTraceCache(string message, string param1)
             if (s_debugLogCacheActivity)
             {
                 string prefix = OutOfProcNode.IsOutOfProcNode ? "C" : "P";
-                Trace.WriteLine(prefix + " " + EnvironmentUtilities.CurrentProcessId + " | " + message + param1);
+                Trace.WriteLine($"{prefix} {Process.GetCurrentProcess().Id} | {message}{param1}");
             }
         }
     }
diff --git a/src/Build/Evaluation/StringMetadataTable.cs b/src/Build/Evaluation/StringMetadataTable.cs
index 5e920a99c23..277c5d829d9 100644
--- a/src/Build/Evaluation/StringMetadataTable.cs
+++ b/src/Build/Evaluation/StringMetadataTable.cs
@@ -69,7 +69,7 @@ public string GetEscapedValueIfPresent(string itemType, string name)
             }
             else
             {
-                key = itemType + "." + name;
+                key = $"{itemType}.{name}";
             }
 
             string value;
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index e6cb8ab1ac5..38915e44cd3 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -47,7 +47,7 @@ public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDir
         }
 
         // Cache of Regex objects that we have created and are still alive.
-        private static WeakValueDictionary<string, Regex> s_regexCache = new WeakValueDictionary<string, Regex>();
+        private static readonly WeakValueDictionary<string, Regex> s_regexCache = new WeakValueDictionary<string, Regex>();
 
         private readonly Lazy<GlobState> _state;
 
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 311392df81f..09c7709e062 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -205,9 +205,9 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
             {
                 var projectPath = project.Value.GraphNode.ProjectInstance.FullPath;
 
-                if (projectsByPath.ContainsKey(projectPath))
+                if (projectsByPath.TryGetValue(projectPath, out List<ProjectGraphNode> value))
                 {
-                    projectsByPath[projectPath].Add(project.Value.GraphNode);
+                    value.Add(project.Value.GraphNode);
                 }
                 else
                 {
diff --git a/src/Build/Graph/ParallelWorkSet.cs b/src/Build/Graph/ParallelWorkSet.cs
index ed4ecb41537..8474968ed2c 100644
--- a/src/Build/Graph/ParallelWorkSet.cs
+++ b/src/Build/Graph/ParallelWorkSet.cs
@@ -145,7 +145,12 @@ internal void WaitForAllWorkAndComplete()
 
             // Release one thread that will release all the threads when all the elements are processed.
             _semaphore.Release();
-            Task.WaitAll(_tasks.ToArray());
+            Task.WaitAll(
+#if NET
+                _tasks);
+#else
+                _tasks.ToArray());
+#endif
 
             if (_exceptions.Count > 0)
             {
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index d927eaa7e8c..12ae373485d 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -64,7 +64,7 @@ public TargetSpecification(string target, bool skipIfNonexistent)
                 ErrorUtilities.VerifyThrow(
                     !skipIfNonexistent || (!target.Equals(MSBuildConstants.DefaultTargetsMarker)
                     && !target.Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker)),
-                    target + " cannot be marked as SkipNonexistentTargets");
+                    $"{target} cannot be marked as SkipNonexistentTargets");
                 Target = target;
                 SkipIfNonexistent = skipIfNonexistent;
             }
diff --git a/src/Build/Instance/HostObjectException.cs b/src/Build/Instance/HostObjectException.cs
index ee4613d1b14..47ba77e5d17 100644
--- a/src/Build/Instance/HostObjectException.cs
+++ b/src/Build/Instance/HostObjectException.cs
@@ -40,7 +40,7 @@ internal HostObjectException(
             Exception innerException) :
             base(ErrorMessagePrefix
                 + string.Format(ErrorMessageProjectTargetTask, projectFile, targetName, taskName)
-                + (innerException == null ? string.Empty : ("\n=============\n" + innerException.ToString() + "\n\n")),
+                + (innerException == null ? string.Empty : ($"\n=============\n{innerException}\n\n")),
                 innerException)
         {
         }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 938fcc5cba9..f77da95817b 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2640,7 +2640,12 @@ private static ProjectInstance[] CalculateToolsVersionAndGenerateSolutionWrapper
                 }
                 else /* Dev 12 and above */
                 {
-                    toolsVersion = visualStudioVersion.ToString(CultureInfo.InvariantCulture) + ".0";
+                    toolsVersion =
+#if NET
+                        string.Create(CultureInfo.InvariantCulture, $"{visualStudioVersion}.0");
+#else
+                        $"{visualStudioVersion.ToString(CultureInfo.InvariantCulture)}.0";
+#endif
                 }
 
                 string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
@@ -3161,7 +3166,7 @@ private void Initialize(
 
             if (Traits.Instance.EscapeHatches.DebugEvaluation)
             {
-                Trace.WriteLine(String.Format(CultureInfo.InvariantCulture, "MSBUILD: Creating a ProjectInstance from an unevaluated state [{0}]", FullPath));
+                Trace.WriteLine($"MSBUILD: Creating a ProjectInstance from an unevaluated state [{FullPath}]");
             }
 
             ErrorUtilities.VerifyThrow(EvaluationId == BuildEventContext.InvalidEvaluationId, "Evaluation ID is invalid prior to evaluation");
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 8dd5127eba5..36f280f88bb 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -2112,7 +2112,7 @@ internal class TaskItemFactory : IItemFactory<ProjectItem, TaskItem>, IItemFacto
                 /// <summary>
                 /// The singleton instance.
                 /// </summary>
-                private static TaskItemFactory s_instance = new TaskItemFactory();
+                private static readonly TaskItemFactory s_instance = new TaskItemFactory();
 
                 /// <summary>
                 /// Private constructor for singleton creation.
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index ec764cbbbb3..15136b19c1d 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -164,7 +164,7 @@ internal string EvaluatedValueEscaped
         /// </summary>
         public override string ToString()
         {
-            return _name + "=" + _escapedValue;
+            return $"{_name}={_escapedValue}";
         }
 
         #region INodePacketTranslatable Members
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index dc7cb2b6624..2d0de613ea9 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -186,7 +186,7 @@ void ITranslatable.Translate(ITranslator translator)
         /// </summary>
         public override string ToString()
         {
-            return _name + "=" + _escapedValue;
+            return $"{_name}={_escapedValue}";
         }
 
         /// <summary>
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index a71dad69e15..12d084f9940 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -68,64 +68,64 @@ internal sealed class TaskRegistry : ITranslatable
         /// callbacks; as forcing those out of proc would be just setting them up for
         /// known failure.
         /// </summary>
-        private static bool s_forceTaskHostLaunch = (Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC") == "1");
+        private static readonly bool s_forceTaskHostLaunch = (Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC") == "1");
 
         /// <summary>
         /// Simple name for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksV4SimpleName = "Microsoft.Build.Tasks.v4.0";
+        private const string s_tasksV4SimpleName = "Microsoft.Build.Tasks.v4.0";
 
         /// <summary>
         /// Filename for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksV4Filename = s_tasksV4SimpleName + ".dll";
+        private const string s_tasksV4Filename = $"{s_tasksV4SimpleName}.dll";
 
         /// <summary>
         /// Expected location that MSBuild tasks (v4) is picked up from if the user
         /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_potentialTasksV4Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV4Filename);
+        private static readonly string s_potentialTasksV4Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV4Filename);
 
         /// <summary>
         /// Simple name for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksV12SimpleName = "Microsoft.Build.Tasks.v12.0";
+        private const string s_tasksV12SimpleName = "Microsoft.Build.Tasks.v12.0";
 
         /// <summary>
         /// Filename for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksV12Filename = s_tasksV12SimpleName + ".dll";
+        private const string s_tasksV12Filename = $"{s_tasksV12SimpleName}.dll";
 
         /// <summary>
         /// Expected location that MSBuild tasks (v12) is picked up from if the user
         /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_potentialTasksV12Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV12Filename);
+        private static readonly string s_potentialTasksV12Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV12Filename);
 
         /// <summary>
         /// Simple name for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksCoreSimpleName = "Microsoft.Build.Tasks.Core";
+        private const string s_tasksCoreSimpleName = "Microsoft.Build.Tasks.Core";
 
         /// <summary>
         /// Filename for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksCoreFilename = s_tasksCoreSimpleName + ".dll";
+        private const string s_tasksCoreFilename = $"{s_tasksCoreSimpleName}.dll";
 
         /// <summary>
         /// Expected location that MSBuild tasks (v14+) is picked up from if the user
         /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);
+        private static readonly string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);
 
         /// <summary>
         /// Monotonically increasing counter for registered tasks.
@@ -853,13 +853,13 @@ internal class RegisteredTaskIdentityComparer : IEqualityComparer<RegisteredTask
                 /// <summary>
                 /// The singleton comparer to use when an exact match is desired
                 /// </summary>
-                private static RegisteredTaskIdentityComparer s_exact = new RegisteredTaskIdentityComparer(true /* exact match */);
+                private static readonly RegisteredTaskIdentityComparer s_exact = new RegisteredTaskIdentityComparer(true /* exact match */);
 
                 /// <summary>
                 /// The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the
                 /// name, but does a fuzzy match on the task identity parameters.
                 /// </summary>
-                private static RegisteredTaskIdentityComparer s_fuzzy = new RegisteredTaskIdentityComparer(false /* fuzzy match */);
+                private static readonly RegisteredTaskIdentityComparer s_fuzzy = new RegisteredTaskIdentityComparer(false /* fuzzy match */);
 
                 /// <summary>
                 /// Keeps track of whether we're doing exact or fuzzy equivalency
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 508223e628b..364487c1e72 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -518,7 +518,7 @@ internal virtual void OutputEnvironment(IDictionary<string, string> environment)
                 foreach (KeyValuePair<string, string> entry in environment)
                 {
                     setColor(ConsoleColor.Gray);
-                    WritePretty(String.Format(CultureInfo.CurrentCulture, "{0,-30} = ", entry.Key));
+                    WritePretty($"{entry.Key,-30} = ");
                     setColor(ConsoleColor.DarkGray);
                     WriteLinePretty(entry.Value);
                 }
@@ -536,7 +536,7 @@ internal virtual void OutputProperties(List<DictionaryEntry> list)
             foreach (DictionaryEntry prop in list)
             {
                 setColor(ConsoleColor.Gray);
-                WritePretty(String.Format(CultureInfo.CurrentCulture, "{0,-30} = ", prop.Key));
+                WritePretty($"{prop.Key,-30} = ");
                 setColor(ConsoleColor.DarkGray);
                 WriteLinePretty(EscapingUtilities.UnescapeAll((string)prop.Value));
             }
@@ -656,12 +656,12 @@ protected virtual void WriteItemType(string itemType)
 
         protected virtual void WriteItemSpec(string itemSpec)
         {
-            WriteLinePretty("    " + itemSpec);
+            WriteLinePretty($"    {itemSpec}");
         }
 
         protected virtual void WriteMetadata(string name, string value)
         {
-            WriteLinePretty("        " + name + " = " + value);
+            WriteLinePretty($"        {name} = {value}");
         }
 
         /// <summary>
@@ -821,8 +821,8 @@ internal virtual void PrintCounterMessage(WriteLinePrettyFromResourceDelegate wr
                     2,
                     "PerformanceLine",
                     time,
-                    String.Format(CultureInfo.CurrentCulture, "{0,-40}" /* pad to 40 align left */, scopeName),
-                    String.Format(CultureInfo.CurrentCulture, "{0,3}", calls));
+                    $"{scopeName,-40}", // pad to 40 align left
+                    $"{calls,3}");
             }
 
             /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 4b48d9a8592..69afeee1674 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -56,9 +56,9 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa
 
         // reflection is needed to set these three fields because public constructors don't provide
         // a way to set these from the outside
-        private static FieldInfo? buildEventArgsFieldThreadId =
+        private static readonly FieldInfo? buildEventArgsFieldThreadId =
             typeof(BuildEventArgs).GetField("threadId", BindingFlags.Instance | BindingFlags.NonPublic);
-        private static FieldInfo? buildEventArgsFieldSenderName =
+        private static readonly FieldInfo? buildEventArgsFieldSenderName =
             typeof(BuildEventArgs).GetField("senderName", BindingFlags.Instance | BindingFlags.NonPublic);
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
index 8c6e0c6e2b8..af92788d62a 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
@@ -70,9 +70,13 @@ public override int ReadByte()
         public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
         {
             count = Math.Min((int)Math.Max(Length - _position, 0), count);
-#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-            int read = await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(false);
-#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            int read = await _stream.ReadAsync(
+#if NET
+                buffer.AsMemory(offset, count),
+#else
+                buffer, offset, count,
+#endif
+                cancellationToken).ConfigureAwait(false);
             _position += read;
             return read;
         }
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
index ea3fcb3c9c7..bd427fbb3bc 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
@@ -116,9 +116,13 @@ public override async Task<int> ReadAsync(byte[] buffer, int offset, int count,
                 count = (int)(_maxAllowedPosition - _position);
             }
 
-#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-            int cnt = await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(false);
-#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            int cnt = await _stream.ReadAsync(
+#if NET
+                buffer.AsMemory(offset, count),
+#else
+                buffer, offset, count,
+#endif
+                cancellationToken).ConfigureAwait(false);
             _position += cnt;
             return cnt;
         }
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 591df6df9f3..bfd1d41a51f 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -113,7 +113,7 @@ public void Initialize(IEventSource eventSource)
                 // but avoids confusion by being consistent with the Engine and any error messages it may produce.
                 fileName = _logFile.Replace(extension, _nodeId + extension);
                 _nodeFileLogger.Verbosity = LoggerVerbosity.Detailed;
-                _nodeFileLogger.Parameters = "ShowEventId;ShowCommandLine;logfile=" + fileName + ";" + _parameters;
+                _nodeFileLogger.Parameters = $"ShowEventId;ShowCommandLine;logfile={fileName};{_parameters}";
             }
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
diff --git a/src/Build/Logging/LogFormatter.cs b/src/Build/Logging/LogFormatter.cs
index b03391a34a1..22c0ab05658 100644
--- a/src/Build/Logging/LogFormatter.cs
+++ b/src/Build/Logging/LogFormatter.cs
@@ -51,7 +51,7 @@ internal static string FormatTimeSpan(TimeSpan t)
             string rawTime = t.ToString(); // Timespan is a value type and can't be null.
             int rawTimeLength = rawTime.Length;
             int prettyLength = System.Math.Min(11, rawTimeLength);
-            return t.ToString().Substring(0, prettyLength);
+            return rawTime.Substring(0, prettyLength);
         }
     }
 }
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index 8f949afb9ad..9b4e34e5c34 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -96,7 +96,7 @@ public string Name
                 if (!string.IsNullOrEmpty(_loggerClassName) &&
                     !string.IsNullOrEmpty(_loggerAssembly.AssemblyFile))
                 {
-                    return _loggerClassName + ":" + _loggerAssembly.AssemblyFile;
+                    return $"{_loggerClassName}:{_loggerAssembly.AssemblyFile}";
                 }
                 else if (!string.IsNullOrEmpty(_loggerClassName))
                 {
diff --git a/src/Build/Logging/OptimizedStringIndenter.cs b/src/Build/Logging/OptimizedStringIndenter.cs
index d98f1d62094..ed28c80e8fd 100644
--- a/src/Build/Logging/OptimizedStringIndenter.cs
+++ b/src/Build/Logging/OptimizedStringIndenter.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Buffers;
 
-#if NET7_0_OR_GREATER
+#if NET
 using System.Runtime.CompilerServices;
 #else
 using System.Text;
@@ -49,7 +49,7 @@ namespace Microsoft.Build.BackEnd.Logging;
 internal static class OptimizedStringIndenter
 {
 #nullable enable
-#if NET7_0_OR_GREATER
+#if NET
     [SkipLocalsInit]
 #endif
     internal static unsafe string IndentString(string? s, int indent, IStringBuilderProvider stringBuilderProvider)
@@ -67,7 +67,7 @@ internal static unsafe string IndentString(string? s, int indent, IStringBuilder
             indentedStringLength += segment.Length;
         }
 
-#if NET7_0_OR_GREATER
+#if NET
 #pragma warning disable CS8500
         string result = string.Create(indentedStringLength, (s, (IntPtr)(&segments), indent), static (output, state) =>
         {
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index d59bbb81e46..9e2368df650 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -760,7 +760,7 @@ internal override void OutputProperties(List<DictionaryEntry> list)
             foreach (DictionaryEntry prop in list)
             {
                 setColor(ConsoleColor.Gray);
-                string propertyString = String.Format(CultureInfo.CurrentCulture, "{0} = {1}", prop.Key, EscapingUtilities.UnescapeAll((string)(prop.Value)));
+                string propertyString = $"{prop.Key} = {EscapingUtilities.UnescapeAll((string)(prop.Value))}";
                 WriteMessageAligned(propertyString, false);
             }
             resetColor();
@@ -781,7 +781,7 @@ internal override void OutputEnvironment(IDictionary<string, string> environment
                 foreach (KeyValuePair<string, string> entry in environment)
                 {
                     setColor(ConsoleColor.Gray);
-                    string environmentMessage = String.Format(CultureInfo.CurrentCulture, "{0} = {1}", entry.Key, entry.Value);
+                    string environmentMessage = $"{entry.Key} = {entry.Value}";
                     WriteMessageAligned(environmentMessage, false);
                 }
             }
@@ -897,7 +897,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
 
                                 foreach (DictionaryEntry metadatum in metadata)
                                 {
-                                    WriteMessageAligned(new String(' ', 4 * tabWidth) + metadatum.Key + " = " + item.GetMetadata(metadatum.Key as string), false);
+                                    WriteMessageAligned($"{new String(' ', 4 * tabWidth)}{metadatum.Key} = {item.GetMetadata(metadatum.Key as string)}", false);
                                 }
                             }
                         }
@@ -1343,7 +1343,7 @@ private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText
                     }
                     else
                     {
-                        WriteMessageAligned(targetName + ":", prefixAlreadyWritten);
+                        WriteMessageAligned($"{targetName}:", prefixAlreadyWritten);
                     }
 
                     if (lightenText)
@@ -1618,11 +1618,11 @@ private void WriteLinePrefix(string key, DateTime eventTimeStamp, bool isMessage
 
             if (!isMessagePrefix || IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
-                prefixString = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildEventContext", context, key) + ">";
+                prefixString = $"{ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildEventContext", context, key)}>";
             }
             else
             {
-                prefixString = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildEventContext", context, string.Empty) + " ";
+                prefixString = $"{ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildEventContext", context, string.Empty)} ";
             }
 
             WritePretty(prefixString);
@@ -1763,8 +1763,8 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
                     MessageIndentLevel,
                     "PerformanceLine",
                     time,
-                    String.Format(CultureInfo.CurrentCulture, "{0,-40}" /* pad to 40 align left */, scopeName),
-                    String.Format(CultureInfo.CurrentCulture, "{0,3}", calls));
+                    $"{scopeName,-40}", // pad to 40 align left
+                    $"{calls,3}");
 
                 if (_internalPerformanceCounters?.Count > 0)
                 {
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index dd73599bec2..b066b31fea4 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -140,7 +140,6 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
 
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(currentKey);
 
-            List<string> stackTrace = new List<string>();
             // If there is no started event then there should be no stack trace
             // this is a valid situation if the event occures in the engine or outside the context of a project
             // or the event is raised before the project started event
@@ -150,19 +149,18 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
             }
 
             List<ProjectStartedEventMinimumFields> projectStackTrace = GetProjectCallStack(e);
-            foreach (ProjectStartedEventMinimumFields projectStartedEvent in projectStackTrace)
+
+            string[] stackTrace = new string[projectStackTrace.Count];
+            for (int i = 0; i < stackTrace.Length; i++)
             {
-                if (!string.IsNullOrEmpty(projectStartedEvent.TargetNames))
-                {
-                    stackTrace.Add(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStackWithTargetNames", projectStartedEvent.ProjectFile, projectStartedEvent.TargetNames, projectStartedEvent.FullProjectKey));
-                }
-                else
-                {
-                    stackTrace.Add(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStackWithDefaultTargets", projectStartedEvent.ProjectFile, projectStartedEvent.FullProjectKey));
-                }
+                ProjectStartedEventMinimumFields projectStartedEvent = projectStackTrace[i];
+
+                stackTrace[stackTrace.Length - i - 1] = !string.IsNullOrEmpty(projectStartedEvent.TargetNames) ?
+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStackWithTargetNames", projectStartedEvent.ProjectFile, projectStartedEvent.TargetNames, projectStartedEvent.FullProjectKey) :
+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStackWithDefaultTargets", projectStartedEvent.ProjectFile, projectStartedEvent.FullProjectKey);
             }
-            stackTrace.Reverse();
-            return stackTrace.ToArray();
+
+            return stackTrace;
         }
 
         /// <summary>
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index b80dcf8cf0e..85f659336d8 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -134,7 +134,7 @@ internal ProfilerResult GetAggregatedResult(bool pruneSmallItems = true)
             // So keeping that map here
             var originalLocations = new Dictionary<EvaluationLocation, EvaluationLocation>(EvaluationLocationIdAgnosticComparer.Singleton);
 
-            while (_profiledResults.Any())
+            while (!_profiledResults.IsEmpty)
             {
                 ProfilerResult profiledResult;
                 var result = _profiledResults.TryDequeue(out profiledResult);
diff --git a/src/Build/Logging/TerminalLogger/TerminalLogger.cs b/src/Build/Logging/TerminalLogger/TerminalLogger.cs
index 33696ada520..44d5727c627 100644
--- a/src/Build/Logging/TerminalLogger/TerminalLogger.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalLogger.cs
@@ -12,8 +12,10 @@
 using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Shared;
 
-#if NET7_0_OR_GREATER
+#if NET
 using System.Diagnostics.CodeAnalysis;
+using System.Buffers;
+
 #endif
 
 #if NETFRAMEWORK
@@ -34,15 +36,10 @@ public sealed partial class TerminalLogger : INodeLogger
 {
     private const string FilePathPattern = " -> ";
 
-#if NET7_0_OR_GREATER
-    [StringSyntax(StringSyntaxAttribute.Regex)]
-    private const string ImmediateMessagePattern = @"\[CredentialProvider\]|--interactive";
-    private const RegexOptions Options = RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.ExplicitCapture;
-
-    [GeneratedRegex(ImmediateMessagePattern, Options)]
-    private static partial Regex ImmediateMessageRegex();
+#if NET
+    private static readonly SearchValues<string> _immediateMessageKeywords = SearchValues.Create(["[CredentialProvider]", "--interactive"], StringComparison.OrdinalIgnoreCase);
 #else
-    private static readonly string[] _immediateMessageKeywords = { "[CredentialProvider]", "--interactive" };
+    private static readonly string[] _immediateMessageKeywords = ["[CredentialProvider]", "--interactive"];
 #endif
 
     private static readonly string[] newLineStrings = { "\r\n", "\n" };
@@ -165,11 +162,6 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     private bool _loggedPreviewMessage;
 
-    /// <summary>
-    /// The two directory separator characters to be passed to methods like <see cref="String.IndexOfAny(char[])"/>.
-    /// </summary>
-    private static readonly char[] PathSeparators = { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar };
-
     /// <summary>
     /// One summary per finished project test run.
     /// </summary>
@@ -1018,8 +1010,8 @@ private void WarningRaised(object sender, BuildWarningEventArgs e)
     /// <param name="message">Raised event.</param>
     /// <returns>true if marker is detected.</returns>
     private bool IsImmediateMessage(string message) =>
-#if NET7_0_OR_GREATER
-        ImmediateMessageRegex().IsMatch(message);
+#if NET
+        message.AsSpan().ContainsAny(_immediateMessageKeywords);
 #else
         _immediateMessageKeywords.Any(imk => message.IndexOf(imk, StringComparison.OrdinalIgnoreCase) >= 0);
 #endif
@@ -1058,11 +1050,22 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
     private void ThreadProc()
     {
         // 1_000 / 30 is a poor approx of 30Hz
+        var count = 0;
         while (!_cts.Token.WaitHandle.WaitOne(1_000 / 30))
         {
+            count++;
             lock (_lock)
             {
-                DisplayNodes();
+                // Querying the terminal for it's dimensions is expensive, so we only do it every 30 frames e.g. once a second.
+                if (count >= 30)
+                {
+                    count = 0;
+                    DisplayNodes();
+                }
+                else
+                {
+                    DisplayNodes(false);
+                }
             }
         }
 
@@ -1073,9 +1076,11 @@ private void ThreadProc()
     /// Render Nodes section.
     /// It shows what all build nodes do.
     /// </summary>
-    internal void DisplayNodes()
+    internal void DisplayNodes(bool updateSize = true)
     {
-        TerminalNodesFrame newFrame = new TerminalNodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
+        var width = updateSize ? Terminal.Width : _currentFrame.Width;
+        var height = updateSize ? Terminal.Height : _currentFrame.Height;
+        TerminalNodesFrame newFrame = new TerminalNodesFrame(_nodes, width: width, height: height);
 
         // Do not render delta but clear everything if Terminal width or height have changed.
         if (newFrame.Width != _currentFrame.Width || newFrame.Height != _currentFrame.Height)
@@ -1182,7 +1187,7 @@ private int NodeIndexForContext(BuildEventContext context)
             return null;
         }
 
-        int index = path.LastIndexOfAny(PathSeparators);
+        int index = path.AsSpan().LastIndexOfAny(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
         return index >= 0
             ? $"{path.Substring(0, index + 1)}{AnsiCodes.MakeBold(path.Substring(index + 1))}"
             : path;
@@ -1280,7 +1285,7 @@ private string FormatEventMessage(
         builder.Append($"{category} {code}: ");
 
         // render multi-line message in a special way
-        if (message.IndexOf('\n') >= 0)
+        if (message.Contains('\n'))
         {
             // Place the multiline message under the project in case of minimal and higher verbosity.
             string[] lines = message.Split(newLineStrings, StringSplitOptions.None);
diff --git a/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs b/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
index 4634040bdf7..4661130b4c8 100644
--- a/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
@@ -68,23 +68,10 @@ obj is TerminalNodeStatus status &&
         TargetPrefixColor == status.TargetPrefixColor &&
         TargetPrefix == status.TargetPrefix;
 
-    public override string ToString()
-    {
-        string duration = Stopwatch.ElapsedSeconds.ToString("F1");
-
-        return string.IsNullOrEmpty(TargetFramework)
-            ? string.Format("{0}{1} {2} ({3}s)",
-                TerminalLogger.Indentation,
-                Project,
-                Target,
-                duration)
-            : string.Format("{0}{1} {2} {3} ({4}s)",
-                TerminalLogger.Indentation,
-                Project,
-                AnsiCodes.Colorize(TargetFramework, TerminalLogger.TargetFrameworkColor),
-                Target,
-                duration);
-    }
+    public override string ToString() =>
+        string.IsNullOrEmpty(TargetFramework) ?
+            $"{TerminalLogger.Indentation}{Project} {Target} ({Stopwatch.ElapsedSeconds:F1}s)" :
+            $"{TerminalLogger.Indentation}{Project} {AnsiCodes.Colorize(TargetFramework, TerminalLogger.TargetFrameworkColor)} {Target} ({Stopwatch.ElapsedSeconds:F1}s)";
 
     public override int GetHashCode()
     {
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c24aeee95df..a7881e04a2f 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -39,6 +39,9 @@
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
 
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
   </ItemGroup>
   
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index f6c7a968081..68a6ab4f4bc 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -178,7 +178,7 @@ internal static class AvailableStaticMethods
         /// <summary>
         /// Locker to protect initialization
         /// </summary>
-        private static Object s_locker = new Object();
+        private static readonly Object s_locker = new Object();
 
         static AvailableStaticMethods()
         {
@@ -365,7 +365,7 @@ private static void InitializeAvailableMethods()
                         availableStaticMethods.TryAdd("Microsoft.Build.Utilities.ToolLocationHelper", new Tuple<string, Type>("Microsoft.Build.Utilities.ToolLocationHelper, Microsoft.Build.Utilities.Core, Version=" + MSBuildConstants.CurrentAssemblyVersion + ", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", null));
                         availableStaticMethods.TryAdd("System.Runtime.InteropServices.RuntimeInformation", runtimeInformationType);
                         availableStaticMethods.TryAdd("System.Runtime.InteropServices.OSPlatform", osPlatformType);
-#if NET5_0_OR_GREATER
+#if NET
                         var operatingSystemType = new Tuple<string, Type>(null, typeof(OperatingSystem));
                         availableStaticMethods.TryAdd("System.OperatingSystem", operatingSystemType);
 #else
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index b12e865dfd1..ba17560035f 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -125,21 +125,19 @@ public static SimpleVersion Parse(string input)
             return new SimpleVersion(major, minor, build, revision);
         }
 
-        private static readonly char[] s_semverSeparators = ['-', '+'];
-
         private static ReadOnlySpan<char> RemoveTrivia(string input)
         {
             // Ignore leading/trailing whitespace in input.
             ReadOnlySpan<char> span = input.AsSpan().Trim();
 
             // Ignore a leading "v".
-            if (span.Length > 0 && (span[0] == 'v' || span[0] == 'V'))
+            if (span.Length > 0 && (span[0] is 'v' or 'V'))
             {
                 span = span.Slice(1);
             }
 
             // Ignore semver separator and anything after.
-            int separatorIndex = span.IndexOfAny(s_semverSeparators);
+            int separatorIndex = span.IndexOfAny('-', '+');
             if (separatorIndex >= 0)
             {
                 span = span.Slice(0, separatorIndex);
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 3e032c61c9c..79d23f8415b 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -2,11 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
+using System.Text;
 using System.Text.RegularExpressions;
 using System.Xml;
 using Microsoft.Build.BackEnd;
@@ -26,7 +28,7 @@ namespace Microsoft.Build.Internal
     /// <summary>
     /// This class contains utility methods for the MSBuild engine.
     /// </summary>
-    internal static class Utilities
+    internal static partial class Utilities
     {
         /// <summary>
         /// Save off the contents of the environment variable that specifies whether we should treat higher toolsversions as the current
@@ -81,7 +83,7 @@ internal static void SetXmlNodeInnerContents(XmlElementWithLocation node, string
         {
             ErrorUtilities.VerifyThrow(s != null, "Need value to set.");
 
-            if (s.IndexOf('<') != -1)
+            if (s.Contains('<'))
             {
                 // If the value looks like it probably contains XML markup ...
                 try
@@ -295,7 +297,12 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
         }
 
         // used to find the xmlns attribute
-        private static readonly Regex s_xmlnsPattern = new Regex("xmlns=\"[^\"]*\"\\s*");
+#if NET
+        [GeneratedRegex("xmlns=\"[^\"]*\"\\s*")]
+        private static partial Regex XmlnsPattern { get; }
+#else
+        private static Regex XmlnsPattern { get; } = new Regex("xmlns=\"[^\"]*\"\\s*");
+#endif
 
         /// <summary>
         /// Removes the xmlns attribute from an XML string.
@@ -304,7 +311,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
         /// <returns>The modified XML string.</returns>
         internal static string RemoveXmlNamespace(string xml)
         {
-            return s_xmlnsPattern.Replace(xml, String.Empty);
+            return XmlnsPattern.Replace(xml, String.Empty);
         }
 
         /// <summary>
@@ -312,19 +319,19 @@ internal static string RemoveXmlNamespace(string xml)
         /// </summary>
         internal static string CreateToolsVersionListString(IEnumerable<Toolset> toolsets)
         {
-            string toolsVersionList = String.Empty;
+            StringBuilder sb = StringBuilderCache.Acquire();
+
             foreach (Toolset toolset in toolsets)
             {
-                toolsVersionList += "\"" + toolset.ToolsVersion + "\", ";
-            }
+                if (sb.Length != 0)
+                {
+                    sb.Append(", ");
+                }
 
-            // Remove trailing comma and space
-            if (toolsVersionList.Length > 0)
-            {
-                toolsVersionList = toolsVersionList.Substring(0, toolsVersionList.Length - 2);
+                sb.Append('"').Append(toolset.ToolsVersion).Append('"');
             }
 
-            return toolsVersionList;
+            return StringBuilderCache.GetStringAndRelease(sb);
         }
 
         /// <summary>
@@ -613,19 +620,6 @@ public static IEnumerable<T> Values<T>(this IEnumerable<KeyValuePair<string, T>>
             }
         }
 
-        public static IEnumerable<T> ToEnumerable<T>(this IEnumerator<T> enumerator)
-        {
-            while (enumerator.MoveNext())
-            {
-                yield return enumerator.Current;
-            }
-        }
-
-        public static T[] ToArray<T>(this IEnumerator<T> enumerator)
-        {
-            return enumerator.ToEnumerable().ToArray();
-        }
-
         /// <summary>
         /// Iterates through the nongeneric enumeration and provides generic strong-typed enumeration of properties.
         /// </summary>
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 7cb6452f124..440a60cc86e 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -26,7 +26,8 @@
   <ItemGroup>
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index fc6affaa7d2..91e186d7fe3 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -47,10 +47,6 @@
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true'">
-    <!-- Force updated reference to this package because xunit and shouldly
-         are netstandard1.6 and transitively bring in an old reference -->
-    <PackageReference Include="System.Security.Cryptography.X509Certificates" />
-
     <!-- As of 17.3, one TF of Microsoft.NET.Test.Sdk depends on Newtonsoft.Json
          9.0.1, causing it to be downloaded and flagged by component governance -->
     <PackageReference Include="Newtonsoft.Json" />
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index f5931d3d9af..aba4ae6c2d2 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -8,11 +8,12 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="FluentAssertions" />
+    <PackageReference Include="AwesomeAssertions" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index e7d5868c1d8..1e1264246ec 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -1,4 +1,4 @@
-// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index e024e3f67a5..73180f14fb8 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -60,7 +60,7 @@ private InternalErrorException(string message, Exception innerException, bool ca
                     ? message
                     : "MSB0001: Internal MSBuild Error: " + message + (innerException == null
                         ? String.Empty
-                        : ("\n=============\n" + innerException.ToString() + "\n\n")),
+                        : $"\n=============\n{innerException}\n\n"),
                 innerException)
         {
             if (!calledFromDeserialization)
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 209c30536d4..5cb00f9a8b2 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -193,7 +193,7 @@ private static string FormatString([StringSyntax(StringSyntaxAttribute.Composite
                     // another one, add it here.
                     if (param != null && param.ToString() == param.GetType().FullName)
                     {
-                        throw new InvalidOperationException(string.Format("Invalid type for message formatting argument, was {0}", param.GetType().FullName));
+                        throw new InvalidOperationException($"Invalid type for message formatting argument, was {param.GetType().FullName}");
                     }
                 }
 #endif
@@ -218,7 +218,7 @@ private static string FormatString([StringSyntax(StringSyntaxAttribute.Composite
                     //          Done executing task "Crash".
                     //
                     // T
-                    formatted = string.Format("\"{0}\"\n{1}", unformatted, ex.ToString());
+                    formatted = $"\"{unformatted}\"\n{ex}";
                 }
             }
 
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index bbc62463b1e..ebd415b9e3c 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -461,7 +461,7 @@ public SystemInformationData()
             {
                 ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
 
-#if NETCOREAPP || NETSTANDARD1_1_OR_GREATER
+#if NET || NETSTANDARD1_1_OR_GREATER
                 // Get the architecture from the runtime.
                 processorArchitecture = RuntimeInformation.OSArchitecture switch
                 {
@@ -469,13 +469,9 @@ public SystemInformationData()
                     Architecture.Arm64 => ProcessorArchitectures.ARM64,
                     Architecture.X64 => ProcessorArchitectures.X64,
                     Architecture.X86 => ProcessorArchitectures.X86,
-#if NET5_0_OR_GREATER
+#if NET
                     Architecture.Wasm => ProcessorArchitectures.WASM,
-#endif
-#if NET6_0_OR_GREATER
                     Architecture.S390x => ProcessorArchitectures.S390X,
-#endif
-#if NET7_0_OR_GREATER
                     Architecture.LoongArch64 => ProcessorArchitectures.LOONGARCH64,
                     Architecture.Armv6 => ProcessorArchitectures.ARMV6,
                     Architecture.Ppc64le => ProcessorArchitectures.PPC64LE,
@@ -1394,7 +1390,7 @@ internal static int GetParentProcessId(int processId)
                 // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
                 // and could be again when FileUtilities moves to Framework
 
-                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, System.IO.FileAccess.Read);
+                using var fileStream = new FileStream($"/proc/{processId}/stat", FileMode.Open, System.IO.FileAccess.Read);
                 using StreamReader r = new(fileStream);
 
                 line = r.ReadLine();
@@ -1522,9 +1518,18 @@ private static unsafe int GetCurrentDirectoryWin32(int nBufferLength, char* lpBu
     [SupportedOSPlatform("windows")]
     internal static unsafe string GetFullPath(string path)
     {
-        int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
-        char* buffer = stackalloc char[bufferSize];
-        int fullPathLength = GetFullPathWin32(path, bufferSize, buffer, IntPtr.Zero);
+        char* buffer = stackalloc char[MAX_PATH];
+        int fullPathLength = GetFullPathWin32(path, MAX_PATH, buffer, IntPtr.Zero);
+
+        // if user is using long paths we could need to allocate a larger buffer
+        if (fullPathLength > MAX_PATH)
+        {
+            char* newBuffer = stackalloc char[fullPathLength];
+            fullPathLength = GetFullPathWin32(path, fullPathLength, newBuffer, IntPtr.Zero);
+
+            buffer = newBuffer;
+        }
+
         // Avoid creating new strings unnecessarily
         return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
     }
@@ -1562,7 +1567,7 @@ private static unsafe bool AreStringsEqual(char* buffer, int len, string s)
 
         return true;
 #else
-        return MemoryExtensions.SequenceEqual(new ReadOnlySpan<char>(buffer, len), s.AsSpan());
+        return s.AsSpan().SequenceEqual(new ReadOnlySpan<char>(buffer, len));
 #endif
     }
 
diff --git a/src/Framework/OperatingSystem.cs b/src/Framework/OperatingSystem.cs
index 883ec55b924..51756afe1da 100644
--- a/src/Framework/OperatingSystem.cs
+++ b/src/Framework/OperatingSystem.cs
@@ -1,7 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if !NET5_0_OR_GREATER
+#if !NET
 
 using System;
 
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 046933f38f0..bcdc4ac195c 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -145,6 +145,7 @@ public Traits()
 
         // for VS17.14
         public readonly bool TelemetryOptIn = IsEnvVarOneOrTrue("MSBUILD_TELEMETRY_OPTIN");
+        public readonly bool SlnParsingWithSolutionPersistenceOptIn = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE"));
 
         public static void UpdateFromEnvironment()
         {
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 1d116d117d2..0876e2b8eec 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -35,6 +35,9 @@
 
     <!-- Add this explicitly since it's marked as Private in MSBuild.csproj, but we need these at runtime to be like VS. -->
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
   </ItemGroup>
 
   <!-- Use deps file from this project with additional dependencies listed instead of the one generated in the MSBuild project -->
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 35fa1dbb627..b54e07f48fe 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -7,8 +7,9 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Verify.Xunit" />
   </ItemGroup>
 
diff --git a/src/MSBuild/AutomaticEncodingRestorer.cs b/src/MSBuild/AutomaticEncodingRestorer.cs
index b5696d62ab8..034a0366786 100644
--- a/src/MSBuild/AutomaticEncodingRestorer.cs
+++ b/src/MSBuild/AutomaticEncodingRestorer.cs
@@ -24,7 +24,7 @@ public AutomaticEncodingRestorer()
         {
             try
             {
-#if NET7_0_OR_GREATER
+#if NET
                 if (OperatingSystem.IsIOS() || OperatingSystem.IsAndroid() || OperatingSystem.IsTvOS()) // Output + Input Encoding are unavailable on these platforms per docs, and they're only available past net 5.
                 {
                     return;
@@ -32,7 +32,7 @@ public AutomaticEncodingRestorer()
 #endif
                 _originalOutputEncoding = Console.OutputEncoding;
 
-#if NET7_0_OR_GREATER
+#if NET
                 if (OperatingSystem.IsBrowser()) // Input Encoding is also unavailable in this platform. (No concern for net472 as browser is unavailable.)
                 {
                     return;
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 960e4a57cf5..a7dc889b270 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -175,6 +175,10 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
+
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="System.Diagnostics.DiagnosticSource" /><!-- for consistency with Framework via transitives -->
@@ -193,10 +197,7 @@
     <Reference Include="System.Xml" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Bump these to the latest version despite transitive references to older -->
-    <PackageReference Include="System.Private.Uri" PrivateAssets="all" />
-  </ItemGroup>
+
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" PrivateAssets="All" />
diff --git a/src/MSBuild/PerformanceLogEventListener.cs b/src/MSBuild/PerformanceLogEventListener.cs
index 6772a6aeefc..2f0a0d31595 100644
--- a/src/MSBuild/PerformanceLogEventListener.cs
+++ b/src/MSBuild/PerformanceLogEventListener.cs
@@ -22,7 +22,7 @@ internal struct ProviderConfiguration
             internal EventLevel Level { get; set; }
         }
 
-        private static ProviderConfiguration[] s_config =
+        private static readonly ProviderConfiguration[] s_config =
         [
             new ProviderConfiguration()
             {
@@ -82,7 +82,7 @@ internal void Initialize(string logDirectory)
             _processIDStr = EnvironmentUtilities.CurrentProcessId.ToString();
 
             // Use a GUID disambiguator to make sure that we have a unique file name.
-            string logFilePath = Path.Combine(logDirectory, $"perf-{_processIDStr}-{Guid.NewGuid().ToString("N")}.log");
+            string logFilePath = Path.Combine(logDirectory, $"perf-{_processIDStr}-{Guid.NewGuid():N}.log");
 
             Stream outputStream = new FileStream(
                 logFilePath,
@@ -143,7 +143,7 @@ protected override void OnEventWritten(EventWrittenEventArgs eventData)
                     s_builder.Clear();
                 }
 
-                s_builder.Append($"[{DateTime.UtcNow.ToString("o")}] Event={eventData.EventSource.Name}/{eventData.EventName} ProcessID={_processIDStr} ThreadID={System.Threading.Thread.CurrentThread.ManagedThreadId}\t ");
+                s_builder.Append($"[{DateTime.UtcNow:o}] Event={eventData.EventSource.Name}/{eventData.EventName} ProcessID={_processIDStr} ThreadID={Environment.CurrentManagedThreadId}\t ");
                 for (int i = 0; i < eventData.PayloadNames.Count; i++)
                 {
                     s_builder.Append($"{eventData.PayloadNames[i]}=\"{eventData.Payload[i]}\" ");
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 8bf202edc41..357cb767e84 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1777,7 +1777,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
                         ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                             "LongPaths",
                             ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
-                                "LongPaths_" + longPaths.ToString())),
+                                $"LongPaths_{longPaths}")),
                         MessageImportance.Low));
             }
 
@@ -1789,7 +1789,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
                         ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                             "SAC",
                             ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
-                                "SAC_" + SAC_State.ToString())),
+                                $"SAC_{SAC_State}")),
                         MessageImportance.Low));
             }
 
@@ -3094,7 +3094,7 @@ private static bool WarningsAsErrorsSwitchIsEmpty(CommandLineSwitches commandLin
                 return false;
             }
 
-            int indexOfColon = val.IndexOf(":");
+            int indexOfColon = val.IndexOf(':');
             return indexOfColon < 0 || indexOfColon == val.Length - 1;
         }
 
@@ -3663,13 +3663,13 @@ private static void ValidateExtensions(string[] projectExtensionsToIgnore)
                     InitializationException.VerifyThrow(extension?.Length >= 2, "InvalidExtensionToIgnore", extension);
 
                     // There is an invalid char in the extensionToIgnore.
-                    InitializationException.VerifyThrow(extension.IndexOfAny(Path.GetInvalidPathChars()) == -1, "InvalidExtensionToIgnore", extension, null, false);
+                    InitializationException.VerifyThrow(extension.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) < 0, "InvalidExtensionToIgnore", extension, null, false);
 
                     // There were characters before the extension.
                     InitializationException.VerifyThrow(string.Equals(extension, Path.GetExtension(extension), StringComparison.OrdinalIgnoreCase), "InvalidExtensionToIgnore", extension, null, false);
 
                     // Make sure that no wild cards are in the string because for now we don't allow wild card extensions.
-                    InitializationException.VerifyThrow(extension.IndexOfAny(s_wildcards) == -1, "InvalidExtensionToIgnore", extension, null, false);
+                    InitializationException.VerifyThrow(extension.IndexOfAny(MSBuildConstants.WildcardChars) == -1, "InvalidExtensionToIgnore", extension, null, false);
                 }
             }
         }
@@ -3723,7 +3723,7 @@ private static string[] ProcessTargetSwitch(string[] parameters)
         {
             foreach (string parameter in parameters)
             {
-                int indexOfSpecialCharacter = parameter.IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
+                int indexOfSpecialCharacter = parameter.AsSpan().IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
                 if (indexOfSpecialCharacter >= 0)
                 {
                     CommandLineSwitchException.Throw("NameInvalid", nameof(XMakeElements.target), parameter, parameter[indexOfSpecialCharacter].ToString());
@@ -3737,11 +3737,6 @@ private static string[] ProcessTargetSwitch(string[] parameters)
         /// </summary>
         private static readonly char[] s_propertyValueSeparator = MSBuildConstants.EqualsChar;
 
-        /// <summary>
-        /// This is a set of wildcard chars which can cause a file extension to be invalid
-        /// </summary>
-        private static readonly char[] s_wildcards = MSBuildConstants.WildcardChars;
-
         /// <summary>
         /// Determines which ToolsVersion was specified on the command line.  If more than
         /// one ToolsVersion was specified, we honor only the final ToolsVersion.
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 96d2e3dbc1d..ca919c51e3f 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -70,8 +70,13 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.HashCode" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+          <codeBase version="1.0.0.0" href="..\Microsoft.Bcl.HashCode.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -96,13 +101,23 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Collections.Immutable.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Collections.Immutable.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.1" />
-          <codeBase version="8.0.0.1" href="..\System.Diagnostics.DiagnosticSource.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Diagnostics.DiagnosticSource.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Formats.Nrbf" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Formats.Nrbf.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.IO.Pipelines" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.IO.Pipelines.dll"/>
         </dependentAssembly>
 
         <dependentAssembly>
@@ -185,18 +200,18 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Reflection.Metadata.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Reflection.Metadata.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Resources.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Resources.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -205,23 +220,23 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
-          <codeBase version="8.0.0.5" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Threading.Channels.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Threading.Channels.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index d63a1782ca4..f1bb2ea9f69 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -33,7 +33,11 @@
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.HashCode" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Extensions.Primitives" publicKeyToken="adb9793829ddae60" culture="neutral" />
@@ -58,11 +62,19 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Formats.Nrbf" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.IO.Pipelines" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.1" newVersion="8.0.0.1" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -74,15 +86,15 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -90,15 +102,15 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 8df9f8d8d90..3330195df6e 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -43,6 +43,8 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Diagnostics.DiagnosticSource.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Formats.Nrbf.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -57,6 +59,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Bcl.HashCode.dll
   file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
   file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
@@ -209,6 +212,8 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Formats.Nrbf.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenArchitecture=all
@@ -219,10 +224,11 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.ValueTuple.dll
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Resources.Extensions.dll
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.HashCode.dll
   file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
   file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index 5ba08499c68..f1c67c65ad0 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -13,6 +13,6 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Shouldly" Version="4.2.1" />
-    <PackageReference Include="System.Net.Http" Version="4.3.4" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 </Project>
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 6820a134454..a15f6e62113 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -82,7 +82,7 @@ internal AssemblyFoldersEx(
                 return;
             }
 
-            bool is64bitOS = EnvironmentUtilities.Is64BitOperatingSystem;
+            bool is64bitOS = Environment.Is64BitOperatingSystem;
             bool targeting64bit = targetProcessorArchitecture == ProcessorArchitecture.Amd64 || targetProcessorArchitecture == ProcessorArchitecture.IA64;
 
             // The registry lookup should be as follows:
@@ -367,7 +367,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
             // Loop over versions from registry.
             foreach (string version in versions)
             {
-                if ((version.Length > 0) && (String.Equals(version.Substring(0, 1), "v", StringComparison.OrdinalIgnoreCase)))
+                if ((version.Length > 0) && version[0] is 'v' or 'V')
                 {
                     Version candidateVersion = VersionUtilities.ConvertToVersion(version);
 
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs b/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
index b546b28ccb9..4f79794879d 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
@@ -41,7 +41,7 @@ internal AssemblyFoldersFromConfig(string configFile, string targetRuntimeVersio
             // Platform-agnostic folders first.
             FindDirectories(assemblyTargets, target => string.IsNullOrEmpty(target.Platform));
 
-            if (EnvironmentUtilities.Is64BitOperatingSystem)
+            if (Environment.Is64BitOperatingSystem)
             {
                 if (targeting64Bit)
                 {
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index f29b9e8e443..12017934f1f 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -577,6 +577,11 @@ private static int CompareBaseNamesStringWise(string asString1, string asString2
                 baseLenThat = asString2.Length;
             }
 
+#if NET
+            ReadOnlySpan<char> nameThis = asString1.AsSpan(0, baseLenThis);
+            ReadOnlySpan<char> nameThat = asString2.AsSpan(0, baseLenThat);
+            return nameThis.CompareTo(nameThat, StringComparison.OrdinalIgnoreCase);
+#else
             // If the lengths are the same then we can compare without copying.
             if (baseLenThis == baseLenThat)
             {
@@ -587,6 +592,7 @@ private static int CompareBaseNamesStringWise(string asString1, string asString2
             string nameThis = asString1.Substring(0, baseLenThis);
             string nameThat = asString2.Substring(0, baseLenThat);
             return string.Compare(nameThis, nameThat, StringComparison.OrdinalIgnoreCase);
+#endif
         }
 
         /// <summary>
@@ -778,24 +784,18 @@ internal bool ComparePublicKeyToken(AssemblyNameExtension that)
         /// </summary>
         internal static bool ComparePublicKeyTokens(byte[] aPKT, byte[] bPKT)
         {
+#if NET
+            return aPKT.AsSpan().SequenceEqual(bPKT.AsSpan());
+#else
             // Some assemblies (real case was interop assembly) may have null PKTs.
-            if (aPKT == null)
-            {
-#pragma warning disable CA1825 // Avoid zero-length array allocations
-                aPKT = new byte[0];
-#pragma warning restore CA1825 // Avoid zero-length array allocations
-            }
-            if (bPKT == null)
-            {
-#pragma warning disable CA1825 // Avoid zero-length array allocations
-                bPKT = new byte[0];
-#pragma warning restore CA1825 // Avoid zero-length array allocations
-            }
+            aPKT ??= [];
+            bPKT ??= [];
 
             if (aPKT.Length != bPKT.Length)
             {
                 return false;
             }
+
             for (int i = 0; i < aPKT.Length; ++i)
             {
                 if (aPKT[i] != bPKT[i])
@@ -803,7 +803,9 @@ internal static bool ComparePublicKeyTokens(byte[] aPKT, byte[] bPKT)
                     return false;
                 }
             }
+
             return true;
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index 711d2dde947..f864c62bb23 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -19,7 +19,7 @@ internal static class AwaitExtensions
         /// <summary>
         /// Synchronizes access to the staScheduler field.
         /// </summary>
-        private static Object s_staSchedulerSync = new Object();
+        private static readonly Object s_staSchedulerSync = new Object();
 
         /// <summary>
         /// The singleton STA scheduler object.
@@ -155,7 +155,7 @@ private class OneSTAThreadPerTaskScheduler : TaskScheduler
             /// <summary>
             /// The current queue of tasks.
             /// </summary>
-            private ConcurrentQueue<Task> _queuedTasks = new ConcurrentQueue<Task>();
+            private readonly ConcurrentQueue<Task> _queuedTasks = new ConcurrentQueue<Task>();
 
             /// <summary>
             /// Returns the list of queued tasks.
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index 011818c3f1c..4c4a8ea96cf 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Globalization;
 using System.Text.RegularExpressions;
 
@@ -49,99 +50,141 @@ namespace Microsoft.Build.Shared
     ///
     ///          &lt;text&gt; : warning [num]: &lt;msg&gt;
     /// </remarks>
-    internal static class CanonicalError
+    internal static partial class CanonicalError
     {
         // Defines the main pattern for matching messages.
-        private static readonly Lazy<Regex> s_originCategoryCodeTextExpression = new Lazy<Regex>(
-            () => new Regex(
-                // Beginning of line and any amount of whitespace.
-                @"^\s*"
-                // Match a [optional project number prefix 'ddd>'], single letter + colon + remaining filename, or
-                // string with no colon followed by a colon.
-                + @"(((?<ORIGIN>(((\d+>)?[a-zA-Z]?:[^:]*)|([^:]*))):)"
-                // Origin may also be empty. In this case there's no trailing colon.
-                + "|())"
-                // Match the empty string or a string without a colon that ends with a space
-                + "(?<SUBCATEGORY>(()|([^:]*? )))"
-                // Match 'error' or 'warning'.
-                + @"(?<CATEGORY>(error|warning))"
-                // Match anything starting with a space that's not a colon/space, followed by a colon.
-                // Error code is optional in which case "error"/"warning" can be followed immediately by a colon.
-                + @"( \s*(?<CODE>[^: ]*))?\s*:"
-                // Whatever's left on this line, including colons.
-                + "(?<TEXT>.*)$",
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
-
-        private static readonly Lazy<Regex> s_originCategoryCodeTextExpression2 = new Lazy<Regex>(
-            () => new Regex(
-                @"^\s*(?<ORIGIN>(?<FILENAME>.*):(?<LOCATION>(?<LINE>[0-9]*):(?<COLUMN>[0-9]*))):(?<CATEGORY> error| warning):(?<TEXT>.*)",
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string OriginCategoryCodeTextExpressionPattern =
+            // Beginning of line and any amount of whitespace.
+            @"^\s*"
+            // Match a [optional project number prefix 'ddd>'], single letter + colon + remaining filename, or
+            // string with no colon followed by a colon.
+            + @"(((?<ORIGIN>(((\d+>)?[a-zA-Z]?:[^:]*)|([^:]*))):)"
+            // Origin may also be empty. In this case there's no trailing colon.
+            + "|())"
+            // Match the empty string or a string without a colon that ends with a space
+            + "(?<SUBCATEGORY>(()|([^:]*? )))"
+            // Match 'error' or 'warning'.
+            + @"(?<CATEGORY>(error|warning))"
+            // Match anything starting with a space that's not a colon/space, followed by a colon.
+            // Error code is optional in which case "error"/"warning" can be followed immediately by a colon.
+            + @"( \s*(?<CODE>[^: ]*))?\s*:"
+            // Whatever's left on this line, including colons.
+            + "(?<TEXT>.*)$";
+
+        private const string OriginCategoryCodeTextExpression2Pattern =
+            @"^\s*(?<ORIGIN>(?<FILENAME>.*):(?<LOCATION>(?<LINE>[0-9]*):(?<COLUMN>[0-9]*))):(?<CATEGORY> error| warning):(?<TEXT>.*)";
 
         // Matches and extracts filename and location from an 'origin' element.
-        private static readonly Lazy<Regex> s_filenameLocationFromOrigin = new Lazy<Regex>(
-            () => new Regex(
-                "^" // Beginning of line
-                + @"(\d+>)?" // Optional ddd> project number prefix
-                + "(?<FILENAME>.*)" // Match anything.
-                + @"\(" // Find a parenthesis.
-                + @"(?<LOCATION>[\,,0-9,-]*)" // Match any combination of numbers and ',' and '-'
-                + @"\)\s*" // Find the closing paren then any amount of spaces.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string FilenameLocationFromOriginPattern =
+            "^" // Beginning of line
+            + @"(\d+>)?" // Optional ddd> project number prefix
+            + "(?<FILENAME>.*)" // Match anything.
+            + @"\(" // Find a parenthesis.
+            + @"(?<LOCATION>[\,,0-9,-]*)" // Match any combination of numbers and ',' and '-'
+            + @"\)\s*" // Find the closing paren then any amount of spaces.
+            + "$"; // End-of-line
 
         // Matches location that is a simple number.
-        private static readonly Lazy<Regex> s_lineFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineFromLocationPattern = // Example: line
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
 
         // Matches location that is a range of lines.
-        private static readonly Lazy<Regex> s_lineLineFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line-line
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "-" // Dash
-                + "(?<ENDLINE>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineLineFromLocationPattern = // Example: line-line
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "-" // Dash
+            + "(?<ENDLINE>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
 
         // Matches location that is a line and column
-        private static readonly Lazy<Regex> s_lineColFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line,col
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "," // Comma
-                + "(?<COLUMN>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineColFromLocationPattern = // Example: line,col
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "," // Comma
+            + "(?<COLUMN>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
 
         // Matches location that is a line and column-range
-        private static readonly Lazy<Regex> s_lineColColFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line,col-col
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "," // Comma
-                + "(?<COLUMN>[0-9]*)" // Match any number.
-                + "-" // Dash
-                + "(?<ENDCOLUMN>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineColColFromLocationPattern = // Example: line,col-col
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "," // Comma
+            + "(?<COLUMN>[0-9]*)" // Match any number.
+            + "-" // Dash
+            + "(?<ENDCOLUMN>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
 
         // Matches location that is line,col,line,col
-        private static readonly Lazy<Regex> s_lineColLineColFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line,col,line,col
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "," // Comma
-                + "(?<COLUMN>[0-9]*)" // Match any number.
-                + "," // Dash
-                + "(?<ENDLINE>[0-9]*)" // Match any number.
-                + "," // Dash
-                + "(?<ENDCOLUMN>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineColLineColFromLocationPattern = // Example: line,col,line,col
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "," // Comma
+            + "(?<COLUMN>[0-9]*)" // Match any number.
+            + "," // Dash
+            + "(?<ENDLINE>[0-9]*)" // Match any number.
+            + "," // Dash
+            + "(?<ENDCOLUMN>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
+
+#if NET
+        [GeneratedRegex(OriginCategoryCodeTextExpressionPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex OriginCategoryCodeTextExpression { get; }
+
+        [GeneratedRegex(OriginCategoryCodeTextExpression2Pattern, RegexOptions.IgnoreCase)]
+        private static partial Regex OriginCategoryCodeTextExpression2 { get; }
+
+        [GeneratedRegex(FilenameLocationFromOriginPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex FilenameLocationFromOrigin { get; }
+
+        [GeneratedRegex(LineFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineFromLocation { get; }
+
+        [GeneratedRegex(LineLineFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineLineFromLocation { get; }
+
+        [GeneratedRegex(LineColFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineColFromLocation { get; }
+
+        [GeneratedRegex(LineColColFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineColColFromLocation { get; }
+
+        [GeneratedRegex(LineColLineColFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineColLineColFromLocation { get; }
+#else
+        private static Regex s_originCategoryCodeTextExpression;
+        private static Regex OriginCategoryCodeTextExpression => s_originCategoryCodeTextExpression ??=
+            new Regex(OriginCategoryCodeTextExpressionPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_originCategoryCodeTextExpression2;
+        private static Regex OriginCategoryCodeTextExpression2 => s_originCategoryCodeTextExpression2 ??=
+            new Regex(OriginCategoryCodeTextExpression2Pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_filenameLocationFromOrigin;
+        private static Regex FilenameLocationFromOrigin => s_filenameLocationFromOrigin ??=
+            new Regex(FilenameLocationFromOriginPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineFromLocation;
+        private static Regex LineFromLocation => s_lineFromLocation ??=
+            new Regex(LineFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineLineFromLocation;
+        private static Regex LineLineFromLocation => s_lineLineFromLocation ??=
+            new Regex(LineLineFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineColFromLocation;
+        private static Regex LineColFromLocation => s_lineColFromLocation ??=
+            new Regex(LineColFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineColColFromLocation;
+        private static Regex LineColColFromLocation => s_lineColColFromLocation ??=
+            new Regex(LineColColFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineColLineColFromLocation;
+        private static Regex LineColLineColFromLocation => s_lineColLineColFromLocation ??=
+            new Regex(LineColLineColFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+#endif
 
         /// <summary>
         /// Represents the parts of a decomposed canonical message.
@@ -234,6 +277,10 @@ private static int ConvertToIntWithDefault(string value)
             return result;
         }
 
+#if NET
+        private static readonly SearchValues<string> s_warningOrError = SearchValues.Create(["warning", "error"], StringComparison.OrdinalIgnoreCase);
+#endif
+
         /// <summary>
         /// Decompose an error or warning message into constituent parts. If the message isn't in the canonical form, return null.
         /// </summary>
@@ -256,8 +303,12 @@ internal static Parts Parse(string message)
             // If a tool has a large amount of output that isn't an error or warning (eg., "dir /s %hugetree%")
             // the regex below is slow. It's faster to pre-scan for "warning" and "error"
             // and bail out if neither are present.
-            if (message.IndexOf("warning", StringComparison.OrdinalIgnoreCase) == -1 &&
-                message.IndexOf("error", StringComparison.OrdinalIgnoreCase) == -1)
+#if NET
+            if (message.AsSpan().IndexOfAny(s_warningOrError) < 0)
+#else
+            if (message.IndexOf("warning", StringComparison.OrdinalIgnoreCase) < 0 &&
+                message.IndexOf("error", StringComparison.OrdinalIgnoreCase) < 0)
+#endif
             {
                 return null;
             }
@@ -283,7 +334,7 @@ internal static Parts Parse(string message)
             //  Here's an example from the Japanese version of LINK.EXE:
             //   AssemblyInfo.cpp : fatal error LNK1106: ???????????? ??????????????: 0x6580 ??????????
             //
-            Match match = s_originCategoryCodeTextExpression.Value.Match(message);
+            Match match = OriginCategoryCodeTextExpression.Match(message);
             string category;
             if (!match.Success)
             {
@@ -292,7 +343,7 @@ internal static Parts Parse(string message)
                 //       err.cpp:6:3: error: use of undeclared identifier 'force_an_error'
                 //       -----------  -----  ---------------------------------------------
                 //       Origin       Cat.   Text
-                match = s_originCategoryCodeTextExpression2.Value.Match(message);
+                match = OriginCategoryCodeTextExpression2.Match(message);
                 if (!match.Success)
                 {
                     return null;
@@ -320,7 +371,7 @@ internal static Parts Parse(string message)
                 string[] explodedText = parsedMessage.text.Split(MSBuildConstants.SingleQuoteChar, StringSplitOptions.RemoveEmptyEntries);
                 if (explodedText.Length > 0)
                 {
-                    parsedMessage.code = "G" + explodedText[0].GetHashCode().ToString("X8");
+                    parsedMessage.code = $"G{explodedText[0].GetHashCode():X8}";
                 }
                 else
                 {
@@ -353,7 +404,7 @@ internal static Parts Parse(string message)
 
             // Origin is not a simple file, but it still could be of the form,
             //  foo.cpp(location)
-            match = s_filenameLocationFromOrigin.Value.Match(origin);
+            match = FilenameLocationFromOrigin.Match(origin);
 
             if (match.Success)
             {
@@ -373,14 +424,14 @@ internal static Parts Parse(string message)
                 //      (line,col,line,col)
                 if (location.Length > 0)
                 {
-                    match = s_lineFromLocation.Value.Match(location);
+                    match = LineFromLocation.Match(location);
                     if (match.Success)
                     {
                         parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
                     }
                     else
                     {
-                        match = s_lineLineFromLocation.Value.Match(location);
+                        match = LineLineFromLocation.Match(location);
                         if (match.Success)
                         {
                             parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
@@ -388,7 +439,7 @@ internal static Parts Parse(string message)
                         }
                         else
                         {
-                            match = s_lineColFromLocation.Value.Match(location);
+                            match = LineColFromLocation.Match(location);
                             if (match.Success)
                             {
                                 parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
@@ -396,7 +447,7 @@ internal static Parts Parse(string message)
                             }
                             else
                             {
-                                match = s_lineColColFromLocation.Value.Match(location);
+                                match = LineColColFromLocation.Match(location);
                                 if (match.Success)
                                 {
                                     parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
@@ -405,7 +456,7 @@ internal static Parts Parse(string message)
                                 }
                                 else
                                 {
-                                    match = s_lineColLineColFromLocation.Value.Match(location);
+                                    match = LineColLineColFromLocation.Match(location);
                                     if (match.Success)
                                     {
                                         parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index d063be62f8d..4b48317081c 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -96,10 +96,10 @@ protected internal Handshake(HandshakeOptions nodeType)
             CommunicationsUtilities.Trace("Building handshake for node type {0}, (version {1}): options {2}.", nodeType, handshakeVersion, options);
 
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
-            CommunicationsUtilities.Trace("Handshake salt is " + handshakeSalt);
+            CommunicationsUtilities.Trace("Handshake salt is {0}", handshakeSalt);
             string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
-            CommunicationsUtilities.Trace("Tools directory root is " + toolsDirectory);
-            salt = CommunicationsUtilities.GetHashCode(handshakeSalt + toolsDirectory);
+            CommunicationsUtilities.Trace("Tools directory root is {0}", toolsDirectory);
+            salt = CommunicationsUtilities.GetHashCode($"{handshakeSalt}{toolsDirectory}");
             Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
             fileVersionMajor = fileVersion.Major;
             fileVersionMinor = fileVersion.Minor;
@@ -112,7 +112,7 @@ protected internal Handshake(HandshakeOptions nodeType)
         // This is used as a key, so it does not need to be human readable.
         public override string ToString()
         {
-            return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
+            return $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}";
         }
 
         public virtual int[] RetrieveHandshakeComponents()
@@ -175,8 +175,14 @@ public string ComputeHash()
             if (_computedHash == null)
             {
                 var input = GetKey();
+                byte[] utf8 = Encoding.UTF8.GetBytes(input);
+#if NET
+                Span<byte> bytes = stackalloc byte[SHA256.HashSizeInBytes];
+                SHA256.HashData(utf8, bytes);
+#else
                 using var sha = SHA256.Create();
-                var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
+                var bytes = sha.ComputeHash(utf8);
+#endif
                 _computedHash = Convert.ToBase64String(bytes)
                     .Replace("/", "_")
                     .Replace("=", string.Empty);
@@ -208,7 +214,7 @@ internal static class CommunicationsUtilities
         /// <summary>
         /// Whether to trace communications
         /// </summary>
-        private static bool s_trace = Traits.Instance.DebugNodeCommunication;
+        private static readonly bool s_trace = Traits.Instance.DebugNodeCommunication;
 
         /// <summary>
         /// Lock trace to ensure we are logging in serial fashion.
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index e435d354935..4aa800ef2d2 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -2,6 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
+using System.Buffers;
+#endif
 using System.IO;
 
 #nullable disable
@@ -112,25 +115,31 @@ internal static class MSBuildConstants
         internal const string ProjectReferenceTargetsOrDefaultTargetsMarker = ".projectReferenceTargetsOrDefaultTargets";
 
         // One-time allocations to avoid implicit allocations for Split(), Trim().
-        internal static readonly char[] SemicolonChar = { ';' };
-        internal static readonly char[] SpaceChar = { ' ' };
-        internal static readonly char[] SingleQuoteChar = { '\'' };
-        internal static readonly char[] EqualsChar = { '=' };
-        internal static readonly char[] ColonChar = { ':' };
-        internal static readonly char[] BackslashChar = { '\\' };
-        internal static readonly char[] NewlineChar = { '\n' };
-        internal static readonly char[] CrLf = { '\r', '\n' };
-        internal static readonly char[] ForwardSlash = { '/' };
-        internal static readonly char[] ForwardSlashBackslash = { '/', '\\' };
-        internal static readonly char[] WildcardChars = { '*', '?' };
-        internal static readonly string[] CharactersForExpansion = { "*", "?", "$(", "@(", "%" };
-        internal static readonly char[] CommaChar = { ',' };
-        internal static readonly char[] HyphenChar = { '-' };
-        internal static readonly char[] DirectorySeparatorChar = { Path.DirectorySeparatorChar };
-        internal static readonly char[] DotChar = { '.' };
-        internal static readonly string[] EnvironmentNewLine = { Environment.NewLine };
-        internal static readonly char[] PipeChar = { '|' };
-        internal static readonly char[] PathSeparatorChar = { Path.PathSeparator };
+        internal static readonly char[] SemicolonChar = [';'];
+        internal static readonly char[] SpaceChar = [' '];
+        internal static readonly char[] SingleQuoteChar = ['\''];
+        internal static readonly char[] EqualsChar = ['='];
+        internal static readonly char[] ColonChar = [':'];
+        internal static readonly char[] BackslashChar = ['\\'];
+        internal static readonly char[] NewlineChar = ['\n'];
+        internal static readonly char[] CrLf = ['\r', '\n'];
+        internal static readonly char[] ForwardSlash = ['/'];
+        internal static readonly char[] ForwardSlashBackslash = ['/', '\\'];
+        internal static readonly char[] WildcardChars = ['*', '?'];
+        internal static readonly string[] CharactersForExpansion = ["*", "?", "$(", "@(", "%"];
+        internal static readonly char[] CommaChar = [','];
+        internal static readonly char[] HyphenChar = ['-'];
+        internal static readonly char[] DirectorySeparatorChar = [Path.DirectorySeparatorChar];
+        internal static readonly char[] DotChar = ['.'];
+        internal static readonly string[] EnvironmentNewLine = [Environment.NewLine];
+        internal static readonly char[] PipeChar = ['|'];
+        internal static readonly char[] PathSeparatorChar = [Path.PathSeparator];
+
+#if NET
+        internal static readonly SearchValues<char> InvalidPathChars = SearchValues.Create(Path.GetInvalidPathChars());
+#else
+        internal static readonly char[] InvalidPathChars = Path.GetInvalidPathChars();
+#endif
     }
 
     internal static class PropertyNames
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 10bdc82790e..9f1e756baeb 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -57,6 +57,9 @@ internal static bool ConvertStringToBool(string parameterValue, bool nullOrWhite
         /// <returns>A string byte types formated as X2.</returns>
         internal static string ConvertByteArrayToHex(byte[] bytes)
         {
+#if NET
+            return Convert.ToHexString(bytes);
+#else
             var sb = new StringBuilder();
             foreach (var b in bytes)
             {
@@ -64,6 +67,7 @@ internal static string ConvertByteArrayToHex(byte[] bytes)
             }
 
             return sb.ToString();
+#endif
         }
 
         internal static bool TryConvertStringToBool(string parameterValue, out bool boolValue)
@@ -131,7 +135,13 @@ internal static double ConvertDecimalToDouble(string number)
         /// </summary>
         internal static double ConvertHexToDouble(string number)
         {
-            return (double)Int32.Parse(number.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat);
+            return (double)Int32.Parse(
+#if NET
+                number.AsSpan(2),
+#else
+                number.Substring(2),
+#endif
+                NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat);
         }
 
         /// <summary>
@@ -172,9 +182,15 @@ private static bool ValidHexNumber(string number, out int value)
         {
             bool canConvert = false;
             value = 0;
-            if (number.Length >= 3 && number[0] == '0' && (number[1] == 'x' || number[1] == 'X'))
+            if (number.Length >= 3 && number[0] is '0' && number[1] is 'x' or 'X')
             {
-                canConvert = Int32.TryParse(number.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat, out value);
+                canConvert = Int32.TryParse(
+#if NET
+                    number.AsSpan(2),
+#else
+                    number.Substring(2),
+#endif
+                    NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat, out value);
             }
             return canConvert;
         }
diff --git a/src/Shared/Debugging/PrintLineDebuggerWriters.cs b/src/Shared/Debugging/PrintLineDebuggerWriters.cs
index e0dc425c320..bcdadc22a24 100644
--- a/src/Shared/Debugging/PrintLineDebuggerWriters.cs
+++ b/src/Shared/Debugging/PrintLineDebuggerWriters.cs
@@ -68,7 +68,7 @@ public CompositeWriter(IEnumerable<CommonWriterType> writers)
 
         public static CommonWriterType StdOutWriter = (id, callsite, args) => Console.WriteLine(SimpleFormat(id, callsite, args));
 
-        private static Lazy<string> _artifactsLogs = new Lazy<string>(
+        private static readonly Lazy<string> _artifactsLogs = new Lazy<string>(
             () =>
             {
                 var executingAssembly = FileUtilities.ExecutingAssemblyPath;
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index f84ddf86632..8bde0027840 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -26,7 +26,7 @@ internal static class EscapingUtilities
         /// Optional cache of escaped strings for use when needing to escape in performance-critical scenarios with significant
         /// expected string reuse.
         /// </summary>
-        private static Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);
+        private static readonly Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);
 
         private static bool TryDecodeHexDigit(char character, out int value)
         {
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index d6cd177e8ad..9d97c12de8d 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -26,14 +26,19 @@ internal class FileMatcher
         private readonly IFileSystem _fileSystem;
         private const string recursiveDirectoryMatch = "**";
 
-        private static readonly string s_directorySeparator = new string(Path.DirectorySeparatorChar, 1);
+        private static readonly string s_directorySeparatorString = Path.DirectorySeparatorChar.ToString();
+        private static readonly string s_twoDirectorySeparators = s_directorySeparatorString + s_directorySeparatorString;
 
-        private static readonly string s_thisDirectory = "." + s_directorySeparator;
+        private static readonly string s_thisDirectory = $".{s_directorySeparatorString}";
 
         private static readonly char[] s_wildcardCharacters = { '*', '?' };
         private static readonly char[] s_wildcardAndSemicolonCharacters = { '*', '?', ';' };
 
-        private static readonly string[] s_propertyAndItemReferences = { "$(", "@(" };
+#if NET
+        private static readonly SearchValues<string> s_propertyAndItemReferences = SearchValues.Create(["$(", "@("], StringComparison.Ordinal);
+#else
+        private static readonly string[] s_propertyAndItemReferences = ["$(", "@("];
+#endif
 
         // on OSX both System.IO.Path separators are '/', so we have to use the literals
         internal static readonly char[] directorySeparatorCharacters = FileUtilities.Slashes;
@@ -45,12 +50,6 @@ internal class FileMatcher
         private readonly ConcurrentDictionary<string, IReadOnlyList<string>> _cachedGlobExpansions;
         private readonly Lazy<ConcurrentDictionary<string, object>> _cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));
 
-        /// <summary>
-        /// Cache of the list of invalid path characters, because this method returns a clone (for security reasons)
-        /// which can cause significant transient allocations
-        /// </summary>
-        private static readonly char[] s_invalidPathChars = Path.GetInvalidPathChars();
-
         public const RegexOptions DefaultRegexOptions = RegexOptions.IgnoreCase;
 
         private readonly GetFileSystemEntries _getFileSystemEntries;
@@ -186,7 +185,7 @@ internal static bool HasWildcards(string filespec)
             // Choose LastIndexOfAny instead of IndexOfAny because it seems more likely
             // that wildcards will tend to be towards the right side.
 
-            return -1 != filespec.LastIndexOfAny(s_wildcardCharacters);
+            return filespec.LastIndexOfAny(s_wildcardCharacters) >= 0;
         }
 
         /// <summary>
@@ -195,10 +194,8 @@ internal static bool HasWildcards(string filespec)
         internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec)
         {
             return
-
-                (-1 != filespec.IndexOfAny(s_wildcardAndSemicolonCharacters)) ||
-                HasPropertyOrItemReferences(filespec)
-                ;
+                (filespec.IndexOfAny(s_wildcardAndSemicolonCharacters) >= 0) ||
+                HasPropertyOrItemReferences(filespec);
         }
 
         /// <summary>
@@ -206,7 +203,12 @@ internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filesp
         /// </summary>
         internal static bool HasPropertyOrItemReferences(string filespec)
         {
-            return s_propertyAndItemReferences.Any(filespec.Contains);
+            return
+#if NET
+                filespec.AsSpan().ContainsAny(s_propertyAndItemReferences);
+#else
+                s_propertyAndItemReferences.Any(filespec.Contains);
+#endif
         }
 
         /// <summary>
@@ -288,10 +290,10 @@ private static bool ShouldEnforceMatching(string searchPattern)
             //    extensions that start with the same three characters e.g. "*.htm" would match both "file.htm" and "file.html"
             // 3) if the ? wildcard is to the left of a period, it matches files with shorter name e.g. ???.txt would match
             //    foo.txt, fo.txt and also f.txt
-            return searchPattern.IndexOf("?.", StringComparison.Ordinal) != -1 ||
+            return searchPattern.Contains("?.") ||
                    (
                        Path.GetExtension(searchPattern).Length == (3 + 1 /* +1 for the period */) &&
-                       searchPattern.IndexOf('*') != -1) ||
+                       searchPattern.Contains('*')) ||
                    searchPattern.EndsWith("?", StringComparison.Ordinal);
         }
 
@@ -440,7 +442,7 @@ internal static string GetLongPathName(
             string path,
             GetFileSystemEntries getFileSystemEntries)
         {
-            if (path.IndexOf("~", StringComparison.Ordinal) == -1)
+            if (!path.Contains('~'))
             {
                 // A path with no '~' must not be a short name.
                 return path;
@@ -451,15 +453,11 @@ internal static string GetLongPathName(
 
             string[] parts = path.Split(directorySeparatorCharacters);
             string pathRoot;
-            bool isUnc = path.StartsWith(s_directorySeparator + s_directorySeparator, StringComparison.Ordinal);
+            bool isUnc = path.StartsWith(s_twoDirectorySeparators, StringComparison.Ordinal);
             int startingElement;
             if (isUnc)
             {
-                pathRoot = s_directorySeparator + s_directorySeparator;
-                pathRoot += parts[2];
-                pathRoot += s_directorySeparator;
-                pathRoot += parts[3];
-                pathRoot += s_directorySeparator;
+                pathRoot = $"{s_twoDirectorySeparators}{parts[2]}{s_directorySeparatorString}{parts[3]}{s_directorySeparatorString}";
                 startingElement = 4;
             }
             else
@@ -468,7 +466,7 @@ internal static string GetLongPathName(
                 if (path.Length > 2 && path[1] == ':')
                 {
                     // Not relative
-                    pathRoot = parts[0] + s_directorySeparator;
+                    pathRoot = parts[0] + s_directorySeparatorString;
                     startingElement = 1;
                 }
                 else
@@ -493,7 +491,7 @@ internal static string GetLongPathName(
                 }
                 else
                 {
-                    if (parts[i].IndexOf("~", StringComparison.Ordinal) == -1)
+                    if (!parts[i].Contains('~'))
                     {
                         // If there's no ~, don't hit the disk.
                         longParts[i - startingElement] = parts[i];
@@ -529,7 +527,7 @@ internal static string GetLongPathName(
                 }
             }
 
-            return pathRoot + string.Join(s_directorySeparator, longParts);
+            return pathRoot + string.Join(s_directorySeparatorString, longParts);
         }
 
         /// <summary>
@@ -562,8 +560,7 @@ internal void SplitFileSpec(
              */
             if (recursiveDirectoryMatch == filenamePart)
             {
-                wildcardDirectoryPart += recursiveDirectoryMatch;
-                wildcardDirectoryPart += s_directorySeparator;
+                wildcardDirectoryPart = $"{wildcardDirectoryPart}{recursiveDirectoryMatch}{s_directorySeparatorString}";
                 filenamePart = "*.*";
             }
 
@@ -1107,7 +1104,7 @@ private static RecursiveStepResult GetFilesRecursiveStep(
                 // or we've reached the end of the wildcard directory elements,
                 considerFiles = true;
             }
-            else if (recursionState.RemainingWildcardDirectory.IndexOf(recursiveDirectoryMatch, StringComparison.Ordinal) == 0)
+            else if (recursionState.RemainingWildcardDirectory.StartsWith(recursiveDirectoryMatch, StringComparison.Ordinal))
             {
                 // or, we've reached a "**" so everything else is matched recursively.
                 considerFiles = true;
@@ -1211,22 +1208,10 @@ internal static string RegularExpressionFromFileSpec(
         /// </summary>
         /// <returns>True if both parts meet all conditions for a legal filespec.</returns>
         private static bool IsLegalFileSpec(string wildcardDirectoryPart, string filenamePart) =>
-            !HasDotDot(wildcardDirectoryPart)
+            !wildcardDirectoryPart.Contains("..")
             && !HasMisplacedRecursiveOperator(wildcardDirectoryPart)
             && !HasMisplacedRecursiveOperator(filenamePart);
 
-        private static bool HasDotDot(string str)
-        {
-            for (int i = 0; i < str.Length - 1; i++)
-            {
-                if (str[i] == '.' && str[i + 1] == '.')
-                {
-                    return true;
-                }
-            }
-            return false;
-        }
-
         private static bool HasMisplacedRecursiveOperator(string str)
         {
             for (int i = 0; i < str.Length - 1; i++)
@@ -1585,7 +1570,7 @@ internal void GetFileSpecInfo(
         internal static bool RawFileSpecIsValid(string filespec)
         {
             // filespec cannot contain illegal characters
-            if (-1 != filespec.IndexOfAny(s_invalidPathChars))
+            if (filespec.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) >= 0)
             {
                 return false;
             }
@@ -1595,7 +1580,7 @@ internal static bool RawFileSpecIsValid(string filespec)
              *
              * Any path with "..." in it is illegal.
              */
-            if (-1 != filespec.IndexOf("...", StringComparison.Ordinal))
+            if (filespec.Contains("..."))
             {
                 return false;
             }
@@ -1607,12 +1592,12 @@ internal static bool RawFileSpecIsValid(string filespec)
              *        http://www.website.com
              *
              */
-            int rightmostColon = filespec.LastIndexOf(":", StringComparison.Ordinal);
+            int rightmostColon = filespec.LastIndexOf(':');
 
             if
             (
-                -1 != rightmostColon
-                && 1 != rightmostColon)
+                rightmostColon >= 0
+                && rightmostColon != 1)
             {
                 return false;
             }
@@ -2229,7 +2214,7 @@ internal static string Normalize(string aString)
                 // replace multiple slashes with the OS separator
                 else if (afterSlashesIndex > index)
                 {
-                    sb.Append(s_directorySeparator);
+                    sb.Append(s_directorySeparatorString);
                 }
 
                 // skip non-slashes
@@ -2526,7 +2511,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                                 Debug.Assert(excludeState.SearchData.RegexFileMatch != null || excludeState.SearchData.DirectoryPattern != null,
                                     "Expected Regex or directory pattern to be used for exclude file matching");
                                 excludeState.BaseDirectory = state.BaseDirectory;
-                                excludeState.RemainingWildcardDirectory = recursiveDirectoryMatch + s_directorySeparator;
+                                excludeState.RemainingWildcardDirectory = recursiveDirectoryMatch + s_directorySeparatorString;
                                 searchesToExclude.Add(excludeState);
                             }
                         }
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index e8fbff8e6e3..911439a8bb0 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -7,6 +7,9 @@
 #else
 using Microsoft.Build.Shared.Concurrent;
 #endif
+#if NET
+using System.Buffers;
+#endif
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
@@ -71,7 +74,7 @@ public static bool GetIsFileSystemCaseSensitive()
         {
             try
             {
-                string pathWithUpperCase = Path.Combine(Path.GetTempPath(), "CASESENSITIVETEST" + Guid.NewGuid().ToString("N"));
+                string pathWithUpperCase = Path.Combine(Path.GetTempPath(), $"CASESENSITIVETEST{Guid.NewGuid():N}");
                 using (new FileStream(pathWithUpperCase, FileMode.CreateNew, FileAccess.ReadWrite, FileShare.None, 0x1000, FileOptions.DeleteOnClose))
                 {
                     string lowerCased = pathWithUpperCase.ToLowerInvariant();
@@ -91,20 +94,24 @@ public static bool GetIsFileSystemCaseSensitive()
         /// Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidPathChars =
+#if NET
+        internal static readonly SearchValues<char> InvalidPathChars = SearchValues.Create(
+#else
+        internal static readonly char[] InvalidPathChars = (
+#endif
         [
             '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
             (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20,
             (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30,
             (char)31
-        ];
+        ]);
 
         /// <summary>
         /// Copied from https://github.com/dotnet/corefx/blob/387cf98c410bdca8fd195b28cbe53af578698f94/src/System.Runtime.Extensions/src/System/IO/Path.Windows.cs#L18
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidFileNameChars =
+        internal static readonly char[] InvalidFileNameCharsArray =
         [
             '\"', '<', '>', '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
@@ -113,6 +120,12 @@ public static bool GetIsFileSystemCaseSensitive()
             (char)31, ':', '*', '?', '\\', '/'
         ];
 
+#if NET
+        internal static readonly SearchValues<char> InvalidFileNameChars = SearchValues.Create(InvalidFileNameCharsArray);
+#else
+        internal static char[] InvalidFileNameChars => InvalidFileNameCharsArray;
+#endif
+
         internal static readonly char[] Slashes = { '/', '\\' };
 
         internal static readonly string DirectorySeparatorString = Path.DirectorySeparatorChar.ToString();
@@ -179,7 +192,7 @@ internal static bool CanWriteToDirectory(string directory)
         {
             try
             {
-                string testFilePath = Path.Combine(directory, $"MSBuild_{Guid.NewGuid().ToString("N")}_testFile.txt");
+                string testFilePath = Path.Combine(directory, $"MSBuild_{Guid.NewGuid():N}_testFile.txt");
                 FileInfo file = new(testFilePath);
                 file.Directory.Create(); // If the directory already exists, this method does nothing.
                 File.WriteAllText(testFilePath, $"MSBuild process {EnvironmentUtilities.CurrentProcessId} successfully wrote to file.");
@@ -258,7 +271,11 @@ internal static string EnsureTrailingNoLeadingSlash(string path, int start)
 
             return FixFilePath(start < stop && IsSlash(path[stop - 1]) ?
                 path.Substring(start) :
+#if NET
+                string.Concat(path.AsSpan(start), new(in Path.DirectorySeparatorChar)));
+#else
                 path.Substring(start) + Path.DirectorySeparatorChar);
+#endif
         }
 
         /// <summary>
@@ -315,7 +332,11 @@ internal static string EnsureQuotes(string path, bool isSingleQuote = true)
                 // Special case: convert the quotes.
                 if (path.Length > 1 && path[0] == convertQuote && path[path.Length - 1] == convertQuote)
                 {
+#if NET
+                    path = $"{targetQuote}{path.AsSpan(1, path.Length - 2)}{targetQuote}";
+#else
                     path = $"{targetQuote}{path.Substring(1, path.Length - 2)}{targetQuote}";
+#endif
                 }
                 // Enclose the path in a set of the 'target' quote unless the string is already quoted with the 'target' quotes.
                 else if (path.Length == 1 || path[0] != targetQuote || path[path.Length - 1] != targetQuote)
@@ -752,14 +773,20 @@ internal static bool HasExtension(string fileName, string[] allowedExtensions)
         /// </summary>
         /// <param name="fileSpec">The file spec to get the full path of.</param>
         /// <param name="currentDirectory"></param>
-        /// <returns>full path</returns>
-        internal static string GetFullPath(string fileSpec, string currentDirectory)
+        /// <param name="escape">Whether to escape the path after getting the full path.</param>
+        /// <returns>Full path to the file, escaped if not specified otherwise.</returns>
+        internal static string GetFullPath(string fileSpec, string currentDirectory, bool escape = true)
         {
             // Sending data out of the engine into the filesystem, so time to unescape.
             fileSpec = FixFilePath(EscapingUtilities.UnescapeAll(fileSpec));
 
-            // Data coming back from the filesystem into the engine, so time to escape it back.
-            string fullPath = EscapingUtilities.Escape(NormalizePath(Path.Combine(currentDirectory, fileSpec)));
+            string fullPath = NormalizePath(Path.Combine(currentDirectory, fileSpec));
+            // In some cases we might want to NOT escape in order to preserve symbols like @, %, $ etc.
+            if (escape)
+            {
+                // Data coming back from the filesystem into the engine, so time to escape it back.
+                fullPath = EscapingUtilities.Escape(fullPath);
+            }
 
             if (NativeMethodsShared.IsWindows && !EndsWithSlash(fullPath))
             {
@@ -838,17 +865,23 @@ internal static string NormalizePathForComparisonNoThrow(string path, string cur
 
         internal static bool PathIsInvalid(string path)
         {
-            if (path.IndexOfAny(InvalidPathChars) >= 0)
-            {
-                return true;
-            }
-
             // Path.GetFileName does not react well to malformed filenames.
             // For example, Path.GetFileName("a/b/foo:bar") returns bar instead of foo:bar
             // It also throws exceptions on illegal path characters
-            var lastDirectorySeparator = path.LastIndexOfAny(Slashes);
-
-            return path.IndexOfAny(InvalidFileNameChars, lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0) >= 0;
+#if NET
+            if (!path.AsSpan().ContainsAny(InvalidPathChars))
+            {
+                int lastDirectorySeparator = path.LastIndexOfAny(Slashes);
+                return path.AsSpan(lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0).ContainsAny(InvalidFileNameChars);
+            }
+#else
+            if (path.IndexOfAny(InvalidPathChars) < 0)
+            {
+                int lastDirectorySeparator = path.LastIndexOfAny(Slashes);
+                return path.IndexOfAny(InvalidFileNameChars, lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0) >= 0;
+            }
+#endif
+            return true;
         }
 
         /// <summary>
@@ -1532,12 +1565,20 @@ internal static void ClearFileExistenceCache()
 
         internal static void ReadFromStream(this Stream stream, byte[] content, int startIndex, int length)
         {
-#if NET7_0_OR_GREATER
+#if NET
             stream.ReadExactly(content, startIndex, length);
 #else
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read'
-            stream.Read(content, 0, length);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+            int bytesRead = 0;
+            while (bytesRead < length)
+            {
+                int read = stream.Read(content, startIndex + bytesRead, length - bytesRead);
+                if (read == 0)
+                {
+                    throw new EndOfStreamException();
+                }
+
+                bytesRead += read;
+            }
 #endif
         }
     }
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index 76e283a1a2a..c35f1f9ed5f 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -52,7 +52,11 @@ internal static bool StartsWithDrivePattern(string pattern)
             // first character must be a letter,
             // second character must be a ":"
             return pattern.Length >= 2 &&
+#if NET
+                char.IsAsciiLetter(pattern[0]) &&
+#else
                 ((pattern[0] >= 'A' && pattern[0] <= 'Z') || (pattern[0] >= 'a' && pattern[0] <= 'z')) &&
+#endif
                 pattern[1] == ':';
         }
 
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 2bc28819c6e..458272bcc30 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -97,7 +97,7 @@ internal static class FrameworkLocationHelper
         private const string dotNetFrameworkRegistryKeyV20 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionV20;
 
         internal static string dotNetFrameworkVersionFolderPrefixV30 = NativeMethodsShared.IsWindows ? "v3.0" : "3.0"; // v3.0 is for WinFx.
-        private static string s_dotNetFrameworkRegistryKeyV30 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV30 + "\\Setup";
+        private static readonly string s_dotNetFrameworkRegistryKeyV30 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV30 + "\\Setup";
 
 #if FEATURE_WIN32_REGISTRY
         private const string fallbackDotNetFrameworkSdkRegistryInstallPath = "SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows";
@@ -111,7 +111,7 @@ internal static class FrameworkLocationHelper
         private const string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A = "HKEY_LOCAL_MACHINE\\" + dotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
 
         internal static string dotNetFrameworkVersionFolderPrefixV35 = NativeMethodsShared.IsWindows ? "v3.5" : "3.5"; // v3.5 is for Orcas.
-        private static string s_dotNetFrameworkRegistryKeyV35 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV35;
+        private static readonly string s_dotNetFrameworkRegistryKeyV35 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV35;
 
         internal const string fullDotNetFrameworkSdkRegistryKeyV35OnVS10 = fullDotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
         internal const string fullDotNetFrameworkSdkRegistryKeyV35OnVS11 = fullDotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
@@ -512,7 +512,7 @@ private static string FallbackDotNetFrameworkSdkInstallPath
                                 fallbackDotNetFrameworkSdkRegistryInstallPath,
                                 fallbackDotNetFrameworkSdkInstallKeyValue);
 
-                        if (EnvironmentUtilities.Is64BitProcess && s_fallbackDotNetFrameworkSdkInstallPath == null)
+                        if (Environment.Is64BitProcess && s_fallbackDotNetFrameworkSdkInstallPath == null)
                         {
                             // Since we're 64-bit, what we just checked was the 64-bit fallback key -- so now let's
                             // check the 32-bit one too, just in case.
@@ -773,8 +773,7 @@ internal static string FindDotNetFrameworkPath(
         {
             if (!NativeMethodsShared.IsWindows)
             {
-                if (!string.IsNullOrEmpty(prefix)
-                    && prefix.Substring(0, 1).Equals("v", StringComparison.OrdinalIgnoreCase))
+                if (!string.IsNullOrEmpty(prefix) && prefix[0] is 'v' or 'V')
                 {
                     prefix = prefix.Substring(1);
                 }
@@ -813,8 +812,12 @@ internal static string FindDotNetFrameworkPath(
                 // the path is something like 'C:\MyPath\64\Framework64'.  9 = length of 'Framework', to make the index match
                 // the location of the '64'.
                 int indexOf64 = indexOfFramework64 + 9;
-                string tempLocation = baseLocation;
-                baseLocation = tempLocation.Substring(0, indexOf64) + tempLocation.Substring(indexOf64 + 2, tempLocation.Length - indexOf64 - 2);
+                baseLocation =
+#if NET
+                    string.Concat(baseLocation.AsSpan(0, indexOf64), baseLocation.AsSpan(indexOf64 + 2));
+#else
+                    baseLocation.Substring(0, indexOf64) + baseLocation.Substring(indexOf64 + 2);
+#endif
             }
             else if (indexOfFramework64 == -1 && architecture == DotNetFrameworkArchitecture.Bitness64)
             {
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 36e8e9db0df..3c617c54014 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -1,4 +1,4 @@
-// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -270,15 +270,17 @@ internal abstract class LogMessagePacketBase : INodePacket
         /// </summary>
         private static readonly int s_defaultPacketVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
 
+#if TASKHOST
         /// <summary>
         /// Dictionary of methods used to read BuildEventArgs.
         /// </summary>
-        private static Dictionary<LoggingEventType, MethodInfo> s_readMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
+        private static readonly Dictionary<LoggingEventType, MethodInfo> s_readMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
 
+#endif
         /// <summary>
         /// Dictionary of methods used to write BuildEventArgs.
         /// </summary>
-        private static Dictionary<LoggingEventType, MethodInfo> s_writeMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
+        private static readonly Dictionary<LoggingEventType, MethodInfo> s_writeMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
 
         /// <summary>
         /// Delegate for translating targetfinished events.
@@ -478,6 +480,8 @@ internal void ReadFromStream(ITranslator translator)
 
             if (eventCanSerializeItself)
             {
+
+#if TASKHOST
                 MethodInfo methodInfo = null;
                 lock (s_readMethodCache)
                 {
@@ -492,6 +496,11 @@ internal void ReadFromStream(ITranslator translator)
                 ArgsReaderDelegate readerMethod = (ArgsReaderDelegate)CreateDelegateRobust(typeof(ArgsReaderDelegate), _buildEvent, methodInfo);
 
                 readerMethod(translator.Reader, packetVersion);
+
+#else
+                _buildEvent.CreateFromStream(translator.Reader, packetVersion);
+#endif
+
                 if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
                 {
                     _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
diff --git a/src/Shared/MSBuildNameIgnoreCaseComparer.cs b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
index 9517b5f2646..e8e9a65b9eb 100644
--- a/src/Shared/MSBuildNameIgnoreCaseComparer.cs
+++ b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
@@ -64,6 +64,9 @@ public bool Equals(string compareToString, string constrainedString, int start,
                 return false;
             }
 
+#if NET
+            return compareToString.AsSpan().Equals(constrainedString.AsSpan(start, lengthToCompare), StringComparison.OrdinalIgnoreCase);
+#else
             if (lengthToCompare != compareToString.Length)
             {
                 return false;
@@ -104,6 +107,7 @@ public bool Equals(string compareToString, string constrainedString, int start,
             }
 
             return true;
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index a6c203525d2..d7e77955644 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -69,7 +69,7 @@ internal static class ItemSpecModifiers
                     DefiningProjectExtension
                 };
 
-            private static HashSet<string> s_tableOfItemSpecModifiers = new HashSet<string>(All, StringComparer.OrdinalIgnoreCase);
+            private static readonly HashSet<string> s_tableOfItemSpecModifiers = new HashSet<string>(All, StringComparer.OrdinalIgnoreCase);
 
             /// <summary>
             /// Indicates if the given name is reserved for an item-spec modifier.
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index 18b9b361e3b..c21db16aa0e 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -61,18 +61,18 @@ internal static string GetNearestPlatform(string overridePlatformValue, string r
             // Prioritize platformLookupTable **metadata** attached to the ProjectReference item
             // before the current project's table. We do this to allow per-ProjectReference fine tuning.
             else if (projectReferenceLookupTable != null &&
-                    projectReferenceLookupTable.ContainsKey(currentProjectPlatform) &&
-                    projectReferencePlatforms.Contains(projectReferenceLookupTable[currentProjectPlatform]))
+                    projectReferenceLookupTable.TryGetValue(currentProjectPlatform, out string? value) &&
+                    projectReferencePlatforms.Contains(value))
             {
-                buildProjectReferenceAs = projectReferenceLookupTable[currentProjectPlatform];
+                buildProjectReferenceAs = value;
                 log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
             }
             // Current project's translation table follows
             else if (currentProjectLookupTable != null &&
-                    currentProjectLookupTable.ContainsKey(currentProjectPlatform) &&
-                    projectReferencePlatforms.Contains(currentProjectLookupTable[currentProjectPlatform]))
+                    currentProjectLookupTable.TryGetValue(currentProjectPlatform, out value) &&
+                    projectReferencePlatforms.Contains(value))
             {
-                buildProjectReferenceAs = currentProjectLookupTable[currentProjectPlatform];
+                buildProjectReferenceAs = value;
                 log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, platformLookupTable);
             }
             // AnyCPU if possible
diff --git a/src/Shared/ProcessExtensions.cs b/src/Shared/ProcessExtensions.cs
index 362a8b0a8c1..d13ebbac5fe 100644
--- a/src/Shared/ProcessExtensions.cs
+++ b/src/Shared/ProcessExtensions.cs
@@ -11,7 +11,7 @@ internal static class ProcessExtensions
     {
         public static void KillTree(this Process process, int timeoutMilliseconds)
         {
-#if NETCOREAPP
+#if NET
             process.Kill(entireProcessTree: true);
 #else
             if (NativeMethodsShared.IsWindows)
diff --git a/src/Shared/ProjectWriter.cs b/src/Shared/ProjectWriter.cs
index fa2e6f76a1c..d5a5a00003f 100644
--- a/src/Shared/ProjectWriter.cs
+++ b/src/Shared/ProjectWriter.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Shared
     /// This class is used to save MSBuild project files. It contains special handling for MSBuild notations that are not saved
     /// correctly by the XML DOM's default save mechanism.
     /// </summary>
-    internal sealed class ProjectWriter : XmlTextWriter
+    internal sealed partial class ProjectWriter : XmlTextWriter
     {
         #region Regular expressions for item vector transforms
 
@@ -28,9 +28,7 @@ internal sealed class ProjectWriter : XmlTextWriter
         // Note that the pattern is more strict than the rules for valid XML element names.
         internal const string itemTypeOrMetadataNameSpecification = @"[A-Za-z_][A-Za-z_0-9\-]*";
 
-        // the portion of an item transform that is the function that we wish to execute on the item
-        internal const string itemFunctionNameSpecification = @"[A-Za-z]*";
-
+        // regular expression used to match item vector transforms
         // description of an item vector transform, including the optional separator specification
         private const string itemVectorTransformSpecification =
             @"(?<PREFIX>@\(\s*)
@@ -40,15 +38,9 @@ internal sealed class ProjectWriter : XmlTextWriter
               (?<SUFFIX>\s*\))";
         // )
 
-        // regular expression used to match item vector transforms
-        // internal for unit testing only
-        internal static readonly Lazy<Regex> itemVectorTransformPattern = new Lazy<Regex>(
-            () =>
-                new Regex(itemVectorTransformSpecification,
-                    RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
-
         // description of an item vector transform, including the optional separator specification, but with no (named) capturing
         // groups -- see the WriteString() method for details
+        // regular expression used to match item vector transforms, with no (named) capturing groups
         private const string itemVectorTransformRawSpecification =
             @"@\(\s*
                 (" + itemTypeOrMetadataNameSpecification + @")
@@ -56,12 +48,21 @@ internal sealed class ProjectWriter : XmlTextWriter
                 (\s*,\s*'[^']*')?
               \s*\)";
 
-        // regular expression used to match item vector transforms, with no (named) capturing groups
-        // internal for unit testing only
-        internal static readonly Lazy<Regex> itemVectorTransformRawPattern = new Lazy<Regex>(
-            () =>
-                new Regex(itemVectorTransformRawSpecification,
-                    RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
+#if NET
+        [GeneratedRegex(itemVectorTransformSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture)]
+        private static partial Regex ItemVectorTransformRegex { get; }
+
+        [GeneratedRegex(itemVectorTransformRawSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture)]
+        private static partial Regex ItemVectorTransformRawRegex { get; }
+#else
+        private static Regex ItemVectorTransformRegex => itemVectorTransformPattern ??=
+            new Regex(itemVectorTransformSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
+        private static Regex itemVectorTransformPattern;
+
+        private static Regex ItemVectorTransformRawRegex => itemVectorTransformRawPattern ??=
+            new Regex(itemVectorTransformRawSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
+        private static Regex itemVectorTransformRawPattern;
+#endif
 
         /**************************************************************************************************************************
          * WARNING: The regular expressions above MUST be kept in sync with the expressions in the ItemExpander class.
@@ -130,14 +131,14 @@ internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementD
         /// <param name="text"></param>
         public override void WriteString(string text)
         {
-            MatchCollection itemVectorTransforms = itemVectorTransformRawPattern.Value.Matches(text);
+            MatchCollection itemVectorTransforms = ItemVectorTransformRawRegex.Matches(text);
 
             // if the string contains any item vector transforms
             if (itemVectorTransforms.Count > 0)
             {
                 // separate out the text that surrounds the transforms
                 // NOTE: use the Regex with no (named) capturing groups, otherwise Regex.Split() will split on them
-                string[] surroundingTextPieces = itemVectorTransformRawPattern.Value.Split(text);
+                string[] surroundingTextPieces = ItemVectorTransformRawRegex.Split(text);
 
                 ErrorUtilities.VerifyThrow(itemVectorTransforms.Count == (surroundingTextPieces.Length - 1),
                     "We must have two pieces of surrounding text for every item vector transform found.");
@@ -149,7 +150,7 @@ public override void WriteString(string text)
                     base.WriteString(surroundingTextPieces[i]);
 
                     // break up the transform into its constituent pieces
-                    Match itemVectorTransform = itemVectorTransformPattern.Value.Match(itemVectorTransforms[i].Value);
+                    Match itemVectorTransform = ItemVectorTransformRegex.Match(itemVectorTransforms[i].Value);
 
                     ErrorUtilities.VerifyThrow(itemVectorTransform.Success,
                         "Item vector transform must be matched by both the raw and decorated regular expressions.");
diff --git a/src/Shared/PropertyParser.cs b/src/Shared/PropertyParser.cs
index a9e1c29d72c..48110e0ca4c 100644
--- a/src/Shared/PropertyParser.cs
+++ b/src/Shared/PropertyParser.cs
@@ -47,10 +47,10 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
                     // whitespace from beginning and end of both name and value.  (When authoring a
                     // project/targets file, people like to use whitespace and newlines to pretty up
                     // the file format.)
-                    if (indexOfEqualsSign != -1)
+                    if (indexOfEqualsSign >= 0)
                     {
-                        propertyName = propertyNameValuePair.Substring(0, indexOfEqualsSign).Trim();
-                        propertyValue = propertyNameValuePair.Substring(indexOfEqualsSign + 1).Trim();
+                        propertyName = propertyNameValuePair.AsSpan(0, indexOfEqualsSign).Trim().ToString();
+                        propertyValue = propertyNameValuePair.AsSpan(indexOfEqualsSign + 1).Trim().ToString();
                     }
 
                     // Make sure we have a property name and property value (though the value is allowed to be blank).
@@ -103,8 +103,8 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
                         // whitespace from beginning and end of both name and value.  (When authoring a
                         // project/targets file, people like to use whitespace and newlines to pretty up
                         // the file format.)
-                        string propertyName = propertyNameValueString.Substring(0, indexOfEqualsSign).Trim();
-                        string propertyValue = EscapingUtilities.Escape(propertyNameValueString.Substring(indexOfEqualsSign + 1).Trim());
+                        string propertyName = propertyNameValueString.AsSpan(0, indexOfEqualsSign).Trim().ToString();
+                        string propertyValue = EscapingUtilities.Escape(propertyNameValueString.AsSpan(indexOfEqualsSign + 1).Trim().ToString());
 
                         // Make sure we have a property name and property value (though the value is allowed to be blank).
                         if (propertyName.Length == 0)
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index d7d25b7d962..10391f5d336 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -22,7 +22,7 @@ internal class RegisteredTaskObjectCacheBase
         /// <summary>
         /// The cache for AppDomain lifetime objects.
         /// </summary>
-        private static Lazy<ConcurrentDictionary<object, object>> s_appDomainLifetimeObjects = new Lazy<ConcurrentDictionary<object, object>>();
+        private static readonly Lazy<ConcurrentDictionary<object, object>> s_appDomainLifetimeObjects = new Lazy<ConcurrentDictionary<object, object>>();
 
         /// <summary>
         /// The cache for Build lifetime objects.
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index e046c7d4c5a..7ff74c83f19 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -122,7 +122,7 @@ internal static string ExtractMessageCode(bool msbuildCodeOnly, string message,
 
             if (i < message.Length)
             {
-                message = message.Substring(i, message.Length - i);
+                message = message.Substring(i);
             }
 
             return message;
diff --git a/src/Shared/StringUtils.cs b/src/Shared/StringUtils.cs
index 10152956f27..cb109d5f9d6 100644
--- a/src/Shared/StringUtils.cs
+++ b/src/Shared/StringUtils.cs
@@ -16,6 +16,10 @@ internal static class StringUtils
         /// <returns>Random generated string of the specified length.</returns>
         public static string GenerateRandomString(int length)
         {
+#if NET
+            return string.Create(length, 0, static (dest, _) =>
+                Random.Shared.GetItems("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_", dest));
+#else
             // Base64, 2^6 = 64
             const int eachStringCharEncodesBites = 6;
             const int eachByteHasBits = 8;
@@ -32,6 +36,7 @@ public static string GenerateRandomString(int length)
             string randomBase64String = Convert.ToBase64String(randomBytes).Replace('/', '_');
 
             return randomBase64String.Substring(0, length);
+#endif
         }
 
         /// <summary>
@@ -45,10 +50,14 @@ public static string RemoveLastInstanceOf(this string fromString, string substri
         {
             int lastOccurrenceIndex = fromString.LastIndexOf(substring, comparison);
 
-            if (lastOccurrenceIndex != -1)
+            if (lastOccurrenceIndex >= 0)
             {
-                fromString = fromString.Substring(0, lastOccurrenceIndex) +
-                             fromString.Substring(lastOccurrenceIndex + substring.Length);
+                fromString =
+#if NET
+                    $"{fromString.AsSpan(0, lastOccurrenceIndex)}{fromString.AsSpan(lastOccurrenceIndex + substring.Length)}";
+#else
+                    $"{fromString.Substring(0, lastOccurrenceIndex)}{fromString.Substring(lastOccurrenceIndex + substring.Length)}";
+#endif
             }
 
             return fromString;
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index 190f0dddf2b..4c607dfd2b4 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -82,7 +82,7 @@ private static string CreateFolderUnderTemp()
         /// <param name="subfolder"></param>
         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)
         {
-            string temporaryDirectory = Path.Combine(TempFileDirectory, "Temporary" + Guid.NewGuid().ToString("N"), subfolder ?? string.Empty);
+            string temporaryDirectory = Path.Combine(TempFileDirectory, $"Temporary{Guid.NewGuid():N}", subfolder ?? string.Empty);
 
             if (createDirectory)
             {
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 0e2f7591b55..70002db51f0 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -279,7 +279,7 @@ private void UpdateOSMap(ConfigurationElement element)
                     {
                         if (element.ElementInformation.LineNumber != 0)
                         {
-                            locationString = String.Format("{0} ({1})", element.ElementInformation.Source, element.ElementInformation.LineNumber);
+                            locationString = $"{element.ElementInformation.Source} ({element.ElementInformation.LineNumber})";
                         }
                         else
                         {
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index 87b3a3b7e67..154c6ff6f05 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -25,7 +25,7 @@ internal static class Tracing
         /// <summary>
         /// A dictionary of named counters
         /// </summary>
-        private static Dictionary<string, int> s_counts;
+        private static readonly Dictionary<string, int> s_counts;
 
         /// <summary>
         /// Last time logging happened
@@ -35,7 +35,7 @@ internal static class Tracing
         /// <summary>
         /// How often to log
         /// </summary>
-        private static TimeSpan s_interval;
+        private static readonly TimeSpan s_interval;
 
         /// <summary>
         /// A place callers can put something worth logging later
@@ -45,7 +45,7 @@ internal static class Tracing
         /// <summary>
         /// Short name of the current assembly - to distinguish statics when this type is shared into different assemblies
         /// </summary>
-        private static string s_currentAssemblyName;
+        private static readonly string s_currentAssemblyName;
 #pragma warning restore 649
 
 #if DEBUG
@@ -95,7 +95,7 @@ internal static void Slot(string tag, string value)
         [Conditional("DEBUG")]
         internal static void Slot<K, V>(string tag, KeyValuePair<K, V> value)
         {
-            Slot(tag, value.Key.ToString() + "=" + value.Key.ToString());
+            Slot(tag, $"{value.Key}={value.Key}");
         }
 
         /// <summary>
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 3a3013b36aa..7c5efa8ce3d 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -31,12 +31,12 @@ internal class TypeLoader
         /// <summary>
         /// Cache to keep track of the assemblyLoadInfos based on a given type filter.
         /// </summary>
-        private static ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfLoadedTypesByFilter = new ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>>();
+        private static readonly ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfLoadedTypesByFilter = new ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>>();
 
         /// <summary>
         /// Cache to keep track of the assemblyLoadInfos based on a given type filter for assemblies which are to be loaded for reflectionOnlyLoads.
         /// </summary>
-        private static ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfReflectionOnlyLoadedTypesByFilter = new ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>>();
+        private static readonly ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfReflectionOnlyLoadedTypesByFilter = new ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>>();
 
         /// <summary>
         /// Type filter for this typeloader
@@ -45,7 +45,7 @@ internal class TypeLoader
 
         private static MetadataLoadContext _context;
 
-        private static string[] runtimeAssemblies = findRuntimeAssembliesWithMicrosoftBuildFramework();
+        private static readonly string[] runtimeAssemblies = findRuntimeAssembliesWithMicrosoftBuildFramework();
         private static string microsoftBuildFrameworkPath;
 
         // We need to append Microsoft.Build.Framework from next to the executing assembly first to make sure it's loaded before the runtime variant.
@@ -56,10 +56,7 @@ private static string[] findRuntimeAssembliesWithMicrosoftBuildFramework()
             string[] msbuildAssemblies = Directory.GetFiles(msbuildDirectory, "*.dll");
             string[] runtimeAssemblies = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");
 
-            List<string> runtimeAssembliesList = new(runtimeAssemblies);
-            runtimeAssembliesList.AddRange(msbuildAssemblies);
-
-            return runtimeAssembliesList.ToArray();
+            return [.. runtimeAssemblies, .. msbuildAssemblies];
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index efb5d7297ab..b96ee0700d4 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -123,7 +123,7 @@ public void SetCurrentDirectoryDoesNotSetNonexistentFolder()
             {
                 for (int i = 0; i < 10; i++)
                 {
-                    nonexistentDirectory = Path.Combine(currentDirectory, "foo", "bar", "baz") + Guid.NewGuid();
+                    nonexistentDirectory = $"{Path.Combine(currentDirectory, "foo", "bar", "baz")}{Guid.NewGuid()}";
 
                     if (!Directory.Exists(nonexistentDirectory))
                     {
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 25e7cb3a50d..0ccd5682302 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using Microsoft.Build.Shared;
 
 using Shouldly;
@@ -130,7 +131,7 @@ public void TestMergeRuntimeValuesCurrentToCore()
         public void TestArchitectureValuesMatch()
         {
             string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
-            string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
+            string notCurrentArchitecture = Environment.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             Assert.True(XMakeAttributes.ArchitectureValuesMatch(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture));
             Assert.True(XMakeAttributes.ArchitectureValuesMatch(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.x64));
@@ -145,7 +146,7 @@ public void TestArchitectureValuesMatch()
         public void TestMergeArchitectureValues()
         {
             string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
-            string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
+            string notCurrentArchitecture = Environment.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             string mergedArchitecture;
             Assert.True(XMakeAttributes.TryMergeArchitectureValues(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture, out mergedArchitecture));
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index 91c4721f00c..99e1e36774d 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -74,7 +74,7 @@ internal static Version ConvertToVersion(string version, bool throwException)
             // Versions must have at least a Major and a Minor (e.g. 10.0), so if it's
             // just one number without a decimal, add a decimal and a 0. Random strings
             // like "tmp" will be filtered out in the Parse() or TryParse() steps
-            if (version.IndexOf(".") == -1)
+            if (version.IndexOf('.') == -1)
             {
                 version += ".0";
             }
diff --git a/src/Shared/XMakeElements.cs b/src/Shared/XMakeElements.cs
index 991feb5796c..40d22e96234 100644
--- a/src/Shared/XMakeElements.cs
+++ b/src/Shared/XMakeElements.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Buffers;
 using System.Collections.Generic;
 
 #nullable disable
@@ -35,7 +36,12 @@ internal static class XMakeElements
         internal const string usingTaskBody = "Task";
         internal const string sdk = "Sdk";
 
-        internal static readonly char[] InvalidTargetNameCharacters = [ '$', '@', '(', ')', '%', '*', '?', '.' ];
+#if NET
+        internal static readonly SearchValues<char> InvalidTargetNameCharacters = SearchValues.Create(
+#else
+        internal static readonly char[] InvalidTargetNameCharacters = (
+#endif
+            ['$', '@', '(', ')', '%', '*', '?', '.']);
 
         // Names that cannot be used as property or item names because they are reserved
         internal static readonly HashSet<string> ReservedItemNames =
diff --git a/src/StringTools.Benchmark/StringTools.Benchmark.csproj b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
index 763be443c66..193a82a792b 100644
--- a/src/StringTools.Benchmark/StringTools.Benchmark.csproj
+++ b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
@@ -16,12 +16,6 @@
     <PackageReference Include="BenchmarkDotNet" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Bump these to the latest version despite transitive references to older -->
-    <PackageReference Include="System.Private.Uri" />
-    <PackageReference Include="System.Runtime" />
-  </ItemGroup>
-
   <ItemGroup>
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
index b48cd46cb93..0cb576f1675 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
@@ -12,7 +12,7 @@
 
   <ItemGroup>
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index 7e657d56cdb..d19afe2a662 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -387,7 +387,7 @@ private static unsafe uint GetHashCodeHelper(char* charPtr, int length, uint has
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         private static uint RotateLeft(uint value, int offset)
         {
-#if NETCOREAPP
+#if NET
             return System.Numerics.BitOperations.RotateLeft(value, offset);
 #else
             // Copied from System\Numerics\BitOperations.cs in dotnet/runtime as the routine is not available on .NET Framework.
diff --git a/src/StringTools/WeakStringCacheInterner.cs b/src/StringTools/WeakStringCacheInterner.cs
index 2eb3fd23231..cc53c501ce3 100644
--- a/src/StringTools/WeakStringCacheInterner.cs
+++ b/src/StringTools/WeakStringCacheInterner.cs
@@ -85,7 +85,7 @@ public string InternableToString(ref InternableString candidate)
             string expectedString = candidate.ExpensiveConvertToString();
             if (!String.Equals(internedString, expectedString))
             {
-                throw new InvalidOperationException(String.Format("Interned string {0} should have been {1}", internedString, expectedString));
+                throw new InvalidOperationException($"Interned string {internedString} should have been {expectedString}");
             }
 #endif
 
@@ -137,12 +137,12 @@ public string FormatStatistics()
 
             if (_internCallCountsByString != null)
             {
-                result.AppendLine(string.Format("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Hits", _regularInternHits, "hits"));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Misses", _regularInternMisses, "misses"));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings"));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars"));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes"));
+                result.AppendLine($"\n{new string('=', 41 - (title.Length / 2))}{title}{new string('=', 41 - (title.Length / 2))}");
+                result.AppendLine($"||{"WeakStringCache Hits",50}|{_regularInternHits,20:N0}|{"hits",8}|");
+                result.AppendLine($"||{"WeakStringCache Misses",50}|{_regularInternMisses,20:N0}|{"misses",8}|");
+                result.AppendLine($"||{"Eliminated Strings*",50}|{_internEliminatedStrings,20:N0}|{"strings",8}|");
+                result.AppendLine($"||{"Eliminated Chars",50}|{_internEliminatedChars,20:N0}|{"chars",8}|");
+                result.AppendLine($"||{"Estimated Eliminated Bytes",50}|{_internEliminatedChars * 2,20:N0}|{"bytes",8}|");
                 result.AppendLine("Elimination assumes that strings provided were unique objects.");
                 result.AppendLine("|---------------------------------------------------------------------------------|");
 
@@ -158,7 +158,7 @@ public string FormatStatistics()
 
                 WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();
                 result.AppendLine("WeakStringCache statistics:");
-                result.AppendLine(string.Format("String count live/collected/total = {0}/{1}/{2}", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount));
+                result.AppendLine($"String count live/collected/total = {debugInfo.LiveStringCount}/{debugInfo.CollectedStringCount}/{debugInfo.LiveStringCount + debugInfo.CollectedStringCount}");
             }
             else
             {
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 26e53c59436..d79ac579d3d 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -79,11 +79,6 @@ public static IEnumerable<object[]> GetNullAndEmptyArrays() =>
             */
         };
 
-        private const int NoParallelismThreadCount = 1;
-        private const int DefaultParallelismThreadCount = int.MaxValue;
-
-        private int GetParallelismThreadCount(bool isUseSingleThreadedCopy) => isUseSingleThreadedCopy ? NoParallelismThreadCount : DefaultParallelismThreadCount;
-
         /// <summary>
         /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
@@ -509,7 +504,7 @@ public void DontCopyOverSameFile(bool isUseHardLinks, bool isUseSymbolicLinks, b
                     UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
-                t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy));
+                t.Execute(m.CopyFile, !isUseSingleThreadedCopy);
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -557,7 +552,7 @@ public void QuestionCopyFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool
                     FailIfNotIncremental = true,
                 };
 
-                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.False(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -617,7 +612,7 @@ public void QuestionCopyFileSameContent(bool isUseHardLinks, bool isUseSymbolicL
                     SkipUnchangedFiles = true,
                     FailIfNotIncremental = true,
                 };
-                Assert.True(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.True(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -670,7 +665,7 @@ public void QuestionCopyFileNotSameContent(bool isUseHardLinks, bool isUseSymbol
                     FailIfNotIncremental = true,
                 };
 
-                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.False(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -2015,7 +2010,7 @@ public void CopyWithDuplicatesUsingFolder(bool isUseHardLinks, bool isUseSymboli
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            }, !isUseSingleThreadedCopy);
 
             Assert.True(success);
             Assert.Equal(2, filesActuallyCopied.Count);
@@ -2082,7 +2077,7 @@ public void CopyWithDuplicatesUsingFiles(bool isUseHardLinks, bool isUseSymbolic
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            }, !isUseSingleThreadedCopy);
 
             Assert.True(success);
             Assert.Equal(4, filesActuallyCopied.Count);
@@ -2352,7 +2347,7 @@ public void FailureWithNoRetries(bool isUseHardLinks, bool isUseSymbolicLinks, b
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogDoesntContain("MSB3026");
@@ -2419,7 +2414,7 @@ public void SuccessAfterOneRetry(bool isUseHardLinks, bool isUseSymbolicLinks, b
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -2446,7 +2441,7 @@ public void SuccessAfterOneRetryContinueToNextFile(bool isUseHardLinks, bool isU
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -2478,7 +2473,7 @@ public void TooFewRetriesReturnsFalse(bool isUseHardLinks, bool isUseSymbolicLin
             };
 
             var copyFunctor = new CopyFunctor(4, false /* do not throw */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
@@ -2507,7 +2502,7 @@ public void TooFewRetriesThrows(bool isUseHardLinks, bool isUseSymbolicLinks, bo
             };
 
             var copyFunctor = new CopyFunctor(3, true /* throw */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 6997613405b..50732b70703 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -171,9 +171,20 @@ public void Timeout()
             Assert.Equal(expectedExitCode, exec.ExitCode);
             ((MockEngine)exec.BuildEngine).AssertLogContains("MSB5002");
             int warningsCount = ((MockEngine)exec.BuildEngine).Warnings;
-            warningsCount.ShouldBe(1,
+            if (warningsCount == 1)
+            {
+                warningsCount.ShouldBe(1,
                 $"Expected 1 warning, encountered {warningsCount}: " + string.Join(",",
                     ((MockEngine)exec.BuildEngine).WarningEvents.Select(w => w.Message)));
+            }
+            else
+            {
+                // Occasionally temp files fail to delete because of virus checkers, so generate MSB5018 warning
+                ((MockEngine)exec.BuildEngine).AssertLogContains("MSB5018");
+                warningsCount.ShouldBe(2,
+                $"Expected 2 warnings, encountered {warningsCount}: " + string.Join(",",
+                    ((MockEngine)exec.BuildEngine).WarningEvents.Select(w => w.Message)));
+            }
 
             // ToolTask does not log an error on timeout.
             Assert.Equal(0, ((MockEngine)exec.BuildEngine).Errors);
diff --git a/src/Tasks/AppConfig/BindingRedirect.cs b/src/Tasks/AppConfig/BindingRedirect.cs
index 8be7d2413c7..d29808b9b59 100644
--- a/src/Tasks/AppConfig/BindingRedirect.cs
+++ b/src/Tasks/AppConfig/BindingRedirect.cs
@@ -43,17 +43,21 @@ internal void Read(XmlReader reader)
 
             try
             {
-                if (dashPosition != -1)
+                if (dashPosition >= 0)
                 {
                     // This is a version range.
-                    OldVersionLow = new Version(oldVersion.Substring(0, dashPosition));
-                    OldVersionHigh = new Version(oldVersion.Substring(dashPosition + 1));
+#if NET
+                    OldVersionLow = Version.Parse(oldVersion.AsSpan(0, dashPosition));
+                    OldVersionHigh = Version.Parse(oldVersion.AsSpan(dashPosition + 1));
+#else
+                    OldVersionLow = Version.Parse(oldVersion.Substring(0, dashPosition));
+                    OldVersionHigh = Version.Parse(oldVersion.Substring(dashPosition + 1));
+#endif
                 }
                 else
                 {
                     // This is a single version.
-                    OldVersionLow = new Version(oldVersion);
-                    OldVersionHigh = new Version(oldVersion);
+                    OldVersionLow = OldVersionHigh = new Version(oldVersion);
                 }
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
index 1453e8ab6d8..ded0c8b46bf 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
@@ -2,7 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Immutable;
+using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using Microsoft.Build.Shared;
@@ -19,7 +19,7 @@ internal class AssemblyFoldersFromConfigCache
         /// <summary>
         /// Set of files in ALL AssemblyFolderFromConfig directories
         /// </summary>
-        private readonly ImmutableHashSet<string> _filesInDirectories = ImmutableHashSet<string>.Empty;
+        private readonly HashSet<string> _filesInDirectories;
 
         /// <summary>
         /// File exists delegate we are replacing
@@ -45,12 +45,12 @@ internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFolder
             }
             else
             {
-                _filesInDirectories = assemblyFoldersFromConfig.AsParallel()
+                _filesInDirectories = new(assemblyFoldersFromConfig.AsParallel()
                     .Where(assemblyFolder => FileUtilities.DirectoryExistsNoThrow(assemblyFolder.DirectoryPath))
                     .SelectMany(
                         assemblyFolder =>
-                            Directory.GetFiles(assemblyFolder.DirectoryPath, "*.*", SearchOption.TopDirectoryOnly))
-                    .ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);
+                            Directory.GetFiles(assemblyFolder.DirectoryPath, "*.*", SearchOption.TopDirectoryOnly)),
+                    StringComparer.OrdinalIgnoreCase);
             }
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 531d95a8fc5..7f6fa93139c 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -50,7 +50,7 @@ internal class AssemblyInformation : DisposableBase
 #endif
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
-        private static string s_targetFrameworkAttribute = "System.Runtime.Versioning.TargetFrameworkAttribute";
+        private const string s_targetFrameworkAttribute = "System.Runtime.Versioning.TargetFrameworkAttribute";
 #endif
 #if !FEATURE_ASSEMBLYLOADCONTEXT
         // Borrowed from genman.
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index daeaae94b3b..1a6656c607d 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -283,7 +283,7 @@ internal static string GetLocation(
             bool useGacRarCache = Environment.GetEnvironmentVariable("MSBUILDDISABLEGACRARCACHE") == null;
             if (buildEngine != null && useGacRarCache)
             {
-                string key = "44d78b60-3bbe-48fe-9493-04119ebf515f" + "|" + targetProcessorArchitecture.ToString() + "|" + targetedRuntimeVersion.ToString() + "|" + fullFusionName.ToString() + "|" + specificVersion.ToString();
+                string key = $"44d78b60-3bbe-48fe-9493-04119ebf515f|{targetProcessorArchitecture}|{targetedRuntimeVersion}|{fullFusionName}|{specificVersion}";
                 fusionNameToResolvedPath = buildEngine.GetRegisteredTaskObject(key, RegisteredTaskObjectLifetime.Build) as ConcurrentDictionary<AssemblyNameExtension, string>;
                 if (fusionNameToResolvedPath == null)
                 {
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index d9ba3671e32..78648beda64 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -725,7 +725,7 @@ internal HashSet<AssemblyRemapping> RemappedAssemblyNames()
         /// </summary>
         internal void AddPreUnificationVersion(String referencePath, Version version, UnificationReason reason)
         {
-            string key = referencePath + version.ToString() + reason.ToString();
+            string key = $"{referencePath}{version}{reason}";
 
             // Only add a reference, version, and reason once.
             UnificationVersion unificationVersion;
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index de1a4b26b20..9e3b0c07d36 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -789,9 +789,7 @@ private static void TryGatherAssemblyNameEssentials(string fusionName, ref Assem
                 return;
             }
 
-            string newFusionName = String.Format(CultureInfo.InvariantCulture,
-                "{0}, Version={1}, Culture={2}, PublicKeyToken={3}",
-                name, version, culture, publicKeyToken);
+            string newFusionName = $"{name}, Version={version}, Culture={culture}, PublicKeyToken={publicKeyToken}";
 
             // Now try to convert to an AssemblyName.
             try
@@ -812,19 +810,20 @@ private static void TryGatherAssemblyNameEssentials(string fusionName, ref Assem
         private static void TryGetAssemblyNameComponent(string fusionName, string component, ref string value)
         {
             int position = fusionName.IndexOf(component + "=", StringComparison.Ordinal);
-            if (position == -1)
+            if (position < 0)
             {
                 return;
             }
+
             position += component.Length + 1;
-            int nextDelimiter = fusionName.IndexOfAny([',', ' '], position);
-            if (nextDelimiter == -1)
+            int nextDelimiter = fusionName.AsSpan(position).IndexOfAny(',', ' ');
+            if (nextDelimiter < 0)
             {
                 value = fusionName.Substring(position);
             }
             else
             {
-                value = fusionName.Substring(position, nextDelimiter - position);
+                value = fusionName.Substring(position, nextDelimiter);
             }
         }
 
@@ -2301,20 +2300,11 @@ private static bool CompareRefToDef(AssemblyName @ref, AssemblyName def)
 
             byte[] rpkt = @ref.GetPublicKeyToken();
             byte[] dpkt = def.GetPublicKeyToken();
-
-            if (rpkt.Length != dpkt.Length)
+            if (!rpkt.AsSpan().SequenceEqual(dpkt.AsSpan()))
             {
                 return false;
             }
 
-            for (int i = 0; i < rpkt.Length; i++)
-            {
-                if (rpkt[i] != dpkt[i])
-                {
-                    return false;
-                }
-            }
-
             if (@ref.Version != def.Version)
             {
                 return false;
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index b322052e386..b331aeb86be 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1311,6 +1311,9 @@ internal static string ByteArrayToString(byte[] a)
                 return null;
             }
 
+#if NET
+            return Convert.ToHexStringLower(a);
+#else
             var buffer = new StringBuilder(a.Length * 2);
             for (int i = 0; i < a.Length; ++i)
             {
@@ -1318,6 +1321,7 @@ internal static string ByteArrayToString(byte[] a)
             }
 
             return buffer.ToString();
+#endif
         }
 
         /// <summary>
@@ -1536,22 +1540,22 @@ private void LogInputs()
             }
 
             Log.LogMessage(importance, property, "AppConfigFile");
-            Log.LogMessage(importance, indent + AppConfigFile);
+            Log.LogMessage(importance, $"{indent}{AppConfigFile}");
 
             Log.LogMessage(importance, property, "AutoUnify");
-            Log.LogMessage(importance, indent + AutoUnify.ToString());
+            Log.LogMessage(importance, $"{indent}{AutoUnify}");
 
             Log.LogMessage(importance, property, "CopyLocalDependenciesWhenParentReferenceInGac");
-            Log.LogMessage(importance, indent + _copyLocalDependenciesWhenParentReferenceInGac);
+            Log.LogMessage(importance, $"{indent}{_copyLocalDependenciesWhenParentReferenceInGac}");
 
             Log.LogMessage(importance, property, "FindDependencies");
-            Log.LogMessage(importance, indent + _findDependencies);
+            Log.LogMessage(importance, $"{indent}{_findDependencies}");
 
             Log.LogMessage(importance, property, "TargetProcessorArchitecture");
-            Log.LogMessage(importance, indent + TargetProcessorArchitecture);
+            Log.LogMessage(importance, $"{indent}{TargetProcessorArchitecture}");
 
             Log.LogMessage(importance, property, "StateFile");
-            Log.LogMessage(importance, indent + StateFile);
+            Log.LogMessage(importance, $"{indent}{StateFile}");
 
             Log.LogMessage(importance, property, "InstalledAssemblySubsetTables");
             foreach (ITaskItem installedAssemblySubsetTable in InstalledAssemblySubsetTables)
@@ -1561,33 +1565,33 @@ private void LogInputs()
             }
 
             Log.LogMessage(importance, property, "IgnoreInstalledAssemblySubsetTable");
-            Log.LogMessage(importance, indent + _ignoreDefaultInstalledAssemblySubsetTables);
+            Log.LogMessage(importance, $"{indent}{_ignoreDefaultInstalledAssemblySubsetTables}");
 
             Log.LogMessage(importance, property, "TargetFrameworkSubsets");
             foreach (string subset in _targetFrameworkSubsets)
             {
-                Log.LogMessage(importance, indent + subset);
+                Log.LogMessage(importance, $"{indent}{subset}");
             }
 
             Log.LogMessage(importance, property, "FullTargetFrameworkSubsetNames");
             foreach (string subset in FullTargetFrameworkSubsetNames)
             {
-                Log.LogMessage(importance, indent + subset);
+                Log.LogMessage(importance, $"{indent}{subset}");
             }
 
             Log.LogMessage(importance, property, "ProfileName");
-            Log.LogMessage(importance, indent + ProfileName);
+            Log.LogMessage(importance, $"{indent}{ProfileName}");
 
             Log.LogMessage(importance, property, "FullFrameworkFolders");
             foreach (string fullFolder in FullFrameworkFolders)
             {
-                Log.LogMessage(importance, indent + fullFolder);
+                Log.LogMessage(importance, $"{indent}{fullFolder}");
             }
 
             Log.LogMessage(importance, property, "LatestTargetFrameworkDirectories");
             foreach (string latestFolder in _latestTargetFrameworkDirectories)
             {
-                Log.LogMessage(importance, indent + latestFolder);
+                Log.LogMessage(importance, $"{indent}{latestFolder}");
             }
 
             Log.LogMessage(importance, property, "ProfileTablesLocation");
@@ -2041,7 +2045,7 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
                     break;
             }
         }
-        #endregion
+#endregion
 
         #region StateFile
         /// <summary>
@@ -2843,7 +2847,7 @@ internal static string GenerateSubSetName(string[] frameworkSubSetNames, ITaskIt
                 }
             }
 
-            return String.Join(", ", subsetNames.ToArray());
+            return String.Join(", ", subsetNames);
         }
 
         /// <summary>
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index c22ab73bc9f..8e7c85a73b3 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -492,9 +492,9 @@ internal string[] Cultures
                     Refresh();
                 }
 
-                List<string> list = _cultures.Values.Select(v => v.ToString()).ToList();
-                list.Sort();
-                return list.ToArray();
+                string[] array = _cultures.Values.Select(v => v.ToString()).ToArray();
+                Array.Sort(array);
+                return array;
             }
         }
 
@@ -603,7 +603,7 @@ private void RefreshProducts()
                     foreach (string strSubDirectory in Directory.GetDirectories(packagePath))
                     {
                         int nStartIndex = packagePath.Length;
-                        if ((strSubDirectory.ToCharArray())[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
+                        if (strSubDirectory[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
                         {
                             nStartIndex++;
                         }
@@ -948,7 +948,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement, st
                                     }
 
                                     XmlNode langNode = langDoc.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":Package", _xmlNamespaceManager);
-                                    Debug.Assert(langNode != null, string.Format(CultureInfo.CurrentCulture, "Unable to find a package node in {0}", strLangManifestFilename));
+                                    Debug.Assert(langNode != null, $"Unable to find a package node in {strLangManifestFilename}");
                                     if (langNode != null)
                                     {
                                         XmlElement langElement = (XmlElement)(_document.ImportNode(langNode, true));
@@ -1040,7 +1040,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement, st
                                 }
                                 else
                                 {
-                                    Debug.WriteLine(String.Format(CultureInfo.CurrentCulture, "Validation results already added for Product Code '{0}'", productCodeAttribute));
+                                    Debug.WriteLine($"Validation results already added for Product Code '{productCodeAttribute}'");
                                 }
                             }
                         }
@@ -1512,7 +1512,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                                 // Add the file size to the PackageFileNode
                                 XmlAttribute sizeAttribute = packageFileNode.OwnerDocument.CreateAttribute("Size");
                                 var fi = new FileInfo(packageFileSource.Value);
-                                sizeAttribute.Value = "" + (fi.Length.ToString(CultureInfo.InvariantCulture));
+                                sizeAttribute.Value = fi.Length.ToString(CultureInfo.InvariantCulture);
                                 MergeAttribute(packageFileNode, sizeAttribute);
                             }
                         }
@@ -1547,7 +1547,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                 if (configElement != null)
                 {
                     configElement.AppendChild(configElement.OwnerDocument.ImportNode(node, true));
-                    DumpXmlToFile(node, string.Format(CultureInfo.CurrentCulture, "{0}.{1}.xml", package.Product.ProductCode, package.Culture));
+                    DumpXmlToFile(node, $"{package.Product.ProductCode}.{package.Culture}.xml");
                 }
             }
 
@@ -1602,13 +1602,17 @@ private static string ByteArrayToString(byte[] byteArray)
                 return null;
             }
 
-            var output = new StringBuilder(byteArray.Length);
+#if NET
+            return Convert.ToHexString(byteArray);
+#else
+            var output = new StringBuilder(byteArray.Length * 2);
             foreach (byte byteValue in byteArray)
             {
                 output.Append(byteValue.ToString("X02", CultureInfo.InvariantCulture));
             }
 
             return output.ToString();
+#endif
         }
 
         private static string GetFileHash(string filePath)
@@ -1983,7 +1987,7 @@ private static Stream GetEmbeddedResourceStream(string name)
         {
             Assembly a = Assembly.GetExecutingAssembly();
             Stream s = a.GetManifestResourceStream(String.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(BootstrapperBuilder).Namespace, name));
-            Debug.Assert(s != null, String.Format(CultureInfo.CurrentCulture, "EmbeddedResource '{0}' not found", name));
+            Debug.Assert(s != null, $"EmbeddedResource '{name}' not found");
             return s;
         }
 
diff --git a/src/Tasks/BootstrapperUtil/BuildMessage.cs b/src/Tasks/BootstrapperUtil/BuildMessage.cs
index bc4272ed8d8..db219a6a7d0 100644
--- a/src/Tasks/BootstrapperUtil/BuildMessage.cs
+++ b/src/Tasks/BootstrapperUtil/BuildMessage.cs
@@ -13,9 +13,14 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// <summary>
     /// Represents messages that occur during the BootstrapperBuilder's Build operation.
     /// </summary>
-    public class BuildMessage : IBuildMessage
+    public partial class BuildMessage : IBuildMessage
     {
-        private static readonly Regex s_msbuildMessageCodePattern = new Regex(@"(\d+)$");
+#if NET
+        [GeneratedRegex(@"\d+$")]
+        private static partial Regex MsbuildMessageCodePattern { get; }
+#else
+        private static Regex MsbuildMessageCodePattern { get; } = new Regex(@"\d+$");
+#endif
 
         private BuildMessage(BuildMessageSeverity severity, string message, string helpKeyword, string helpCode)
         {
@@ -25,7 +30,7 @@ private BuildMessage(BuildMessageSeverity severity, string message, string helpK
             HelpCode = helpCode;
             if (!String.IsNullOrEmpty(HelpCode))
             {
-                Match match = s_msbuildMessageCodePattern.Match(HelpCode);
+                Match match = MsbuildMessageCodePattern.Match(HelpCode);
                 if (match.Success)
                 {
                     HelpId = int.Parse(match.Value, CultureInfo.InvariantCulture);
diff --git a/src/Tasks/BootstrapperUtil/Product.cs b/src/Tasks/BootstrapperUtil/Product.cs
index 6e9d0e1ceca..bf788c343b5 100644
--- a/src/Tasks/BootstrapperUtil/Product.cs
+++ b/src/Tasks/BootstrapperUtil/Product.cs
@@ -168,7 +168,7 @@ internal void AddPackage(Package package)
             }
             else
             {
-                Debug.WriteLine(String.Format(CultureInfo.CurrentCulture, "A package with culture '{0}' has already been added to product '{1}'", package.Culture.ToLowerInvariant(), ProductCode));
+                Debug.WriteLine($"A package with culture '{package.Culture.ToLowerInvariant()}' has already been added to product '{ProductCode}'");
             }
         }
 
diff --git a/src/Tasks/BootstrapperUtil/Util.cs b/src/Tasks/BootstrapperUtil/Util.cs
index 973ca74a61f..bfd845b297f 100644
--- a/src/Tasks/BootstrapperUtil/Util.cs
+++ b/src/Tasks/BootstrapperUtil/Util.cs
@@ -124,7 +124,12 @@ public static string GetDefaultPath(string visualStudioVersion)
             {
                 dotIndex = visualStudioVersion.Length;
             }
+
+#if NET
+            if (Int32.TryParse(visualStudioVersion.AsSpan(0, dotIndex), out int majorVersion) && (majorVersion < 11))
+#else
             if (Int32.TryParse(visualStudioVersion.Substring(0, dotIndex), out int majorVersion) && (majorVersion < 11))
+#endif
             {
                 visualStudioVersion = BOOTSTRAPPER_REGISTRY_PATH_VERSION_VS2010;
             }
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index 340be0e84b1..67e50ba29d6 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -263,7 +263,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
 
                 if (typeLibName.Length >= 4)
                 {
-                    if (string.Equals(typeLibName.Substring(typeLibName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase))
+                    if (typeLibName.AsSpan().EndsWith(".dll".AsSpan(), StringComparison.OrdinalIgnoreCase))
                     {
                         typeLibName = typeLibName.Substring(0, typeLibName.Length - 4);
                     }
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index 6e6f63a5eb6..fafd80dcb79 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -1,10 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- For ease of logging the "not supported on Core" message, these tasks are a
-       TaskRequiresFramework on netstandard/netcore. Since the type is sealed there,
-       that shouldn't cause any implementation problems since no one can derive
-       from it and try to call TaskExtension.Log. -->
   <Suppression>
     <DiagnosticId>CP0007</DiagnosticId>
     <Target>T:Microsoft.Build.Tasks.AL</Target>
@@ -71,11 +67,6 @@
     <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
     <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
-  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
-      This is intentional, because you can only use MSBuild in the context of a .NET SDK
-      (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
-      have previously shipped netstandard2.0 packages, and if you want to support both
-      runtime contexts it still makes sense to target that. -->
   <Suppression>
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>.NETCoreApp,Version=v2.0</Target>
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index e553d1765af..3cf26dc3eb4 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -15,6 +15,8 @@
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
+using TPLTask = System.Threading.Tasks.Task;
+
 #nullable disable
 
 namespace Microsoft.Build.Tasks
@@ -44,6 +46,33 @@ public class Copy : TaskExtension, IIncrementalTask, ICancelableTask
         // taking up the whole threadpool esp. when hosted in Visual Studio. IOW we use a specific number
         // instead of int.MaxValue.
         private static readonly int DefaultCopyParallelism = NativeMethodsShared.GetLogicalCoreCount() > 4 ? 6 : 4;
+        private static Thread[] copyThreads;
+        private static AutoResetEvent[] copyThreadSignals;
+        private AutoResetEvent _signalCopyTasksCompleted;
+
+        private static ConcurrentQueue<Action> _copyActionQueue = new ConcurrentQueue<Action>();
+
+        private static void InitializeCopyThreads()
+        {
+            lock (_copyActionQueue)
+            {
+                if (copyThreads == null)
+                {
+                    copyThreadSignals = new AutoResetEvent[DefaultCopyParallelism];
+                    copyThreads = new Thread[DefaultCopyParallelism];
+                    for (int i = 0; i < copyThreads.Length; ++i)
+                    {
+                        AutoResetEvent autoResetEvent = new AutoResetEvent(false);
+                        copyThreadSignals[i] = autoResetEvent;
+                        Thread newThread = new Thread(ParallelCopyTask);
+                        newThread.IsBackground = true;
+                        newThread.Name = "Parallel Copy Thread";
+                        newThread.Start(autoResetEvent);
+                        copyThreads[i] = newThread;
+                    }
+                }
+            }
+        }
 
         /// <summary>
         /// Constructor.
@@ -63,6 +92,8 @@ public Copy()
                 RemovingReadOnlyAttribute = Log.GetResourceMessage("Copy.RemovingReadOnlyAttribute");
                 SymbolicLinkComment = Log.GetResourceMessage("Copy.SymbolicLinkComment");
             }
+
+            _signalCopyTasksCompleted = new AutoResetEvent(false);
         }
 
         private static string CreatesDirectory;
@@ -79,7 +110,7 @@ public Copy()
         private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
 
         // Bool is just a placeholder, we're mainly interested in a threadsafe key set.
-        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
+        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(DefaultCopyParallelism, DefaultCopyParallelism, StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since
@@ -93,7 +124,7 @@ public Copy()
         /// </summary>
         private static readonly bool s_forceSymlinks = Environment.GetEnvironmentVariable("MSBuildUseSymboliclinksIfPossible") != null;
 
-        private static readonly int s_parallelism = GetParallelismFromEnvironment();
+        private static readonly bool s_copyInParallel = GetParallelismFromEnvironment();
 
         /// <summary>
         /// Default milliseconds to wait between necessary retries
@@ -395,12 +426,12 @@ private void MakeFileWriteable(FileState file, bool logActivity)
         /// Copy the files.
         /// </summary>
         /// <param name="copyFile">Delegate used to copy the files.</param>
-        /// <param name="parallelism">
+        /// <param name="copyInParallel">
         /// Thread parallelism allowed during copies. 1 uses the original algorithm, >1 uses newer algorithm.
         /// </param>
         internal bool Execute(
             CopyFileWithState copyFile,
-            int parallelism)
+            bool copyInParallel)
         {
             // If there are no source files then just return success.
             if (IsSourceSetEmpty())
@@ -430,9 +461,9 @@ internal bool Execute(
 
             try
             {
-                success = parallelism == 1 || DestinationFiles.Length == 1
+                success = !copyInParallel || DestinationFiles.Length == 1
                     ? CopySingleThreaded(copyFile, out destinationFilesSuccessfullyCopied)
-                    : CopyParallel(copyFile, parallelism, out destinationFilesSuccessfullyCopied);
+                    : CopyParallel(copyFile, out destinationFilesSuccessfullyCopied);
             }
             catch (OperationCanceledException)
             {
@@ -507,6 +538,22 @@ private bool CopySingleThreaded(
             return success;
         }
 
+        private static void ParallelCopyTask(object state)
+        {
+            AutoResetEvent autoResetEvent = (AutoResetEvent)state;
+            while (true)
+            {
+                if (_copyActionQueue.TryDequeue(out Action copyAction))
+                {
+                    copyAction();
+                }
+                else
+                {
+                    autoResetEvent.WaitOne();
+                }
+            }
+        }
+
         /// <summary>
         /// Parallelize I/O with the same semantics as the single-threaded copy method above.
         /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send
@@ -516,7 +563,6 @@ private bool CopySingleThreaded(
         /// </summary>
         private bool CopyParallel(
             CopyFileWithState copyFile,
-            int parallelism,
             out List<ITaskItem> destinationFilesSuccessfullyCopied)
         {
             bool success = true;
@@ -559,77 +605,23 @@ private bool CopyParallel(
 
             // Lockless flags updated from each thread - each needs to be a processor word for atomicity.
             var successFlags = new IntPtr[DestinationFiles.Length];
-            var actionBlockOptions = new ExecutionDataflowBlockOptions
-            {
-                MaxDegreeOfParallelism = parallelism,
-                CancellationToken = _cancellationTokenSource.Token
-            };
-            var partitionCopyActionBlock = new ActionBlock<List<int>>(
-                async (List<int> partition) =>
-                {
-                    // Break from synchronous thread context of caller to get onto thread pool thread.
-                    await System.Threading.Tasks.Task.Yield();
 
-                    for (int partitionIndex = 0; partitionIndex < partition.Count && !_cancellationTokenSource.IsCancellationRequested; partitionIndex++)
-                    {
-                        int fileIndex = partition[partitionIndex];
-                        ITaskItem sourceItem = SourceFiles[fileIndex];
-                        ITaskItem destItem = DestinationFiles[fileIndex];
-                        string sourcePath = sourceItem.ItemSpec;
-
-                        // Check if we just copied from this location to the destination, don't copy again.
-                        MSBuildEventSource.Log.CopyUpToDateStart(destItem.ItemSpec);
-                        bool copyComplete = partitionIndex > 0 &&
-                                            String.Equals(
-                                                sourcePath,
-                                                SourceFiles[partition[partitionIndex - 1]].ItemSpec,
-                                                StringComparison.OrdinalIgnoreCase);
-
-                        if (!copyComplete)
-                        {
-                            if (DoCopyIfNecessary(
-                                new FileState(sourceItem.ItemSpec),
-                                new FileState(destItem.ItemSpec),
-                                copyFile))
-                            {
-                                copyComplete = true;
-                            }
-                            else
-                            {
-                                // Thread race to set outer variable but they race to set the same (false) value.
-                                success = false;
-                            }
-                        }
-                        else
-                        {
-                            MSBuildEventSource.Log.CopyUpToDateStop(destItem.ItemSpec, true);
-                        }
+            ConcurrentQueue<List<int>> partitionQueue = new ConcurrentQueue<List<int>>(partitionsByDestination.Values);
 
-                        if (copyComplete)
-                        {
-                            sourceItem.CopyMetadataTo(destItem);
-                            successFlags[fileIndex] = (IntPtr)1;
-                        }
-                    }
-                },
-                actionBlockOptions);
+            int activeCopyThreads = DefaultCopyParallelism;
+            for (int i = 0; i < DefaultCopyParallelism; ++i)
+            {
+                _copyActionQueue.Enqueue(ProcessPartition);
+            }
+
+            InitializeCopyThreads();
 
-            foreach (List<int> partition in partitionsByDestination.Values)
+            for (int i = 0; i < DefaultCopyParallelism; ++i)
             {
-                bool partitionAccepted = partitionCopyActionBlock.Post(partition);
-                if (_cancellationTokenSource.IsCancellationRequested)
-                {
-                    break;
-                }
-                else if (!partitionAccepted)
-                {
-                    // Retail assert...
-                    ErrorUtilities.ThrowInternalError("Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
-                }
+                copyThreadSignals[i].Set();
             }
 
-            partitionCopyActionBlock.Complete();
-            partitionCopyActionBlock.Completion.GetAwaiter().GetResult();
+            _signalCopyTasksCompleted.WaitOne();
 
             // Assemble an in-order list of destination items that succeeded.
             destinationFilesSuccessfullyCopied = new List<ITaskItem>(DestinationFiles.Length);
@@ -642,6 +634,65 @@ private bool CopyParallel(
             }
 
             return success;
+
+            void ProcessPartition()
+            {
+                try
+                {
+                    while (partitionQueue.TryDequeue(out List<int> partition))
+                    {
+                        for (int partitionIndex = 0; partitionIndex < partition.Count && !_cancellationTokenSource.IsCancellationRequested; partitionIndex++)
+                        {
+                            int fileIndex = partition[partitionIndex];
+                            ITaskItem sourceItem = SourceFiles[fileIndex];
+                            ITaskItem destItem = DestinationFiles[fileIndex];
+                            string sourcePath = sourceItem.ItemSpec;
+
+                            // Check if we just copied from this location to the destination, don't copy again.
+                            MSBuildEventSource.Log.CopyUpToDateStart(destItem.ItemSpec);
+                            bool copyComplete = partitionIndex > 0 &&
+                                                String.Equals(
+                                                    sourcePath,
+                                                    SourceFiles[partition[partitionIndex - 1]].ItemSpec,
+                                                    StringComparison.OrdinalIgnoreCase);
+
+                            if (!copyComplete)
+                            {
+                                if (DoCopyIfNecessary(
+                                    new FileState(sourceItem.ItemSpec),
+                                    new FileState(destItem.ItemSpec),
+                                    copyFile))
+                                {
+                                    copyComplete = true;
+                                }
+                                else
+                                {
+                                    // Thread race to set outer variable but they race to set the same (false) value.
+                                    success = false;
+                                }
+                            }
+                            else
+                            {
+                                MSBuildEventSource.Log.CopyUpToDateStop(destItem.ItemSpec, true);
+                            }
+
+                            if (copyComplete)
+                            {
+                                sourceItem.CopyMetadataTo(destItem);
+                                successFlags[fileIndex] = (IntPtr)1;
+                            }
+                        }
+                    }
+                }
+                finally
+                {
+                    int count = System.Threading.Interlocked.Decrement(ref activeCopyThreads);
+                    if (count == 0)
+                    {
+                        _signalCopyTasksCompleted.Set();
+                    }
+                }
+            }
         }
 
         private bool IsSourceSetEmpty()
@@ -1028,7 +1079,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
         /// <returns></returns>
         public override bool Execute()
         {
-            return Execute(CopyFileWithLogging, s_parallelism);
+            return Execute(CopyFileWithLogging, s_copyInParallel);
         }
 
         #endregion
@@ -1049,18 +1100,10 @@ private static bool PathsAreIdentical(FileState source, FileState destination)
             return string.Equals(source.FileNameFullPath, destination.FileNameFullPath, FileUtilities.PathComparison);
         }
 
-        private static int GetParallelismFromEnvironment()
+        private static bool GetParallelismFromEnvironment()
         {
             int parallelism = Traits.Instance.CopyTaskParallelism;
-            if (parallelism < 0)
-            {
-                parallelism = DefaultCopyParallelism;
-            }
-            else if (parallelism == 0)
-            {
-                parallelism = int.MaxValue;
-            }
-            return parallelism;
+            return parallelism != 1;
         }
     }
 }
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index aed8b824d4f..53448eb1ba3 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
-#if NET5_0_OR_GREATER
+#if NET
 using System.Linq;
 using Microsoft.Build.Framework;
 #endif
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal static class CultureInfoCache
     {
-#if !NET5_0_OR_GREATER
+#if !NET
         private static readonly Lazy<HashSet<string>> ValidCultureNames = new Lazy<HashSet<string>>(() => InitializeValidCultureNames());
 #endif
 
@@ -63,7 +63,7 @@ private static HashSet<string> InitializeValidCultureNames()
         /// <returns>True if the culture is determined to be valid.</returns>
         internal static bool IsValidCultureString(string name)
         {
-#if NET5_0_OR_GREATER
+#if NET
             try
             {
                 // GetCultureInfo throws if the culture doesn't exist
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 71dc72e4c91..9028bd1f386 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -156,7 +156,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                     {
                         response.EnsureSuccessStatusCode();
                     }
-#if NET6_0_OR_GREATER
+#if NET
                     catch (HttpRequestException)
                     {
                         throw;
@@ -203,7 +203,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                             Log.LogMessageFromResources(MessageImportance.High, "DownloadFile.Downloading", SourceUrl, destinationFile.FullName, response.Content.Headers.ContentLength);
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
                             using (Stream responseStream = await response.Content.ReadAsStreamAsync(
-#if NET6_0_OR_GREATER
+#if NET
                             cancellationToken
 #endif
                             ).ConfigureAwait(false))
@@ -260,7 +260,7 @@ private static bool IsRetriable(Exception exception, out Exception actualExcepti
                     }
                 }
 
-#if NET6_0_OR_GREATER
+#if NET
                 // net5.0 included StatusCode in the HttpRequestException.
                 switch (httpRequestException.StatusCode)
                 {
@@ -329,7 +329,7 @@ private bool TryGetFileName(HttpResponseMessage response, out string filename)
             return !String.IsNullOrWhiteSpace(filename);
         }
 
-#if !NET6_0_OR_GREATER
+#if !NET
         /// <summary>
         /// Represents a wrapper around the <see cref="HttpRequestException"/> that also contains the <see cref="HttpStatusCode"/>.
         /// DEPRECATED as of net5.0, which included the StatusCode in the HttpRequestException class.
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index 2d1ec4f5308..b975be5fd5e 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -143,7 +143,7 @@ internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string
             using (var stream = File.OpenRead(filePath))
             using (var algorithm = algorithmFactory())
             {
-#if NET5_0_OR_GREATER
+#if NET
                 return algorithm.ComputeHashAsync(stream, ct).Result;
 #else
                 return algorithm.ComputeHash(stream);
diff --git a/src/Tasks/FindInvalidProjectReferences.cs b/src/Tasks/FindInvalidProjectReferences.cs
index 791ac147af6..607df8b83cd 100644
--- a/src/Tasks/FindInvalidProjectReferences.cs
+++ b/src/Tasks/FindInvalidProjectReferences.cs
@@ -13,17 +13,22 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Returns the reference assembly paths to the various frameworks
     /// </summary>
-    public class FindInvalidProjectReferences : TaskExtension
+    public partial class FindInvalidProjectReferences : TaskExtension
     {
         #region Fields
 
+        private const string PlatformMonikerFormatPattern = @"(?<PLATFORMIDENTITY>^[^,]*),\s*Version=(?<PLATFORMVERSION>.*)";
+
         /// <summary>
         /// Regex for breaking up the platform moniker
         /// Example: XNA, Version=8.0
         /// </summary>
-        private static readonly Regex s_platformMonikerFormat = new Regex(
-             @"(?<PLATFORMIDENTITY>^[^,]*),\s*Version=(?<PLATFORMVERSION>.*)",
-            RegexOptions.IgnoreCase);
+#if NET
+        [GeneratedRegex(PlatformMonikerFormatPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex PlatformMonikerRegex { get; }
+#else
+        private static Regex PlatformMonikerRegex { get; } = new Regex(PlatformMonikerFormatPattern, RegexOptions.IgnoreCase);
+#endif
 
         /// <summary>
         /// Reference moniker metadata
@@ -111,7 +116,7 @@ public override bool Execute()
         /// </summary>
         private static bool ParseMoniker(string reference, out string platformIdentity, out Version platformVersion)
         {
-            Match match = s_platformMonikerFormat.Match(reference);
+            Match match = PlatformMonikerRegex.Match(reference);
 
             platformIdentity = String.Empty;
             bool parsedVersion = false;
diff --git a/src/Tasks/FormatVersion.cs b/src/Tasks/FormatVersion.cs
index 88cfc595cb5..86182dca239 100644
--- a/src/Tasks/FormatVersion.cs
+++ b/src/Tasks/FormatVersion.cs
@@ -47,9 +47,14 @@ public override bool Execute()
             {
                 OutputVersion = "1.0.0.0";
             }
-            else if (Version.EndsWith("*", StringComparison.Ordinal))
+            else if (Version[Version.Length - 1] == '*')
             {
-                OutputVersion = Version.Substring(0, Version.Length - 1) + Revision.ToString("G", CultureInfo.InvariantCulture);
+                OutputVersion =
+#if NET
+                    string.Create(CultureInfo.InvariantCulture, $"{Version.AsSpan(0, Version.Length - 1)}{Revision:G}");
+#else
+                    Version.Substring(0, Version.Length - 1) + Revision.ToString("G", CultureInfo.InvariantCulture);
+#endif
             }
             else
             {
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index 1c32b6feb36..c91044032b0 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -241,7 +241,7 @@ private bool AddIsolatedComReferences(ApplicationManifest manifest)
                 }
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateApplicationManifest.AddIsolatedComReferences t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateApplicationManifest.AddIsolatedComReferences t={Environment.TickCount - t1}");
             return success;
         }
 
@@ -326,7 +326,7 @@ private bool AddClickOnceFiles(ApplicationManifest manifest)
                 }
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateApplicationManifest.AddClickOnceFiles t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateApplicationManifest.AddClickOnceFiles t={Environment.TickCount - t1}");
             return true;
         }
 
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index a58209b9053..96ae300d52a 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -519,7 +519,7 @@ private bool ResolveFiles()
                 return false;
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifestBase.ResolveFiles t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateManifestBase.ResolveFiles t={Environment.TickCount - t1}");
             return true;
         }
 
@@ -625,8 +625,8 @@ private bool WriteManifest()
                 return false;
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifestBase.WriteManifest t={0}", Environment.TickCount - t1));
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "Total time to generate manifest '{1}': t={0}", Environment.TickCount - _startTime, Path.GetFileName(OutputManifest.ItemSpec)));
+            Util.WriteLog($"GenerateManifestBase.WriteManifest t={Environment.TickCount - t1}");
+            Util.WriteLog($"Total time to generate manifest '{Path.GetFileName(OutputManifest.ItemSpec)}': t={Environment.TickCount - _startTime}");
             return true;
         }
     }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index b888da26a59..b7e981bea5f 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -145,7 +145,7 @@ public sealed partial class GenerateResource : TaskExtension, IIncrementalTask
 #if FEATURE_RESGEN
         // Our calculation is not quite correct. Using a number substantially less than 32768 in order to
         // be sure we don't exceed it.
-        private static int s_maximumCommandLength = 28000;
+        private const int s_maximumCommandLength = 28000;
 #endif // FEATURE_RESGEN
 
         // Contains the list of paths from which inputs will not be taken into account during up-to-date check.
@@ -1793,7 +1793,7 @@ private bool NeedSeparateAppDomain()
                                             string resolvedTypeName = typeName;
 
                                             // This type name might be an alias, so first resolve that if any.
-                                            int indexOfSeperator = typeName.IndexOf(",", StringComparison.Ordinal);
+                                            int indexOfSeperator = typeName.IndexOf(',');
 
                                             if (indexOfSeperator != -1)
                                             {
@@ -2017,18 +2017,13 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
         }
 #endif
 
-        /// <summary>
-        /// Chars that should be ignored in the nicely justified block of base64
-        /// </summary>
-        private static readonly char[] s_specialChars = [' ', '\r', '\n'];
-
         /// <summary>
         /// Turns the nicely justified block of base64 found in a resx into a byte array.
         /// Copied from fx\src\winforms\managed\system\winforms\control.cs
         /// </summary>
         private static byte[] ByteArrayFromBase64WrappedString(string text)
         {
-            if (text.IndexOfAny(s_specialChars) != -1)
+            if (text.AsSpan().IndexOfAny(' ', '\r', '\n') != -1) // Chars that should be ignored in the nicely justified block of base64
             {
                 StringBuilder sb = new StringBuilder(text.Length);
                 for (int i = 0; i < text.Length; i++)
@@ -3044,7 +3039,7 @@ private void ReadResources(String filename, bool shouldUseSourcePath, String out
 
                     default:
                         // We should never get here, we've already checked the format
-                        Debug.Fail("Unknown format " + format.ToString());
+                        Debug.Fail($"Unknown format {format}");
                         return;
                 }
                 _logger.LogMessageFromResources(MessageImportance.Low, "GenerateResource.ReadResourceMessage", reader.resources.Count, filename);
@@ -3325,7 +3320,7 @@ private void WriteResources(ReaderInfo reader, String filename)
 #if FEATURE_RESXREADER_LIVEDESERIALIZATION
                     WriteResources(reader, new ResXResourceWriter(filename)); // closes writer for us
 #else
-                    _logger.LogError(format.ToString() + " not supported on .NET Core MSBuild");
+                    _logger.LogError($"{format} not supported on .NET Core MSBuild");
 #endif
                     break;
 
@@ -3339,7 +3334,7 @@ private void WriteResources(ReaderInfo reader, String filename)
 
                 default:
                     // We should never get here, we've already checked the format
-                    Debug.Fail("Unknown format " + format.ToString());
+                    Debug.Fail($"Unknown format {format}");
                     break;
             }
         }
@@ -3695,7 +3690,13 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                                     }
                                     try
                                     {
-                                        ch = (char)UInt16.Parse(new String(hex), NumberStyles.HexNumber, CultureInfo.CurrentCulture);
+                                        ch = (char)UInt16.Parse(
+#if NET
+                                            hex,
+#else
+                                            new String(hex),
+#endif
+                                            NumberStyles.HexNumber, CultureInfo.CurrentCulture);
                                     }
                                     catch (FormatException)
                                     {
@@ -4013,7 +4014,7 @@ internal int LinePosition
                 get { return column; }
             }
         }
-        #endregion // Code from ResGen.EXE
+#endregion // Code from ResGen.EXE
     }
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
@@ -4150,7 +4151,7 @@ public Type GetType(string name, bool throwOnError, bool ignoreCase)
                             result = a.GetType(name, false, ignoreCase);
                             if (result == null)
                             {
-                                int indexOfComma = name.IndexOf(",", StringComparison.Ordinal);
+                                int indexOfComma = name.IndexOf(',');
                                 if (indexOfComma != -1)
                                 {
                                     string shortName = name.Substring(0, indexOfComma);
diff --git a/src/Tasks/GetAssemblyIdentity.cs b/src/Tasks/GetAssemblyIdentity.cs
index 1d5c78c929e..f818366bc9f 100644
--- a/src/Tasks/GetAssemblyIdentity.cs
+++ b/src/Tasks/GetAssemblyIdentity.cs
@@ -45,12 +45,17 @@ private static string ByteArrayToHex(Byte[] a)
             {
                 return null;
             }
+
+#if NET
+            return Convert.ToHexString(a);
+#else
             var s = new StringBuilder(a.Length * 2);
             foreach (Byte b in a)
             {
                 s.Append(b.ToString("X02", CultureInfo.InvariantCulture));
             }
             return s.ToString();
+#endif
         }
 
         public override bool Execute()
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index b1a24a00d6a..34f84047a3f 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -1090,7 +1090,7 @@ internal bool IsAssemblyListCacheFileUpToDate(string sdkIdentity, string sdkRoot
                 string currentAssembly = String.Empty;
                 try
                 {
-#if NETCOREAPP
+#if NET
                     currentAssembly = Assembly.GetExecutingAssembly().Location;
 #else
                     currentAssembly = Assembly.GetExecutingAssembly().CodeBase;
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index 0bc42f56bfe..828012a2add 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -94,6 +94,9 @@ public override bool Execute()
 
                         sha.TransformFinalBlock(shaBuffer, 0, shaBufferPosition);
 
+#if NET
+                        HashResult = Convert.ToHexStringLower(sha.Hash);
+#else
                         using (var stringBuilder = new ReuseableStringBuilder(sha.HashSize))
                         {
                             foreach (var b in sha.Hash)
@@ -102,6 +105,7 @@ public override bool Execute()
                             }
                             HashResult = stringBuilder.ToString();
                         }
+#endif
                     }
                     finally
                     {
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 3169eaec219..12426e0c9aa 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -261,10 +261,7 @@ public override bool Execute()
             if (BuildInParallel)
             {
                 skipProjects = new bool[Projects.Length];
-                for (int i = 0; i < skipProjects.Length; i++)
-                {
-                    skipProjects[i] = true;
-                }
+                skipProjects.AsSpan().Fill(true);
             }
             else
             {
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 081762e8b84..555734fde12 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -508,7 +508,7 @@ private void ValidateCom()
                 }
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifest.CheckForComDuplicates t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateManifest.CheckForComDuplicates t={Environment.TickCount - t1}");
         }
 
         private void ValidateConfig()
@@ -661,11 +661,11 @@ private void ValidateReferencesForClickOnceApplication()
 
                     // Check for two or more items with the same TargetPath...
                     string key = assembly.TargetPath.ToLowerInvariant();
-                    if (!targetPathList.ContainsKey(key))
+                    if (!targetPathList.TryGetValue(key, out bool value))
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (!targetPathList[key])
+                    else if (!value)
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", assembly.ToString());
                         targetPathList[key] = true; // only warn once per path
@@ -707,18 +707,18 @@ private void ValidateReferencesForClickOnceApplication()
 
                     // Check for two or more items with the same TargetPath...
                     string key = file.TargetPath.ToLowerInvariant();
-                    if (!targetPathList.ContainsKey(key))
+                    if (!targetPathList.TryGetValue(key, out bool value))
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (!targetPathList[key])
+                    else if (!value)
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", file.TargetPath);
                         targetPathList[key] = true; // only warn once per path
                     }
                 }
             }
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifest.CheckManifestReferences t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateManifest.CheckManifestReferences t={Environment.TickCount - t1}");
         }
 
         private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustInfo trustInfo)
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 6328476020f..28dbbfef17f 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     /// <remarks>This is a serialization format, do not remove or change the private fields.</remarks>
     [ComVisible(false)]
     [XmlRoot("AssemblyIdentity")]
-    public sealed class AssemblyIdentity
+    public sealed partial class AssemblyIdentity
     {
         /// <summary>
         /// Specifies which attributes are to be returned by the GetFullName function.
@@ -59,6 +59,17 @@ public enum FullNameFlags
         private string _processorArchitecture;
         private string _type;
 
+        private const string AssemblyNamePattern =
+            "^(?<name>[^,]*)(, Version=(?<version>[^,]*))?(, Culture=(?<culture>[^,]*))?(, PublicKeyToken=(?<pkt>[^,]*))?(, ProcessorArchitecture=(?<pa>[^,]*))?(, Type=(?<type>[^,]*))?";
+
+#if NET
+        [GeneratedRegex(AssemblyNamePattern)]
+        private static partial Regex AssemblyNameRegex { get; }
+#else
+        private static Regex AssemblyNameRegex => _assemblyNameRegex ??= new Regex(AssemblyNamePattern);
+        private static Regex _assemblyNameRegex;
+#endif
+
         /// <summary>
         /// Initializes a new instance of the AssemblyIdentity class.
         /// </summary>
@@ -165,7 +176,7 @@ public AssemblyIdentity(AssemblyIdentity identity)
         public static AssemblyIdentity FromAssemblyName(string assemblyName)
         {
             // NOTE: We're not using System.Reflection.AssemblyName class here because we need ProcessorArchitecture and Type attributes.
-            Regex re = new Regex("^(?<name>[^,]*)(, Version=(?<version>[^,]*))?(, Culture=(?<culture>[^,]*))?(, PublicKeyToken=(?<pkt>[^,]*))?(, ProcessorArchitecture=(?<pa>[^,]*))?(, Type=(?<type>[^,]*))?");
+            Regex re = AssemblyNameRegex;
             Match m = re.Match(assemblyName);
             string name = m.Result("${name}");
             string version = m.Result("${version}");
@@ -367,10 +378,15 @@ public bool IsInFramework(string frameworkIdentifier, string frameworkVersion)
             Version version = null;
             if (!string.IsNullOrEmpty(frameworkVersion))
             {
-                // CA1307:Specify StringComparison.  Suppressed since a valid string representation of a version would be parsed correctly even if the the first character is not "v".
-                if (frameworkVersion.StartsWith("v"))
+                if (frameworkVersion[0] == 'v')
                 {
-                    System.Version.TryParse(frameworkVersion.Substring(1), out version);
+                    System.Version.TryParse(
+#if NET
+                        frameworkVersion.AsSpan(1),
+#else
+                        frameworkVersion.Substring(1),
+#endif
+                        out version);
                 }
                 else
                 {
@@ -514,14 +530,14 @@ internal string Resolve(string[] searchPaths, bool specificVersion)
 
             foreach (string searchPath in searchPaths)
             {
-                string file = String.Format(CultureInfo.InvariantCulture, "{0}.dll", _name);
+                string file = $"{_name}.dll";
                 string path = Path.Combine(searchPath, file);
                 if (FileSystems.Default.FileExists(path) && IsEqual(this, FromFile(path), specificVersion))
                 {
                     return path;
                 }
 
-                file = String.Format(CultureInfo.InvariantCulture, "{0}.manifest", _name);
+                file = $"{_name}.manifest";
                 path = Path.Combine(searchPath, file);
                 if (FileSystems.Default.FileExists(path) && IsEqual(this, FromManifest(path), specificVersion))
                 {
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 9df8266fb8e..94e6a9c206c 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -26,7 +26,6 @@ namespace System.Security.Cryptography
 {
     internal static partial class CngLightup
     {
-        private const string DsaOid = "1.2.840.10040.4.1";
         private const string RsaOid = "1.2.840.113549.1.1.1";
 
         private const string HashAlgorithmNameTypeName = "System.Security.Cryptography.HashAlgorithmName";
@@ -57,9 +56,6 @@ internal static partial class CngLightup
 
         private static readonly Lazy<bool> s_preferRsaCng = new Lazy<bool>(DetectRsaCngSupport);
 
-        private static volatile Func<X509Certificate2, DSA> s_getDsaPublicKey;
-        private static volatile Func<X509Certificate2, DSA> s_getDsaPrivateKey;
-
         private static volatile Func<X509Certificate2, RSA> s_getRsaPublicKey;
         private static volatile Func<X509Certificate2, RSA> s_getRsaPrivateKey;
         private static volatile Func<RSA, byte[], string, byte[]> s_rsaPkcs1SignMethod;
@@ -112,30 +108,6 @@ internal static RSA GetRSAPrivateKey(X509Certificate2 cert)
             return s_getRsaPrivateKey(cert);
         }
 
-        internal static DSA GetDSAPublicKey(X509Certificate2 cert)
-        {
-            if (s_getDsaPublicKey == null)
-            {
-                s_getDsaPublicKey =
-                    BindCoreDelegate<DSA>("DSA", isPublic: true) ??
-                    BindGetCapiPublicKey<DSA, DSACryptoServiceProvider>(DsaOid);
-            }
-
-            return s_getDsaPublicKey(cert);
-        }
-
-        internal static DSA GetDSAPrivateKey(X509Certificate2 cert)
-        {
-            if (s_getDsaPrivateKey == null)
-            {
-                s_getDsaPrivateKey =
-                    BindCoreDelegate<DSA>("DSA", isPublic: false) ??
-                    BindGetCapiPrivateKey<DSA>(DsaOid, csp => new DSACryptoServiceProvider(csp));
-            }
-
-            return s_getDsaPrivateKey(cert);
-        }
-
 #if !CNG_LIGHTUP_NO_SYSTEM_CORE
         internal static ECDsa GetECDsaPublicKey(X509Certificate2 cert)
         {
@@ -526,7 +498,6 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
             // Load System.Core.dll and load the appropriate extension class
             // (one of
             //    System.Security.Cryptography.X509Certificates.RSACertificateExtensions
-            //    System.Security.Cryptography.X509Certificates.DSACertificateExtensions
             //    System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions
             // )
             string typeName = "System.Security.Cryptography.X509Certificates." + algorithmName + "CertificateExtensions";
@@ -547,8 +518,6 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
             // (one of
             //     GetRSAPublicKey(this X509Certificate2 c)
             //     GetRSAPrivateKey(this X509Certificate2 c)
-            //     GetDSAPublicKey(this X509Certificate2 c)
-            //     GetDSAPrivateKey(this X509Certificate2 c)
             //     GetECDsaPublicKey(this X509Certificate2 c)
             //     GetECDsaPrivateKey(this X509Certificate2 c)
             // )
diff --git a/src/Tasks/ManifestUtil/ConvertUtil.cs b/src/Tasks/ManifestUtil/ConvertUtil.cs
index 7945fed64e5..88be5e23f8a 100644
--- a/src/Tasks/ManifestUtil/ConvertUtil.cs
+++ b/src/Tasks/ManifestUtil/ConvertUtil.cs
@@ -26,11 +26,11 @@ public static bool ToBoolean(string value, bool defaultValue)
                 }
                 catch (FormatException)
                 {
-                    Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Invalid value '{0}' for {1}, returning {2}", value, typeof(bool).Name, defaultValue.ToString()));
+                    Debug.Fail($"Invalid value '{value}' for {typeof(bool).Name}, returning {defaultValue}");
                 }
                 catch (ArgumentException)
                 {
-                    Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Invalid value '{0}' for {1}, returning {2}", value, typeof(bool).Name, defaultValue.ToString()));
+                    Debug.Fail($"Invalid value '{value}' for {typeof(bool).Name}, returning {defaultValue}");
                 }
             }
             return defaultValue;
diff --git a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
index 01cb5f8f5d3..ff62bb0b948 100644
--- a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
+++ b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
@@ -74,7 +74,7 @@ public static Stream Read(string path)
 
             int t1 = Environment.TickCount;
             EmbeddedManifestReader r = new EmbeddedManifestReader(path);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "EmbeddedManifestReader.Read t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"EmbeddedManifestReader.Read t={Environment.TickCount - t1}");
             return r._manifest;
         }
     }
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index d8e5b2a8fdd..63b307cd6df 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -630,11 +630,11 @@ private void ValidateReferences()
                     // Check for two or more assemblies with the same identity...
                     string identity = assembly.AssemblyIdentity.GetFullName(AssemblyIdentity.FullNameFlags.All);
                     string key = identity.ToLowerInvariant();
-                    if (!identityList.ContainsKey(key))
+                    if (!identityList.TryGetValue(key, out bool value))
                     {
                         identityList.Add(key, false);
                     }
-                    else if (!identityList[key])
+                    else if (!value)
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateAssemblyIdentity", identity);
                         identityList[key] = true; // only warn once per identity
diff --git a/src/Tasks/ManifestUtil/ManifestFormatter.cs b/src/Tasks/ManifestUtil/ManifestFormatter.cs
index d7d7ee01eb1..91405ecaac7 100644
--- a/src/Tasks/ManifestUtil/ManifestFormatter.cs
+++ b/src/Tasks/ManifestUtil/ManifestFormatter.cs
@@ -97,8 +97,8 @@ public static Stream Format(Stream input)
             w.WriteEndDocument();
             w.Flush();
             m.Position = 0;
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestWriter.Format t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"ManifestWriter.Format t={Environment.TickCount - t1}");
             return m;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index 131de566c33..1bd48abe2db 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -246,7 +246,7 @@ private static Manifest Deserialize(Stream s)
             using (XmlReader xr = XmlReader.Create(s, xrSettings))
             {
                 var m = (Manifest)xs.Deserialize(xr);
-                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestReader.Deserialize t={0}", Environment.TickCount - t1));
+                Util.WriteLog($"ManifestReader.Deserialize t={Environment.TickCount - t1}");
                 return m;
             }
         }
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 8da08fbacde..c5aff0aeae1 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -28,7 +28,7 @@ private static Stream Serialize(Manifest manifest)
 
             int t1 = Environment.TickCount;
             s.Serialize(w, manifest);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestWriter.Serialize t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"ManifestWriter.Serialize t={Environment.TickCount - t1}");
 
             w.Flush();
             m.Position = 0;
@@ -188,7 +188,7 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
             Util.WriteLogFile(n + ".write.3-formatted.xml", s4);
 
             Util.CopyStream(s4, output);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestWriter.WriteManifest t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"ManifestWriter.WriteManifest t={Environment.TickCount - t1}");
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index fe8269ecdca..efd6d271087 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -173,7 +173,12 @@ private string GetPublicKeyToken()
                 an.SetPublicKey(pk);
                 byte[] pkt = an.GetPublicKeyToken();
 
-                publicKeyToken = BitConverter.ToString(pkt).Replace("-", "");
+                publicKeyToken =
+#if NET
+                    Convert.ToHexString(pkt);
+#else
+                    BitConverter.ToString(pkt).Replace("-", "");
+#endif
             }
 
             if (!String.IsNullOrEmpty(publicKeyToken))
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 81c678e17cf..705f2a79d3b 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -4,6 +4,7 @@
 using System;
 using System.IO;
 using System.Linq;
+using System.Text;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -222,7 +223,13 @@ public static string Resolve(string path)
                 {
                     // Unfortunately Uri.Host is read-only, so we need to reconstruct it manually...
                     int i = path.IndexOf(localHost, StringComparison.OrdinalIgnoreCase);
-                    return i >= 0 ? path.Substring(0, i) + Environment.MachineName.ToLowerInvariant() + path.Substring(i + localHost.Length) : path;
+                    return i >= 0 ?
+#if NET
+                        $"{path.AsSpan(0, i)}{Environment.MachineName.ToLowerInvariant()}{path.AsSpan(i + localHost.Length)}" :
+#else
+                        $"{path.Substring(0, i)}{Environment.MachineName.ToLowerInvariant()}{path.Substring(i + localHost.Length)}" :
+#endif
+                        path;
                 }
                 return path;
             }
@@ -231,7 +238,11 @@ public static string Resolve(string path)
             return Path.GetFullPath(path); // make sure it's a full path
         }
 
-        private static bool IsAsciiString(string str)
-            => str.All(c => c <= 127);
+        private static bool IsAsciiString(string str) =>
+#if NET
+            Ascii.IsValid(str);
+#else
+            str.All(c => c <= 127);
+#endif
     }
 }
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index bc10cb1d02c..07eaa9e03d2 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -790,7 +790,7 @@ public void WriteManifest(Stream input, Stream output)
                 output.Flush();
             }
             document.Save(output);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestWriter.WriteTrustInfo t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"ManifestWriter.WriteTrustInfo t={Environment.TickCount - t1}");
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index a6b50bd028f..a2d89b437c7 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -67,47 +67,25 @@ public static string ByteArrayToHex(Byte[] a)
                 return null;
             }
 
-            StringBuilder s = new StringBuilder(a.Length);
+#if NET
+            return Convert.ToHexString(a);
+#else
+            StringBuilder s = new StringBuilder(a.Length * 2);
             foreach (Byte b in a)
             {
                 s.Append(b.ToString("X02", CultureInfo.InvariantCulture));
             }
 
             return s.ToString();
+#endif
         }
 
-        public static string ByteArrayToString(Byte[] a)
-        {
-            if (a == null)
-            {
-                return null;
-            }
-
-            StringBuilder s = new StringBuilder(a.Length);
-            foreach (Byte b in a)
-            {
-                s.Append(Convert.ToChar(b));
-            }
-
-            return s.ToString();
-        }
-
-        public static int CopyStream(Stream input, Stream output)
+        public static void CopyStream(Stream input, Stream output)
         {
             const int bufferSize = 0x4000;
-            byte[] buffer = new byte[bufferSize];
-            int bytesCopied = 0;
-            int bytesRead;
-            do
-            {
-                bytesRead = input.Read(buffer, 0, bufferSize);
-                output.Write(buffer, 0, bytesRead);
-                bytesCopied += bytesRead;
-            } while (bytesRead > 0);
-            output.Flush();
+            input.CopyTo(output, bufferSize);
             input.Position = 0;
             output.Position = 0;
-            return bytesCopied;
         }
 
         public static string FilterNonprintableChars(string value)
@@ -194,9 +172,15 @@ public static Version GetTargetFrameworkVersion(string targetFramework)
             Version frameworkVersion = null;
             if (!String.IsNullOrEmpty(targetFramework))
             {
-                if (targetFramework.StartsWith("v", StringComparison.OrdinalIgnoreCase))
+                if (targetFramework[0] is 'v' or 'V')
                 {
-                    Version.TryParse(targetFramework.Substring(1), out frameworkVersion);
+                    Version.TryParse(
+#if NET
+                        targetFramework.AsSpan(1),
+#else
+                        targetFramework.Substring(1),
+#endif
+                        out frameworkVersion);
                 }
                 else
                 {
@@ -216,8 +200,8 @@ public static string GetEmbeddedResourceString(string name)
         public static Stream GetEmbeddedResourceStream(string name)
         {
             Assembly a = Assembly.GetExecutingAssembly();
-            Stream s = a.GetManifestResourceStream(String.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(Util).Namespace, name));
-            Debug.Assert(s != null, String.Format(CultureInfo.CurrentCulture, "EmbeddedResource '{0}' not found", name));
+            Stream s = a.GetManifestResourceStream($"{typeof(Util).Namespace}.{name}");
+            Debug.Assert(s != null, $"EmbeddedResource '{name}' not found");
             return s;
         }
 
@@ -634,8 +618,14 @@ public static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
             {
-                return new Version(version.Substring(1));
+                return Version.Parse(
+#if NET
+                    version.AsSpan(1));
+#else
+                    version.Substring(1));
+#endif
             }
+
             return new Version(version);
         }
 
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index 32f985124aa..39c110eebb0 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -82,14 +82,14 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
 
             int t2 = Environment.TickCount;
             XPathDocument d = new XPathDocument(s);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XPathDocument(1) t={0}", Environment.TickCount - t2));
+            Util.WriteLog($"new XPathDocument(1) t={Environment.TickCount - t2}");
 
             int t3 = Environment.TickCount;
             var xslc = new XslCompiledTransform();
             // Using the Trusted Xslt is fine as the style sheet comes from our own assemblies.
             // This is similar to the prior this.GetType().Assembly/Evidence method that was used in the now depricated XslTransform.
             xslc.Load(d, XsltSettings.TrustedXslt, s_resolver);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform.Load t={0}", Environment.TickCount - t3));
+            Util.WriteLog($"XslCompiledTransform.Load t={Environment.TickCount - t3}");
 
             // Need to copy input stream because XmlReader will close it,
             // causing errors for later callers that access the same stream
@@ -99,7 +99,7 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
             int t4 = Environment.TickCount;
             using (XmlReader reader = XmlReader.Create(clonedInput))
             {
-                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XmlReader(2) t={0}", Environment.TickCount - t4));
+                Util.WriteLog($"new XmlReader(2) t={Environment.TickCount - t4}");
 
                 XsltArgumentList args = null;
                 if (entries.Length > 0)
@@ -110,7 +110,7 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
                         string key = entry.Key.ToString();
                         object val = entry.Value.ToString();
                         args.AddParam(key, "", val);
-                        Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "arg: key='{0}' value='{1}'", key, val.ToString()));
+                        Util.WriteLog($"arg: key='{key}' value='{val}'");
                     }
                 }
 
@@ -122,13 +122,13 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
 
                 int t5 = Environment.TickCount;
                 xslc.Transform(reader, args, w, s_resolver);
-                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform.Transform t={0}", Environment.TickCount - t4));
+                Util.WriteLog($"XslCompiledTransform.Transform t={Environment.TickCount - t4}");
 
                 w.WriteEndDocument();
                 w.Flush();
                 m.Position = 0;
 
-                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform(\"{0}\") t={1}", resource, Environment.TickCount - t1));
+                Util.WriteLog($"XslCompiledTransform(\"{resource}\") t={Environment.TickCount - t1}");
 
                 return m;
             }
@@ -153,7 +153,7 @@ public override Object GetEntity(Uri uri, string role, Type t)
                 {
                     // First look in assembly resources...
                     Assembly a = Assembly.GetExecutingAssembly();
-                    s = a.GetManifestResourceStream(String.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(Util).Namespace, filename));
+                    s = a.GetManifestResourceStream($"{typeof(Util).Namespace}.{filename}");
 
                     if (s != null)
                     {
@@ -191,7 +191,7 @@ public override Object GetEntity(Uri uri, string role, Type t)
                 }
 
                 // Didn't find the resource...
-                Debug.Fail(String.Format(CultureInfo.CurrentCulture, "ResourceResolver could not find file '{0}'", filename));
+                Debug.Fail($"ResourceResolver could not find file '{filename}'");
                 return null;
             }
         }
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 862bfb6b88c..d23e63c0870 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -817,12 +817,17 @@ private static string ObtainRFC3161Timestamp(string timeStampUrl, string signatu
 
                 try
                 {
+#if NET
+                    Span<byte> nonce = stackalloc byte[32];
+                    RandomNumberGenerator.Fill(nonce);
+#else
                     byte[] nonce = new byte[32];
 
                     using (RandomNumberGenerator rng = RandomNumberGenerator.Create())
                     {
                         rng.GetBytes(nonce);
                     }
+#endif
 
                     // Eventually, CryptEncodeObjectEx(...) is called on a CRYPT_TIMESTAMP_REQUEST with this nonce,
                     // and CryptEncodeObjectEx(...) interprets the nonce as a little endian, DER-encoded integer value
@@ -1044,13 +1049,19 @@ private static void StrongNameSignManifestDom(XmlDocument manifestDom, XmlDocume
             // Insert the signature now.
             signatureParent.AppendChild(xmlDigitalSignature);
         }
+
+#if !NET
         private static readonly char[] s_hexValues = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+#endif
 
         private static string BytesToHexString(byte[] array, int start, int end)
         {
             string result = null;
             if (array != null)
             {
+#if NET
+                return Convert.ToHexStringLower(array.AsSpan(start, end - start));
+#else
                 char[] hexOrder = new char[(end - start) * 2];
                 int i = end;
                 int digit, j = 0;
@@ -1062,6 +1073,7 @@ private static string BytesToHexString(byte[] array, int start, int end)
                     hexOrder[j++] = s_hexValues[digit];
                 }
                 result = new String(hexOrder);
+#endif
             }
             return result;
         }
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 80694ad6d50..48b9de51827 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1639,7 +1639,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
 
   <Target
-    Name="_SplitProjectReferencesByFileExistence">
+    Name="_SplitProjectReferencesByFileExistence"
+    DependsOnTargets="AssignProjectConfiguration">
 
     <!--
         Use this task for matching projects with pre-resolved project outputs set by the IDE
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 111880e1d30..8c761db013d 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -520,7 +520,7 @@ internal struct PROCESS_INFORMATION
     /// <summary>
     /// Interop methods.
     /// </summary>
-    internal static class NativeMethods
+    internal static partial class NativeMethods
     {
         #region Constants
 
@@ -1160,7 +1160,7 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                             }
 
                             // And convert it to the output string.
-                            strValue = new String(Encoding.UTF8.GetChars(bytes));
+                            strValue = Encoding.UTF8.GetString(bytes);
                         }
                         else
                         {
@@ -1235,19 +1235,24 @@ internal static unsafe int CorSigUncompressData(IntPtr data, out int uncompresse
         /// This class is a wrapper over the native GAC enumeration API.
         /// </summary>
         [ComVisible(false)]
-        internal class AssemblyCacheEnum : IEnumerable<AssemblyNameExtension>
+        internal partial class AssemblyCacheEnum : IEnumerable<AssemblyNameExtension>
         {
             /// <summary>
             /// Path to the gac
             /// </summary>
             private static readonly string s_gacPath = Path.Combine(NativeMethodsShared.FrameworkBasePath, "gac");
 
+            private const string AssemblyVersionPattern = @"^([.\d]+)_([^_]*)_([a-fA-F\d]{16})$";
+
             /// <summary>
             /// Regex for directory version parsing
             /// </summary>
-            private static readonly Regex s_assemblyVersionRegex = new Regex(
-                @"^([.\d]+)_([^_]*)_([a-fA-F\d]{16})$",
-                RegexOptions.CultureInvariant | RegexOptions.Compiled);
+#if NET
+            [GeneratedRegex(AssemblyVersionPattern, RegexOptions.CultureInvariant)]
+            private static partial Regex AssemblyVersionRegex { get; }
+#else
+            private static Regex AssemblyVersionRegex { get; } = new Regex(AssemblyVersionPattern, RegexOptions.CultureInvariant | RegexOptions.Compiled);
+#endif
 
             /// <summary>
             /// The IAssemblyEnum interface which allows us to ask for the next assembly from the GAC enumeration.
@@ -1387,7 +1392,7 @@ public IEnumerator<AssemblyNameExtension> GetEnumerator()
                                 var versionString = Path.GetFileName(version);
                                 if (!string.IsNullOrWhiteSpace(versionString))
                                 {
-                                    var match = s_assemblyVersionRegex.Match(versionString);
+                                    var match = AssemblyVersionRegex.Match(versionString);
                                     if (match.Success)
                                     {
                                         var name = new AssemblyName
@@ -1407,10 +1412,16 @@ public IEnumerator<AssemblyNameExtension> GetEnumerator()
                                         if (!string.IsNullOrWhiteSpace(match.Groups[3].Value))
                                         {
                                             var value = match.Groups[3].Value;
-                                            name.SetPublicKeyToken(
+                                            byte[] key =
+#if NET
+                                                Convert.FromHexString(value.AsSpan(0, 16));
+#else
                                                 Enumerable.Range(0, 16)
-                                                    .Where(x => x % 2 == 0)
-                                                    .Select(x => Convert.ToByte(value.Substring(x, 2), 16)).ToArray());
+                                                .Where(x => x % 2 == 0)
+                                                .Select(x => Convert.ToByte(value.Substring(x, 2), 16))
+                                                .ToArray();
+#endif
+                                            name.SetPublicKeyToken(key);
                                         }
 
                                         yield return new AssemblyNameExtension(name);
@@ -1455,8 +1466,12 @@ public static string AssemblyPathFromStrongName(string strongName)
                             "{0}_{1}_{2}",
                             assemblyNameVersion.Version.ToString(4),
                             assemblyNameVersion.CultureName != "neutral" ? assemblyNameVersion.CultureName : string.Empty,
+#if NET
+                            Convert.ToHexStringLower(assemblyNameVersion.GetPublicKeyToken())),
+#else
                             assemblyNameVersion.GetPublicKeyToken()
                                 .Aggregate(new StringBuilder(), (builder, v) => builder.Append(v.ToString("x2")))),
+#endif
                         assemblyNameVersion.Name + ".dll");
 
                     if (FileSystems.Default.FileExists(path))
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index f5476e2f9fc..7d8e6acd7ce 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -372,7 +372,7 @@ private static string GetSimpleName(string assemblyName)
                 throw new ArgumentNullException(nameof(assemblyName));
             }
 
-            int i = assemblyName.IndexOf(",", StringComparison.Ordinal);
+            int i = assemblyName.IndexOf(',');
             return i > 0 ? assemblyName.Substring(0, i) : assemblyName;
         }
 
@@ -794,7 +794,7 @@ private static void ParseFileListSection(AssemblyTableInfo assemblyTableInfo, st
                         {
                             // When comparing the assembly entries we want to compare the FullName which is a formatted as name, version, publicKeyToken and culture and whether the entry is a redistroot flag
                             // We do not need to add the redistName and the framework directory because this will be the same for all entries in the current redist list being read.
-                            string hashIndex = String.Format(CultureInfo.InvariantCulture, "{0},{1}", newEntry.FullName, newEntry.IsRedistRoot == null ? "null" : newEntry.IsRedistRoot.ToString());
+                            string hashIndex = $"{newEntry.FullName},{(newEntry.IsRedistRoot == null ? "null" : newEntry.IsRedistRoot.ToString())}";
 
                             assemblyEntries.TryGetValue(hashIndex, out AssemblyEntry dictionaryEntry);
                             // If the entry is not in the dictionary or the entry is in the dictionary but the new entry has the ingac flag true, make sure the dictionary contains the entry with the ingac true.
diff --git a/src/Tasks/RequiresFramework35SP1Assembly.cs b/src/Tasks/RequiresFramework35SP1Assembly.cs
index 4714f818e73..741dcbe59fc 100644
--- a/src/Tasks/RequiresFramework35SP1Assembly.cs
+++ b/src/Tasks/RequiresFramework35SP1Assembly.cs
@@ -79,7 +79,12 @@ private static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
             {
-                return new Version(version.Substring(1));
+                return Version.Parse(
+#if NET
+                    version.AsSpan(1));
+#else
+                    version.Substring(1));
+#endif
             }
             return new Version(version);
         }
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index c8ba6d686f4..c339ea9c5be 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -5,7 +5,7 @@
 #if !RUNTIME_TYPE_NETCORE
 using System.Collections.Generic;
 #endif
-#if !NET7_0_OR_GREATER
+#if !NET
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 9a78f010f16..d8a61ab1579 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -215,7 +215,12 @@ private static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
             {
-                return new Version(version.Substring(1));
+                return Version.Parse(
+#if NET
+                    version.AsSpan(1));
+#else
+                    version.Substring(1));
+#endif
             }
             return new Version(version);
         }
@@ -346,7 +351,7 @@ private static CultureInfo GetItemCulture(ITaskItem item)
                 // Infer culture from path (i.e. "obj\debug\fr\WindowsApplication1.resources.dll" -> "fr")
                 string[] pathSegments = PathUtil.GetPathSegments(item.ItemSpec);
                 itemCulture = pathSegments.Length > 1 ? pathSegments[pathSegments.Length - 2] : null;
-                Debug.Assert(!String.IsNullOrEmpty(itemCulture), String.Format(CultureInfo.CurrentCulture, "Satellite item '{0}' is missing expected attribute '{1}'", item.ItemSpec, "Culture"));
+                Debug.Assert(!String.IsNullOrEmpty(itemCulture), $"Satellite item '{item.ItemSpec}' is missing expected attribute 'Culture'");
                 item.SetMetadata("Culture", itemCulture);
             }
             return new CultureInfo(itemCulture);
@@ -862,7 +867,7 @@ public void Add(ITaskItem item)
 
                 // Add to map with full name, for SpecificVersion=true case
                 string key = fusionName.ToLowerInvariant();
-                Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same key '{0}' detected", key));
+                Debug.Assert(!_dictionary.ContainsKey(key), $"Two or more items with same key '{key}' detected");
                 if (!_dictionary.ContainsKey(key))
                 {
                     _dictionary.Add(key, entry);
@@ -921,7 +926,7 @@ public void Add(ITaskItem item)
                 {
                     // Use satellite assembly strong name signature as key
                     string key = identity.ToString();
-                    Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same key '{0}' detected", key));
+                    Debug.Assert(!_dictionary.ContainsKey(key), $"Two or more items with same key '{key}' detected");
                     if (!_dictionary.ContainsKey(key))
                     {
                         _dictionary.Add(key, entry);
@@ -962,7 +967,7 @@ public void Add(ITaskItem item, bool includedByDefault)
                 }
 
                 string key = targetPath.ToLowerInvariant();
-                Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same '{0}' attribute detected", ItemMetadataNames.targetPath));
+                Debug.Assert(!_dictionary.ContainsKey(key), $"Two or more items with same '{(object)ItemMetadataNames.targetPath}' attribute detected");
                 var entry = new MapEntry(item, includedByDefault);
                 if (!_dictionary.ContainsKey(key))
                 {
@@ -997,11 +1002,11 @@ private static PublishState StringToPublishState(string value)
                 }
                 catch (FormatException)
                 {
-                    Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Invalid value '{0}' for {1}", value, "PublishState"));
+                    Debug.Fail($"Invalid value '{value}' for PublishState");
                 }
                 catch (ArgumentException)
                 {
-                    Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Invalid value '{0}' for {1}", value, "PublishState"));
+                    Debug.Fail($"Invalid value '{value}' for PublishState");
                 }
             }
             return PublishState.Auto;
@@ -1036,14 +1041,14 @@ public static PublishFlags GetAssemblyFlags(PublishState state, bool copyLocal)
                         isPublished = false;
                         break;
                     case PublishState.DataFile:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "PublishState.DataFile is invalid for an assembly"));
+                        Debug.Fail("PublishState.DataFile is invalid for an assembly");
                         break;
                     case PublishState.Prerequisite:
                         isPrerequisite = true;
                         isPublished = false;
                         break;
                     default:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Unhandled value PublishFlags.{0}", state.ToString()));
+                        Debug.Fail($"Unhandled value PublishFlags.{state}");
                         break;
                 }
                 return new PublishFlags(isDataFile, isPrerequisite, isPublished);
@@ -1073,10 +1078,10 @@ public static PublishFlags GetFileFlags(PublishState state, string fileExtension
                         isPublished = true;
                         break;
                     case PublishState.Prerequisite:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "PublishState.Prerequisite is invalid for a file"));
+                        Debug.Fail("PublishState.Prerequisite is invalid for a file");
                         break;
                     default:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Unhandled value PublishFlags.{0}", state.ToString()));
+                        Debug.Fail($"Unhandled value PublishFlags.{state}");
                         break;
                 }
                 return new PublishFlags(isDataFile, isPrerequisite, isPublished);
@@ -1103,14 +1108,14 @@ public static PublishFlags GetSatelliteFlags(PublishState state, CultureInfo sat
                         isPublished = false;
                         break;
                     case PublishState.DataFile:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "PublishState.DataFile is invalid for an assembly"));
+                        Debug.Fail("PublishState.DataFile is invalid for an assembly");
                         break;
                     case PublishState.Prerequisite:
                         isPrerequisite = true;
                         isPublished = false;
                         break;
                     default:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Unhandled value PublishFlags.{0}", state.ToString()));
+                        Debug.Fail($"Unhandled value PublishFlags.{state}");
                         break;
                 }
                 return new PublishFlags(isDataFile, isPrerequisite, isPublished);
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 4cf06aa29e8..6a1a82c1ced 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Tasks
     /// Resolves an SDKReference to a full path on disk
     /// </summary>
 #pragma warning disable RS0022 // Constructor make noninheritable base class inheritable: Longstanding API design that we shouldn't change now
-    public class ResolveSDKReference : TaskExtension
+    public partial class ResolveSDKReference : TaskExtension
 #pragma warning restore RS0022 // Constructor make noninheritable base class inheritable
     {
         #region fields
@@ -33,13 +33,18 @@ public class ResolveSDKReference : TaskExtension
             { "UAP", "Windows" }
         };
 
+        private const string SdkReferenceFormatPattern = @"(?<SDKSIMPLENAME>^[^,]*),\s*Version=(?<SDKVERSION>.*)";
+
         /// <summary>
         /// Regex for breaking up the sdk reference include into pieces.
         /// Example: XNA, Version=8.0
         /// </summary>
-        private static readonly Regex s_sdkReferenceFormat = new Regex(
-             @"(?<SDKSIMPLENAME>^[^,]*),\s*Version=(?<SDKVERSION>.*)",
-            RegexOptions.IgnoreCase);
+#if NET
+        [GeneratedRegex(SdkReferenceFormatPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex SdkReferenceFormatRegex { get; }
+#else
+        private static Regex SdkReferenceFormatRegex { get; } = new Regex(SdkReferenceFormatPattern, RegexOptions.IgnoreCase);
+#endif
 
         /// <summary>
         /// SimpleName group
@@ -409,7 +414,7 @@ public override bool Execute()
                         {
                             if (!sdksAlreadyErrorOrWarnedFor.Contains(incompatibleReference) && incompatibleReference != notCompatibleReference /*cannot be incompatible with self*/)
                             {
-                                listOfIncompatibleReferences.Add(String.Format(CultureInfo.CurrentCulture, "\"{0}\"", incompatibleReference.SDKName));
+                                listOfIncompatibleReferences.Add($"\"{incompatibleReference.SDKName}\"");
                                 sdksAlreadyErrorOrWarnedFor.Add(incompatibleReference);
                             }
                         }
@@ -438,7 +443,7 @@ public override bool Execute()
                     {
                         if (!sdksAlreadyErrorOrWarnedFor.Contains(incompatibleReference) && incompatibleReference != notCompatibleReference /*cannot be incompatible with self*/)
                         {
-                            listOfIncompatibleReferences.Add(String.Format(CultureInfo.CurrentCulture, "\"{0}\"", incompatibleReference.SDKName));
+                            listOfIncompatibleReferences.Add($"\"{incompatibleReference.SDKName}\"");
                             sdksAlreadyErrorOrWarnedFor.Add(incompatibleReference);
                         }
                     }
@@ -481,7 +486,7 @@ internal static void AddMetadataToReferences(TaskLoggingHelper log, HashSet<SDKR
                     string sdkSimpleName = referenceItem.SimpleName;
                     string rawSdkVersion = referenceItem.Version;
 
-                    if (referencesToAddMetadata.ContainsKey(sdkSimpleName) && referencesToAddMetadata[sdkSimpleName].Equals(rawSdkVersion, StringComparison.InvariantCultureIgnoreCase))
+                    if (referencesToAddMetadata.TryGetValue(sdkSimpleName, out string value) && value.Equals(rawSdkVersion, StringComparison.InvariantCultureIgnoreCase))
                     {
                         referenceItem.ResolvedItem.SetMetadata(metadataName, metadataValue);
                     }
@@ -533,7 +538,7 @@ internal static string[] GetUnresolvedDependentSDKs(HashSet<SDKReference> sdkRef
                 // Return true if no reference could be found
                 return resolvedReference == null;
             })
-            .Select(y => String.Format(CultureInfo.CurrentCulture, "\"{0}\"", y))
+            .Select(y => $"\"{y}\"")
             .ToArray();
 
             return unresolvedDependencyIdentities;
@@ -574,7 +579,7 @@ internal SDKReference ParseSDKReference(ITaskItem referenceItem)
         /// </summary>
         private static bool ParseSDKReference(string reference, out string sdkSimpleName, out string rawSdkVersion)
         {
-            Match match = s_sdkReferenceFormat.Match(reference);
+            Match match = SdkReferenceFormatRegex.Match(reference);
 
             sdkSimpleName = String.Empty;
             bool parsedVersion = false;
@@ -733,7 +738,7 @@ public SDKReference(ITaskItem taskItem, string sdkName, string sdkVersion)
                 ReferenceItem = taskItem;
                 SimpleName = sdkName;
                 Version = sdkVersion;
-                SDKName = String.Format(CultureInfo.InvariantCulture, "{0}, Version={1}", SimpleName, Version);
+                SDKName = $"{SimpleName}, Version={Version}";
                 FrameworkIdentitiesFromManifest = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 AppxLocationsFromManifest = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 ResolutionErrors = new List<Tuple<string, object[]>>();
@@ -1289,13 +1294,13 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                     {
                         // Try and find a framework identity that matches on both the configuration and architecture "FrameworkIdentity-<Config>-<Arch>"
                         FrameworkIdentity = null;
-                        string frameworkIdentityKey = String.Format(CultureInfo.InvariantCulture, "{0}-{1}-{2}", SDKManifest.Attributes.FrameworkIdentity, sdkConfiguration, sdkArchitecture);
+                        string frameworkIdentityKey = $"{SDKManifest.Attributes.FrameworkIdentity}-{sdkConfiguration}-{sdkArchitecture}";
                         FrameworkIdentity = FindFrameworkIdentity(frameworkIdentityKey);
 
                         // Try and find a framework identity that matches on the configuration , Element must be named "FrameworkIdentity-<Config>" only.
                         if (FrameworkIdentity == null)
                         {
-                            frameworkIdentityKey = String.Format(CultureInfo.InvariantCulture, "{0}-{1}", SDKManifest.Attributes.FrameworkIdentity, sdkConfiguration);
+                            frameworkIdentityKey = $"{SDKManifest.Attributes.FrameworkIdentity}-{sdkConfiguration}";
                             FrameworkIdentity = FindFrameworkIdentity(frameworkIdentityKey);
                         }
 
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index ea1ffae0211..1f6b95b7067 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -89,7 +89,11 @@ private static string GetFullTypeNameFromAlias(string aliasedTypeName, Dictionar
             int indexStart = aliasedTypeName.IndexOf(',');
             if (aliases.TryGetValue(aliasedTypeName.Substring(indexStart + 2), out string fullAssemblyIdentity))
             {
+#if NET
+                return string.Concat(aliasedTypeName.AsSpan(0, indexStart + 2), fullAssemblyIdentity);
+#else
                 return aliasedTypeName.Substring(0, indexStart + 2) + fullAssemblyIdentity;
+#endif
             }
 
             // Allow "System.String" bare
@@ -290,7 +294,7 @@ private static void AddLinkedResource(string resxFilename, bool pathsRelativeToB
         /// </remarks>
         private static bool IsByteArray(string fileRefType)
         {
-            return fileRefType.IndexOf("System.Byte[]") != -1 && fileRefType.IndexOf("mscorlib") != -1;
+            return fileRefType.Contains("System.Byte[]") && fileRefType.Contains("mscorlib");
         }
 
         internal static bool IsString(string fileRefType)
@@ -333,7 +337,7 @@ internal static string[] ParseResxFileRefString(string stringValue)
                 string remainingString;
                 if (stringValue.StartsWith("\""))
                 {
-                    int lastIndexOfQuote = stringValue.LastIndexOf("\"");
+                    int lastIndexOfQuote = stringValue.LastIndexOf('"');
                     if (lastIndexOfQuote - 1 < 0)
                     {
                         throw new ArgumentException(nameof(stringValue));
@@ -349,7 +353,7 @@ internal static string[] ParseResxFileRefString(string stringValue)
                 }
                 else
                 {
-                    int nextSemiColumn = stringValue.IndexOf(";");
+                    int nextSemiColumn = stringValue.IndexOf(';');
                     if (nextSemiColumn == -1)
                     {
                         throw new ArgumentException(nameof(stringValue));
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 535156bc1fd..d5d9ebda785 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -536,10 +536,10 @@ internal bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTask
             // Start with the user specified references and include all of the default references that are language agnostic
             IEnumerable<string> references = taskInfo.References.Union(DefaultReferences[String.Empty]);
 
-            if (DefaultReferences.ContainsKey(taskInfo.CodeLanguage))
+            if (DefaultReferences.TryGetValue(taskInfo.CodeLanguage, out IEnumerable<string> value))
             {
                 // Append default references for the specific language
-                references = references.Union(DefaultReferences[taskInfo.CodeLanguage]);
+                references = references.Union(value);
             }
 
             List<string> directoriesToAddToAppDomain = new();
diff --git a/src/Tasks/System.Resources.Extensions.pkgdef b/src/Tasks/System.Resources.Extensions.pkgdef
index 62579ad4643..4e811b44871 100644
--- a/src/Tasks/System.Resources.Extensions.pkgdef
+++ b/src/Tasks/System.Resources.Extensions.pkgdef
@@ -3,5 +3,5 @@
 "codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\System.Resources.Extensions.dll"
 "publicKeyToken"="cc7b13ffcd2ddd51"
 "culture"="neutral"
-"oldVersion"="0.0.0.0-99.9.9.9"
-"newVersion"="8.0.0.0"
+"oldVersion"="0.0.0.0-9.0.0.0"
+"newVersion"="9.0.0.0"
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index f85dc93eb7e..cbb66f13907 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -70,7 +70,7 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// <summary>
         /// Additional level of caching kept at the process level.
         /// </summary>
-        private static ConcurrentDictionary<string, FileState> s_processWideFileStateCache = new ConcurrentDictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
+        private static readonly ConcurrentDictionary<string, FileState> s_processWideFileStateCache = new ConcurrentDictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// XML tables of installed assemblies.
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 690308135f0..01026579232 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -327,7 +327,7 @@ private void ParsePattern(string pattern, out string[] patterns)
                     // Supporting property references would require access to Expander which is unavailable in Microsoft.Build.Tasks
                     Log.LogErrorWithCodeFromResources("Unzip.ErrorParsingPatternPropertyReferences", pattern);
                 }
-                else if (pattern.IndexOfAny(FileUtilities.InvalidPathChars) != -1)
+                else if (pattern.AsSpan().IndexOfAny(FileUtilities.InvalidPathChars) >= 0)
                 {
                     Log.LogErrorWithCodeFromResources("Unzip.ErrorParsingPatternInvalidPath", pattern);
                 }
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index ecfe9bad0d6..9e08cea56bc 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -210,7 +210,13 @@ private string GenerateCode(out string extension)
 
                         if (name.StartsWith("_Parameter", StringComparison.OrdinalIgnoreCase))
                         {
-                            if (!Int32.TryParse(name.Substring("_Parameter".Length), out int index))
+                            if (!Int32.TryParse(
+#if NET
+                                name.AsSpan("_Parameter".Length),
+#else
+                                name.Substring("_Parameter".Length),
+#endif
+                                out int index))
                             {
                                 Log.LogErrorWithCodeFromResources("General.InvalidValue", name, "WriteCodeFragment");
                                 return null;
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 1ef6c1ec726..f2fbe04a6b2 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -413,22 +413,21 @@ private static void EmitStringArraySwitch(CommandLineBuilder clb, CommandLineToo
         /// </summary>
         private static bool PerformSwitchValueSubstition(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch, string switchValue)
         {
-            Regex regex = new Regex(@"\[value]", RegexOptions.IgnoreCase);
-            Match match = regex.Match(commandLineToolSwitch.SwitchValue);
-            if (match.Success)
+            const string Value = "[value]";
+            int valuePos = commandLineToolSwitch.SwitchValue.IndexOf(Value, StringComparison.OrdinalIgnoreCase);
+            if (valuePos >= 0)
             {
-                string prefixToAppend = commandLineToolSwitch.SwitchValue.Substring(match.Index + match.Length, commandLineToolSwitch.SwitchValue.Length - (match.Index + match.Length));
-                string valueToAppend;
-                if (!switchValue.EndsWith("\\\\", StringComparison.OrdinalIgnoreCase) && switchValue.EndsWith("\\", StringComparison.OrdinalIgnoreCase) && prefixToAppend.Length > 0 && prefixToAppend[0] == '\"')
-                {
-                    // If the combined string would create \" then we need to escape it
-                    // if the combined string would create \\" then we ignore it as as assume it is already escaped.
-                    valueToAppend = commandLineToolSwitch.SwitchValue.Substring(0, match.Index) + switchValue + "\\" + prefixToAppend;
-                }
-                else
-                {
-                    valueToAppend = commandLineToolSwitch.SwitchValue.Substring(0, match.Index) + switchValue + prefixToAppend;
-                }
+                string prefixToAppend = commandLineToolSwitch.SwitchValue.Substring(valuePos + Value.Length);
+
+                // If the combined string would create \" then we need to escape it
+                // if the combined string would create \\" then we ignore it as as assume it is already escaped.
+                bool needsEscaping =
+                    !switchValue.EndsWith("\\\\", StringComparison.OrdinalIgnoreCase) &&
+                    switchValue.EndsWith("\\", StringComparison.OrdinalIgnoreCase) &&
+                    prefixToAppend.Length > 0 &&
+                    prefixToAppend[0] == '\"';
+
+                string valueToAppend = $"{commandLineToolSwitch.SwitchValue.Substring(0, valuePos)}{switchValue}{(needsEscaping ? "\\" : "")}{prefixToAppend}";
 
                 clb.AppendSwitch(valueToAppend);
                 return true;
@@ -645,8 +644,7 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
             // Match all instances of [asdf], where "asdf" can be any combination of any
             // characters *except* a [ or an ]. i.e., if "[ [ sdf ]" is passed, then we will
             // match "[ sdf ]"
-            string matchString = @"\[[^\[\]]+\]";
-            Regex regex = new Regex(matchString, RegexOptions.ECMAScript);
+            Regex regex = new Regex(@"\[[^\[\]]+\]", RegexOptions.ECMAScript);
             MatchCollection matches = regex.Matches(CommandLineTemplate);
 
             int indexOfEndOfLastSubstitution = 0;
@@ -735,7 +733,7 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
                 indexOfEndOfLastSubstitution = match.Index + match.Length;
             }
 
-            builder.AppendTextUnquoted(CommandLineTemplate.Substring(indexOfEndOfLastSubstitution, CommandLineTemplate.Length - indexOfEndOfLastSubstitution));
+            builder.AppendTextUnquoted(CommandLineTemplate.Substring(indexOfEndOfLastSubstitution));
         }
     }
 }
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index e74251b8bba..18e0ce17d1d 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -71,7 +71,7 @@ public Type TaskType
             {
                 if (_taskType == null)
                 {
-                    _taskType = _taskAssembly.GetType(String.Concat(XamlTaskNamespace, ".", TaskName), true);
+                    _taskType = _taskAssembly.GetType($"{XamlTaskNamespace}.{TaskName}", true);
                 }
 
                 return _taskType;
@@ -195,7 +195,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
         /// <param name="taskFactoryLoggingHost">The task factory logging host will log messages in the context of the task.</param>
         public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
         {
-            string fullTaskName = String.Concat(TaskNamespace, ".", TaskName);
+            string fullTaskName = $"{TaskNamespace}.{TaskName}";
             return (ITask)_taskAssembly.CreateInstance(fullTaskName);
         }
 
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index e29bd389537..cdc831de205 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -9,8 +9,9 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
 
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index a34a45ea3ec..7fbd0431575 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -2142,7 +2142,7 @@ public void GetPathToStandardLibraries64Bit35()
             string frameworkDirectory2064bit = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(SharedDotNetFrameworkArchitecture.Bitness64);
             string frameworkDirectory20Current = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(SharedDotNetFrameworkArchitecture.Current);
 
-            if (!EnvironmentUtilities.Is64BitOperatingSystem)
+            if (!Environment.Is64BitOperatingSystem)
             {
                 // "Not 64 bit OS "
                 return;
@@ -2163,7 +2163,7 @@ public void GetPathToStandardLibraries64Bit35()
             pathToFramework = ToolLocationHelper.GetPathToStandardLibraries(".NetFramework", "v3.5", string.Empty, "itanium");
             pathToFramework.ShouldBe(frameworkDirectory2064bit, StringCompareShould.IgnoreCase);
 
-            if (!EnvironmentUtilities.Is64BitProcess)
+            if (!Environment.Is64BitProcess)
             {
                 pathToFramework = ToolLocationHelper.GetPathToStandardLibraries(".NetFramework", "v3.5", string.Empty, "RandomPlatform");
                 pathToFramework.ShouldBe(frameworkDirectory2032bit, StringCompareShould.IgnoreCase);
@@ -2188,7 +2188,7 @@ public void GetPathToStandardLibraries64Bit40()
         {
             IList<string> referencePaths = ToolLocationHelper.GetPathToReferenceAssemblies(new FrameworkNameVersioning(".NETFramework", new Version("4.0")));
 
-            if (!EnvironmentUtilities.Is64BitOperatingSystem)
+            if (!Environment.Is64BitOperatingSystem)
             {
                 // "Not 64 bit OS "
                 return;
@@ -2233,7 +2233,7 @@ public void GetPathToStandardLibraries32Bit35()
             string frameworkDirectory2032bit = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(SharedDotNetFrameworkArchitecture.Bitness32);
             string frameworkDirectory20Current = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(SharedDotNetFrameworkArchitecture.Current);
 
-            if (EnvironmentUtilities.Is64BitOperatingSystem)
+            if (Environment.Is64BitOperatingSystem)
             {
                 // "Is a 64 bit OS "
                 return;
@@ -2271,7 +2271,7 @@ public void GetPathToStandardLibraries32Bit40()
         {
             IList<string> referencePaths = ToolLocationHelper.GetPathToReferenceAssemblies(new FrameworkNameVersioning(".NETFramework", new Version("4.0")));
 
-            if (EnvironmentUtilities.Is64BitOperatingSystem)
+            if (Environment.Is64BitOperatingSystem)
             {
                 // "Is 64 bit OS "
                 return;
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index c41b18d74c0..07ac12544e9 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -154,14 +154,14 @@ public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparat
         /// <summary>
         /// Use a private property so that we can lazy initialize the regex
         /// </summary>
-        private Regex DefinitelyNeedQuotes => _definitelyNeedQuotes
-            ?? (_definitelyNeedQuotes = new Regex(_quoteHyphens ? s_definitelyNeedQuotesRegexWithHyphen : s_definitelyNeedQuotesRegexNoHyphen, RegexOptions.CultureInvariant));
+        private Regex DefinitelyNeedQuotes => _definitelyNeedQuotes ??=
+            new Regex(_quoteHyphens ? s_definitelyNeedQuotesRegexWithHyphen : s_definitelyNeedQuotesRegexNoHyphen, RegexOptions.CultureInvariant);
 
         /// <summary>
         /// Use a private getter property to we can lazy initialize the regex
         /// </summary>
-        private Regex AllowedUnquoted => _allowedUnquoted
-            ?? (_allowedUnquoted = new Regex(_quoteHyphens ? s_allowedUnquotedRegexNoHyphen : s_allowedUnquotedRegexWithHyphen, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant));
+        private Regex AllowedUnquoted => _allowedUnquoted ??=
+            new Regex(_quoteHyphens ? s_allowedUnquotedRegexNoHyphen : s_allowedUnquotedRegexWithHyphen, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
 
         /// <summary>
         /// Checks the given switch parameter to see if it must/can be quoted.
@@ -259,6 +259,9 @@ protected void AppendQuotedTextToBuffer(StringBuilder buffer, string unquotedTex
                 }
 
                 // Count the number of quotes
+#if NET
+                int literalQuotes = unquotedTextToAppend.AsSpan().Count('"');
+#else
                 int literalQuotes = 0;
                 for (int i = 0; i < unquotedTextToAppend.Length; i++)
                 {
@@ -267,6 +270,8 @@ protected void AppendQuotedTextToBuffer(StringBuilder buffer, string unquotedTex
                         literalQuotes++;
                     }
                 }
+#endif
+
                 if (literalQuotes > 0)
                 {
                     // Replace any \" sequences with \\"
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
index eeee8bb3f8a..d61bb3c6b1f 100644
--- a/src/Utilities/CompatibilitySuppressions.xml
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -1,11 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
-       This is intentional, because you can only use MSBuild in the context of a .NET SDK
-       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
-       have previously shipped netstandard2.0 packages, and if you want to support both
-       runtime contexts it still makes sense to target that. -->
   <Suppression>
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>.NETCoreApp,Version=v2.0</Target>
diff --git a/src/Utilities/LockCheck.cs b/src/Utilities/LockCheck.cs
index 7b191851e70..f9ec08b314a 100644
--- a/src/Utilities/LockCheck.cs
+++ b/src/Utilities/LockCheck.cs
@@ -241,7 +241,7 @@ public override bool Equals(object obj)
 
             public override string ToString()
             {
-                return ProcessId + "@" + StartTime.ToString("s");
+                return $"{ProcessId}@{StartTime:s}";
             }
         }
 
diff --git a/src/Utilities/SDKManifest.cs b/src/Utilities/SDKManifest.cs
index 86e0be400ce..d8c06a2c234 100644
--- a/src/Utilities/SDKManifest.cs
+++ b/src/Utilities/SDKManifest.cs
@@ -45,22 +45,22 @@ public class SDKManifest
         /// <summary>
         /// Pattern in path to extension SDK used to help determine if manifest is from a framework SDK
         /// </summary>
-        private static string s_extensionSDKPathPattern = @"\MICROSOFT SDKS\WINDOWS\V8.0\EXTENSIONSDKS";
+        private const string s_extensionSDKPathPattern = @"\MICROSOFT SDKS\WINDOWS\V8.0\EXTENSIONSDKS";
 
         /// <summary>
         /// Default version of MaxPlatformVersion in framework extension SDKs with manifest not containing such a property
         /// </summary>
-        private static string s_defaultMaxPlatformVersion = "8.0";
+        private const string s_defaultMaxPlatformVersion = "8.0";
 
         /// <summary>
         /// Default version of MinOSVersion in framework extension SDKs with manifest not containing such a property
         /// </summary>
-        private static string s_defaultMinOSVersion = "6.2.1";
+        private const string s_defaultMinOSVersion = "6.2.1";
 
         /// <summary>
         /// Default version of MaxOSVersionTested in framework extension SDKs with manifest not containing such a property
         /// </summary>
-        private static string s_defaultMaxOSVersionTested = "6.2.1";
+        private const string s_defaultMaxOSVersionTested = "6.2.1";
 
         /// <summary>
         /// What should happen if this sdk is resolved with other sdks of the same productfamily or same sdk name.
diff --git a/src/Utilities/TargetPlatformSDK.cs b/src/Utilities/TargetPlatformSDK.cs
index 8740fe39e10..f0c7992c74b 100644
--- a/src/Utilities/TargetPlatformSDK.cs
+++ b/src/Utilities/TargetPlatformSDK.cs
@@ -189,6 +189,6 @@ public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatf
         /// <summary>
         /// Given an identifier and version, construct a string to use as a key for that combination.
         /// </summary>
-        internal static string GetSdkKey(string sdkIdentifier, string sdkVersion) => string.Format(CultureInfo.InvariantCulture, "{0}, Version={1}", sdkIdentifier, sdkVersion);
+        internal static string GetSdkKey(string sdkIdentifier, string sdkVersion) => $"{sdkIdentifier}, Version={sdkVersion}";
     }
 }
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 3f13658e0dd..598b9539c43 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -1821,7 +1821,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
                 if (NativeMethodsShared.IsWindows && platformTarget != null)
                 {
                     // If we are a 32 bit operating system the we should always return the 32 bit directory, or we are targeting x86, arm is also 32 bit
-                    if (!EnvironmentUtilities.Is64BitOperatingSystem || platformTarget.Equals("x86", StringComparison.OrdinalIgnoreCase) || platformTarget.Equals("arm", StringComparison.OrdinalIgnoreCase))
+                    if (!Environment.Is64BitOperatingSystem || platformTarget.Equals("x86", StringComparison.OrdinalIgnoreCase) || platformTarget.Equals("arm", StringComparison.OrdinalIgnoreCase))
                     {
                         targetedArchitecture = SharedDotNetFrameworkArchitecture.Bitness32;
                     }
@@ -2863,7 +2863,7 @@ private static void GatherSDKListFromRegistry(string registryRoot, Dictionary<Ta
             OpenBaseKey openBaseKey = new OpenBaseKey(RegistryHelper.OpenBaseKey);
             FileExists fileExists = new FileExists(File.Exists);
 
-            bool is64bitOS = EnvironmentUtilities.Is64BitOperatingSystem;
+            bool is64bitOS = Environment.Is64BitOperatingSystem;
 
             // Under WOW64 the HKEY_CURRENT_USER\SOFTWARE key is shared. This means the values are the same in the 64 bit and 32 bit views. This means we only need to get one view of this key.
             GatherSDKsFromRegistryImpl(platformMonikers, registryRoot, RegistryView.Default, RegistryHive.CurrentUser, getSubkeyNames, getRegistrySubKeyDefaultValue, openBaseKey, fileExists);
@@ -3738,9 +3738,13 @@ private static SharedDotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkA
         private static Version ConvertTargetFrameworkVersionToVersion(string targetFrameworkVersion)
         {
             // Trim off the v if is is there.
-            if (!string.IsNullOrEmpty(targetFrameworkVersion) && targetFrameworkVersion.Substring(0, 1).Equals("v", StringComparison.OrdinalIgnoreCase))
+            if (!string.IsNullOrEmpty(targetFrameworkVersion) && targetFrameworkVersion[0] is 'v' or 'V')
             {
-                targetFrameworkVersion = targetFrameworkVersion.Substring(1);
+#if NET
+                return Version.Parse(targetFrameworkVersion.AsSpan(1));
+#else
+                return new Version(targetFrameworkVersion.Substring(1));
+#endif
             }
 
             return new Version(targetFrameworkVersion);
@@ -3859,8 +3863,13 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
                     // only add if the version folder name is of the right format
                     if (folder.Name.Length >= 4 && folder.Name.StartsWith("v", StringComparison.OrdinalIgnoreCase))
                     {
-                        Version ver;
-                        if (Version.TryParse(folder.Name.Substring(1), out ver))
+                        if (Version.TryParse(
+#if NET
+                            folder.Name.AsSpan(1),
+#else
+                            folder.Name.Substring(1),
+#endif
+                            out _))
                         {
                             frameworkVersions.Add(folder.Name);
                         }
@@ -3982,10 +3991,14 @@ private VersionComparer()
 
             public int Compare(string versionX, string versionY)
             {
+#if NET
+                return Version.Parse(versionX.AsSpan(1)).CompareTo(Version.Parse(versionY.AsSpan(1)));
+#else
                 return new Version(versionX.Substring(1)).CompareTo(new Version(versionY.Substring(1)));
+#endif
             }
         }
 
-        #endregion
+#endregion
     }
 }
diff --git a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
index c3b83f0c8e8..91b192b37a9 100644
--- a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -27,7 +27,7 @@
       "type": "parameter",
       "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
       "datatype": "text",
-      "defaultValue": "17.13.0",
+      "defaultValue": "17.14.0",
       "replaces": "1.0.0-MicrosoftBuildPackageVersion",
       "displayName": "Microsoft.Build default package version override"
     }
