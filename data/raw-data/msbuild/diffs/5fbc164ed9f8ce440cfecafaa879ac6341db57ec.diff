diff --git a/src/StringTools/AssemblyInfo.cs b/src/StringTools/AssemblyInfo.cs
new file mode 100644
index 00000000000..0a8c0ee0a72
--- /dev/null
+++ b/src/StringTools/AssemblyInfo.cs
@@ -0,0 +1,13 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+[assembly: InternalsVisibleTo("Microsoft.NET.StringTools.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.NET.StringTools.net35.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
+[assembly: InternalsVisibleTo("Microsoft.NET.StringTools.Benchmark, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
+
+[assembly: ComVisible(false)]
+[assembly: CLSCompliant(true)]
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
new file mode 100644
index 00000000000..88126da5c6f
--- /dev/null
+++ b/src/StringTools/InternableString.Simple.cs
@@ -0,0 +1,231 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq.Expressions;
+using System.Text;
+
+namespace System
+{
+    /// <summary>
+    /// A bare minimum and inefficient version of MemoryExtensions as provided in System.Memory on .NET 4.5.
+    /// </summary>
+    public static class MemoryExtensions
+    {
+        public static string AsSpan<T>(this T[] array, int start, int length)
+        {
+            if (array is char[] charArray)
+            {
+                return new string(charArray, start, length);
+            }
+            throw new ArgumentException(nameof(array));
+        }
+    }
+}
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Represents a string that can be converted to System.String with interning, i.e. by returning an existing string if it has been seen before
+    /// and is still tracked in the intern table.
+    /// </summary>
+    /// <remarks>
+    /// This is a simple and inefficient implementation compatible with .NET Framework 3.5.
+    /// </remarks>
+    internal ref struct InternableString
+    {
+        /// <summary>
+        /// Enumerator for the top-level struct. Enumerates characters of the string.
+        /// </summary>
+        public ref struct Enumerator
+        {
+            /// <summary>
+            /// The InternableString being enumerated.
+            /// </summary>
+            private InternableString _string;
+
+            /// <summary>
+            /// Index of the current character, -1 if MoveNext has not been called yet.
+            /// </summary>
+            private int _charIndex;
+
+            public Enumerator(ref InternableString spanBuilder)
+            {
+                _string = spanBuilder;
+                _charIndex = -1;
+            }
+
+            /// <summary>
+            /// Returns the current character.
+            /// </summary>
+            public char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
+
+            /// <summary>
+            /// Moves to the next character.
+            /// </summary>
+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>
+            public bool MoveNext()
+            {
+                int newIndex = _charIndex + 1;
+                if (newIndex < _string.Length)
+                {
+                    _charIndex = newIndex;
+                    return true;
+                }
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// If this instance wraps a StringBuilder, it uses this backing field.
+        /// </summary>
+        private StringBuilder? _builder;
+
+        /// <summary>
+        /// If this instance represents one contiguous string, it may be held in this field.
+        /// </summary>
+        private string? _firstString;
+
+        /// <summary>
+        /// A convenience getter to ensure that we always operate on a non-null string.
+        /// </summary>
+        private string FirstString => _firstString ?? string.Empty;
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given string.
+        /// </summary>
+        /// <param name="str">The string to wrap, must be non-null.</param>
+        internal InternableString(string str)
+        {
+            if (str == null)
+            {
+                throw new ArgumentNullException(nameof(str));
+            }
+            _builder = null;
+            _firstString = str;
+        }
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given SpanBasedStringBuilder.
+        /// </summary>
+        internal InternableString(SpanBasedStringBuilder builder)
+        {
+            _builder = builder.Builder;
+            _firstString = null;
+        }
+
+        /// <summary>
+        /// Gets the length of the string.
+        /// </summary>
+        public int Length => (_builder == null ? FirstString.Length : _builder.Length);
+
+        /// <summary>
+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
+        /// </summary>
+        /// <returns>The enumerator.</returns>
+        public Enumerator GetEnumerator()
+        {
+            return new Enumerator(ref this);
+        }
+
+        /// <summary>
+        /// Returns true if the string is equal to another string by ordinal comparison.
+        /// </summary>
+        /// <param name="other">Another string.</param>
+        /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
+        public bool Equals(string other)
+        {
+            if (other.Length != Length)
+            {
+                return false;
+            }
+
+            if (_firstString != null)
+            {
+                return _firstString.Equals(other);
+            }
+            if (_builder != null)
+            {
+                for (int i = 0; i < other.Length; i++)
+                {
+                    // Note: This indexing into the StringBuilder could be O(N). We prefer it over allocating
+                    // a new string with ToString().
+                    if (other[i] != _builder[i])
+                    {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+
+        /// <summary>
+        /// Returns a System.String representing this string. Allocates memory unless this InternableString was created by wrapping a
+        /// System.String in which case the original string is returned.
+        /// </summary>
+        /// <returns>The string.</returns>
+        public string ExpensiveConvertToString()
+        {
+            // Special case: if we hold just one string, we can directly return it.
+            if (_firstString != null)
+            {
+                return _firstString;
+            }
+            return _builder?.ToString() ?? string.Empty;
+        }
+
+        /// <summary>
+        /// Returns true if this InternableString wraps a System.String and the same System.String is passed as the argument.
+        /// </summary>
+        /// <param name="str">The string to compare to.</param>
+        /// <returns>True is this instance wraps the given string.</returns>
+        public bool ReferenceEquals(string str)
+        {
+            return Object.ReferenceEquals(str, _firstString);
+        }
+
+        /// <summary>
+        /// Converts this instance to a System.String while first searching for a match in the intern table.
+        /// </summary>
+        /// <remarks>
+        /// May allocate depending on whether the string has already been interned.
+        /// </remarks>
+        public override unsafe string ToString()
+        {
+            return WeakStringCacheInterner.Instance.InternableToString(ref this);
+        }
+
+        /// <summary>
+        /// Implements the simple yet very decently performing djb2 hash function (xor version).
+        /// </summary>
+        /// <returns>A stable hashcode of the string represented by this instance.</returns>
+        public override int GetHashCode()
+        {
+            int hashCode = 5381;
+
+            if (_firstString != null)
+            {
+                foreach (char ch in _firstString)
+                {
+                    unchecked
+                    {
+                        hashCode = hashCode * 33 ^ ch;
+                    }
+                }
+            }
+            else if (_builder != null)
+            {
+                for (int i = 0; i < _builder.Length; i++)
+                {
+                    unchecked
+                    {
+                        hashCode = hashCode * 33 ^ _builder[i];
+                    }
+                }
+            }
+            return hashCode;
+        }
+    }
+}
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
new file mode 100644
index 00000000000..ca8fa75ef48
--- /dev/null
+++ b/src/StringTools/InternableString.cs
@@ -0,0 +1,331 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Runtime.CompilerServices;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Represents a string that can be converted to System.String with interning, i.e. by returning an existing string if it has been seen before
+    /// and is still tracked in the intern table.
+    /// </summary>
+    internal ref struct InternableString
+    {
+        /// <summary>
+        /// Enumerator for the top-level struct. Enumerates characters of the string.
+        /// </summary>
+        public ref struct Enumerator
+        {
+            /// <summary>
+            /// The InternableString being enumerated.
+            /// </summary>
+            private InternableString _string;
+
+            /// <summary>
+            /// Index of the current span, -1 represents the inline span.
+            /// </summary>
+            private int _spanIndex;
+
+            /// <summary>
+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.
+            /// </summary>
+            private int _charIndex;
+
+            internal Enumerator(ref InternableString str)
+            {
+                _string = str;
+                _spanIndex = -1;
+                _charIndex = -1;
+            }
+
+            /// <summary>
+            /// Returns the current character.
+            /// </summary>
+            public ref readonly char Current
+            {
+                get
+                {
+                    if (_spanIndex == -1)
+                    {
+                        return ref _string._inlineSpan[_charIndex];
+                    }
+                    ReadOnlyMemory<char> span = _string._spans![_spanIndex];
+                    return ref span.Span[_charIndex];
+                }
+            }
+
+            /// <summary>
+            /// Moves to the next character.
+            /// </summary>
+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>
+            public bool MoveNext()
+            {
+                int newCharIndex = _charIndex + 1;
+                if (_spanIndex == -1)
+                {
+                    if (newCharIndex < _string._inlineSpan.Length)
+                    {
+                        _charIndex = newCharIndex;
+                        return true;
+                    }
+                    _spanIndex = 0;
+                    newCharIndex = 0;
+                }
+
+                if (_string._spans != null)
+                {
+                    while (_spanIndex < _string._spans.Count)
+                    {
+                        if (newCharIndex < _string._spans[_spanIndex].Length)
+                        {
+                            _charIndex = newCharIndex;
+                            return true;
+                        }
+                        _spanIndex++;
+                        newCharIndex = 0;
+                    }
+                }
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// The span held by this struct, inline to be able to represent <see cref="ReadOnlySpan{char}"/>. May be empty.
+        /// </summary>
+        private readonly ReadOnlySpan<char> _inlineSpan;
+
+#if NETSTANDARD
+        /// <summary>
+        /// .NET Core does not keep a reference to the containing object in <see cref="ReadOnlySpan{char}"/>. In particular,
+        /// it cannot recover the string if the span represents one. We have to hold the reference separately to be able to
+        /// roundtrip String-&gt;InternableString-&gt;String without allocating a new String.
+        /// </summary>
+        private string? _inlineSpanString;
+#endif
+
+        /// <summary>
+        /// Additional spans held by this struct. May be null.
+        /// </summary>
+        private List<ReadOnlyMemory<char>>? _spans;
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given <see cref="ReadOnlySpan{char}"/>.
+        /// </summary>
+        /// <param name="span">The span to wrap.</param>
+        /// <remarks>
+        /// When wrapping a span representing an entire System.String, use Internable(string) for optimum performance.
+        /// </remarks>
+        internal InternableString(ReadOnlySpan<char> span)
+        {
+            _inlineSpan = span;
+            _spans = null;
+            Length = span.Length;
+#if NETSTANDARD
+            _inlineSpanString = null;
+#endif
+        }
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given string.
+        /// </summary>
+        /// <param name="str">The string to wrap, must be non-null.</param>
+        internal InternableString(string str)
+        {
+            if (str == null)
+            {
+                throw new ArgumentNullException(nameof(str));
+            }
+
+            _inlineSpan = str.AsSpan();
+            _spans = null;
+            Length = str.Length;
+#if NETSTANDARD
+            _inlineSpanString = str;
+#endif
+        }
+
+        /// <summary>
+        /// Constructs a new InternableString wrapping the given SpanBasedStringBuilder.
+        /// </summary>
+        internal InternableString(SpanBasedStringBuilder stringBuilder)
+        {
+            _inlineSpan = default(ReadOnlySpan<char>);
+            _spans = stringBuilder.Spans;
+            Length = stringBuilder.Length;
+#if NETSTANDARD
+            _inlineSpanString = null;
+#endif
+        }
+
+        /// <summary>
+        /// Gets the length of the string.
+        /// </summary>
+        public int Length { get; private set; }
+
+        /// <summary>
+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
+        /// </summary>
+        /// <returns>The enumerator.</returns>
+        public Enumerator GetEnumerator()
+        {
+            return new Enumerator(ref this);
+        }
+
+        /// <summary>
+        /// Returns true if the string is equal to another string by ordinal comparison.
+        /// </summary>
+        /// <param name="other">Another string.</param>
+        /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
+        public bool Equals(string other)
+        {
+            if (other.Length != Length)
+            {
+                return false;
+            }
+
+            if (_inlineSpan.SequenceCompareTo(other.AsSpan(0, _inlineSpan.Length)) != 0)
+            {
+                return false;
+            }
+
+            if (_spans != null)
+            {
+                int otherStart = _inlineSpan.Length;
+                foreach (ReadOnlyMemory<char> span in _spans)
+                {
+                    if (span.Span.SequenceCompareTo(other.AsSpan(otherStart, span.Length)) != 0)
+                    {
+                        return false;
+                    }
+                    otherStart += span.Length;
+                }
+            }
+            return true;
+        }
+
+        /// <summary>
+        /// Returns a System.String representing this string. Allocates memory unless this InternableString was created by wrapping a
+        /// System.String in which case the original string is returned.
+        /// </summary>
+        /// <returns>The string.</returns>
+        public unsafe string ExpensiveConvertToString()
+        {
+            if (Length == 0)
+            {
+                return string.Empty;
+            }
+
+            // Special case: if we hold just one string, we can directly return it.
+            if (_inlineSpan.Length == Length)
+            {
+#if NETSTANDARD
+                if (_inlineSpanString != null)
+                {
+                    return _inlineSpanString;
+                }
+#else
+                return _inlineSpan.ToString();
+#endif
+            }
+            if (_inlineSpan.IsEmpty && _spans?[0].Length == Length)
+            {
+                return _spans[0].ToString();
+            }
+
+            // In all other cases we create a new string instance and concatenate all spans into it. Note that while technically mutating
+            // the System.String, the technique is generally considered safe as we are the sole owners of the new object. It is important
+            // to initialize the string with the '\0' characters as this hits an optimized code path in the runtime.
+            string result = new string((char)0, Length);
+
+            fixed (char* resultPtr = result)
+            {
+                char* destPtr = resultPtr;
+                if (!_inlineSpan.IsEmpty)
+                {
+                    fixed (char* sourcePtr = _inlineSpan)
+                    {
+                        Unsafe.CopyBlockUnaligned(destPtr, sourcePtr, 2 * (uint)_inlineSpan.Length);
+                    }
+                    destPtr += _inlineSpan.Length;
+                }
+
+                if (_spans != null)
+                {
+                    foreach (ReadOnlyMemory<char> span in _spans)
+                    {
+                        if (!span.IsEmpty)
+                        {
+                            fixed (char* sourcePtr = span.Span)
+                            {
+                                Unsafe.CopyBlockUnaligned(destPtr, sourcePtr, 2 * (uint)span.Length);
+                            }
+                            destPtr += span.Length;
+                        }
+                    }
+                }
+            }
+            return result;
+        }
+
+        /// <summary>
+        /// Returns true if this InternableString wraps a System.String and the same System.String is passed as the argument.
+        /// </summary>
+        /// <param name="str">The string to compare to.</param>
+        /// <returns>True is this instance wraps the given string.</returns>
+        public bool ReferenceEquals(string str)
+        {
+            if (_inlineSpan.Length == Length)
+            {
+                return _inlineSpan == str.AsSpan();
+            }
+            if (_inlineSpan.IsEmpty && _spans?.Count == 1 && _spans[0].Length == Length)
+            {
+                return _spans[0].Span == str.AsSpan();
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Converts this instance to a System.String while first searching for a match in the intern table.
+        /// </summary>
+        /// <remarks>
+        /// May allocate depending on whether the string has already been interned.
+        /// </remarks>
+        public override string ToString()
+        {
+            return WeakStringCacheInterner.Instance.InternableToString(ref this);
+        }
+
+        /// <summary>
+        /// Implements the simple yet very decently performing djb2 hash function (xor version).
+        /// </summary>
+        /// <returns>A stable hashcode of the string represented by this instance.</returns>
+        public override unsafe int GetHashCode()
+        {
+            int hashCode = 5381;
+            fixed (char* charPtr = _inlineSpan)
+            {
+                for (int i = 0; i < _inlineSpan.Length; i++)
+                {
+                    hashCode = unchecked(hashCode * 33 ^ charPtr[i]);
+                }
+            }
+            if (_spans != null)
+            {
+                foreach (ReadOnlyMemory<char> span in _spans)
+                {
+                    fixed (char* charPtr = span.Span)
+                    {
+                        for (int i = 0; i < span.Length; i++)
+                        {
+                            hashCode = unchecked(hashCode * 33 ^ charPtr[i]);
+                        }
+                    }
+                }
+            }
+            return hashCode;
+        }
+    }
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.Simple.cs b/src/StringTools/SpanBasedStringBuilder.Simple.cs
new file mode 100644
index 00000000000..86e38c2907f
--- /dev/null
+++ b/src/StringTools/SpanBasedStringBuilder.Simple.cs
@@ -0,0 +1,153 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Text;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// A simple version of SpanBasedStringBuilder to be used on .NET Framework 3.5. Wraps a <see cref="StringBuilder"/>.
+    /// </summary>
+    public class SpanBasedStringBuilder : IDisposable
+    {
+        /// <summary>
+        /// Enumerator for the top-level struct. Enumerates characters of the string.
+        /// </summary>
+        public struct Enumerator
+        {
+            /// <summary>
+            /// The StringBuilder being enumerated.
+            /// </summary>
+            private StringBuilder _builder;
+
+            /// <summary>
+            /// Index of the current character, -1 if MoveNext has not been called yet.
+            /// </summary>
+            private int _charIndex;
+
+            public Enumerator(StringBuilder builder)
+            {
+                _builder = builder;
+                _charIndex = -1;
+            }
+
+            /// <summary>
+            /// Returns the current character.
+            /// </summary>
+            public char Current => _builder[_charIndex];
+
+            /// <summary>
+            /// Moves to the next character.
+            /// </summary>
+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>
+            public bool MoveNext()
+            {
+                int newIndex = _charIndex + 1;
+                if (newIndex < _builder.Length)
+                {
+                    _charIndex = newIndex;
+                    return true;
+                }
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// The backing StringBuilder.
+        /// </summary>
+        private StringBuilder _builder;
+
+        internal StringBuilder Builder => _builder;
+
+        /// <summary>
+        /// Constructs a new SpanBasedStringBuilder containing the given string.
+        /// </summary>
+        /// <param name="str">The string to wrap, must be non-null.</param>
+        public SpanBasedStringBuilder(string str)
+            : this()
+        {
+            if (str == null)
+            {
+                throw new ArgumentNullException(nameof(str));
+            }
+            Append(str);
+        }
+
+        /// <summary>
+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.
+        /// </summary>
+        public SpanBasedStringBuilder(int capacity = 4)
+        {
+            // Since we're using StringBuilder as the backing store in this implementation, our capacity is expressed
+            // in number of characters rather than number of spans. We use 128 as a reasonable expected multiplier to
+            // go from one to the other, i.e. by default we'll preallocate a 512-character StringBuilder.
+            _builder = new StringBuilder(capacity * 128);
+        }
+
+        /// <summary>
+        /// Gets the length of the string.
+        /// </summary>
+        public int Length => _builder.Length;
+
+        /// <summary>
+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
+        /// </summary>
+        /// <returns>The enumerator.</returns>
+        public Enumerator GetEnumerator()
+        {
+            return new Enumerator(_builder);
+        }
+
+        /// <summary>
+        /// Converts this instance to a System.String while first searching for a match in the intern table.
+        /// </summary>
+        /// <remarks>
+        /// May allocate depending on whether the string has already been interned.
+        /// </remarks>
+        public override string ToString()
+        {
+            return new InternableString(this).ToString();
+        }
+
+        /// <summary>
+        /// Releases this instance.
+        /// </summary>
+        public void Dispose()
+        {
+            Strings.ReturnSpanBasedStringBuilder(this);
+        }
+
+        #region Public mutating methods
+
+        /// <summary>
+        /// Appends a string.
+        /// </summary>
+        /// <param name="value">The string to append.</param>
+        internal void Append(string value)
+        {
+            _builder.Append(value);
+        }
+
+        /// <summary>
+        /// Appends a substring.
+        /// </summary>
+        /// <param name="value">The string to append.</param>
+        /// <param name="startIndex">The start index of the substring within <paramref name="value"/> to append.</param>
+        /// <param name="count">The length of the substring to append.</param>
+        internal void Append(string value, int startIndex, int count)
+        {
+            _builder.Append(value, startIndex, count);
+        }
+
+        /// <summary>
+        /// Clears this instance making it represent an empty string.
+        /// </summary>
+        public void Clear()
+        {
+            _builder.Length = 0;
+        }
+
+        #endregion
+    }
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.cs b/src/StringTools/SpanBasedStringBuilder.cs
new file mode 100644
index 00000000000..2d388641f85
--- /dev/null
+++ b/src/StringTools/SpanBasedStringBuilder.cs
@@ -0,0 +1,261 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// A StringBuilder replacement that keeps a list of <see cref="ReadOnlyMemory{T}"/> spans making up the intermediate string rather
+    /// than a copy of its characters. This has positive impact on both memory (no need to allocate space for the intermediate string)
+    /// and time (no need to copy characters to the intermediate string).
+    /// </summary>
+    /// <remarks>
+    /// The <see cref="ToString"/> method tries to intern the resulting string without even allocating it if it's already interned.
+    /// Use <see cref="Strings.GetSpanBasedStringBuilder"/> to take advantage of pooling to eliminate allocation overhead of this class.
+    /// </remarks>
+    public class SpanBasedStringBuilder : IDisposable
+    {
+        /// <summary>
+        /// Enumerator for the top-level class. Enumerates characters of the string.
+        /// </summary>
+        public struct Enumerator
+        {
+            /// <summary>
+            /// The spans being enumerated.
+            /// </summary>
+            private readonly List<ReadOnlyMemory<char>> _spans;
+
+            /// <summary>
+            /// Index of the current span.
+            /// </summary>
+            private int _spanIndex;
+
+            /// <summary>
+            /// Index of the current character in the current span, -1 if MoveNext has not been called yet.
+            /// </summary>
+            private int _charIndex;
+
+            internal Enumerator(List<ReadOnlyMemory<char>> spans)
+            {
+                _spans = spans;
+                _spanIndex = 0;
+                _charIndex = -1;
+            }
+
+            /// <summary>
+            /// Returns the current character.
+            /// </summary>
+            public readonly char Current
+            {
+                get
+                {
+                    ReadOnlyMemory<char> span = _spans[_spanIndex];
+                    return span.Span[_charIndex];
+                }
+            }
+
+            /// <summary>
+            /// Moves to the next character.
+            /// </summary>
+            /// <returns>True if there is another character, false if the enumerator reached the end.</returns>
+            public bool MoveNext()
+            {
+                int newCharIndex = _charIndex + 1;
+                while (_spanIndex < _spans.Count)
+                {
+                    if (newCharIndex < _spans[_spanIndex].Length)
+                    {
+                        _charIndex = newCharIndex;
+                        return true;
+                    }
+                    _spanIndex++;
+                    newCharIndex = 0;
+                }
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Spans making up the rope.
+        /// </summary>
+        private readonly List<ReadOnlyMemory<char>> _spans;
+
+        /// <summary>
+        /// Internal getter to get the list of spans out of the SpanBasedStringBuilder.
+        /// </summary>
+        internal List<ReadOnlyMemory<char>> Spans => _spans;
+
+        /// <summary>
+        /// Constructs a new SpanBasedStringBuilder containing the given string.
+        /// </summary>
+        /// <param name="str">The string to wrap, must be non-null.</param>
+        public SpanBasedStringBuilder(string str)
+            : this()
+        {
+            if (str == null)
+            {
+                throw new ArgumentNullException(nameof(str));
+            }
+            Append(str);
+        }
+
+        /// <summary>
+        /// Constructs a new empty SpanBasedStringBuilder with the given expected number of spans.
+        /// </summary>
+        public SpanBasedStringBuilder(int capacity = 4)
+        {
+            _spans = new List<ReadOnlyMemory<char>>(capacity);
+            Length = 0;
+        }
+
+        /// <summary>
+        /// Gets the length of the string.
+        /// </summary>
+        public int Length { get; private set; }
+
+        /// <summary>
+        /// Gets the capacity of the SpanBasedStringBuilder in terms of number of spans it can hold without allocating.
+        /// </summary>
+        public int Capacity => _spans.Capacity;
+
+        /// <summary>
+        /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
+        /// </summary>
+        /// <returns>The enumerator.</returns>
+        public Enumerator GetEnumerator()
+        {
+            return new Enumerator(_spans);
+        }
+
+        /// <summary>
+        /// Converts this instance to a System.String while first searching for a match in the intern table.
+        /// </summary>
+        /// <remarks>
+        /// May allocate depending on whether the string has already been interned.
+        /// </remarks>
+        public override string ToString()
+        {
+            return new InternableString(this).ToString();
+        }
+
+        /// <summary>
+        /// Releases this instance.
+        /// </summary>
+        public void Dispose()
+        {
+            Strings.ReturnSpanBasedStringBuilder(this);
+        }
+
+        #region Public mutating methods
+
+        /// <summary>
+        /// Appends a string.
+        /// </summary>
+        /// <param name="value">The string to append.</param>
+        public void Append(string value)
+        {
+            if (!string.IsNullOrEmpty(value))
+            {
+                _spans.Add(value.AsMemory());
+                Length += value.Length;
+            }
+        }
+
+        /// <summary>
+        /// Appends a substring.
+        /// </summary>
+        /// <param name="value">The string to append.</param>
+        /// <param name="startIndex">The start index of the substring within <paramref name="value"/> to append.</param>
+        /// <param name="count">The length of the substring to append.</param>
+        public void Append(string value, int startIndex, int count)
+        {
+            if (value != null)
+            {
+                if (count > 0)
+                {
+                    _spans.Add(value.AsMemory(startIndex, count));
+                    Length += count;
+                }
+            }
+            else
+            {
+                if (startIndex != 0 || count != 0)
+                {
+                    throw new ArgumentNullException(nameof(value));
+                }
+            }
+        }
+
+        /// <summary>
+        /// Removes leading white-space characters from the string.
+        /// </summary>
+        public void TrimStart()
+        {
+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)
+            {
+                ReadOnlySpan<char> span = _spans[spanIdx].Span;
+                int i = 0;
+                while (i < span.Length && char.IsWhiteSpace(span[i]))
+                {
+                    i++;
+                }
+                if (i > 0)
+                {
+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);
+                    Length -= i;
+                }
+                if (!_spans[spanIdx].IsEmpty)
+                {
+                    return;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Removes trailing white-space characters from the string.
+        /// </summary>
+        public void TrimEnd()
+        {
+            for (int spanIdx = _spans.Count - 1; spanIdx >= 0; spanIdx--)
+            {
+                ReadOnlySpan<char> span = _spans[spanIdx].Span;
+                int i = span.Length - 1;
+                while (i >= 0 && char.IsWhiteSpace(span[i]))
+                {
+                    i--;
+                }
+                if (i + 1 < span.Length)
+                {
+                    _spans[spanIdx] = _spans[spanIdx].Slice(0, i + 1);
+                    Length -= span.Length - (i + 1);
+                }
+                if (!_spans[spanIdx].IsEmpty)
+                {
+                    return;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Removes leading and trailing white-space characters from the string.
+        /// </summary>
+        public void Trim()
+        {
+            TrimStart();
+            TrimEnd();
+        }
+
+        /// <summary>
+        /// Clears this instance making it represent an empty string.
+        /// </summary>
+        public void Clear()
+        {
+            _spans.Clear();
+            Length = 0;
+        }
+
+        #endregion
+    }
+}
diff --git a/src/StringTools/StringTools.cs b/src/StringTools/StringTools.cs
new file mode 100644
index 00000000000..fbe794342b9
--- /dev/null
+++ b/src/StringTools/StringTools.cs
@@ -0,0 +1,108 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.NET.StringTools
+{
+    public static class Strings
+
+    {
+        #region Fields
+
+        /// <summary>
+        /// Per-thread instance of the SpanBasedStringBuilder, created lazily.
+        /// </summary>
+        /// <remarks>
+        /// This field serves as a per-thread one-item object pool, which is adequate for most use
+        /// cases as the builder is not expected to be held for extended periods of time.
+        /// </remarks>
+        [ThreadStatic]
+        private static SpanBasedStringBuilder? _spanBasedStringBuilder;
+
+        #endregion
+
+        #region Public methods
+
+        /// <summary>
+        /// Interns the given string, keeping only a weak reference to the returned value.
+        /// </summary>
+        /// <param name="str">The string to intern.</param>
+        /// <returns>A string equal to <paramref name="str"/>, could be the same object as <paramref name="str"/>.</returns>
+        /// <remarks>
+        /// The intern pool does not retain strong references to the strings it's holding so strings are automatically evicted
+        /// after they become unrooted. This is in contrast to <c>System.String.Intern</c> which holds strings forever.
+        /// </remarks>
+        public static string WeakIntern(string str)
+        {
+            InternableString internableString = new InternableString(str);
+            return WeakStringCacheInterner.Instance.InternableToString(ref internableString);
+        }
+
+#if !NET35
+        /// <summary>
+        /// Interns the given readonly span of characters, keeping only a weak reference to the returned value.
+        /// </summary>
+        /// <param name="str">The character span to intern.</param>
+        /// <returns>A string equal to <paramref name="str"/>, could be the result of calling ToString() on <paramref name="str"/>.</returns>
+        /// <remarks>
+        /// The intern pool does not retain strong references to the strings it's holding so strings are automatically evicted
+        /// after they become unrooted. This is in contrast to <c>System.String.Intern</c> which holds strings forever.
+        /// </remarks>
+        public static string WeakIntern(ReadOnlySpan<char> str)
+        {
+            InternableString internableString = new InternableString(str);
+            return WeakStringCacheInterner.Instance.InternableToString(ref internableString);
+        }
+#endif
+
+        /// <summary>
+        /// Returns a new or recycled <see cref="SpanBasedStringBuilder"/>.
+        /// </summary>
+        /// <returns>The SpanBasedStringBuilder.</returns>
+        /// <remarks>
+        /// Call <see cref="IDisposable.Dispose"/> on the returned instance to recycle it.
+        /// </remarks>
+        public static SpanBasedStringBuilder GetSpanBasedStringBuilder()
+        {
+            SpanBasedStringBuilder? stringBuilder = _spanBasedStringBuilder;
+            if (stringBuilder == null)
+            {
+                return new SpanBasedStringBuilder();
+            }
+            else
+            {
+                _spanBasedStringBuilder = null;
+                return stringBuilder;
+            }
+        }
+
+        /// <summary>
+        /// Enables diagnostics in the interner. Call <see cref="CreateDiagnosticReport"/> to retrieve the diagnostic data.
+        /// </summary>
+        public static void EnableDiagnostics()
+        {
+            WeakStringCacheInterner.Instance.EnableStatistics();
+        }
+
+        /// <summary>
+        /// Retrieves the diagnostic data describing the current state of the interner. Make sure to call <see cref="EnableDiagnostics"/> beforehand.
+        /// </summary>
+        public static string CreateDiagnosticReport()
+        {
+            return WeakStringCacheInterner.Instance.FormatStatistics();
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Returns a <see cref="SpanBasedStringBuilder"/> instance back to the pool if possible.
+        /// </summary>
+        /// <param name="stringBuilder">The instance to return.</param>
+        internal static void ReturnSpanBasedStringBuilder(SpanBasedStringBuilder stringBuilder)
+        {
+            stringBuilder.Clear();
+            _spanBasedStringBuilder = stringBuilder;
+        }
+    }
+}
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
new file mode 100644
index 00000000000..f3ac3633595
--- /dev/null
+++ b/src/StringTools/StringTools.csproj
@@ -0,0 +1,39 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
+    <TargetFrameworks Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(MonoBuild)' != 'true'">$(LibraryTargetFrameworks);net35</TargetFrameworks>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <WarningsAsErrors>true</WarningsAsErrors>
+    <IsPackable>true</IsPackable>
+    <LangVersion>8.0</LangVersion>
+    <PackageId>Microsoft.NET.StringTools</PackageId>
+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <Nullable>enable</Nullable>
+
+    <VersionPrefix>1.0.0</VersionPrefix>
+    <AssemblyVersion></AssemblyVersion>
+    <SemanticVersioningV1>true</SemanticVersioningV1>
+
+    <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
+    <AssemblyName Condition="'$(TargetFramework)' == 'net35'">Microsoft.NET.StringTools.net35</AssemblyName>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
+    <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
+  </ItemGroup>
+  <ItemGroup>
+    <PackageReference Include="jnm2.ReferenceAssemblies.net35" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'net35'">
+    <Compile Remove="SpanBasedStringBuilder.cs" />
+    <Compile Remove="InternableString.cs" />
+    <Compile Remove="WeakStringCache.Concurrent.cs" />
+  </ItemGroup>
+  <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
+    <Compile Remove="SpanBasedStringBuilder.Simple.cs" />
+    <Compile Remove="InternableString.Simple.cs" />
+    <Compile Remove="WeakStringCache.Locking.cs" />
+  </ItemGroup>
+</Project>
diff --git a/src/StringTools/StringTools.pkgdef b/src/StringTools/StringTools.pkgdef
new file mode 100644
index 00000000000..4ca09cf37c9
--- /dev/null
+++ b/src/StringTools/StringTools.pkgdef
@@ -0,0 +1,7 @@
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{7FBCE0AF-48AC-46AC-8841-F00D17C63A22}]
+"name"="StringTools"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\Microsoft.NET.StringTools.dll"
+"publicKeyToken"="b03f5f7f11d50a3a"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
diff --git a/src/StringTools/WeakStringCache.Concurrent.cs b/src/StringTools/WeakStringCache.Concurrent.cs
new file mode 100644
index 00000000000..6110475e946
--- /dev/null
+++ b/src/StringTools/WeakStringCache.Concurrent.cs
@@ -0,0 +1,124 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Threading;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Implements the WeakStringCache functionality on modern .NET versions where ConcurrentDictionary is available.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;
+
+        public WeakStringCache()
+        {
+            _stringsByHashCode = new ConcurrentDictionary<int, StringWeakHandle>(Environment.ProcessorCount, _initialCapacity);
+        }
+
+        /// <summary>
+        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
+        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
+        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
+        /// </summary>
+        /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <param name="cacheHit">true if match found in cache, false otherwise.</param>
+        /// <returns>A string matching the given internable.</returns>
+        public string GetOrCreateEntry(ref InternableString internable, out bool cacheHit)
+        {
+            int hashCode = internable.GetHashCode();
+
+            StringWeakHandle handle;
+            string? result;
+
+            // Get the existing handle from the cache and lock it while we're dereferencing it to prevent a race with the Scavenge
+            // method running on another thread and freeing the handle from underneath us.
+            if (_stringsByHashCode.TryGetValue(hashCode, out handle))
+            {
+                lock (handle)
+                {
+                    result = handle.GetString(ref internable);
+                    if (result != null)
+                    {
+                        cacheHit = true;
+                        return result;
+                    }
+
+                    // We have the handle but it's not referencing the right string - create the right string and store it in the handle.
+                    result = internable.ExpensiveConvertToString();
+                    handle.SetString(result);
+
+                    cacheHit = false;
+                    return result;
+                }
+            }
+
+            // We don't have the handle in the cache - create the right string, store it in the handle, and add the handle to the cache.
+            result = internable.ExpensiveConvertToString();
+
+            handle = new StringWeakHandle();
+            handle.SetString(result);
+            _stringsByHashCode.TryAdd(hashCode, handle);
+
+            // Remove unused handles if our heuristic indicates that it would be productive.
+            int scavengeThreshold = _scavengeThreshold;
+            if (_stringsByHashCode.Count >= scavengeThreshold)
+            {
+                // Before we start scavenging set _scavengeThreshold to a high value to effectively lock other threads from
+                // running Scavenge at the same time.
+                if (Interlocked.CompareExchange(ref _scavengeThreshold, int.MaxValue, scavengeThreshold) == scavengeThreshold)
+                {
+                    try
+                    {
+                        // Get rid of unused handles.
+                        Scavenge();
+                    }
+                    finally
+                    {
+                        // And do this again when the number of handles reaches double the current after-scavenge number.
+                        _scavengeThreshold = _stringsByHashCode.Count * 2;
+                    }
+                }
+            }
+
+            cacheHit = false;
+            return result;
+        }
+
+        /// <summary>
+        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
+        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
+        /// </summary>
+        public void Scavenge()
+        {
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                // We can safely dereference entry.Value as the caller guarantees that Scavenge runs only on one thread.
+                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle removedHandle))
+                {
+                    lock (removedHandle)
+                    {
+                        // Note that the removed handle may be different from the one we got from the enumerator so check again
+                        // and try to put it back if it's still in use.
+                        if (!removedHandle.IsUsed || !_stringsByHashCode.TryAdd(entry.Key, removedHandle))
+                        {
+                            removedHandle.Free();
+                        }
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        public DebugInfo GetDebugInfo()
+        {
+            return GetDebugInfoImpl();
+        }
+    }
+}
diff --git a/src/StringTools/WeakStringCache.Locking.cs b/src/StringTools/WeakStringCache.Locking.cs
new file mode 100644
index 00000000000..47daf7ee824
--- /dev/null
+++ b/src/StringTools/WeakStringCache.Locking.cs
@@ -0,0 +1,125 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Implements the WeakStringCache functionality on .NET Framework 3.5 where ConcurrentDictionary is not available.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        private readonly Dictionary<int, StringWeakHandle> _stringsByHashCode;
+
+        public WeakStringCache()
+        {
+            _stringsByHashCode = new Dictionary<int, StringWeakHandle>(_initialCapacity);
+        }
+
+        /// <summary>
+        /// Main entrypoint of this cache. Tries to look up a string that matches the given internable. If it succeeds, returns
+        /// the string and sets cacheHit to true. If the string is not found, calls ExpensiveConvertToString on the internable,
+        /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
+        /// </summary>
+        /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <returns>A string matching the given internable.</returns>
+        public string GetOrCreateEntry(ref InternableString internable, out bool cacheHit)
+        {
+            int hashCode = internable.GetHashCode();
+
+            StringWeakHandle handle;
+            string? result;
+            bool addingNewHandle = false;
+
+            lock (_stringsByHashCode)
+            {
+                if (_stringsByHashCode.TryGetValue(hashCode, out handle))
+                {
+                    result = handle.GetString(ref internable);
+                    if (result != null)
+                    {
+                        cacheHit = true;
+                        return result;
+                    }
+                }
+                else
+                {
+                    handle = new StringWeakHandle();
+                    addingNewHandle = true;
+                }
+
+                // We don't have the string in the cache - create it.
+                result = internable.ExpensiveConvertToString();
+
+                // Set the handle to reference the new string.
+                handle.SetString(result);
+
+                if (addingNewHandle)
+                {
+                    // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
+                    if (_stringsByHashCode.Count >= _scavengeThreshold)
+                    {
+                        // Get rid of unused handles.
+                        ScavengeNoLock();
+                        // And do this again when the number of handles reaches double the current after-scavenge number.
+                        _scavengeThreshold = _stringsByHashCode.Count * 2;
+                    }
+                }
+                _stringsByHashCode[hashCode] = handle;
+            }
+
+            cacheHit = false;
+            return result;
+        }
+
+        /// <summary>
+        /// Iterates over the cache and removes unused GC handles, i.e. handles that don't reference live strings.
+        /// This is expensive so try to call such that the cost is amortized to O(1) per GetOrCreateEntry() invocation.
+        /// Assumes the lock is taken by the caller.
+        /// </summary>
+        private void ScavengeNoLock()
+        {
+            List<int>? keysToRemove = null;
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                if (!entry.Value.IsUsed)
+                {
+                    entry.Value.Free();
+                    keysToRemove ??= new List<int>();
+                    keysToRemove.Add(entry.Key);
+                }
+            }
+            if (keysToRemove != null)
+            {
+                for (int i = 0; i < keysToRemove.Count; i++)
+                {
+                    _stringsByHashCode.Remove(keysToRemove[i]);
+                }
+            }
+        }
+
+        /// <summary>
+        /// Public version of ScavengeUnderLock() which takes the lock.
+        /// </summary>
+        public void Scavenge()
+        {
+            lock (_stringsByHashCode)
+            {
+                ScavengeNoLock();
+            }
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        public DebugInfo GetDebugInfo()
+        {
+            lock (_stringsByHashCode)
+            {
+                return GetDebugInfoImpl();
+            }
+        }
+    }
+}
diff --git a/src/StringTools/WeakStringCache.cs b/src/StringTools/WeakStringCache.cs
new file mode 100644
index 00000000000..cedde724390
--- /dev/null
+++ b/src/StringTools/WeakStringCache.cs
@@ -0,0 +1,141 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Runtime.InteropServices;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// A cache of weak GC handles pointing to strings. Weak GC handles are functionally equivalent to WeakReference's but have less overhead
+    /// (they're a struct as opposed to WR which is a finalizable class) at the expense of requiring manual lifetime management. As long as
+    /// a string has an ordinary strong GC root elsewhere in the process and another string with the same hashcode hasn't reused the entry,
+    /// the cache has a reference to it and can match it to an internable. When the string is collected, it is also automatically "removed"
+    /// from the cache by becoming unrecoverable from the GC handle. GC handles that do not reference a live string anymore are freed lazily.
+    /// </summary>
+    internal sealed partial class WeakStringCache : IDisposable
+    {
+        /// <summary>
+        /// Debug stats returned by GetDebugInfo().
+        /// </summary>
+        public struct DebugInfo
+        {
+            public int LiveStringCount;
+            public int CollectedStringCount;
+        }
+
+        /// <summary>
+        /// Holds a weak GC handle to a string. Shared by all strings with the same hash code and referencing the last such string we've seen.
+        /// </summary>
+        private class StringWeakHandle
+        {
+            /// <summary>
+            /// Weak GC handle to the last string of the given hashcode we've seen.
+            /// </summary>
+            public GCHandle WeakHandle;
+
+            /// <summary>
+            /// Returns true if the string referenced by the handle is still alive.
+            /// </summary>
+            public bool IsUsed => WeakHandle.Target != null;
+
+            /// <summary>
+            /// Returns the string referenced by this handle if it is equal to the given internable.
+            /// </summary>
+            /// <param name="internable">The internable describing the string we're looking for.</param>
+            /// <returns>The string matching the internable or null if the handle is referencing a collected string or the string is different.</returns>
+            public string? GetString(ref InternableString internable)
+            {
+                if (WeakHandle.IsAllocated && WeakHandle.Target is string str)
+                {
+                    if (internable.Equals(str))
+                    {
+                        return str;
+                    }
+                }
+                return null;
+            }
+
+            /// <summary>
+            /// Sets the handle to the given string. If the handle is still referencing another live string, that string is effectively forgotten.
+            /// </summary>
+            /// <param name="str">The string to set.</param>
+            public void SetString(string str)
+            {
+                if (!WeakHandle.IsAllocated)
+                {
+                    // The handle is not allocated - allocate it.
+                    WeakHandle = GCHandle.Alloc(str, GCHandleType.Weak);
+                }
+                else
+                {
+                    WeakHandle.Target = str;
+                }
+            }
+
+            /// <summary>
+            /// Frees the GC handle.
+            /// </summary>
+            public void Free()
+            {
+                WeakHandle.Free();
+            }
+        }
+
+        /// <summary>
+        /// Initial capacity of the underlying dictionary.
+        /// </summary>
+        private const int _initialCapacity = 503;
+
+        /// <summary>
+        /// The maximum size we let the collection grow before scavenging unused entries.
+        /// </summary>
+        private int _scavengeThreshold = _initialCapacity;
+
+        /// <summary>
+        /// Frees all GC handles and clears the cache.
+        /// </summary>
+        private void DisposeImpl()
+        {
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                entry.Value.Free();
+            }
+            _stringsByHashCode.Clear();
+        }
+
+        public void Dispose()
+        {
+            DisposeImpl();
+            GC.SuppressFinalize(this);
+        }
+
+        ~WeakStringCache()
+        {
+            DisposeImpl();
+        }
+
+        /// <summary>
+        /// Returns internal debug counters calculated based on the current state of the cache.
+        /// </summary>
+        private DebugInfo GetDebugInfoImpl()
+        {
+            DebugInfo debugInfo = new DebugInfo();
+
+            foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
+            {
+                if (entry.Value.IsUsed)
+                {
+                    debugInfo.LiveStringCount++;
+                }
+                else
+                {
+                    debugInfo.CollectedStringCount++;
+                }
+            }
+
+            return debugInfo;
+        }
+    }
+}
diff --git a/src/StringTools/WeakStringCacheInterner.cs b/src/StringTools/WeakStringCacheInterner.cs
new file mode 100644
index 00000000000..34366af3cfc
--- /dev/null
+++ b/src/StringTools/WeakStringCacheInterner.cs
@@ -0,0 +1,180 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using System.Text;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Implements interning based on a WeakStringCache.
+    /// </summary>
+    internal class WeakStringCacheInterner : IDisposable
+    {
+        /// <summary>
+        /// Enumerates the possible interning results.
+        /// </summary>
+        private enum InternResult
+        {
+            FoundInWeakStringCache,
+            AddedToWeakStringCache,
+        }
+
+        internal static WeakStringCacheInterner Instance = new WeakStringCacheInterner();
+
+        /// <summary>
+        /// The cache to keep strings in.
+        /// </summary>
+        private readonly WeakStringCache _weakStringCache = new WeakStringCache();
+
+#region Statistics
+        /// <summary>
+        /// Number of times the regular interning path found the string in the cache.
+        /// </summary>
+        private int _regularInternHits;
+
+        /// <summary>
+        /// Number of times the regular interning path added the string to the cache.
+        /// </summary>
+        private int _regularInternMisses;
+
+        /// <summary>
+        /// Total number of strings eliminated by interning.
+        /// </summary>
+        private int _internEliminatedStrings;
+
+        /// <summary>
+        /// Total number of chars eliminated across all strings.
+        /// </summary>
+        private int _internEliminatedChars;
+
+        /// <summary>
+        /// Maps strings that went though the interning path to the number of times they have been
+        /// seen. The higher the number the better the payoff of interning. Null if statistics
+        /// gathering has not been enabled.
+        /// </summary>
+        private Dictionary<string, int>? _internCallCountsByString;
+
+#endregion
+
+        /// <summary>
+        /// Try to intern the string.
+        /// The return value indicates the how the string was interned.
+        /// </summary>
+        private InternResult Intern(ref InternableString candidate, out string interned)
+        {
+            interned = _weakStringCache.GetOrCreateEntry(ref candidate, out bool cacheHit);
+            return cacheHit ? InternResult.FoundInWeakStringCache : InternResult.AddedToWeakStringCache;
+        }
+
+        /// <summary>
+        /// WeakIntern the given InternableString.
+        /// </summary>
+        public string InternableToString(ref InternableString candidate)
+        {
+            if (candidate.Length == 0)
+            {
+                return string.Empty;
+            }
+
+            InternResult resultForStatistics = Intern(ref candidate, out string internedString);
+#if DEBUG
+            string expectedString = candidate.ExpensiveConvertToString();
+            if (!String.Equals(internedString, expectedString))
+            {
+                throw new InvalidOperationException(String.Format("Interned string {0} should have been {1}", internedString, expectedString));
+            }
+#endif
+
+            if (_internCallCountsByString != null)
+            {
+                lock (_internCallCountsByString)
+                {
+                    switch (resultForStatistics)
+                    {
+                        case InternResult.FoundInWeakStringCache:
+                            _regularInternHits++;
+                            break;
+                        case InternResult.AddedToWeakStringCache:
+                            _regularInternMisses++;
+                            break;
+                    }
+
+                    _internCallCountsByString.TryGetValue(internedString, out int priorCount);
+                    _internCallCountsByString[internedString] = priorCount + 1;
+
+                    if (!candidate.ReferenceEquals(internedString))
+                    {
+                        // Reference changed so 'candidate' is now released and should save memory.
+                        _internEliminatedStrings++;
+                        _internEliminatedChars += candidate.Length;
+                    }
+                }
+            }
+
+            return internedString;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public void EnableStatistics()
+        {
+            _internCallCountsByString = new Dictionary<string, int>();
+        }
+
+        /// <summary>
+        /// Returns a string with human-readable statistics.
+        /// </summary>
+        public string FormatStatistics()
+        {
+            StringBuilder result = new StringBuilder(1024);
+
+            string title = "Opportunistic Intern";
+
+            if (_internCallCountsByString != null)
+            {
+                result.AppendLine(string.Format("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Hits", _regularInternHits, "hits"));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Misses", _regularInternMisses, "misses"));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings"));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars"));
+                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes"));
+                result.AppendLine("Elimination assumes that strings provided were unique objects.");
+                result.AppendLine("|---------------------------------------------------------------------------------|");
+
+                IEnumerable<string> topInternedStrings =
+                    _internCallCountsByString
+                    .OrderByDescending(kv => kv.Value * kv.Key.Length)
+                    .Where(kv => kv.Value > 1)
+                    .Take(15)
+                    .Select(kv => string.Format(CultureInfo.InvariantCulture, "({1} instances x each {2} chars)\n{0}", kv.Key, kv.Value, kv.Key.Length));
+
+                result.AppendLine(string.Format("##########Top Top Interned Strings:  \n{0} ", string.Join("\n==============\n", topInternedStrings.ToArray())));
+                result.AppendLine();
+
+                WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();
+                result.AppendLine("WeakStringCache statistics:");
+                result.AppendLine(string.Format("String count live/collected/total = {0}/{1}/{2}", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount));
+            }
+            else
+            {
+                result.Append(title);
+                result.AppendLine(" - EnableStatisticsGathering() has not been called");
+            }
+
+            return result.ToString();
+        }
+
+        /// <summary>
+        /// Releases all strings from the underlying intern table.
+        /// </summary>
+        public void Dispose()
+        {
+            _weakStringCache.Dispose();
+        }
+    }
+}
