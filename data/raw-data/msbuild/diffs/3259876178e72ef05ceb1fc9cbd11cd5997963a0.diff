diff --git a/eng/BootStrapMsBuild.props b/eng/BootStrapMsBuild.props
new file mode 100644
index 00000000000..c84fa2f5ca4
--- /dev/null
+++ b/eng/BootStrapMsBuild.props
@@ -0,0 +1,21 @@
+<Project>
+
+  <!--
+  Construct a location of MSBuild bootstrap folder - to be used for deployment and for tests
+   relying on bootstrapped MSBuild
+   -->
+
+  <PropertyGroup>
+    <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
+    <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
+    <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
+  </PropertyGroup>
+  
+  <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
+    <BootstrapBinaryDestination>$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin</BootstrapBinaryDestination>
+  </PropertyGroup>
+  
+  <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
+    <BootstrapBinaryDestination>$(BootstrapDestination)</BootstrapBinaryDestination>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/src/Analyzers.UnitTests/AssemblyInfo.cs b/src/Analyzers.UnitTests/AssemblyInfo.cs
deleted file mode 100644
index 3b5d7bbb185..00000000000
--- a/src/Analyzers.UnitTests/AssemblyInfo.cs
+++ /dev/null
@@ -1,4 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs
deleted file mode 100644
index 6863e02cbf7..00000000000
--- a/src/Analyzers.UnitTests/BuildAnalyzerConfiguration_Test.cs
+++ /dev/null
@@ -1,119 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection.Metadata;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
-using Shouldly;
-using Xunit;
-
-namespace Microsoft.Build.Analyzers.UnitTests
-{
-    public class BuildAnalyzerConfiguration_Test
-    {
-        [Fact]
-        public void CreateWithNull_ReturnsObjectWithNullValues()
-        {
-            var buildConfig = BuildAnalyzerConfiguration.Create(null);
-            buildConfig.ShouldNotBeNull();
-            buildConfig.Severity.ShouldBeNull();
-            buildConfig.IsEnabled.ShouldBeNull();
-            buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-        }
-
-        [Fact]
-        public void CreateWithEmpty_ReturnsObjectWithNullValues()
-        {
-            var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
-            buildConfig.ShouldNotBeNull();
-            buildConfig.Severity.ShouldBeNull();
-            buildConfig.IsEnabled.ShouldBeNull();
-            buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-        }
-
-        [Theory]
-        [InlineData("error", BuildAnalyzerResultSeverity.Error)]
-        [InlineData("info", BuildAnalyzerResultSeverity.Info)]
-        [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
-        [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
-        public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
-        {
-            var config = new Dictionary<string, string>()
-            {
-                { "severity" , parameter },
-            };
-            var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-            buildConfig.ShouldNotBeNull();
-            buildConfig.Severity.ShouldBe(expected);
-
-            buildConfig.IsEnabled.ShouldBeNull();
-            buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-        }
-
-        [Theory]
-        [InlineData("true", true)]
-        [InlineData("TRUE", true)]
-        [InlineData("false", false)]
-        [InlineData("FALSE", false)]
-        public void CreateBuildAnalyzerConfiguration_IsEnabled(string parameter, bool? expected)
-        {
-            var config = new Dictionary<string, string>()
-            {
-                { "isenabled" , parameter },
-            };
-
-            var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-            buildConfig.ShouldNotBeNull();
-            buildConfig.IsEnabled.ShouldBe(expected);
-
-            buildConfig.Severity.ShouldBeNull();
-            buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-        }
-
-        [Theory]
-        [InlineData("AnalyzedProjectOnly", EvaluationAnalysisScope.AnalyzedProjectOnly)]
-        [InlineData("AnalyzedProjectWithImportsFromCurrentWorkTree", EvaluationAnalysisScope.AnalyzedProjectWithImportsFromCurrentWorkTree)]
-        [InlineData("AnalyzedProjectWithImportsWithoutSdks", EvaluationAnalysisScope.AnalyzedProjectWithImportsWithoutSdks)]
-        [InlineData("AnalyzedProjectWithAllImports", EvaluationAnalysisScope.AnalyzedProjectWithAllImports)]
-        [InlineData("analyzedprojectwithallimports", EvaluationAnalysisScope.AnalyzedProjectWithAllImports)]
-        public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
-        {
-            var config = new Dictionary<string, string>()
-            {
-                { "evaluationanalysisscope" , parameter },
-            };
-
-            var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-            buildConfig.ShouldNotBeNull();
-            buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
-
-            buildConfig.IsEnabled.ShouldBeNull();
-            buildConfig.Severity.ShouldBeNull();
-        }
-
-        [Theory]
-        [InlineData("evaluationanalysisscope", "incorrec-value")]
-        [InlineData("isenabled", "incorrec-value")]
-        [InlineData("severity", "incorrec-value")]
-        public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
-        {
-            var config = new Dictionary<string, string>()
-            {
-                { key , value},
-            };
-
-            var exception = Should.Throw<BuildCheckConfigurationException>(() => {
-                BuildAnalyzerConfiguration.Create(config);
-            });
-            exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
-        }
-    }
-}
diff --git a/src/Analyzers.UnitTests/ConfigurationProvider_Tests.cs b/src/Analyzers.UnitTests/ConfigurationProvider_Tests.cs
deleted file mode 100644
index 826c040488e..00000000000
--- a/src/Analyzers.UnitTests/ConfigurationProvider_Tests.cs
+++ /dev/null
@@ -1,230 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.BuildCheck.Infrastructure;
-using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
-using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.UnitTests;
-using Shouldly;
-using Xunit;
-using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
-
-namespace Microsoft.Build.Analyzers.UnitTests
-{
-    public class ConfigurationProvider_Tests
-    {
-        [Fact]
-        public void GetRuleIdConfiguration_ReturnsEmptyConfig()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            test_key=test_value_updated
-            """);
-
-            var configurationProvider = new ConfigurationProvider();
-            var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
-
-            // empty
-            configs.ShouldBe(new Dictionary<string, string>());
-        }
-
-        [Fact]
-        public void GetRuleIdConfiguration_ReturnsConfiguration()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            build_check.rule_id.property1=value1
-            build_check.rule_id.property2=value2
-            """);
-
-            var configurationProvider = new ConfigurationProvider();
-            var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
-
-            configs.Keys.Count.ShouldBe(2);
-
-            configs.ContainsKey("property1").ShouldBeTrue();
-            configs.ContainsKey("property2").ShouldBeTrue();
-
-            configs["property2"].ShouldBe("value2");
-            configs["property1"].ShouldBe("value1");
-        }
-
-        [Fact]
-        public void GetRuleIdConfiguration_CustomConfigurationData()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            build_check.rule_id.property1=value1
-            build_check.rule_id.property2=value2
-            build_check.rule_id.isEnabled=true
-            build_check.rule_id.isEnabled2=true
-            any_other_key1=any_other_value1
-            any_other_key2=any_other_value2
-            any_other_key3=any_other_value3
-            any_other_key3=any_other_value3
-            """);
-
-            var configurationProvider = new ConfigurationProvider();
-            var customConfiguration = configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
-            var configs = customConfiguration.ConfigurationData;
-
-            configs!.Keys.Count().ShouldBe(3);
-
-            configs.ContainsKey("property1").ShouldBeTrue();
-            configs.ContainsKey("property2").ShouldBeTrue();
-            configs.ContainsKey("isenabled2").ShouldBeTrue();
-        }
-
-        [Fact]
-        public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            build_check.rule_id.isEnabled=true
-            build_check.rule_id.Severity=Error
-            build_check.rule_id.EvaluationAnalysisScope=AnalyzedProjectOnly
-            """);
-
-            var configurationProvider = new ConfigurationProvider();
-            var buildConfig = configurationProvider.GetUserConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
-
-            buildConfig.ShouldNotBeNull();
-
-            buildConfig.IsEnabled?.ShouldBeTrue();
-            buildConfig.Severity?.ShouldBe(BuildAnalyzerResultSeverity.Error);
-            buildConfig.EvaluationAnalysisScope?.ShouldBe(EvaluationAnalysisScope.AnalyzedProjectOnly);
-        }
-
-        
-        [Fact]
-        public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentValues()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            build_check.rule_id.property1=value1
-            build_check.rule_id.property2=value2
-            build_check.rule_id.isEnabled=true
-            build_check.rule_id.isEnabled2=true
-
-            [test123.csproj]
-            build_check.rule_id.property1=value2
-            build_check.rule_id.property2=value3
-            build_check.rule_id.isEnabled=true
-            build_check.rule_id.isEnabled2=tru1
-            """);
-
-            var configurationProvider = new ConfigurationProvider();
-            configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
-
-            // should not fail => configurations are the same
-            Should.Throw<BuildCheckConfigurationException>(() =>
-            {
-                configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
-            });
-        }
-
-        [Fact]
-        public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentKeys()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            build_check.rule_id.property1=value1
-            build_check.rule_id.property2=value2
-            build_check.rule_id.isEnabled2=true
-
-            [test123.csproj]
-            build_check.rule_id.property1=value1
-            build_check.rule_id.property2=value2
-            build_check.rule_id.isEnabled2=true
-            build_check.rule_id.isEnabled3=true
-            """);
-
-            var configurationProvider = new ConfigurationProvider();
-            configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
-
-            // should not fail => configurations are the same
-            Should.Throw<BuildCheckConfigurationException>(() =>
-            {
-                configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
-            });
-        }
-
-
-        [Fact]
-        public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            build_check.rule_id.property1=value1
-            build_check.rule_id.property2=value2
-            build_check.rule_id.isEnabled=true
-            build_check.rule_id.isEnabled2=true
-
-            [test123.csproj]
-            build_check.rule_id.property1=value1
-            build_check.rule_id.property2=value2
-            build_check.rule_id.isEnabled=true
-            build_check.rule_id.isEnabled2=true
-            """);
-
-            var configurationProvider = new ConfigurationProvider();
-            configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
-
-            // should fail, because the configs are the different
-            Should.NotThrow(() =>
-            {
-                configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
-            });
-        }
-    }
-}
diff --git a/src/Analyzers.UnitTests/CustomConfigurationData_Tests.cs b/src/Analyzers.UnitTests/CustomConfigurationData_Tests.cs
deleted file mode 100644
index f3b52c4645c..00000000000
--- a/src/Analyzers.UnitTests/CustomConfigurationData_Tests.cs
+++ /dev/null
@@ -1,152 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.BuildCheck.Infrastructure;
-using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
-using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.UnitTests;
-using Shouldly;
-using Xunit;
-using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
-
-namespace Microsoft.Build.Analyzers.UnitTests
-{
-    public class CustomConfigurationData_Tests
-    {
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeTrue_NullInstance()
-        {
-            var customConfigurationData1 = CustomConfigurationData.Null;
-            var customConfigurationData2 = CustomConfigurationData.Null;
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
-        }
-
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeTrue_SameInstance()
-        {
-            var customConfigurationData1 = new CustomConfigurationData("testRuleId");
-            var customConfigurationData2 = customConfigurationData1;
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
-        }
-
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeFalse_DifferentObjectType()
-        {
-            var customConfigurationData1 = new CustomConfigurationData("testRuleId");
-            var customConfigurationData2 = new object();
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
-        }
-
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeTrue_DifferentInstanceSameValues()
-        {
-            var customConfigurationData1 = new CustomConfigurationData("testRuleId");
-            var customConfigurationData2 = new CustomConfigurationData("testRuleId");
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
-        }
-
-
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataSame()
-        {
-            var config1 = new Dictionary<string, string>()
-            {
-                { "key1", "val1" }
-            };
-
-            var config2 = new Dictionary<string, string>()
-            {
-                { "key1", "val1" }
-            };
-            var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
-            var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
-        }
-
-
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferent()
-        {
-            var config = new Dictionary<string, string>()
-            {
-                { "key1", "val1" }
-            };
-            var customConfigurationData1 = new CustomConfigurationData("testRuleId", config);
-            var customConfigurationData2 = new CustomConfigurationData("testRuleId");
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
-        }
-
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentKeys()
-        {
-            var config1 = new Dictionary<string, string>()
-            {
-                { "key1", "val1" }
-            };
-
-            var config2 = new Dictionary<string, string>()
-            {
-                { "key2", "val2" }
-            };
-
-            var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
-            var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
-        }
-
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentValues()
-        {
-            var config1 = new Dictionary<string, string>()
-            {
-                { "key1", "val1" }
-            };
-
-            var config2 = new Dictionary<string, string>()
-            {
-                { "key1", "val2" }
-            };
-
-            var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
-            var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
-        }
-
-        [Fact]
-        public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataKeysOrderDiffers()
-        {
-            var config1 = new Dictionary<string, string>()
-            {
-                { "key1", "val1" },
-                { "key2", "val2" }
-            };
-
-            var config2 = new Dictionary<string, string>()
-            {
-                { "key2", "val2" },
-                { "key1", "val1" }
-            };
-
-            var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
-            var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
-
-            customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
-        }
-    }
-}
diff --git a/src/Analyzers.UnitTests/EditorConfigParser_Tests.cs b/src/Analyzers.UnitTests/EditorConfigParser_Tests.cs
deleted file mode 100644
index e39dfb6681f..00000000000
--- a/src/Analyzers.UnitTests/EditorConfigParser_Tests.cs
+++ /dev/null
@@ -1,127 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
-using Microsoft.Build.UnitTests;
-using Shouldly;
-using Xunit;
-using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
-
-
-namespace Microsoft.Build.Analyzers.UnitTests
-{
-    public class EditorConfigParser_Tests
-    {
-        [Fact]
-        public void NoSectionConfigured_ResultsEmptyResultConfig()
-        {
-            var configs = new List<EditorConfigFile>(){
-                EditorConfigFile.Parse(""""
-                    property1=value1
-""""),
-                EditorConfigFile.Parse(""""
-                    property1=value2
-                    """"),
-                EditorConfigFile.Parse(""""
-                    property1=value3
-                    """"),
-            };
-
-            var parser = new EditorConfigParser();
-            var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file");
-            mergedResult.Keys.Count.ShouldBe(0);
-        }
-
-        [Fact]
-        public void ProperOrderOfconfiguration_ClosestToTheFileShouldBeApplied()
-        {
-            var configs = new List<EditorConfigFile>(){
-                EditorConfigFile.Parse(""""
-                    [*]
-                    property1=value1
-""""),
-                EditorConfigFile.Parse(""""
-                    [*]
-                    property1=value2
-                    """"),
-                EditorConfigFile.Parse(""""
-                    [*]
-                    property1=value3
-                    """"),
-            };
-
-            var parser = new EditorConfigParser();
-            var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file.proj");
-            mergedResult.Keys.Count.ShouldBe(1);
-            mergedResult["property1"].ShouldBe("value1");
-        }
-
-        [Fact]
-        public void EditorconfigFileDiscovery_RootTrue()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
-
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            test_key=test_value_updated
-            """);
-
-
-            TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            [*.csproj]
-            test_key=should_not_be_respected_and_parsed
-            """);
-
-            var parser = new EditorConfigParser();
-            var listOfEditorConfigFile = parser.EditorConfigFileDiscovery(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj") ).ToList();
-            // should be one because root=true so we do not need to go further
-            listOfEditorConfigFile.Count.ShouldBe(1);
-            listOfEditorConfigFile[0].IsRoot.ShouldBeTrue();
-            listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
-            listOfEditorConfigFile[0].NamedSections[0].Properties["test_key"].ShouldBe("test_value_updated");
-        }
-
-        [Fact]
-        public void EditorconfigFileDiscovery_RootFalse()
-        {
-            using TestEnvironment testEnvironment = TestEnvironment.Create();
-
-            TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
-            TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
-
-            TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
-            """
-            [*.csproj]
-            test_key=test_value_updated
-            """);
-
-            TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
-            """
-            [*.csproj]
-            test_key=will_be_there
-            """);
-
-            var parser = new EditorConfigParser();
-            var listOfEditorConfigFile = parser.EditorConfigFileDiscovery(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj")).ToList();
-
-            listOfEditorConfigFile.Count.ShouldBe(2);
-            listOfEditorConfigFile[0].IsRoot.ShouldBeFalse();
-            listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
-        }
-    }
-}
diff --git a/src/Analyzers.UnitTests/EditorConfig_Tests.cs b/src/Analyzers.UnitTests/EditorConfig_Tests.cs
deleted file mode 100644
index 71b367cc7a0..00000000000
--- a/src/Analyzers.UnitTests/EditorConfig_Tests.cs
+++ /dev/null
@@ -1,1082 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
-using Microsoft.Build.UnitTests;
-using Xunit;
-using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
-
-#nullable disable
-
-namespace Microsoft.Build.Analyzers.UnitTests
-{
-    public class EditorConfig_Tests
-    {
-
-        #region AssertEqualityComparer<T>
-        private sealed class AssertEqualityComparer<T> : IEqualityComparer<T>
-        {
-            public static readonly IEqualityComparer<T> Instance = new AssertEqualityComparer<T>();
-
-            private static bool CanBeNull()
-            {
-                var type = typeof(T);
-                return !type.GetTypeInfo().IsValueType ||
-                    (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
-            }
-
-            public static bool IsNull(T @object)
-            {
-                if (!CanBeNull())
-                {
-                    return false;
-                }
-
-                return object.Equals(@object, default(T));
-            }
-
-            public static bool Equals(T left, T right)
-            {
-                return Instance.Equals(left, right);
-            }
-
-            bool IEqualityComparer<T>.Equals(T x, T y)
-            {
-                if (CanBeNull())
-                {
-                    if (object.Equals(x, default(T)))
-                    {
-                        return object.Equals(y, default(T));
-                    }
-
-                    if (object.Equals(y, default(T)))
-                    {
-                        return false;
-                    }
-                }
-
-                if (x.GetType() != y.GetType())
-                {
-                    return false;
-                }
-
-                if (x is IEquatable<T> equatable)
-                {
-                    return equatable.Equals(y);
-                }
-
-                if (x is IComparable<T> comparableT)
-                {
-                    return comparableT.CompareTo(y) == 0;
-                }
-
-                if (x is IComparable comparable)
-                {
-                    return comparable.CompareTo(y) == 0;
-                }
-
-                var enumerableX = x as IEnumerable;
-                var enumerableY = y as IEnumerable;
-
-                if (enumerableX != null && enumerableY != null)
-                {
-                    var enumeratorX = enumerableX.GetEnumerator();
-                    var enumeratorY = enumerableY.GetEnumerator();
-
-                    while (true)
-                    {
-                        bool hasNextX = enumeratorX.MoveNext();
-                        bool hasNextY = enumeratorY.MoveNext();
-
-                        if (!hasNextX || !hasNextY)
-                        {
-                            return hasNextX == hasNextY;
-                        }
-
-                        if (!Equals(enumeratorX.Current, enumeratorY.Current))
-                        {
-                            return false;
-                        }
-                    }
-                }
-
-                return object.Equals(x, y);
-            }
-
-            int IEqualityComparer<T>.GetHashCode(T obj)
-            {
-                throw new NotImplementedException();
-            }
-        }
-
-        #endregion
-
-        // Section Matchin Test cases: https://github.com/dotnet/roslyn/blob/ba163e712b01358a217065eec8a4a82f94a7efd5/src/Compilers/Core/CodeAnalysisTest/Analyzers/AnalyzerConfigTests.cs#L337
-        #region Section Matching Tests
-        [Fact]
-        public void SimpleNameMatch()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc").Value;
-            Assert.Equal("^.*/abc$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc"));
-            Assert.False(matcher.IsMatch("/aabc"));
-            Assert.False(matcher.IsMatch("/ abc"));
-            Assert.False(matcher.IsMatch("/cabc"));
-        }
-
-        [Fact]
-        public void StarOnlyMatch()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("*").Value;
-            Assert.Equal("^.*/[^/]*$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc"));
-            Assert.True(matcher.IsMatch("/123"));
-            Assert.True(matcher.IsMatch("/abc/123"));
-        }
-
-        [Fact]
-        public void StarNameMatch()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.cs").Value;
-            Assert.Equal("^.*/[^/]*\\.cs$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc.cs"));
-            Assert.True(matcher.IsMatch("/123.cs"));
-            Assert.True(matcher.IsMatch("/dir/subpath.cs"));
-            // Only '/' is defined as a directory separator, so the caller
-            // is responsible for converting any other machine directory
-            // separators to '/' before matching
-            Assert.True(matcher.IsMatch("/dir\\subpath.cs"));
-
-            Assert.False(matcher.IsMatch("/abc.vb"));
-        }
-
-        [Fact]
-        public void StarStarNameMatch()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("**.cs").Value;
-            Assert.Equal("^.*/.*\\.cs$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc.cs"));
-            Assert.True(matcher.IsMatch("/dir/subpath.cs"));
-        }
-
-        [Fact]
-        public void EscapeDot()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("...").Value;
-            Assert.Equal("^.*/\\.\\.\\.$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/..."));
-            Assert.True(matcher.IsMatch("/subdir/..."));
-            Assert.False(matcher.IsMatch("/aaa"));
-            Assert.False(matcher.IsMatch("/???"));
-            Assert.False(matcher.IsMatch("/abc"));
-        }
-
-        [Fact]
-        public void EndBackslashMatch()
-        {
-            SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc\\");
-            Assert.Null(matcher);
-        }
-
-        [Fact]
-        public void QuestionMatch()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab?def").Value;
-            Assert.Equal("^.*/ab.def$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abcdef"));
-            Assert.True(matcher.IsMatch("/ab?def"));
-            Assert.True(matcher.IsMatch("/abzdef"));
-            Assert.True(matcher.IsMatch("/ab/def"));
-            Assert.True(matcher.IsMatch("/ab\\def"));
-        }
-
-        [Fact]
-        public void LiteralBackslash()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab\\\\c").Value;
-            Assert.Equal("^.*/ab\\\\c$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/ab\\c"));
-            Assert.False(matcher.IsMatch("/ab/c"));
-            Assert.False(matcher.IsMatch("/ab\\\\c"));
-        }
-
-        [Fact]
-        public void LiteralStars()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\***\\*\\**").Value;
-            Assert.Equal("^.*/\\*.*\\*\\*[^/]*$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/*ab/cd**efg*"));
-            Assert.False(matcher.IsMatch("/ab/cd**efg*"));
-            Assert.False(matcher.IsMatch("/*ab/cd*efg*"));
-            Assert.False(matcher.IsMatch("/*ab/cd**ef/gh"));
-        }
-
-        [Fact]
-        public void LiteralQuestions()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\??\\?*\\??").Value;
-            Assert.Equal("^.*/\\?.\\?[^/]*\\?.$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/?a?cde?f"));
-            Assert.True(matcher.IsMatch("/???????f"));
-            Assert.False(matcher.IsMatch("/aaaaaaaa"));
-            Assert.False(matcher.IsMatch("/aa?cde?f"));
-            Assert.False(matcher.IsMatch("/?a?cdexf"));
-            Assert.False(matcher.IsMatch("/?axcde?f"));
-        }
-
-        [Fact]
-        public void LiteralBraces()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\{\\}def").Value;
-            Assert.Equal(@"^.*/abc\{}def$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc{}def"));
-            Assert.True(matcher.IsMatch("/subdir/abc{}def"));
-            Assert.False(matcher.IsMatch("/abcdef"));
-            Assert.False(matcher.IsMatch("/abc}{def"));
-        }
-
-        [Fact]
-        public void LiteralComma()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\,def").Value;
-            Assert.Equal("^.*/abc,def$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc,def"));
-            Assert.True(matcher.IsMatch("/subdir/abc,def"));
-            Assert.False(matcher.IsMatch("/abcdef"));
-            Assert.False(matcher.IsMatch("/abc\\,def"));
-            Assert.False(matcher.IsMatch("/abc`def"));
-        }
-
-        [Fact]
-        public void SimpleChoice()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.{cs,vb,fs}").Value;
-            Assert.Equal("^.*/[^/]*\\.(?:cs|vb|fs)$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc.cs"));
-            Assert.True(matcher.IsMatch("/abc.vb"));
-            Assert.True(matcher.IsMatch("/abc.fs"));
-            Assert.True(matcher.IsMatch("/subdir/abc.cs"));
-            Assert.True(matcher.IsMatch("/subdir/abc.vb"));
-            Assert.True(matcher.IsMatch("/subdir/abc.fs"));
-
-            Assert.False(matcher.IsMatch("/abcxcs"));
-            Assert.False(matcher.IsMatch("/abcxvb"));
-            Assert.False(matcher.IsMatch("/abcxfs"));
-            Assert.False(matcher.IsMatch("/subdir/abcxcs"));
-            Assert.False(matcher.IsMatch("/subdir/abcxcb"));
-            Assert.False(matcher.IsMatch("/subdir/abcxcs"));
-        }
-
-        [Fact]
-        public void OneChoiceHasSlashes()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs,subdir/test.vb}").Value;
-            // This is an interesting case that may be counterintuitive.  A reasonable understanding
-            // of the section matching could interpret the choice as generating multiple identical
-            // sections, so [{a, b, c}] would be equivalent to [a] ... [b] ... [c] with all of the
-            // same properties in each section. This is somewhat true, but the rules of how the matching
-            // prefixes are constructed violate this assumption because they are defined as whether or
-            // not a section contains a slash, not whether any of the choices contain a slash. So while
-            // [*.cs] usually translates into '**/*.cs' because it contains no slashes, the slashes in
-            // the second choice make this into '/*.cs', effectively matching only files in the root
-            // directory of the match, instead of all subdirectories.
-            Assert.Equal("^/(?:[^/]*\\.cs|subdir/test\\.vb)$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/test.cs"));
-            Assert.True(matcher.IsMatch("/subdir/test.vb"));
-
-            Assert.False(matcher.IsMatch("/subdir/test.cs"));
-            Assert.False(matcher.IsMatch("/subdir/subdir/test.vb"));
-            Assert.False(matcher.IsMatch("/test.vb"));
-        }
-
-        [Fact]
-        public void EmptyChoice()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("{}").Value;
-            Assert.Equal("^.*/(?:)$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/"));
-            Assert.True(matcher.IsMatch("/subdir/"));
-            Assert.False(matcher.IsMatch("/."));
-            Assert.False(matcher.IsMatch("/anything"));
-        }
-
-        [Fact]
-        public void SingleChoice()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs}").Value;
-            Assert.Equal("^.*/(?:[^/]*\\.cs)$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/test.cs"));
-            Assert.True(matcher.IsMatch("/subdir/test.cs"));
-            Assert.False(matcher.IsMatch("test.vb"));
-            Assert.False(matcher.IsMatch("testxcs"));
-        }
-
-        [Fact]
-        public void UnmatchedBraces()
-        {
-            SectionNameMatcher? matcher = TryCreateSectionNameMatcher("{{{{}}");
-            Assert.Null(matcher);
-        }
-
-        [Fact]
-        public void CommaOutsideBraces()
-        {
-            SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc,def");
-            Assert.Null(matcher);
-        }
-
-        [Fact]
-        public void RecursiveChoice()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("{test{.cs,.vb},other.{a{bb,cc}}}").Value;
-            Assert.Equal("^.*/(?:test(?:\\.cs|\\.vb)|other\\.(?:a(?:bb|cc)))$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/test.cs"));
-            Assert.True(matcher.IsMatch("/test.vb"));
-            Assert.True(matcher.IsMatch("/subdir/test.cs"));
-            Assert.True(matcher.IsMatch("/subdir/test.vb"));
-            Assert.True(matcher.IsMatch("/other.abb"));
-            Assert.True(matcher.IsMatch("/other.acc"));
-
-            Assert.False(matcher.IsMatch("/test.fs"));
-            Assert.False(matcher.IsMatch("/other.bbb"));
-            Assert.False(matcher.IsMatch("/other.ccc"));
-            Assert.False(matcher.IsMatch("/subdir/other.bbb"));
-            Assert.False(matcher.IsMatch("/subdir/other.ccc"));
-        }
-
-        [Fact]
-        public void DashChoice()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{-}cd{-,}ef").Value;
-            Assert.Equal("^.*/ab(?:-)cd(?:-|)ef$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/ab-cd-ef"));
-            Assert.True(matcher.IsMatch("/ab-cdef"));
-
-            Assert.False(matcher.IsMatch("/abcdef"));
-            Assert.False(matcher.IsMatch("/ab--cd-ef"));
-            Assert.False(matcher.IsMatch("/ab--cd--ef"));
-        }
-
-        [Fact]
-        public void MiddleMatch()
-        {
-            SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{cs,vb,fs}cd").Value;
-            Assert.Equal("^.*/ab(?:cs|vb|fs)cd$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abcscd"));
-            Assert.True(matcher.IsMatch("/abvbcd"));
-            Assert.True(matcher.IsMatch("/abfscd"));
-
-            Assert.False(matcher.IsMatch("/abcs"));
-            Assert.False(matcher.IsMatch("/abcd"));
-            Assert.False(matcher.IsMatch("/vbcd"));
-        }
-
-        private static IEnumerable<(string, string)> RangeAndInverse(string s1, string s2)
-        {
-            yield return (s1, s2);
-            yield return (s2, s1);
-        }
-
-        [Fact]
-        public void NumberMatch()
-        {
-            foreach (var (i1, i2) in RangeAndInverse("0", "10"))
-            {
-                var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
-
-                Assert.True(matcher.IsMatch("/0"));
-                Assert.True(matcher.IsMatch("/10"));
-                Assert.True(matcher.IsMatch("/5"));
-                Assert.True(matcher.IsMatch("/000005"));
-                Assert.False(matcher.IsMatch("/-1"));
-                Assert.False(matcher.IsMatch("/-00000001"));
-                Assert.False(matcher.IsMatch("/11"));
-            }
-        }
-
-        [Fact]
-        public void NumberMatchNegativeRange()
-        {
-            foreach (var (i1, i2) in RangeAndInverse("-10", "0"))
-            {
-                var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
-
-                Assert.True(matcher.IsMatch("/0"));
-                Assert.True(matcher.IsMatch("/-10"));
-                Assert.True(matcher.IsMatch("/-5"));
-                Assert.False(matcher.IsMatch("/1"));
-                Assert.False(matcher.IsMatch("/-11"));
-                Assert.False(matcher.IsMatch("/--0"));
-            }
-        }
-
-        [Fact]
-        public void NumberMatchNegToPos()
-        {
-            foreach (var (i1, i2) in RangeAndInverse("-10", "10"))
-            {
-                var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
-
-                Assert.True(matcher.IsMatch("/0"));
-                Assert.True(matcher.IsMatch("/-5"));
-                Assert.True(matcher.IsMatch("/5"));
-                Assert.True(matcher.IsMatch("/-10"));
-                Assert.True(matcher.IsMatch("/10"));
-                Assert.False(matcher.IsMatch("/-11"));
-                Assert.False(matcher.IsMatch("/11"));
-                Assert.False(matcher.IsMatch("/--0"));
-            }
-        }
-
-        [Fact]
-        public void MultipleNumberRanges()
-        {
-            foreach (var matchString in new[] { "a{-10..0}b{0..10}", "a{0..-10}b{10..0}" })
-            {
-                var matcher = TryCreateSectionNameMatcher(matchString).Value;
-
-                Assert.True(matcher.IsMatch("/a0b0"));
-                Assert.True(matcher.IsMatch("/a-5b0"));
-                Assert.True(matcher.IsMatch("/a-5b5"));
-                Assert.True(matcher.IsMatch("/a-5b10"));
-                Assert.True(matcher.IsMatch("/a-10b10"));
-                Assert.True(matcher.IsMatch("/a-10b0"));
-                Assert.True(matcher.IsMatch("/a-0b0"));
-                Assert.True(matcher.IsMatch("/a-0b-0"));
-
-                Assert.False(matcher.IsMatch("/a-11b10"));
-                Assert.False(matcher.IsMatch("/a-11b10"));
-                Assert.False(matcher.IsMatch("/a-10b11"));
-            }
-        }
-
-        [Fact]
-        public void BadNumberRanges()
-        {
-            var matcherOpt = TryCreateSectionNameMatcher("{0..");
-
-            Assert.Null(matcherOpt);
-
-            var matcher = TryCreateSectionNameMatcher("{0..}").Value;
-
-            Assert.True(matcher.IsMatch("/0.."));
-            Assert.False(matcher.IsMatch("/0"));
-            Assert.False(matcher.IsMatch("/0."));
-            Assert.False(matcher.IsMatch("/0abc"));
-
-            matcher = TryCreateSectionNameMatcher("{0..A}").Value;
-            Assert.True(matcher.IsMatch("/0..A"));
-            Assert.False(matcher.IsMatch("/0"));
-            Assert.False(matcher.IsMatch("/0abc"));
-
-            // The reference implementation uses atoi here so we can presume
-            // numbers out of range of Int32 are not well supported
-            matcherOpt = TryCreateSectionNameMatcher($"{{0..{UInt32.MaxValue}}}");
-
-            Assert.Null(matcherOpt);
-        }
-
-        [Fact]
-        public void CharacterClassSimple()
-        {
-            var matcher = TryCreateSectionNameMatcher("*.[cf]s").Value;
-            Assert.Equal(@"^.*/[^/]*\.[cf]s$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc.cs"));
-            Assert.True(matcher.IsMatch("/abc.fs"));
-            Assert.False(matcher.IsMatch("/abc.vs"));
-        }
-
-        [Fact]
-        public void CharacterClassNegative()
-        {
-            var matcher = TryCreateSectionNameMatcher("*.[!cf]s").Value;
-            Assert.Equal(@"^.*/[^/]*\.[^cf]s$", matcher.Regex.ToString());
-
-            Assert.False(matcher.IsMatch("/abc.cs"));
-            Assert.False(matcher.IsMatch("/abc.fs"));
-            Assert.True(matcher.IsMatch("/abc.vs"));
-            Assert.True(matcher.IsMatch("/abc.xs"));
-            Assert.False(matcher.IsMatch("/abc.vxs"));
-        }
-
-        [Fact]
-        public void CharacterClassCaret()
-        {
-            var matcher = TryCreateSectionNameMatcher("*.[^cf]s").Value;
-            Assert.Equal(@"^.*/[^/]*\.[\^cf]s$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/abc.cs"));
-            Assert.True(matcher.IsMatch("/abc.fs"));
-            Assert.True(matcher.IsMatch("/abc.^s"));
-            Assert.False(matcher.IsMatch("/abc.vs"));
-            Assert.False(matcher.IsMatch("/abc.xs"));
-            Assert.False(matcher.IsMatch("/abc.vxs"));
-        }
-
-        [Fact]
-        public void CharacterClassRange()
-        {
-            var matcher = TryCreateSectionNameMatcher("[0-9]x").Value;
-            Assert.Equal("^.*/[0-9]x$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/0x"));
-            Assert.True(matcher.IsMatch("/1x"));
-            Assert.True(matcher.IsMatch("/9x"));
-            Assert.False(matcher.IsMatch("/yx"));
-            Assert.False(matcher.IsMatch("/00x"));
-        }
-
-        [Fact]
-        public void CharacterClassNegativeRange()
-        {
-            var matcher = TryCreateSectionNameMatcher("[!0-9]x").Value;
-            Assert.Equal("^.*/[^0-9]x$", matcher.Regex.ToString());
-
-            Assert.False(matcher.IsMatch("/0x"));
-            Assert.False(matcher.IsMatch("/1x"));
-            Assert.False(matcher.IsMatch("/9x"));
-            Assert.True(matcher.IsMatch("/yx"));
-            Assert.False(matcher.IsMatch("/00x"));
-        }
-
-        [Fact]
-        public void CharacterClassRangeAndChoice()
-        {
-            var matcher = TryCreateSectionNameMatcher("[ab0-9]x").Value;
-            Assert.Equal("^.*/[ab0-9]x$", matcher.Regex.ToString());
-
-            Assert.True(matcher.IsMatch("/ax"));
-            Assert.True(matcher.IsMatch("/bx"));
-            Assert.True(matcher.IsMatch("/0x"));
-            Assert.True(matcher.IsMatch("/1x"));
-            Assert.True(matcher.IsMatch("/9x"));
-            Assert.False(matcher.IsMatch("/yx"));
-            Assert.False(matcher.IsMatch("/0ax"));
-        }
-
-        [Fact]
-        public void CharacterClassOpenEnded()
-        {
-            var matcher = TryCreateSectionNameMatcher("[");
-            Assert.Null(matcher);
-        }
-
-        [Fact]
-        public void CharacterClassEscapedOpenEnded()
-        {
-            var matcher = TryCreateSectionNameMatcher(@"[\]");
-            Assert.Null(matcher);
-        }
-
-        [Fact]
-        public void CharacterClassEscapeAtEnd()
-        {
-            var matcher = TryCreateSectionNameMatcher(@"[\");
-            Assert.Null(matcher);
-        }
-
-        [Fact]
-        public void CharacterClassOpenBracketInside()
-        {
-            var matcher = TryCreateSectionNameMatcher(@"[[a]bc").Value;
-
-            Assert.True(matcher.IsMatch("/abc"));
-            Assert.True(matcher.IsMatch("/[bc"));
-            Assert.False(matcher.IsMatch("/ab"));
-            Assert.False(matcher.IsMatch("/[b"));
-            Assert.False(matcher.IsMatch("/bc"));
-            Assert.False(matcher.IsMatch("/ac"));
-            Assert.False(matcher.IsMatch("/[c"));
-
-            Assert.Equal(@"^.*/[\[a]bc$", matcher.Regex.ToString());
-        }
-
-        [Fact]
-        public void CharacterClassStartingDash()
-        {
-            var matcher = TryCreateSectionNameMatcher(@"[-ac]bd").Value;
-
-            Assert.True(matcher.IsMatch("/abd"));
-            Assert.True(matcher.IsMatch("/cbd"));
-            Assert.True(matcher.IsMatch("/-bd"));
-            Assert.False(matcher.IsMatch("/bbd"));
-            Assert.False(matcher.IsMatch("/-cd"));
-            Assert.False(matcher.IsMatch("/bcd"));
-
-            Assert.Equal(@"^.*/[-ac]bd$", matcher.Regex.ToString());
-        }
-
-        [Fact]
-        public void CharacterClassEndingDash()
-        {
-            var matcher = TryCreateSectionNameMatcher(@"[ac-]bd").Value;
-
-            Assert.True(matcher.IsMatch("/abd"));
-            Assert.True(matcher.IsMatch("/cbd"));
-            Assert.True(matcher.IsMatch("/-bd"));
-            Assert.False(matcher.IsMatch("/bbd"));
-            Assert.False(matcher.IsMatch("/-cd"));
-            Assert.False(matcher.IsMatch("/bcd"));
-
-            Assert.Equal(@"^.*/[ac-]bd$", matcher.Regex.ToString());
-        }
-
-        [Fact]
-        public void CharacterClassEndBracketAfter()
-        {
-            var matcher = TryCreateSectionNameMatcher(@"[ab]]cd").Value;
-
-            Assert.True(matcher.IsMatch("/a]cd"));
-            Assert.True(matcher.IsMatch("/b]cd"));
-            Assert.False(matcher.IsMatch("/acd"));
-            Assert.False(matcher.IsMatch("/bcd"));
-            Assert.False(matcher.IsMatch("/acd"));
-
-            Assert.Equal(@"^.*/[ab]]cd$", matcher.Regex.ToString());
-        }
-
-        [Fact]
-        public void CharacterClassEscapeBackslash()
-        {
-            var matcher = TryCreateSectionNameMatcher(@"[ab\\]cd").Value;
-
-            Assert.True(matcher.IsMatch("/acd"));
-            Assert.True(matcher.IsMatch("/bcd"));
-            Assert.True(matcher.IsMatch("/\\cd"));
-            Assert.False(matcher.IsMatch("/dcd"));
-            Assert.False(matcher.IsMatch("/\\\\cd"));
-            Assert.False(matcher.IsMatch("/cd"));
-
-            Assert.Equal(@"^.*/[ab\\]cd$", matcher.Regex.ToString());
-        }
-
-        [Fact]
-        public void EscapeOpenBracket()
-        {
-            var matcher = TryCreateSectionNameMatcher(@"ab\[cd").Value;
-
-            Assert.True(matcher.IsMatch("/ab[cd"));
-            Assert.False(matcher.IsMatch("/ab[[cd"));
-            Assert.False(matcher.IsMatch("/abc"));
-            Assert.False(matcher.IsMatch("/abd"));
-
-            Assert.Equal(@"^.*/ab\[cd$", matcher.Regex.ToString());
-        }
-        #endregion
-
-        #region Parsing Tests
-
-        private static void SetEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null, string message = null)
-        {
-            var expectedSet = new HashSet<T>(expected, comparer);
-            var result = expected.Count() == actual.Count() && expectedSet.SetEquals(actual);
-            Assert.True(result, message);
-        }
-
-        private static void Equal<T>(
-            IEnumerable<T> expected,
-            IEnumerable<T> actual,
-            IEqualityComparer<T> comparer = null,
-            string message = null)
-        {
-            if (expected == null)
-            {
-                Assert.Null(actual);
-            }
-            else
-            {
-                Assert.NotNull(actual);
-            }
-
-            if (SequenceEqual(expected, actual, comparer))
-            {
-                return;
-            }
-
-            Assert.True(false, message);
-        }
-
-        private static bool SequenceEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null)
-        {
-            if (ReferenceEquals(expected, actual))
-            {
-                return true;
-            }
-
-            var enumerator1 = expected.GetEnumerator();
-            var enumerator2 = actual.GetEnumerator();
-
-            while (true)
-            {
-                var hasNext1 = enumerator1.MoveNext();
-                var hasNext2 = enumerator2.MoveNext();
-
-                if (hasNext1 != hasNext2)
-                {
-                    return false;
-                }
-
-                if (!hasNext1)
-                {
-                    break;
-                }
-
-                var value1 = enumerator1.Current;
-                var value2 = enumerator2.Current;
-
-                if (!(comparer != null ? comparer.Equals(value1, value2) : AssertEqualityComparer<T>.Equals(value1, value2)))
-                {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        public static KeyValuePair<K, V> Create<K, V>(K key, V value)
-        {
-            return new KeyValuePair<K, V>(key, value);
-        }
-
-        [Fact]
-        public void SimpleCase()
-        {
-            var config = EditorConfigFile.Parse("""
-root = true
-
-# Comment1
-# Comment2
-##################################
-
-my_global_prop = my_global_val
-
-[*.cs]
-my_prop = my_val
-""");
-            Assert.Equal("", config.GlobalSection.Name);
-            var properties = config.GlobalSection.Properties;
-
-            SetEqual(
-                new[] { Create("my_global_prop", "my_global_val") ,
-                        Create("root", "true") },
-                properties);
-
-            var namedSections = config.NamedSections;
-            Assert.Equal("*.cs", namedSections[0].Name);
-            SetEqual(
-                new[] { Create("my_prop", "my_val") },
-                namedSections[0].Properties);
-            
-            Assert.True(config.IsRoot);
-        }
-
-        
-        [Fact]
-        // [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
-        public void ConfigWithEscapedValues()
-        {
-            var config = EditorConfigFile.Parse(@"is_global = true
-
-[c:/\{f\*i\?le1\}.cs]
-build_metadata.Compile.ToRetrieve = abc123
-
-[c:/f\,ile\#2.cs]
-build_metadata.Compile.ToRetrieve = def456
-
-[c:/f\;i\!le\[3\].cs]
-build_metadata.Compile.ToRetrieve = ghi789
-");
-
-            var namedSections = config.NamedSections;
-            Assert.Equal("c:/\\{f\\*i\\?le1\\}.cs", namedSections[0].Name);
-            Equal(
-                new[] { Create("build_metadata.compile.toretrieve", "abc123") },
-                namedSections[0].Properties);
-
-            Assert.Equal("c:/f\\,ile\\#2.cs", namedSections[1].Name);
-            Equal(
-                new[] { Create("build_metadata.compile.toretrieve", "def456") },
-                namedSections[1].Properties);
-
-            Assert.Equal("c:/f\\;i\\!le\\[3\\].cs", namedSections[2].Name);
-            Equal(
-                new[] { Create("build_metadata.compile.toretrieve", "ghi789") },
-                namedSections[2].Properties);
-        }
-
-        /*
-        [Fact]
-        [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
-        public void CanGetSectionsWithSpecialCharacters()
-        {
-            var config = ParseConfigFile(@"is_global = true
-
-[/home/foo/src/\{releaseid\}.cs]
-build_metadata.Compile.ToRetrieve = abc123
-
-[/home/foo/src/Pages/\#foo/HomePage.cs]
-build_metadata.Compile.ToRetrieve = def456
-");
-
-            var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
-
-            var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
-            Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
-
-            sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
-            Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
-        }*/
-
-        [Fact]
-        public void MissingClosingBracket()
-        {
-            var config = EditorConfigFile.Parse(@"
-[*.cs
-my_prop = my_val");
-            var properties = config.GlobalSection.Properties;
-            SetEqual(
-                new[] { Create("my_prop", "my_val") },
-                properties);
-
-            Assert.Equal(0, config.NamedSections.Length);
-        }
-
-        
-        [Fact]
-        public void EmptySection()
-        {
-            var config = EditorConfigFile.Parse(@"
-[]
-my_prop = my_val");
-
-            var properties = config.GlobalSection.Properties;
-            Assert.Equal(new[] { Create("my_prop", "my_val") }, properties);
-            Assert.Equal(0, config.NamedSections.Length);
-        }
-
-        
-        [Fact]
-        public void CaseInsensitivePropKey()
-        {
-            var config = EditorConfigFile.Parse(@"
-my_PROP = my_VAL");
-            var properties = config.GlobalSection.Properties;
-
-            Assert.True(properties.TryGetValue("my_PrOp", out var val));
-            Assert.Equal("my_VAL", val);
-            Assert.Equal("my_prop", properties.Keys.Single());
-        }
-
-        // there is no reversed keys support for msbuild
-        /*[Fact]
-        public void NonReservedKeyPreservedCaseVal()
-        {
-            var config = ParseConfigFile(string.Join(Environment.NewLine,
-                AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
-            AssertEx.SetEqual(
-                AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
-                config.GlobalSection.Properties);
-        }*/
-
-
-        [Fact]
-        public void DuplicateKeys()
-        {
-            var config = EditorConfigFile.Parse(@"
-my_prop = my_val
-my_prop = my_other_val");
-
-            var properties = config.GlobalSection.Properties;
-            Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
-        }
-
-        
-        [Fact]
-        public void DuplicateKeysCasing()
-        {
-            var config = EditorConfigFile.Parse(@"
-my_prop = my_val
-my_PROP = my_other_val");
-
-            var properties = config.GlobalSection.Properties;
-            Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
-        }
-
-        
-        [Fact]
-        public void MissingKey()
-        {
-            var config = EditorConfigFile.Parse(@"
-= my_val1
-my_prop = my_val2");
-
-            var properties = config.GlobalSection.Properties;
-            SetEqual(
-                new[] { Create("my_prop", "my_val2") },
-                properties);
-        }
-
-        
-
-        [Fact]
-        public void MissingVal()
-        {
-            var config = EditorConfigFile.Parse(@"
-my_prop1 =
-my_prop2 = my_val");
-
-            var properties = config.GlobalSection.Properties;
-            SetEqual(
-                new[] { Create("my_prop1", ""),
-                        Create("my_prop2", "my_val") },
-                properties);
-        }
-
-        
-        [Fact]
-        public void SpacesInProperties()
-        {
-            var config = EditorConfigFile.Parse(@"
-my prop1 = my_val1
-my_prop2 = my val2");
-
-            var properties = config.GlobalSection.Properties;
-            SetEqual(
-                new[] { Create("my_prop2", "my val2") },
-                properties);
-        }
-
-        
-        [Fact]
-        public void EndOfLineComments()
-        {
-            var config = EditorConfigFile.Parse(@"
-my_prop2 = my val2 # Comment");
-
-            var properties = config.GlobalSection.Properties;
-            SetEqual(
-                new[] { Create("my_prop2", "my val2") },
-                properties);
-        }
-        
-        [Fact]
-        public void SymbolsStartKeys()
-        {
-            var config = EditorConfigFile.Parse(@"
-@!$abc = my_val1
-@!$\# = my_val2");
-
-            var properties = config.GlobalSection.Properties;
-            Assert.Equal(0, properties.Count);
-        }
-
-        
-        [Fact]
-        public void EqualsAndColon()
-        {
-            var config = EditorConfigFile.Parse(@"
-my:key1 = my_val
-my_key2 = my:val");
-
-            var properties = config.GlobalSection.Properties;
-            SetEqual(
-                new[] { Create("my", "key1 = my_val"),
-                        Create("my_key2", "my:val")},
-                properties);
-        }
-        
-        [Fact]
-        public void SymbolsInProperties()
-        {
-            var config = EditorConfigFile.Parse(@"
-my@key1 = my_val
-my_key2 = my@val");
-
-            var properties = config.GlobalSection.Properties;
-            SetEqual(
-                new[] { Create("my_key2", "my@val") },
-                properties);
-        }
-        
-        [Fact]
-        public void LongLines()
-        {
-            // This example is described in the Python ConfigParser as allowing
-            // line continuation via the RFC 822 specification, section 3.1.1
-            // LONG HEADER FIELDS. The VS parser does not accept this as a
-            // valid parse for an editorconfig file. We follow similarly.
-            var config = EditorConfigFile.Parse(@"
-long: this value continues
-   in the next line");
-
-            var properties = config.GlobalSection.Properties;
-            SetEqual(
-                new[] { Create("long", "this value continues") },
-                properties);
-        }
-
-        
-        [Fact]
-        public void CaseInsensitiveRoot()
-        {
-            var config = EditorConfigFile.Parse(@"
-RoOt = TruE");
-            Assert.True(config.IsRoot);
-        }
-
-
-        /*
-        Reserved values are not supported at the moment
-        [Fact]
-        public void ReservedValues()
-        {
-            int index = 0;
-            var config = ParseConfigFile(string.Join(Environment.NewLine,
-                AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
-            index = 0;
-            AssertEx.SetEqual(
-                AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
-                config.GlobalSection.Properties);
-        }
-        */
-
-        /*
-        [Fact]
-        public void ReservedKeys()
-        {
-            var config = ParseConfigFile(string.Join(Environment.NewLine,
-                AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
-            AssertEx.SetEqual(
-                AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
-                config.GlobalSection.Properties);
-        }
-        */
-        #endregion
-    }
-}
diff --git a/src/Analyzers.UnitTests/EndToEndTests.cs b/src/Analyzers.UnitTests/EndToEndTests.cs
deleted file mode 100644
index 91b9d6c3742..00000000000
--- a/src/Analyzers.UnitTests/EndToEndTests.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.UnitTests;
-using Microsoft.Build.UnitTests.Shared;
-using Shouldly;
-using Xunit;
-using Xunit.Abstractions;
-
-namespace Microsoft.Build.Analyzers.UnitTests
-{
-    public class EndToEndTests : IDisposable
-    {
-        private readonly TestEnvironment _env;
-        public EndToEndTests(ITestOutputHelper output)
-        {
-            _env = TestEnvironment.Create(output);
-
-            // this is needed to ensure the binary logger does not pollute the environment
-            _env.WithEnvironmentInvariant();
-        }
-
-        public void Dispose() => _env.Dispose();
-
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode)
-        {
-            string contents = $"""
-                <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
-                    
-                    <PropertyGroup>
-                    <OutputType>Exe</OutputType>
-                    <TargetFramework>net8.0</TargetFramework>
-                    <ImplicitUsings>enable</ImplicitUsings>
-                    <Nullable>enable</Nullable>
-                    </PropertyGroup>
-                      
-                    <PropertyGroup Condition="$(Test) == true">
-                    <TestProperty>Test</TestProperty>
-                    </PropertyGroup>
-                     
-                    <ItemGroup>
-                    <ProjectReference Include=".\FooBar-Copy.csproj" />
-                    </ItemGroup>
-                      
-                    <Target Name="Hello">
-                    <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
-                    </Target>
-                    
-                </Project>
-                """;
-
-            string contents2 = $"""
-                <Project Sdk="Microsoft.NET.Sdk">
-                                   
-                    <PropertyGroup>
-                    <OutputType>Exe</OutputType>
-                    <TargetFramework>net8.0</TargetFramework>
-                    <ImplicitUsings>enable</ImplicitUsings>
-                    <Nullable>enable</Nullable>
-                    </PropertyGroup>
-                                     
-                    <PropertyGroup Condition="$(Test) == true">
-                    <TestProperty>Test</TestProperty>
-                    </PropertyGroup>
-                                    
-                    <ItemGroup>
-                    <Reference Include="bin/foo.dll" />
-                    </ItemGroup>
-                                    
-                    <Target Name="Hello">
-                    <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
-                    </Target>
-                </Project>
-                """;
-            TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
-            TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
-            TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
-            TransientTestFile config = _env.CreateFile(workFolder, ".editorconfig",
-            """
-            root=true
-
-            [*.csproj]
-            build_check.BC0101.IsEnabled=true
-            build_check.BC0101.Severity=warning
-
-            build_check.COND0543.IsEnabled=false
-            build_check.COND0543.Severity=Error
-            build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
-            build_check.COND0543.CustomSwitch=QWERTY
-
-            build_check.BLA.IsEnabled=false
-            """);
-
-            // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
-            // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
-            // TODO: See if there is a way of fixing it in the engine.
-            _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
-
-            _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
-            _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
-            string output = RunnerUtilities.ExecBootstrapedMSBuild($"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -analyze", out bool success);
-            _env.Output.WriteLine(output);
-            success.ShouldBeTrue();
-            // The conflicting outputs warning appears
-            output.ShouldContain("warning : BC0101");
-        }
-    }
-}
diff --git a/src/Analyzers.UnitTests/Microsoft.Build.Analyzers.UnitTests.csproj b/src/Analyzers.UnitTests/Microsoft.Build.Analyzers.UnitTests.csproj
deleted file mode 100644
index 5890b8fce94..00000000000
--- a/src/Analyzers.UnitTests/Microsoft.Build.Analyzers.UnitTests.csproj
+++ /dev/null
@@ -1,44 +0,0 @@
-<Project Sdk="Microsoft.NET.Sdk">
-
-  <PropertyGroup>
-    <!-- Don't build a netfx version of this unit with dotnet, as the netfx bootstrap layout created with 'dotnet build' is incomplete. -->
-    <TargetFrameworks>$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
-    <TargetFrameworks Condition="'$(MSBuildRuntimeType)' == 'Full'">$(FullFrameworkTFM);$(TargetFrameworks)</TargetFrameworks>
-
-    <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    <IsPackable>false</IsPackable>
-    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
-  </PropertyGroup>
-
-  <ItemGroup>
-    <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
-    <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
-    <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
-  </ItemGroup>
-
-  <ItemGroup>
-    <PackageReference Include="System.Collections.Immutable" />
-    <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
-  </ItemGroup>
-
-  <ItemGroup>
-    <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
-  </ItemGroup>
-
-  <ItemGroup>
-    <Compile Include="..\Shared\UnitTests\AssemblyResources.cs">
-      <Link>SharedUtilities\AssemblyResources.cs</Link>
-    </Compile>
-  </ItemGroup>
-
-  <ItemGroup>
-    <None Include="..\Shared\UnitTests\App.config">
-      <Link>App.config</Link>
-      <SubType>Designer</SubType>
-    </None>
-    <None Include="..\Shared\UnitTests\xunit.runner.json">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </None>
-  </ItemGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
new file mode 100644
index 00000000000..4b76786f3b4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
@@ -0,0 +1,118 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection.Metadata;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildAnalyzerConfiguration_Test
+{
+    [Fact]
+    public void CreateWithNull_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(null);
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Fact]
+    public void CreateWithEmpty_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", BuildAnalyzerResultSeverity.Error)]
+    [InlineData("info", BuildAnalyzerResultSeverity.Info)]
+    [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
+    [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
+    public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity" , parameter },
+        };
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("true", true)]
+    [InlineData("TRUE", true)]
+    [InlineData("false", false)]
+    [InlineData("FALSE", false)]
+    public void CreateBuildAnalyzerConfiguration_IsEnabled(string parameter, bool? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "isenabled" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.IsEnabled.ShouldBe(expected);
+
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("ProjectOnly", EvaluationAnalysisScope.ProjectOnly)]
+    [InlineData("ProjectWithImportsFromCurrentWorkTree", EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree)]
+    [InlineData("ProjectWithImportsWithoutSdks", EvaluationAnalysisScope.ProjectWithImportsWithoutSdks)]
+    [InlineData("ProjectWithAllImports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    [InlineData("projectwithallimports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "evaluationanalysisscope" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.Severity.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("evaluationanalysisscope", "incorrec-value")]
+    [InlineData("isenabled", "incorrec-value")]
+    [InlineData("severity", "incorrec-value")]
+    public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { key , value },
+        };
+
+        var exception = Should.Throw<BuildCheckConfigurationException>(() => {
+            BuildAnalyzerConfiguration.Create(config);
+        });
+        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
new file mode 100644
index 00000000000..1d5fec680b0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -0,0 +1,229 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class ConfigurationProvider_Tests
+{
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsEmptyConfig()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // empty
+        configs.ShouldBe(new Dictionary<string, string>());
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        configs.Keys.Count.ShouldBe(2);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+
+        configs["property2"].ShouldBe("value2");
+        configs["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationData()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        any_other_key1=any_other_value1
+        any_other_key2=any_other_value2
+        any_other_key3=any_other_value3
+        any_other_key3=any_other_value3
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var customConfiguration = configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+        var configs = customConfiguration.ConfigurationData;
+
+        configs!.Keys.Count().ShouldBe(3);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+        configs.ContainsKey("isenabled2").ShouldBeTrue();
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.Severity=Error
+        build_check.rule_id.EvaluationAnalysisScope=ProjectOnly
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var buildConfig = configurationProvider.GetUserConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        buildConfig.ShouldNotBeNull();
+
+        buildConfig.IsEnabled?.ShouldBeTrue();
+        buildConfig.Severity?.ShouldBe(BuildAnalyzerResultSeverity.Error);
+        buildConfig.EvaluationAnalysisScope?.ShouldBe(EvaluationAnalysisScope.ProjectOnly);
+    }
+
+        
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentValues()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value2
+        build_check.rule_id.property2=value3
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=tru1
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentKeys()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.isEnabled3=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should fail, because the configs are the different
+        Should.NotThrow(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+}
diff --git a/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
new file mode 100644
index 00000000000..0de7e02e1c4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
@@ -0,0 +1,151 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CustomConfigurationData_Tests
+{
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_NullInstance()
+    {
+        var customConfigurationData1 = CustomConfigurationData.Null;
+        var customConfigurationData2 = CustomConfigurationData.Null;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_SameInstance()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = customConfigurationData1;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_DifferentObjectType()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new object();
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_DifferentInstanceSameValues()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataSame()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferent()
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentKeys()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentValues()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataKeysOrderDiffers()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" },
+            { "key2", "val2" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" },
+            { "key1", "val1" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
new file mode 100644
index 00000000000..2c1a65018a2
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
@@ -0,0 +1,125 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfigParser_Tests
+{
+    [Fact]
+    public void NoSectionConfigured_ResultsEmptyResultConfig()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file");
+        mergedResult.Keys.Count.ShouldBe(0);
+    }
+
+    [Fact]
+    public void ProperOrderOfconfiguration_ClosestToTheFileShouldBeApplied()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    [*]
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file.proj");
+        mergedResult.Keys.Count.ShouldBe(1);
+        mergedResult["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootTrue()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=should_not_be_respected_and_parsed
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.EditorConfigFileDiscovery(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj") ).ToList();
+        // should be one because root=true so we do not need to go further
+        listOfEditorConfigFile.Count.ShouldBe(1);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeTrue();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+        listOfEditorConfigFile[0].NamedSections[0].Properties["test_key"].ShouldBe("test_value_updated");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootFalse()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=will_be_there
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.EditorConfigFileDiscovery(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj")).ToList();
+
+        listOfEditorConfigFile.Count.ShouldBe(2);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeFalse();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
new file mode 100644
index 00000000000..2bf7856c43e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -0,0 +1,1081 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
+using Microsoft.Build.UnitTests;
+using Xunit;
+using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+#nullable disable
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfig_Tests
+{
+
+    #region AssertEqualityComparer<T>
+    private sealed class AssertEqualityComparer<T> : IEqualityComparer<T>
+    {
+        public static readonly IEqualityComparer<T> Instance = new AssertEqualityComparer<T>();
+
+        private static bool CanBeNull()
+        {
+            var type = typeof(T);
+            return !type.GetTypeInfo().IsValueType ||
+                (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
+        }
+
+        public static bool IsNull(T @object)
+        {
+            if (!CanBeNull())
+            {
+                return false;
+            }
+
+            return object.Equals(@object, default(T));
+        }
+
+        public static bool Equals(T left, T right)
+        {
+            return Instance.Equals(left, right);
+        }
+
+        bool IEqualityComparer<T>.Equals(T x, T y)
+        {
+            if (CanBeNull())
+            {
+                if (object.Equals(x, default(T)))
+                {
+                    return object.Equals(y, default(T));
+                }
+
+                if (object.Equals(y, default(T)))
+                {
+                    return false;
+                }
+            }
+
+            if (x.GetType() != y.GetType())
+            {
+                return false;
+            }
+
+            if (x is IEquatable<T> equatable)
+            {
+                return equatable.Equals(y);
+            }
+
+            if (x is IComparable<T> comparableT)
+            {
+                return comparableT.CompareTo(y) == 0;
+            }
+
+            if (x is IComparable comparable)
+            {
+                return comparable.CompareTo(y) == 0;
+            }
+
+            var enumerableX = x as IEnumerable;
+            var enumerableY = y as IEnumerable;
+
+            if (enumerableX != null && enumerableY != null)
+            {
+                var enumeratorX = enumerableX.GetEnumerator();
+                var enumeratorY = enumerableY.GetEnumerator();
+
+                while (true)
+                {
+                    bool hasNextX = enumeratorX.MoveNext();
+                    bool hasNextY = enumeratorY.MoveNext();
+
+                    if (!hasNextX || !hasNextY)
+                    {
+                        return hasNextX == hasNextY;
+                    }
+
+                    if (!Equals(enumeratorX.Current, enumeratorY.Current))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return object.Equals(x, y);
+        }
+
+        int IEqualityComparer<T>.GetHashCode(T obj)
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+    #endregion
+
+    // Section Matchin Test cases: https://github.com/dotnet/roslyn/blob/ba163e712b01358a217065eec8a4a82f94a7efd5/src/Compilers/Core/CodeAnalysisTest/Analyzers/AnalyzerConfigTests.cs#L337
+    #region Section Matching Tests
+    [Fact]
+    public void SimpleNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc").Value;
+        Assert.Equal("^.*/abc$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/aabc"));
+        Assert.False(matcher.IsMatch("/ abc"));
+        Assert.False(matcher.IsMatch("/cabc"));
+    }
+
+    [Fact]
+    public void StarOnlyMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*").Value;
+        Assert.Equal("^.*/[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/123"));
+        Assert.True(matcher.IsMatch("/abc/123"));
+    }
+
+    [Fact]
+    public void StarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.cs").Value;
+        Assert.Equal("^.*/[^/]*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/123.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+        // Only '/' is defined as a directory separator, so the caller
+        // is responsible for converting any other machine directory
+        // separators to '/' before matching
+        Assert.True(matcher.IsMatch("/dir\\subpath.cs"));
+
+        Assert.False(matcher.IsMatch("/abc.vb"));
+    }
+
+    [Fact]
+    public void StarStarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("**.cs").Value;
+        Assert.Equal("^.*/.*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+    }
+
+    [Fact]
+    public void EscapeDot()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("...").Value;
+        Assert.Equal("^.*/\\.\\.\\.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/..."));
+        Assert.True(matcher.IsMatch("/subdir/..."));
+        Assert.False(matcher.IsMatch("/aaa"));
+        Assert.False(matcher.IsMatch("/???"));
+        Assert.False(matcher.IsMatch("/abc"));
+    }
+
+    [Fact]
+    public void EndBackslashMatch()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc\\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void QuestionMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab?def").Value;
+        Assert.Equal("^.*/ab.def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcdef"));
+        Assert.True(matcher.IsMatch("/ab?def"));
+        Assert.True(matcher.IsMatch("/abzdef"));
+        Assert.True(matcher.IsMatch("/ab/def"));
+        Assert.True(matcher.IsMatch("/ab\\def"));
+    }
+
+    [Fact]
+    public void LiteralBackslash()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab\\\\c").Value;
+        Assert.Equal("^.*/ab\\\\c$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab\\c"));
+        Assert.False(matcher.IsMatch("/ab/c"));
+        Assert.False(matcher.IsMatch("/ab\\\\c"));
+    }
+
+    [Fact]
+    public void LiteralStars()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\***\\*\\**").Value;
+        Assert.Equal("^.*/\\*.*\\*\\*[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/*ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd*efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd**ef/gh"));
+    }
+
+    [Fact]
+    public void LiteralQuestions()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\??\\?*\\??").Value;
+        Assert.Equal("^.*/\\?.\\?[^/]*\\?.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/?a?cde?f"));
+        Assert.True(matcher.IsMatch("/???????f"));
+        Assert.False(matcher.IsMatch("/aaaaaaaa"));
+        Assert.False(matcher.IsMatch("/aa?cde?f"));
+        Assert.False(matcher.IsMatch("/?a?cdexf"));
+        Assert.False(matcher.IsMatch("/?axcde?f"));
+    }
+
+    [Fact]
+    public void LiteralBraces()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\{\\}def").Value;
+        Assert.Equal(@"^.*/abc\{}def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc{}def"));
+        Assert.True(matcher.IsMatch("/subdir/abc{}def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc}{def"));
+    }
+
+    [Fact]
+    public void LiteralComma()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\,def").Value;
+        Assert.Equal("^.*/abc,def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc,def"));
+        Assert.True(matcher.IsMatch("/subdir/abc,def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc\\,def"));
+        Assert.False(matcher.IsMatch("/abc`def"));
+    }
+
+    [Fact]
+    public void SimpleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.{cs,vb,fs}").Value;
+        Assert.Equal("^.*/[^/]*\\.(?:cs|vb|fs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.vb"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.cs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.vb"));
+        Assert.True(matcher.IsMatch("/subdir/abc.fs"));
+
+        Assert.False(matcher.IsMatch("/abcxcs"));
+        Assert.False(matcher.IsMatch("/abcxvb"));
+        Assert.False(matcher.IsMatch("/abcxfs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcb"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+    }
+
+    [Fact]
+    public void OneChoiceHasSlashes()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs,subdir/test.vb}").Value;
+        // This is an interesting case that may be counterintuitive.  A reasonable understanding
+        // of the section matching could interpret the choice as generating multiple identical
+        // sections, so [{a, b, c}] would be equivalent to [a] ... [b] ... [c] with all of the
+        // same properties in each section. This is somewhat true, but the rules of how the matching
+        // prefixes are constructed violate this assumption because they are defined as whether or
+        // not a section contains a slash, not whether any of the choices contain a slash. So while
+        // [*.cs] usually translates into '**/*.cs' because it contains no slashes, the slashes in
+        // the second choice make this into '/*.cs', effectively matching only files in the root
+        // directory of the match, instead of all subdirectories.
+        Assert.Equal("^/(?:[^/]*\\.cs|subdir/test\\.vb)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+
+        Assert.False(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("/subdir/subdir/test.vb"));
+        Assert.False(matcher.IsMatch("/test.vb"));
+    }
+
+    [Fact]
+    public void EmptyChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{}").Value;
+        Assert.Equal("^.*/(?:)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/"));
+        Assert.True(matcher.IsMatch("/subdir/"));
+        Assert.False(matcher.IsMatch("/."));
+        Assert.False(matcher.IsMatch("/anything"));
+    }
+
+    [Fact]
+    public void SingleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs}").Value;
+        Assert.Equal("^.*/(?:[^/]*\\.cs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("test.vb"));
+        Assert.False(matcher.IsMatch("testxcs"));
+    }
+
+    [Fact]
+    public void UnmatchedBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("{{{{}}");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CommaOutsideBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc,def");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void RecursiveChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{test{.cs,.vb},other.{a{bb,cc}}}").Value;
+        Assert.Equal("^.*/(?:test(?:\\.cs|\\.vb)|other\\.(?:a(?:bb|cc)))$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/test.vb"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+        Assert.True(matcher.IsMatch("/other.abb"));
+        Assert.True(matcher.IsMatch("/other.acc"));
+
+        Assert.False(matcher.IsMatch("/test.fs"));
+        Assert.False(matcher.IsMatch("/other.bbb"));
+        Assert.False(matcher.IsMatch("/other.ccc"));
+        Assert.False(matcher.IsMatch("/subdir/other.bbb"));
+        Assert.False(matcher.IsMatch("/subdir/other.ccc"));
+    }
+
+    [Fact]
+    public void DashChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{-}cd{-,}ef").Value;
+        Assert.Equal("^.*/ab(?:-)cd(?:-|)ef$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab-cd-ef"));
+        Assert.True(matcher.IsMatch("/ab-cdef"));
+
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/ab--cd-ef"));
+        Assert.False(matcher.IsMatch("/ab--cd--ef"));
+    }
+
+    [Fact]
+    public void MiddleMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{cs,vb,fs}cd").Value;
+        Assert.Equal("^.*/ab(?:cs|vb|fs)cd$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcscd"));
+        Assert.True(matcher.IsMatch("/abvbcd"));
+        Assert.True(matcher.IsMatch("/abfscd"));
+
+        Assert.False(matcher.IsMatch("/abcs"));
+        Assert.False(matcher.IsMatch("/abcd"));
+        Assert.False(matcher.IsMatch("/vbcd"));
+    }
+
+    private static IEnumerable<(string, string)> RangeAndInverse(string s1, string s2)
+    {
+        yield return (s1, s2);
+        yield return (s2, s1);
+    }
+
+    [Fact]
+    public void NumberMatch()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("0", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/000005"));
+            Assert.False(matcher.IsMatch("/-1"));
+            Assert.False(matcher.IsMatch("/-00000001"));
+            Assert.False(matcher.IsMatch("/11"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegativeRange()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "0"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.False(matcher.IsMatch("/1"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegToPos()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void MultipleNumberRanges()
+    {
+        foreach (var matchString in new[] { "a{-10..0}b{0..10}", "a{0..-10}b{10..0}" })
+        {
+            var matcher = TryCreateSectionNameMatcher(matchString).Value;
+
+            Assert.True(matcher.IsMatch("/a0b0"));
+            Assert.True(matcher.IsMatch("/a-5b0"));
+            Assert.True(matcher.IsMatch("/a-5b5"));
+            Assert.True(matcher.IsMatch("/a-5b10"));
+            Assert.True(matcher.IsMatch("/a-10b10"));
+            Assert.True(matcher.IsMatch("/a-10b0"));
+            Assert.True(matcher.IsMatch("/a-0b0"));
+            Assert.True(matcher.IsMatch("/a-0b-0"));
+
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-10b11"));
+        }
+    }
+
+    [Fact]
+    public void BadNumberRanges()
+    {
+        var matcherOpt = TryCreateSectionNameMatcher("{0..");
+
+        Assert.Null(matcherOpt);
+
+        var matcher = TryCreateSectionNameMatcher("{0..}").Value;
+
+        Assert.True(matcher.IsMatch("/0.."));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0."));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        matcher = TryCreateSectionNameMatcher("{0..A}").Value;
+        Assert.True(matcher.IsMatch("/0..A"));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        // The reference implementation uses atoi here so we can presume
+        // numbers out of range of Int32 are not well supported
+        matcherOpt = TryCreateSectionNameMatcher($"{{0..{UInt32.MaxValue}}}");
+
+        Assert.Null(matcherOpt);
+    }
+
+    [Fact]
+    public void CharacterClassSimple()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+    }
+
+    [Fact]
+    public void CharacterClassNegative()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[!cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[^cf]s$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/abc.cs"));
+        Assert.False(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.vs"));
+        Assert.True(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassCaret()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[^cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[\^cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.^s"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+        Assert.False(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[0-9]x").Value;
+        Assert.Equal("^.*/[0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassNegativeRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[!0-9]x").Value;
+        Assert.Equal("^.*/[^0-9]x$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/0x"));
+        Assert.False(matcher.IsMatch("/1x"));
+        Assert.False(matcher.IsMatch("/9x"));
+        Assert.True(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassRangeAndChoice()
+    {
+        var matcher = TryCreateSectionNameMatcher("[ab0-9]x").Value;
+        Assert.Equal("^.*/[ab0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ax"));
+        Assert.True(matcher.IsMatch("/bx"));
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/0ax"));
+    }
+
+    [Fact]
+    public void CharacterClassOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher("[");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapedOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\]");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapeAtEnd()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassOpenBracketInside()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[[a]bc").Value;
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/[bc"));
+        Assert.False(matcher.IsMatch("/ab"));
+        Assert.False(matcher.IsMatch("/[b"));
+        Assert.False(matcher.IsMatch("/bc"));
+        Assert.False(matcher.IsMatch("/ac"));
+        Assert.False(matcher.IsMatch("/[c"));
+
+        Assert.Equal(@"^.*/[\[a]bc$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassStartingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[-ac]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[-ac]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ac-]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[ac-]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndBracketAfter()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab]]cd").Value;
+
+        Assert.True(matcher.IsMatch("/a]cd"));
+        Assert.True(matcher.IsMatch("/b]cd"));
+        Assert.False(matcher.IsMatch("/acd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+        Assert.False(matcher.IsMatch("/acd"));
+
+        Assert.Equal(@"^.*/[ab]]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEscapeBackslash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab\\]cd").Value;
+
+        Assert.True(matcher.IsMatch("/acd"));
+        Assert.True(matcher.IsMatch("/bcd"));
+        Assert.True(matcher.IsMatch("/\\cd"));
+        Assert.False(matcher.IsMatch("/dcd"));
+        Assert.False(matcher.IsMatch("/\\\\cd"));
+        Assert.False(matcher.IsMatch("/cd"));
+
+        Assert.Equal(@"^.*/[ab\\]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void EscapeOpenBracket()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"ab\[cd").Value;
+
+        Assert.True(matcher.IsMatch("/ab[cd"));
+        Assert.False(matcher.IsMatch("/ab[[cd"));
+        Assert.False(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/abd"));
+
+        Assert.Equal(@"^.*/ab\[cd$", matcher.Regex.ToString());
+    }
+    #endregion
+
+    #region Parsing Tests
+
+    private static void SetEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null, string message = null)
+    {
+        var expectedSet = new HashSet<T>(expected, comparer);
+        var result = expected.Count() == actual.Count() && expectedSet.SetEquals(actual);
+        Assert.True(result, message);
+    }
+
+    private static void Equal<T>(
+        IEnumerable<T> expected,
+        IEnumerable<T> actual,
+        IEqualityComparer<T> comparer = null,
+        string message = null)
+    {
+        if (expected == null)
+        {
+            Assert.Null(actual);
+        }
+        else
+        {
+            Assert.NotNull(actual);
+        }
+
+        if (SequenceEqual(expected, actual, comparer))
+        {
+            return;
+        }
+
+        Assert.True(false, message);
+    }
+
+    private static bool SequenceEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null)
+    {
+        if (ReferenceEquals(expected, actual))
+        {
+            return true;
+        }
+
+        var enumerator1 = expected.GetEnumerator();
+        var enumerator2 = actual.GetEnumerator();
+
+        while (true)
+        {
+            var hasNext1 = enumerator1.MoveNext();
+            var hasNext2 = enumerator2.MoveNext();
+
+            if (hasNext1 != hasNext2)
+            {
+                return false;
+            }
+
+            if (!hasNext1)
+            {
+                break;
+            }
+
+            var value1 = enumerator1.Current;
+            var value2 = enumerator2.Current;
+
+            if (!(comparer != null ? comparer.Equals(value1, value2) : AssertEqualityComparer<T>.Equals(value1, value2)))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static KeyValuePair<K, V> Create<K, V>(K key, V value)
+    {
+        return new KeyValuePair<K, V>(key, value);
+    }
+
+    [Fact]
+    public void SimpleCase()
+    {
+        var config = EditorConfigFile.Parse("""
+root = true
+
+# Comment1
+# Comment2
+##################################
+
+my_global_prop = my_global_val
+
+[*.cs]
+my_prop = my_val
+""");
+        Assert.Equal("", config.GlobalSection.Name);
+        var properties = config.GlobalSection.Properties;
+
+        SetEqual(
+            new[] { Create("my_global_prop", "my_global_val") ,
+                    Create("root", "true") },
+            properties);
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("*.cs", namedSections[0].Name);
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            namedSections[0].Properties);
+        
+        Assert.True(config.IsRoot);
+    }
+
+    
+    [Fact]
+    // [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void ConfigWithEscapedValues()
+    {
+        var config = EditorConfigFile.Parse(@"is_global = true
+
+[c:/\{f\*i\?le1\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[c:/f\,ile\#2.cs]
+build_metadata.Compile.ToRetrieve = def456
+
+[c:/f\;i\!le\[3\].cs]
+build_metadata.Compile.ToRetrieve = ghi789
+");
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("c:/\\{f\\*i\\?le1\\}.cs", namedSections[0].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "abc123") },
+            namedSections[0].Properties);
+
+        Assert.Equal("c:/f\\,ile\\#2.cs", namedSections[1].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "def456") },
+            namedSections[1].Properties);
+
+        Assert.Equal("c:/f\\;i\\!le\\[3\\].cs", namedSections[2].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "ghi789") },
+            namedSections[2].Properties);
+    }
+
+    /*
+    [Fact]
+    [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void CanGetSectionsWithSpecialCharacters()
+    {
+        var config = ParseConfigFile(@"is_global = true
+
+[/home/foo/src/\{releaseid\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[/home/foo/src/Pages/\#foo/HomePage.cs]
+build_metadata.Compile.ToRetrieve = def456
+");
+
+        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+
+        var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
+        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+
+        sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
+        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+    }*/
+
+    [Fact]
+    public void MissingClosingBracket()
+    {
+        var config = EditorConfigFile.Parse(@"
+[*.cs
+my_prop = my_val");
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            properties);
+
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void EmptySection()
+    {
+        var config = EditorConfigFile.Parse(@"
+[]
+my_prop = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_val") }, properties);
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitivePropKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_PROP = my_VAL");
+        var properties = config.GlobalSection.Properties;
+
+        Assert.True(properties.TryGetValue("my_PrOp", out var val));
+        Assert.Equal("my_VAL", val);
+        Assert.Equal("my_prop", properties.Keys.Single());
+    }
+
+    // there is no reversed keys support for msbuild
+    /*[Fact]
+    public void NonReservedKeyPreservedCaseVal()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            config.GlobalSection.Properties);
+    }*/
+
+
+    [Fact]
+    public void DuplicateKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_prop = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void DuplicateKeysCasing()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_PROP = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void MissingKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+= my_val1
+my_prop = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val2") },
+            properties);
+    }
+
+    
+
+    [Fact]
+    public void MissingVal()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop1 =
+my_prop2 = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop1", ""),
+                    Create("my_prop2", "my_val") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void SpacesInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my prop1 = my_val1
+my_prop2 = my val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void EndOfLineComments()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop2 = my val2 # Comment");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsStartKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+@!$abc = my_val1
+@!$\# = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(0, properties.Count);
+    }
+
+    
+    [Fact]
+    public void EqualsAndColon()
+    {
+        var config = EditorConfigFile.Parse(@"
+my:key1 = my_val
+my_key2 = my:val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my", "key1 = my_val"),
+                    Create("my_key2", "my:val")},
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my@key1 = my_val
+my_key2 = my@val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_key2", "my@val") },
+            properties);
+    }
+    
+    [Fact]
+    public void LongLines()
+    {
+        // This example is described in the Python ConfigParser as allowing
+        // line continuation via the RFC 822 specification, section 3.1.1
+        // LONG HEADER FIELDS. The VS parser does not accept this as a
+        // valid parse for an editorconfig file. We follow similarly.
+        var config = EditorConfigFile.Parse(@"
+long: this value continues
+   in the next line");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("long", "this value continues") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitiveRoot()
+    {
+        var config = EditorConfigFile.Parse(@"
+RoOt = TruE");
+        Assert.True(config.IsRoot);
+    }
+
+
+    /*
+    Reserved values are not supported at the moment
+    [Fact]
+    public void ReservedValues()
+    {
+        int index = 0;
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+        index = 0;
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+
+    /*
+    [Fact]
+    public void ReservedKeys()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+    #endregion
+}
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index a0007d2c103..6740eeacd27 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -62,7 +62,6 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
 
         string contents2 = $"""
             <Project Sdk="Microsoft.NET.Sdk">
-                               
                 <PropertyGroup>
                 <OutputType>Exe</OutputType>
                 <TargetFramework>net8.0</TargetFramework>
@@ -88,28 +87,20 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
         TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
         TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
 
-        // var cache = new SimpleProjectRootElementCache();
-        // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
+        TransientTestFile config = _env.CreateFile(workFolder, ".editorconfig",
+            """
+            root=true
+
+            [*.csproj]
+            build_check.BC0101.IsEnabled=true
+            build_check.BC0101.Severity=warning
 
+            build_check.COND0543.IsEnabled=false
+            build_check.COND0543.Severity=Error
+            build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+            build_check.COND0543.CustomSwitch=QWERTY
 
-        TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
-            /*lang=json,strict*/
-            """
-            {
-                "BC0101": {
-                    "IsEnabled": true,
-                    "Severity": "Error"
-                },
-                "COND0543": {
-                    "IsEnabled": false,
-                    "Severity": "Error",
-                    "EvaluationAnalysisScope": "AnalyzedProjectOnly",
-                    "CustomSwitch": "QWERTY"
-                },
-                "BLA": {
-                    "IsEnabled": false
-                }
-            }
+            build_check.BLA.IsEnabled=false
             """);
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 0bade6a09d5..d908e0fbcdd 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -1,6 +1,6 @@
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
-    <TargetFrameworks>$(FullFrameworkTFM);$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
+    <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <AssemblyName>Microsoft.Build.UnitTests.Shared</AssemblyName>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <IsShipping>false</IsShipping>
@@ -18,5 +18,21 @@
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
+    <ProjectReference Include="..\MSBuild.Bootstrap\MSBuild.Bootstrap.csproj">
+      <Private>false</Private>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
   </ItemGroup>
-</Project>
+
+  <ItemGroup>
+    <Compile Include="..\Shared\IsExternalInit.cs" />
+  </ItemGroup>
+
+  <Import Project="..\..\eng\BootStrapMsBuild.props" />
+
+  <ItemGroup>
+    <AssemblyAttribute Include="Microsoft.Build.UnitTests.Shared.BootstrapLocationAttribute">
+      <_Parameter1>$(BootstrapBinaryDestination)</_Parameter1>
+    </AssemblyAttribute>
+  </ItemGroup>
+</Project>
\ No newline at end of file
