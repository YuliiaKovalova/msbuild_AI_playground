diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 239f7910b68..f850148d0bf 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -38,6 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
+        protected System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -589,6 +590,22 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
         public string TaskName { get { throw null; } }
     }
     public delegate void TaskFinishedEventHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e);
+    public partial class TaskParameterEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemName, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) { }
+        public string ItemName { get { throw null; } }
+        public System.Collections.IList Items { get { throw null; } }
+        public Microsoft.Build.Framework.TaskParameterMessageKind Kind { get { throw null; } }
+        public bool LogItemMetadata { get { throw null; } }
+        public override string Message { get { throw null; } }
+    }
+    public enum TaskParameterMessageKind
+    {
+        TaskInput = 0,
+        TaskOutput = 1,
+        AddItem = 2,
+        RemoveItem = 3,
+    }
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 9c2d45f2253..a19a70ce45a 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -38,6 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
+        protected System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -588,6 +589,22 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
         public string TaskName { get { throw null; } }
     }
     public delegate void TaskFinishedEventHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e);
+    public partial class TaskParameterEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemName, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) { }
+        public string ItemName { get { throw null; } }
+        public System.Collections.IList Items { get { throw null; } }
+        public Microsoft.Build.Framework.TaskParameterMessageKind Kind { get { throw null; } }
+        public bool LogItemMetadata { get { throw null; } }
+        public override string Message { get { throw null; } }
+    }
+    public enum TaskParameterMessageKind
+    {
+        TaskInput = 0,
+        TaskOutput = 1,
+        AddItem = 2,
+        RemoveItem = 3,
+    }
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
diff --git a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
index 3798326b7e2..8dc2e82dbdd 100644
--- a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
@@ -68,6 +68,7 @@ public void ConsumeEventsGoodEventsNoHandlers()
             eventHelper.RaiseBuildEvent(RaiseEventHelper.NormalMessage);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.TaskFinished);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.CommandLine);
+            eventHelper.RaiseBuildEvent(RaiseEventHelper.TaskParameter);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.Warning);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.Error);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.TargetStarted);
@@ -99,6 +100,7 @@ public void LoggerExceptionInEventHandler()
                 RaiseExceptionInEventHandler(RaiseEventHelper.NormalMessage, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.TaskFinished, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.CommandLine, exception);
+                RaiseExceptionInEventHandler(RaiseEventHelper.TaskParameter, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.Warning, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.Error, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.TargetStarted, exception);
@@ -733,6 +735,11 @@ internal class RaiseEventHelper
             /// </summary>
             private static TaskCommandLineEventArgs s_taskCommandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
 
+            /// <summary>
+            /// Task Parameter Event
+            /// </summary>
+            private static TaskParameterEventArgs s_taskParameter = new TaskParameterEventArgs(TaskParameterMessageKind.TaskInput, "ItemName", null, true, DateTime.MinValue);
+
             /// <summary>
             /// Build Warning Event
             /// </summary>
@@ -883,6 +890,11 @@ internal static TaskCommandLineEventArgs CommandLine
                 }
             }
 
+            /// <summary>
+            /// Event which can be raised in multiple tests.
+            /// </summary>
+            internal static TaskParameterEventArgs TaskParameter => s_taskParameter;
+
             /// <summary>
             /// Event which can be raised in multiple tests.
             /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 459d835bd25..b2232cf9167 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
@@ -44,6 +45,7 @@ public void VerifyEventType()
             TaskStartedEventArgs taskStarted = new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName");
             TaskFinishedEventArgs taskFinished = new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true);
             TaskCommandLineEventArgs commandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
+            TaskParameterEventArgs taskParameter = CreateTaskParameter();
             BuildWarningEventArgs warning = new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
             BuildErrorEventArgs error = new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
             TargetStartedEventArgs targetStarted = new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile");
@@ -58,6 +60,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(taskStarted, LoggingEventType.TaskStartedEvent);
             VerifyLoggingPacket(taskFinished, LoggingEventType.TaskFinishedEvent);
             VerifyLoggingPacket(commandLine, LoggingEventType.TaskCommandLineEvent);
+            VerifyLoggingPacket(taskParameter, LoggingEventType.TaskParameterEvent);
             VerifyLoggingPacket(warning, LoggingEventType.BuildWarningEvent);
             VerifyLoggingPacket(error, LoggingEventType.BuildErrorEvent);
             VerifyLoggingPacket(targetStarted, LoggingEventType.TargetStartedEvent);
@@ -67,12 +70,41 @@ public void VerifyEventType()
             VerifyLoggingPacket(externalStartedEvent, LoggingEventType.CustomEvent);
         }
 
+        private static TaskParameterEventArgs CreateTaskParameter()
+        {
+            var items = new TaskItemData[]
+            {
+                new TaskItemData("ItemSpec1", null),
+                new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
+            };
+            var result = new TaskParameterEventArgs(
+                TaskParameterMessageKind.TaskInput,
+                "ItemName",
+                items,
+                logItemMetadata: true,
+                DateTime.MinValue);
+
+            // normalize line endings as we can't rely on the line endings of NodePackets_Tests.cs
+            Assert.Equal(@"Task Parameter:
+    ItemName=
+        ItemSpec1
+        ItemSpec2
+                1=1value
+                2=2value
+                3=3value".Replace("\r\n", "\n"), result.Message);
+
+            return result;
+        }
+
         /// <summary>
         /// Tests serialization of LogMessagePacket with each kind of event type.
         /// </summary>
         [Fact]
         public void TestTranslation()
         {
+            // need to touch the type so that the static constructor runs
+            _ = ItemGroupLoggingHelper.OutputItemParameterMessagePrefix;
+
             TaskItem item = new TaskItem("Hello", "my.proj");
             List<TaskItem> targetOutputs = new List<TaskItem>();
             targetOutputs.Add(item);
@@ -88,6 +120,7 @@ public void TestTranslation()
                     new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName"),
                     new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true),
                     new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low),
+                    CreateTaskParameter(),
                     new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender"),
                     new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender"),
                     new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile"),
@@ -281,6 +314,19 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftCommand.TaskName, rightCommand.TaskName);
                     break;
 
+                case LoggingEventType.TaskParameterEvent:
+                    var leftTaskParameter = left.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
+                    var rightTaskParameter = right.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
+                    Assert.NotNull(leftTaskParameter);
+                    Assert.NotNull(rightTaskParameter);
+                    Assert.Equal(leftTaskParameter.Kind, rightTaskParameter.Kind);
+                    Assert.Equal(leftTaskParameter.ItemName, rightTaskParameter.ItemName);
+                    Assert.Equal(leftTaskParameter.Items.Count, rightTaskParameter.Items.Count);
+                    Assert.Equal(leftTaskParameter.Message, rightTaskParameter.Message);
+                    Assert.Equal(leftTaskParameter.BuildEventContext, rightTaskParameter.BuildEventContext);
+                    Assert.Equal(leftTaskParameter.Timestamp, rightTaskParameter.Timestamp);
+                    break;
+
                 case LoggingEventType.TaskFinishedEvent:
                     TaskFinishedEventArgs leftTaskFinished = left.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
                     TaskFinishedEventArgs rightTaskFinished = right.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index ec95009bec1..8deb4db94b7 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -7,7 +7,7 @@ namespace Microsoft.Build.UnitTests
 {
     public class BinaryLoggerTests : IDisposable
     {
-        private static string s_testProject = @"
+        private const string s_testProject = @"
          <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
             <PropertyGroup>
                <TestProperty>Test</TestProperty>
@@ -22,6 +22,38 @@ public class BinaryLoggerTests : IDisposable
                <Exec Command='echo a'/>
             </Target>
          </Project>";
+
+        private const string s_testProject2 = @"
+        <Project>
+            <ItemGroup>
+            <Compile Include=""0.cs"" />
+            </ItemGroup>
+            <ItemDefinitionGroup>
+            <Compile>
+                <MetadataFromItemDefinition>fromItemDefinition%61%62%63&lt;&gt;</MetadataFromItemDefinition>
+            </Compile>
+            </ItemDefinitionGroup>
+            <Target Name=""Build"" Outputs=""@(CombinedOutput)"">
+            <ItemGroup>
+                <Compile Include=""1.cs"">
+                <MetadataName>MetadataValue1%61%62%63&lt;&gt;</MetadataName>
+                </Compile>
+                <Compile Remove=""1.cs"" />
+                <Compile Include=""2.cs"" />
+                <Compile Include=""3.cs"">
+                <CustomMetadata>custom%61%62%63&lt;&gt;</CustomMetadata>
+                </Compile>
+            </ItemGroup>
+            <Message Importance=""High"" Condition=""$(Test) != true"" Text=""Hello"" />
+            <CombinePath BasePath=""base"" Paths=""@(Compile)"">
+                <Output TaskParameter=""CombinedPaths"" ItemName=""CombinedOutput""/>
+            </CombinePath>
+            <ItemGroup>
+                <Compile Remove=""2.cs"" />
+            </ItemGroup>
+            </Target>
+        </Project>";
+
         private readonly TestEnvironment _env;
         private string _logFile;
 
@@ -35,8 +67,10 @@ public BinaryLoggerTests(ITestOutputHelper output)
             _logFile = _env.ExpectFile(".binlog").Path;
         }
 
-        [Fact]
-        public void TestBinaryLoggerRoundtrip()
+        [Theory]
+        [InlineData(s_testProject)]
+        [InlineData(s_testProject2)]
+        public void TestBinaryLoggerRoundtrip(string projectText)
         {
             var binaryLogger = new BinaryLogger();
 
@@ -45,14 +79,14 @@ public void TestBinaryLoggerRoundtrip()
             var mockLogFromBuild = new MockLogger();
 
             // build and log into binary logger and mockLogger1
-            ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger, mockLogFromBuild);
+            ObjectModelHelpers.BuildProjectExpectSuccess(projectText, binaryLogger, mockLogFromBuild);
 
             var mockLogFromPlayback = new MockLogger();
 
             var binaryLogReader = new BinaryLogReplayEventSource();
             mockLogFromPlayback.Initialize(binaryLogReader);
 
-            // read the binary log and replay into mockLogger2testassembly
+            // read the binary log and replay into mockLogger2
             binaryLogReader.Replay(_logFile);
 
             // the binlog will have more information than recorded by the text log
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index afd56aea915..e73ff6a500f 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -4,6 +4,7 @@
 using System.IO;
 using System.Linq;
 using System.Text;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Logging;
@@ -70,21 +71,39 @@ public void RoundtripProjectStartedEventArgs()
                 toolsVersion: "Current");
             args.BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6);
 
-            Roundtrip(args,
+            Roundtrip<ProjectStartedEventArgs>(args,
                 e => ToString(e.BuildEventContext),
                 e => ToString(e.GlobalProperties),
-                e => ToString(e.Items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => ((ITaskItem)d.Value).ItemSpec)),
+                e => GetItemsString(e.Items),
                 e => e.Message,
                 e => ToString(e.ParentProjectBuildEventContext),
                 e => e.ProjectFile,
                 e => e.ProjectId.ToString(),
-                e => ToString(e.Properties.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => d.Value.ToString())),
+                e => ToString(e.Properties.OfType<DictionaryEntry>().ToDictionary((Func<DictionaryEntry, string>)(d => d.Key.ToString()), (Func<DictionaryEntry, string>)(d => d.Value.ToString()))),
                 e => e.TargetNames,
                 e => e.ThreadId.ToString(),
                 e => e.Timestamp.ToString(),
                 e => e.ToolsVersion);
         }
 
+        private string GetItemsString(IEnumerable items)
+        {
+            return ToString(items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => GetTaskItemString((ITaskItem)d.Value)));
+        }
+
+        private string GetTaskItemString(ITaskItem taskItem)
+        {
+            var sb = new StringBuilder();
+            sb.Append(taskItem.ItemSpec);
+            foreach (string name in taskItem.MetadataNames)
+            {
+                var value = taskItem.GetMetadata(name);
+                sb.Append($";{name}={value}");
+            }
+
+            return sb.ToString();
+        }
+
         [Fact]
         public void RoundtripProjectFinishedEventArgs()
         {
@@ -309,6 +328,23 @@ public void RoundtripTaskCommandLineEventArgs()
                 e => e.Subcategory);
         }
 
+        [Fact]
+        public void RoundtripTaskParameterEventArgs()
+        {
+            var items = new TaskItemData[]
+            {
+                new TaskItemData("ItemSpec1", null),
+                new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
+            };
+            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ItemName", items, true, DateTime.MinValue);
+
+            Roundtrip(args,
+                e => e.Kind.ToString(),
+                e => e.ItemName,
+                e => e.LogItemMetadata.ToString(),
+                e => GetItemsString(e.Items));
+        }
+
         [Fact]
         public void RoundtripProjectEvaluationStartedEventArgs()
         {
diff --git a/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs b/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
index f584072937b..3698f90ed5d 100644
--- a/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
+++ b/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
@@ -20,6 +21,7 @@ public class ConfigureableForwardingLogger_Tests
         private readonly TaskStartedEventArgs _taskStarted = new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName");
         private readonly TaskFinishedEventArgs _taskFinished = new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true);
         private readonly TaskCommandLineEventArgs _commandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
+        private readonly TaskParameterEventArgs _taskParameter = new TaskParameterEventArgs(TaskParameterMessageKind.TaskInput, "ItemName", null, true, DateTime.MinValue);
         private readonly BuildWarningEventArgs _warning = new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
         private readonly BuildErrorEventArgs _error = new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
         private readonly TargetStartedEventArgs _targetStarted = new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile");
@@ -131,6 +133,7 @@ public void ForwardingLoggingEventsBasedOnVerbosity(LoggerVerbosity? loggerVerbo
                         _normalMessage,
                         _highMessage,
                         _commandLine,
+                        _taskParameter,
                         _warning,
                         _error,
                         _taskFinished,
@@ -150,6 +153,7 @@ public void ForwardingLoggingEventsBasedOnVerbosity(LoggerVerbosity? loggerVerbo
                         _normalMessage,
                         _highMessage,
                         _commandLine,
+                        _taskParameter,
                         _externalStartedEvent,
                         _warning,
                         _error,
@@ -266,6 +270,7 @@ private void RaiseEvents(EventSourceSink source)
             source.Consume(_normalMessage);
             source.Consume(_highMessage);
             source.Consume(_commandLine);
+            source.Consume(_taskParameter);
             source.Consume(_externalStartedEvent);
             source.Consume(_warning);
             source.Consume(_error);
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 6daf7608f20..efde35dd8af 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -138,6 +138,11 @@ internal TargetOutputItemsInstanceEnumeratorProxy(IEnumerable<TaskItem> backingI
                 _backingItems = backingItems;
             }
 
+            // For performance reasons we need to expose the raw items to BinaryLogger
+            // as we know we're not going to mutate anything. This allows us to bypass DeepClone
+            // for each item
+            internal IEnumerable<TaskItem> BackingItems => _backingItems;
+
             /// <summary>
             /// Returns an enumerator that provides copies of the items
             /// in the backing store.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 9b24ebd0cec..66195775b22 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -213,12 +213,12 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
 
             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
-                var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
-                    ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix,
+                ItemGroupLoggingHelper.LogTaskParameter(
+                    LoggingContext,
+                    TaskParameterMessageKind.AddItem,
                     child.ItemType,
                     itemsToAdd,
                     logItemMetadata: true);
-                LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
             }
 
             // Now add the items we created to the lookup.
@@ -256,12 +256,12 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             {
                 if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToRemove.Count > 0)
                 {
-                    var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
-                        ItemGroupLoggingHelper.ItemGroupRemoveLogMessage,
+                    ItemGroupLoggingHelper.LogTaskParameter(
+                        LoggingContext,
+                        TaskParameterMessageKind.RemoveItem,
                         child.ItemType,
                         itemsToRemove,
                         logItemMetadata: true);
-                    LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
                 }
 
                 bucket.Lookup.RemoveItems(itemsToRemove);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index 9aa0bfd4fce..83aa5564c92 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -5,6 +5,8 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -31,6 +33,17 @@ internal static class ItemGroupLoggingHelper
         internal static string OutputItemParameterMessagePrefix = ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix");
         internal static string TaskParameterPrefix = ResourceUtilities.GetResourceString("TaskParameterPrefix");
 
+        /// <summary>
+        /// <see cref="TaskParameterEventArgs"/> by itself doesn't have the implementation
+        /// to materialize the Message as that's a declaration assembly. We inject the logic
+        /// here.
+        /// </summary>
+        static ItemGroupLoggingHelper()
+        {
+            TaskParameterEventArgs.MessageGetter = GetTaskParameterText;
+            TaskParameterEventArgs.DictionaryFactory = SmallDictionary<string, string>.Create;
+        }
+
         /// <summary>
         /// Gets a text serialized value of a parameter for logging.
         /// </summary>
@@ -203,5 +216,56 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob
                 ErrorUtilities.ThrowInternalErrorUnreachable();
             }
         }
+
+        internal static void LogTaskParameter(
+            LoggingContext loggingContext,
+            TaskParameterMessageKind messageKind,
+            string itemName,
+            IList items,
+            bool logItemMetadata)
+        {
+            var args = CreateTaskParameterEventArgs(loggingContext.BuildEventContext, messageKind, itemName, items, logItemMetadata, DateTime.UtcNow);
+            loggingContext.LogBuildEvent(args);
+        }
+
+        internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
+            BuildEventContext buildEventContext,
+            TaskParameterMessageKind messageKind,
+            string itemName,
+            IList items,
+            bool logItemMetadata,
+            DateTime timestamp)
+        {
+            var args = new TaskParameterEventArgs(
+                messageKind,
+                itemName,
+                items,
+                logItemMetadata,
+                timestamp);
+            args.BuildEventContext = buildEventContext;
+            return args;
+        }
+
+        internal static string GetTaskParameterText(TaskParameterEventArgs args)
+            => GetTaskParameterText(args.Kind, args.ItemName, args.Items, args.LogItemMetadata);
+
+        internal static string GetTaskParameterText(TaskParameterMessageKind messageKind, string itemName, IList items, bool logItemMetadata)
+        {
+            var resourceText = messageKind switch
+            {
+                TaskParameterMessageKind.AddItem => ItemGroupIncludeLogMessagePrefix,
+                TaskParameterMessageKind.RemoveItem => ItemGroupRemoveLogMessage,
+                TaskParameterMessageKind.TaskInput => TaskParameterPrefix,
+                TaskParameterMessageKind.TaskOutput => OutputItemParameterMessagePrefix,
+                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {messageKind}")
+            };
+
+            var itemGroupText = GetParameterText(
+                resourceText,
+                itemName,
+                items,
+                logItemMetadata);
+            return itemGroupText;
+        }
     }
 }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 7bf9a69aebc..dc75cd9496e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1333,12 +1333,12 @@ private bool InternalSetTaskParameter(TaskPropertyInfo parameter, IList paramete
                 parameterValue.Count > 0 &&
                 parameter.Log)
             {
-                string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                    ItemGroupLoggingHelper.TaskParameterPrefix,
+                ItemGroupLoggingHelper.LogTaskParameter(
+                    _taskLoggingContext,
+                    TaskParameterMessageKind.TaskInput,
                     parameter.Name,
                     parameterValue,
                     parameter.LogItemMetadata);
-                _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
             }
 
             return InternalSetTaskParameter(parameter, (object)parameterValue);
@@ -1426,11 +1426,16 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
             {
                 if (outputTargetIsItem)
                 {
+                    // Only count non-null elements. We sometimes have a single-element array where the element is null
+                    bool hasElements = false;
+
                     foreach (ITaskItem output in outputs)
                     {
                         // if individual items in the array are null, ignore them
                         if (output != null)
                         {
+                            hasElements = true;
+
                             ProjectItemInstance newItem;
 
                             TaskItem outputAsProjectItem = output as TaskItem;
@@ -1474,15 +1479,14 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         }
                     }
 
-                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
+                    if (hasElements && LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && parameter.Log)
                     {
-                        string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                            ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
+                        ItemGroupLoggingHelper.LogTaskParameter(
+                            _taskLoggingContext,
+                            TaskParameterMessageKind.TaskOutput,
                             outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
-
-                        _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
                 }
                 else
@@ -1553,12 +1557,12 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
 
                     if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
                     {
-                        string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                            ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
+                        ItemGroupLoggingHelper.LogTaskParameter(
+                            _taskLoggingContext,
+                            TaskParameterMessageKind.TaskOutput,
                             outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
-                        _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
                 }
                 else
diff --git a/src/Build/Collections/SmallDictionary.cs b/src/Build/Collections/SmallDictionary.cs
new file mode 100644
index 00000000000..79709cf6333
--- /dev/null
+++ b/src/Build/Collections/SmallDictionary.cs
@@ -0,0 +1,257 @@
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Small, lightweight, read-only IDictionary implementation using two arrays
+    /// and O(n) lookup. Requires specifying capacity at construction and does not
+    /// support reallocation to increase capacity.
+    /// </summary>
+    /// <typeparam name="TKey">Type of keys</typeparam>
+    /// <typeparam name="TValue">Type of values</typeparam>
+    internal class SmallDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary
+    {
+        private TKey[] keys;
+        private TValue[] values;
+
+        private int count;
+
+        public SmallDictionary(int capacity)
+        {
+            keys = new TKey[capacity];
+            values = new TValue[capacity];
+        }
+
+        public static IDictionary<TKey, TValue> Create(int capacity)
+        {
+            return new SmallDictionary<TKey, TValue>(capacity);
+        }
+
+        public TValue this[TKey key]
+        {
+            get
+            {
+                TryGetValue(key, out var value);
+                return value;
+            }
+
+            set
+            {
+                var comparer = KeyComparer;
+                for (int i = 0; i < count; i++)
+                {
+                    if (comparer.Equals(key, keys[i]))
+                    {
+                        values[i] = value;
+                        return;
+                    }
+                }
+
+                Add(key, value);
+            }
+        }
+
+        object IDictionary.this[object key]
+        {
+            get => this[(TKey)key];
+            set => this[(TKey)key] = (TValue)value;
+        }
+
+        public ICollection<TKey> Keys => keys;
+
+        ICollection IDictionary.Keys => keys;
+
+        public ICollection<TValue> Values => values;
+
+        ICollection IDictionary.Values => values;
+
+        private IEqualityComparer<TKey> KeyComparer => EqualityComparer<TKey>.Default;
+
+        private IEqualityComparer<TValue> ValueComparer => EqualityComparer<TValue>.Default;
+
+        public int Count => count;
+
+        public bool IsReadOnly => true;
+
+        bool IDictionary.IsFixedSize => true;
+
+        object ICollection.SyncRoot => this;
+
+        bool ICollection.IsSynchronized => false;
+
+        public void Add(TKey key, TValue value)
+        {
+            if (count < keys.Length)
+            {
+                keys[count] = key;
+                values[count] = value;
+                count += 1;
+            }
+            else
+            {
+                throw new InvalidOperationException($"SmallDictionary is at capacity {keys.Length}");
+            }
+        }
+
+        public void Add(KeyValuePair<TKey, TValue> item)
+        {
+            Add(item.Key, item.Value);
+        }
+
+        public void Clear()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool Contains(KeyValuePair<TKey, TValue> item)
+        {
+            var keyComparer = KeyComparer;
+            var valueComparer = ValueComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (keyComparer.Equals(item.Key, keys[i]) && valueComparer.Equals(item.Value, values[i]))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public bool ContainsKey(TKey key)
+        {
+            var comparer = KeyComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (comparer.Equals(key, keys[i]))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
+        {
+            for (int i = 0; i < count; i++)
+            {
+                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(keys[i], values[i]);
+            }
+        }
+
+        void ICollection.CopyTo(Array array, int index)
+        {
+            throw new NotImplementedException();
+        }
+
+        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
+        {
+            return new Enumerator(this);
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+
+        IDictionaryEnumerator IDictionary.GetEnumerator()
+        {
+            return new Enumerator(this, emitDictionaryEntries: true);
+        }
+
+        public bool Remove(TKey key)
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool Remove(KeyValuePair<TKey, TValue> item)
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool TryGetValue(TKey key, out TValue value)
+        {
+            var comparer = KeyComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (comparer.Equals(key, keys[i]))
+                {
+                    value = values[i];
+                    return true;
+                }
+            }
+
+            value = default;
+            return false;
+        }
+
+        bool IDictionary.Contains(object key)
+        {
+            if (key is not TKey typedKey)
+            {
+                return false;
+            }
+
+            return ContainsKey(typedKey);
+        }
+
+        void IDictionary.Add(object key, object value)
+        {
+            if (key is TKey typedKey && value is TValue typedValue)
+            {
+                Add(typedKey, typedValue);
+            }
+
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Remove(object key)
+        {
+            throw new NotImplementedException();
+        }
+
+        private struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>, IDictionaryEnumerator
+        {
+            private readonly SmallDictionary<TKey, TValue> _dictionary;
+            private readonly bool _emitDictionaryEntries;
+            private int _position;
+
+            public Enumerator(SmallDictionary<TKey, TValue> dictionary, bool emitDictionaryEntries = false)
+            {
+                this._dictionary = dictionary;
+                this._position = -1;
+                this._emitDictionaryEntries = emitDictionaryEntries;
+            }
+
+            public KeyValuePair<TKey, TValue> Current =>
+                new KeyValuePair<TKey, TValue>(
+                    _dictionary.keys[_position],
+                    _dictionary.values[_position]);
+
+            private DictionaryEntry CurrentDictionaryEntry => new DictionaryEntry(_dictionary.keys[_position], _dictionary.values[_position]);
+
+            object IEnumerator.Current => _emitDictionaryEntries ? CurrentDictionaryEntry : Current;
+
+            object IDictionaryEnumerator.Key => _dictionary.keys[_position];
+
+            object IDictionaryEnumerator.Value => _dictionary.values[_position];
+
+            DictionaryEntry IDictionaryEnumerator.Entry => CurrentDictionaryEntry;
+
+            public void Dispose()
+            {
+            }
+
+            public bool MoveNext()
+            {
+                _position += 1;
+                return _position < _dictionary.Count;
+            }
+
+            public void Reset()
+            {
+                throw new NotImplementedException();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 6200da27e43..8a385864cd8 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -28,7 +28,13 @@ namespace Microsoft.Build.Execution
     /// and evaluation has already been performed, so it is unnecessary bulk.
     /// </remarks>
     [DebuggerDisplay("{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})")]
-    public class ProjectItemInstance : IItem<ProjectMetadataInstance>, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>
+    public class ProjectItemInstance :
+        IItem<ProjectMetadataInstance>,
+        ITaskItem2,
+        IMetadataTable,
+        ITranslatable,
+        IDeepCloneable<ProjectItemInstance>,
+        IMetadataContainer
     {
         /// <summary>
         /// The project instance to which this item belongs.
@@ -515,6 +521,8 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             return ((ITaskItem2)_taskItem).CloneCustomMetadataEscaped();
         }
 
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.Metadata => _taskItem.Metadata;
+
         #region IMetadataTable Members
 
         /// <summary>
@@ -723,7 +731,11 @@ internal sealed class TaskItem :
 #if FEATURE_APPDOMAIN
             MarshalByRefObject,
 #endif
-            ITaskItem2, IItem<ProjectMetadataInstance>, ITranslatable, IEquatable<TaskItem>
+            ITaskItem2,
+            IItem<ProjectMetadataInstance>,
+            ITranslatable,
+            IEquatable<TaskItem>,
+            IMetadataContainer
         {
             /// <summary>
             /// The source file that defined this item.
@@ -1045,6 +1057,39 @@ internal int DirectMetadataCount
                 get { return (_directMetadata == null) ? 0 : _directMetadata.Count; }
             }
 
+            /// <summary>
+            /// Efficient way to retrieve metadata used by packet serialization
+            /// and binary logger.
+            /// </summary>
+            public IEnumerable<KeyValuePair<string, string>> Metadata
+            {
+                get
+                {
+                    // If we have item definitions, call the expensive property that does the right thing.
+                    // Otherwise use _directMetadata to avoid allocations caused by DeepClone().
+                    var list = _itemDefinitions != null ? MetadataCollection : _directMetadata;
+                    if (list != null)
+                    {
+                        return EnumerateMetadata(list);
+                    }
+                    else
+                    {
+                        return Array.Empty<KeyValuePair<string, string>>();
+                    }
+                }
+            }
+
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            {
+                foreach (var projectMetadataInstance in list)
+                {
+                    if (projectMetadataInstance != null)
+                    {
+                        yield return new KeyValuePair<string, string>(projectMetadataInstance.Name, projectMetadataInstance.EvaluatedValue);
+                    }
+                }
+            }
+
             /// <summary>
             /// Unordered collection of evaluated metadata on the item.
             /// If there is no metadata, returns an empty collection.
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index d8c90800210..dcb22fc4979 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -27,5 +27,6 @@ internal enum BinaryLogRecordKind
         PropertyInitialValueSet,
         NameValueList,
         String,
+        TaskParameter
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index c6456c1a759..e4dc9c80b9c 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -2,6 +2,7 @@
 using System.IO;
 using System.IO.Compression;
 using System.Threading;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -14,6 +15,14 @@ namespace Microsoft.Build.Logging
     /// <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>
     public sealed class BinaryLogReplayEventSource : EventArgsDispatcher
     {
+        /// Touches the <see cref="ItemGroupLoggingHelper"/> static constructor
+        /// to ensure it initializes <see cref="TaskParameterEventArgs.MessageGetter"/>
+        /// and <see cref="TaskParameterEventArgs.DictionaryFactory"/>
+        static BinaryLogReplayEventSource()
+        {
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+        }
+
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
         /// </summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index f9e9cb0b295..5274f54ab3a 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -41,7 +41,9 @@ public sealed class BinaryLogger : ILogger
         //      * NameValueList - deduplicate arrays of name-value pairs such as properties, items and metadata
         //                        in a separate record and refer to those records from regular records
         //                        where a list used to be written in-place
-        internal const int FileFormatVersion = 10;
+        // version 11:
+        //   - new record kind: TaskParameterEventArgs
+        internal const int FileFormatVersion = 11;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index bd9ae6e9481..30788ca6d8a 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -4,8 +4,11 @@
 using System.IO;
 using System.Reflection;
 using System.Text;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
 {
@@ -29,6 +32,8 @@ public class BuildEventArgsReader : IDisposable
         /// <summary>
         /// A list of dictionaries we've encountered so far. Dictionaries are referred to by their order in this list.
         /// </summary>
+        /// <remarks>This is designed to not hold on to strings. We just store the string indices and
+        /// hydrate the dictionary on demand before returning.</remarks>
         private readonly List<(int keyIndex, int valueIndex)[]> nameValueListRecords = new List<(int, int)[]>();
 
         /// <summary>
@@ -146,6 +151,9 @@ public BuildEventArgs Read()
                 case BinaryLogRecordKind.TaskCommandLine:
                     result = ReadTaskCommandLineEventArgs();
                     break;
+                case BinaryLogRecordKind.TaskParameter:
+                    result = ReadTaskParameterEventArgs();
+                    break;
                 case BinaryLogRecordKind.ProjectEvaluationStarted:
                     result = ReadProjectEvaluationStartedEventArgs();
                     break;
@@ -215,14 +223,17 @@ private IDictionary<string, string> GetNameValueList(int id)
             {
                 var list = nameValueListRecords[id];
 
-                var dictionary = new Dictionary<string, string>(list.Length);
+                // We can't cache these as they would hold on to strings.
+                // This reader is designed to not hold onto strings,
+                // so that we can fit in a 32-bit process when reading huge binlogs
+                var dictionary = SmallDictionary<string, string>.Create(list.Length);
                 for (int i = 0; i < list.Length; i++)
                 {
                     string key = GetStringFromRecord(list[i].keyIndex);
                     string value = GetStringFromRecord(list[i].valueIndex);
                     if (key != null)
                     {
-                        dictionary[key] = value;
+                        dictionary.Add(key, value);
                     }
                 }
 
@@ -596,6 +607,27 @@ private BuildEventArgs ReadTaskCommandLineEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadTaskParameterEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            // Read unused Importance, it defaults to Low
+            ReadInt32();
+
+            var kind = (TaskParameterMessageKind)ReadInt32();
+            var itemName = ReadDeduplicatedString();
+            var items = ReadTaskItemList() as IList;
+
+            var e = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
+                fields.BuildEventContext,
+                kind,
+                itemName,
+                items,
+                true,
+                fields.Timestamp);
+            e.ProjectFile = fields.ProjectFile;
+            return e;
+        }
+
         private BuildEventArgs ReadCriticalBuildMessageEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
@@ -896,65 +928,12 @@ private IDictionary<string, string> ReadLegacyStringDictionary()
             return result;
         }
 
-        private class TaskItem : ITaskItem
-        {
-            private static readonly Dictionary<string, string> emptyMetadata = new Dictionary<string, string>();
-
-            public string ItemSpec { get; set; }
-            public IDictionary<string, string> Metadata { get; }
-
-            public TaskItem()
-            {
-                Metadata = new Dictionary<string, string>();
-            }
-
-            public TaskItem(string itemSpec, IDictionary<string, string> metadata)
-            {
-                ItemSpec = itemSpec;
-                Metadata = metadata ?? emptyMetadata;
-            }
-
-            public int MetadataCount => Metadata.Count;
-
-            public ICollection MetadataNames => (ICollection)Metadata.Keys;
-
-            public IDictionary CloneCustomMetadata()
-            {
-                return (IDictionary)Metadata;
-            }
-
-            public void CopyMetadataTo(ITaskItem destinationItem)
-            {
-                throw new NotImplementedException();
-            }
-
-            public string GetMetadata(string metadataName)
-            {
-                return Metadata[metadataName];
-            }
-
-            public void RemoveMetadata(string metadataName)
-            {
-                throw new NotImplementedException();
-            }
-
-            public void SetMetadata(string metadataName, string metadataValue)
-            {
-                throw new NotImplementedException();
-            }
-
-            public override string ToString()
-            {
-                return $"{ItemSpec} Metadata: {MetadataCount}";
-            }
-        }
-
         private ITaskItem ReadTaskItem()
         {
             string itemSpec = ReadDeduplicatedString();
             var metadata = ReadStringDictionary();
 
-            var taskItem = new TaskItem(itemSpec, metadata);
+            var taskItem = new TaskItemData(itemSpec, metadata);
             return taskItem;
         }
 
@@ -1079,7 +1058,10 @@ private string GetStringFromRecord(int index)
 
         private int ReadInt32()
         {
-            return Read7BitEncodedInt(binaryReader);
+            // on some platforms (net5) this method was added to BinaryReader
+            // but it's not available on others. Call our own extension method
+            // explicitly to avoid ambiguity.
+            return BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
         }
 
         private long ReadInt64()
@@ -1102,30 +1084,6 @@ private TimeSpan ReadTimeSpan()
             return new TimeSpan(binaryReader.ReadInt64());
         }
 
-        private int Read7BitEncodedInt(BinaryReader reader)
-        {
-            // Read out an Int32 7 bits at a time.  The high bit
-            // of the byte when on means to continue reading more bytes.
-            int count = 0;
-            int shift = 0;
-            byte b;
-            do
-            {
-                // Check for a corrupted stream.  Read a max of 5 bytes.
-                // In a future version, add a DataFormatException.
-                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7
-                {
-                    throw new FormatException();
-                }
-
-                // ReadByte handles end of stream cases for us.
-                b = reader.ReadByte();
-                count |= (b & 0x7F) << shift;
-                shift += 7;
-            } while ((b & 0x80) != 0);
-            return count;
-        }
-
         private ProfiledLocation ReadProfiledLocation()
         {
             var numberOfHits = ReadInt32();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 3b37d1404cf..65b0f3727b6 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -4,10 +4,13 @@
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
 {
@@ -129,57 +132,57 @@ public void Write(BuildEventArgs e)
         private void WriteCore(BuildEventArgs e)
         {
             // the cases are ordered by most used first for performance
-            if (e is BuildMessageEventArgs)
+            if (e is BuildMessageEventArgs buildMessage)
             {
-                Write((BuildMessageEventArgs)e);
+                Write(buildMessage);
             }
-            else if (e is TaskStartedEventArgs)
+            else if (e is TaskStartedEventArgs taskStarted)
             {
-                Write((TaskStartedEventArgs)e);
+                Write(taskStarted);
             }
-            else if (e is TaskFinishedEventArgs)
+            else if (e is TaskFinishedEventArgs taskFinished)
             {
-                Write((TaskFinishedEventArgs)e);
+                Write(taskFinished);
             }
-            else if (e is TargetStartedEventArgs)
+            else if (e is TargetStartedEventArgs targetStarted)
             {
-                Write((TargetStartedEventArgs)e);
+                Write(targetStarted);
             }
-            else if (e is TargetFinishedEventArgs)
+            else if (e is TargetFinishedEventArgs targetFinished)
             {
-                Write((TargetFinishedEventArgs)e);
+                Write(targetFinished);
             }
-            else if (e is BuildErrorEventArgs)
+            else if (e is BuildErrorEventArgs buildError)
             {
-                Write((BuildErrorEventArgs)e);
+                Write(buildError);
             }
-            else if (e is BuildWarningEventArgs)
+            else if (e is BuildWarningEventArgs buildWarning)
             {
-                Write((BuildWarningEventArgs)e);
+                Write(buildWarning);
             }
-            else if (e is ProjectStartedEventArgs)
+            else if (e is ProjectStartedEventArgs projectStarted)
             {
-                Write((ProjectStartedEventArgs)e);
+                Write(projectStarted);
             }
-            else if (e is ProjectFinishedEventArgs)
+            else if (e is ProjectFinishedEventArgs projectFinished)
             {
-                Write((ProjectFinishedEventArgs)e);
+                Write(projectFinished);
             }
-            else if (e is BuildStartedEventArgs)
+            else if (e is BuildStartedEventArgs buildStarted)
             {
-                Write((BuildStartedEventArgs)e);
+                Write(buildStarted);
             }
-            else if (e is BuildFinishedEventArgs)
+            else if (e is BuildFinishedEventArgs buildFinished)
             {
-                Write((BuildFinishedEventArgs)e);
+                Write(buildFinished);
             }
-            else if (e is ProjectEvaluationStartedEventArgs)
+            else if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)
             {
-                Write((ProjectEvaluationStartedEventArgs)e);
+                Write(projectEvaluationStarted);
             }
-            else if (e is ProjectEvaluationFinishedEventArgs)
+            else if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinished)
             {
-                Write((ProjectEvaluationFinishedEventArgs)e);
+                Write(projectEvaluationFinished);
             }
             else
             {
@@ -389,51 +392,57 @@ private void Write(BuildWarningEventArgs e)
 
         private void Write(BuildMessageEventArgs e)
         {
-            if (e is CriticalBuildMessageEventArgs)
+            if (e is TaskParameterEventArgs taskParameter)
             {
-                Write((CriticalBuildMessageEventArgs)e);
+                Write(taskParameter);
                 return;
             }
 
-            if (e is TaskCommandLineEventArgs)
+            if (e is CriticalBuildMessageEventArgs criticalBuildMessage)
             {
-                Write((TaskCommandLineEventArgs)e);
+                Write(criticalBuildMessage);
                 return;
             }
 
-            if (e is ProjectImportedEventArgs)
+            if (e is TaskCommandLineEventArgs taskCommandLine)
             {
-                Write((ProjectImportedEventArgs)e);
+                Write(taskCommandLine);
                 return;
             }
 
-            if (e is TargetSkippedEventArgs)
+            if (e is ProjectImportedEventArgs projectImported)
             {
-                Write((TargetSkippedEventArgs)e);
+                Write(projectImported);
                 return;
             }
 
-            if (e is PropertyReassignmentEventArgs)
+            if (e is TargetSkippedEventArgs targetSkipped)
             {
-                Write((PropertyReassignmentEventArgs)e);
+                Write(targetSkipped);
                 return;
             }
 
-            if (e is UninitializedPropertyReadEventArgs)
+            if (e is PropertyReassignmentEventArgs propertyReassignment)
             {
-                Write((UninitializedPropertyReadEventArgs)e);
+                Write(propertyReassignment);
                 return;
             }
 
-            if (e is EnvironmentVariableReadEventArgs)
+            if (e is UninitializedPropertyReadEventArgs uninitializedPropertyRead)
             {
-                Write((EnvironmentVariableReadEventArgs)e);
+                Write(uninitializedPropertyRead);
                 return;
             }
 
-            if (e is PropertyInitialValueSetEventArgs)
+            if (e is EnvironmentVariableReadEventArgs environmentVariableRead)
             {
-                Write((PropertyInitialValueSetEventArgs)e);
+                Write(environmentVariableRead);
+                return;
+            }
+
+            if (e is PropertyInitialValueSetEventArgs propertyInitialValueSet)
+            {
+                Write(propertyInitialValueSet);
                 return;
             }
 
@@ -507,9 +516,18 @@ private void Write(TaskCommandLineEventArgs e)
             WriteDeduplicatedString(e.TaskName);
         }
 
-        private void WriteBuildEventArgsFields(BuildEventArgs e)
+        private void Write(TaskParameterEventArgs e)
         {
-            var flags = GetBuildEventArgsFieldFlags(e);
+            Write(BinaryLogRecordKind.TaskParameter);
+            WriteMessageFields(e, writeMessage: false);
+            Write((int)e.Kind);
+            WriteDeduplicatedString(e.ItemName);
+            WriteTaskItemList(e.Items, e.LogItemMetadata);
+        }
+
+        private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true)
+        {
+            var flags = GetBuildEventArgsFieldFlags(e, writeMessage);
             Write((int)flags);
             WriteBaseFields(e, flags);
         }
@@ -547,9 +565,9 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
             }
         }
 
-        private void WriteMessageFields(BuildMessageEventArgs e)
+        private void WriteMessageFields(BuildMessageEventArgs e, bool writeMessage = true)
         {
-            var flags = GetBuildEventArgsFieldFlags(e);
+            var flags = GetBuildEventArgsFieldFlags(e, writeMessage);
             flags = GetMessageFlags(e, flags);
 
             Write((int)flags);
@@ -644,7 +662,7 @@ private static BuildEventArgsFieldFlags GetMessageFlags(BuildMessageEventArgs e,
             return flags;
         }
 
-        private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e)
+        private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e, bool writeMessage = true)
         {
             var flags = BuildEventArgsFieldFlags.None;
             if (e.BuildEventContext != null)
@@ -657,7 +675,7 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
                 flags |= BuildEventArgsFieldFlags.HelpHeyword;
             }
 
-            if (!string.IsNullOrEmpty(e.Message))
+            if (writeMessage)
             {
                 flags |= BuildEventArgsFieldFlags.Message;
             }
@@ -681,21 +699,68 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
             return flags;
         }
 
-        private void WriteTaskItemList(IEnumerable items)
+        private readonly List<object> reusableItemsList = new List<object>();
+
+        private void WriteTaskItemList(IEnumerable items, bool writeMetadata = true)
         {
-            var taskItems = items as IEnumerable<ITaskItem>;
-            if (taskItems == null)
+            if (items == null)
             {
                 Write(false);
                 return;
             }
 
-            Write(taskItems.Count());
+            // For target outputs bypass copying of all items to save on performance.
+            // The proxy creates a deep clone of each item to protect against writes,
+            // but since we're not writing we don't need the deep cloning.
+            // Additionally, it is safe to access the underlying List<ITaskItem> as it's allocated
+            // in a single location and noboby else mutates it after that:
+            // https://github.com/dotnet/msbuild/blob/f0eebf2872d76ab0cd43fdc4153ba636232b222f/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs#L564
+            if (items is TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy proxy)
+            {
+                items = proxy.BackingItems;
+            }
+
+            int count;
+
+            if (items is ICollection arrayList)
+            {
+                count = arrayList.Count;
+            }
+            else if (items is ICollection<ITaskItem> genericList)
+            {
+                count = genericList.Count;
+            }
+            else
+            {
+                // enumerate only once
+                foreach (var item in items)
+                {
+                    if (item != null)
+                    {
+                        reusableItemsList.Add(item);
+                    }
+                }
+
+                items = reusableItemsList;
+                count = reusableItemsList.Count;
+            }
+
+            Write(count);
 
-            foreach (var item in taskItems)
+            foreach (var item in items)
             {
-                Write(item);
+                if (item is ITaskItem taskItem)
+                {
+                    Write(taskItem, writeMetadata);
+                }
+                else
+                {
+                    WriteDeduplicatedString(item?.ToString() ?? ""); // itemspec
+                    Write(0); // no metadata
+                }
             }
+
+            reusableItemsList.Clear();
         }
 
         private void WriteProjectItems(IEnumerable items)
@@ -721,40 +786,32 @@ private void WriteProjectItems(IEnumerable items)
             }
         }
 
-        private void Write(ITaskItem item)
+        private void Write(ITaskItem item, bool writeMetadata = true)
         {
             WriteDeduplicatedString(item.ItemSpec);
-
-            nameValueListBuffer.Clear();
-
-            IDictionary customMetadata = item.CloneCustomMetadata();
-
-            foreach (string metadataName in customMetadata.Keys)
+            if (!writeMetadata)
             {
-                string valueOrError;
+                Write((byte)0);
+                return;
+            }
 
-                try
-                {
-                    valueOrError = item.GetMetadata(metadataName);
-                }
-                catch (InvalidProjectFileException e)
-                {
-                    valueOrError = e.Message;
-                }
-                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in
-                // the logging code until CopyOnWritePropertyDictionary is replaced with
-                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case
-                // the exception occures in Debug builds.
-                catch (Exception e)
-                {
-                    valueOrError = e.Message;
-                    Debug.Fail(e.ToString());
-                }
+            // WARNING: Can't use AddRange here because CopyOnWriteDictionary in Microsoft.Build.Utilities.v4.0.dll
+            // is broken. Microsoft.Build.Utilities.v4.0.dll loads from the GAC by XAML markup tooling and it's
+            // implementation doesn't work with AddRange because AddRange special-cases ICollection<T> and
+            // CopyOnWriteDictionary doesn't implement it properly.
+            foreach (var kvp in item.EnumerateMetadata())
+            {
+                nameValueListBuffer.Add(kvp);
+            }
 
-                nameValueListBuffer.Add(new KeyValuePair<string, string>(metadataName, valueOrError));
+            if (nameValueListBuffer.Count > 1)
+            {
+                nameValueListBuffer.Sort((l, r) => StringComparer.OrdinalIgnoreCase.Compare(l.Key, r.Key));
             }
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void WriteProperties(IEnumerable properties)
@@ -765,8 +822,6 @@ private void WriteProperties(IEnumerable properties)
                 return;
             }
 
-            nameValueListBuffer.Clear();
-
             // there are no guarantees that the properties iterator won't change, so 
             // take a snapshot and work with the readonly copy
             var propertiesArray = properties.OfType<DictionaryEntry>().ToArray();
@@ -785,6 +840,8 @@ private void WriteProperties(IEnumerable properties)
             }
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void Write(BuildEventContext buildEventContext)
@@ -800,8 +857,6 @@ private void Write(BuildEventContext buildEventContext)
 
         private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
         {
-            nameValueListBuffer.Clear();
-
             if (keyValuePairs != null)
             {
                 foreach (var kvp in keyValuePairs)
@@ -811,6 +866,8 @@ private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
             }
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void WriteNameValueList()
@@ -893,7 +950,7 @@ private void Write(BinaryLogRecordKind kind)
 
         private void Write(int value)
         {
-            Write7BitEncodedInt(binaryWriter, value);
+            BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, value);
         }
 
         private void Write(long value)
@@ -901,19 +958,6 @@ private void Write(long value)
             binaryWriter.Write(value);
         }
 
-        private void Write7BitEncodedInt(BinaryWriter writer, int value)
-        {
-            // Write out an int 7 bits at a time.  The high bit of the byte,
-            // when on, tells reader to continue reading more bytes.
-            uint v = (uint)value;   // support negative numbers
-            while (v >= 0x80)
-            {
-                writer.Write((byte)(v | 0x80));
-                v >>= 7;
-            }
-            writer.Write((byte)v);
-        }
-
         private void Write(byte[] bytes)
         {
             binaryWriter.Write(bytes);
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 01a5fd018d2..75c281d1db6 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -375,6 +375,7 @@
     <Compile Include="Collections\ReadOnlyConvertingDictionary.cs" />
     <!-- ######################## -->
     <Compile Include="Collections\WeakValueDictionary.cs" />
+    <Compile Include="Collections\SmallDictionary.cs" />
     <!-- #### CONSTRUCTION MODEL ### -->
     <Compile Include="Construction\ProjectElement.cs" />
     <Compile Include="Construction\ProjectElementContainer.cs" />
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 1592e8fd480..58dc81f838a 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -111,6 +111,17 @@ public DateTime Timestamp
             }
         }
 
+        /// <summary>
+        /// Exposes the private <see cref="timestamp"/> field to derived types.
+        /// Used for serialization. Avoids the side effects of calling the
+        /// <see cref="Timestamp"/> getter.
+        /// </summary>
+        protected DateTime RawTimestamp
+        {
+            get => timestamp;
+            set => timestamp = value;
+        }
+
         /// <summary>
         /// The thread that raised event.  
         /// </summary>
@@ -155,24 +166,8 @@ internal virtual void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(helpKeyword);
             writer.WriteOptionalString(senderName);
             writer.WriteTimestamp(timestamp);
-
-            writer.Write((Int32)threadId);
-
-            if (buildEventContext == null)
-            {
-                writer.Write((byte)0);
-            }
-            else
-            {
-                writer.Write((byte)1);
-                writer.Write((Int32)buildEventContext.NodeId);
-                writer.Write((Int32)buildEventContext.ProjectContextId);
-                writer.Write((Int32)buildEventContext.TargetId);
-                writer.Write((Int32)buildEventContext.TaskId);
-                writer.Write((Int32)buildEventContext.SubmissionId);
-                writer.Write((Int32)buildEventContext.ProjectInstanceId);
-                writer.Write((Int32)buildEventContext.EvaluationId);
-            }
+            writer.Write(threadId);
+            writer.WriteOptionalBuildEventContext(buildEventContext);
         }
 
         /// <summary>
@@ -182,9 +177,9 @@ internal virtual void WriteToStream(BinaryWriter writer)
         /// <param name="version">The version of the runtime the message packet was created from</param>
         internal virtual void CreateFromStream(BinaryReader reader, int version)
         {
-            message = reader.ReadByte() == 0 ? null : reader.ReadString();
-            helpKeyword = reader.ReadByte() == 0 ? null : reader.ReadString();
-            senderName = reader.ReadByte() == 0 ? null : reader.ReadString();
+            message = reader.ReadOptionalString();
+            helpKeyword = reader.ReadOptionalString();
+            senderName = reader.ReadOptionalString();
 
             long timestampTicks = reader.ReadInt64();
 
diff --git a/src/Framework/IMetadataContainer.cs b/src/Framework/IMetadataContainer.cs
new file mode 100644
index 00000000000..121c80a813e
--- /dev/null
+++ b/src/Framework/IMetadataContainer.cs
@@ -0,0 +1,22 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Provides a way to efficiently enumerate item metadata
+    /// </summary>
+    internal interface IMetadataContainer
+    {
+        /// <summary>
+        /// Returns a list of metadata names and unescaped values, including
+        /// metadata from item definition groups, but not including built-in
+        /// metadata. Implementations should be low-overhead as the method
+        /// is used for serialization (in node packet translator) as well as
+        /// in the binary logger.
+        /// </summary>
+        IEnumerable<KeyValuePair<string, string>> Metadata { get; }
+    }
+}
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
new file mode 100644
index 00000000000..7315d29ade3
--- /dev/null
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -0,0 +1,65 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Framework
+{
+    internal static class ITaskItemExtensions
+    {
+        /// <summary>
+        /// Provides a way to efficiently enumerate custom metadata of an item, without built-in metadata.
+        /// </summary>
+        /// <param name="taskItem">TaskItem implementation to return metadata from</param>
+        /// <remarks>WARNING: do NOT use List`1.AddRange to iterate over this collection.
+        /// CopyOnWriteDictionary from Microsoft.Build.Utilities.v4.0.dll is broken.</remarks>
+        /// <returns>A non-null (but possibly empty) enumerable of item metadata.</returns>
+        public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this ITaskItem taskItem)
+        {
+            if (taskItem is IMetadataContainer container)
+            {
+                // This is the common case: most implementations should implement this for quick access
+                return container.Metadata;
+            }
+
+            // This runs if ITaskItem is Microsoft.Build.Utilities.TaskItem from Microsoft.Build.Utilities.v4.0.dll
+            // that is loaded from the GAC.
+            IDictionary customMetadata = taskItem.CloneCustomMetadata();
+            if (customMetadata is IEnumerable<KeyValuePair<string, string>> enumerableMetadata)
+            {
+                return enumerableMetadata;
+            }
+
+            // In theory this should never be reachable.
+            var list = new KeyValuePair<string, string>[customMetadata.Count];
+            int i = 0;
+
+            foreach (string metadataName in customMetadata.Keys)
+            {
+                string valueOrError;
+
+                try
+                {
+                    valueOrError = taskItem.GetMetadata(metadataName);
+                }
+                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in
+                // the logging code until CopyOnWritePropertyDictionary is replaced with
+                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case
+                // the exception occurres in Debug builds.
+                catch (Exception e)
+                {
+                    valueOrError = e.Message;
+                    Debug.Fail(e.ToString());
+                }
+
+                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);
+                i += 1;
+            }
+
+            return list;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 59296adc225..939d7db72f7 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -8,9 +8,6 @@
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">partial</ApplyNgenOptimization>
   </PropertyGroup>
-  <ItemGroup>
-    <Compile Remove="BinaryWriterExtensions.cs" />
-  </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Security.Permissions" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
@@ -21,6 +18,9 @@
     <Compile Include="..\Shared\Constants.cs">
       <Link>Shared\Constants.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\BinaryReaderExtensions.cs">
+      <Link>Shared\BinaryReaderExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\BinaryWriterExtensions.cs">
       <Link>Shared\BinaryWriterExtensions.cs</Link>
     </Compile>
diff --git a/src/Framework/TaskItemData.cs b/src/Framework/TaskItemData.cs
new file mode 100644
index 00000000000..c9d7e09fb33
--- /dev/null
+++ b/src/Framework/TaskItemData.cs
@@ -0,0 +1,68 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Lightweight specialized implementation of ITaskItem only used for deserializing items.
+    /// The goal is to minimize overhead when representing deserialized items.
+    /// Used by node packet translator and binary logger.
+    /// </summary>
+    internal class TaskItemData : ITaskItem, IMetadataContainer
+    {
+        private static readonly Dictionary<string, string> _emptyMetadata = new Dictionary<string, string>();
+
+        public string ItemSpec { get; set; }
+        public IDictionary<string, string> Metadata { get; }
+
+        public TaskItemData(string itemSpec, IDictionary<string, string> metadata)
+        {
+            ItemSpec = itemSpec;
+            Metadata = metadata ?? _emptyMetadata;
+        }
+
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.Metadata => Metadata;
+
+        public int MetadataCount => Metadata.Count;
+
+        public ICollection MetadataNames => (ICollection)Metadata.Keys;
+
+        public IDictionary CloneCustomMetadata()
+        {
+            // against the guidance for CloneCustomMetadata this returns the original collection.
+            // Since this is only to be used for serialization and logging, consumers should not
+            // modify the collection. We need to minimize allocations so avoid cloning here.
+            return (IDictionary)Metadata;
+        }
+
+        public void CopyMetadataTo(ITaskItem destinationItem)
+        {
+            throw new NotImplementedException();
+        }
+
+        public string GetMetadata(string metadataName)
+        {
+            Metadata.TryGetValue(metadataName, out var result);
+            return result;
+        }
+
+        public void RemoveMetadata(string metadataName)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void SetMetadata(string metadataName, string metadataValue)
+        {
+            throw new NotImplementedException();
+        }
+
+        public override string ToString()
+        {
+            return $"{ItemSpec} Metadata: {MetadataCount}";
+        }
+    }
+}
diff --git a/src/Framework/TaskParameterEventArgs.cs b/src/Framework/TaskParameterEventArgs.cs
new file mode 100644
index 00000000000..8f8e484fc38
--- /dev/null
+++ b/src/Framework/TaskParameterEventArgs.cs
@@ -0,0 +1,225 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Text;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework
+{
+    public enum TaskParameterMessageKind
+    {
+        TaskInput,
+        TaskOutput,
+        AddItem,
+        RemoveItem,
+    }
+
+    /// <summary>
+    /// This class is used by tasks to log their parameters (input, output).
+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also
+    /// uses this class.
+    /// </summary>
+    public class TaskParameterEventArgs : BuildMessageEventArgs
+    {
+        /// <summary>
+        /// Creates an instance of this class for the given task parameter.
+        /// </summary>
+        public TaskParameterEventArgs
+        (
+            TaskParameterMessageKind kind,
+            string itemName,
+            IList items,
+            bool logItemMetadata,
+            DateTime eventTimestamp
+        )
+            : base(null, null, null, MessageImportance.Low, eventTimestamp)
+        {
+            Kind = kind;
+            ItemName = itemName;
+            Items = items;
+            LogItemMetadata = logItemMetadata;
+        }
+
+        public TaskParameterMessageKind Kind { get; private set; }
+        public string ItemName { get; private set; }
+        public IList Items { get; private set; }
+        public bool LogItemMetadata { get; private set; }
+
+        /// <summary>
+        /// The <see cref="TaskParameterEventArgs"/> type is declared in Microsoft.Build.Framework.dll
+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build.dll
+        /// which is an implementations assembly. This seems like the easiest way to inject the
+        /// implementation for realizing the Message.
+        /// </summary>
+        /// <remarks>Note that the current implementation never runs and is provided merely
+        /// as a safeguard in case MessageGetter isn't set for some reason.</remarks>
+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args =>
+        {
+            var sb = new StringBuilder();
+            sb.AppendLine($"{args.Kind}: {args.ItemName}");
+            foreach (var item in args.Items)
+            {
+                sb.AppendLine(item.ToString());
+            }
+
+            return sb.ToString();
+        };
+
+        /// <summary>
+        /// Provides a way for Microsoft.Build.dll to provide a more efficient dictionary factory
+        /// (using SmallDictionary`2). Since that is an implementation detail, it is not included
+        /// in Microsoft.Build.Framework.dll so we need this extensibility point here.
+        /// </summary>
+        internal static Func<int, IDictionary<string, string>> DictionaryFactory = capacity => new Dictionary<string, string>(capacity);
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            RawTimestamp = reader.ReadTimestamp();
+            BuildEventContext = reader.ReadOptionalBuildEventContext();
+            Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();
+            ItemName = reader.ReadString();
+            Items = ReadItems(reader);
+        }
+
+        private IList ReadItems(BinaryReader reader)
+        {
+            var list = new ArrayList();
+
+            int count = reader.Read7BitEncodedInt();
+            for (int i = 0; i < count; i++)
+            {
+                var item = ReadItem(reader);
+                list.Add(item);
+            }
+
+            return list;
+        }
+
+        private object ReadItem(BinaryReader reader)
+        {
+            string itemSpec = reader.ReadString();
+            int metadataCount = reader.Read7BitEncodedInt();
+            if (metadataCount == 0)
+            {
+                return new TaskItemData(itemSpec, metadata: null);
+            }
+
+            var metadata = DictionaryFactory(metadataCount);
+            for (int i = 0; i < metadataCount; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                if (key != null)
+                {
+                    metadata.Add(key, value);
+                }
+            }
+
+            var taskItem = new TaskItemData(itemSpec, metadata);
+            return taskItem;
+        }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            writer.WriteTimestamp(RawTimestamp);
+            writer.WriteOptionalBuildEventContext(BuildEventContext);
+            writer.Write7BitEncodedInt((int)Kind);
+            writer.Write(ItemName);
+            WriteItems(writer, Items);
+        }
+
+        private void WriteItems(BinaryWriter writer, IList items)
+        {
+            if (items == null)
+            {
+                writer.Write7BitEncodedInt(0);
+                return;
+            }
+
+            int count = items.Count;
+            writer.Write7BitEncodedInt(count);
+
+            for (int i = 0; i < count; i++)
+            {
+                var item = items[i];
+                WriteItem(writer, item);
+            }
+        }
+
+        private void WriteItem(BinaryWriter writer, object item)
+        {
+            if (item is ITaskItem taskItem)
+            {
+                writer.Write(taskItem.ItemSpec);
+                if (LogItemMetadata)
+                {
+                    WriteMetadata(writer, taskItem);
+                }
+                else
+                {
+                    writer.Write7BitEncodedInt(0);
+                }
+            }
+            else // string or ValueType
+            {
+                writer.Write(item?.ToString() ?? "");
+                writer.Write7BitEncodedInt(0);
+            }
+        }
+
+        [ThreadStatic]
+        private static List<KeyValuePair<string, string>> reusableMetadataList;
+
+        private void WriteMetadata(BinaryWriter writer, ITaskItem taskItem)
+        {
+            if (reusableMetadataList == null)
+            {
+                reusableMetadataList = new List<KeyValuePair<string, string>>();
+            }
+
+            // WARNING: Can't use AddRange here because CopyOnWriteDictionary in Microsoft.Build.Utilities.v4.0.dll
+            // is broken. Microsoft.Build.Utilities.v4.0.dll loads from the GAC by XAML markup tooling and it's
+            // implementation doesn't work with AddRange because AddRange special-cases ICollection<T> and
+            // CopyOnWriteDictionary doesn't implement it properly.
+            foreach (var kvp in taskItem.EnumerateMetadata())
+            {
+                reusableMetadataList.Add(kvp);
+            }
+
+            writer.Write7BitEncodedInt(reusableMetadataList.Count);
+            if (reusableMetadataList.Count == 0)
+            {
+                return;
+            }
+
+            foreach (var kvp in reusableMetadataList)
+            {
+                writer.Write(kvp.Key);
+                writer.Write(kvp.Value);
+            }
+
+            reusableMetadataList.Clear();
+        }
+
+        public override string Message
+        {
+            get
+            {
+                lock (this)
+                {
+                    if (base.Message == null)
+                    {
+                        base.Message = MessageGetter(this);
+                    }
+
+                    return base.Message;
+                }
+            }
+        }
+    }
+}
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 0437fdcbb36..8c4de37e038 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -16,7 +16,7 @@
     <RuntimeIdentifiers>win7-x86;win7-x64</RuntimeIdentifiers>
     
     <EnableDefaultItems>false</EnableDefaultItems>
-    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY</DefineConstants>
+    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST</DefineConstants>
     <!-- Need pointers for getting environment block -->
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <!-- It is vital that msbuildtaskhost.exe is allowed to use the full 4GB on 64 bit machines in order to help avoid 
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
new file mode 100644
index 00000000000..f1a1c16c587
--- /dev/null
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -0,0 +1,79 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using System.Runtime.CompilerServices;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class BinaryReaderExtensions
+    {
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static string ReadOptionalString(this BinaryReader reader)
+        {
+            return reader.ReadByte() == 0 ? null : reader.ReadString();
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static int Read7BitEncodedInt(this BinaryReader reader)
+        {
+            // Read out an Int32 7 bits at a time.  The high bit
+            // of the byte when on means to continue reading more bytes.
+            int count = 0;
+            int shift = 0;
+            byte b;
+            do
+            {
+                // Check for a corrupted stream.  Read a max of 5 bytes.
+                // In a future version, add a DataFormatException.
+                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7
+                {
+                    throw new FormatException();
+                }
+
+                // ReadByte handles end of stream cases for us.
+                b = reader.ReadByte();
+                count |= (b & 0x7F) << shift;
+                shift += 7;
+            } while ((b & 0x80) != 0);
+            return count;
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static DateTime ReadTimestamp(this BinaryReader reader)
+        {
+            long timestampTicks = reader.ReadInt64();
+            DateTimeKind kind = (DateTimeKind)reader.ReadInt32();
+            var timestamp = new DateTime(timestampTicks, kind);
+            return timestamp;
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static BuildEventContext ReadOptionalBuildEventContext(this BinaryReader reader)
+        {
+            if (reader.ReadByte() == 0)
+            {
+                return null;
+            }
+
+            return reader.ReadBuildEventContext();
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static BuildEventContext ReadBuildEventContext(this BinaryReader reader)
+        {
+            int nodeId = reader.ReadInt32();
+            int projectContextId = reader.ReadInt32();
+            int targetId = reader.ReadInt32();
+            int taskId = reader.ReadInt32();
+            int submissionId = reader.ReadInt32();
+            int projectInstanceId = reader.ReadInt32();
+            int evaluationId = reader.ReadInt32();
+
+            var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
+            return buildEventContext;
+        }
+    }
+}
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index f4f5b00d73b..946eb483eaa 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -1,6 +1,10 @@
-﻿using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.IO;
 using System.Runtime.CompilerServices;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Shared
 {
@@ -23,8 +27,49 @@ public static void WriteOptionalString(this BinaryWriter writer, string value)
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static void WriteTimestamp(this BinaryWriter writer, DateTime timestamp)
         {
-            writer.Write((Int64)timestamp.Ticks);
+            writer.Write(timestamp.Ticks);
             writer.Write((Int32)timestamp.Kind);
         }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
+        {
+            // Write out an int 7 bits at a time.  The high bit of the byte,
+            // when on, tells reader to continue reading more bytes.
+            uint v = (uint)value;   // support negative numbers
+            while (v >= 0x80)
+            {
+                writer.Write((byte)(v | 0x80));
+                v >>= 7;
+            }
+
+            writer.Write((byte)v);
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void WriteOptionalBuildEventContext(this BinaryWriter writer, BuildEventContext context)
+        {
+            if (context == null)
+            {
+                writer.Write((byte)0);
+            }
+            else
+            {
+                writer.Write((byte)1);
+                writer.WriteBuildEventContext(context);
+            }
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void WriteBuildEventContext(this BinaryWriter writer, BuildEventContext context)
+        {
+            writer.Write(context.NodeId);
+            writer.Write(context.ProjectContextId);
+            writer.Write(context.TargetId);
+            writer.Write(context.TaskId);
+            writer.Write(context.SubmissionId);
+            writer.Write(context.ProjectInstanceId);
+            writer.Write(context.EvaluationId);
+        }
     }
 }
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 497be9de813..ab68c229c04 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -89,7 +89,12 @@ internal enum LoggingEventType : int
         /// <summary>
         /// Event is a TaskCommandLineEventArgs
         /// </summary>
-        TaskCommandLineEvent = 12
+        TaskCommandLineEvent = 12,
+
+        /// <summary>
+        /// Event is a TaskParameterEventArgs
+        /// </summary>
+        TaskParameterEvent = 13,
     }
     #endregion
 
@@ -485,6 +490,10 @@ private BuildEventArgs GetBuildEventArgFromId()
                     return new TaskFinishedEventArgs(null, null, null, null, null, false);
                 case LoggingEventType.TaskCommandLineEvent:
                     return new TaskCommandLineEventArgs(null, null, MessageImportance.Normal);
+#if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
+                case LoggingEventType.TaskParameterEvent:
+                    return new TaskParameterEventArgs(0, null, null, true, default);
+#endif
                 default:
                     ErrorUtilities.VerifyThrow(false, "Should not get to the default of GetBuildEventArgFromId ID: " + _eventType);
                     return null;
@@ -509,6 +518,12 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.TaskCommandLineEvent;
             }
+#if !TASKHOST
+            else if (eventType == typeof(TaskParameterEventArgs))
+            {
+                return LoggingEventType.TaskParameterEvent;
+            }
+#endif
             else if (eventType == typeof(ProjectFinishedEventArgs))
             {
                 return LoggingEventType.ProjectFinishedEvent;
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index ead8151a85b..e26ce6f4ab5 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -5,10 +5,11 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
+using System.Reflection;
 using System.Security;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Reflection;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -492,7 +493,11 @@ private class TaskParameterTaskItem :
 #if FEATURE_APPDOMAIN
             MarshalByRefObject,
 #endif
-            ITaskItem, ITaskItem2
+            ITaskItem,
+            ITaskItem2
+#if !TASKHOST
+            ,IMetadataContainer
+#endif
         {
             /// <summary>
             /// The item spec 
@@ -751,6 +756,23 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
                 IDictionary clonedDictionary = new Dictionary<string, string>(_customEscapedMetadata);
                 return clonedDictionary;
             }
+
+            public IEnumerable<KeyValuePair<string, string>> Metadata
+            {
+                get
+                {
+                    if (_customEscapedMetadata == null)
+                    {
+                        yield break;
+                    }
+
+                    foreach (var kvp in _customEscapedMetadata)
+                    {
+                        var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));
+                        yield return unescaped;
+                    }
+                }
+            }
         }
     }
 }
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index a2bb6693c41..d7f38122a0c 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Linq;
 using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
@@ -30,7 +31,8 @@ public sealed class TaskItem :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        ITaskItem2
+        ITaskItem2,
+        IMetadataContainer // expose direct underlying metadata for fast access in binary logger
     {
         #region Member Data
 
@@ -460,5 +462,22 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped() => _metadata == null
             : _metadata.Clone();
 
         #endregion
+
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.Metadata
+        {
+            get
+            {
+                if (_metadata == null)
+                {
+                    yield break;
+                }
+
+                foreach (var kvp in _metadata)
+                {
+                    var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));
+                    yield return unescaped;
+                }
+            }
+        }
     }
-}
+}
\ No newline at end of file
