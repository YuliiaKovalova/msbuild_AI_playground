diff --git a/eng/Common.globalconfig b/eng/Common.globalconfig
index ca4efcfa87b..d4bf7db5cde 100644
--- a/eng/Common.globalconfig
+++ b/eng/Common.globalconfig
@@ -1197,9 +1197,6 @@ dotnet_diagnostic.IDE0049.severity = suggestion
 # Use compound assignment
 dotnet_diagnostic.IDE0054.severity = suggestion
 
-# Fix formatting
-dotnet_diagnostic.IDE0055.severity = suggestion
-
 # Indexing can be simplified
 dotnet_diagnostic.IDE0056.severity = suggestion
 
diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index bc6e78a22fd..2faf2cc786a 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -1014,7 +1014,7 @@ public static IEnumerable<object[]> InsertMetadataAttributeAfterSiblingsTestData
             }
         }
 
-        [Theory(Skip= "https://github.com/dotnet/msbuild/issues/1253")]
+        [Theory(Skip = "https://github.com/dotnet/msbuild/issues/1253")]
         [MemberData(nameof(InsertMetadataAttributeAfterSiblingsTestData))]
         public void InsertMetadataAttributeAfterSiblings(AddMetadata addMetadata, int position, string expectedItem)
         {
@@ -1078,7 +1078,7 @@ public static IEnumerable<object[]> InsertMetadataAttributeBeforeSiblingsTestDat
             }
         }
 
-        [Theory(Skip= "https://github.com/dotnet/msbuild/issues/1253")]
+        [Theory(Skip = "https://github.com/dotnet/msbuild/issues/1253")]
         [MemberData(nameof(InsertMetadataAttributeBeforeSiblingsTestData))]
         public void InsertMetadataAttributeBeforeSiblings(AddMetadata addMetadata, int position, string expectedItem)
         {
diff --git a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
index 7e565c36f69..0386b296628 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
@@ -267,7 +267,7 @@ public void ProjectRemoveItemFormatting()
 
             var itemToRemove = project.GetItems("Compile").Single(item => item.EvaluatedInclude == "Class2.cs");
             project.RemoveItem(itemToRemove);
-            
+
             StringWriter writer = new StringWriter();
             project.Save(writer);
 
@@ -303,7 +303,7 @@ public void ProjectAddItemMetadataFormatting()
 
             var itemToEdit = project.GetItems("Compile").Single(item => item.EvaluatedInclude == "Class2.cs");
             itemToEdit.SetMetadataValue("ExcludeFromStyleCop", "true");
-            
+
             StringWriter writer = new StringWriter();
             project.Save(writer);
 
@@ -503,8 +503,8 @@ public void DefaultProjectSaveContainsAllNewFileOptions()
 
             Project project = new Project();
             project.AddItem("ProjectReference", @"..\CLREXE\CLREXE.vcxproj",
-                new[] {new KeyValuePair<string, string>("metadata", "value")});
-            
+                new[] { new KeyValuePair<string, string>("metadata", "value") });
+
             StringWriter writer = new EncodingStringWriter();
             project.Save(writer);
 
diff --git a/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs b/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
index 586b3cb9ecd..08d95f1e707 100644
--- a/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
@@ -1156,7 +1156,7 @@ public void RenameItem_StillMatchesWildcard()
         [MemberData(nameof(ItemElementsWithGlobsThatRequireSplitting))]
         public void RenameThrowsWhenItemElementSplittingIsDisabled(string projectContents, int itemIndex, SetupProject setupProject)
         {
-            AssertDisabledItemSplitting(projectContents, itemIndex, setupProject, (p, i) => {i.Rename("foo"); });
+            AssertDisabledItemSplitting(projectContents, itemIndex, setupProject, (p, i) => { i.Rename("foo"); });
         }
 
         /// <summary>
@@ -1457,7 +1457,7 @@ public void RemoveItemThrowsWhenItemElementSplittingIsDisabled(string projectCon
         [MemberData(nameof(ItemElementsWithGlobsThatRequireSplitting))]
         public void RemoveItemsThrowsWhenItemElementSplittingIsDisabled(string projectContents, int itemIndex, SetupProject setupProject)
         {
-            AssertDisabledItemSplitting(projectContents, itemIndex, setupProject, (p, i) => { p.RemoveItems(new [] {i}); });
+            AssertDisabledItemSplitting(projectContents, itemIndex, setupProject, (p, i) => { p.RemoveItems(new[] { i }); });
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 0d44fcf3f06..3f50821db20 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -837,7 +837,7 @@ private static void ProjectGetterResultsInDriveEnumerationWarning(string unevalu
                     Project project = new Project(projectCollection);
 
                     // Add item
-                    _= project.AddItem("i", unevaluatedInclude);
+                    _ = project.AddItem("i", unevaluatedInclude);
 
                     // Verify
                     collectionLogger.WarningCount.ShouldBe(1);
@@ -927,7 +927,7 @@ public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingCont
         public void LogWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
         {
             content = string.Format(content, placeHolder, excludePlaceHolder);
-                CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
+            CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
         }
 
         private static void CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(string content, bool throwException)
@@ -1133,7 +1133,7 @@ public void IncludeAndExcludeWorkWithRelativeAndAbsolutePaths(
         [InlineData(
             "../a.cs;b.cs", // include string
             "**/*.cs", // exclude string
-            new[] {"a.cs", "ProjectDir/b.cs"}, // files to create relative to the test root dir
+            new[] { "a.cs", "ProjectDir/b.cs" }, // files to create relative to the test root dir
             "ProjectDir", // relative path from test root to project
             new[] { "../a.cs" } // expected items
             )]
@@ -2482,7 +2482,7 @@ public void RemoveWithItemReferenceOnFilePathMatchingMetadata()
                 <I1 Include='c1' M1='foo/bar.vb' M2='y'/>
                 <I1 Include='d1' M1='foo\foo\foo' M2='b'/>
                 <I1 Include='e1' M1='a/b/../c/./d' M2='1'/>
-                <I1 Include='f1' M1='{ Environment.CurrentDirectory }\b\c' M2='6'/>
+                <I1 Include='f1' M1='{Environment.CurrentDirectory}\b\c' M2='6'/>
 
                 <I2 Include='a2' M1='FOO.TXT' m2='c'/>
                 <I2 Include='b2' M1='foo/bar.txt' m2='x'/>
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index a3457bbcd44..9d39903ae11 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -3677,28 +3677,28 @@ public void GetAllGlobsShouldFindAllExcludesAndRemoves()
         }
 
         [Theory]
-// [InlineData(
-//            @"
-// <A Include=`a;b*;c*;d*;e*;f*` Exclude=`c*;d*`/>
-// <A Remove=`e*;f*`/>
-// ",
-//        new[] {"ba"},
-//        new[] {"a", "ca", "da", "ea", "fa"}
-//        )]
-//        [InlineData(
-//            @"
-// <A Include=`a;b*;c*;d*;e*;f*` Exclude=`c*;d*`/>
-// ",
-//        new[] {"ba", "ea", "fa"},
-//        new[] {"a", "ca", "da"}
-//        )]
-//        [InlineData(
-//            @"
-// <A Include=`a;b*;c*;d*;e*;f*`/>
-// ",
-//        new[] {"ba", "ca", "da", "ea", "fa"},
-//        new[] {"a"}
-//        )]
+        // [InlineData(
+        //            @"
+        // <A Include=`a;b*;c*;d*;e*;f*` Exclude=`c*;d*`/>
+        // <A Remove=`e*;f*`/>
+        // ",
+        //        new[] {"ba"},
+        //        new[] {"a", "ca", "da", "ea", "fa"}
+        //        )]
+        //        [InlineData(
+        //            @"
+        // <A Include=`a;b*;c*;d*;e*;f*` Exclude=`c*;d*`/>
+        // ",
+        //        new[] {"ba", "ea", "fa"},
+        //        new[] {"a", "ca", "da"}
+        //        )]
+        //        [InlineData(
+        //            @"
+        // <A Include=`a;b*;c*;d*;e*;f*`/>
+        // ",
+        //        new[] {"ba", "ca", "da", "ea", "fa"},
+        //        new[] {"a"}
+        //        )]
         [InlineData(
             @"
 <E Include=`b`/>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index 8672b476a16..975c78ab947 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -230,7 +230,7 @@ public TestCollectionGroup(int remoteCount, int stdFilesCount)
             this.Disk = this.ImmutableDisk.GetSubFolder("Mutable");
 
             List<string> stdFiles = new List<string>();
-            for (int i=0; i< stdFilesCount; i++)
+            for (int i = 0; i < stdFilesCount; i++)
             {
                 stdFiles.Add(this.ImmutableDisk.WriteProjectFile($"Proj{i}.proj", TestCollectionGroup.SampleProjectFile));
             }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index 31170402812..6f0fb2abfee 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -73,7 +73,7 @@ public ElementLinkPair<CT> AddNewNamedChaildWithVerify<CT>(ObjectType where, str
         public ElementLinkPair<CT> AddNewLabeledChaildWithVerify<CT>(ObjectType where, string label, Func<T, string, CT> adder)
             where CT : ProjectElement
             => AddNewChaildWithVerify(where, label,
-                (t, l)=>
+                (t, l) =>
                 {
                     var ct = adder(t, l);
                     Assert.NotNull(ct);
@@ -141,7 +141,7 @@ public ICollection<ElementLinkPair<CT>> QueryChildrenWithValidation<CT>(Func<T,
             return result;
         }
 
-        public ICollection<ElementLinkPair<CT>> QueryChildrenWithValidation<CT>(Func<T,IEnumerable> getter,  Func<CT, bool> matcher)
+        public ICollection<ElementLinkPair<CT>> QueryChildrenWithValidation<CT>(Func<T, IEnumerable> getter, Func<CT, bool> matcher)
             where CT : ProjectElement
         {
             var viewResult = new List<CT>();
@@ -270,7 +270,7 @@ public static bool IsLinkedObject(object obj)
             return LinkedObjectsFactory.GetLink(obj) != null;
         }
 
-        private static bool dbgIgnoreLinked = false; 
+        private static bool dbgIgnoreLinked = false;
         public static void VerifyNotLinked(object obj)
         {
             if (dbgIgnoreLinked)
@@ -386,7 +386,7 @@ private static void VerifyProjectElementViewInternal(ProjectElement viewXml, Pro
 
             VerifySameLocation(realXml.LabelLocation, viewXml.LabelLocation, context);
 
-            VerifySameLocationWithException(()=>realXml.ConditionLocation, ()=>viewXml.ConditionLocation, context);
+            VerifySameLocationWithException(() => realXml.ConditionLocation, () => viewXml.ConditionLocation, context);
 
             VerifyNotLinked(realXml.ContainingProject);
             VerifyLinked(viewXml.ContainingProject);
@@ -430,7 +430,7 @@ private static void VerifyProjectElementContainerView(ProjectElementContainer vi
             var realChild = realXml.FirstChild;
             var viewChild = viewXml.FirstChild;
 
-            while (realChild != null )
+            while (realChild != null)
             {
                 Assert.NotNull(viewChild);
                 Assert.Same(realChild.Parent, realXml);
@@ -899,15 +899,15 @@ public static void Verify(ProjectItemElement viewXml, ProjectItemElement realXml
             Assert.Equal(realXml.KeepDuplicates, viewXml.KeepDuplicates);
             Assert.Equal(realXml.HasMetadata, viewXml.HasMetadata);
 
-           Verify(viewXml.Metadata, realXml.Metadata, ViewValidation.Verify, context);
+            Verify(viewXml.Metadata, realXml.Metadata, ViewValidation.Verify, context);
 
-           VerifySameLocation(realXml.IncludeLocation, viewXml.IncludeLocation, context);
-           VerifySameLocation(realXml.ExcludeLocation, viewXml.ExcludeLocation, context);
-           VerifySameLocation(realXml.RemoveLocation, viewXml.RemoveLocation, context);
-           VerifySameLocation(realXml.UpdateLocation, viewXml.UpdateLocation, context);
-           VerifySameLocation(realXml.KeepMetadataLocation, viewXml.KeepMetadataLocation, context);
-           VerifySameLocation(realXml.RemoveMetadataLocation, viewXml.RemoveMetadataLocation, context);
-           VerifySameLocation(realXml.KeepDuplicatesLocation, viewXml.KeepDuplicatesLocation, context);
+            VerifySameLocation(realXml.IncludeLocation, viewXml.IncludeLocation, context);
+            VerifySameLocation(realXml.ExcludeLocation, viewXml.ExcludeLocation, context);
+            VerifySameLocation(realXml.RemoveLocation, viewXml.RemoveLocation, context);
+            VerifySameLocation(realXml.UpdateLocation, viewXml.UpdateLocation, context);
+            VerifySameLocation(realXml.KeepMetadataLocation, viewXml.KeepMetadataLocation, context);
+            VerifySameLocation(realXml.RemoveMetadataLocation, viewXml.RemoveMetadataLocation, context);
+            VerifySameLocation(realXml.KeepDuplicatesLocation, viewXml.KeepDuplicatesLocation, context);
         }
 
         public static void Verify(ProjectItemGroupElement viewXml, ProjectItemGroupElement realXml, ValidationContext context = null)
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
index 9b512430af6..4c84b002f29 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
@@ -300,7 +300,7 @@ private static void Verify(List<string> viewProps, List<string> realProps, Valid
             Assert.NotNull(realProps);
             Assert.Equal(realProps.Count, viewProps.Count);
 
-            for (int i = 0; i< realProps.Count; i++)
+            for (int i = 0; i < realProps.Count; i++)
             {
                 Assert.Equal(realProps[i], viewProps[i]);
             }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
index 2489f2b4687..6c328e5361d 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
@@ -159,7 +159,7 @@ public void ProjectTargetElementModify()
             newTarget1.Add2NewLabeledChildrenWithVerify<ProjectPropertyGroupElement>(NewPropertyGroup, (t, l) => t.AddPropertyGroup(), out var newPropertyGroup1, out var newPropertyGroup2);
 
             // Add property groups
-            newTarget1.Append2NewChildrenWithVerify<ProjectOnErrorElement>("errTarget", (p, et) => p.CreateOnErrorElement(et), (oe, et)=>oe.ExecuteTargetsAttribute == et, out var newOnErr1, out var newOnErr2);
+            newTarget1.Append2NewChildrenWithVerify<ProjectOnErrorElement>("errTarget", (p, et) => p.CreateOnErrorElement(et), (oe, et) => oe.ExecuteTargetsAttribute == et, out var newOnErr1, out var newOnErr2);
 
 
             // string setters
@@ -193,7 +193,7 @@ public void ProjectTargetElementModify()
 
             // removes
             newTarget1.View.RemoveChild(newTask2.View);
-            Assert.ThrowsAny<ArgumentException>( () => newTarget1.Real.RemoveChild(newTask2.Real) );
+            Assert.ThrowsAny<ArgumentException>(() => newTarget1.Real.RemoveChild(newTask2.Real));
             Assert.Equal(1, newTarget1.View.Tasks.Count);
             newTarget1.Real.RemoveChild(newTask1.Real);
             Assert.ThrowsAny<ArgumentException>(() => newTarget1.View.RemoveChild(newTask1.View));
@@ -264,9 +264,9 @@ public void ProjectTaskElementModify()
                 newTask.VerifySetter(paramValue.Ver(i), (t) => t.GetParameter(paramName.Ver(i)), (t, v) => t.SetParameter(paramName.Ver(i), v));
             }
 
-            newTask.Verify(); 
+            newTask.Verify();
             Assert.Equal(5, newTask.View.Parameters.Count);
-            for (int i = 1; i<= 5; i++)
+            for (int i = 1; i <= 5; i++)
             {
                 Assert.Equal(paramValue.Ver(i), newTask.View.Parameters[paramName.Ver(i)]);
             }
@@ -320,7 +320,7 @@ public void ProjectOutputElementModify()
 
             const string NewOutputItem = "NewOutputItem";
             const string ItemType = "CPPSource";
-            var newOutputItem =  newTask.AddNewChaildWithVerify<ProjectOutputElement>(ObjectType.View, NewOutputItem, (t, n) => t.AddOutputItem(n, ItemType), (oi, n) => oi.TaskParameter == n);
+            var newOutputItem = newTask.AddNewChaildWithVerify<ProjectOutputElement>(ObjectType.View, NewOutputItem, (t, n) => t.AddOutputItem(n, ItemType), (oi, n) => oi.TaskParameter == n);
 
             Assert.True(newOutputItem.View.IsOutputItem);
             Assert.False(newOutputItem.View.IsOutputProperty);
@@ -387,7 +387,7 @@ public void ProjectChooseElementModify()
 
             Assert.Null(choose.View.OtherwiseElement);
 
-            var otherWise = choose.AppendNewChaildWithVerify<ProjectOtherwiseElement>(ObjectType.View, "when", (p, l) => p.CreateOtherwiseElement(), (p,l) => true);
+            var otherWise = choose.AppendNewChaildWithVerify<ProjectOtherwiseElement>(ObjectType.View, "when", (p, l) => p.CreateOtherwiseElement(), (p, l) => true);
             Assert.Same(otherWise.View, choose.View.OtherwiseElement);
             Assert.Same(otherWise.Real, choose.Real.OtherwiseElement);
 
@@ -410,7 +410,7 @@ public void ProjectWhenElementModify()
             var xmlPair = new ProjectXmlPair(pair);
 
             var choose = xmlPair.AppendNewChaildWithVerify<ProjectChooseElement>(ObjectType.View, "choose", (p, s) => p.CreateChooseElement(), (p, s) => true);
-            var when  = choose.AppendNewChaildWithVerify<ProjectWhenElement>(ObjectType.View, "when", (p, s) => p.CreateWhenElement("true"), (p, s) => true);
+            var when = choose.AppendNewChaildWithVerify<ProjectWhenElement>(ObjectType.View, "when", (p, s) => p.CreateWhenElement("true"), (p, s) => true);
 
             when.VerifySetter("Condition", (we) => we.Condition, (we, v) => we.Condition = v);
             Assert.Empty(when.View.ChooseElements);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
index 5c53201c0d8..4733993db9f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
@@ -71,7 +71,7 @@ public void ProjectRootElemetReadOnly()
 
             ViewValidation.Verify(preView, preReal);
         }
-        
+
         [Fact]
         public void ProjectChooseElementReadOnly()
         {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
index d0f1b2125c9..1ea6746eed0 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
@@ -215,7 +215,7 @@ public void ProjectItemModify()
                 var fooRealFast = pair.GetSingleItemWithVerify(ObjectType.Real, "fooFast.cpp");
                 Assert.NotNull(fooRealFast);
                 ViewValidation.Verify(fooViewFast, fooRealFast, validationContext);
-                var toRemoveReal = new List<ProjectItem>() { fooRealFast, barRealFast};
+                var toRemoveReal = new List<ProjectItem>() { fooRealFast, barRealFast };
 
                 Assert.Throws<ArgumentException>(() =>
                 {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
index 89447997df1..ec1d5b2cda1 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
@@ -29,7 +29,7 @@ public void EnumerationBasic()
             var pcRemote = this.StdGroup.Remote[0];
 
             var proj1Path = this.StdGroup.StdProjectFiles[0];
-            var proj2Path = this.StdGroup.StdProjectFiles[1]; 
+            var proj2Path = this.StdGroup.StdProjectFiles[1];
 
             var proj1 = pcLocal.LoadProject(proj1Path);
             var proj2 = pcRemote.LoadProject(proj2Path);
@@ -106,7 +106,7 @@ public void EnumerationMultiple()
             Assert.Equal(2, prj2Coll.Count);
             Assert.False(prj2Coll.Contains(proj2remote0));
             Assert.False(prj2Coll.Contains(proj2remote1));
-            foreach(var p in prj2Coll)
+            foreach (var p in prj2Coll)
             {
                 ViewValidation.VerifyLinkedNotNull(p);
             }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
index be59c2fe7d1..1cf780d9ea4 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 
     internal static class CollectionHelpers
     {
-        public static IList<A> ConvertCollection<A,B>(this IEnumerable<B> source, Func<B, A> converter)
+        public static IList<A> ConvertCollection<A, B>(this IEnumerable<B> source, Func<B, A> converter)
         {
             if (source == null)
             {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
index 2dff6a546e7..78ea38e377a 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
@@ -167,7 +167,7 @@ public static ProjectElementContainer DeepClone(this IProjectElementContainerLin
         {
             var factoryRemote = xml.Linker.Export<ProjectElement, MockProjectRootElementLinkRemoter>(factory);
             var parentRemote = (MockProjectElementContainerLinkRemoter)xml.Linker.ExportElement(parent);
-            var result  = xml.ContainerProxy.DeepClone(factoryRemote, parentRemote);
+            var result = xml.ContainerProxy.DeepClone(factoryRemote, parentRemote);
 
             return (ProjectElementContainer)result.Import(xml.Linker);
         }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
index 66ba4062712..c34fb6f5cdb 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
@@ -53,7 +53,7 @@ public MockProjectItemElementLinkRemoter CreateItemElement(string itemType)
         }
         public MockProjectItemElementLinkRemoter CreateItemElement(string itemType, string include)
         {
-            return (MockProjectItemElementLinkRemoter) this.Export(this.ProjectXml.CreateItemElement(itemType, include));
+            return (MockProjectItemElementLinkRemoter)this.Export(this.ProjectXml.CreateItemElement(itemType, include));
         }
         public MockProjectItemDefinitionElementLinkRemoter CreateItemDefinitionElement(string itemType)
         {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTaskElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTaskElementLink.cs
index 0270ebd93f1..e0760529bee 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTaskElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTaskElementLink.cs
@@ -59,7 +59,7 @@ public MockProjectTaskElementLink(MockProjectTaskElementLinkRemoter proxy, IImpo
         public override IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations => this.Proxy.ParameterLocations;
         public override string GetParameter(string name) { return this.Proxy.GetParameter(name); }
         // hmm did not know can use => on functions, can clean the milion other cases some tiem ...
-        public override void SetParameter(string name, string unevaluatedValue) =>  this.Proxy.SetParameter(name, unevaluatedValue);
+        public override void SetParameter(string name, string unevaluatedValue) => this.Proxy.SetParameter(name, unevaluatedValue);
         public override void RemoveParameter(string name) => Proxy.RemoveParameter(name);
         public override void RemoveAllParameters() => Proxy.RemoveAllParameters();
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskParameterElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskParameterElementLink.cs
index 4a2ea57fc08..1e3433cb445 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskParameterElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskParameterElementLink.cs
@@ -40,7 +40,7 @@ public MockProjectUsingTaskParameterElementLink(MockProjectUsingTaskParameterEle
         object ILinkMock.Remoter => this.Proxy;
         MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
 
-        public override string Name { get => Proxy.Name; set =>Proxy.Name = value; }
+        public override string Name { get => Proxy.Name; set => Proxy.Name = value; }
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
         public override ProjectElementContainer Parent => EImpl.GetParent();
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index 2eaf1a6fa6f..e1c26178520 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -79,7 +79,7 @@ public IList<MockProjectItemLinkRemoter> AddItemFast(string itemType, string une
         public ICollection<MockProjectItemLinkRemoter> GetItems(string itemType)
             => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.GetItems(itemType));
 
-        public  ICollection<MockProjectItemLinkRemoter> GetItemsByEvaluatedInclude(string evaluatedInclude)
+        public ICollection<MockProjectItemLinkRemoter> GetItemsByEvaluatedInclude(string evaluatedInclude)
             => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.GetItemsByEvaluatedInclude(evaluatedInclude));
 
         public ICollection<MockProjectItemLinkRemoter> GetItemsIgnoringCondition(string itemType)
@@ -89,7 +89,7 @@ public IEnumerable<MockProjectElementLinkRemoter> GetLogicalProject()
             => this.OwningCollection.ExportCollection(this.Source.GetLogicalProject());
 
         public MockProjectPropertyLinkRemoter GetProperty(string name) => this.OwningCollection.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Source.GetProperty(name));
-        public  string GetPropertyValue(string name) => this.Source.GetPropertyValue(name);
+        public string GetPropertyValue(string name) => this.Source.GetPropertyValue(name);
         public void MarkDirty() => this.Source.MarkDirty();
         public void ReevaluateIfNecessary(EvaluationContext evaluationContext) => this.Source.ReevaluateIfNecessary(evaluationContext);
         public bool RemoveGlobalProperty(string name) => this.Source.RemoveGlobalProperty(name);
@@ -107,9 +107,9 @@ public void SaveLogicalProject(TextWriter writer)
             this.Source.SaveLogicalProject(writer);
         }
 
-        public  bool SetGlobalProperty(string name, string escapedValue) => this.Source.SetGlobalProperty(name, escapedValue);
+        public bool SetGlobalProperty(string name, string escapedValue) => this.Source.SetGlobalProperty(name, escapedValue);
 
-        public  MockProjectPropertyLinkRemoter SetProperty(string name, string unevaluatedValue)
+        public MockProjectPropertyLinkRemoter SetProperty(string name, string unevaluatedValue)
             => this.OwningCollection.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Source.SetProperty(name, unevaluatedValue));
         public void Unload() { }
     }
@@ -138,7 +138,7 @@ public MockProjectLink(MockProjectLinkRemoter proxy, IImportHolder holder)
 
         public override ICollection<string> ItemTypes => this.Proxy.ItemTypes;
 
-        public override ICollection<ProjectProperty> Properties => this.Linker.ImportCollection<ProjectProperty,MockProjectPropertyLinkRemoter>(this.Proxy.Properties);
+        public override ICollection<ProjectProperty> Properties => this.Linker.ImportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Proxy.Properties);
 
         public override IDictionary<string, List<string>> ConditionedProperties => this.Proxy.ConditionedProperties;
 
@@ -184,7 +184,7 @@ public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnum
             => throw new NotImplementedException();
         public override ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext) => throw new NotImplementedException();
         public override IDictionary<string, ProjectTargetInstance> Targets => throw new NotImplementedException();
-// --------------------------------------------------
+        // --------------------------------------------------
 
         public override string ExpandString(string unexpandedValue) => this.Proxy.ExpandString(unexpandedValue);
 
@@ -212,7 +212,7 @@ public override List<ProvenanceResult> GetItemProvenance(ProjectItem item, Evalu
         {
             throw new NotImplementedException();
         }
-// ---------------------------------------------------------------------------------------
+        // ---------------------------------------------------------------------------------------
 
         public override ICollection<ProjectItem> GetItems(string itemType)
             => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.GetItems(itemType));
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
index cea7656b893..6674f58bcc3 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
@@ -22,7 +22,7 @@ public override ProjectProperty CreateLinkedObject(IImportHolder holder)
         public MockProjectPropertyElementLinkRemoter Xml => (MockProjectPropertyElementLinkRemoter)this.ExportElement(this.Source.Xml);
         public string Name => this.Source.Name;
         public string EvaluatedIncludeEscaped => ProjectPropertyLink.GetEvaluatedValueEscaped(this.Source);
-        public string UnevaluatedValue { get => this.Source.UnevaluatedValue; set=> this.Source.UnevaluatedValue = value; }
+        public string UnevaluatedValue { get => this.Source.UnevaluatedValue; set => this.Source.UnevaluatedValue = value; }
         public bool IsEnvironmentProperty => this.Source.IsEnvironmentProperty;
         public bool IsGlobalProperty => this.Source.IsGlobalProperty;
         public bool IsReservedProperty => this.Source.IsReservedProperty;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
index 1b7e3b67aee..498f5f92b8c 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
@@ -154,12 +154,12 @@ internal class ProjectCollectionLinker : ExternalProjectsProvider
         private ProjectCollectionLinker(ConnectedProjectCollections group)
         {
             this.LinkedCollections = group;
-            this.CollectionId = (UInt32) Interlocked.Increment(ref _collecitonId);
+            this.CollectionId = (UInt32)Interlocked.Increment(ref _collecitonId);
             this.Collection = new ProjectCollection();
             this.LinkFactory = LinkedObjectsFactory.Get(this.Collection);
         }
 
-        public Project LoadProject(string path) =>  this.Collection.LoadProject(path);
+        public Project LoadProject(string path) => this.Collection.LoadProject(path);
         public Project LoadProjectIgnoreMissingImports(string path) => LoadProjectWithSettings(path, ProjectLoadSettings.IgnoreMissingImports);
         public Project LoadProjectWithSettings(string path, ProjectLoadSettings settings) => new Project(path, null, null, this.Collection, settings);
 
@@ -193,7 +193,7 @@ public bool Importing
             }
         }
 
-        private void ConnectTo (ProjectCollectionLinker other)
+        private void ConnectTo(ProjectCollectionLinker other)
         {
             if (other.CollectionId == this.CollectionId)
             {
@@ -219,7 +219,7 @@ private void ConnectTo (ProjectCollectionLinker other)
         private static bool dbgValidateDuplicateViews = false;
 
 
-        internal  void ValidateNoDuplicates()
+        internal void ValidateNoDuplicates()
         {
             foreach (var r in imported)
             {
@@ -329,7 +329,7 @@ public void Export<T, RMock>(T obj, out RMock remoter)
             {
                 var proxy = (ILinkMock)external;
 
-                remoter = (RMock) proxy.Remoter;
+                remoter = (RMock)proxy.Remoter;
                 return;
             }
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
index da3a45fc598..74a62826568 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
@@ -126,7 +126,7 @@ private LinkedObjectsMap(UInt32 id)
         }
         private UInt32 CollectionId { get; set; }
 
-        public static LinkedObjectsMap<KeyType>  Create()
+        public static LinkedObjectsMap<KeyType> Create()
         {
             lock (Lock)
             {
diff --git a/src/Build.OM.UnitTests/TransientIO.cs b/src/Build.OM.UnitTests/TransientIO.cs
index d30000833b1..08af7fde6db 100644
--- a/src/Build.OM.UnitTests/TransientIO.cs
+++ b/src/Build.OM.UnitTests/TransientIO.cs
@@ -94,7 +94,7 @@ public TransientIO GetSubFolder(string path)
             var subFolder = this.GetRelativePath(path);
             if (!this.Children.TryGetValue(subFolder, out var result))
             {
-                result  = new TransientIO(this, subFolder);
+                result = new TransientIO(this, subFolder);
                 this.Children.Add(subFolder, result);
             }
 
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index b1d16be134b..dbc0ed6ffd4 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -550,7 +550,7 @@ public void AssemblyNameWithAllFields()
                 ContentType = AssemblyContentType.WindowsRuntime,
                 CultureName = "zh-HK",
             };
-            value.SetPublicKey(new byte[]{ 3, 2, 1});
+            value.SetPublicKey(new byte[] { 3, 2, 1 });
             value.SetPublicKeyToken(new byte[] { 8, 7, 6, 5, 4, 3, 2, 1 });
 
             TranslationHelpers.GetWriteTranslator().Translate(ref value);
@@ -794,7 +794,7 @@ public override bool Equals(object obj)
                     return false;
                 }
 
-                return Equals((BaseClass) obj);
+                return Equals((BaseClass)obj);
             }
 
             public override int GetHashCode()
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index dc3d33b9784..bf46cce5006 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -277,7 +277,7 @@ public void TestTranslationWithEntireProjectState()
 </Target>
 </Project>");
 
-            Dictionary<string, string> globalProperties = new (StringComparer.OrdinalIgnoreCase);
+            Dictionary<string, string> globalProperties = new(StringComparer.OrdinalIgnoreCase);
             globalProperties["ThreeIn"] = "3";
 
             Project project = new Project(
@@ -472,7 +472,7 @@ public void WorksCorrectlyWithCurlyBraces()
             try
             {
                 // Check if } do not cause it to crash due to usage of String.Format or such on code path
-                string problematicTmpPath = Path.Combine(originalTmp,  "}", "blabla", "temp");
+                string problematicTmpPath = Path.Combine(originalTmp, "}", "blabla", "temp");
                 Environment.SetEnvironmentVariable("TMP", problematicTmpPath);
                 Environment.SetEnvironmentVariable("TEMP", problematicTmpPath);
 
diff --git a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
index f4cd9d64cf0..a63a1142d25 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
@@ -35,7 +35,7 @@ public void TestConstructorBad()
         [Fact]
         public void TestConstructorGood()
         {
-            CreateNewBuildRequest(0, Array.Empty<string>() );
+            CreateNewBuildRequest(0, Array.Empty<string>());
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index 0a55644bbf8..62d7f03dc37 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -75,11 +75,11 @@ public void CannotAddAfterAggregation()
         public void RejectCachesWithMoreConfigEntriesThanResultEntries()
         {
             var configCache = new ConfigCache();
-            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"a", "b"}, null), "13"));
-            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 2, new BuildRequestData("path2", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"c", "d"}, null), "13"));
+            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "a", "b" }, null), "13"));
+            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 2, new BuildRequestData("path2", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "c", "d" }, null), "13"));
 
             var resultsCache = new ResultsCache();
-            var buildResult = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>(){"a", "b"}, null, BuildEventContext.Invalid, null));
+            var buildResult = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>() { "a", "b" }, null, BuildEventContext.Invalid, null));
             buildResult.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
             resultsCache.AddResult(buildResult);
 
@@ -97,15 +97,15 @@ public void RejectCachesWithMoreConfigEntriesThanResultEntries()
         public void RejectCachesWithMoreResultEntriesThanConfigEntries()
         {
             var configCache = new ConfigCache();
-            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"a", "b"}, null), "13"));
+            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "a", "b" }, null), "13"));
 
             var resultsCache = new ResultsCache();
-            var buildResult = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>(){"a", "b"}, null, BuildEventContext.Invalid, null));
+            var buildResult = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>() { "a", "b" }, null, BuildEventContext.Invalid, null));
             buildResult.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
 
             resultsCache.AddResult(buildResult);
 
-            var buildResult2 = new BuildResult(new BuildRequest(1, 2, configurationId: 2, new List<string>(){"a", "b"}, null, BuildEventContext.Invalid, null));
+            var buildResult2 = new BuildResult(new BuildRequest(1, 2, configurationId: 2, new List<string>() { "a", "b" }, null, BuildEventContext.Invalid, null));
             buildResult2.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
 
             resultsCache.AddResult(buildResult2);
@@ -126,10 +126,10 @@ public void RejectCachesWithMismatchedIds()
             // one entry in each cache but different config ids
 
             var configCache = new ConfigCache();
-            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"a", "b"}, null), "13"));
+            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "a", "b" }, null), "13"));
 
             var resultsCache = new ResultsCache();
-            var buildResult = new BuildResult(new BuildRequest(1, 2, configurationId: 2, new List<string>(){"a", "b"}, null, BuildEventContext.Invalid, null));
+            var buildResult = new BuildResult(new BuildRequest(1, 2, configurationId: 2, new List<string>() { "a", "b" }, null, BuildEventContext.Invalid, null));
             buildResult.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
             resultsCache.AddResult(buildResult);
 
@@ -148,18 +148,18 @@ public void RejectCollidingConfigurationsFromSeparateCaches()
         {
             // collides with the config id from configCache2
             var configCache1 = new ConfigCache();
-            configCache1.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"a", "b"}, null), "13"));
+            configCache1.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "a", "b" }, null), "13"));
 
             var resultsCache1 = new ResultsCache();
-            var buildResult11 = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>(){"a", "b"}, null, BuildEventContext.Invalid, null));
+            var buildResult11 = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>() { "a", "b" }, null, BuildEventContext.Invalid, null));
             buildResult11.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
             resultsCache1.AddResult(buildResult11);
 
             var configCache2 = new ConfigCache();
-            configCache2.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"a", "b"}, null), "13"));
+            configCache2.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "a", "b" }, null), "13"));
 
             var resultsCache2 = new ResultsCache();
-            var buildResult21 = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>(){"e", "f"}, null, BuildEventContext.Invalid, null));
+            var buildResult21 = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>() { "e", "f" }, null, BuildEventContext.Invalid, null));
             buildResult21.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
             resultsCache2.AddResult(buildResult21);
 
@@ -185,17 +185,17 @@ public void SingleEmpty()
 
             var results = aggregator.Aggregate();
 
-            AssertAggregation(new[] {(configCache, resultsCache)}, results);
+            AssertAggregation(new[] { (configCache, resultsCache) }, results);
         }
 
         [Fact]
         public void SingleCacheWithSingleEntry()
         {
             var configCache = new ConfigCache();
-            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"a", "b"}, null), "13"));
+            configCache.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "a", "b" }, null), "13"));
 
             var resultsCache = new ResultsCache();
-            var buildResult = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>(){"a", "b"}, null, BuildEventContext.Invalid, null));
+            var buildResult = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>() { "a", "b" }, null, BuildEventContext.Invalid, null));
             buildResult.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
             resultsCache.AddResult(buildResult);
 
@@ -203,32 +203,32 @@ public void SingleCacheWithSingleEntry()
 
             var results = aggregator.Aggregate();
 
-            AssertAggregation(new[] {(configCache, resultsCache)}, results);
+            AssertAggregation(new[] { (configCache, resultsCache) }, results);
         }
 
         [Fact]
         public void MultipleCachesMultipleEntries()
         {
             var configCache1 = new ConfigCache();
-            configCache1.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"a", "b"}, null), "13"));
-            configCache1.AddConfiguration(new BuildRequestConfiguration(configId: 2, new BuildRequestData("path2", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"c", "d"}, null), "13"));
+            configCache1.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "a", "b" }, null), "13"));
+            configCache1.AddConfiguration(new BuildRequestConfiguration(configId: 2, new BuildRequestData("path2", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "c", "d" }, null), "13"));
 
             var resultsCache1 = new ResultsCache();
-            var buildResult11 = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>(){"a", "b"}, null, BuildEventContext.Invalid, null));
+            var buildResult11 = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>() { "a", "b" }, null, BuildEventContext.Invalid, null));
             buildResult11.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
-            var buildResult12 = new BuildResult(new BuildRequest(1, 2, configurationId: 2, new List<string>(){"c", "d"}, null, BuildEventContext.Invalid, null));
+            var buildResult12 = new BuildResult(new BuildRequest(1, 2, configurationId: 2, new List<string>() { "c", "d" }, null, BuildEventContext.Invalid, null));
             buildResult12.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
             resultsCache1.AddResult(buildResult11);
             resultsCache1.AddResult(buildResult12);
 
             var configCache2 = new ConfigCache();
-            configCache2.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path3", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"e", "f"}, null), "13"));
-            configCache2.AddConfiguration(new BuildRequestConfiguration(configId: 2, new BuildRequestData("path4", new Dictionary<string, string>(){["p"] = "v"}, "13", new []{"g", "h"}, null), "13"));
+            configCache2.AddConfiguration(new BuildRequestConfiguration(configId: 1, new BuildRequestData("path3", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "e", "f" }, null), "13"));
+            configCache2.AddConfiguration(new BuildRequestConfiguration(configId: 2, new BuildRequestData("path4", new Dictionary<string, string>() { ["p"] = "v" }, "13", new[] { "g", "h" }, null), "13"));
 
             var resultsCache2 = new ResultsCache();
-            var buildResult21 = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>(){"e", "f"}, null, BuildEventContext.Invalid, null));
+            var buildResult21 = new BuildResult(new BuildRequest(1, 2, configurationId: 1, new List<string>() { "e", "f" }, null, BuildEventContext.Invalid, null));
             buildResult21.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
-            var buildResult22 = new BuildResult(new BuildRequest(1, 2, configurationId: 2, new List<string>(){"g", "h"}, null, BuildEventContext.Invalid, null));
+            var buildResult22 = new BuildResult(new BuildRequest(1, 2, configurationId: 2, new List<string>() { "g", "h" }, null, BuildEventContext.Invalid, null));
             buildResult22.AddResultsForTarget("a", GetNonEmptySucceedingTargetResult());
             resultsCache2.AddResult(buildResult21);
             resultsCache2.AddResult(buildResult22);
@@ -238,7 +238,7 @@ public void MultipleCachesMultipleEntries()
 
             var results = aggregator.Aggregate();
 
-            AssertAggregation(new[] {(configCache1, resultsCache1), (configCache2, resultsCache2)}, results);
+            AssertAggregation(new[] { (configCache1, resultsCache1), (configCache2, resultsCache2) }, results);
         }
 
         private void AssertAggregation((ConfigCache configCache, ResultsCache resultsCache)[] inputCaches, CacheAggregation aggregation)
diff --git a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
index 1593604ae74..146c2acccd6 100644
--- a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
@@ -24,13 +24,13 @@ public static IEnumerable<object[]> CacheSerializationTestData
 
                 var brq1 = new BuildRequestConfiguration(
                     1,
-                    new BuildRequestData("path1", new Dictionary<string, string> {["a1"] = "b1"}, Constants.defaultToolsVersion, new[] {"target1"}, null),
+                    new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
                     Constants.defaultToolsVersion);
 
                 var configCache1 = new ConfigCache();
                 configCache1.AddConfiguration(brq1.ShallowCloneWithNewId(1));
 
-                yield return new[] {configCache1};
+                yield return new[] { configCache1 };
 
                 var brq2 = new BuildRequestConfiguration(
                     2,
@@ -46,8 +46,8 @@ public static IEnumerable<object[]> CacheSerializationTestData
                     new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
                     Constants.defaultToolsVersion);
 
-                brq3.ProjectDefaultTargets = new List<string> {"target3"};
-                brq3.ProjectInitialTargets = new List<string> {"targetInitial"};
+                brq3.ProjectDefaultTargets = new List<string> { "target3" };
+                brq3.ProjectInitialTargets = new List<string> { "targetInitial" };
 
                 var configCache3 = new ConfigCache();
                 configCache3.AddConfiguration(brq3.ShallowCloneWithNewId(3));
@@ -92,7 +92,7 @@ public static IEnumerable<object[]> CacheSerializationTestDataMultipleConfigs
         [MemberData(nameof(CacheSerializationTestData))]
         public void ConfigCacheShouldBeTranslatable(object obj)
         {
-            var initial = (ConfigCache) obj;
+            var initial = (ConfigCache)obj;
 
             TranslationHelpers.GetWriteTranslator().Translate(ref initial);
 
diff --git a/src/Build.UnitTests/BackEnd/FailingBuilderTask.cs b/src/Build.UnitTests/BackEnd/FailingBuilderTask.cs
index c8701f6beb4..972dfba7d1b 100644
--- a/src/Build.UnitTests/BackEnd/FailingBuilderTask.cs
+++ b/src/Build.UnitTests/BackEnd/FailingBuilderTask.cs
@@ -8,7 +8,7 @@
 
 namespace Microsoft.Build.UnitTests
 {
-    public  class FailingBuilderTask : Task
+    public class FailingBuilderTask : Task
     {
         public FailingBuilderTask()
             : base(null)
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index 6497b641bbc..eb1d85c5e82 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -1739,7 +1739,7 @@ public void RemoveWithItemReferenceOnMatchingMetadata()
 
             var items = lookup.GetItems("I2");
 
-            items.Select(i => i.EvaluatedInclude).ShouldBe(new []{"a2", "d2"});
+            items.Select(i => i.EvaluatedInclude).ShouldBe(new[] { "a2", "d2" });
 
             items.ElementAt(0).GetMetadataValue("M1").ShouldBe("x");
             items.ElementAt(0).GetMetadataValue("M2").ShouldBe("c");
@@ -1796,7 +1796,7 @@ public void RemoveWithItemReferenceOnFilePathMatchingMetadata()
                             <I1 Include='c1' M1='foo/bar.vb' M2='y'/>
                             <I1 Include='d1' M1='foo\foo\foo' M2='b'/>
                             <I1 Include='e1' M1='a/b/../c/./d' M2='1'/>
-                            <I1 Include='f1' M1='{ Environment.CurrentDirectory }\b\c' M2='6'/>
+                            <I1 Include='f1' M1='{Environment.CurrentDirectory}\b\c' M2='6'/>
 
                             <I2 Include='a2' M1='FOO.TXT' m2='c'/>
                             <I2 Include='b2' M1='foo/bar.txt' m2='x'/>
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 98d9ffdd515..575dd00ee0b 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -215,7 +215,8 @@ public void TestTranslation()
 
             string _initialTargetOutputLogging = Environment.GetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING");
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", "1");
-            try {
+            try
+            {
                 BuildEventArgs[] testArgs = new BuildEventArgs[]
                 {
                     new BuildFinishedEventArgs("Message", "Keyword", true),
@@ -252,7 +253,9 @@ public void TestTranslation()
 
                     CompareLogMessagePackets(packet, deserializedPacket);
                 }
-            } finally {
+            }
+            finally
+            {
                 Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", _initialTargetOutputLogging);
             }
         }
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index 09a81dfa5e7..f348fce8ca0 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -583,7 +583,7 @@ public void ErrorWhenTaskFailsWithoutLoggingErrorEscapeHatch(string failureRespo
             else
             {
                 logger.ErrorCount.ShouldBe(0);
-                logger.AssertLogContains( String.Format(MockLogger.GetString("TaskReturnedFalseButDidNotLogError"), "FailingTask") );
+                logger.AssertLogContains(String.Format(MockLogger.GetString("TaskReturnedFalseButDidNotLogError"), "FailingTask"));
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index 7509c29c15b..277ab66fe0a 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -211,10 +211,10 @@ public static IEnumerable<object[]> CacheSerializationTestData
         {
             get
             {
-                yield return new[] {new ResultsCache()};
+                yield return new[] { new ResultsCache() };
 
-                var request1 = new BuildRequest(1, 2, 3, new[] {"target1"}, null, BuildEventContext.Invalid, null);
-                var request2 = new BuildRequest(4, 5, 6, new[] {"target2"}, null, BuildEventContext.Invalid, null);
+                var request1 = new BuildRequest(1, 2, 3, new[] { "target1" }, null, BuildEventContext.Invalid, null);
+                var request2 = new BuildRequest(4, 5, 6, new[] { "target2" }, null, BuildEventContext.Invalid, null);
 
                 var br1 = new BuildResult(request1);
                 br1.AddResultsForTarget("target1", BuildResultUtilities.GetEmptySucceedingTargetResult());
@@ -222,7 +222,7 @@ public static IEnumerable<object[]> CacheSerializationTestData
                 var resultsCache = new ResultsCache();
                 resultsCache.AddResult(br1.Clone());
 
-                yield return new[] {resultsCache};
+                yield return new[] { resultsCache };
 
                 var br2 = new BuildResult(request2);
                 br2.AddResultsForTarget("target2", BuildResultUtilities.GetEmptyFailingTargetResult());
@@ -231,7 +231,7 @@ public static IEnumerable<object[]> CacheSerializationTestData
                 resultsCache2.AddResult(br1.Clone());
                 resultsCache2.AddResult(br2.Clone());
 
-                yield return new[] {resultsCache2};
+                yield return new[] { resultsCache2 };
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index c6406b169b7..58eb90d01e8 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -504,7 +504,7 @@ public void TestMaxNodeCountNodesNotExceededWithSomeOOPRequests2()
         public void SchedulerShouldHonorDisableInprocNode()
         {
             var s = new Scheduler();
-            s.InitializeComponent(new MockHost(new BuildParameters {DisableInProcNode = true}));
+            s.InitializeComponent(new MockHost(new BuildParameters { DisableInProcNode = true }));
             s.ForceAffinityOutOfProc.ShouldBeTrue();
         }
 
@@ -544,7 +544,7 @@ public void TestProxyAffinityIsInProc()
 
             CreateConfiguration(1, "foo.csproj");
 
-            BuildRequest request1 = CreateProxyBuildRequest(1, 1, new ProxyTargets(new Dictionary<string, string> {{"foo", "bar"}}), null);
+            BuildRequest request1 = CreateProxyBuildRequest(1, 1, new ProxyTargets(new Dictionary<string, string> { { "foo", "bar" } }), null);
 
             BuildRequestBlocker blocker = new BuildRequestBlocker(-1, Array.Empty<string>(), new[] { request1 });
             List<ScheduleResponse> response = new List<ScheduleResponse>(_scheduler.ReportRequestBlocked(1, blocker));
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index e8b3812ab57..e0d64b6007e 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -48,8 +48,8 @@ public void AssertDefaultLoaderReturnsDefaultResolvers()
 
             var resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
 
-            resolvers.Select(i => i.GetType().FullName).ShouldBe(new [] { typeof(DefaultSdkResolver).FullName });
-            
+            resolvers.Select(i => i.GetType().FullName).ShouldBe(new[] { typeof(DefaultSdkResolver).FullName });
+
             _logger.ErrorCount.ShouldBe(0);
             _logger.WarningCount.ShouldBe(0);
         }
@@ -342,7 +342,8 @@ public void SdkResolverLoaderHonorsIncludeDefaultEnvVar()
                     Environment.SetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER", "false");
                     SdkResolverLoader loader = new MockSdkResolverLoader()
                     {
-                        LoadResolversAction = (resolverPath, loggingContext, location, resolvers) => {
+                        LoadResolversAction = (resolverPath, loggingContext, location, resolvers) =>
+                        {
                             resolvers.Add(new MockSdkResolverWithAssemblyPath(resolverPath));
                         }
                     };
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 2d0d4fde76f..0a7d6462259 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -381,7 +381,7 @@ public void SdkResultCanReturnPropertiesAndItems()
 
             Dictionary<string, string> propertiesToAdd;
             Dictionary<string, SdkResultItem> itemsToAdd;
-           
+
             CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
 
             var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
@@ -430,7 +430,7 @@ public void SdkResultCanReturnMultiplePaths(bool includePropertiesAndItems)
             var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
                 new SdkResultImpl(
                     sdk,
-                    new []
+                    new[]
                     {
                         expectedPath1,
                         expectedPath2
@@ -654,7 +654,7 @@ internal override IList<SdkResolverManifest> GetResolversManifests(LoggingContex
             ElementLocation location)
             {
                 var manifests = new List<SdkResolverManifest>();
-                foreach(SdkResolver resolver in _resolvers)
+                foreach (SdkResolver resolver in _resolvers)
                 {
                     SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(resolver.Name, null, null);
                     manifests.Add(sdkResolverManifest);
@@ -737,10 +737,10 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
 
                 if (sdk.Name.StartsWith("2"))
                 {
-                    return factory.IndicateSuccess("resolverpath2", "version2", new[] {"WARNING2"});
+                    return factory.IndicateSuccess("resolverpath2", "version2", new[] { "WARNING2" });
                 }
 
-                return factory.IndicateFailure(new[] {"ERROR2"}, new[] {"WARNING2"});
+                return factory.IndicateFailure(new[] { "ERROR2" }, new[] { "WARNING2" });
             }
         }
 
@@ -798,7 +798,7 @@ public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverCont
                 }
                 if (resolverContext.State != null)
                 {
-                    return factory.IndicateSuccess((string) resolverContext.State, "1.0");
+                    return factory.IndicateSuccess((string)resolverContext.State, "1.0");
                 }
 
                 resolverContext.State = Expected;
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 3c83e4fd004..cf1e91d1e27 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -958,7 +958,7 @@ bool includeOutput2
         public void NewSymlinkOldDestinationIsUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: New,
-                targetWriteTime: Old, 
+                targetWriteTime: Old,
                 outputWriteTime: Middle,
                 expectedOutOfDate: false);
         }
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index a858d3fb9a4..a61bc9aa2b7 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1043,7 +1043,7 @@ public void TestTaskResolutionFailureWithNoUsingTask()
         #endregion
 
         #region ITestTaskHost Members
-        #pragma warning disable xUnit1013
+#pragma warning disable xUnit1013
 
         /// <summary>
         /// Records that a parameter was set on the task.
@@ -1125,7 +1125,7 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, IDict
             throw new NotImplementedException();
         }
 
-        #pragma warning restore xUnit1013
+#pragma warning restore xUnit1013
         #endregion
 
         #region Validation Routines
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 5e5e6724247..dfd23f2a52e 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -89,6 +89,6 @@ public void VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost()
             TransientTestProjectWithFiles project = env.CreateTestProjectWithFiles(projectContents);
             ProjectInstance projectInstance = new(project.ProjectFile);
             projectInstance.Build(new[] { new MockLogger(env.Output) }).ShouldBeTrue();
-            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 7138a700b21..75062aaf26b 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -629,7 +629,7 @@ public void RetrieveFromCacheMatchingExactParameters_AdditionalParameters()
         }
 
         [Theory]
-        [InlineData("x64","true","x86","", "x64")] // x64 wins
+        [InlineData("x64", "true", "x86", "", "x64")] // x64 wins
         [InlineData("x64", "false", "x86", "true", "x86")] // x86 wins
         public void OverriddenTask_AlwaysWins(string firstArch, string firstOverride, string secondArch, string secondOverride, string expectedArch)
         {
@@ -1319,7 +1319,7 @@ public void TaskFactoryWithNullTaskTypeLogsError()
         {
             List<ProjectUsingTaskElement> elementList = new List<ProjectUsingTaskElement>();
             ProjectRootElement project = ProjectRootElement.Create();
-            
+
             ProjectUsingTaskElement element = project.AddUsingTask("Task1", AssemblyUtilities.GetAssemblyLocation(typeof(TaskRegistry_Tests.NullTaskTypeTaskFactory).GetTypeInfo().Assembly), null);
 
             element.TaskFactory = typeof(NullTaskTypeTaskFactory).FullName;
@@ -1328,7 +1328,7 @@ public void TaskFactoryWithNullTaskTypeLogsError()
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() => registry.GetRegisteredTask("Task1", "none", null, false, new TargetLoggingContext(_loggingService, new BuildEventContext(1, 1, BuildEventContext.InvalidProjectContextId, 1)), ElementLocation.Create("none", 1, 2)));
-            
+
             exception.ErrorCode.ShouldBe("MSB4175");
 
             exception.Message.ShouldContain("The task factory must return a value for the \"TaskType\" property.");
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 177526e3650..71eb4e534a2 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -308,11 +308,11 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
         [Fact]
         public void RoundtripResponseFileUsedEventArgs()
         {
-            var args = new ResponseFileUsedEventArgs("MSBuild.rsp"); 
+            var args = new ResponseFileUsedEventArgs("MSBuild.rsp");
             Roundtrip(args,
                 e => e.ResponseFilePath);
         }
-         
+
         [Fact]
         public void RoundtripCriticalBuildMessageEventArgs()
         {
diff --git a/src/Build.UnitTests/BuildResultUtilities.cs b/src/Build.UnitTests/BuildResultUtilities.cs
index b637deaee69..b3060ca259e 100644
--- a/src/Build.UnitTests/BuildResultUtilities.cs
+++ b/src/Build.UnitTests/BuildResultUtilities.cs
@@ -24,7 +24,7 @@ public static TargetResult GetEmptySucceedingTargetResult()
 
         public static TargetResult GetNonEmptySucceedingTargetResult()
         {
-            return new TargetResult(new TaskItem[1] { new TaskItem("i", "v")}, BuildResultUtilities.GetSuccessResult());
+            return new TargetResult(new TaskItem[1] { new TaskItem("i", "v") }, BuildResultUtilities.GetSuccessResult());
         }
 
         public static WorkUnitResult GetSuccessResult()
diff --git a/src/Build.UnitTests/Collections/OMcollections_tests.cs b/src/Build.UnitTests/Collections/OMcollections_tests.cs
index 19b4c44ab26..8188b0f70c7 100644
--- a/src/Build.UnitTests/Collections/OMcollections_tests.cs
+++ b/src/Build.UnitTests/Collections/OMcollections_tests.cs
@@ -116,7 +116,7 @@ public void BasicItemDictionary()
                 enumerator.MoveNext().ShouldBeFalse();
                 Should.Throw<InvalidOperationException>(() =>
                 {
-                    object o = ((IEnumerator) enumerator).Current;
+                    object o = ((IEnumerator)enumerator).Current;
                 });
                 enumerator.Current.ShouldBeNull();
             }
diff --git a/src/Build.UnitTests/ConsoleOutputAlignerTests.cs b/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
index 8c5db6c2e03..517bb733561 100644
--- a/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
+++ b/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
@@ -75,8 +75,8 @@ public void NoAlignPrefixAlreadyWritten_NotChanged(string input)
         }
 
         [Theory]
-        [InlineData("",   "123")]
-        [InlineData(" ",  "12")]
+        [InlineData("", "123")]
+        [InlineData(" ", "12")]
         [InlineData("  ", "1")]
         public void SmallerThanBuffer_NotAligned(string indent, string input)
         {
@@ -107,7 +107,7 @@ public void BiggerThanBuffer_AlignedWithIndent(string indent, string input, stri
         [InlineData(" ", "12345678", " 12\n" +
                                      " 34\n" +
                                      " 56\n" +
-                                     " 78\n" )]
+                                     " 78\n")]
         [InlineData("  ", "1234", "  1\n" +
                                   "  2\n" +
                                   "  3\n" +
@@ -311,7 +311,7 @@ public void TabsMakesItJustOverLimit_IndentAndAlign(string prefix, string input,
         // +----+----+---+---+---+---+---+---+
         // | b  |    |   |   |   |   |   |   |
         // +----+----+---+---+---+---+---+---+
-        [InlineData("", "\t1\na\tb", "\t\n1\na\t\nb\n",  8, false)]
+        [InlineData("", "\t1\na\tb", "\t\n1\na\t\nb\n", 8, false)]
         // +---+---+---+----+---+---+---+---+----+
         // | 1 | 2 | 3 | 4  | 5 | 6 | 7 | 8 | 9  |
         // +---+---+---+----+---+---+---+---+----+
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index 38dcb87dd5d..005054134ad 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -370,7 +370,8 @@ public void SaveReadOnly2()
             var doc = new XmlDocumentWithLocation(loadAsReadOnly: true);
             doc.Load(_pathToCommonTargets);
             Assert.True(doc.IsReadOnly);
-            Assert.Throws<InvalidOperationException>(() => {
+            Assert.Throws<InvalidOperationException>(() =>
+            {
                 doc.Save(new MemoryStream());
             });
         }
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 92a1591a313..76cd7c95152 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -2251,13 +2251,16 @@ public void TestTargetFrameworkVersionGreaterThan4()
                 ProjectCollection collection = new ProjectCollection();
                 collection.RegisterLogger(logger);
 
+#pragma warning disable format
 #if !FEATURE_ASPNET_COMPILER
-                Assert.Throws<InvalidProjectFileException>(() => {
+                Assert.Throws<InvalidProjectFileException>(() =>
+                {
 #endif
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, collection.LoggingService);
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, collection.LoggingService);
 #if !FEATURE_ASPNET_COMPILER
                 });
 #endif
+#pragma warning restore format
 
 #if FEATURE_ASPNET_COMPILER
                 Version ver = new Version("4.34");
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index f542b837ee5..30b078d407a 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -49,9 +49,9 @@ public void Dispose()
 
         private static void SetResolverForContext(EvaluationContext context, SdkResolver resolver)
         {
-            var sdkService = (SdkResolverService) context.SdkResolverService;
+            var sdkService = (SdkResolverService)context.SdkResolverService;
 
-            sdkService.InitializeForTests(null, new List<SdkResolver> {resolver});
+            sdkService.InitializeForTests(null, new List<SdkResolver> { resolver });
         }
 
         [Theory]
@@ -408,7 +408,7 @@ public void ContextDisambiguatesSameRelativeGlobsPointingInsideDifferentProjectC
             File.WriteAllText(Path.Combine(projectDirectory2, $"2.{evaluationCount}.cs"), "");
 
             EvaluateProjects(
-                new []
+                new[]
                 {
                     new ProjectSpecification(
                         Path.Combine(projectDirectory1, "1"),
@@ -464,7 +464,7 @@ public void ContextDisambiguatesSameRelativeGlobsPointingOutsideDifferentProject
             File.WriteAllText(Path.Combine(project2GlobDirectory, $"2.{evaluationCount}.cs"), "");
 
             EvaluateProjects(
-                new []
+                new[]
                 {
                     new ProjectSpecification(
                         Path.Combine(project1Directory, "1"),
@@ -526,7 +526,7 @@ public void ContextDisambiguatesAFullyQualifiedGlobPointingInAnotherRelativeGlob
             File.WriteAllText(Path.Combine(project1GlobDirectory, $"{evaluationCount}.cs"), "");
 
             EvaluateProjects(
-                new []
+                new[]
                 {
                     // first project uses a relative path
                     new ProjectSpecification(
@@ -594,7 +594,7 @@ public void ContextDisambiguatesDistinctRelativeGlobsPointingOutsideOfSameProjec
             File.WriteAllText(Path.Combine(globDirectory.Path, $"{evaluationCount}.cs"), "");
 
             EvaluateProjects(
-                new []
+                new[]
                 {
                     new ProjectSpecification(
                         Path.Combine(project1Directory.Path, "1"),
@@ -642,7 +642,7 @@ public void ContextCachesCommonOutOfProjectConeFullyQualifiedGlob(EvaluationCont
             ContextCachesCommonOutOfProjectCone(itemSpecPathIsRelative: false, policy: policy, expectedGlobExpansions: expectedGlobExpansions);
         }
 
-        [Theory (Skip="https://github.com/dotnet/msbuild/issues/3889")]
+        [Theory(Skip = "https://github.com/dotnet/msbuild/issues/3889")]
         [MemberData(nameof(ContextPinsGlobExpansionCacheData))]
         // projects should cache glob expansions when the __relative__ glob is shared between projects and points outside of project cone
         public void ContextCachesCommonOutOfProjectConeRelativeGlob(EvaluationContext.SharingPolicy policy, string[][] expectedGlobExpansions)
@@ -822,7 +822,7 @@ public void ContextCachesExistenceChecksInGetDirectoryNameOfFileAbove(Evaluation
             int evaluationCount = 0;
 
             EvaluateProjects(
-                new []
+                new[]
                 {
                     $@"<Project>
                       <PropertyGroup>
@@ -876,7 +876,7 @@ public void ContextCachesExistenceChecksInGetPathOfFileAbove(EvaluationContext.S
             int evaluationCount = 0;
 
             EvaluateProjects(
-                new []
+                new[]
                 {
                     $@"<Project>
                       <PropertyGroup>
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index e0a0f3dfeee..a4c90de1768 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -567,7 +567,7 @@ public void ExtensionPathsTest_Basic1()
 
             Assert.Equal("unix", allPaths.GetElement(2).OS);
             Assert.Single(allPaths.GetElement(2).PropertyElements);
-            Assert.Equal( @"/tmp/bar", allPaths.GetElement(2).PropertyElements.GetElement("MSBuildExtensionsPath").Value);
+            Assert.Equal(@"/tmp/bar", allPaths.GetElement(2).PropertyElements.GetElement("MSBuildExtensionsPath").Value);
 
             var reader = GetStandardConfigurationReader();
             Dictionary<string, Toolset> toolsets = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
@@ -578,17 +578,17 @@ public void ExtensionPathsTest_Basic1()
             Dictionary<string, ProjectImportPathMatch> pathsTable = toolsets["2.0"].ImportPropertySearchPathsTable;
             if (NativeMethodsShared.IsWindows)
             {
-                CheckPathsTable(pathsTable, "MSBuildExtensionsPath", new string[] {"c:\\foo"});
-                CheckPathsTable(pathsTable, "MSBuildExtensionsPath64", new string[] {"c:\\foo64", "c:\\bar64"});
+                CheckPathsTable(pathsTable, "MSBuildExtensionsPath", new string[] { "c:\\foo" });
+                CheckPathsTable(pathsTable, "MSBuildExtensionsPath64", new string[] { "c:\\foo64", "c:\\bar64" });
             }
             else if (NativeMethodsShared.IsOSX)
             {
-                CheckPathsTable(pathsTable, "MSBuildExtensionsPath", new string[] {"/tmp/foo"});
-                CheckPathsTable(pathsTable, "MSBuildExtensionsPath32", new string[] {"/tmp/foo32", "/tmp/bar32"});
+                CheckPathsTable(pathsTable, "MSBuildExtensionsPath", new string[] { "/tmp/foo" });
+                CheckPathsTable(pathsTable, "MSBuildExtensionsPath32", new string[] { "/tmp/foo32", "/tmp/bar32" });
             }
             else
             {
-                CheckPathsTable(pathsTable, "MSBuildExtensionsPath", new string[] {"/tmp/bar"});
+                CheckPathsTable(pathsTable, "MSBuildExtensionsPath", new string[] { "/tmp/bar" });
             }
         }
 
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index 07ab3ac1d6a..2e9660b6e3e 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -988,7 +988,9 @@ public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
             Assert.Equal(@"some>value", values["2>.0"].Properties["foo"].EvaluatedValue);
         }
 #endif
-        #endregion
+#pragma warning disable format
+    #endregion
+#pragma warning restore format
 
         #region "GetToolsetData tests"
 
diff --git a/src/Build.UnitTests/Definition/Toolset_Tests.cs b/src/Build.UnitTests/Definition/Toolset_Tests.cs
index 5e5a3260b5d..01920d076e7 100644
--- a/src/Build.UnitTests/Definition/Toolset_Tests.cs
+++ b/src/Build.UnitTests/Definition/Toolset_Tests.cs
@@ -119,7 +119,7 @@ public void ValidateToolsetTranslation()
             Toolset t = new Toolset("4.0", "c:\\bar", buildProperties, environmentProperties, globalProperties,
                 subToolsets, "c:\\foo", "4.0", new Dictionary<string, ProjectImportPathMatch>
                 {
-                    ["MSBuildExtensionsPath"] = new ProjectImportPathMatch("MSBuildExtensionsPath", new List<string> {@"c:\foo"})
+                    ["MSBuildExtensionsPath"] = new ProjectImportPathMatch("MSBuildExtensionsPath", new List<string> { @"c:\foo" })
                 });
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index ccd370b5e81..22fc6d68300 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4442,7 +4442,7 @@ public void ThrownInvalidProjectExceptionProperlyHandled()
                 File.WriteAllText(primaryProject, projectContents);
                 File.WriteAllText(import, importContents);
 
-                InvalidProjectFileException ex = Assert.Throws<InvalidProjectFileException>( () =>
+                InvalidProjectFileException ex = Assert.Throws<InvalidProjectFileException>(() =>
                     {
                         Project unused = new Project(primaryProject, null, null);
                     })
diff --git a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
index 378c4394b36..fb3c051da08 100644
--- a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
@@ -63,7 +63,7 @@ public void IncludeShouldPreserveIntermediaryReferences()
             };
 
             var itemsForI = items.Where(i => i.ItemType == "i").ToList();
-            ObjectModelHelpers.AssertItems(new [] {"a", "b", "c"}, itemsForI, mI2_1);
+            ObjectModelHelpers.AssertItems(new[] { "a", "b", "c" }, itemsForI, mI2_1);
 
             var mI2_2 = new Dictionary<string, string>
             {
@@ -75,7 +75,7 @@ public void IncludeShouldPreserveIntermediaryReferences()
             ObjectModelHelpers.AssertItems(
                 new[] { "a", "b", "c", "d", "e", "f", "a", "b", "c" },
                 itemsForI2,
-                new [] { mI2_1, mI2_1 , mI2_1, mI2_2, mI2_2, mI2_2, mI2_2, mI2_2, mI2_2 });
+                new[] { mI2_1, mI2_1, mI2_1, mI2_2, mI2_2, mI2_2, mI2_2, mI2_2, mI2_2 });
         }
 
         [Theory]
@@ -206,7 +206,7 @@ public void UpdateShouldPreserveIntermediaryReferences()
             };
 
             var itemsForI = items.Where(i => i.ItemType == "i").ToList();
-            ObjectModelHelpers.AssertItems(new[] { "a", "b", "c" }, itemsForI, new [] {a, b, c});
+            ObjectModelHelpers.AssertItems(new[] { "a", "b", "c" }, itemsForI, new[] { a, b, c });
 
             var metadataForI2 = new Dictionary<string, string>
             {
@@ -458,7 +458,7 @@ public void ExcludeSeesIntermediaryState()
 
             var items = ObjectModelHelpers.GetItems(projectContent);
 
-            ObjectModelHelpers.AssertItems(new []{"2"}, items);
+            ObjectModelHelpers.AssertItems(new[] { "2" }, items);
         }
 
         [Fact]
@@ -586,7 +586,7 @@ public void LazyWildcardExpansionDoesNotEvaluateWildCardsIfNotReferenced()
 ".Cleanup();
             using (var env = TestEnvironment.Create())
             {
-                var projectFiles = env.CreateTestProjectWithFiles(content, new[] {"foo/extra.props", "foo/a.cs", "foo/b.cs", "bar/c.cs", "bar/d.cs"});
+                var projectFiles = env.CreateTestProjectWithFiles(content, new[] { "foo/extra.props", "foo/a.cs", "foo/b.cs", "bar/c.cs", "bar/d.cs" });
 
                 File.WriteAllText(projectFiles.CreatedFiles[0], import);
 
@@ -650,8 +650,8 @@ public void DifferentExcludesOnSameWildcardProduceDifferentResults(bool cacheFil
 
                     ObjectModelHelpers.AssertItemEvaluationFromProject(
                         projectContents,
-                        inputFiles: new[] {"a.cs", "b.cs", "c.cs"},
-                        expectedInclude: new[] {"a.cs", "b.cs", "c.cs", "b.cs", "c.cs", "b.cs"});
+                        inputFiles: new[] { "a.cs", "b.cs", "c.cs" },
+                        expectedInclude: new[] { "a.cs", "b.cs", "c.cs", "b.cs", "c.cs", "b.cs" });
                 }
             }
             finally
diff --git a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
index 0923131def0..5340df512bd 100644
--- a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
@@ -25,7 +25,7 @@ public class ItemSpec_Tests
         [Fact]
         public void EachFragmentTypeShouldContributeToItemSpecGlob()
         {
-            var itemSpec = CreateItemSpecFrom("a;b*;c*;@(foo)", CreateExpander(new Dictionary<string, string[]> {{"foo", new[] {"d", "e"}}}));
+            var itemSpec = CreateItemSpecFrom("a;b*;c*;@(foo)", CreateExpander(new Dictionary<string, string[]> { { "foo", new[] { "d", "e" } } }));
 
             var itemSpecGlob = itemSpec.ToMSBuildGlob();
 
@@ -59,7 +59,7 @@ public void AbsolutePathsShouldMatch()
         [Fact]
         public void FragmentGlobsWorkAfterStateIsPartiallyInitializedByOtherOperations()
         {
-            var itemSpec = CreateItemSpecFrom("a;b*;c*;@(foo)", CreateExpander(new Dictionary<string, string[]> {{"foo", new[] {"d", "e"}}}));
+            var itemSpec = CreateItemSpecFrom("a;b*;c*;@(foo)", CreateExpander(new Dictionary<string, string[]> { { "foo", new[] { "d", "e" } } }));
 
             int matches;
             // cause partial Lazy state to initialize in the ItemExpressionFragment
@@ -87,7 +87,7 @@ private ProjectInstanceExpander CreateExpander(Dictionary<string, string[]> item
         {
             var itemDictionary = ToItemDictionary(items);
 
-            return new ProjectInstanceExpander(new PropertyDictionary<ProjectPropertyInstance>(), itemDictionary, (IFileSystem) FileSystems.Default);
+            return new ProjectInstanceExpander(new PropertyDictionary<ProjectPropertyInstance>(), itemDictionary, (IFileSystem)FileSystems.Default);
         }
 
         private static ItemDictionary<ProjectItemInstance> ToItemDictionary(Dictionary<string, string[]> itemTypes)
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index c8999cb6d79..d2942ac7a07 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -954,7 +954,7 @@ public void SdkResolverItemsAndPropertiesAreInPreprocessedOutput()
                 var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
                     new Build.BackEnd.SdkResolution.SdkResult(
                         new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
-                        new [] { testDirectory},
+                        new[] { testDirectory },
                         version: null,
                         propertiesToAdd,
                         itemsToAdd,
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index e3787657f65..a58b676f560 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -805,8 +805,8 @@ public override SdkResult Resolve(SdkReference sdk, SdkResolverContext resolverC
                 {
                     SdkName when sdk.Version == SdkExpectedVersion =>
                     factory.IndicateSuccess(ResolvedPath, SdkExpectedVersion),
-                    SdkName => factory.IndicateFailure(new[] {ErrorVersion}),
-                    _ => factory.IndicateFailure(new[] {ErrorName})
+                    SdkName => factory.IndicateFailure(new[] { ErrorVersion }),
+                    _ => factory.IndicateFailure(new[] { ErrorName })
                 };
             }
         }
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
index 3584cd1a2b2..61515cbcb89 100644
--- a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -31,7 +31,7 @@ public class SdkResultEvaluation_Tests : IDisposable
         public SdkResultEvaluation_Tests(ITestOutputHelper log)
         {
             _log = log;
-    
+
             _env = TestEnvironment.Create();
 
             _originalWarnOnUnitializedProperty = BuildParameters.WarnOnUninitializedProperty;
diff --git a/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs b/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
index 3bb784def3e..e949de07967 100644
--- a/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
@@ -241,7 +241,7 @@ public static IEnumerable<object[]> Parse_Invalid_TestData()
             yield return new object[] { "1,2,3,4", typeof(FormatException) }; // Input contains invalid separator
             yield return new object[] { "1.2.3.4.5", typeof(FormatException) }; // Input has more than 4 version components
 
-            yield return new object[] { "1." , typeof(FormatException) }; // Input contains empty component
+            yield return new object[] { "1.", typeof(FormatException) }; // Input contains empty component
             yield return new object[] { "1.2,", typeof(FormatException) }; // Input contains empty component
             yield return new object[] { "1.2.3.", typeof(FormatException) }; // Input contains empty component
             yield return new object[] { "1.2.3.4.", typeof(FormatException) }; // Input contains empty component
@@ -285,7 +285,7 @@ public static void Parse_InvalidInput_ThrowsException(string input, Type excepti
 
         public static IEnumerable<object[]> ToString_TestData()
         {
-            yield return new object[] { new SimpleVersion(1), "1.0.0.0"};
+            yield return new object[] { new SimpleVersion(1), "1.0.0.0" };
             yield return new object[] { new SimpleVersion(1, 2), "1.2.0.0" };
             yield return new object[] { new SimpleVersion(1, 2, 3), "1.2.3.0" };
             yield return new object[] { new SimpleVersion(1, 2, 3, 4), "1.2.3.4" };
diff --git a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
index eec4ca3fb28..090057bc965 100644
--- a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
@@ -24,7 +24,7 @@ public class ExpressionTest : IDisposable
 
         private readonly Expander<ProjectPropertyInstance, ProjectItemInstance> _expander;
 
-        public static readonly IEnumerable<object[]> TrueTests = new []
+        public static readonly IEnumerable<object[]> TrueTests = new[]
         {
             "true or (SHOULDNOTEVALTHIS)", // short circuit
             "(true and false) or true",
@@ -160,9 +160,9 @@ public class ExpressionTest : IDisposable
             "'59264.59264' == '59264.59264'",
             "1" + new String('0', 500) + "==" + "1" + new String('0', 500), /* too big for double, eval as string */
             "'1" + new String('0', 500) + "'=='" + "1" + new String('0', 500) + "'" /* too big for double, eval as string */
-        }.Select(s => new[] {s});
+        }.Select(s => new[] { s });
 
-        public static readonly IEnumerable<object[]> FalseTests = new [] {
+        public static readonly IEnumerable<object[]> FalseTests = new[] {
             "false and SHOULDNOTEVALTHIS", // short circuit
             "$(a)!=no",
             "$(b)==1.1",
@@ -219,7 +219,7 @@ public class ExpressionTest : IDisposable
             "'1" + new String('0', 500) + "'=='01" + new String('0', 500) + "'" /* too big for double, eval as string */
         }.Select(s => new[] { s });
 
-        public static readonly IEnumerable<object[]> ErrorTests = new [] {
+        public static readonly IEnumerable<object[]> ErrorTests = new[] {
             "$",
             "$(",
             "$()",
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 22f7a510ac4..4f9f1124ced 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -368,7 +368,7 @@ public void EmptyErrorLogUsingWarningsErrorsOnly(string loggerOption)
 
                 // Note: Only the ParallelConsoleLogger supports this scenario (log file empty on no error/warn). We
                 // need to explicitly enable it here with the 'ENABLEMPLOGGING' flag.
-                FileLogger fileLogger = new FileLogger {Parameters = $"{loggerOption};logfile={logFile};ENABLEMPLOGGING" };
+                FileLogger fileLogger = new FileLogger { Parameters = $"{loggerOption};logfile={logFile};ENABLEMPLOGGING" };
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index f198b324c2c..1578082417c 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -137,7 +137,7 @@ public void ResolvesViaPlatformLookupTable()
                                                         <Platforms>x64;x86;AnyCPU</Platforms>
                                                     </PropertyGroup>
                                                     </Project>");
-                
+
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x64");
             }
@@ -165,7 +165,7 @@ public void ResolvesViaProjectReferencesPlatformLookupTable()
                                                         <PlatformLookupTable>win32=x86</PlatformLookupTable>
                                                     </PropertyGroup>
                                                     </Project>");
-               
+
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
             }
@@ -220,7 +220,7 @@ public void ResolvesViaSamePlatform()
                                                         <Platforms>x86;x64;AnyCPU</Platforms>
                                                     </PropertyGroup>
                                                     </Project>");
-             
+
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
             }
@@ -247,7 +247,7 @@ public void FailsToResolve()
                                                         <Platforms>x64</Platforms>
                                                     </PropertyGroup>
                                                     </Project>");
-              
+
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
                 // Here we are checking if platform is defined. in this case it should not be since Platorm would be set to the value this project defaults as
                 // in order to avoid dual build errors we remove platform in order to avoid the edge case where a project has global platform set and does not have global platform set
@@ -277,7 +277,7 @@ public void PlatformIsChosenAsDefault()
                                                         <Platforms>x86;AnyCPU</Platforms>
                                                     </PropertyGroup>
                                                     </Project>");
-              
+
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GetPropertyValue("Platform").ShouldBe(GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GetPropertyValue("Platform"));
             }
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 4d28600f8a1..ba7fd24ed0d 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -175,7 +175,7 @@ public static IEnumerable<object[]> GraphsWithUniformSolutionConfigurations
                 foreach (var graph in Graphs)
                 {
                     foreach (
-                        var currentSolutionConfigurationPlatform in SolutionFileBuilder.SolutionConfigurationPlatformsDefaults.Concat(new SolutionConfigurationInSolution[] {null}))
+                        var currentSolutionConfigurationPlatform in SolutionFileBuilder.SolutionConfigurationPlatformsDefaults.Concat(new SolutionConfigurationInSolution[] { null }))
                     {
                         yield return new[]
                         {
@@ -228,7 +228,7 @@ public void SolutionParserIgnoresProjectConfigurationsThatDoNotFullyMatchAnySolu
                 {
                     {"1", _env.CreateFile("1.csproj", string.Empty).Path}
                 },
-                SolutionConfigurationPlatforms = new[] {new SolutionConfigurationInSolution("Foo", "Bar")},
+                SolutionConfigurationPlatforms = new[] { new SolutionConfigurationInSolution("Foo", "Bar") },
                 ProjectConfigurations = new Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>>
                 {
                     {
@@ -579,7 +579,7 @@ public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()
                     {"3", GraphTestingUtilities.CreateProjectFile(_env, 3, new[] {4}, extraContent: MultitargetingSpecificationPropertyGroup).Path},
                     {"4", GraphTestingUtilities.CreateProjectFile(_env, 4).Path}
                 },
-                SolutionDependencies = new[] {("1", "2"), ("3", "4")}
+                SolutionDependencies = new[] { ("1", "2"), ("3", "4") }
             }.BuildSolution();
 
             var graph = new ProjectGraph(_env.CreateFile("solution.sln", solutionContents).Path);
@@ -617,8 +617,8 @@ public void GraphConstructionShouldThrowOnMissingSolutionDependencies()
         {
             var solutionContents = SolutionFileBuilder.FromGraphEdges(
                 _env,
-                new Dictionary<int, int[]> {{1, null}, {2, null}},
-                new[] {("1", new[] {Guid.NewGuid().ToString("B")})}).BuildSolution();
+                new Dictionary<int, int[]> { { 1, null }, { 2, null } },
+                new[] { ("1", new[] { Guid.NewGuid().ToString("B") }) }).BuildSolution();
 
             var solutionFile = _env.CreateFile(
                 "solution.sln",
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index fd6e5a951c3..a5b6cffa035 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Graph.UnitTests
 {
     internal static class GraphTestingUtilities
     {
-        public static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, "true"}}.ToImmutableDictionary();
+        public static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> { { PropertyNames.IsGraphBuild, "true" } }.ToImmutableDictionary();
 
         public const string InnerBuildPropertyName = "InnerBuild";
         public const string InnerBuildPropertiesName = "InnerBuildProperties";
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index dbd8b9edae1..f89c229b50f 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -156,11 +156,11 @@ public void Dispose()
             _env.Dispose();
         }
 
-        
+
 
         [Theory]
         [InlineData(BuildResultCode.Success, new string[] { })]
-        [InlineData(BuildResultCode.Success, new[] {"BuildSelf"})]
+        [InlineData(BuildResultCode.Success, new[] { "BuildSelf" })]
         public void CacheAndUndeclaredReferenceEnforcementShouldAcceptSelfReferences(BuildResultCode expectedBuildResult, string[] targets)
         {
             AssertBuild(targets,
@@ -175,7 +175,7 @@ public void CacheAndUndeclaredReferenceEnforcementShouldAcceptSelfReferences(Bui
         [Fact]
         public void CacheAndUndeclaredReferenceEnforcementShouldAcceptCallTarget()
         {
-            AssertBuild(new []{"CallTarget"},
+            AssertBuild(new[] { "CallTarget" },
                 (result, logger) =>
                 {
                     result.OverallResult.ShouldBe(BuildResultCode.Success);
@@ -199,7 +199,7 @@ public void CacheEnforcementShouldFailWhenReferenceWasNotPreviouslyBuiltWithoutC
         private void CacheEnforcementImpl(bool addContinueOnError)
         {
             AssertBuild(
-                new[] {"BuildDeclaredReference"},
+                new[] { "BuildDeclaredReference" },
                 (result, logger) =>
                 {
                     result.OverallResult.ShouldBe(BuildResultCode.Failure);
@@ -272,7 +272,7 @@ public void EnforcementsCanBeSkipped(string targetName)
         [InlineData("BuildDeclaredReferenceViaTask")]
         public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences(string targetName)
         {
-            AssertBuild(new []{ targetName },
+            AssertBuild(new[] { targetName },
                 (result, logger) =>
                 {
                     result.OverallResult.ShouldBe(BuildResultCode.Success);
@@ -284,9 +284,9 @@ public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences(string targetN
 
         [Theory]
         [InlineData(false, "BuildUndeclaredReference")]
-// [InlineData(false, "BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
+        // [InlineData(false, "BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
         [InlineData(true, "BuildUndeclaredReference")]
-// [InlineData(true, "BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
+        // [InlineData(true, "BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
         public void UndeclaredReferenceEnforcementShouldFailOnUndeclaredReference(bool addContinueOnError, string targetName)
         {
             AssertBuild(new[] { targetName },
@@ -303,7 +303,7 @@ public void UndeclaredReferenceEnforcementShouldFailOnUndeclaredReference(bool a
 
         [Theory]
         [InlineData("BuildUndeclaredReference")]
-// [InlineData("BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
+        // [InlineData("BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
         public void UndeclaredReferenceEnforcementShouldFailOnPreviouslyBuiltButUndeclaredReferences(string targetName)
         {
             AssertBuild(new[] { targetName },
@@ -338,9 +338,9 @@ public static IEnumerable<object[]> UndeclaredReferenceEnforcementShouldNormaliz
 
                 Func<string, string> ToDuplicateSlashes = path => path.Replace("/", "//").Replace(@"\", @"\\");
 
-                var targetNames = new []{"BuildDeclaredReference", /*"BuildDeclaredReferenceViaTask"*/};
+                var targetNames = new[] { "BuildDeclaredReference", /*"BuildDeclaredReferenceViaTask"*/};
 
-                var functions = new[] {Preserve, FullToRelative, ToForwardSlash, ToBackSlash, ToDuplicateSlashes};
+                var functions = new[] { Preserve, FullToRelative, ToForwardSlash, ToBackSlash, ToDuplicateSlashes };
 
                 foreach (var projectReferenceModifier in functions)
                 {
@@ -364,7 +364,7 @@ public static IEnumerable<object[]> UndeclaredReferenceEnforcementShouldNormaliz
         [MemberData(nameof(UndeclaredReferenceEnforcementShouldNormalizeFilePathsTestData))]
         public void UndeclaredReferenceEnforcementShouldNormalizeFilePaths(Func<string, string> projectReferenceModifier, Func<string, string> msbuildProjectModifier, string targetName)
         {
-            AssertBuild(new []{targetName},
+            AssertBuild(new[] { targetName },
                 (result, logger) =>
                 {
                     result.OverallResult.ShouldBe(BuildResultCode.Success);
@@ -417,13 +417,13 @@ private void AssertBuild(
             {
                 if (buildDeclaredReference)
                 {
-                    buildManagerSession.BuildProjectFile(declaredReferenceFile, new[] {"DeclaredReferenceTarget"})
+                    buildManagerSession.BuildProjectFile(declaredReferenceFile, new[] { "DeclaredReferenceTarget" })
                         .OverallResult.ShouldBe(BuildResultCode.Success);
                 }
 
                 if (buildUndeclaredReference)
                 {
-                    buildManagerSession.BuildProjectFile(undeclaredReferenceFile, new[] {"UndeclaredReferenceTarget"})
+                    buildManagerSession.BuildProjectFile(undeclaredReferenceFile, new[] { "UndeclaredReferenceTarget" })
                         .OverallResult.ShouldBe(BuildResultCode.Success);
                 }
 
@@ -481,7 +481,7 @@ public void SkippedTargetsShouldNotTriggerCacheMissEnforcement()
             {
                 // seed caches with results from the reference
                 buildManagerSession.BuildProjectFile(referenceFile).OverallResult.ShouldBe(BuildResultCode.Success);
-                buildManagerSession.BuildProjectFile(referenceFile, new []{"A"}).OverallResult.ShouldBe(BuildResultCode.Success);
+                buildManagerSession.BuildProjectFile(referenceFile, new[] { "A" }).OverallResult.ShouldBe(BuildResultCode.Success);
 
                 buildManagerSession.BuildProjectFile(projectFile).OverallResult.ShouldBe(BuildResultCode.Success);
 
diff --git a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
index 26575faf9aa..ac8b289d30d 100644
--- a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
+++ b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
@@ -267,7 +267,7 @@ private void TestParallelWorkSet(ParallelWorkSetTestCase tt)
 
             _workSet.WaitForAllWorkAndComplete();
             _workSet.IsCompleted.ShouldBeTrue();
-            _workSet.CompletedWork.ShouldBeSameIgnoringOrder((IReadOnlyCollection<KeyValuePair<string, string>>) tt.ExpectedCompletedWork);
+            _workSet.CompletedWork.ShouldBeSameIgnoringOrder((IReadOnlyCollection<KeyValuePair<string, string>>)tt.ExpectedCompletedWork);
         }
     }
 }
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 273d6d4a7eb..234ac76c4cc 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -32,8 +32,8 @@ public class ProjectGraphTests : IDisposable
                                                                                <ProjectReferenceTargets Include='A' Targets='AHelperInner;A' />
                                                                                <ProjectReferenceTargets Include='A' Targets='AHelperOuter' OuterBuild='true' />
                                                                            </ItemGroup>";
-        private static string[] NonOuterBuildTargets = {"AHelperOuter", "AHelperInner", "A"};
-        private static string[] OuterBuildTargets = {"AHelperOuter"};
+        private static string[] NonOuterBuildTargets = { "AHelperOuter", "AHelperInner", "A" };
+        private static string[] OuterBuildTargets = { "AHelperOuter" };
 
         private const string OuterBuildSpecificationWithProjectReferenceTargets = MultitargetingSpecificationPropertyGroup + ProjectReferenceTargetsWithMultitargeting;
 
@@ -51,7 +51,7 @@ public void ConstructWithNoNodes()
             projectGraph.EntryPointNodes.ShouldBeEmpty();
             projectGraph.GraphRoots.ShouldBeEmpty();
             projectGraph.ProjectNodesTopologicallySorted.ShouldBeEmpty();
-            projectGraph.GetTargetLists(new []{"restore", "build"}).ShouldBeEmpty();
+            projectGraph.GetTargetLists(new[] { "restore", "build" }).ShouldBeEmpty();
         }
 
         [Fact]
@@ -141,13 +141,13 @@ public void UpdatingReferencesIsBidirectional()
                 node.AddProjectReference(reference1, referenceItem1, edges);
                 node.AddProjectReference(reference2, referenceItem2, edges);
 
-                node.ProjectReferences.ShouldBeSameIgnoringOrder(new []{reference1, reference2});
+                node.ProjectReferences.ShouldBeSameIgnoringOrder(new[] { reference1, reference2 });
                 node.ReferencingProjects.ShouldBeEmpty();
 
-                reference1.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] {node});
+                reference1.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] { node });
                 reference1.ProjectReferences.ShouldBeEmpty();
 
-                reference2.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] {node});
+                reference2.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] { node });
                 reference2.ProjectReferences.ShouldBeEmpty();
 
                 edges[(node, reference1)].ShouldBe(referenceItem1);
@@ -302,7 +302,7 @@ public void ConstructWithCycle()
                 TransientTestFile entryProject = CreateProjectFile(env, 1, new[] { 2 });
                 var proj2 = CreateProjectFile(env, 2, new[] { 3 });
                 var proj3 = CreateProjectFile(env, 3, new[] { 1 });
-                var projectsInCycle = new List<string> {entryProject.Path, proj3.Path, proj2.Path, entryProject.Path};
+                var projectsInCycle = new List<string> { entryProject.Path, proj3.Path, proj2.Path, entryProject.Path };
                 string expectedErrorMessage = GraphBuilder.FormatCircularDependencyError(projectsInCycle);
                 Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path)).Message.ShouldContain(expectedErrorMessage);
             }
@@ -326,17 +326,17 @@ public void ConstructBigGraphWithCycle()
         {
             using (var env = TestEnvironment.Create())
             {
-                TransientTestFile entryProject = CreateProjectFile(env, 1, new[] {2,3,4});
-                var proj2 = CreateProjectFile(env, 2, new[] {5, 6});
-                var proj3 = CreateProjectFile(env, 3, new[] {2, 8});
+                TransientTestFile entryProject = CreateProjectFile(env, 1, new[] { 2, 3, 4 });
+                var proj2 = CreateProjectFile(env, 2, new[] { 5, 6 });
+                var proj3 = CreateProjectFile(env, 3, new[] { 2, 8 });
                 CreateProjectFile(env, 4);
-                CreateProjectFile(env, 5, new []{9, 10});
-                var proj6 = CreateProjectFile(env, 6, new[] { 7});
+                CreateProjectFile(env, 5, new[] { 9, 10 });
+                var proj6 = CreateProjectFile(env, 6, new[] { 7 });
                 var proj7 = CreateProjectFile(env, 7, new[] { 3 });
                 CreateProjectFile(env, 8);
                 CreateProjectFile(env, 9);
                 CreateProjectFile(env, 10);
-                var projectsInCycle = new List<string> {proj2.Path, proj3.Path, proj7.Path, proj6.Path, proj2.Path };
+                var projectsInCycle = new List<string> { proj2.Path, proj3.Path, proj7.Path, proj6.Path, proj2.Path };
                 var errorMessage = GraphBuilder.FormatCircularDependencyError(projectsInCycle);
                 Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path)).Message.ShouldContain(errorMessage);
             }
@@ -346,12 +346,12 @@ public void ConstructBigGraphWithCycle()
         public void ProjectCollectionShouldNotInfluenceGlobalProperties()
         {
             var entryFile1 = CreateProjectFile(_env, 1, new[] { 3, 4 });
-            var entryFile2 = CreateProjectFile(_env, 2, new []{ 4, 5 });
+            var entryFile2 = CreateProjectFile(_env, 2, new[] { 4, 5 });
             CreateProjectFile(_env, 3);
             CreateProjectFile(_env, 4);
             CreateProjectFile(_env, 5);
 
-            var entryPoint1 = new ProjectGraphEntryPoint(entryFile1.Path, new Dictionary<string, string> {["B"] = "EntryPointB", ["C"] = "EntryPointC"});
+            var entryPoint1 = new ProjectGraphEntryPoint(entryFile1.Path, new Dictionary<string, string> { ["B"] = "EntryPointB", ["C"] = "EntryPointC" });
             var entryPoint2 = new ProjectGraphEntryPoint(entryFile2.Path, null);
 
             var collection = _env.CreateProjectCollection().Collection;
@@ -572,7 +572,7 @@ public void ConstructWithMultipleEntryPoints()
                 TransientTestFile entryProject1 = CreateProjectFile(env, 1, new[] { 3 });
                 TransientTestFile entryProject2 = CreateProjectFile(env, 2, new[] { 3 });
                 CreateProjectFile(env, 3);
-                var projectGraph = new ProjectGraph(new [] { entryProject1.Path, entryProject2.Path });
+                var projectGraph = new ProjectGraph(new[] { entryProject1.Path, entryProject2.Path });
                 projectGraph.ProjectNodes.Count.ShouldBe(3);
 
                 var node1 = GetFirstNodeWithProjectNumber(projectGraph, 1);
@@ -659,7 +659,7 @@ public void ConstructWithMultipleEntryPointsWithDifferentGlobalPropertiesConverg
         [Fact]
         public void ConstructGraphWithDifferentEntryPointsAndGraphRoots()
         {
-            using(var env = TestEnvironment.Create())
+            using (var env = TestEnvironment.Create())
             {
                 TransientTestFile entryProject1 = CreateProjectFile(env, 1, new[] { 4 });
                 TransientTestFile entryProject2 = CreateProjectFile(env, 2, new[] { 4, 5 });
@@ -780,15 +780,15 @@ public void GetTargetsListReturnsEmptyTargetsForNodeIfNoTargetsPropagatedToIt()
         {
             using (var env = TestEnvironment.Create())
             {
-                TransientTestFile entryProject = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] { 2 }, projectReferenceTargets: new Dictionary<string, string[]> { { "A", new []{ "B" }} }, defaultTargets: "A");
+                TransientTestFile entryProject = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] { 2 }, projectReferenceTargets: new Dictionary<string, string[]> { { "A", new[] { "B" } } }, defaultTargets: "A");
                 CreateProjectFile(env: env, projectNumber: 2);
 
                 var projectGraph = new ProjectGraph(entryProject.Path);
                 projectGraph.ProjectNodes.Count.ShouldBe(2);
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new []{ "Foo" });
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new[] { "Foo" });
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new []{ "Foo" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "Foo" });
                 targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBeEmpty();
             }
         }
@@ -800,7 +800,7 @@ public void GetTargetListsReturnsEmptyTargetsForAllNodesWhenDefaultTargetsAreReq
             {
                 // Root project has no default targets.
                 // The project file does not contain any targets
-                TransientTestFile entryProject = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] { 2 }, projectReferenceTargets: new Dictionary<string, string[]> { { "A", new[] { "B" } }}, defaultTargets: string.Empty);
+                TransientTestFile entryProject = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] { 2 }, projectReferenceTargets: new Dictionary<string, string[]> { { "A", new[] { "B" } } }, defaultTargets: string.Empty);
 
                 // Dependency has default targets. Even though it gets called with empty targets, B will not get called,
                 // because target propagation only equates empty targets to default targets for the root nodes.
@@ -823,7 +823,7 @@ public void GetTargetListsDoesNotPropagateEmptyTargets()
             {
                 // Target protocol produces empty target
                 // The project file also does not contain any targets
-                TransientTestFile entryProject = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] { 2 }, projectReferenceTargets: new Dictionary<string, string[]> { { "A", new[] { " ; ; " } }}, defaultTargets: string.Empty);
+                TransientTestFile entryProject = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] { 2 }, projectReferenceTargets: new Dictionary<string, string[]> { { "A", new[] { " ; ; " } } }, defaultTargets: string.Empty);
 
                 // Dependency has default targets. Even though it gets called with empty targets, B will not get called,
                 // because target propagation only equates empty targets to default targets for the root nodes.
@@ -832,9 +832,9 @@ public void GetTargetListsDoesNotPropagateEmptyTargets()
                 var projectGraph = new ProjectGraph(entryProject.Path);
                 projectGraph.ProjectNodes.Count.ShouldBe(2);
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new []{ "A" });
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new[] { "A" });
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new []{ "A" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
                 targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBeEmpty();
             }
         }
@@ -849,7 +849,7 @@ public void GetTargetListsThrowsOnInvalidTargetNames()
                 var projectGraph = new ProjectGraph(entryProject.Path);
                 projectGraph.ProjectNodes.Count.ShouldBe(1);
 
-                Should.Throw<ArgumentException>(() => projectGraph.GetTargetLists(new []{ "   " }));
+                Should.Throw<ArgumentException>(() => projectGraph.GetTargetLists(new[] { "   " }));
             }
         }
 
@@ -862,7 +862,7 @@ public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()
                 var root1 = CreateProjectFile(
                     env: env,
                     projectNumber: 1,
-                    projectReferences: new[] {2},
+                    projectReferences: new[] { 2 },
                     projectReferenceTargets: null,
                     defaultTargets: null,
                     extraContent: ProjectReferenceTargetsWithMultitargeting)
@@ -875,7 +875,7 @@ public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()
 
                 projectGraph.ProjectNodes.Count.ShouldBe(2);
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string> {"A"});
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string> { "A" });
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
 
                 targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
@@ -893,10 +893,10 @@ public void GetTargetsListInnerBuildToInnerBuild()
                             <{InnerBuildPropertyName}>a</{InnerBuildPropertyName}>
                           </PropertyGroup>";
 
-                var root1 =CreateProjectFile(
+                var root1 = CreateProjectFile(
                             env: env,
                             projectNumber: 1,
-                            projectReferences: new[] {2},
+                            projectReferences: new[] { 2 },
                             projectReferenceTargets: null,
                             defaultTargets: null,
                             extraContent: singleTargetedSpec)
@@ -916,7 +916,7 @@ public void GetTargetsListInnerBuildToInnerBuild()
 
                 projectGraph.ProjectNodes.Count.ShouldBe(2);
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string> {"A"});
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string> { "A" });
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
 
                 targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
@@ -950,7 +950,7 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()
 
                 projectGraph.ProjectNodes.Count.ShouldBe(4);
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string> {"A"});
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string> { "A" });
 
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
                 var root = GetFirstNodeWithProjectNumber(projectGraph, 1);
@@ -1086,7 +1086,7 @@ public void GetTargetListsForComplexMultitargetingGraph()
                 CreateProjectFile(
                     env: env,
                     projectNumber: 4,
-                    projectReferences: new []{6},
+                    projectReferences: new[] { 6 },
                     projectReferenceTargets: null,
                     defaultTargets: null,
                     extraContent: ProjectReferenceTargetsWithMultitargeting);
@@ -1116,21 +1116,21 @@ public void GetTargetListsForComplexMultitargetingGraph()
                     defaultTargets: null,
                     extraContent: OuterBuildSpecificationWithProjectReferenceTargets);
 
-                var projectGraph = new ProjectGraph(new[] {root1, root2});
+                var projectGraph = new ProjectGraph(new[] { root1, root2 });
 
                 var dot = projectGraph.ToDot();
 
                 projectGraph.ProjectNodes.Count.ShouldBe(12);
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string> {"A"});
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new List<string> { "A" });
 
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
 
-                AssertMultitargetingNode(1, projectGraph, targetLists, new []{"A"}, NonOuterBuildTargets);
+                AssertMultitargetingNode(1, projectGraph, targetLists, new[] { "A" }, NonOuterBuildTargets);
                 AssertMultitargetingNode(3, projectGraph, targetLists, OuterBuildTargets, NonOuterBuildTargets);
                 AssertMultitargetingNode(6, projectGraph, targetLists, OuterBuildTargets, NonOuterBuildTargets);
 
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new []{"A"});
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "A" });
                 targetLists[GetFirstNodeWithProjectNumber(projectGraph, 4)].ShouldBe(NonOuterBuildTargets);
                 targetLists[GetFirstNodeWithProjectNumber(projectGraph, 5)].ShouldBe(NonOuterBuildTargets);
             }
@@ -1236,14 +1236,14 @@ public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
                 var entryProject = CreateProjectFile(
                     env: env,
                     projectNumber: 1,
-                    projectReferences: new[] {2, 3, 4},
-                    projectReferenceTargets: new Dictionary<string, string[]> {{"Build", new[] {"Build"}}});
+                    projectReferences: new[] { 2, 3, 4 },
+                    projectReferenceTargets: new Dictionary<string, string[]> { { "Build", new[] { "Build" } } });
                 CreateProjectFile(
                     env: env,
                     projectNumber: 2,
                     projectReferences: null,
                     projectReferenceTargets:
-                        new Dictionary<string, string[]> {{"Build", new[] {MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T2"}}},
+                        new Dictionary<string, string[]> { { "Build", new[] { MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T2" } } },
                     defaultTargets: null,
                     extraContent: referenceItem.Format("5", "T51"));
                 CreateProjectFile(
@@ -1251,7 +1251,7 @@ public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
                     projectNumber: 3,
                     projectReferences: null,
                     projectReferenceTargets:
-                        new Dictionary<string, string[]> {{"Build", new[] {MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T3"}}},
+                        new Dictionary<string, string[]> { { "Build", new[] { MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T3" } } },
                     defaultTargets: null,
                     extraContent: referenceItem.Format("5", "T51;T53;T54"));
                 CreateProjectFile(
@@ -1259,7 +1259,7 @@ public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
                     projectNumber: 4,
                     projectReferences: null,
                     projectReferenceTargets:
-                        new Dictionary<string, string[]> {{"Build", new[] {MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T4"}}},
+                        new Dictionary<string, string[]> { { "Build", new[] { MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T4" } } },
                     defaultTargets: null,
                     extraContent: referenceItem.Format("5", ""));
                 CreateProjectFile(env: env, projectNumber: 5, projectReferences: null, projectReferenceTargets: null, defaultTargets: "D51;D52");
@@ -1487,7 +1487,7 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 edges,
-                globalProperties: new Dictionary<string, string> {{"a", "b"}},
+                globalProperties: new Dictionary<string, string> { { "a", "b" } },
                 createProjectFile: (env, projectId, references, _, _, _) => Helpers.CreateProjectFile(
                     env,
                     projectId,
@@ -1497,7 +1497,7 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
                         {"Build", new[] {$"TargetFrom{projectId}", "Build"}}
                     }));
 
-            var targetsPerNode = graph.GetTargetLists(new []{ "Build" });
+            var targetsPerNode = graph.GetTargetLists(new[] { "Build" });
 
             Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;
 
@@ -1525,10 +1525,10 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             }
 
             // edge count
-            Regex.Matches(dot,"->").Count.ShouldBe(edgeCount);
+            Regex.Matches(dot, "->").Count.ShouldBe(edgeCount);
 
             // node count
-            Regex.Matches(dot,"label").Count.ShouldBe(graph.ProjectNodes.Count);
+            Regex.Matches(dot, "label").Count.ShouldBe(graph.ProjectNodes.Count);
         }
 
         [Fact]
@@ -1646,7 +1646,7 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
         [Fact]
         public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] { 2 }, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
             CreateProjectFile(env: _env, projectNumber: 2);
 
             var graph = new ProjectGraph(root);
@@ -1670,7 +1670,7 @@ public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildProperty
             var root = CreateProjectFile(
                 env: _env,
                 projectNumber: 1,
-                projectReferences: new[] {2},
+                projectReferences: new[] { 2 },
                 projectReferenceTargets: null,
                 defaultTargets: null,
                 extraContent: innerBuildViaLocalProperty).Path;
@@ -1693,10 +1693,10 @@ public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildProperty
         [Fact]
         public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] { 2 }, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
             CreateProjectFile(env: _env, projectNumber: 2);
 
-            var graph = new ProjectGraph(root, new Dictionary<string, string> {{InnerBuildPropertyName, "foo"}});
+            var graph = new ProjectGraph(root, new Dictionary<string, string> { { InnerBuildPropertyName, "foo" } });
 
             var dot = graph.ToDot();
 
@@ -1712,9 +1712,9 @@ public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropert
         [Fact]
         public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
         {
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2, 3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
-            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new[] {4});
-            CreateProjectFile(env: _env, projectNumber: 3, projectReferences: new[] {4});
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] { 2, 3 }, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path;
+            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new[] { 4 });
+            CreateProjectFile(env: _env, projectNumber: 3, projectReferences: new[] { 4 });
             CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
 
             var graph = new ProjectGraph(root);
@@ -1738,7 +1738,7 @@ public void InnerBuildsCanHaveSeparateReferences()
                                                 <ProjectReference Condition=`'$({InnerBuildPropertyName})'=='b'` Include=`4.proj;5.proj`/>
                                             </ItemGroup>".Cleanup();
 
-            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] {2, 3}, projectReferenceTargets: null, defaultTargets: null, extraContent: extraInnerBuildReferenceSpec).Path;
+            var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: new[] { 2, 3 }, projectReferenceTargets: null, defaultTargets: null, extraContent: extraInnerBuildReferenceSpec).Path;
             CreateProjectFile(env: _env, projectNumber: 2, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
             CreateProjectFile(env: _env, projectNumber: 3);
             CreateProjectFile(env: _env, projectNumber: 4, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup);
@@ -1761,13 +1761,13 @@ public void InnerBuildsCanHaveSeparateReferences()
 
             innerBuildWithCommonReferences.ProjectReferences.Count.ShouldBe(4);
             var referenceNumbersSet = innerBuildWithCommonReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
-            referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string> {"2", "3"});
+            referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string> { "2", "3" });
 
             var innerBuildWithAdditionalReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GlobalProperties.TryGetValue(InnerBuildPropertyName, out string p) && p == "b");
 
             innerBuildWithAdditionalReferences.ProjectReferences.Count.ShouldBe(8);
             referenceNumbersSet = innerBuildWithAdditionalReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
-            referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string> {"2", "3", "4", "5"});
+            referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string> { "2", "3", "4", "5" });
         }
 
         [Fact]
@@ -1777,9 +1777,9 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
                                                <ProjectReference Include='1.proj' Properties='{InnerBuildPropertyName}=a'/>
                                            </ItemGroup>";
 
-            var additionalGlobalProperties = new Dictionary<string, string> {{"x", "y"}};
+            var additionalGlobalProperties = new Dictionary<string, string> { { "x", "y" } };
 
-            var graph = new ProjectGraph(new []
+            var graph = new ProjectGraph(new[]
             {
                 CreateProjectFile(env: _env, projectNumber: 1, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup).Path,
                 CreateProjectFile(env: _env, projectNumber: 2, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: referenceToInnerBuild).Path
@@ -1802,7 +1802,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
             two.ProjectReferences.ShouldHaveSingleItem();
             two.ProjectReferences.First().ShouldBe(referencedInnerBuild);
 
-            referencedInnerBuild.ReferencingProjects.ShouldBeSameIgnoringOrder(new []{two, outerBuild});
+            referencedInnerBuild.ReferencingProjects.ShouldBeSameIgnoringOrder(new[] { two, outerBuild });
         }
 
         [Fact]
@@ -1813,10 +1813,10 @@ public void StandaloneInnerBuildsCanBeReferencedWithoutOuterBuilds()
                                            </ItemGroup>";
 
             var root = CreateProjectFile(env: _env, projectNumber: 1, projectReferences: null, projectReferenceTargets: null, defaultTargets: null, extraContent: referenceToInnerBuild).Path;
-            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new []{3}, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup + $"<PropertyGroup><{InnerBuildPropertyName}>a</{InnerBuildPropertyName}></PropertyGroup>");
+            CreateProjectFile(env: _env, projectNumber: 2, projectReferences: new[] { 3 }, projectReferenceTargets: null, defaultTargets: null, extraContent: MultitargetingSpecificationPropertyGroup + $"<PropertyGroup><{InnerBuildPropertyName}>a</{InnerBuildPropertyName}></PropertyGroup>");
             CreateProjectFile(env: _env, projectNumber: 3);
 
-            var additionalGlobalProperties = new Dictionary<string, string> {{"x", "y"}};
+            var additionalGlobalProperties = new Dictionary<string, string> { { "x", "y" } };
 
             var graph = new ProjectGraph(root, additionalGlobalProperties);
 
@@ -1843,7 +1843,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
                                                <ProjectReference Include='2.proj' Condition=`'$({InnerBuildPropertyName})' == 'a'` Properties='{InnerBuildPropertyName}=a'/>
                                            </ItemGroup>".Cleanup();
 
-            var additionalGlobalProperties = new Dictionary<string, string> {{"x", "y"}};
+            var additionalGlobalProperties = new Dictionary<string, string> { { "x", "y" } };
 
             var root = CreateProjectFile(
                 env: _env,
@@ -1862,7 +1862,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
                 defaultTargets: null,
                 extraContent: MultitargetingSpecificationPropertyGroup);
 
-            var graph = new ProjectGraph(new [] { root }, additionalGlobalProperties);
+            var graph = new ProjectGraph(new[] { root }, additionalGlobalProperties);
 
             var dot = graph.ToDot();
 
@@ -1887,7 +1887,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
             // the outer build is necessary as the referencing inner build can still call targets on it
             GetNodesWithProjectNumber(graph, 2).Count().ShouldBe(2);
 
-            innerBuild1WithReferenceToInnerBuild2.ProjectReferences.ShouldBeSameIgnoringOrder(new []{outerBuild2, innerBuild2});
+            innerBuild1WithReferenceToInnerBuild2.ProjectReferences.ShouldBeSameIgnoringOrder(new[] { outerBuild2, innerBuild2 });
         }
 
         public static IEnumerable<object[]> AllNodesShouldHaveGraphBuildGlobalPropertyData
@@ -2000,8 +2000,8 @@ public void UserValuesForIsGraphBuildGlobalPropertyShouldBePreserved()
             {
                 var projectGraph = Helpers.CreateProjectGraph(
                     env,
-                    new Dictionary<int, int[]> {{1, null}},
-                    new Dictionary<string, string> {{PropertyNames.IsGraphBuild, "xyz"}});
+                    new Dictionary<int, int[]> { { 1, null } },
+                    new Dictionary<string, string> { { PropertyNames.IsGraphBuild, "xyz" } });
 
                 projectGraph.ProjectNodes.First().ProjectInstance.GlobalProperties[PropertyNames.IsGraphBuild].ShouldBe("xyz");
             }
@@ -2191,14 +2191,14 @@ public void TransitiveReferencesShouldNotBeAddedToOuterBuilds()
                 }
             );
 
-            GetOuterBuild(graph, 1).AssertReferencesIgnoringOrder(new []{1, 1});
+            GetOuterBuild(graph, 1).AssertReferencesIgnoringOrder(new[] { 1, 1 });
 
             var innerBuilds1 = GetInnerBuilds(graph, 1);
             innerBuilds1.Count.ShouldBe(2);
 
             foreach (var innerBuild in innerBuilds1)
             {
-                innerBuild.AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
+                innerBuild.AssertReferencesIgnoringOrder(new[] { 3, 4, 4, 4, 5, 6, 6, 6 });
             }
 
             GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new[] { 3, 4, 4, 4, 5, 6, 6, 6 });
@@ -2210,7 +2210,7 @@ public void TransitiveReferencesShouldNotBeAddedToOuterBuilds()
 
             foreach (var innerBuild in innerBuilds4)
             {
-                innerBuild.AssertReferencesIgnoringOrder(new []{5, 6, 6, 6});
+                innerBuild.AssertReferencesIgnoringOrder(new[] { 5, 6, 6, 6 });
             }
         }
 
@@ -2273,10 +2273,10 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
     <ProjectReferenceTargets Include='Build' Targets='BuildForOuterBuild' OuterBuild='true' />
 </ItemGroup>");
 
-            var targetLists = graph.GetTargetLists(new[] {"Build"});
+            var targetLists = graph.GetTargetLists(new[] { "Build" });
 
             var outerBuild1 = GetOuterBuild(graph, 1);
-            targetLists[outerBuild1].ShouldBe(new[] {"Build"});
+            targetLists[outerBuild1].ShouldBe(new[] { "Build" });
 
             AssertOuterBuild(outerBuild1, graph, expectedInnerBuildCount: 2);
 
@@ -2286,11 +2286,11 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
             foreach (var inner1 in innerBuildsFor1)
             {
                 // Outer build targets are added to inner builds because
-                targetLists[inner1].ShouldBe(new[] {"BuildForOuterBuild", "Build"});
+                targetLists[inner1].ShouldBe(new[] { "BuildForOuterBuild", "Build" });
             }
 
             var outerBuild2 = GetOuterBuild(graph, 2);
-            targetLists[outerBuild2].ShouldBe(new[] {"BuildForOuterBuild"});
+            targetLists[outerBuild2].ShouldBe(new[] { "BuildForOuterBuild" });
             AssertOuterBuild(outerBuild2, graph, expectedInnerBuildCount: 2);
 
             var innerBuildsFor2 = GetInnerBuilds(graph, 2);
@@ -2298,7 +2298,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             foreach (var inner2 in innerBuildsFor2)
             {
-                targetLists[inner2].ShouldBe(new[] {"BuildForOuterBuild", "Build", "1ATarget", "1BTarget"});
+                targetLists[inner2].ShouldBe(new[] { "BuildForOuterBuild", "Build", "1ATarget", "1BTarget" });
             }
 
             var outerBuild3 = GetOuterBuild(graph, 3);
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index cb40be2fbad..fdf70c9d99d 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -44,11 +44,11 @@ public void Dispose()
         private readonly MockLogger _logger;
 
         [Theory]
-        [InlineData(new byte[] {})]
-        [InlineData(new byte[] {1})]
-        [InlineData(new byte[] {0})]
-        [InlineData(new byte[] {1, 1})]
-        [InlineData(new byte[] {1, 1, 90, 23})]
+        [InlineData(new byte[] { })]
+        [InlineData(new byte[] { 1 })]
+        [InlineData(new byte[] { 0 })]
+        [InlineData(new byte[] { 1, 1 })]
+        [InlineData(new byte[] { 1, 1, 90, 23 })]
         public void InvalidCacheFilesShouldLogError(byte[] cacheContents)
         {
             var project = CreateProjectFileWithBuildTargetAndItems(_env, 1).Path;
@@ -63,7 +63,7 @@ public void InvalidCacheFilesShouldLogError(byte[] cacheContents)
                 _logger,
                 new BuildParameters
                 {
-                    InputResultsCacheFiles = new[] {existingFile}
+                    InputResultsCacheFiles = new[] { existingFile }
                 });
 
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
@@ -102,9 +102,9 @@ public void CachesGetLogged()
             {
                 buildManager.BeginBuild(new BuildParameters
                 {
-                    InputResultsCacheFiles = new []{"a", "b"},
+                    InputResultsCacheFiles = new[] { "a", "b" },
                     OutputResultsCacheFile = "c",
-                    Loggers = new []{_logger}
+                    Loggers = new[] { _logger }
                 });
 
                 buildManager.EndBuild();
@@ -164,7 +164,7 @@ public void RebuildSingleProjectFromCache(string defaultTargets, string explicit
                 _logger,
                 new BuildParameters
                 {
-                    InputResultsCacheFiles = new[] {outputCache}
+                    InputResultsCacheFiles = new[] { outputCache }
                 });
 
             resultFromCachedBuild.OverallResult.ShouldBe(BuildResultCode.Success);
@@ -456,7 +456,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
 
                 var logger = new MockLogger();
 
-                buildParameters.Loggers = new[] {logger};
+                buildParameters.Loggers = new[] { logger };
 
                 var result = BuildProjectFileUsingBuildManager(
                     node.ProjectInstance.FullPath,
@@ -553,7 +553,7 @@ public void NonExistingInputResultsCacheShouldLogError()
                 _logger,
                 new BuildParameters
                 {
-                    InputResultsCacheFiles = new[] {"FileDoesNotExist1", existingFile, "FileDoesNotExist2"}
+                    InputResultsCacheFiles = new[] { "FileDoesNotExist1", existingFile, "FileDoesNotExist2" }
                 });
 
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
diff --git a/src/Build.UnitTests/Instance/ProjectItemGroupTaskItemInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectItemGroupTaskItemInstance_Internal_Tests.cs
index 2ce98e6f74d..105bee4fb0d 100644
--- a/src/Build.UnitTests/Instance/ProjectItemGroupTaskItemInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectItemGroupTaskItemInstance_Internal_Tests.cs
@@ -42,7 +42,7 @@ public void ProjectItemGroupTaskItemInstanceCanSerializeViaTranslator(List<Proje
         {
             var original = CreateTargetItem(null, metadata);
 
-            ((ITranslatable) original).Translate(TranslationHelpers.GetWriteTranslator());
+            ((ITranslatable)original).Translate(TranslationHelpers.GetWriteTranslator());
             var clone = ProjectItemGroupTaskItemInstance.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal(original, clone, new TargetItemComparer());
diff --git a/src/Build.UnitTests/Instance/ProjectPropertyGroupTaskPropertyInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectPropertyGroupTaskPropertyInstance_Internal_Tests.cs
index 3b7790a1104..bd657854590 100644
--- a/src/Build.UnitTests/Instance/ProjectPropertyGroupTaskPropertyInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectPropertyGroupTaskPropertyInstance_Internal_Tests.cs
@@ -20,7 +20,7 @@ public void ProjectPropertyGroupTaskPropertyInstanceCanSerializeViaTranslator()
         {
             var original = CreateTargetProperty();
 
-            ((ITranslatable) original).Translate(TranslationHelpers.GetWriteTranslator());
+            ((ITranslatable)original).Translate(TranslationHelpers.GetWriteTranslator());
             var copy = ProjectPropertyGroupTaskPropertyInstance.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal(original, copy, new TargetPropertyComparer());
diff --git a/src/Build.UnitTests/Instance/ProjectTargetInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectTargetInstance_Internal_Tests.cs
index 924d55be3f5..16cc6ccc764 100644
--- a/src/Build.UnitTests/Instance/ProjectTargetInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectTargetInstance_Internal_Tests.cs
@@ -78,7 +78,7 @@ public void ProjectTargetInstanceCanSerializeViaTranslator(
         {
             var original = CreateTarget(null, children, errorChildren);
 
-            ((ITranslatable) original).Translate(TranslationHelpers.GetWriteTranslator());
+            ((ITranslatable)original).Translate(TranslationHelpers.GetWriteTranslator());
             var copy = ProjectTargetInstance.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal(original, copy, new TargetComparer());
diff --git a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
index 0c32202a0a8..89bd094fd1a 100644
--- a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
@@ -77,7 +77,7 @@ public void ProjectTaskInstanceCanSerializeViaTranslator(
 
             var original = CreateTargetTask(null, parametersCopy, outputs);
 
-            ((ITranslatable) original).Translate(TranslationHelpers.GetWriteTranslator());
+            ((ITranslatable)original).Translate(TranslationHelpers.GetWriteTranslator());
             var copy = ProjectTaskInstance.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal(original, copy, new TargetTaskComparer());
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 405f2716d21..32fb90014ae 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -186,7 +186,7 @@ char Chr(int projectNumber)
                         CacheResultType.CacheNotApplicable => 'N',
                         CacheResultType.None => 'E',
                         _ => throw new ArgumentOutOfRangeException()
-                        };
+                    };
                 }
             }
         }
@@ -1360,7 +1360,7 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
         [InlineData(true, true)]
         public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousLogging, bool disableInprocNode)
         {
-            var referenceNumbers = new []{2, 3, 4};
+            var referenceNumbers = new[] { 2, 3, 4 };
 
             var testData = new GraphCacheResponse(
                 new Dictionary<int, int[]?>
@@ -1608,7 +1608,7 @@ public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
                                 Interlocked.Increment(ref cacheHitCount);
                                 return Task.FromResult(
                                     CacheResult.IndicateCacheHit(
-                                        new ProxyTargets(new Dictionary<string, string> {{proxyTarget, cacheHitTarget}})));
+                                        new ProxyTargets(new Dictionary<string, string> { { proxyTarget, cacheHitTarget } })));
                             }
                         }
                     }),
@@ -1653,7 +1653,7 @@ private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, Erro
         {
             foreach (var enumValue in Enum.GetValues(typeof(ErrorLocations)))
             {
-                var typedValue = (ErrorLocations) enumValue;
+                var typedValue = (ErrorLocations)enumValue;
                 if (errorLocations.HasFlag(typedValue))
                 {
                     var exceptionLocation = typedValue.ToString();
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 19f04cfe9c3..4f47e92e38f 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -95,7 +95,7 @@ public static SolutionFileBuilder FromGraph(
             return new SolutionFileBuilder
             {
                 Projects = graph.ProjectNodes.ToDictionary(
-                    n => GraphTestingUtilities.GetProjectNumber((ProjectGraphNode) n).ToString(),
+                    n => GraphTestingUtilities.GetProjectNumber((ProjectGraphNode)n).ToString(),
                     n => n.ProjectInstance.FullPath),
                 ProjectConfigurations = projectConfigurations,
                 SolutionDependencies = solutionDependencies,
@@ -121,7 +121,7 @@ public string BuildSolution()
                     projectInfos.ShouldContainKey(parent);
                     projectInfos.ShouldContainKey(dependency);
 
-                    projectInfos[parent].AddDependency(projectInfos[dependency]); 
+                    projectInfos[parent].AddDependency(projectInfos[dependency]);
                 }
             }
 
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 8c6e8c82f23..4d1f5521ad7 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -861,7 +861,7 @@ public void TestTargetFrameworkPaths()
         public void NoLinkMetadataSynthesisWhenDefinedInProject()
         {
             string[] files = null;
-            string outputPath = Path.Combine(Path.GetTempPath(),Guid.NewGuid().ToString("N"));
+            string outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
 
             try
             {
diff --git a/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs b/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
index ef9e52db8b9..17fffc10a6f 100644
--- a/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
+++ b/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
@@ -27,7 +27,7 @@ public bool Equals(ProjectInstance x, ProjectInstance y)
                 Assert.Equal(x.Properties, y.Properties, EqualityComparer<ProjectPropertyInstance>.Default);
                 Assert.Equal(x.TestEnvironmentalProperties, y.TestEnvironmentalProperties, EqualityComparer<ProjectPropertyInstance>.Default);
                 Helpers.AssertDictionariesEqual(x.GlobalProperties, y.GlobalProperties);
-                Assert.Equal(((EvaluatorData) x).GlobalPropertiesToTreatAsLocal, ((EvaluatorData) y).GlobalPropertiesToTreatAsLocal);
+                Assert.Equal(((EvaluatorData)x).GlobalPropertiesToTreatAsLocal, ((EvaluatorData)y).GlobalPropertiesToTreatAsLocal);
 
                 Assert.Equal(x.Items.ToArray(), y.Items.ToArray(), ProjectItemInstance.ProjectItemInstanceEqualityComparer.Default);
 
@@ -119,22 +119,22 @@ public bool Equals(ProjectTargetInstanceChild x, ProjectTargetInstanceChild y)
             {
                 if (x is ProjectItemGroupTaskInstance)
                 {
-                    return new TargetItemGroupComparer().Equals((ProjectItemGroupTaskInstance) x, (ProjectItemGroupTaskInstance) y);
+                    return new TargetItemGroupComparer().Equals((ProjectItemGroupTaskInstance)x, (ProjectItemGroupTaskInstance)y);
                 }
 
                 if (x is ProjectPropertyGroupTaskInstance)
                 {
-                    return new TargetPropertyGroupComparer().Equals((ProjectPropertyGroupTaskInstance) x, (ProjectPropertyGroupTaskInstance) y);
+                    return new TargetPropertyGroupComparer().Equals((ProjectPropertyGroupTaskInstance)x, (ProjectPropertyGroupTaskInstance)y);
                 }
 
                 if (x is ProjectOnErrorInstance)
                 {
-                    return new TargetOnErrorComparer().Equals((ProjectOnErrorInstance) x, (ProjectOnErrorInstance) y);
+                    return new TargetOnErrorComparer().Equals((ProjectOnErrorInstance)x, (ProjectOnErrorInstance)y);
                 }
 
                 if (x is ProjectTaskInstance)
                 {
-                    return new TargetTaskComparer().Equals((ProjectTaskInstance) x, (ProjectTaskInstance) y);
+                    return new TargetTaskComparer().Equals((ProjectTaskInstance)x, (ProjectTaskInstance)y);
                 }
 
                 throw new NotImplementedException();
@@ -359,11 +359,11 @@ public bool Equals(ProjectTaskInstanceChild x, ProjectTaskInstanceChild y)
             {
                 if (x is ProjectTaskOutputItemInstance)
                 {
-                    return new ProjectTaskOutputItemComparer().Equals((ProjectTaskOutputItemInstance) x, (ProjectTaskOutputItemInstance) y);
+                    return new ProjectTaskOutputItemComparer().Equals((ProjectTaskOutputItemInstance)x, (ProjectTaskOutputItemInstance)y);
                 }
                 if (x is ProjectTaskOutputPropertyInstance)
                 {
-                    return new ProjectTaskOutputPropertyComparer().Equals((ProjectTaskOutputPropertyInstance) x, (ProjectTaskOutputPropertyInstance) y);
+                    return new ProjectTaskOutputPropertyComparer().Equals((ProjectTaskOutputPropertyInstance)x, (ProjectTaskOutputPropertyInstance)y);
                 }
 
                 throw new NotImplementedException();
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index 57d28cb6411..d32ac025aec 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -274,7 +274,7 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
         }
 
         [Theory]
-        
+
         [InlineData("MSB1235", "MSB1234", "MSB1234", "MSB1234", false)] // Log MSB1234, treat as error via MSBuildWarningsAsErrors
         [InlineData("MSB1235", "", "MSB1234", "MSB1234", true)] // Log MSB1234, expect MSB1234 as error via MSBuildTreatWarningsAsErrors
         [InlineData("MSB1234", "MSB1234", "MSB1234", "MSB4181", true)]// Log MSB1234, MSBuildWarningsAsMessages takes priority
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 12a3d83376e..559353ea2a5 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -49,7 +49,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         // TODO: Figure out a more elegant way to do this.
         //       The rationale for this is that we can detect during design-time builds in the Evaluator (which populates this) that the project cache will be used so that we don't
         //       need to evaluate the project at build time just to figure that out, which would regress perf for scenarios which don't use the project cache.
-        internal static ConcurrentDictionary<ProjectCacheDescriptor, ProjectCacheDescriptor> ProjectCacheDescriptors { get; } = new (ProjectCacheDescriptorEqualityComparer.Instance);
+        internal static ConcurrentDictionary<ProjectCacheDescriptor, ProjectCacheDescriptor> ProjectCacheDescriptors { get; } = new(ProjectCacheDescriptorEqualityComparer.Instance);
 
         /// <summary>
         /// The object used for thread-safe synchronization of static members.
@@ -1386,7 +1386,7 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
                 config.GlobalProperties,
                 config.ExplicitToolsVersionSpecified ? config.ToolsVersion : null,
                 _buildParameters,
-                ((IBuildComponentHost) this).LoggingService,
+                ((IBuildComponentHost)this).LoggingService,
                 request.BuildEventContext,
                 false /* loaded by solution parser*/,
                 config.TargetNames,
@@ -1404,7 +1404,8 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
                 // metaproject as well.
                 var newConfig = new BuildRequestConfiguration(
                     GetNewConfigurationId(),
-                    instances[i]) { ExplicitlyLoaded = config.ExplicitlyLoaded };
+                    instances[i])
+                { ExplicitlyLoaded = config.ExplicitlyLoaded };
                 if (_configCache.GetMatchingConfiguration(newConfig) == null)
                 {
                     _configCache.AddConfiguration(newConfig);
@@ -1623,7 +1624,7 @@ private void WaitForAllLoggingServiceEventsToBeProcessed()
             // this has to be called out of the lock (_syncLock)
             // because processing events can callback to 'this' instance and cause deadlock
             Debug.Assert(!Monitor.IsEntered(_syncLock));
-            ((LoggingService) ((IBuildComponentHost) this).LoggingService).WaitForLoggingToProcessEvents();
+            ((LoggingService)((IBuildComponentHost)this).LoggingService).WaitForLoggingToProcessEvents();
         }
 
         /// <summary>
@@ -1759,7 +1760,7 @@ void IssueBuildSubmissionToSchedulerImpl(BuildSubmission submission, bool allowM
                             }
                         }
 
-                        BuildRequestBlocker blocker = new BuildRequestBlocker(-1, Array.Empty<string>(), new[] {submission.BuildRequest});
+                        BuildRequestBlocker blocker = new BuildRequestBlocker(-1, Array.Empty<string>(), new[] { submission.BuildRequest });
 
                         HandleNewRequest(Scheduler.VirtualNode, blocker);
                     }
@@ -3096,7 +3097,7 @@ public LoggerVerbosity Verbosity
             public string Parameters
             {
                 get => String.Empty;
-                set{ }
+                set { }
             }
 
             /// <summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 5bc3111c107..616c94134c9 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -413,7 +413,7 @@ public IDictionary<string, string> EnvironmentProperties
             get
             {
                 return new ReadOnlyConvertingDictionary<string, ProjectPropertyInstance, string>(_environmentProperties,
-                    instance => ((IProperty) instance).EvaluatedValueEscaped);
+                    instance => ((IProperty)instance).EvaluatedValueEscaped);
             }
         }
 
@@ -448,7 +448,7 @@ public IDictionary<string, string> GlobalProperties
             get
             {
                 return new ReadOnlyConvertingDictionary<string, ProjectPropertyInstance, string>(_globalProperties,
-                    instance => ((IProperty) instance).EvaluatedValueEscaped);
+                    instance => ((IProperty)instance).EvaluatedValueEscaped);
             }
 
             set
@@ -859,7 +859,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _shutdownInProcNodeOnBuildFinish);
             translator.Translate(ref _logTaskInputs);
             translator.Translate(ref _logInitialPropertiesAndItems);
-            translator.TranslateEnum(ref _projectLoadSettings, (int) _projectLoadSettings);
+            translator.TranslateEnum(ref _projectLoadSettings, (int)_projectLoadSettings);
             translator.Translate(ref _interactive);
             translator.Translate(ref _isolateProjects);
 
@@ -871,7 +871,7 @@ void ITranslatable.Translate(ITranslator translator)
             // LowPriority is passed as an argument to new nodes, so it doesn't need to be transmitted here.
         }
 
-#region INodePacketTranslatable Members
+        #region INodePacketTranslatable Members
 
         /// <summary>
         /// The class factory for deserialization.
@@ -881,7 +881,7 @@ internal static BuildParameters FactoryForDeserialization(ITranslator translator
             return new BuildParameters(translator);
         }
 
-#endregion
+        #endregion
 
         /// <summary>
         /// Gets the value of a boolean environment setting which is not expected to change.
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 262b3eedd79..0375a078d63 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -412,7 +412,7 @@ private void ConfigureAndQueryConsoleProperties()
 
             return (acceptAnsiColorCodes: acceptAnsiColorCodes, outputIsScreen: outputIsScreen);
         }
-        
+
         private int QueryConsoleBufferWidth()
         {
             int consoleBufferWidth = -1;
@@ -492,7 +492,7 @@ private bool TryLaunchServer()
             }
             catch (IOException ex) when (ex is not PathTooLongException)
             {
-                CommunicationsUtilities.Trace("Failed to obtain the current build server state: {0}",  ex);
+                CommunicationsUtilities.Trace("Failed to obtain the current build server state: {0}", ex);
                 CommunicationsUtilities.Trace("HResult: {0}.", ex.HResult);
                 _exitResult.MSBuildClientExitType = MSBuildClientExitType.UnknownServerState;
                 return false;
@@ -526,7 +526,7 @@ private bool TryLaunchServer()
         private bool TrySendShutdownCommand()
         {
             _packetPump.ServerWillDisconnect();
-            return  TrySendPacket(() => new NodeBuildComplete(false /* no node reuse */));
+            return TrySendPacket(() => new NodeBuildComplete(false /* no node reuse */));
         }
 
         private ServerNodeBuildCommand GetServerNodeBuildCommand()
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 89066fc9ef4..2c6f41ecc8b 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -262,7 +262,7 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
 
                                 while (packetBytesRead < packetLength)
                                 {
-                                    int bytesRead = localStream.Read(packetData, packetBytesRead, packetLength-packetBytesRead);
+                                    int bytesRead = localStream.Read(packetData, packetBytesRead, packetLength - packetBytesRead);
                                     if (bytesRead == 0)
                                     {
                                         // Incomplete read.  Abort.
@@ -271,7 +271,7 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
 
                                     packetBytesRead += bytesRead;
                                 }
-                                
+
                                 try
                                 {
                                     _packetFactory.DeserializeAndRoutePacket(0, packetType, _binaryReadTranslator);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
index b415350f1e6..988670a5429 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
@@ -116,7 +116,7 @@ public override bool Equals(object obj)
                 return false;
             }
 
-            return GetType() == obj.GetType() && InternalEquals((FullyQualifiedBuildRequest) obj);
+            return GetType() == obj.GetType() && InternalEquals((FullyQualifiedBuildRequest)obj);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index ce4c5fc154b..421252cd1f6 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -215,7 +215,7 @@ public int GetSmallestConfigId()
                 return _configurations.OrderBy(kvp => kvp.Key).First().Key;
             }
         }
-    
+
         /// <summary>
         /// Clears configurations from the configuration cache which have not been explicitly loaded.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index f932844178b..f5300bd4517 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -242,7 +242,7 @@ public void Translate(ITranslator translator)
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
             {
-                _resultsByConfiguration = (ConcurrentDictionary<int, BuildResult>) localReference;
+                _resultsByConfiguration = (ConcurrentDictionary<int, BuildResult>)localReference;
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 5cdcd483a30..e8060949d2a 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -373,14 +373,14 @@ private bool InstantiateNode(INodePacketFactory factory)
 #if FEATURE_THREAD_CULTURE
             _inProcNodeThread = new Thread(InProcNodeThreadProc, BuildParameters.ThreadStackSize);
 #else
-                CultureInfo culture = _componentHost.BuildParameters.Culture;
-                CultureInfo uiCulture = _componentHost.BuildParameters.UICulture;
-                _inProcNodeThread = new Thread(() =>
-                {
-                    CultureInfo.CurrentCulture = culture;
-                    CultureInfo.CurrentUICulture = uiCulture;
-                    InProcNodeThreadProc();
-                });
+            CultureInfo culture = _componentHost.BuildParameters.Culture;
+            CultureInfo uiCulture = _componentHost.BuildParameters.UICulture;
+            _inProcNodeThread = new Thread(() =>
+            {
+                CultureInfo.CurrentCulture = culture;
+                CultureInfo.CurrentUICulture = uiCulture;
+                InProcNodeThreadProc();
+            });
 #endif
             _inProcNodeThread.Name = String.Format(CultureInfo.CurrentCulture, "In-proc Node ({0})", _componentHost.Name);
             _inProcNodeThread.IsBackground = true;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 3511a7ed454..d9c2fc64d35 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -111,7 +111,7 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool
 
             // We wait for child nodes to exit to avoid them changing the terminal
             // after this process terminates.
-            bool waitForExit =  !enableReuse &&
+            bool waitForExit = !enableReuse &&
                                 !Console.IsInputRedirected &&
                                 Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index c3e040ef0fe..42cf7350002 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -376,7 +376,8 @@ internal static void ClearCachedTaskHostPaths()
         internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostContext)
         {
             ErrorUtilities.VerifyThrowInternalErrorUnreachable((hostContext & HandshakeOptions.TaskHost) == HandshakeOptions.TaskHost);
-            if ((hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2) {
+            if ((hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            {
                 return TaskHostNameForClr2TaskHost;
             }
             else
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 11aea7b2c52..6affa4233b6 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -91,11 +91,11 @@ public static T FactoryForDeserializingTypeWithName<T>(this ITranslator translat
                     return constructor;
                 });
 
-            var targetInstanceChild = (ITranslatable) parameterlessConstructor.Invoke(Array.Empty<object>());
+            var targetInstanceChild = (ITranslatable)parameterlessConstructor.Invoke(Array.Empty<object>());
 
             targetInstanceChild.Translate(translator);
 
-            return (T) targetInstanceChild;
+            return (T)targetInstanceChild;
         }
 
         public static void TranslateOptionalBuildEventContext(this ITranslator translator, ref BuildEventContext buildEventContext)
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 5604021e28a..96888a30f45 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -95,7 +95,7 @@ internal sealed class EventSourceSink :
         /// occurred.  It is raised on every event.
         /// </summary>
         public event AnyEventHandler AnyEventRaised;
-        
+
         /// <summary>
         /// This event is raised to log telemetry.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index c8018767633..615048f7a64 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -275,7 +275,7 @@ internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
         /// </summary>
         /// <param name="filePath">Path to response file</param>
         internal void LogIncludeFile(string filePath)
-        { 
+        {
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             _loggingService.LogIncludeFile(BuildEventContext, filePath);
         }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 957300c06ac..4be970bd9cb 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -234,7 +234,7 @@ private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
         {
             try
             {
-                return (ProjectCachePluginBase) Activator.CreateInstance(pluginType)!;
+                return (ProjectCachePluginBase)Activator.CreateInstance(pluginType)!;
             }
             catch (TargetInvocationException e) when (e.InnerException != null)
             {
@@ -268,7 +268,7 @@ Assembly LoadAssembly(string resolverPath)
             IEnumerable<Type> GetTypes<T>(Assembly assembly)
             {
                 return assembly.ExportedTypes
-                    .Select(type => new {type, info = type.GetTypeInfo()})
+                    .Select(type => new { type, info = type.GetTypeInfo() })
                     .Where(
                         t => t.info.IsClass &&
                              t.info.IsPublic &&
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs b/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs
index 2379042fe5f..f94ff615c9a 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs
@@ -46,7 +46,7 @@ void ITranslatable.Translate(ITranslator translator)
         internal static ProxyTargets FactoryForDeserialization(ITranslator translator)
         {
             var instance = new ProxyTargets();
-            ((ITranslatable) instance).Translate(translator);
+            ((ITranslatable)instance).Translate(translator);
 
             return instance;
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index cc55c5c90d3..6b7df33a1f6 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -55,7 +55,7 @@ void ITranslatable.Translate(ITranslator translator)
         internal static TargetSpecification FactoryForDeserialization(ITranslator translator)
         {
             var instance = new TargetSpecification();
-            ((ITranslatable) instance).Translate(translator);
+            ((ITranslatable)instance).Translate(translator);
 
             return instance;
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 4ee0c78cae4..d6ca0d77a27 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -450,8 +450,8 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                     e.BuildEventContext = _taskLoggingContext.BuildEventContext;
                     _taskLoggingContext.LoggingService.LogBuildEvent(e);
                 }
-                
-                 _taskLoggingContext.HasLoggedErrors = true;
+
+                _taskLoggingContext.HasLoggedErrors = true;
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index d7a21d38548..76465422559 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -618,7 +618,7 @@ public void InitializeComponent(IBuildComponentHost host)
             _componentHost = host;
             _resultsCache = (IResultsCache)_componentHost.GetComponent(BuildComponentType.ResultsCache);
             _configCache = (IConfigCache)_componentHost.GetComponent(BuildComponentType.ConfigCache);
-            _inprocNodeContext =  new NodeLoggingContext(_componentHost.LoggingService, InProcNodeId, true);
+            _inprocNodeContext = new NodeLoggingContext(_componentHost.LoggingService, InProcNodeId, true);
         }
 
         /// <summary>
@@ -1631,7 +1631,7 @@ private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRe
 
             // detect the case for https://github.com/dotnet/msbuild/issues/3047
             // if we have partial results AND blocked and blocking share the same configuration AND are blocked on each other
-            if (blocker.PartialBuildResult !=null &&
+            if (blocker.PartialBuildResult != null &&
                 blockingRequest.BuildRequest.ConfigurationId == blockedRequest.BuildRequest.ConfigurationId &&
                 blockingRequest.RequestsWeAreBlockedBy.Contains(blockedRequest))
             {
@@ -1964,7 +1964,7 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
             emitNonErrorLogs = _ => { };
 
             var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;
-            var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);
+            var configCache = (IConfigCache)_componentHost.GetComponent(BuildComponentType.ConfigCache);
 
             // do not check root requests as nothing depends on them
             if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 0b9e5ceecb8..5970ce0338e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -126,7 +126,7 @@ private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk,
             SendPacket(packet);
 
             // Wait for either the response or a shutdown event.  Either event means this thread should return
-            WaitHandle.WaitAny(new WaitHandle[] {_responseReceivedEvent, ShutdownEvent});
+            WaitHandle.WaitAny(new WaitHandle[] { _responseReceivedEvent, ShutdownEvent });
 
             // Keep track of the element location of the reference
             _lastResponse.ElementLocation = sdkReferenceLocation;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 96f5e14e981..7e46d3e31b6 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -37,7 +37,7 @@ internal class SdkResolverLoader
         internal virtual IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
         {
             var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
-                new List<SdkResolver> {new DefaultSdkResolver()}
+                new List<SdkResolver> { new DefaultSdkResolver() }
                 : new List<SdkResolver>();
 
             return resolvers;
@@ -47,7 +47,7 @@ internal virtual IList<SdkResolver> LoadAllResolvers(LoggingContext loggingConte
             ElementLocation location)
         {
             var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
-                new List<SdkResolver> {new DefaultSdkResolver()}
+                new List<SdkResolver> { new DefaultSdkResolver() }
                 : new List<SdkResolver>();
 
             var potentialResolvers = FindPotentialSdkResolvers(
@@ -228,7 +228,7 @@ private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolver
         protected virtual IEnumerable<Type> GetResolverTypes(Assembly assembly)
         {
             return assembly.ExportedTypes
-                .Select(type => new {type, info = type.GetTypeInfo()})
+                .Select(type => new { type, info = type.GetTypeInfo() })
                 .Where(t => t.info.IsClass && t.info.IsPublic && !t.info.IsAbstract && typeof(SdkResolver).IsAssignableFrom(t.type))
                 .Select(t => t.type);
         }
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 52f8dfc21db..cec28e77c6e 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -137,7 +137,7 @@ public LoggingNodeConfiguration LoggingNodeConfiguration
             { return _loggingNodeConfiguration; }
         }
 
-#region INodePacket Members
+        #region INodePacket Members
 
         /// <summary>
         /// Retrieves the packet type.
@@ -149,9 +149,9 @@ public NodePacketType Type
             { return NodePacketType.NodeConfiguration; }
         }
 
-#endregion
+        #endregion
 
-#region INodePacketTranslatable Members
+        #region INodePacketTranslatable Members
 
         /// <summary>
         /// Translates the packet to/from binary form.
@@ -177,7 +177,7 @@ internal static INodePacket FactoryForDeserialization(ITranslator translator)
             configuration.Translate(translator);
             return configuration;
         }
-#endregion
+        #endregion
 
         /// <summary>
         /// We need to clone this object since it gets modified for each node which is launched.
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index f45bb803573..3e954fb824f 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -153,7 +153,7 @@ public OutOfProcNode()
             // Create a factory for the out-of-proc SDK resolver service which can pass our SendPacket delegate to be used for sending packets to the main node
             OutOfProcNodeSdkResolverServiceFactory sdkResolverServiceFactory = new OutOfProcNodeSdkResolverServiceFactory(SendPacket);
 
-            ((IBuildComponentHost) this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
+            ((IBuildComponentHost)this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
 
             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
 
@@ -833,7 +833,7 @@ private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
                     }
                 }
             }
-            
+
             _shutdownEvent.Set();
         }
     }
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 18297977aaa..11e5f7ebda7 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -111,7 +111,7 @@ public NodeEngineShutdownReason Run(out Exception? shutdownException)
                 return NodeEngineShutdownReason.Error;
             }
 
-            while(true)
+            while (true)
             {
                 NodeEngineShutdownReason shutdownReason = RunInternal(out shutdownException, handshake);
                 if (shutdownReason != NodeEngineShutdownReason.BuildCompleteReuse)
@@ -331,7 +331,7 @@ private void HandleServerNodeBuildCommandAsync(ServerNodeBuildCommand command)
                 {
                     HandleServerNodeBuildCommand(command);
                 }
-                catch(Exception e)
+                catch (Exception e)
                 {
                     _shutdownException = e;
                     _shutdownReason = NodeEngineShutdownReason.Error;
@@ -415,7 +415,7 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
                 Console.SetOut(oldOut);
                 Console.SetError(oldErr);
             }
-          
+
             // On Windows, a process holds a handle to the current directory,
             // so reset it away from a user-requested folder that may get deleted.
             NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
diff --git a/src/Build/BackEnd/Node/ServerNodeBuildCancel.cs b/src/Build/BackEnd/Node/ServerNodeBuildCancel.cs
index 67cd7f0df7f..6c852dcfaa1 100644
--- a/src/Build/BackEnd/Node/ServerNodeBuildCancel.cs
+++ b/src/Build/BackEnd/Node/ServerNodeBuildCancel.cs
@@ -4,7 +4,7 @@
 namespace Microsoft.Build.BackEnd
 {
     internal sealed class ServerNodeBuildCancel : INodePacket
-    { 
+    {
         public NodePacketType Type => NodePacketType.ServerNodeBuildCancel;
 
         public void Translate(ITranslator translator)
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 26d41241e41..e13ea57d48f 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -298,7 +298,7 @@ private void TranslateItems(ITranslator translator)
                 // rough guess for an average number of bytes needed to store them.  This doesn't have to be accurate, just
                 // big enough to avoid unnecessary buffer reallocations in most cases.
                 var defaultBufferCapacity = _items.Length * 128;
-                
+
                 using var itemsStream = new MemoryStream(defaultBufferCapacity);
                 var itemTranslator = BinaryTranslator.GetWriteTranslator(itemsStream);
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index ce0b8db4ad0..211a9204a90 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1108,7 +1108,7 @@ out parameterSet
                     // flag an error if we find a parameter that has no .NET property equivalent
                     _taskLoggingContext.LogError
                         (
-                        new BuildEventFileInfo( parameterLocation ),
+                        new BuildEventFileInfo(parameterLocation),
                         "UnexpectedTaskAttribute",
                         parameterName,
                         _taskName,
diff --git a/src/Build/Collections/MultiDictionary.cs b/src/Build/Collections/MultiDictionary.cs
index 1f34c6009bb..387330e1532 100644
--- a/src/Build/Collections/MultiDictionary.cs
+++ b/src/Build/Collections/MultiDictionary.cs
@@ -245,7 +245,7 @@ public void Add(TT value)
                 }
                 else if (_entry is TT)
                 {
-                    var list = new List<TT> { (TT) _entry, value };
+                    var list = new List<TT> { (TT)_entry, value };
                     _entry = list;
                 }
                 else
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
index 735c08b2a37..659e4e6557e 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
@@ -92,7 +92,7 @@ internal static int ExpandPrime(int oldSize)
 
             // Allow the hashtables to grow to maximum possible size (~2G elements) before encoutering capacity overflow.
             // Note that this check works even when _items.Length overflowed thanks to the (uint) cast
-            if ((uint) newSize > MaxPrimeArrayLength)
+            if ((uint)newSize > MaxPrimeArrayLength)
             {
                 return MaxPrimeArrayLength;
             }
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 663c824dbfd..42e8663c27e 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -120,7 +120,7 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
         // temporary variable needed during deserialization
         private SerializationInfo _siInfo;
 
-#region Constructors
+        #region Constructors
 
         public RetrievableEntryHashSet(IEqualityComparer<string> comparer)
         {
@@ -203,7 +203,7 @@ protected RetrievableEntryHashSet(SerializationInfo info, StreamingContext conte
             _siInfo = info;
         }
 
-#endregion
+        #endregion
 
         // Convenience to minimise change to callers used to dictionaries
         public ICollection<string> Keys
@@ -229,7 +229,7 @@ public ICollection<T> Values
             get { return this; }
         }
 
-#region ICollection<T> methods
+        #region ICollection<T> methods
 
         // Convenience to minimise change to callers used to dictionaries
         internal T this[string name]
@@ -486,9 +486,9 @@ internal void MakeReadOnly()
             _readOnly = true;
         }
 
-#endregion
+        #endregion
 
-#region IEnumerable methods
+        #region IEnumerable methods
 
         public Enumerator GetEnumerator()
         {
@@ -513,9 +513,9 @@ IEnumerator IEnumerable.GetEnumerator()
             return new Enumerator(this);
         }
 
-#endregion
+        #endregion
 
-#region ISerializable methods
+        #region ISerializable methods
 
         // [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
         [SecurityCritical]
@@ -538,9 +538,9 @@ public virtual void GetObjectData(SerializationInfo info, StreamingContext conte
             }
         }
 
-#endregion
+        #endregion
 
-#region IDeserializationCallback methods
+        #region IDeserializationCallback methods
 
         public virtual void OnDeserialization(Object sender)
         {
@@ -585,9 +585,9 @@ public virtual void OnDeserialization(Object sender)
             _siInfo = null;
         }
 
-#endregion
+        #endregion
 
-#region HashSet methods
+        #region HashSet methods
 
         /// <summary>
         /// Add item to this HashSet. 
@@ -1161,9 +1161,9 @@ public static IEqualityComparer<RetrievableEntryHashSet<T>> CreateSetComparer()
 #endif
 #endif
 
-#endregion
+        #endregion
 
-#region Helper methods
+        #region Helper methods
 
         /// <summary>
         /// Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
@@ -1708,7 +1708,7 @@ private static bool AreEqualityComparersEqual(RetrievableEntryHashSet<T> set1, R
                                                                                                                                                                 return set1.Comparer.Equals(set2.Comparer);
         }
 #endif
-       
+
         private int InternalGetHashCode(string item, int index, int length)
         {
             // No need to check for null 'item' as we own all comparers
@@ -1734,7 +1734,7 @@ private int InternalGetHashCode(string item)
             return _comparer.GetHashCode(item) & Lower31BitMask;
         }
 
-#endregion
+        #endregion
 
         // used for set checking operations (using enumerables) that rely on counting
         internal struct ElementCount
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index f27a1a95d87..2e5791c0a59 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -90,7 +90,7 @@ internal virtual bool ExpressedAsAttribute
                     _expressedAsAttribute = value;
                     Parent?.AddToXml(this);
                     MarkDirty("Set express as attribute: {0}", value.ToString());
-                }                
+                }
             }
         }
 
@@ -210,7 +210,7 @@ public IEnumerable<ProjectElementContainer> AllParents
         public ProjectElement PreviousSibling
         {
             [DebuggerStepThrough]
-            get => Link != null? Link.PreviousSibling : _previousSibling;
+            get => Link != null ? Link.PreviousSibling : _previousSibling;
             [DebuggerStepThrough]
             internal set => _previousSibling = value;
         }
@@ -291,10 +291,10 @@ internal set
         /// In the case of an unsaved edit, the location only
         /// contains the path to the file that the element originates from.
         /// </summary>
-        public ElementLocation Location => Link != null ? Link.Location :  XmlElement.Location;
+        public ElementLocation Location => Link != null ? Link.Location : XmlElement.Location;
 
         /// <inheritdoc/>
-        public string ElementName => Link != null? Link.ElementName : XmlElement.Name;
+        public string ElementName => Link != null ? Link.ElementName : XmlElement.Name;
 
         // Using ILinkedXml to share single field for either Linked (external) and local (XML backed) nodes.
         private ILinkedXml _xmlSource;
@@ -331,7 +331,7 @@ internal XmlDocumentWithLocation XmlDocument
             [DebuggerStepThrough]
             get
             {
-                return (XmlDocumentWithLocation) XmlElement?.OwnerDocument;
+                return (XmlDocumentWithLocation)XmlElement?.OwnerDocument;
             }
         }
 
diff --git a/src/Build/Construction/ProjectImportElement.cs b/src/Build/Construction/ProjectImportElement.cs
index 36ba393d7be..0c14225ac30 100644
--- a/src/Build/Construction/ProjectImportElement.cs
+++ b/src/Build/Construction/ProjectImportElement.cs
@@ -144,7 +144,7 @@ public string MinimumVersion
         internal static ProjectImportElement CreateDisconnected(string project, ProjectRootElement containingProject)
         {
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.import);
-            return new ProjectImportElement(element, containingProject) {Project = project};
+            return new ProjectImportElement(element, containingProject) { Project = project };
         }
 
         /// <summary>
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index 3bf4639787c..d39aba7acfa 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -104,7 +104,7 @@ public string Include
 
             set
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(String.IsNullOrEmpty(value) || (Remove.Length == 0 && Update.Length == 0) , "OM_OneOfAttributeButNotMore", ElementName, XMakeAttributes.include, XMakeAttributes.remove, XMakeAttributes.update);
+                ErrorUtilities.VerifyThrowInvalidOperation(String.IsNullOrEmpty(value) || (Remove.Length == 0 && Update.Length == 0), "OM_OneOfAttributeButNotMore", ElementName, XMakeAttributes.include, XMakeAttributes.remove, XMakeAttributes.update);
                 SetOrRemoveAttribute(XMakeAttributes.include, value, ref _include, "Set item Include {0}", value);
                 _includeHasWildcards = null;
             }
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index 2acd6b83299..946de50c5e3 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -67,7 +67,7 @@ public string Name
             {
                 if (value)
                 {
-                    ValidateValidMetadataAsAttributeName(Name, Parent?.ElementName ?? "null" , Parent?.Location);
+                    ValidateValidMetadataAsAttributeName(Name, Parent?.ElementName ?? "null", Parent?.Location);
                 }
                 base.ExpressedAsAttribute = value;
             }
diff --git a/src/Build/Construction/ProjectOnErrorElement.cs b/src/Build/Construction/ProjectOnErrorElement.cs
index a1564143564..ab665319f9d 100644
--- a/src/Build/Construction/ProjectOnErrorElement.cs
+++ b/src/Build/Construction/ProjectOnErrorElement.cs
@@ -76,7 +76,7 @@ internal static ProjectOnErrorElement CreateDisconnected(string executeTargets,
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.onError);
 
             var onError = new ProjectOnErrorElement(element, containingProject) { ExecuteTargetsAttribute = executeTargets };
-            
+
             return onError;
         }
 
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 3463e872980..a8619927227 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -238,7 +238,7 @@ bool preserveFormatting
         /// <remarks>
         /// Do not make public: we do not wish to expose particular XML API's.
         /// </remarks>
-        private ProjectRootElement(XmlDocumentWithLocation document, ProjectRootElementCacheBase  projectRootElementCache)
+        private ProjectRootElement(XmlDocumentWithLocation document, ProjectRootElementCacheBase projectRootElementCache)
         {
             ErrorUtilities.VerifyThrowArgumentNull(document, nameof(document));
             ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, nameof(projectRootElementCache));
@@ -789,7 +789,8 @@ public static ProjectRootElement Create(string path, ProjectCollection projectCo
 
             var projectRootElement = new ProjectRootElement(
                 projectCollection.ProjectRootElementCache,
-                newProjectFileOptions) { FullPath = path };
+                newProjectFileOptions)
+            { FullPath = path };
 
             return projectRootElement;
         }
@@ -1239,7 +1240,7 @@ public ProjectUsingTaskElement AddUsingTask(string name, string assemblyFile, st
         /// </summary>
         public ProjectChooseElement CreateChooseElement()
         {
-            return Link!=null ? RootLink.CreateChooseElement() : ProjectChooseElement.CreateDisconnected(this);
+            return Link != null ? RootLink.CreateChooseElement() : ProjectChooseElement.CreateDisconnected(this);
         }
 
         /// <summary>
@@ -1266,7 +1267,7 @@ public ProjectItemElement CreateItemElement(string itemType)
         /// </summary>
         public ProjectItemElement CreateItemElement(string itemType, string include)
         {
-            if (Link != null )
+            if (Link != null)
             {
                 return RootLink.CreateItemElement(itemType, include);
             }
@@ -2054,7 +2055,7 @@ private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveForma
         {
             ErrorUtilities.VerifyThrowInternalRooted(fullPath);
 
-            var document = new XmlDocumentWithLocation(loadAsReadOnly ? true : (bool?) null)
+            var document = new XmlDocumentWithLocation(loadAsReadOnly ? true : (bool?)null)
             {
                 FullPath = fullPath,
                 PreserveWhitespace = preserveFormatting
@@ -2104,7 +2105,7 @@ private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveForma
         /// </summary>
         private static XmlDocumentWithLocation LoadDocument(XmlReader reader, bool preserveFormatting)
         {
-            var document = new XmlDocumentWithLocation {PreserveWhitespace = preserveFormatting};
+            var document = new XmlDocumentWithLocation { PreserveWhitespace = preserveFormatting };
 
             try
             {
diff --git a/src/Build/Construction/ProjectUsingTaskParameterElement.cs b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
index 668f40c97c9..c2fab76444a 100644
--- a/src/Build/Construction/ProjectUsingTaskParameterElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
@@ -75,7 +75,7 @@ public string Name
                 XmlElementWithLocation newElement = XmlUtilities.RenameXmlElement(XmlElement, value, XmlElement.NamespaceURI);
                 ReplaceElement(newElement);
 
-                 // SetOrRemoveAttribute(XMakeAttributes.name, value, "Set usingtaskparameter {0}", value);
+                // SetOrRemoveAttribute(XMakeAttributes.name, value, "Set usingtaskparameter {0}", value);
             }
         }
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 0ba22cdf4e7..b6d40f0987c 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2660,9 +2660,9 @@ private static IMSBuildGlob CreateIncludeGlobWithGaps(IMSBuildGlob includeGlob,
             {
                 return (excludeGlob, removeGlob) switch
                 {
-                    (null,     null)     => includeGlob,
-                    (not null, null)     => new MSBuildGlobWithGaps(includeGlob, excludeGlob),
-                    (null,     not null) => new MSBuildGlobWithGaps(includeGlob, removeGlob),
+                    (null, null) => includeGlob,
+                    (not null, null) => new MSBuildGlobWithGaps(includeGlob, excludeGlob),
+                    (null, not null) => new MSBuildGlobWithGaps(includeGlob, removeGlob),
                     (not null, not null) => new MSBuildGlobWithGaps(includeGlob, new CompositeGlob(excludeGlob, removeGlob))
                 };
             }
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 838e95574fc..020f6439d7e 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -613,7 +613,7 @@ public ICollection<ILogger> Loggers
                 using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _loggingService.Loggers == null
-                        ? (ICollection<ILogger>) ReadOnlyEmptyCollection<ILogger>.Instance
+                        ? (ICollection<ILogger>)ReadOnlyEmptyCollection<ILogger>.Instance
                         : new List<ILogger>(_loggingService.Loggers);
                 }
             }
@@ -1090,7 +1090,7 @@ internal ICollection<Project> GetLoadedProjects(bool includeExternal, string ful
             List<Project> loaded;
             using (_locker.EnterDisposableWriteLock())
             {
-                    loaded = fullPath == null ? new List<Project>(_loadedProjects) : new List<Project>(_loadedProjects.GetMatchingProjectsIfAny(fullPath));
+                loaded = fullPath == null ? new List<Project>(_loadedProjects) : new List<Project>(_loadedProjects.GetMatchingProjectsIfAny(fullPath));
             }
 
             if (includeExternal)
@@ -1495,7 +1495,7 @@ public void Dispose()
             GC.SuppressFinalize(this);
         }
 
-#region IBuildComponent Members
+        #region IBuildComponent Members
 
         /// <summary>
         /// Initializes the component with the component host.
@@ -1512,7 +1512,7 @@ void IBuildComponent.ShutdownComponent()
         {
         }
 
-#endregion
+        #endregion
 
         /// <summary>
         /// Unloads a project XML root element from the cache entirely, if it is not
@@ -1934,7 +1934,7 @@ public ReusableLogger(ILogger originalLogger)
                 _originalLogger = originalLogger;
             }
 
-#region IEventSource Members
+            #region IEventSource Members
 
             /// <summary>
             /// The Message logging event
@@ -2161,7 +2161,7 @@ public void Shutdown()
                 }
             }
 
-#endregion
+            #endregion
 
             /// <summary>
             /// Registers for all of the events on the specified event source.
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 6dd0d58102c..ba6ad15f653 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -270,7 +270,7 @@ public int DirectMetadataCount
         {
             [DebuggerStepThrough]
             get
-            { return Link != null ? Link.DirectMetadata.Count  : _directMetadata != null ? _directMetadata.Count : 0; }
+            { return Link != null ? Link.DirectMetadata.Count : _directMetadata != null ? _directMetadata.Count : 0; }
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index db1aa93901e..09d20be8cb2 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -267,8 +267,8 @@ private static Configuration ReadOpenMappedExeConfiguration()
         {
             // When running from the command-line or from VS, use the msbuild.exe.config file.
             if (BuildEnvironmentHelper.Instance.Mode != BuildEnvironmentMode.None &&
- // This FEATURE_SYSTEM_CONFIGURATION is needed as OpenExeConfiguration for net5.0 works differently, without this condition unit tests won't pass.
- // ConfigurationManager.OpenExeConfiguration in net5.0 will find testhost.exe instead which does not contain any configuration and therefore fail.
+                // This FEATURE_SYSTEM_CONFIGURATION is needed as OpenExeConfiguration for net5.0 works differently, without this condition unit tests won't pass.
+                // ConfigurationManager.OpenExeConfiguration in net5.0 will find testhost.exe instead which does not contain any configuration and therefore fail.
 #if FEATURE_SYSTEM_CONFIGURATION
                 !BuildEnvironmentHelper.Instance.RunningTests &&
 #endif
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index f2393bfcbc1..04e987866cf 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -853,5 +853,5 @@ public static MSBuildExtensionsPathReferenceKind FindIn(string expression)
 
             return MSBuildExtensionsPathReferenceKind.None;
         }
-     }
+    }
 }
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 9b8b04e1736..3f9b3b0883d 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -174,7 +174,7 @@ public override void Load(string fullPath)
 
             _fullPath = fullPath;
 
-            using(var xtr = XmlReaderExtension.Create(fullPath, _loadAsReadOnly ?? false))
+            using (var xtr = XmlReaderExtension.Create(fullPath, _loadAsReadOnly ?? false))
             {
                 this.Load(xtr.Reader);
             }
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index df40e7472de..e74ccd61994 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -95,7 +95,7 @@ bool initializationException
             ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
             ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
             ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(helpKeyword), "Must specify the help keyword for the IDE.");
-            
+
             this.e = e;
             this.errorCode = errorCode;
             this.helpKeyword = helpKeyword;
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 7d9b891a484..5ab37b9d02b 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -67,7 +67,7 @@ private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem, ISdkReso
         /// </summary>
         public static EvaluationContext Create(SharingPolicy policy)
         {
-            
+
             // ReSharper disable once IntroduceOptionalParameters.Global
             // do not remove this method to avoid breaking binary compatibility
             return Create(policy, fileSystem: null);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 3deaa98dbdc..162e9dfd923 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1778,7 +1778,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
 
                     _evaluationLoggingContext.LogBuildEvent(eventArgs);
                 }
-                
+
                 return;
             }
 
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 88e5fea6c1b..a60a58f91c4 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3236,7 +3236,7 @@ internal static Function<T> ExtractPropertyFunction(
                 IFileSystem fileSystem)
             {
                 // Used to aggregate all the components needed for a Function
-                FunctionBuilder<T> functionBuilder = new FunctionBuilder<T> {FileSystem = fileSystem};
+                FunctionBuilder<T> functionBuilder = new FunctionBuilder<T> { FileSystem = fileSystem };
 
                 // By default the expression root is the whole function expression
                 ReadOnlySpan<char> expressionRoot = expressionFunction == null ? ReadOnlySpan<char>.Empty : expressionFunction.AsSpan();
@@ -3453,7 +3453,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             //
                             string startingDirectory = String.IsNullOrWhiteSpace(elementLocation.File) ? String.Empty : Path.GetDirectoryName(elementLocation.File);
 
-                            args = new []
+                            args = new[]
                             {
                                 args[0],
                                 startingDirectory,
@@ -3852,7 +3852,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         {
                             if (ElementsOfType(args, typeof(string)))
                             {
-                                returnVal = IntrinsicFunctions.NormalizePath(Array.ConvertAll(args, o => (string) o));
+                                returnVal = IntrinsicFunctions.NormalizePath(Array.ConvertAll(args, o => (string)o));
                                 return true;
                             }
                         }
@@ -4158,7 +4158,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 default:
                                     if (ElementsOfType(args, typeof(string)))
                                     {
-                                        returnVal = Path.Combine(Array.ConvertAll(args, o => (string) o));
+                                        returnVal = Path.Combine(Array.ConvertAll(args, o => (string)o));
                                         return true;
                                     }
                                     break;
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index ce0f37bbd56..9d3d07f54e5 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -594,7 +594,7 @@ public static bool IsRunningFromVisualStudio()
             return BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio;
         }
 
-#region Debug only intrinsics
+        #region Debug only intrinsics
 
         /// <summary>
         /// returns if the string contains escaped wildcards
@@ -604,7 +604,7 @@ internal static List<string> __GetListTest()
             return new List<string> { "A", "B", "C", "D" };
         }
 
-#endregion
+        #endregion
 
         /// <summary>
         /// Following function will parse a keyName and returns the basekey for it.
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index d7f58c8088a..6c3ade3872c 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -145,7 +145,7 @@ private bool InitReferencedItemsIfNecessary()
         ///     The expander needs to have a default item factory set.
         /// </summary>
         // todo Make this type immutable. Dealing with an Expander change is painful. See the ItemExpressionFragment
-            public Expander<P, I> Expander { get; set; }
+        public Expander<P, I> Expander { get; set; }
 
         /// <summary>
         ///     The xml attribute where this itemspec comes from
@@ -583,7 +583,7 @@ internal MetadataTrie(MatchOnMetadataOptions options, IEnumerable<string> metada
                 options == MatchOnMetadataOptions.CaseInsensitive || FileUtilities.PathComparison == StringComparison.OrdinalIgnoreCase ? StringComparer.OrdinalIgnoreCase :
                 StringComparer.Ordinal;
             _children = new Dictionary<string, MetadataTrie<P, I>>(comparer);
-            _normalize = options == MatchOnMetadataOptions.PathLike ? (Func<string, string>) (p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory)) : p => p;
+            _normalize = options == MatchOnMetadataOptions.PathLike ? (Func<string, string>)(p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory)) : p => p;
             foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)
             {
                 foreach (ItemSpec<P, I>.ReferencedItem referencedItem in frag.ReferencedItems)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 2e0cf86d90d..7f90b4c250e 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -32,7 +32,7 @@ private abstract class LazyItemOperation : IItemOperation
             //  the items and then removes them
             protected readonly IItemFactory<I, I> _itemFactory;
             internal ItemSpec<P, I> Spec => _itemSpec;
-            
+
             protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)
             {
                 _itemElement = builder.ItemElement;
@@ -113,7 +113,7 @@ public ItemBatchingContext(I operationItem, Dictionary<string, I> capturedItems
                 public IMetadataTable GetMetadataTable()
                 {
                     return CapturedItems == null
-                        ? (IMetadataTable) OperationItem
+                        ? (IMetadataTable)OperationItem
                         : new ItemOperationMetadataTable(OperationItem, CapturedItems);
                 }
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index ce7db6202e4..85b6764d711 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -169,7 +169,7 @@ private bool QualifiedMetadataReferencesExist(ImmutableList<ProjectMetadataEleme
 
             private static bool ItemSpecContainsItemReferences(ItemSpec<P, I> itemSpec)
             {
-                return itemSpec.Fragments.Any(f => f is ItemSpec<P,I>.ItemExpressionFragment);
+                return itemSpec.Fragments.Any(f => f is ItemSpec<P, I>.ItemExpressionFragment);
             }
         }
     }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 99d92be2005..7f8ad466334 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -477,7 +477,7 @@ private class OperationBuilder
 
             public ProjectItemElement ItemElement { get; set; }
             public string ItemType { get; set; }
-            public ItemSpec<P,I> ItemSpec { get; set; }
+            public ItemSpec<P, I> ItemSpec { get; set; }
 
             public ImmutableDictionary<string, LazyItemList>.Builder ReferencedItemLists { get; } = Traits.Instance.EscapeHatches.UseCaseSensitiveItemNames ?
                 ImmutableDictionary.CreateBuilder<string, LazyItemList>() :
diff --git a/src/Build/Evaluation/Preprocessor.cs b/src/Build/Evaluation/Preprocessor.cs
index 7655b5b0faa..9dabfd80dc1 100644
--- a/src/Build/Evaluation/Preprocessor.cs
+++ b/src/Build/Evaluation/Preprocessor.cs
@@ -283,7 +283,7 @@ private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination)
                     string sdk = importSdk.Length > 0 ? $" {XMakeAttributes.sdk}=\"{importSdk}\"" : String.Empty;
 
                     // Get the Sdk attribute of the Project element if specified
-                    string projectSdk = source.NodeType == XmlNodeType.Element && String.Equals(XMakeElements.project, source.Name, StringComparison.Ordinal) ? ((XmlElement) source).GetAttribute(XMakeAttributes.sdk) : String.Empty;
+                    string projectSdk = source.NodeType == XmlNodeType.Element && String.Equals(XMakeElements.project, source.Name, StringComparison.Ordinal) ? ((XmlElement)source).GetAttribute(XMakeAttributes.sdk) : String.Empty;
 
                     IList<ProjectRootElement> resolvedList;
                     if (!_importTable.TryGetValue((XmlElement)child, out resolvedList))
diff --git a/src/Build/Evaluation/Profiler/EvaluationProfiler.cs b/src/Build/Evaluation/Profiler/EvaluationProfiler.cs
index bc7adaf312e..8ff51bac3ec 100644
--- a/src/Build/Evaluation/Profiler/EvaluationProfiler.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationProfiler.cs
@@ -145,7 +145,7 @@ public void Dispose()
                 {
                     previousTimeSpent = new ProfiledLocation(TimeSpan.Zero, TimeSpan.Zero, 0);
                 }
-                
+
                 var updatedTimeSpent = new ProfiledLocation(
                         previousTimeSpent.InclusiveTime + _inclusiveTime.Elapsed,
                         previousTimeSpent.ExclusiveTime + _exclusiveTime.Elapsed,
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index fd9f087f7a9..dff5d41c12d 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -635,7 +635,7 @@ private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation el
                         if (onError != null)
                         {
                             ProjectErrorUtilities.ThrowInvalidProject(onError.Location, "NodeMustBeLastUnderElement", XMakeElements.onError, XMakeElements.target, childElement.Name);
-                        }                       
+                        }
                         if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
                         {
                             if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 208a43ed668..1f055d88bd0 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -218,7 +218,8 @@ internal override ProjectRootElement Get(string projectFile, OpenProjectRootElem
                 "Reentrance to the ProjectRootElementCache.Get function detected."
             );
 
-            try {
+            try
+            {
 #endif
                 // Should already have been canonicalized
                 ErrorUtilities.VerifyThrowInternalRooted(projectFile);
diff --git a/src/Build/Evaluation/SimpleProjectRootElementCache.cs b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
index a5cb9278e33..2ce5a68450b 100644
--- a/src/Build/Evaluation/SimpleProjectRootElementCache.cs
+++ b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
@@ -143,7 +143,7 @@ internal override void OnProjectDirtied(Project sender, ProjectChangedEventArgs
 
         protected override void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement)
         {
-             throw new NotImplementedException();
+            throw new NotImplementedException();
         }
     }
 }
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
index 71b55892b1c..4b5d884a2a9 100644
--- a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -103,9 +103,9 @@ private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string sea
             return Enumerable.Concat(directories, files);
         }
 
-#endregion
+        #endregion
 
-#region IFileSystem pass-through implementation
+        #region IFileSystem pass-through implementation
 
         public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);
 
@@ -119,6 +119,6 @@ private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string sea
 
         public byte[] ReadFileAllBytes(string path) => _fileSystem.ReadFileAllBytes(path);
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Build/Globbing/CompositeGlob.cs b/src/Build/Globbing/CompositeGlob.cs
index b1dabb12741..86167182da9 100644
--- a/src/Build/Globbing/CompositeGlob.cs
+++ b/src/Build/Globbing/CompositeGlob.cs
@@ -30,7 +30,7 @@ public class CompositeGlob : IMSBuildGlob
         /// <param name="globs">Children globs. Input gets shallow cloned</param>
         public CompositeGlob(IEnumerable<IMSBuildGlob> globs)
             : this(globs.ToImmutableArray())
-        {}
+        { }
 
         /// <summary>
         ///     Constructor
@@ -38,7 +38,7 @@ public CompositeGlob(IEnumerable<IMSBuildGlob> globs)
         /// <param name="globs">Children globs. Input gets shallow cloned</param>
         public CompositeGlob(params IMSBuildGlob[] globs)
             : this(ImmutableArray.Create(globs))
-        {}
+        { }
 
         /// <summary>
         ///     Constructor
@@ -47,7 +47,7 @@ public CompositeGlob(params IMSBuildGlob[] globs)
         /// <param name="glob2">Second child glob.</param>
         internal CompositeGlob(IMSBuildGlob glob1, IMSBuildGlob glob2)
             : this(ImmutableArray.Create(glob1, glob2))
-        {}
+        { }
 
         /// <summary>
         ///     Constructor
diff --git a/src/Build/Globbing/MSBuildGlobWithGaps.cs b/src/Build/Globbing/MSBuildGlobWithGaps.cs
index 5126a13744c..c0377c13880 100644
--- a/src/Build/Globbing/MSBuildGlobWithGaps.cs
+++ b/src/Build/Globbing/MSBuildGlobWithGaps.cs
@@ -68,7 +68,7 @@ public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IEnumerable<IMSBuildGlob> gaps
         /// <param name="mainGlob">The main glob</param>
         /// <param name="gaps">The gap glob</param>
         public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, params IMSBuildGlob[] gaps) : this(mainGlob, gaps.AsEnumerable())
-        {}
+        { }
 
         /// <inheritdoc />
         public bool IsMatch(string stringToMatch)
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 776514e4d7d..0a7ac4b6f90 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Graph
     internal class GraphBuilder
     {
         internal const string SolutionItemReference = "_SolutionReference";
-        
+
         /// <summary>
         /// The thread calling BuildGraph() will act as an implicit worker
         /// </summary>
@@ -61,7 +61,7 @@ public GraphBuilder(
             _solutionDependencies = solutionDependencies;
 
             _entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(actualEntryPoints);
-            
+
             IEqualityComparer<ConfigurationMetadata> configComparer = EqualityComparer<ConfigurationMetadata>.Default;
 
             _graphWorkSet = new ParallelWorkSet<ConfigurationMetadata, ParsedProject>(
@@ -82,7 +82,7 @@ public void BuildGraph()
             }
 
             var allParsedProjects = FindGraphNodes();
-            
+
             AddEdges(allParsedProjects);
 
             EntryPointNodes = _entryPointConfigurationMetadata.Select(e => allParsedProjects[e].GraphNode).ToList();
@@ -205,7 +205,7 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                 }
                 else
                 {
-                    projectsByPath[projectPath] = new List<ProjectGraphNode> {project.Value.GraphNode};
+                    projectsByPath[projectPath] = new List<ProjectGraphNode> { project.Value.GraphNode };
                 }
             }
 
@@ -450,7 +450,7 @@ private void DetectCycles(
                             {
                                 // the project being evaluated has a reference to itself
                                 var selfReferencingProjectString =
-                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});
+                                    FormatCircularDependencyError(new List<string> { node.ProjectInstance.FullPath, node.ProjectInstance.FullPath });
                                 throw new CircularDependencyException(
                                     string.Format(
                                         ResourceUtilities.GetResourceString("CircularDependencyInProjectGraph"),
@@ -459,7 +459,7 @@ private void DetectCycles(
 
                             // the project being evaluated has a circular dependency involving multiple projects
                             // add this project to the list of projects involved in cycle 
-                            var projectsInCycle = new List<string> {referenceNode.ProjectInstance.FullPath};
+                            var projectsInCycle = new List<string> { referenceNode.ProjectInstance.FullPath };
                             return (false, projectsInCycle);
                         }
                     }
@@ -527,10 +527,10 @@ private Dictionary<ConfigurationMetadata, ParsedProject> FindGraphNodes()
             foreach (ConfigurationMetadata projectToEvaluate in _entryPointConfigurationMetadata)
             {
                 SubmitProjectForParsing(projectToEvaluate);
-                                /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,
-                             meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context
-                             and duplicates the information, leading to wasted work
-                             */
+                /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,
+             meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context
+             and duplicates the information, leading to wasted work
+             */
             }
 
             _graphWorkSet.WaitForAllWorkAndComplete();
@@ -546,7 +546,7 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
         private List<ProjectInterpretation.ReferenceInfo> ParseReferences(ProjectGraphNode parsedProject)
         {
             var referenceInfos = new List<ProjectInterpretation.ReferenceInfo>();
-            
+
 
             foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, _projectInstanceFactory))
             {
@@ -558,7 +558,7 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
                         referenceInfo.ReferenceConfiguration.ProjectFullPath
                         ));
                 }
-                
+
                 SubmitProjectForParsing(referenceInfo.ReferenceConfiguration);
 
                 referenceInfos.Add(referenceInfo);
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 76a28c6c8fd..a645ae35072 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -123,14 +123,14 @@ public ITaskHost GetHostObject(string projectFile, string targetName, string tas
         public void RegisterHostObject(string projectFile, string targetName, string taskName, ITaskHost hostObject)
         {
 
-/* Unmerged change from project 'Microsoft.Build (netcoreapp2.1)'
-Before:
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-After:
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile));
-            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName));
-*/
+            /* Unmerged change from project 'Microsoft.Build (netcoreapp2.1)'
+            Before:
+                        ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
+                        ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
+            After:
+                        ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile));
+                        ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName));
+            */
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
             ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 8c9c1f0f26c..b1ad5b2d670 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -231,7 +231,7 @@ void ITranslatable.Translate(ITranslator translator)
         internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITranslator translator)
         {
             var instance = new ProjectItemDefinitionInstance();
-            ((ITranslatable) instance).Translate(translator);
+            ((ITranslatable)instance).Translate(translator);
 
             return instance;
         }
diff --git a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
index 4ee2e3a30a0..2ec19e845b0 100644
--- a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
@@ -145,7 +145,7 @@ void ITranslatable.Translate(ITranslator translator)
         internal static ProjectItemGroupTaskMetadataInstance FactoryForDeserialization(ITranslator translator)
         {
             var instance = new ProjectItemGroupTaskMetadataInstance();
-            ((ITranslatable) instance).Translate(translator);
+            ((ITranslatable)instance).Translate(translator);
 
             return instance;
         }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index a47095e4a4d..5c353cdd468 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1137,7 +1137,7 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
 
             IEnumerable<ProjectMetadataInstance> IItem<ProjectMetadataInstance>.Metadata => MetadataCollection;
 
-#region Operators
+            #region Operators
 
             /// <summary>
             /// This allows an explicit typecast from a "TaskItem" to a "string", returning the ItemSpec for this item.
@@ -1178,7 +1178,7 @@ public static explicit operator string(TaskItem that)
                 return !(left == right);
             }
 
-#endregion
+            #endregion
 
             /// <summary>
             /// Produce a string representation.
@@ -1200,7 +1200,7 @@ public override object InitializeLifetimeService()
             }
 #endif
 
-#region IItem and ITaskItem2 Members
+            #region IItem and ITaskItem2 Members
 
             /// <summary>
             /// Returns the metadata with the specified key.
@@ -1451,9 +1451,9 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
                 return clonedMetadata;
             }
 
-#endregion
+            #endregion
 
-#region INodePacketTranslatable Members
+            #region INodePacketTranslatable Members
 
             /// <summary>
             /// Reads or writes the packet to the serializer.
@@ -1483,9 +1483,9 @@ void ITranslatable.Translate(ITranslator translator)
                 }
             }
 
-#endregion
+            #endregion
 
-#region IEquatable<TaskItem> Members
+            #region IEquatable<TaskItem> Members
 
             /// <summary>
             /// Override of GetHashCode.
@@ -1594,7 +1594,7 @@ public bool Equals(TaskItem other)
                 return thisNames.Count == 0;
             }
 
-#endregion
+            #endregion
 
             /// <summary>
             /// Returns true if a particular piece of metadata is defined on this item (even if
@@ -1655,7 +1655,7 @@ private void WriteInternString(ITranslator translator, LookasideStringInterner i
                 var key = interner.Intern(str);
                 translator.Writer.Write(key);
             }
-            
+
             private void ReadInternString(ITranslator translator, LookasideStringInterner interner, ref string str)
             {
                 var val = translator.Reader.ReadInt32();
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index 9fd8e974939..a9ea7b667e1 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -143,7 +143,7 @@ void ITranslatable.Translate(ITranslator translator)
         internal static ProjectPropertyGroupTaskPropertyInstance FactoryForDeserialization(ITranslator translator)
         {
             var instance = new ProjectPropertyGroupTaskPropertyInstance();
-            ((ITranslatable) instance).Translate(translator);
+            ((ITranslatable)instance).Translate(translator);
 
             return instance;
         }
diff --git a/src/Build/Instance/ProjectTargetInstance.cs b/src/Build/Instance/ProjectTargetInstance.cs
index a10cb8456fb..b634c02a1a4 100644
--- a/src/Build/Instance/ProjectTargetInstance.cs
+++ b/src/Build/Instance/ProjectTargetInstance.cs
@@ -587,7 +587,7 @@ void ITranslatable.Translate(ITranslator translator)
         internal static ProjectTargetInstance FactoryForDeserialization(ITranslator translator)
         {
             var instance = new ProjectTargetInstance();
-            var translatable = (ITranslatable) instance;
+            var translatable = (ITranslatable)instance;
 
             translatable.Translate(translator);
 
diff --git a/src/Build/Instance/ProjectTaskInstance.cs b/src/Build/Instance/ProjectTaskInstance.cs
index c171aa4c118..9b46993576a 100644
--- a/src/Build/Instance/ProjectTaskInstance.cs
+++ b/src/Build/Instance/ProjectTaskInstance.cs
@@ -388,7 +388,7 @@ void ITranslatable.Translate(ITranslator translator)
 
             if (translator.Mode == TranslationDirection.ReadFromStream && localParameters != null)
             {
-                _parameters = (CopyOnWriteDictionary<(string, ElementLocation)>) localParameters;
+                _parameters = (CopyOnWriteDictionary<(string, ElementLocation)>)localParameters;
             }
         }
 
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index e8d2bfb9ebd..3d952b7eea6 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -276,7 +276,7 @@ public bool Execute()
                         _taskLoggingContext.GetWarningsAsErrors(),
                         _taskLoggingContext.GetWarningsNotAsErrors(),
                         _taskLoggingContext.GetWarningsAsMessages()
-                        
+
                     );
 
             try
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 5fbc2d36765..c93115fb9fd 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -414,7 +414,7 @@ ElementLocation elementLocation
         )
         {
             TaskFactoryWrapper taskFactory = null;
-            
+
             // If there are no usingtask tags in the project don't bother caching or looking for tasks locally
             RegisteredTaskRecord record = GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out bool retrievedFromCache);
 
@@ -1433,7 +1433,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
 #if FEATURE_APPDOMAIN
                                 factory = (ITaskFactory)AppDomain.CurrentDomain.CreateInstanceAndUnwrap(loadedType.Type.GetTypeInfo().Assembly.FullName, loadedType.Type.FullName);
 #else
-                                factory = (ITaskFactory) Activator.CreateInstance(loadedType.Type);
+                                factory = (ITaskFactory)Activator.CreateInstance(loadedType.Type);
 #endif
                                 TaskFactoryLoggingHost taskFactoryLoggingHost = new TaskFactoryLoggingHost(true /*I dont have the data at this point, the safest thing to do is make sure events are serializable*/, elementLocation, targetLoggingContext);
 
@@ -1811,7 +1811,7 @@ public void Translate(ITranslator translator)
 
                 if (translator.Mode == TranslationDirection.ReadFromStream && localParameters != null)
                 {
-                    _taskFactoryParameters = (Dictionary<string, string>) localParameters;
+                    _taskFactoryParameters = (Dictionary<string, string>)localParameters;
                 }
             }
 
@@ -1833,7 +1833,7 @@ public void Translate(ITranslator translator)
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
             {
-                _taskRegistrations = (Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>) copy;
+                _taskRegistrations = (Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>)copy;
             }
         }
 
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 9722ff1d00e..1f4878a4734 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -105,7 +105,7 @@ private DictionaryEntryKeyComparer() { }
 
             public int Compare(DictionaryEntry a, DictionaryEntry b)
             {
-                return string.Compare((string) a.Key, (string) b.Key, StringComparison.CurrentCultureIgnoreCase);
+                return string.Compare((string)a.Key, (string)b.Key, StringComparison.CurrentCultureIgnoreCase);
             }
         }
 
@@ -599,8 +599,8 @@ internal void WriteItems(SortedList itemTypes)
             // Write each item type and its itemspec, one per line
             foreach (DictionaryEntry entry in itemTypes)
             {
-                string itemType = (string) entry.Key;
-                ArrayList itemTypeList = (ArrayList) entry.Value;
+                string itemType = (string)entry.Key;
+                ArrayList itemTypeList = (ArrayList)entry.Value;
 
                 if (itemTypeList.Count == 0)
                 {
@@ -973,7 +973,7 @@ public virtual void Initialize(IEventSource eventSource)
             if (eventSource != null)
             {
                 eventSource.BuildStarted += BuildStartedHandler;
-                eventSource.BuildFinished +=BuildFinishedHandler;
+                eventSource.BuildFinished += BuildFinishedHandler;
                 eventSource.ProjectStarted += ProjectStartedHandler;
                 eventSource.ProjectFinished += ProjectFinishedHandler;
                 eventSource.TargetStarted += TargetStartedHandler;
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 46c583f3472..2a5a548b50e 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -30,6 +30,6 @@ internal enum BinaryLogRecordKind
         NameValueList,
         String,
         TaskParameter,
-        ResponseFileUsed, 
+        ResponseFileUsed,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 79dac4ce124..4da9bff8cc7 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -139,41 +139,41 @@ public void Write(BuildEventArgs e)
             currentRecordStream.SetLength(0);
         }
 
-/*
-Base types and inheritance ("EventArgs" suffix omitted):
-
-Build
-    Telemetry
-    LazyFormattedBuild
-        BuildMessage
-            CriticalBuildMessage
-            EnvironmentVariableRead
-            MetaprojectGenerated
-            ProjectImported
-            PropertyInitialValueSet
-            PropertyReassignment
-            TargetSkipped
-            TaskCommandLine
-            TaskParameter
-            UninitializedPropertyRead
-        BuildStatus
-            TaskStarted
-            TaskFinished
-            TargetStarted
-            TargetFinished
-            ProjectStarted
-            ProjectFinished
-            BuildStarted
-            BuildFinished
-            ProjectEvaluationStarted
-            ProjectEvaluationFinished
-        BuildError
-        BuildWarning
-        CustomBuild
-            ExternalProjectStarted
-            ExternalProjectFinished
-
-*/
+        /*
+        Base types and inheritance ("EventArgs" suffix omitted):
+
+        Build
+            Telemetry
+            LazyFormattedBuild
+                BuildMessage
+                    CriticalBuildMessage
+                    EnvironmentVariableRead
+                    MetaprojectGenerated
+                    ProjectImported
+                    PropertyInitialValueSet
+                    PropertyReassignment
+                    TargetSkipped
+                    TaskCommandLine
+                    TaskParameter
+                    UninitializedPropertyRead
+                BuildStatus
+                    TaskStarted
+                    TaskFinished
+                    TargetStarted
+                    TargetFinished
+                    ProjectStarted
+                    ProjectFinished
+                    BuildStarted
+                    BuildFinished
+                    ProjectEvaluationStarted
+                    ProjectEvaluationFinished
+                BuildError
+                BuildWarning
+                CustomBuild
+                    ExternalProjectStarted
+                    ExternalProjectFinished
+
+        */
 
         private void WriteCore(BuildEventArgs e)
         {
diff --git a/src/Build/Logging/FancyLogger/ANSIBuilder.cs b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
index 733ba1dc241..981eacab714 100644
--- a/src/Build/Logging/FancyLogger/ANSIBuilder.cs
+++ b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
@@ -261,7 +261,8 @@ public static string Up(int n = 1)
             public static string UpAndScroll(int n)
             {
                 string result = "";
-                for (int i = 0; i < n; i++) {
+                for (int i = 0; i < n; i++)
+                {
                     result += "\x1bM";
                 }
                 return result;
@@ -297,7 +298,8 @@ public static string SavePosition()
                 return String.Format("\x1b[s");
             }
 
-            public static string RestorePosition() {
+            public static string RestorePosition()
+            {
                 return String.Format("\x1b[u");
             }
 
@@ -416,7 +418,7 @@ public static string Spinner()
 
             public static string Spinner(int n)
             {
-                char[] chars = { '\\', '|', '/', '-'};
+                char[] chars = { '\\', '|', '/', '-' };
                 return chars[n % (chars.Length - 1)].ToString();
             }
 
diff --git a/src/Build/Logging/FancyLogger/FancyLogger.cs b/src/Build/Logging/FancyLogger/FancyLogger.cs
index 8d51e4a8477..477e5466123 100644
--- a/src/Build/Logging/FancyLogger/FancyLogger.cs
+++ b/src/Build/Logging/FancyLogger/FancyLogger.cs
@@ -9,7 +9,7 @@
 namespace Microsoft.Build.Logging.FancyLogger
 {
     public class FancyLogger : ILogger
-    {   
+    {
         private Dictionary<int, FancyLoggerProjectNode> projects = new Dictionary<int, FancyLoggerProjectNode>();
 
         private bool Succeeded;
@@ -17,7 +17,7 @@ public class FancyLogger : ILogger
         private float existingTasks = 1;
         private float completedTasks = 0;
 
-        public string Parameters {  get; set; }
+        public string Parameters { get; set; }
 
         public LoggerVerbosity Verbosity { get; set; }
 
@@ -45,7 +45,7 @@ public void Initialize(IEventSource eventSource)
             eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
             // Cancelled
             Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);
-            
+
             Task.Run(() =>
             {
                 Render();
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
index 57dd32bd9d6..bd98e1cb135 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
@@ -6,7 +6,7 @@
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Logging.FancyLogger
-{ 
+{
 
     public class FancyLoggerMessageNode
     {
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
index 6bba1fa99f1..86190000101 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
@@ -9,7 +9,7 @@
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Logging.FancyLogger
-{ 
+{
     internal class FancyLoggerProjectNode
     {
         /// <summary>
@@ -72,7 +72,7 @@ public void Log()
                 // Project
                 ANSIBuilder.Formatting.Dim("Project: ") +
                 // Project file path with color
-                $"{ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default )} [{TargetFramework ?? "*"}]",
+                $"{ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default)} [{TargetFramework ?? "*"}]",
                 $"({MessageCount} Messages, {WarningCount} Warnings, {ErrorCount} Errors)",
                 Console.WindowWidth
             );
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
index 0c5ad00ed4f..6abf0ab5be7 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
@@ -5,7 +5,7 @@
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Logging.FancyLogger
-{ 
+{
 
     public class FancyLoggerTargetNode
     {
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
index d645a5daedc..a5cfc363609 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
@@ -5,7 +5,7 @@
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Logging.FancyLogger
-{ 
+{
 
     public class FancyLoggerTaskNode
     {
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index c40bb1aeef6..3d8a02ca664 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -617,7 +617,7 @@ private string ReadProjectConfigurationDescription(IEnumerable items)
                     // Add the item value to the string to be printed in error/warning messages.
                     if (!descriptionEmpty)
                     {
-                        projectConfigurationDescription.Append(" "); 
+                        projectConfigurationDescription.Append(" ");
                     }
 
                     projectConfigurationDescription.Append(itemSpec);
diff --git a/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementContainerLink.cs b/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementContainerLink.cs
index 680ab19717c..1af55d6d093 100644
--- a/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementContainerLink.cs
+++ b/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementContainerLink.cs
@@ -66,7 +66,7 @@ public abstract class ProjectElementContainerLink : ProjectElementLink
     /// External projects support.
     /// Allow for creating a local representation to external object of type <see cref="ProjectChooseElement"/>
     /// </summary>
-    public abstract class ProjectChooseElementLink : ProjectElementContainerLink  { }
+    public abstract class ProjectChooseElementLink : ProjectElementContainerLink { }
 
     /// <summary>
     /// External projects support.
diff --git a/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementLink.cs b/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementLink.cs
index 4a244d9e504..715b012cad8 100644
--- a/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementLink.cs
+++ b/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementLink.cs
@@ -130,7 +130,7 @@ public abstract class ProjectElementLink : ILinkedXml
         public static string GetAttributeValue(ProjectElement xml, string attributeName, bool nullIfNotExists) => xml.GetAttributeValue(attributeName, nullIfNotExists);
         public static void SetOrRemoveAttribute(ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) => xml.SetOrRemoveAttributeForLink(name, value, clearAttributeCache, reason, param);
         public static void MarkDirty(ProjectElement xml, string reason, string param) => xml.MarkDirty(reason, param);
-        public static ProjectElement CreateNewInstance(ProjectElement xml, ProjectRootElement owner) =>  ProjectElement.CreateNewInstance(xml, owner);
+        public static ProjectElement CreateNewInstance(ProjectElement xml, ProjectRootElement owner) => ProjectElement.CreateNewInstance(xml, owner);
 
         public static string GetPureText(ProjectElement xml)
         {
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectLink.cs
index 03f7a8795a5..c6d2f2eab1b 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectLink.cs
@@ -68,7 +68,7 @@ public abstract class ProjectLink
         /// <summary>
         /// Access to remote <see cref="Project.ItemsIgnoringCondition"/>.
         /// </summary>
-        public abstract  ICollection<ProjectItem> ItemsIgnoringCondition { get; }
+        public abstract ICollection<ProjectItem> ItemsIgnoringCondition { get; }
 
         /// <summary>
         /// Access to remote <see cref="Project.Imports"/>.
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index b6b534637e0..34ef483b39d 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -107,7 +107,7 @@ public ProjectMetadata Create(ProjectMetadataLink link, object parent = null)
             return new LinkedProjectMetadata(parent, link);
         }
 
-        public ProjectProperty Create(ProjectPropertyLink link, Project project = null )
+        public ProjectProperty Create(ProjectPropertyLink link, Project project = null)
         {
             project ??= link.Project;
 
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index fbe306e3632..f455a80fddf 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -240,7 +240,7 @@ private static string[] GetFileList
                                     includeLocation,
                                     excludeLocation,
                                     excludeFileSpecIsEmpty,
-                                    disableExcludeDriveEnumerationWarning,                                
+                                    disableExcludeDriveEnumerationWarning,
                                     fileSpec);
 
                                 break;
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index dd665af000e..6d6368edae1 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -166,12 +166,12 @@ private static bool ParseComponent(ref ReadOnlySpan<char> span, out int value)
 
         private static int ParseComponent(ReadOnlySpan<char> span)
         {
-        #if NETFRAMEWORK
+#if NETFRAMEWORK
             // Cannot parse int from span on .NET Framework, so allocate the substring
             var spanOrString = span.ToString();
-        #else
+#else
             var spanOrString = span;
-        #endif
+#endif
 
             if (!int.TryParse(spanOrString, NumberStyles.None, CultureInfo.InvariantCulture, out int value))
             {
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 23e35aa8a81..aeaf1fef393 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -355,7 +355,7 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                         // This is higher than the 'legacy' toolsversion values.
                         // Therefore we need to enter best effort mode and
                         // present the current one.
-                        if (toolsVersionAsVersion > new Version(15,0))
+                        if (toolsVersionAsVersion > new Version(15, 0))
                         {
                             toolsVersionToUse = MSBuildConstants.CurrentToolsVersion;
                         }
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 8cfd9b6497e..72bf3a20a8e 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -83,7 +83,7 @@ private static XmlReader GetXmlReader(string file, StreamReader input, bool load
         {
             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();
 
-            
+
             // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes
             // of attribute text, specifically newline removal.
             // https://github.com/dotnet/msbuild/issues/4210
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index 1695918ddb2..00f0347821c 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -247,7 +247,8 @@ private string[] TokenizeAdditionalOptionsValue(string additionalOptionsValue)
             {
                 switch (c)
                 {
-                    case '\t': case ' ':
+                    case '\t':
+                    case ' ':
                         if (inQuotes)
                         {
                             option.Append(c);
@@ -260,15 +261,15 @@ private string[] TokenizeAdditionalOptionsValue(string additionalOptionsValue)
                                 option.Length = 0;
                             }
                         }
-                    break;
+                        break;
 
                     case '"':
                         inQuotes = !inQuotes;
-                    break;
+                        break;
 
                     default:
                         option.Append(c);
-                    break;
+                        break;
                 }
             }
 
@@ -291,7 +292,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
         {
             string matchedID = null;
             // First see if we have a match...
-            for (int i=0; i<compSwitchInfo.SwitchIDs.Length; i++)
+            for (int i = 0; i < compSwitchInfo.SwitchIDs.Length; i++)
             {
                 if (compSwitch.StartsWith(compSwitchInfo.SwitchIDs[i], StringComparison.Ordinal))
                 {
@@ -333,7 +334,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         Debug.Assert(false, "Cannot parse boolean switch: " + compSwitch);
                     }
-                break;
+                    break;
 
                 case SwitchValueType.SVT_String:
                     if (matchedID.Length < compSwitch.Length)
@@ -348,7 +349,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         Debug.Assert(false, "Cannot parse string switch: " + compSwitch);
                     }
-                break;
+                    break;
 
                 case SwitchValueType.SVT_MultiString:
                     Debug.Assert(
@@ -369,11 +370,11 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         Debug.Assert(false, "Cannot parse multistring switch: " + compSwitch);
                     }
-                break;
+                    break;
 
                 default:
                     Debug.Assert(false, "Unknown switch value type");
-                break;
+                    break;
             }
 
             return true;
@@ -405,7 +406,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                                 compSwitchInfo.SwitchValue.ToString().ToLower(CultureInfo.InvariantCulture)
                             );
                         }
-                    break;
+                        break;
 
                     case SwitchValueType.SVT_String:
                         if (compSwitchInfo.SwitchValue != null)
@@ -415,7 +416,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                                 compSwitchInfo.SwitchValue.ToString()
                             );
                         }
-                    break;
+                        break;
 
                     case SwitchValueType.SVT_MultiString:
                         Debug.Assert(compSwitchInfo.SwitchValue != null, "Expected non null value for multistring switch");
@@ -426,11 +427,11 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                                 compSwitchInfo.SwitchValue.ToString()
                             );
                         }
-                    break;
+                        break;
 
                     default:
                         Debug.Assert(false, "Unknown switch value type");
-                    break;
+                        break;
                 }
             }
         }
diff --git a/src/Deprecated/Conversion/Constants.cs b/src/Deprecated/Conversion/Constants.cs
index c151142eedc..fe1d68298b9 100644
--- a/src/Deprecated/Conversion/Constants.cs
+++ b/src/Deprecated/Conversion/Constants.cs
@@ -11,8 +11,8 @@ namespace Microsoft.Build.Conversion
     /// <owner>AJenner</owner>
     internal static class LegacyFrameworkPaths
     {
-        internal const string RTMFrameworkPath       = "MICROSOFT.NET\\FRAMEWORK\\V1.0.3705";
-        internal const string EverettFrameworkPath   = "MICROSOFT.NET\\FRAMEWORK\\V1.1.4322";
+        internal const string RTMFrameworkPath = "MICROSOFT.NET\\FRAMEWORK\\V1.0.3705";
+        internal const string EverettFrameworkPath = "MICROSOFT.NET\\FRAMEWORK\\V1.1.4322";
         internal const string JSharpRTMFrameworkPath = "MICROSOFT VISUAL JSHARP .NET\\FRAMEWORK\\V1.0.4205";
     }
 
@@ -23,35 +23,35 @@ internal static class LegacyFrameworkPaths
     internal static class VSProjectElements
     {
         internal const string visualStudioProject = "VisualStudioProject";
-        internal const string visualJSharp        = "VISUALJSHARP";
-        internal const string cSharp              = "CSHARP";
-        internal const string visualBasic         = "VisualBasic";
-        internal const string ECSharp             = "ECSHARP";
-        internal const string EVisualBasic        = "EVisualBasic";
-        internal const string build               = "Build";
-        internal const string settings            = "Settings";
-        internal const string config              = "Config";
-        internal const string platform            = "Platform";
+        internal const string visualJSharp = "VISUALJSHARP";
+        internal const string cSharp = "CSHARP";
+        internal const string visualBasic = "VisualBasic";
+        internal const string ECSharp = "ECSHARP";
+        internal const string EVisualBasic = "EVisualBasic";
+        internal const string build = "Build";
+        internal const string settings = "Settings";
+        internal const string config = "Config";
+        internal const string platform = "Platform";
         internal const string interopRegistration = "InteropRegistration";
-        internal const string references          = "References";
-        internal const string reference           = "Reference";
-        internal const string files               = "Files";
-        internal const string imports             = "Imports";
-        internal const string import              = "Import";
-        internal const string include             = "Include";
-        internal const string exclude             = "Exclude";
-        internal const string file                = "File";
-        internal const string folder              = "Folder";
-        internal const string startupServices     = "StartupServices";
-        internal const string service             = "Service";
-        internal const string userProperties      = "UserProperties";
-        internal const string otherProjectSettings= "OtherProjectSettings";
-        internal const string PocketPC            = "Pocket PC";
-        internal const string WindowsCE           = "Windows CE";
-        internal const string Smartphone          = "Smartphone";
-        internal const string SystemDataCommon    = "System.Data.Common";
-        internal const string SystemSR            = "System.SR";
-        internal const string MSCorLib            = "MSCorLib";
+        internal const string references = "References";
+        internal const string reference = "Reference";
+        internal const string files = "Files";
+        internal const string imports = "Imports";
+        internal const string import = "Import";
+        internal const string include = "Include";
+        internal const string exclude = "Exclude";
+        internal const string file = "File";
+        internal const string folder = "Folder";
+        internal const string startupServices = "StartupServices";
+        internal const string service = "Service";
+        internal const string userProperties = "UserProperties";
+        internal const string otherProjectSettings = "OtherProjectSettings";
+        internal const string PocketPC = "Pocket PC";
+        internal const string WindowsCE = "Windows CE";
+        internal const string Smartphone = "Smartphone";
+        internal const string SystemDataCommon = "System.Data.Common";
+        internal const string SystemSR = "System.SR";
+        internal const string MSCorLib = "MSCorLib";
     }
 
     /// <summary>
@@ -60,42 +60,42 @@ internal static class VSProjectElements
     /// <owner>RGoel</owner>
     internal static class VSProjectAttributes
     {
-        internal const string relPath             = "RelPath";
-        internal const string name                = "Name";
-        internal const string guid                = "Guid";
-        internal const string project             = "Project";
-        internal const string projectType         = "ProjectType";
-        internal const string local               = "Local";
-        internal const string assemblyName        = "AssemblyName";
-        internal const string importNamespace     = "Namespace";
-        internal const string id                  = "ID";
-        internal const string link                = "Link";
-        internal const string buildAction         = "BuildAction";
-        internal const string buildActionNone     = "None";
+        internal const string relPath = "RelPath";
+        internal const string name = "Name";
+        internal const string guid = "Guid";
+        internal const string project = "Project";
+        internal const string projectType = "ProjectType";
+        internal const string local = "Local";
+        internal const string assemblyName = "AssemblyName";
+        internal const string importNamespace = "Namespace";
+        internal const string id = "ID";
+        internal const string link = "Link";
+        internal const string buildAction = "BuildAction";
+        internal const string buildActionNone = "None";
         internal const string buildActionResource = "EmbeddedResource";
-        internal const string webReferences       = "WebReferences";
-        internal const string webReferenceUrl     = "WebReferenceUrl";
-        internal const string projectGuid         = "ProjectGuid";
-        internal const string preBuildEvent       = "PreBuildEvent";
-        internal const string postBuildEvent      = "PostBuildEvent";
-        internal const string productVersion      = "ProductVersion";
-        internal const string schemaVersion       = "SchemaVersion";
-        internal const string outputPath          = "OutputPath";
-        internal const string officeDocumentPath  = "OfficeDocumentPath";
-        internal const string officeDocumentType  = "OfficeProjectType";
-        internal const string officeProject       = "OfficeProject";
-        internal const string additionalOptions   = "AdditionalOptions";
-        internal const string platform            = "Platform";
-        internal const string selectedDevice      = "SelectedDevice";
-        internal const string deploymentPlatform  = "DeploymentPlatform";
-        internal const string incrementalBuild    = "IncrementalBuild";
-        internal const string hintPath            = "HintPath";
-        internal const string documentationFile   = "DocumentationFile";
-        internal const string debugType           = "DebugType";
-        internal const string debugTypeNone       = "none";
-        internal const string debugTypeFull       = "full";
-        internal const string errorReport         = "ErrorReport";
-        internal const string errorReportPrompt   = "prompt";
+        internal const string webReferences = "WebReferences";
+        internal const string webReferenceUrl = "WebReferenceUrl";
+        internal const string projectGuid = "ProjectGuid";
+        internal const string preBuildEvent = "PreBuildEvent";
+        internal const string postBuildEvent = "PostBuildEvent";
+        internal const string productVersion = "ProductVersion";
+        internal const string schemaVersion = "SchemaVersion";
+        internal const string outputPath = "OutputPath";
+        internal const string officeDocumentPath = "OfficeDocumentPath";
+        internal const string officeDocumentType = "OfficeProjectType";
+        internal const string officeProject = "OfficeProject";
+        internal const string additionalOptions = "AdditionalOptions";
+        internal const string platform = "Platform";
+        internal const string selectedDevice = "SelectedDevice";
+        internal const string deploymentPlatform = "DeploymentPlatform";
+        internal const string incrementalBuild = "IncrementalBuild";
+        internal const string hintPath = "HintPath";
+        internal const string documentationFile = "DocumentationFile";
+        internal const string debugType = "DebugType";
+        internal const string debugTypeNone = "none";
+        internal const string debugTypeFull = "full";
+        internal const string errorReport = "ErrorReport";
+        internal const string errorReportPrompt = "prompt";
     }
 
     /// <summary>
@@ -104,98 +104,98 @@ internal static class VSProjectAttributes
     /// <owner>RGoel</owner>
     internal static class XMakeProjectStrings
     {
-        internal const string project                     = "Project";
-        internal const string defaultTargets              = "Build";
-        internal const string msbuildVersion              = "MSBuildVersion";
-        internal const string xmlns                       = "xmlns";
-        internal const string importPrefix                = "$(MSBuildToolsPath)\\";
-        internal const string importSuffix                = ".targets";
-        internal const string targetsFilenamePrefix       = "Microsoft.";
-        internal const string csharpTargets               = "CSharp";
-        internal const string visualBasicTargets          = "VisualBasic";
-        internal const string visualJSharpTargets         = "VisualJSharp";
-        internal const string triumphImport               = "$(MSBuildExtensionsPath)\\Microsoft\\VisualStudio\\v9.0\\OfficeTools\\Microsoft.VisualStudio.OfficeTools.targets";
-        internal const string officeTargetsVS2005Import   = @"$(MSBuildExtensionsPath)\Microsoft.VisualStudio.OfficeTools.targets";
-        internal const string officeTargetsVS2005Import2  = @"$(MSBuildExtensionsPath)\Microsoft.VisualStudio.OfficeTools2.targets";
-        internal const string officeTargetsVS2005Repair   = @"OfficeTools\Microsoft.VisualStudio.Tools.Office.targets";
-        internal const string configurationPrefix         = " '$(Configuration)' == '";
-        internal const string configurationSuffix         = "' ";
-        internal const string configuration               = "Configuration";
-        internal const string platformPrefix              = " '$(Platform)' == '";
-        internal const string platformSuffix              = "' ";
-        internal const string platform                    = "Platform";
-        internal const string configplatformPrefix        = " '$(Configuration)|$(Platform)' == '";
-        internal const string configplatformSeparator     = "|";
-        internal const string configplatformSuffix        = "' ";
-        internal const string defaultConfiguration        = "Debug";
-        internal const string defaultPlatform             = "AnyCPU";
-        internal const string x86Platform                 = "x86";
-        internal const string debugSymbols                = "DebugSymbols";
-        internal const string reference                   = "Reference";
-        internal const string comReference                = "COMReference";
-        internal const string projectReference            = "ProjectReference";
-        internal const string import                      = "Import";
-        internal const string service                     = "Service";
-        internal const string folder                      = "Folder";
-        internal const string link                        = "Link";
-        internal const string autogen                     = "AutoGen";
-        internal const string webReferences               = "WebReferences";
-        internal const string webReferenceUrl             = "WebReferenceUrl";
-        internal const string relPath                     = "RelPath";
-        internal const string visualStudio                = "VisualStudio";
-        internal const string webRefEnableProperties      = "WebReference_EnableProperties";
-        internal const string webRefEnableSqlTypes        = "WebReference_EnableSQLTypes";
-        internal const string webRefEnableLegacyEventing  = "WebReference_EnableLegacyEventingModel";
-        internal const string xmlNamespace                = "http://schemas.microsoft.com/developer/msbuild/2003";
+        internal const string project = "Project";
+        internal const string defaultTargets = "Build";
+        internal const string msbuildVersion = "MSBuildVersion";
+        internal const string xmlns = "xmlns";
+        internal const string importPrefix = "$(MSBuildToolsPath)\\";
+        internal const string importSuffix = ".targets";
+        internal const string targetsFilenamePrefix = "Microsoft.";
+        internal const string csharpTargets = "CSharp";
+        internal const string visualBasicTargets = "VisualBasic";
+        internal const string visualJSharpTargets = "VisualJSharp";
+        internal const string triumphImport = "$(MSBuildExtensionsPath)\\Microsoft\\VisualStudio\\v9.0\\OfficeTools\\Microsoft.VisualStudio.OfficeTools.targets";
+        internal const string officeTargetsVS2005Import = @"$(MSBuildExtensionsPath)\Microsoft.VisualStudio.OfficeTools.targets";
+        internal const string officeTargetsVS2005Import2 = @"$(MSBuildExtensionsPath)\Microsoft.VisualStudio.OfficeTools2.targets";
+        internal const string officeTargetsVS2005Repair = @"OfficeTools\Microsoft.VisualStudio.Tools.Office.targets";
+        internal const string configurationPrefix = " '$(Configuration)' == '";
+        internal const string configurationSuffix = "' ";
+        internal const string configuration = "Configuration";
+        internal const string platformPrefix = " '$(Platform)' == '";
+        internal const string platformSuffix = "' ";
+        internal const string platform = "Platform";
+        internal const string configplatformPrefix = " '$(Configuration)|$(Platform)' == '";
+        internal const string configplatformSeparator = "|";
+        internal const string configplatformSuffix = "' ";
+        internal const string defaultConfiguration = "Debug";
+        internal const string defaultPlatform = "AnyCPU";
+        internal const string x86Platform = "x86";
+        internal const string debugSymbols = "DebugSymbols";
+        internal const string reference = "Reference";
+        internal const string comReference = "COMReference";
+        internal const string projectReference = "ProjectReference";
+        internal const string import = "Import";
+        internal const string service = "Service";
+        internal const string folder = "Folder";
+        internal const string link = "Link";
+        internal const string autogen = "AutoGen";
+        internal const string webReferences = "WebReferences";
+        internal const string webReferenceUrl = "WebReferenceUrl";
+        internal const string relPath = "RelPath";
+        internal const string visualStudio = "VisualStudio";
+        internal const string webRefEnableProperties = "WebReference_EnableProperties";
+        internal const string webRefEnableSqlTypes = "WebReference_EnableSQLTypes";
+        internal const string webRefEnableLegacyEventing = "WebReference_EnableLegacyEventingModel";
+        internal const string xmlNamespace = "http://schemas.microsoft.com/developer/msbuild/2003";
 
-        internal const string cSharpGuid                  = "FAE04EC0-301F-11D3-BF4B-00C04F79EFBC";
-        internal const string visualBasicGuid             = "F184B08F-C81C-45F6-A57F-5ABD9991F28F";
-        internal const string visualJSharpGuid            = "E6FDF86B-F3D1-11D4-8576-0002A516ECE8";
-        internal const string triumphProjectTypeGuid      = "BAA0C2D2-18E2-41B9-852F-F413020CAA33";
-        internal const string VSDCSProjectTypeGuid        = "4D628B5B-2FBC-4AA6-8C16-197242AEB884";
-        internal const string VSDVBProjectTypeGuid        = "68B1623D-7FB9-47D8-8664-7ECEA3297D4F";
-        internal const string wpfFlavorGuid               = "60dc8134-eba5-43b8-bcc9-bb4bc16c2548";
-        internal const string projectTypeGuids            = "ProjectTypeGuids";
-        internal const string platformID                  = "PlatformID";
-        internal const string platformFamilyName          = "PlatformFamilyName";
-        internal const string deployTargetSuffix          = "DeployDirSuffix";
-        internal const string disableCSHostProc           = "<FlavorProperties GUID=\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\">\n<HostingProcess disable=\"1\" />\n</FlavorProperties>";
-        internal const string disableVBHostProc           = "<FlavorProperties GUID=\"{F184B08F-C81C-45F6-A57F-5ABD9991F28F}\">\n<HostingProcess disable=\"1\" />\n</FlavorProperties>";
-        internal const string SDECSTargets                = "Microsoft.CompactFramework.CSharp.targets";
-        internal const string SDEVBTargets                = "Microsoft.CompactFramework.VisualBasic.targets";
-        internal const string TargetFrameworkVersion      = "TargetFrameworkVersion";
-        internal const string TargetFrameworkSubset       = "TargetFrameworkSubset";
-        internal const string TargetFrameworkProfile      = "TargetFrameworkProfile";
-        internal const string ClientProfile               = "Client";
-        internal const string vOne                        = "v1.0";
-        internal const string vTwo                        = "v2.0";
-        internal const string noWarn                      = "NoWarn";
-        internal const string disabledVBWarnings          = "42016,42017,42018,42019,42032,42353,42354,42355";
-        internal const string xmlFileExtension            = ".xml";
-        internal const string csdprojFileExtension        = ".csdproj";
-        internal const string vbdprojFileExtension        = ".vbdproj";
-        internal const string csprojFileExtension         = ".csproj";
-        internal const string vbprojFileExtension         = ".vbproj";
-        internal const string myType                      = "MyType";
-        internal const string web                         = "Web";
+        internal const string cSharpGuid = "FAE04EC0-301F-11D3-BF4B-00C04F79EFBC";
+        internal const string visualBasicGuid = "F184B08F-C81C-45F6-A57F-5ABD9991F28F";
+        internal const string visualJSharpGuid = "E6FDF86B-F3D1-11D4-8576-0002A516ECE8";
+        internal const string triumphProjectTypeGuid = "BAA0C2D2-18E2-41B9-852F-F413020CAA33";
+        internal const string VSDCSProjectTypeGuid = "4D628B5B-2FBC-4AA6-8C16-197242AEB884";
+        internal const string VSDVBProjectTypeGuid = "68B1623D-7FB9-47D8-8664-7ECEA3297D4F";
+        internal const string wpfFlavorGuid = "60dc8134-eba5-43b8-bcc9-bb4bc16c2548";
+        internal const string projectTypeGuids = "ProjectTypeGuids";
+        internal const string platformID = "PlatformID";
+        internal const string platformFamilyName = "PlatformFamilyName";
+        internal const string deployTargetSuffix = "DeployDirSuffix";
+        internal const string disableCSHostProc = "<FlavorProperties GUID=\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\">\n<HostingProcess disable=\"1\" />\n</FlavorProperties>";
+        internal const string disableVBHostProc = "<FlavorProperties GUID=\"{F184B08F-C81C-45F6-A57F-5ABD9991F28F}\">\n<HostingProcess disable=\"1\" />\n</FlavorProperties>";
+        internal const string SDECSTargets = "Microsoft.CompactFramework.CSharp.targets";
+        internal const string SDEVBTargets = "Microsoft.CompactFramework.VisualBasic.targets";
+        internal const string TargetFrameworkVersion = "TargetFrameworkVersion";
+        internal const string TargetFrameworkSubset = "TargetFrameworkSubset";
+        internal const string TargetFrameworkProfile = "TargetFrameworkProfile";
+        internal const string ClientProfile = "Client";
+        internal const string vOne = "v1.0";
+        internal const string vTwo = "v2.0";
+        internal const string noWarn = "NoWarn";
+        internal const string disabledVBWarnings = "42016,42017,42018,42019,42032,42353,42354,42355";
+        internal const string xmlFileExtension = ".xml";
+        internal const string csdprojFileExtension = ".csdproj";
+        internal const string vbdprojFileExtension = ".vbdproj";
+        internal const string csprojFileExtension = ".csproj";
+        internal const string vbprojFileExtension = ".vbproj";
+        internal const string myType = "MyType";
+        internal const string web = "Web";
         internal const string windowsFormsWithCustomSubMain = "WindowsFormsWithCustomSubMain";
-        internal const string windows                     = "Windows";
-        internal const string codeAnalysisRuleAssemblies  = "CodeAnalysisRuleAssemblies";
-        internal const string console                     = "Console";
-        internal const string empty                       = "Empty";
-        internal const string exe                         = "Exe";
-        internal const string library                     = "Library";
-        internal const string winExe                      = "WinExe";
-        internal const string outputType                  = "OutputType";
-        internal const string fileUpgradeFlags            = "FileUpgradeFlags";
-        internal const string content                     = "Content";
-        internal const string copytooutput                = "CopyToOutputDirectory";
-        internal const string preservenewest              = "PreserveNewest";
-        internal const string toolsVersion                = MSBuildConstants.CurrentToolsVersion;
-        internal const string vbTargetsVS2008             = @"$(MSBuildToolsPath)\Microsoft.VisualBasic.targets";
-        internal const string vbTargetsVS2005             = @"$(MSBuildBinPath)\Microsoft.VisualBasic.targets";
-        internal const string vsToolsPath                 = @"VSToolsPath";
-        internal const string visualStudioVersion         = @"VisualStudioVersion";
+        internal const string windows = "Windows";
+        internal const string codeAnalysisRuleAssemblies = "CodeAnalysisRuleAssemblies";
+        internal const string console = "Console";
+        internal const string empty = "Empty";
+        internal const string exe = "Exe";
+        internal const string library = "Library";
+        internal const string winExe = "WinExe";
+        internal const string outputType = "OutputType";
+        internal const string fileUpgradeFlags = "FileUpgradeFlags";
+        internal const string content = "Content";
+        internal const string copytooutput = "CopyToOutputDirectory";
+        internal const string preservenewest = "PreserveNewest";
+        internal const string toolsVersion = MSBuildConstants.CurrentToolsVersion;
+        internal const string vbTargetsVS2008 = @"$(MSBuildToolsPath)\Microsoft.VisualBasic.targets";
+        internal const string vbTargetsVS2005 = @"$(MSBuildBinPath)\Microsoft.VisualBasic.targets";
+        internal const string vsToolsPath = @"VSToolsPath";
+        internal const string visualStudioVersion = @"VisualStudioVersion";
         internal const string toRepairPatternForAssetCompat = @"$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\";
         internal const string toRepairPatternForAssetCompatBeforeV10 = @"$(MSBuildExtensionsPath)\Microsoft\VisualStudio\";
         internal const string toRepairPatternForAssetCompatV10 = @"$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\";
diff --git a/src/Deprecated/Conversion/OldVSProjectFileReader.cs b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
index cbfce91cf0b..906eaca6296 100644
--- a/src/Deprecated/Conversion/OldVSProjectFileReader.cs
+++ b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
@@ -33,18 +33,18 @@ internal sealed class OldVSProjectFileReader : TextReader
     {
         // This is the underlying text file where we will be reading the raw text
         // from.
-        private StreamReader    oldVSProjectFile;
-        
+        private StreamReader oldVSProjectFile;
+
         // We will be reading one line at a time out of the text file, and caching
         // it here.
-        private StringBuilder   singleLine;
-        
+        private StringBuilder singleLine;
+
         // The "TextReader" interface that we are implementing only allows
         // forward access through the file.  You cannot seek to a random location
         // or read backwards.  This variable is the index into the "singleLine"
         // string above, which indicates how far the caller has read.  Once we
         // reach the end of "singleLine", we'll go read a new line from the file.
-        private int             currentReadPositionWithinSingleLine;
+        private int currentReadPositionWithinSingleLine;
 
         /// <summary>
         /// Constructor, initialized using the filename of an existing old format
@@ -58,7 +58,7 @@ string filename
             )
         {
             this.oldVSProjectFile = new StreamReader(filename, Encoding.Default); // HIGHCHAR: Default means ANSI, ANSI is what VS .NET 2003 wrote. Without this, the project would be read as ASCII.
-            
+
             this.singleLine = new StringBuilder();
             this.currentReadPositionWithinSingleLine = 0;
         }
@@ -131,9 +131,9 @@ public override int Read
         /// <owner>rgoel</owner>
         public override int Read
             (
-            char[]  bufferToReadInto,       // The buffer to read the data into.
-            int     startIndexIntoBuffer,   // The index into "bufferToReadInto"
-            int     charactersToRead        // The number of characters to read.
+            char[] bufferToReadInto,       // The buffer to read the data into.
+            int startIndexIntoBuffer,   // The index into "bufferToReadInto"
+            int charactersToRead        // The number of characters to read.
             )
         {
             // Make sure there's enough room in the caller's buffer for what he's
@@ -169,7 +169,7 @@ int     charactersToRead        // The number of characters to read.
                 }
 
                 // Copy characters from our cached "singleLine" to the caller's buffer.
-                this.singleLine.ToString().CopyTo(this.currentReadPositionWithinSingleLine, bufferToReadInto, 
+                this.singleLine.ToString().CopyTo(this.currentReadPositionWithinSingleLine, bufferToReadInto,
                     startIndexIntoBuffer, charactersToCopy);
 
                 // Update all counts and indices.
@@ -197,9 +197,9 @@ int     charactersToRead        // The number of characters to read.
         /// <owner>rgoel</owner>
         public override int ReadBlock
             (
-            char[]  bufferToReadInto, 
-            int     startIndexIntoBuffer, 
-            int     charactersToRead
+            char[] bufferToReadInto,
+            int startIndexIntoBuffer,
+            int charactersToRead
             )
         {
             throw new NotImplementedException();
@@ -235,7 +235,7 @@ public override string ReadLine
             this.currentReadPositionWithinSingleLine = this.singleLine.Length;
 
             // Strip off the line endings before returning to caller.
-            char[] lineEndingCharacters = new char[] {'\r', '\n'};
+            char[] lineEndingCharacters = new char[] { '\r', '\n' };
             return result.Trim(lineEndingCharacters);
         }
 
@@ -264,7 +264,7 @@ public override string ReadToEnd
                 }
 
                 // Append the line of text to the resulting output.
-                result.Append(this.singleLine.ToString(this.currentReadPositionWithinSingleLine, 
+                result.Append(this.singleLine.ToString(this.currentReadPositionWithinSingleLine,
                     this.singleLine.Length - this.currentReadPositionWithinSingleLine));
 
                 this.currentReadPositionWithinSingleLine = this.singleLine.Length;
@@ -314,11 +314,11 @@ private bool ReadLineIntoInternalBuffer
                 // Take the line of text just read, and replace all special characters
                 // with the escaped XML-friendly string equivalents.
                 this.singleLine = new StringBuilder(this.ReplaceSpecialCharacters(lineFromProjectFile));
-                
+
                 // The underlying StreamReader.ReadLine method doesn't give us the 
                 // trailing line endings, so add them back ourselves.
                 this.singleLine.Append(Environment.NewLine);
-                
+
                 // So now we have a new cached "singleLine".  Reset the read pointer
                 // to the beginning of the new line just read.
                 this.currentReadPositionWithinSingleLine = 0;
@@ -346,17 +346,17 @@ string originalLine
             // the special characters.
             Regex attributeValueInsideDoubleQuotesPattern = new Regex("= *\"[^\"]*\"");
 
-            string replacedStuffInsideDoubleQuotes = attributeValueInsideDoubleQuotesPattern.Replace(originalLine, 
+            string replacedStuffInsideDoubleQuotes = attributeValueInsideDoubleQuotesPattern.Replace(originalLine,
                 new MatchEvaluator(this.ReplaceSpecialCharactersInXmlAttribute));
-                
+
             // Find the stuff within single-quotes, and send it off to the 
             // "ReplaceSpecialCharactersInXmlAttribute" for proper replacement of
             // the special characters.
             Regex attributeValueInsideSingleQuotesPattern = new Regex("= *'[^']*'");
 
-            string replacedStuffInsideSingleQuotes = attributeValueInsideSingleQuotesPattern.Replace(replacedStuffInsideDoubleQuotes, 
+            string replacedStuffInsideSingleQuotes = attributeValueInsideSingleQuotesPattern.Replace(replacedStuffInsideDoubleQuotes,
                 new MatchEvaluator(this.ReplaceSpecialCharactersInXmlAttribute));
-                
+
             return replacedStuffInsideSingleQuotes;
         }
 
@@ -400,7 +400,7 @@ string xmlAttributeText
             xmlAttributeText = xmlAttributeText.Replace("<", "&lt;");
             xmlAttributeText = xmlAttributeText.Replace(">", "&gt;");
             xmlAttributeText = ReplaceNonEscapingAmpersands(xmlAttributeText);
-            
+
             return xmlAttributeText;
         }
 
@@ -429,7 +429,7 @@ string xmlAttributeText
             //      aaa&bbb         should be replaced with         aaa&amp;bbb
             // But:
             //      aaa&lt;bbb      should not be touched.
-            
+
             // Loop through each instance of "&"
             int indexOfAmpersand = xmlAttributeText.IndexOf('&');
             while (indexOfAmpersand != -1)
@@ -448,7 +448,7 @@ string xmlAttributeText
                 {
                     // We found the semicolon.  Capture the characters between (but not
                     // including) the "&" and ";".
-                    string entityName = xmlAttributeText.Substring(indexOfAmpersand + 1, 
+                    string entityName = xmlAttributeText.Substring(indexOfAmpersand + 1,
                         indexOfNextSemicolon - indexOfAmpersand - 1);
 
                     // Perf note: Here we are walking through the entire list of entities, and
@@ -456,7 +456,7 @@ string xmlAttributeText
                     // should only get executed in fairly rare circumstances.  It's not very 
                     // common for people to have these embedded into their project files.
                     bool foundEntity = false;
-                    for (int i = 0 ; i < entities.Length ; i++)
+                    for (int i = 0; i < entities.Length; i++)
                     {
                         // Case-sensitive comparison to see if the entity name matches any of
                         // the well-known ones that were emitted by the XML writer in the VS.NET
@@ -478,7 +478,7 @@ string xmlAttributeText
                     {
                         // At this point, we know entityName is something like "#1234" or "#x1234abcd"
                         bool isNumber = false;
-                        
+
                         // A lower-case "x" in the second position indicates a hexadecimal value.
                         if ((entityName.Length > 2) && (entityName[1] == 'x'))
                         {
@@ -562,7 +562,7 @@ int indexOfAmpersand
         // This is the complete list of well-known entity names that were written out
         // by the XML writer in the VS.NET 2002/2003 project system.  This list was
         // taken directly from the source code.
-        private static readonly string[] entities = 
+        private static readonly string[] entities =
         {
             "quot",          // 
             "amp",           // & - ampersand
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 8356633c1d9..54d85e27bb6 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -185,7 +185,7 @@ public sealed class ProjectFileConverter
         private ArrayList conversionWarnings = null;
 
         // A list of property names whose values we need to escape when converting to Whidbey.
-        private Dictionary<string,string> propertiesToEscape = null;
+        private Dictionary<string, string> propertiesToEscape = null;
 
         /// <summary>
         /// Default constructor.  We need a constructor that takes zero parameters,
@@ -300,7 +300,7 @@ public string[] ConversionWarnings
         {
             get
             {
-                return (string[]) conversionWarnings.ToArray(typeof(string));
+                return (string[])conversionWarnings.ToArray(typeof(string));
             }
         }
 
@@ -400,7 +400,7 @@ private void Initialize()
             this.isMyTypeAlreadySetInOriginalProject = false;
             this.conversionWarnings = new ArrayList();
 
-            this.propertiesToEscape = new Dictionary<string,string>(StringComparer.OrdinalIgnoreCase);
+            this.propertiesToEscape = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
             this.propertiesToEscape.Add("ApplicationIcon", null);
             this.propertiesToEscape.Add("AssemblyKeyContainerName", null);
             this.propertiesToEscape.Add("AssemblyName", null);
@@ -464,13 +464,13 @@ private void ConvertInMemoryToMSBuildProject()
             // but since XML comments may appear outside of the <VisualStudioProject> scope,
             // it's possible to get more than one child node.  Just find the first
             // non-comment node.  That should be the <VisualStudioProject> element.
-            foreach(XmlNode childNode in rootNodes)
+            foreach (XmlNode childNode in rootNodes)
             {
                 if ((childNode.NodeType != XmlNodeType.Comment) &&
                     (childNode.NodeType != XmlNodeType.XmlDeclaration) &&
                     (childNode.NodeType != XmlNodeType.Whitespace))
                 {
-                    visualStudioProjectElement = (XmlElementWithLocation) childNode;
+                    visualStudioProjectElement = (XmlElementWithLocation)childNode;
                     break;
                 }
             }
@@ -814,9 +814,9 @@ private IEnumerable<ProjectImportElement> RequiresRepairForAssetCompat()
         {
             // check if the project has the to-repair pattern in the Imports
             // pattern: $(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\
-            var toRepairImports =  from import in xmakeProject.Imports
-                                   where HasRepairPattern(import)
-                                   select import;
+            var toRepairImports = from import in xmakeProject.Imports
+                                  where HasRepairPattern(import)
+                                  select import;
 
             return toRepairImports;
         }
@@ -882,13 +882,13 @@ private bool FixTargetFrameworkSubset()
 
             foreach (ProjectPropertyElement propertyElement in xmakeProject.Properties)
             {
-                if (String.Equals(propertyElement.Name , XMakeProjectStrings.TargetFrameworkSubset, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(propertyElement.Name, XMakeProjectStrings.TargetFrameworkSubset, StringComparison.OrdinalIgnoreCase))
                 {
                     // For the Client profile, which was the only profile supported in Orcas SP1, we want to replace 
                     // <TargetFrameworkSubset/> with <TargetFrameworkProfile/>.
                     if (String.Equals(propertyElement.Value, XMakeProjectStrings.ClientProfile, StringComparison.OrdinalIgnoreCase))
                     {
-                        ProjectPropertyGroupElement parentGroup = (ProjectPropertyGroupElement) propertyElement.Parent;
+                        ProjectPropertyGroupElement parentGroup = (ProjectPropertyGroupElement)propertyElement.Parent;
                         parentGroup.SetProperty(XMakeProjectStrings.TargetFrameworkProfile, XMakeProjectStrings.ClientProfile);
                         changedProject = true;
                     }
@@ -995,7 +995,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 else if (equals(importElement.Project, fsharpPortableDev11TargetsPath))
                 {
                     fsharpTargetsDev11PortableImport = importElement;
-                    isAtLeastDev10Project= true;
+                    isAtLeastDev10Project = true;
                 }
             }
 
@@ -1205,7 +1205,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             const string MinimumVisualStudioVersionProperty = "MinimumVisualStudioVersion";
             var hasMinimumVSVersion = xmakeProject.Properties.Any(prop => prop.Name == MinimumVisualStudioVersionProperty);
 
-            foreach(var group in xmakeProject.PropertyGroups)
+            foreach (var group in xmakeProject.PropertyGroups)
             {
                 // find first non-conditional property group to add TargetFSharpCoreVersion property
                 if (string.IsNullOrEmpty(group.Condition))
@@ -1408,7 +1408,7 @@ ProjectLoadSettings projectLoadSettings
         private void AddXMakePropertiesFromXMLAttributes
             (
             ProjectPropertyGroupElement propertyGroup,
-            XmlElement          xmlElement
+            XmlElement xmlElement
             )
         {
             error.VerifyThrow(propertyGroup != null, "Expected valid ProjectPropertyElementGroup to add properties to.");
@@ -1434,7 +1434,7 @@ XmlElement          xmlElement
         /// <owner>RGoel</owner>
         private void ProcessVisualStudioProjectElement
             (
-            XmlElementWithLocation      visualStudioProjectElement
+            XmlElementWithLocation visualStudioProjectElement
             )
         {
             // Make sure this is the <VisualStudioProject> element.
@@ -1459,7 +1459,7 @@ XmlElementWithLocation      visualStudioProjectElement
             bool languageFound = false;
 
             // Loop through all the direct children of the <VisualStudioProject> element.
-            foreach(XmlNode visualStudioProjectChildNode in visualStudioProjectElement)
+            foreach (XmlNode visualStudioProjectChildNode in visualStudioProjectElement)
             {
                 // Handle XML comments under the <VisualStudioProject> node (just ignore them)
                 if ((visualStudioProjectChildNode.NodeType == XmlNodeType.Comment) ||
@@ -1510,7 +1510,7 @@ XmlElementWithLocation      visualStudioProjectElement
         /// <owner>RGoel</owner>
         private void ProcessLanguageElement
             (
-            XmlElementWithLocation      languageElement
+            XmlElementWithLocation languageElement
             )
         {
             // Make sure we have a valid XML element to process.
@@ -1610,24 +1610,24 @@ XmlElementWithLocation      languageElement
             {
                 if (languageElement.Name == VSProjectElements.ECSharp)
                 {
-                    this.globalPropertyGroup.AddProperty ( XMakeProjectStrings.projectTypeGuids,
+                    this.globalPropertyGroup.AddProperty(XMakeProjectStrings.projectTypeGuids,
                                                               "{" +
                                                               XMakeProjectStrings.VSDCSProjectTypeGuid +
                                                               "};{" +
                                                               XMakeProjectStrings.cSharpGuid +
-                                                              "}" );
-                    string visualStudioProjectExtensions =  GetProjectExtensionsString(XMakeProjectStrings.visualStudio);
+                                                              "}");
+                    string visualStudioProjectExtensions = GetProjectExtensionsString(XMakeProjectStrings.visualStudio);
                     visualStudioProjectExtensions += XMakeProjectStrings.disableCSHostProc;
                     SetProjectExtensionsString(XMakeProjectStrings.visualStudio, visualStudioProjectExtensions);
                 }
                 else if (languageElement.Name == VSProjectElements.EVisualBasic)
                 {
-                    this.globalPropertyGroup.AddProperty ( XMakeProjectStrings.projectTypeGuids,
+                    this.globalPropertyGroup.AddProperty(XMakeProjectStrings.projectTypeGuids,
                                                               "{" +
                                                               XMakeProjectStrings.VSDVBProjectTypeGuid +
                                                               "};{" +
                                                               XMakeProjectStrings.visualBasicGuid +
-                                                              "}" );
+                                                              "}");
                     string visualStudioProjectExtensions = GetProjectExtensionsString(XMakeProjectStrings.visualStudio);
                     visualStudioProjectExtensions += XMakeProjectStrings.disableVBHostProc;
                     SetProjectExtensionsString(XMakeProjectStrings.visualStudio, visualStudioProjectExtensions);
@@ -1635,7 +1635,7 @@ XmlElementWithLocation      languageElement
             }
 
             // Loop through all the direct child elements of the language element.
-            foreach(XmlNode languageChildNode in languageElement)
+            foreach (XmlNode languageChildNode in languageElement)
             {
                 // Handle XML comments under the the language node (just ignore them).
                 if ((languageChildNode.NodeType == XmlNodeType.Comment) ||
@@ -1824,7 +1824,7 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
         /// <owner>RGoel</owner>
         private void ProcessBuildElement
             (
-            XmlElementWithLocation      buildElement
+            XmlElementWithLocation buildElement
             )
         {
             // Make sure this is the <Build> element.
@@ -1841,7 +1841,7 @@ XmlElementWithLocation      buildElement
                 "NoAttributesExpected", VSProjectElements.build);
 
             // Loop through all the direct child elements of the <Build> element.
-            foreach(XmlNode buildChildNode in buildElement)
+            foreach (XmlNode buildChildNode in buildElement)
             {
                 // Handle XML comments under the the <Build> node (just ignore them).
                 if ((buildChildNode.NodeType == XmlNodeType.Comment) ||
@@ -1891,7 +1891,7 @@ XmlElementWithLocation      buildElement
         /// <owner>RGoel</owner>
         private void ProcessSettingsElement
             (
-            XmlElementWithLocation      settingsElement
+            XmlElementWithLocation settingsElement
             )
         {
             // Make sure this is the <Settings> element.
@@ -1970,7 +1970,7 @@ XmlElementWithLocation      settingsElement
             this.AddXMakePropertiesFromXMLAttributes(this.globalPropertyGroup, settingsElement);
 
             // Loop through all the direct child elements of the <Build> element.
-            foreach(XmlNode settingsChildNode in settingsElement)
+            foreach (XmlNode settingsChildNode in settingsElement)
             {
                 // Handle XML comments under the the <Settings> node (just ignore them).
                 if ((settingsChildNode.NodeType == XmlNodeType.Comment) ||
@@ -2016,7 +2016,7 @@ XmlElementWithLocation      settingsElement
         /// <owner>RGoel</owner>
         private void ProcessConfigElement
             (
-            XmlElementWithLocation      configElement
+            XmlElementWithLocation configElement
             )
         {
             // Make sure this is the <Config> element.
@@ -2083,14 +2083,14 @@ XmlElementWithLocation      configElement
             // In the case of VSD projects, the "Name" attribute will have a pipe in it,
             // followed by the device platform.  This last part needs to be removed,
             // leaving just the config name.
-            if ( ( this.language == VSProjectElements.ECSharp ) ||
-                 ( this.language == VSProjectElements.EVisualBasic ) )
+            if ((this.language == VSProjectElements.ECSharp) ||
+                 (this.language == VSProjectElements.EVisualBasic))
             {
-                int pipeLocation = configName.IndexOf ( '|' );
-                if ( pipeLocation != -1 )
+                int pipeLocation = configName.IndexOf('|');
+                if (pipeLocation != -1)
                 {
-                    configName = configName.Remove ( pipeLocation,
-                                                     configName.Length - pipeLocation );
+                    configName = configName.Remove(pipeLocation,
+                                                     configName.Length - pipeLocation);
                 }
             }
 
@@ -2117,7 +2117,7 @@ XmlElementWithLocation      configElement
             string outputPath = configElement.GetAttribute(VSProjectAttributes.outputPath);
             if (!string.IsNullOrEmpty(outputPath))
             {
-                if (outputPath[outputPath.Length-1] != Path.DirectorySeparatorChar)
+                if (outputPath[outputPath.Length - 1] != Path.DirectorySeparatorChar)
                 {
                     outputPath += Path.DirectorySeparatorChar;
                 }
@@ -2128,23 +2128,23 @@ XmlElementWithLocation      configElement
 
             // If the "SelectedDevice" or "DeploymentPlatform" attributes exist in the per-user
             //   project file, we should get rid of them.
-            string selectedDevice = configElement.GetAttribute ( VSProjectAttributes.selectedDevice );
+            string selectedDevice = configElement.GetAttribute(VSProjectAttributes.selectedDevice);
             if (isUserFile && (selectedDevice?.Length > 0))
             {
-                configElement.RemoveAttribute ( VSProjectAttributes.selectedDevice );
+                configElement.RemoveAttribute(VSProjectAttributes.selectedDevice);
             }
 
-            string deploymentPlatform = configElement.GetAttribute ( VSProjectAttributes.deploymentPlatform );
+            string deploymentPlatform = configElement.GetAttribute(VSProjectAttributes.deploymentPlatform);
             if (isUserFile && (deploymentPlatform?.Length > 0))
             {
-                configElement.RemoveAttribute ( VSProjectAttributes.deploymentPlatform );
+                configElement.RemoveAttribute(VSProjectAttributes.deploymentPlatform);
             }
 
             // Get rid of the "IncrementalBuild" attribute
-            string incrementalBuild = configElement.GetAttribute ( VSProjectAttributes.incrementalBuild );
+            string incrementalBuild = configElement.GetAttribute(VSProjectAttributes.incrementalBuild);
             if (!string.IsNullOrEmpty(incrementalBuild))
             {
-                configElement.RemoveAttribute ( VSProjectAttributes.incrementalBuild );
+                configElement.RemoveAttribute(VSProjectAttributes.incrementalBuild);
             }
 
             // VSWhidbey bug 261464.  For VB projects migrated from VS7/Everett, the VB team would
@@ -2187,11 +2187,11 @@ XmlElementWithLocation      configElement
                 if (String.IsNullOrEmpty(debugType))
                 {
                     string debugSymbols = configElement.GetAttribute(XMakeProjectStrings.debugSymbols);
-                    if (  String.Equals ( debugSymbols, "true", StringComparison.OrdinalIgnoreCase ) )
+                    if (String.Equals(debugSymbols, "true", StringComparison.OrdinalIgnoreCase))
                     {
                         configPropertyGroup.AddProperty(VSProjectAttributes.debugType, VSProjectAttributes.debugTypeFull);
                     }
-                    else if ( String.Equals(debugSymbols, "false", StringComparison.OrdinalIgnoreCase) )
+                    else if (String.Equals(debugSymbols, "false", StringComparison.OrdinalIgnoreCase))
                     {
                         configPropertyGroup.AddProperty(VSProjectAttributes.debugType, VSProjectAttributes.debugTypeNone);
                     }
@@ -2200,7 +2200,7 @@ XmlElementWithLocation      configElement
 
             // VSWhidbey bug 472064.  For all VC# projects that are converted, we add an ErrorReport
             // property, always set to "prompt"
-            if ( !this.isUserFile && this.language == VSProjectElements.cSharp )
+            if (!this.isUserFile && this.language == VSProjectElements.cSharp)
             {
                 configPropertyGroup.AddProperty(VSProjectAttributes.errorReport, VSProjectAttributes.errorReportPrompt);
             }
@@ -2216,7 +2216,7 @@ XmlElementWithLocation      configElement
                 ProjectCollection.Escape(platform) + XMakeProjectStrings.configplatformSuffix;
 
             // Loop through all the direct child elements of the <Config> element.
-            foreach(XmlNode configChildNode in configElement)
+            foreach (XmlNode configChildNode in configElement)
             {
                 // Handle XML comments under the the <Config> node (just ignore them).
                 if ((configChildNode.NodeType == XmlNodeType.Comment) ||
@@ -2257,10 +2257,10 @@ XmlElementWithLocation      configElement
         /// <owner>BCham</owner>
         private void ProcessPlatformElement
             (
-            XmlElementWithLocation      platformElement
+            XmlElementWithLocation platformElement
             )
         {
-            if ( !IsUserFile )
+            if (!IsUserFile)
             {
                 // Make sure this is the <Platform> element.
                 error.VerifyThrow((platformElement?.Name == VSProjectElements.platform),
@@ -2298,7 +2298,7 @@ XmlElementWithLocation      platformElement
 
                 frameworkVersionForVSD = XMakeProjectStrings.vOne;
 
-                switch ( platformForVSD )
+                switch (platformForVSD)
                 {
                     case VSProjectElements.PocketPC:
                         platformID = "3C41C503-53EF-4c2a-8DD4-A8217CAD115E";
@@ -2333,7 +2333,7 @@ XmlElementWithLocation      platformElement
                 //   add a property for the deployment target path.  Note, we only need a suffix.
                 //   The prefix will be defaulted to based on the selected device.
 
-                platformPropertyGroup.AddProperty(XMakeProjectStrings.deployTargetSuffix, "$(AssemblyName)" );
+                platformPropertyGroup.AddProperty(XMakeProjectStrings.deployTargetSuffix, "$(AssemblyName)");
 
                 // And, we should also set the Target Framework version.  For
                 //   VSD projects, we want to stay with v1.0
@@ -2350,7 +2350,7 @@ XmlElementWithLocation      platformElement
         /// <owner>RGoel</owner>
         private void ProcessInteropRegistrationElement
             (
-            XmlElementWithLocation      interopRegistrationElement,
+            XmlElementWithLocation interopRegistrationElement,
             ProjectPropertyGroupElement configPropertyGroup
             )
         {
@@ -2407,7 +2407,7 @@ ProjectPropertyGroupElement configPropertyGroup
         /// <owner>RGoel</owner>
         private void ProcessReferencesElement
             (
-            XmlElementWithLocation      referencesElement
+            XmlElementWithLocation referencesElement
             )
         {
             // Make sure this is the <References> element.
@@ -2445,7 +2445,7 @@ XmlElementWithLocation      referencesElement
             ProjectItemGroupElement referencesItemGroup = null;
 
             // Loop through all the direct child elements of the <References> element.
-            foreach(XmlNode referencesChildNode in referencesElement)
+            foreach (XmlNode referencesChildNode in referencesElement)
             {
                 // Handle XML comments under the the <References> node (just ignore them).
                 if ((referencesChildNode.NodeType == XmlNodeType.Comment) ||
@@ -2490,7 +2490,7 @@ XmlElementWithLocation      referencesElement
         /// <owner>RGoel</owner>
         private void ProcessReferenceElement
             (
-            XmlElementWithLocation      referenceElement,
+            XmlElementWithLocation referenceElement,
             ProjectItemGroupElement referencesItemGroup
             )
         {
@@ -2514,7 +2514,7 @@ ProjectItemGroupElement referencesItemGroup
                     return;
                 }
 
-                referenceElement.RemoveAttribute ( VSProjectAttributes.platform );
+                referenceElement.RemoveAttribute(VSProjectAttributes.platform);
             }
 
             ProjectItemElement newReferenceItem;
@@ -2530,23 +2530,23 @@ ProjectItemGroupElement referencesItemGroup
             if ((this.language == VSProjectElements.ECSharp) ||
                    (this.language == VSProjectElements.EVisualBasic))
             {
-                if ( ( this.frameworkVersionForVSD == XMakeProjectStrings.vTwo ) &&
-                     ( String.Equals ( referenceName, VSProjectElements.SystemDataCommon, StringComparison.OrdinalIgnoreCase ) ) )
+                if ((this.frameworkVersionForVSD == XMakeProjectStrings.vTwo) &&
+                     (String.Equals(referenceName, VSProjectElements.SystemDataCommon, StringComparison.OrdinalIgnoreCase)))
                 {
                     // We need to remove all references to "System.Data.Common" for VSD projects only.
                     //   Note : We only want to do this for projects that will be updated to v2.0
                     //          System.Data.Common is still valid for v1.0 upgraded projects.
                     return;
                 }
-                else if ( String.Equals ( referenceName, VSProjectElements.SystemSR, StringComparison.OrdinalIgnoreCase ) )
+                else if (String.Equals(referenceName, VSProjectElements.SystemSR, StringComparison.OrdinalIgnoreCase))
                 {
                     // We always want to remove all references to "System.SR"
                     return;
                 }
             }
 
-            if ( ( this.language == VSProjectElements.EVisualBasic ) &&
-                 ( String.Equals ( referenceName, VSProjectElements.MSCorLib, StringComparison.OrdinalIgnoreCase ) ) )
+            if ((this.language == VSProjectElements.EVisualBasic) &&
+                 (String.Equals(referenceName, VSProjectElements.MSCorLib, StringComparison.OrdinalIgnoreCase)))
             {
                 // We also want to get rid of all 'mscorlib' references for VB projects only.
                 return;
@@ -2939,7 +2939,7 @@ string referencedProjectGuid
         /// <owner>RGoel</owner>
         private void ProcessImportsElement
             (
-            XmlElementWithLocation      importsElement
+            XmlElementWithLocation importsElement
             )
         {
             // Make sure this is the <Imports> element.
@@ -2957,7 +2957,7 @@ XmlElementWithLocation      importsElement
             ProjectItemGroupElement importsItemGroup = null;
 
             // Loop through all the direct child elements of the <Imports> element.
-            foreach(XmlNode importsChildNode in importsElement)
+            foreach (XmlNode importsChildNode in importsElement)
             {
                 // Handle XML comments under the the <Imports> node (just ignore them).
                 if ((importsChildNode.NodeType == XmlNodeType.Comment) ||
@@ -3055,7 +3055,7 @@ ProjectItemGroupElement importsItemGroup
         /// <owner>RGoel</owner>
         private void ProcessFilesElement
             (
-            XmlElementWithLocation      filesElement
+            XmlElementWithLocation filesElement
             )
         {
             // Make sure this is the <Files> element.
@@ -3071,7 +3071,7 @@ XmlElementWithLocation      filesElement
                 "NoAttributesExpected", VSProjectElements.files);
 
             // Loop through all the direct child elements of the <Files> element.
-            foreach(XmlNode filesChildNode in filesElement)
+            foreach (XmlNode filesChildNode in filesElement)
             {
                 // Handle XML comments under the the <Files> node (just ignore them).
                 if ((filesChildNode.NodeType == XmlNodeType.Comment) ||
@@ -3121,7 +3121,7 @@ XmlElementWithLocation      filesElement
         /// <owner>RGoel</owner>
         private void ProcessIncludeElement
             (
-            XmlElementWithLocation      includeElement
+            XmlElementWithLocation includeElement
             )
         {
             // Make sure this is the <Include> element.
@@ -3139,7 +3139,7 @@ XmlElementWithLocation      includeElement
             ProjectItemGroupElement filesItemGroup = null;
 
             // Loop through all the direct child elements of the <Include> element.
-            foreach(XmlNode includeChildNode in includeElement)
+            foreach (XmlNode includeChildNode in includeElement)
             {
                 // Handle XML comments under the the <Include> node (just ignore them).
                 if ((includeChildNode.NodeType == XmlNodeType.Comment) ||
@@ -3189,7 +3189,7 @@ XmlElementWithLocation      includeElement
         /// <owner>RGoel</owner>
         private void ProcessFileElement
             (
-            XmlElementWithLocation      fileElement,
+            XmlElementWithLocation fileElement,
             ProjectItemGroupElement filesItemGroup
             )
         {
@@ -3298,12 +3298,12 @@ ProjectItemGroupElement filesItemGroup
 
                 // If this is a VSD(devices) project and we're dealing with a content file,
                 // mark it to copy if newer.
-                if ( ((this.language == VSProjectElements.ECSharp) ||
+                if (((this.language == VSProjectElements.ECSharp) ||
                          (this.language == VSProjectElements.EVisualBasic)) &&
-                     ( String.Equals ( buildAction, XMakeProjectStrings.content, StringComparison.OrdinalIgnoreCase ) ) )
+                     (String.Equals(buildAction, XMakeProjectStrings.content, StringComparison.OrdinalIgnoreCase)))
                 {
-                    newFileItem.AddMetadata ( XMakeProjectStrings.copytooutput,
-                                              XMakeProjectStrings.preservenewest );
+                    newFileItem.AddMetadata(XMakeProjectStrings.copytooutput,
+                                              XMakeProjectStrings.preservenewest);
                 }
             }
             else
@@ -3378,7 +3378,7 @@ private bool IsFilePresentButEmpty(string relPath, string linkPath)
         /// <owner>RGoel</owner>
         private void ProcessFolderElement
             (
-            XmlElementWithLocation      folderElement,
+            XmlElementWithLocation folderElement,
             ProjectItemGroupElement filesItemGroup
             )
         {
@@ -3527,7 +3527,7 @@ ProjectItemGroupElement filesItemGroup
         /// <owner>RGoel</owner>
         private void ProcessStartupServicesElement
             (
-            XmlElementWithLocation      startupServicesElement
+            XmlElementWithLocation startupServicesElement
             )
         {
             // Make sure this is the <StartupServices> element.
@@ -3545,7 +3545,7 @@ XmlElementWithLocation      startupServicesElement
             ProjectItemGroupElement startupServicesItemGroup = null;
 
             // Loop through all the direct child elements of the <StartupServices> element.
-            foreach(XmlNode startupServicesChildNode in startupServicesElement)
+            foreach (XmlNode startupServicesChildNode in startupServicesElement)
             {
                 // Handle XML comments under the the <StartupServices> node (just ignore them).
                 if ((startupServicesChildNode.NodeType == XmlNodeType.Comment) ||
@@ -3590,7 +3590,7 @@ XmlElementWithLocation      startupServicesElement
         /// <owner>RGoel</owner>
         private void ProcessServiceElement
             (
-            XmlElementWithLocation      serviceElement,
+            XmlElementWithLocation serviceElement,
             ProjectItemGroupElement startupServicesItemGroup
             )
         {
@@ -3643,7 +3643,7 @@ ProjectItemGroupElement startupServicesItemGroup
         /// <owner>RGoel</owner>
         private void ProcessOtherProjectSettingsElement
             (
-            XmlElementWithLocation      otherProjectSettingsElement
+            XmlElementWithLocation otherProjectSettingsElement
             )
         {
             // Make sure this is the <OtherProjectSettings> element.
@@ -3698,8 +3698,8 @@ XmlElementWithLocation      otherProjectSettingsElement
         /// <owner>rgoel</owner>
         private void ProcessUserPropertiesElement
             (
-            XmlElementWithLocation      userPropertiesElement,
-            out bool                    isTriumphProject
+            XmlElementWithLocation userPropertiesElement,
+            out bool isTriumphProject
             )
         {
             // Make sure this is the <UserProperties> element.
diff --git a/src/Deprecated/Engine/Caching/CacheEntryCustomSerializer.cs b/src/Deprecated/Engine/Caching/CacheEntryCustomSerializer.cs
index 2538722be84..2fa94153cae 100644
--- a/src/Deprecated/Engine/Caching/CacheEntryCustomSerializer.cs
+++ b/src/Deprecated/Engine/Caching/CacheEntryCustomSerializer.cs
@@ -38,7 +38,7 @@ internal static void WriteToStream(CacheEntry entry, BinaryWriter writer)
 
         internal static CacheEntry CreateFromStream(BinaryReader reader)
         {
-            CacheEntryTypes entryType = (CacheEntryTypes) reader.ReadByte();
+            CacheEntryTypes entryType = (CacheEntryTypes)reader.ReadByte();
             CacheEntry entry = null;
 
             switch (entryType)
diff --git a/src/Deprecated/Engine/Choose/GroupEnumeratorHelper.cs b/src/Deprecated/Engine/Choose/GroupEnumeratorHelper.cs
index 70360f67a3d..792b8d3f3fd 100644
--- a/src/Deprecated/Engine/Choose/GroupEnumeratorHelper.cs
+++ b/src/Deprecated/Engine/Choose/GroupEnumeratorHelper.cs
@@ -74,11 +74,11 @@ ListType type
         /// </remarks>
         /// <owner>DavidLe</owner>
         /// <returns>IEnumerator</returns>
-        public IEnumerator GetEnumerator( )
+        public IEnumerator GetEnumerator()
         {
             foreach (IItemPropertyGrouping group in this.groupingCollection)
             {
-                if ((group is BuildItemGroup) && 
+                if ((group is BuildItemGroup) &&
                     ((this.type == ListType.ItemGroupsTopLevel) || (this.type == ListType.ItemGroupsTopLevelAndChoose) || (this.type == ListType.ItemGroupsAll)))
                 {
                     yield return group;
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index b743c0bc57f..31276204924 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -77,7 +77,7 @@ internal int PropertyGroupCount
                 return this.propertyGroupCount;
             }
         }
-        
+
         /// <summary>
         /// </summary>
         internal object SyncRoot
@@ -563,7 +563,7 @@ internal void RemoveAllPropertyGroupsByCondition(string condition, bool includeI
             ArrayList propertiesToRemove = new ArrayList();
             foreach (BuildPropertyGroup propertyGroup in this.PropertyGroupsAll)
             {
-                if (String.Equals(condition.Trim(), propertyGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
+                if (String.Equals(condition.Trim(), propertyGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase)
                     && (!propertyGroup.IsImported || includeImportedPropertyGroups))
                 {
                     propertiesToRemove.Add(propertyGroup);
@@ -623,7 +623,7 @@ internal void RemoveAllItemGroupsByCondition(string condition)
 
             foreach (BuildItemGroup itemGroup in this.ItemGroupsAll)
             {
-                if (String.Equals(condition.Trim(), itemGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
+                if (String.Equals(condition.Trim(), itemGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase)
                     && !itemGroup.IsImported)
                 {
                     itemsToRemove.Add(itemGroup);
diff --git a/src/Deprecated/Engine/Choose/When.cs b/src/Deprecated/Engine/Choose/When.cs
index 83f85fc5505..5efabc16852 100644
--- a/src/Deprecated/Engine/Choose/When.cs
+++ b/src/Deprecated/Engine/Choose/When.cs
@@ -73,7 +73,7 @@ int nestingDepth
             if (options == Options.ProcessWhen)
             {
                 conditionAttribute = ProjectXmlUtilities.GetConditionAttribute(whenElement, /*verify sole attribute*/ true);
-                ProjectErrorUtilities.VerifyThrowInvalidProject(conditionAttribute != null, whenElement, "MissingCondition", XMakeElements.when);            
+                ProjectErrorUtilities.VerifyThrowInvalidProject(conditionAttribute != null, whenElement, "MissingCondition", XMakeElements.when);
             }
             else
             {
@@ -207,7 +207,7 @@ int nestingDepth
             }
         }
 
-       /// <summary>
+        /// <summary>
         /// Evaluates a When clause.  Checks if the condition is true, and if it is,
         /// applies all of the contained property group, item lists, and import statements.
         /// Returns true if the When clause is process (because the condition is true), false
@@ -225,9 +225,9 @@ internal bool EvaluateCondition
             Hashtable conditionedPropertiesTable
         )
         {
-            if  (
-                    (this.Condition != null) 
-                    && 
+            if (
+                    (this.Condition != null)
+                    &&
                     !Utilities.EvaluateCondition(this.Condition, this.ConditionAttribute,
                         new Expander(parentPropertyBag, parentProject.EvaluatedItemsByName),
                         conditionedPropertiesTable, ParserOptions.AllowProperties, this.parentProject.ParentEngine.LoggingServices, this.parentProject.ProjectBuildEventContext)
@@ -269,16 +269,16 @@ ProcessingPass pass
                 if (propOrItem is BuildPropertyGroup &&
                     pass == ProcessingPass.Pass1)
                 {
-                    ((BuildPropertyGroup) propOrItem).Evaluate(parentPropertyBag, conditionedPropertiesTable, pass);
+                    ((BuildPropertyGroup)propOrItem).Evaluate(parentPropertyBag, conditionedPropertiesTable, pass);
                 }
                 else if (propOrItem is BuildItemGroup &&
                     pass == ProcessingPass.Pass2)
                 {
-                    ((BuildItemGroup) propOrItem).Evaluate(parentPropertyBag, parentProject.EvaluatedItemsByName, ignoreCondition, honorCondition, pass);
+                    ((BuildItemGroup)propOrItem).Evaluate(parentPropertyBag, parentProject.EvaluatedItemsByName, ignoreCondition, honorCondition, pass);
                 }
                 else if (propOrItem is Choose)
                 {
-                    ((Choose) propOrItem).Evaluate(parentPropertyBag, ignoreCondition, honorCondition, conditionedPropertiesTable, pass);
+                    ((Choose)propOrItem).Evaluate(parentPropertyBag, ignoreCondition, honorCondition, conditionedPropertiesTable, pass);
                 }
             }
         }
diff --git a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
index e700930ad8d..35af126fac5 100644
--- a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
+++ b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
@@ -24,7 +24,7 @@ internal sealed class CopyOnWriteHashtable : IDictionary, ICloneable
         // Carry around the StringComparer when possible to make Clear less expensive.
         private StringComparer stringComparer = null;
 
-#region Construct
+        #region Construct
         /// <summary>
         /// Construct as a traditional data-backed hashtable.
         /// </summary>
@@ -101,7 +101,7 @@ private CopyOnWriteHashtable(CopyOnWriteHashtable that)
             this.sharedLock = new object();
             ConstructFrom(that);
         }
-        
+
         /// <summary>
         /// Implementation of construction logic.
         /// </summary>
@@ -136,11 +136,11 @@ internal bool IsShallowCopy
                 return this.readonlyData != null;
             }
         }
-#endregion
-#region Pass-through Hashtable methods.
-        public bool Contains(Object key) {return ReadOperation.Contains(key);}
-        public void Add(Object key, Object value) {WriteOperation.Add(key, value);}
-        public void Clear() 
+        #endregion
+        #region Pass-through Hashtable methods.
+        public bool Contains(Object key) { return ReadOperation.Contains(key); }
+        public void Add(Object key, Object value) { WriteOperation.Add(key, value); }
+        public void Clear()
         {
             lock (sharedLock)
             {
@@ -152,25 +152,25 @@ public void Clear()
         }
 
         IEnumerator IEnumerable.GetEnumerator() { return ((IEnumerable)ReadOperation).GetEnumerator(); }
-        public IDictionaryEnumerator GetEnumerator() {return ReadOperation.GetEnumerator();}
-        public void Remove(Object key) {WriteOperation.Remove(key);}        
-        public bool IsFixedSize { get { return ReadOperation.IsFixedSize; }}
-        public bool IsReadOnly {get {return ReadOperation.IsFixedSize;}}
-        public ICollection Keys {get {return ReadOperation.Keys;}}
-        public ICollection Values {get {return ReadOperation.Values;}}
+        public IDictionaryEnumerator GetEnumerator() { return ReadOperation.GetEnumerator(); }
+        public void Remove(Object key) { WriteOperation.Remove(key); }
+        public bool IsFixedSize { get { return ReadOperation.IsFixedSize; } }
+        public bool IsReadOnly { get { return ReadOperation.IsFixedSize; } }
+        public ICollection Keys { get { return ReadOperation.Keys; } }
+        public ICollection Values { get { return ReadOperation.Values; } }
         public void CopyTo(Array array, int arrayIndex) { ReadOperation.CopyTo(array, arrayIndex); }
-        public int Count{get { return ReadOperation.Count; }}
-        public bool IsSynchronized {get { return ReadOperation.IsSynchronized; }}
-        public Object SyncRoot {get { return ReadOperation.SyncRoot; }}
-        public bool ContainsKey(Object key)    {return ReadOperation.Contains(key);}
-        
-        public Object this[Object key] 
+        public int Count { get { return ReadOperation.Count; } }
+        public bool IsSynchronized { get { return ReadOperation.IsSynchronized; } }
+        public Object SyncRoot { get { return ReadOperation.SyncRoot; } }
+        public bool ContainsKey(Object key) { return ReadOperation.Contains(key); }
+
+        public Object this[Object key]
         {
-            get 
+            get
             {
                 return ReadOperation[key];
             }
-            set 
+            set
             {
                 lock (sharedLock)
                 {
@@ -189,7 +189,7 @@ public Object this[Object key]
                 }
             }
         }
-#endregion
+        #endregion
 
         /// <summary>
         /// Clone this.
diff --git a/src/Deprecated/Engine/Collections/DualQueue.cs b/src/Deprecated/Engine/Collections/DualQueue.cs
index 37448774e8f..db53d4574be 100644
--- a/src/Deprecated/Engine/Collections/DualQueue.cs
+++ b/src/Deprecated/Engine/Collections/DualQueue.cs
@@ -119,7 +119,7 @@ internal void Enqueue(T item)
                 writingQueueCount++;
 
                 // if the queue transitions from empty to non-empty reset the queue empty event and raise queue ready event
-                if ( writingQueueCount == 1)
+                if (writingQueueCount == 1)
                 {
                     // raise the event saying queue contains data
                     queueReadyEvent.Set();
@@ -256,7 +256,7 @@ private Queue<T> GetReadingQueue()
                         Queue<T> postingQueue = queue;
                         queue = readingQueue;
                         readingQueue = postingQueue;
-                        
+
                         writingQueueCount = 0;
                     }
                 }
diff --git a/src/Deprecated/Engine/Conditionals/AndExpressionNode.cs b/src/Deprecated/Engine/Conditionals/AndExpressionNode.cs
index c9b35383e35..e928d6a464c 100644
--- a/src/Deprecated/Engine/Conditionals/AndExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/AndExpressionNode.cs
@@ -21,7 +21,7 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
                      state.conditionAttribute,
                      "ExpressionDoesNotEvaluateToBoolean",
                      LeftChild.GetUnexpandedValue(state),
-                     LeftChild.GetExpandedValue(state), 
+                     LeftChild.GetExpandedValue(state),
                      state.parsedCondition);
 
             if (!LeftChild.BoolEvaluate(state))
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index cb5f3833cec..09c6d8cfabe 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -40,7 +40,7 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
 
                 if (Project.PerThreadProjectDirectory != null && !String.IsNullOrEmpty(expandedValue))
                 {
-                    try 
+                    try
                     {
                         expandedValue = Path.GetFullPath(Path.Combine(Project.PerThreadProjectDirectory, expandedValue));
                     }
@@ -90,9 +90,9 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
             {
                 ProjectErrorUtilities.VerifyThrowInvalidProject(
                     false,
-                    state.conditionAttribute, 
+                    state.conditionAttribute,
                     "UndefinedFunctionCall",
-                    state.parsedCondition, 
+                    state.parsedCondition,
                     this.functionName);
 
                 return false;
@@ -111,7 +111,7 @@ private string ExpandArgumentForScalarParameter(string function, GenericExpressi
         {
             string argument = argumentNode.GetUnexpandedValue(state);
 
-            List<TaskItem> items = state.expanderToUse.ExpandAllIntoTaskItems(argument, state.conditionAttribute); 
+            List<TaskItem> items = state.expanderToUse.ExpandAllIntoTaskItems(argument, state.conditionAttribute);
 
             string expandedValue = String.Empty;
 
diff --git a/src/Deprecated/Engine/Conditionals/MultipleComparisonExpressionNode.cs b/src/Deprecated/Engine/Conditionals/MultipleComparisonExpressionNode.cs
index 3f5ee4dbc44..5a3b81de9c1 100644
--- a/src/Deprecated/Engine/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/MultipleComparisonExpressionNode.cs
@@ -56,9 +56,9 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
                 string rightExpandedValue = RightChild.GetExpandedValue(state);
 
                 ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (leftExpandedValue != null && rightExpandedValue != null, 
-                     state.conditionAttribute, 
-                     "IllFormedCondition", 
+                    (leftExpandedValue != null && rightExpandedValue != null,
+                     state.conditionAttribute,
+                     "IllFormedCondition",
                      state.parsedCondition);
 
                 if (!conditionedPropertiesUpdated)
@@ -69,16 +69,16 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
                     if (leftUnexpandedValue != null)
                     {
                         Utilities.UpdateConditionedPropertiesTable
-                            (state.conditionedPropertiesInProject, 
-                             leftUnexpandedValue, 
+                            (state.conditionedPropertiesInProject,
+                             leftUnexpandedValue,
                              rightExpandedValue);
                     }
 
                     if (rightUnexpandedValue != null)
                     {
                         Utilities.UpdateConditionedPropertiesTable
-                            (state.conditionedPropertiesInProject, 
-                             rightUnexpandedValue, 
+                            (state.conditionedPropertiesInProject,
+                             rightUnexpandedValue,
                              leftExpandedValue);
                     }
 
diff --git a/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs b/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
index 6333997c111..6385ff8b13b 100644
--- a/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
@@ -23,7 +23,7 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (LeftChild.CanNumericEvaluate(state) && RightChild.CanNumericEvaluate(state),
-                 state.conditionAttribute, 
+                 state.conditionAttribute,
                 "ComparisonOnNonNumericExpression",
                  state.parsedCondition,
                  /* helpfully display unexpanded token and expanded result in error message */
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index 9dfbd1082ba..495c4581938 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -13,13 +13,13 @@ namespace Microsoft.Build.BuildEngine
     [Flags]
     internal enum ParserOptions
     {
-        None                = 0x0,
-        AllowProperties     = 0x1,
-        AllowItemLists      = 0x2,
+        None = 0x0,
+        AllowProperties = 0x1,
+        AllowItemLists = 0x2,
         AllowPropertiesAndItemLists = AllowProperties | AllowItemLists,
-        AllowItemMetadata   = 0x4,
+        AllowItemMetadata = 0x4,
         AllowPropertiesAndItemMetadata = AllowProperties | AllowItemMetadata,
-        AllowAll            = AllowProperties | AllowItemLists | AllowItemMetadata
+        AllowAll = AllowProperties | AllowItemLists | AllowItemMetadata
     };
 
     /// <summary>
@@ -38,10 +38,10 @@ internal sealed class Parser
         private ParserOptions options;
         internal int errorPosition = 0; // useful for unit tests
 
-#region REMOVE_COMPAT_WARNING
+        #region REMOVE_COMPAT_WARNING
 
         private bool warnedForExpression = false;
-        
+
         private BuildEventContext logBuildEventContext;
         /// <summary>
         ///  Location contextual information which are attached to logging events to 
@@ -68,13 +68,13 @@ internal EngineLoggingServices LoggingServices
             {
                 this.loggingServices = value;
             }
-            
+
             get
             {
                 return this.loggingServices;
             }
         }
-#endregion 
+        #endregion
 
         internal Parser()
         {
@@ -133,7 +133,7 @@ private GenericExpressionNode Expr(string expression)
                 warnedForExpression = true;
                 // Try to figure out where this expression was located
                 string projectFile = String.Empty;
-                int lineNumber   = 0;
+                int lineNumber = 0;
                 int columnNumber = 0;
                 if (this.conditionAttribute != null)
                 {
@@ -142,7 +142,7 @@ private GenericExpressionNode Expr(string expression)
                 }
                 // Log a warning regarding the fact the expression may have been evaluated
                 // incorrectly in earlier version of MSBuild
-                LoggingServices.LogWarning(logBuildEventContext,new BuildEventFileInfo(projectFile, lineNumber, columnNumber), "ConditionMaybeEvaluatedIncorrectly", expression);
+                LoggingServices.LogWarning(logBuildEventContext, new BuildEventFileInfo(projectFile, lineNumber, columnNumber), "ConditionMaybeEvaluatedIncorrectly", expression);
             }
             #endregion
 
@@ -161,7 +161,7 @@ private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode
                 GenericExpressionNode rhs = BooleanTerm(expression);
                 orNode.LeftChild = lhs;
                 orNode.RightChild = rhs;
-                return ExprPrime( expression, orNode );
+                return ExprPrime(expression, orNode);
             }
             else
             {
@@ -217,7 +217,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
 
         private GenericExpressionNode RelationalExpr(string expression)
         {
-         {
+            {
                 GenericExpressionNode lhs = Factor(expression);
                 if (lhs == null)
                 {
@@ -296,7 +296,7 @@ private GenericExpressionNode Factor(string expression)
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
                     return null;
                 }
-                return new FunctionCallExpressionNode( current.String, arglist);
+                return new FunctionCallExpressionNode(current.String, arglist);
             }
             else if (Same(expression, Token.TokenType.LeftParenthesis))
             {
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index 25734ce9a51..7d9a7fe4ba7 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -29,10 +29,10 @@ internal sealed class Scanner
         private bool errorState;
         private int errorPosition;
         // What we found instead of what we were looking for
-        private string unexpectedlyFound = null; 
+        private string unexpectedlyFound = null;
         private ParserOptions options;
         private string errorResource = null;
-        
+
         // Shared instances of "hardcoded" token strings. These are only used 
         // in error messages.
         private const string comma = ",";
@@ -104,7 +104,7 @@ internal string GetErrorResource()
             }
         }
 
-        internal bool IsNext( Token.TokenType type )
+        internal bool IsNext(Token.TokenType type)
         {
             return lookahead.IsToken(type);
         }
@@ -573,7 +573,7 @@ private bool ParseRemaining()
             }
             return true;
         }
-        private bool ParseSimpleStringOrFunction( int start )
+        private bool ParseSimpleStringOrFunction(int start)
         {
             SkipSimpleStringChars();
             if (string.Equals(expression.Substring(start, parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
@@ -600,16 +600,16 @@ private bool ParseSimpleStringOrFunction( int start )
             }
             return true;
         }
-        private bool ParseNumeric( int start )
+        private bool ParseNumeric(int start)
         {
-            if ((expression.Length-parsePoint) > 2 && expression[parsePoint] == '0' && (expression[parsePoint + 1] == 'x' || expression[parsePoint + 1] == 'X'))
+            if ((expression.Length - parsePoint) > 2 && expression[parsePoint] == '0' && (expression[parsePoint + 1] == 'x' || expression[parsePoint + 1] == 'X'))
             {
                 // Hex number
                 parsePoint += 2;
                 SkipHexDigits();
                 lookahead = new Token(Token.TokenType.Numeric, expression.Substring(start, parsePoint - start));
             }
-            else if ( CharacterUtilities.IsNumberStart(expression[parsePoint]))
+            else if (CharacterUtilities.IsNumberStart(expression[parsePoint]))
             {
                 // Decimal number
                 if (expression[parsePoint] == '+')
diff --git a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
index b5493eae3b2..0921cc390d6 100644
--- a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
@@ -26,7 +26,7 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
         {
             return ConversionUtilities.ConvertStringToBool(GetExpandedValue(state));
         }
-        
+
         /// <summary>
         /// Evaluate as numeric
         /// </summary>
diff --git a/src/Deprecated/Engine/Conditionals/Token.cs b/src/Deprecated/Engine/Conditionals/Token.cs
index 60d93cfaeee..11af505fbe5 100644
--- a/src/Deprecated/Engine/Conditionals/Token.cs
+++ b/src/Deprecated/Engine/Conditionals/Token.cs
@@ -14,7 +14,7 @@ internal sealed class Token
         /// <summary>
         /// Valid tokens
         /// </summary>
-        internal enum TokenType 
+        internal enum TokenType
         {
             Comma, LeftParenthesis, RightParenthesis,
             LessThan, GreaterThan, LessThanOrEqualTo, GreaterThanOrEqualTo,
@@ -33,7 +33,7 @@ internal enum TokenType
         /// </summary>
         /// <param name="type"></param>
         /// <param name="tokenString"></param>
-        internal Token( TokenType type, string tokenString )
+        internal Token(TokenType type, string tokenString)
         {
             this.tokenType = type;
             this.tokenString = tokenString;
@@ -44,7 +44,7 @@ internal Token( TokenType type, string tokenString )
         /// </summary>
         /// <param name="type"></param>
         /// <returns></returns>
-        internal bool IsToken( TokenType type )
+        internal bool IsToken(TokenType type)
         {
             return tokenType == type;
         }
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index f4cb0ac6e47..69800edbeac 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -192,9 +192,9 @@ private static Hashtable GetItemListsToBeBatched
         (
             XmlNode parentNode,
             Dictionary<string, MetadataReference> consumedMetadataReferences,   // Key is [string] potentially qualified metadata name
-                                                    // Value is [struct MetadataReference]
+                                                                                // Value is [struct MetadataReference]
             Hashtable consumedItemReferenceNames,       // Key is [string] item name.
-                                                    // Value is always String.Empty (unused).
+                                                        // Value is always String.Empty (unused).
             Lookup lookup
         )
         {
@@ -267,7 +267,7 @@ Lookup lookup
 
             return itemListsToBeBatched;
         }
-    
+
         /// <summary>
         /// Partitions the items consumed by the batchable object into buckets, where each bucket contains a set of items that
         /// have the same value set on all item metadata consumed by the object.
@@ -387,7 +387,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
                 string metadataItemName = consumedMetadataReference.Value.itemName;
                 string metadataName = consumedMetadataReference.Value.metadataName;
 
-                if  (
+                if (
                         (metadataItemName != null) &&
                         (!String.Equals(item.Name, metadataItemName, StringComparison.OrdinalIgnoreCase))
                     )
diff --git a/src/Deprecated/Engine/Engine/BuildRequest.cs b/src/Deprecated/Engine/Engine/BuildRequest.cs
index de90df06466..9a736c2fa04 100644
--- a/src/Deprecated/Engine/Engine/BuildRequest.cs
+++ b/src/Deprecated/Engine/Engine/BuildRequest.cs
@@ -494,13 +494,13 @@ internal long StartTime
             get { return startTime; }
             set { startTime = value; }
         }
-        
+
         internal long ProcessingStartTime
         {
             get { return processingStartTime; }
             set { processingStartTime = value; }
         }
-        
+
         internal long ProcessingTotalTime
         {
             get { return processingTotalTime; }
@@ -553,13 +553,13 @@ internal void InitializeFromCachedResult(BuildResult cachedResult)
         internal BuildResult GetBuildResult()
         {
             // Calculate the time spent on this build request
-            int totalTime  = 0;
+            int totalTime = 0;
             int engineTime = 0;
             int taskTimeMs = 0;
-            if ( startTime != 0 )
+            if (startTime != 0)
             {
-               TimeSpan totalTimeSpan = new TimeSpan(DateTime.Now.Ticks - startTime );
-               totalTime = (int)totalTimeSpan.TotalMilliseconds;
+                TimeSpan totalTimeSpan = new TimeSpan(DateTime.Now.Ticks - startTime);
+                totalTime = (int)totalTimeSpan.TotalMilliseconds;
             }
             if (processingTotalTime != 0)
             {
diff --git a/src/Deprecated/Engine/Engine/BuildResult.cs b/src/Deprecated/Engine/Engine/BuildResult.cs
index 05a39f10452..986a11a525b 100644
--- a/src/Deprecated/Engine/Engine/BuildResult.cs
+++ b/src/Deprecated/Engine/Engine/BuildResult.cs
@@ -25,8 +25,8 @@ internal BuildResult()
         /// </summary>
         internal BuildResult
         (
-            IDictionary outputsByTarget, Hashtable resultByTarget, bool evaluationResult, 
-            int handleId, int requestId, int projectId, bool useResultCache, 
+            IDictionary outputsByTarget, Hashtable resultByTarget, bool evaluationResult,
+            int handleId, int requestId, int projectId, bool useResultCache,
             string defaultTargets, string initialTargets,
             int totalTime, int engineTime, int taskTime
         )
@@ -36,7 +36,7 @@ internal BuildResult
             this.handleId = handleId;
             this.requestId = requestId;
             this.projectId = projectId;
-            this.flags = (byte)((evaluationResult ? 1 : 0 ) | (useResultCache ? 2 : 0));
+            this.flags = (byte)((evaluationResult ? 1 : 0) | (useResultCache ? 2 : 0));
             this.defaultTargets = defaultTargets;
             this.initialTargets = initialTargets;
             this.totalTime = totalTime;
@@ -86,7 +86,7 @@ internal BuildResult
                             itemArray[i] = new BuildItem(null, originalArray[i].FinalItemSpecEscaped);
                         }
                     }
-                    
+
                     this.outputsByTarget.Add(entry.Key, itemArray);
                 }
             }
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index 4d7552ed0fa..a13d2239fe2 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -30,7 +30,7 @@ public class BuildTask
         private XmlAttribute continueOnErrorAttribute = null;
 
         // The target to which this task belongs.
-        private Target parentTarget= null;
+        private Target parentTarget = null;
 
         // The name of the task.
         private string taskName = String.Empty;
@@ -59,9 +59,9 @@ public class BuildTask
         /// <owner>rgoel</owner>
         internal BuildTask
         (
-            XmlElement      taskElement,
-            Target          parentTarget,
-            bool            importedFromAnotherProject
+            XmlElement taskElement,
+            Target parentTarget,
+            bool importedFromAnotherProject
         )
         {
             // Make sure a valid node has been given to us.
@@ -495,11 +495,11 @@ private void MarkTaskAsDirty
             (
             )
         {
-               
-            
-                // This is a change to the contents of the target.
-                this.ParentTarget?.MarkTargetAsDirty();
-            
+
+
+            // This is a change to the contents of the target.
+            this.ParentTarget?.MarkTargetAsDirty();
+
         }
 
         #endregion
diff --git a/src/Deprecated/Engine/Engine/CacheManager.cs b/src/Deprecated/Engine/Engine/CacheManager.cs
index 472b3125dbb..d371fae3b3f 100644
--- a/src/Deprecated/Engine/Engine/CacheManager.cs
+++ b/src/Deprecated/Engine/Engine/CacheManager.cs
@@ -104,7 +104,7 @@ internal CacheScope GetCacheScope(string scopeName, BuildPropertyGroup scopeProp
                 lock (cacheManagerLock)
                 {
                     cacheScope = GetCacheScopeIfExists(scopeName, scopeProperties, scopeToolsVersion, cacheContentType);
-                    
+
                     if (cacheScope == null)
                     {
                         // If the list of scopes doesn't exist create it
diff --git a/src/Deprecated/Engine/Engine/CacheScope.cs b/src/Deprecated/Engine/Engine/CacheScope.cs
index ffec30b70b4..75a274d6bf8 100644
--- a/src/Deprecated/Engine/Engine/CacheScope.cs
+++ b/src/Deprecated/Engine/Engine/CacheScope.cs
@@ -34,8 +34,8 @@ internal CacheScope(string scopeName, BuildPropertyGroup scopeProperties, string
         {
             // Make certain we don't cache a reference to a Project object, which would defeat 
             // the purpose of this cache
-            scopeProperties.ClearParentProject(); 
-            
+            scopeProperties.ClearParentProject();
+
             this.scopeName = scopeName;
             this.scopeToolsVersion = scopeToolsVersion;
             this.scopeProperties = scopeProperties;
@@ -54,7 +54,7 @@ internal BuildPropertyGroup ScopeProperties
                 return this.scopeProperties;
             }
         }
-        
+
         /// <summary>
         /// Usually the project file name
         /// </summary>
@@ -157,7 +157,7 @@ internal CacheEntry GetCacheEntry(string name)
             {
                 return (CacheEntry)cacheContents[name];
             }
-            
+
             return null;
         }
 
@@ -242,15 +242,15 @@ internal void AddCacheEntryForBuildResults(BuildResult buildResult)
                     // If the project file is malformed the build may fail without initializing the initialtargets or
                     // the default targests fields. The retrieval code expects non-null values
                     // so it is necessary to replace null with empty string
-                    ErrorUtilities.VerifyThrow(!buildResult.EvaluationResult || (buildResult.InitialTargets != null 
-                                               && buildResult.DefaultTargets != null), 
+                    ErrorUtilities.VerifyThrow(!buildResult.EvaluationResult || (buildResult.InitialTargets != null
+                                               && buildResult.DefaultTargets != null),
                                                "Expect initial targets to be non-null for successful builds");
                     string defaultTargets = buildResult.DefaultTargets ?? String.Empty;
                     PropertyCacheEntry defaultTargetsCacheEntry = new PropertyCacheEntry(Constants.defaultTargetCacheName, defaultTargets);
                     AddCacheEntryInternal(defaultTargetsCacheEntry);
 
                     string initialTargets = buildResult.InitialTargets ?? String.Empty;
-                    PropertyCacheEntry initialTargetsCacheEntry = new PropertyCacheEntry(Constants.initialTargetCacheName, initialTargets );
+                    PropertyCacheEntry initialTargetsCacheEntry = new PropertyCacheEntry(Constants.initialTargetCacheName, initialTargets);
                     AddCacheEntryInternal(initialTargetsCacheEntry);
                 }
 
@@ -350,7 +350,7 @@ internal BuildResult GetCachedBuildResult(BuildRequest buildRequest, out ArrayLi
             ErrorUtilities.VerifyThrow(defaultTargetsCacheEntry != null && initialTargetsCacheEntry != null,
                 "We should have both the initial and default targets in the cache");
 
-            ArrayList targetsToBuild = new ArrayList(initialTargetsCacheEntry.Value.Split(new char[] {';'}, StringSplitOptions.RemoveEmptyEntries));
+            ArrayList targetsToBuild = new ArrayList(initialTargetsCacheEntry.Value.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries));
 
             if (buildRequest.TargetNames == null || buildRequest.TargetNames.Length == 0)
             {
@@ -413,8 +413,8 @@ internal BuildResult GetCachedBuildResult(BuildRequest buildRequest, out ArrayLi
 
             actuallyBuiltTargets = targetsToBuild;
 
-            return new BuildResult(outputsByTargetName, resultByTarget, overallSuccess, buildRequest.HandleId, buildRequest.RequestId, 
-                int.Parse(projectIdCacheEntry.Value, CultureInfo.InvariantCulture), false /* use results cache */, 
+            return new BuildResult(outputsByTargetName, resultByTarget, overallSuccess, buildRequest.HandleId, buildRequest.RequestId,
+                int.Parse(projectIdCacheEntry.Value, CultureInfo.InvariantCulture), false /* use results cache */,
                 defaultTargetsCacheEntry.Value, initialTargetsCacheEntry.Value, 0, 0, 0);
         }
 
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index 392f2f6f042..d786bf2b446 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -325,7 +325,7 @@ internal Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations
             // Get a list of properties which should be serialized
             if (!String.IsNullOrEmpty(forwardPropertiesFromChild))
             {
-                propertyListToSerialize = forwardPropertiesFromChild.Split(new char[]{';'}, StringSplitOptions.RemoveEmptyEntries);
+                propertyListToSerialize = forwardPropertiesFromChild.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
             }
         }
 
@@ -1134,7 +1134,7 @@ public void RegisterDistributedLogger(ILogger centralLogger, LoggerDescription f
                 localForwardingLogger.BuildEventRedirector = newRedirector;
                 localForwardingLogger.Parameters = forwardingLogger.LoggerSwitchParameters;
                 localForwardingLogger.Verbosity = forwardingLogger.Verbosity;
-                localForwardingLogger.NodeId= nodeId;
+                localForwardingLogger.NodeId = nodeId;
                 // Convert the path to the logger DLL to full path before passing it to the node provider
                 forwardingLogger.ConvertPathsToFullPaths();
             }
@@ -1374,7 +1374,7 @@ Project project
             UnloadProject(project, true /* Unload all versions */);
         }
 
-        internal void UnloadProject(Project project, bool unloadAllVersions )
+        internal void UnloadProject(Project project, bool unloadAllVersions)
         {
             if (project.FullFileName.Length > 0)
             {
@@ -1570,7 +1570,7 @@ public bool BuildProject
             IDictionary targetOutputs   // can be null if outputs are not needed
         )
         {
-          return BuildProject(project, targetNames, targetOutputs, BuildSettings.None);
+            return BuildProject(project, targetNames, targetOutputs, BuildSettings.None);
         }
 
         /// <summary>
@@ -1614,7 +1614,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
             BuildResult buildResult = null;
             bool continueExecution = true;
             lastLoopActivity = DateTime.Now.Ticks;
-            int loopTimeout= Introspector.initialLoopTimeout;   // Inactivity timeout which triggers deadlock check
+            int loopTimeout = Introspector.initialLoopTimeout;   // Inactivity timeout which triggers deadlock check
             int loopTimeoutRemaining = Introspector.initialLoopTimeout;
             int flushTimeout = EngineLoggingServices.flushTimeoutInMS; // Timeout with which the log is flushed
             bool forceFlush = false;
@@ -1796,7 +1796,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                     }
                 }
 
-                if (ExternalLoggingServices != null && ( ExternalLoggingServices.NeedsFlush(lastLoopActivity) || forceFlush ))
+                if (ExternalLoggingServices != null && (ExternalLoggingServices.NeedsFlush(lastLoopActivity) || forceFlush))
                 {
                     if (ExternalLoggingServices.ProcessPostedLoggingEvents())
                     {
@@ -1992,7 +1992,7 @@ private void SetBuildItemCurrentDirectory(Project project)
         /// </summary>
         private void BuildProjectInternalContinue(BuildRequest buildRequest, ProjectBuildState buildContext, TaskExecutionContext taskExecutionContext, Project project)
         {
-            if (buildRequest != null && ProfileBuild )
+            if (buildRequest != null && ProfileBuild)
             {
                 buildRequest.ProcessingStartTime = DateTime.Now.Ticks;
             }
@@ -2115,7 +2115,7 @@ public bool BuildProjectFile
             string targetName
             )
         {
-            return this.BuildProjectFile(projectFile, new string[] {targetName}, this.GlobalProperties,
+            return this.BuildProjectFile(projectFile, new string[] { targetName }, this.GlobalProperties,
                 null, BuildSettings.None);
         }
 
@@ -2239,7 +2239,7 @@ string toolsVersion
             return PostProjectEvaluationRequests
                 (null, new string[] { projectFile }, new string[][] { targetNames },
                  new BuildPropertyGroup[] { globalProperties }, new IDictionary[] { targetOutputs }, buildFlags,
-                 new string[] {toolsVersion});
+                 new string[] { toolsVersion });
         }
 
         /// <summary>
@@ -2261,7 +2261,7 @@ public bool BuildProjectFiles
             BuildPropertyGroup[] globalPropertiesPerProject,
             IDictionary[] targetOutputsPerProject,
             BuildSettings buildFlags,
-            string [] toolsVersions
+            string[] toolsVersions
         )
         {
             // Verify the arguments to the API
@@ -2274,7 +2274,7 @@ string [] toolsVersions
             // Verify the entries in the project file array
             for (int i = 0; i < projectFiles.Length; i++)
             {
-                error.VerifyThrowArgumentNull(projectFiles[i], "projectFiles[" + i +"]");
+                error.VerifyThrowArgumentNull(projectFiles[i], "projectFiles[" + i + "]");
                 error.VerifyThrowArgument(projectFiles[i].Length > 0, "projectFilesEmptyElement", i);
             }
 
@@ -2291,7 +2291,7 @@ internal bool PostProjectEvaluationRequests
             BuildPropertyGroup[] globalPropertiesPerProject,
             IDictionary[] targetOutputsPerProject,
             BuildSettings buildFlags,
-            string [] toolVersions
+            string[] toolVersions
         )
         {
             string currentDirectory = Environment.CurrentDirectory;
@@ -2432,7 +2432,7 @@ private BuildRequest CreateLocalBuildRequest(BuildEventContext buildEventContext
                 globalProperties = new BuildPropertyGroup();
             }
 
-            BuildRequest buildRequest =  new BuildRequest(EngineCallback.invalidEngineHandle, projectFile, targetNames, globalProperties, toolsVersion, -1, true, false);
+            BuildRequest buildRequest = new BuildRequest(EngineCallback.invalidEngineHandle, projectFile, targetNames, globalProperties, toolsVersion, -1, true, false);
             buildRequest.ParentBuildEventContext = buildEventContext;
             // Set the project object to the passed in project
             buildRequest.ProjectToBuild = project;
@@ -2608,7 +2608,7 @@ BuildRequest buildRequest
                         {
                             IncrementProjectsInProgress();
                         }
-                       Router.PostBuildRequest(buildRequest, evaluationNode);
+                        Router.PostBuildRequest(buildRequest, evaluationNode);
                     }
                 }
             }
@@ -2712,7 +2712,7 @@ internal Project GetMatchingProject
             string projectFullPath,
             BuildPropertyGroup globalPropertiesToUse,
             string toolsVersion,
-            string [] targetNames,
+            string[] targetNames,
             BuildEventContext buildEventContext,
             bool toolsVersionPeekedFromProjectFile
             )
@@ -2725,7 +2725,7 @@ bool toolsVersionPeekedFromProjectFile
             // and load the contents from the project file.
             if (returnProject == null)
             {
-                #if DEBUG
+#if DEBUG
                 if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDASSERTONLOADMULTIPLECOPIESOFPROJECT")))
                 {
                     if (this.projectsLoadedByHost.Contains(projectFullPath))
@@ -2766,7 +2766,7 @@ bool toolsVersionPeekedFromProjectFile
                         }
                     }
                 }
-                #endif
+#endif
 
                 // Check if the project has been previously unloaded due to a user request during the current build
                 // In this case reloaded a project is an error because we can't ensure a consistent state of the reloaded project
@@ -2802,7 +2802,7 @@ bool toolsVersionPeekedFromProjectFile
                     string errorCode;
                     string helpKeyword;
                     string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "UnrecognizedToolsVersion", toolsVersion);
-                    throw new InvalidProjectFileException(projectFullPath,fileInfo.Line,fileInfo.Column,fileInfo.EndLine, fileInfo.EndColumn,message, null, errorCode,helpKeyword);
+                    throw new InvalidProjectFileException(projectFullPath, fileInfo.Line, fileInfo.Column, fileInfo.EndLine, fileInfo.EndColumn, message, null, errorCode, helpKeyword);
                 }
 
                 // We're only building this project ... it is not loaded by a host, and we
@@ -2899,7 +2899,7 @@ IDictionary globalPropertiesPassedIntoTask
                 string childProjectFullPath = Path.GetFullPath(childProjectFile);
 
                 // Find out if there's a project already loaded with the same full path.
-                Project loadedProjectWithSameFullPath = (Project) this.projectsLoadedByHost[childProjectFullPath];
+                Project loadedProjectWithSameFullPath = (Project)this.projectsLoadedByHost[childProjectFullPath];
 
                 // Then ... if there is a loaded project with the same full path, merge in its global properties.
                 // This way, we honor whatever settings the IDE has requested for this project (e.g. Configuration=Release, or whatever).
@@ -2914,8 +2914,8 @@ IDictionary globalPropertiesPassedIntoTask
             {
                 foreach (DictionaryEntry newGlobalProperty in globalPropertiesPassedIntoTask)
                 {
-                    finalGlobalProperties.SetProperty((string) newGlobalProperty.Key,
-                        (string) newGlobalProperty.Value);
+                    finalGlobalProperties.SetProperty((string)newGlobalProperty.Key,
+                        (string)newGlobalProperty.Value);
                 }
             }
 
@@ -2963,9 +2963,9 @@ internal TaskExecutionContext GetTaskOutputUpdates()
         internal NodeStatus RequestStatus(int requestId)
         {
             // Find out the list of the inprogress waiting targets
-            List<BuildRequest []> outstandingRequests = new List<BuildRequest []>();
-            int [] handleIds = NodeManager.TaskExecutionModule.GetWaitingTaskData(outstandingRequests);
-            Target [] waitingTargets = EngineCallback.GetListOfTargets(handleIds);
+            List<BuildRequest[]> outstandingRequests = new List<BuildRequest[]>();
+            int[] handleIds = NodeManager.TaskExecutionModule.GetWaitingTaskData(outstandingRequests);
+            Target[] waitingTargets = EngineCallback.GetListOfTargets(handleIds);
 
             // Find out the list of targets waiting due to dependency or onerror call but not actively in progress
             List<Project> inProgressProject = cacheOfBuildingProjects.GetInProgressProjects();
diff --git a/src/Deprecated/Engine/Engine/EngineCallback.cs b/src/Deprecated/Engine/Engine/EngineCallback.cs
index f63605391cc..847dbd1cbfb 100644
--- a/src/Deprecated/Engine/Engine/EngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/EngineCallback.cs
@@ -42,7 +42,7 @@ public void PostBuildRequestsToHost(BuildRequest[] buildRequests)
             {
                 // We can safely assume that all requests need to be routed to the same engine because
                 // they originated from the same task 
-                for(int i = 0; i < buildRequests.Length; i++)
+                for (int i = 0; i < buildRequests.Length; i++)
                 {
                     ProcessBuildRequest(buildRequests[i]);
                 }
@@ -491,7 +491,7 @@ internal RequestRoutingContext GetRoutingContextFromHandleId(int handleId)
         internal int CreateTaskContext
         (
             Project parentProject,
-            Target  parentTarget,
+            Target parentTarget,
             ProjectBuildState buildContext,
             XmlElement taskNode,
             int nodeIndex,
@@ -594,7 +594,7 @@ internal void ClearContextState(int handleId)
         /// <summary>
         /// List of contexts that should be removed from the hashtable by the engine thread
         /// </summary>
-        private List<ExecutionContext> freedContexts = new List<ExecutionContext>(2*freeListThreshold);
+        private List<ExecutionContext> freedContexts = new List<ExecutionContext>(2 * freeListThreshold);
         /// <summary>
         /// The counter used to generate unique identifiers for each context
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/EngineCommand.cs b/src/Deprecated/Engine/Engine/EngineCommand.cs
index 64b56703376..89461560a41 100644
--- a/src/Deprecated/Engine/Engine/EngineCommand.cs
+++ b/src/Deprecated/Engine/Engine/EngineCommand.cs
@@ -91,7 +91,7 @@ internal override void Execute(Engine parentEngine)
     }
     #endregion
 
-   #region ChangeTraversalType
+    #region ChangeTraversalType
     /// <summary>
     /// Wrapper class for a changing the traversal approach used by the TEM
     /// </summary>
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index ddb77d194ba..f6ac20d5963 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -33,7 +33,7 @@ internal abstract class EngineLoggingServices
         protected void Initialize(ManualResetEvent flushRequestEventIn)
         {
             this.loggingQueueOfBuildEvents = new DualQueue<BuildEventArgs>();
-            this.loggingQueueOfNodeEvents  = new DualQueue<NodeLoggingEvent>();
+            this.loggingQueueOfNodeEvents = new DualQueue<NodeLoggingEvent>();
             this.lastFlushTime = DateTime.Now.Ticks;
             this.flushRequestEvent = flushRequestEventIn;
             this.requestedQueueFlush = false;
@@ -185,7 +185,7 @@ internal void PostLoggingEvents(NodeLoggingEvent[] eventArray)
         /// implementation, this will send the events from the node process to the engine.
         /// </summary>
         internal abstract bool ProcessPostedLoggingEvents();
-        
+
         /// <summary>
         /// This method is to process a single build event, by default if this method is used
         /// the event should be posted and processed
@@ -196,7 +196,7 @@ internal virtual void ProcessBuildEvent(BuildEventArgs buildEventArgs)
             PostLoggingEvent(buildEventArgs);
             ProcessPostedLoggingEvents();
         }
-        
+
         /// <summary>
         /// Return true if the queue needs to be flushed
         /// </summary>
@@ -338,7 +338,7 @@ internal virtual void LogComment(BuildEventContext buildEventContext, MessageImp
         /// <summary>
         /// Logs a custom-priority comment with all registered loggers using the given text.
         /// </summary>
-        internal virtual void LogCommentFromText(BuildEventContext buildEventContext,MessageImportance importance, string message)
+        internal virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message)
         {
             if (!OnlyLogCriticalEvents)
             {
@@ -513,9 +513,9 @@ internal virtual void LogFatalError(BuildEventContext buildEventContext, Excepti
             string errorCode;
             string helpKeyword;
             string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, messageResourceName, messageArgs);
-            #if DEBUG
+#if DEBUG
             message += Environment.NewLine + "This is an unhandled exception -- PLEASE OPEN A BUG.";
-            #endif
+#endif
             if (exception != null)
             {
                 message += Environment.NewLine + exception.ToString();
@@ -550,9 +550,9 @@ internal virtual void LogTaskWarningFromException(BuildEventContext buildEventCo
             string warningCode;
             string helpKeyword;
             string message = ResourceUtilities.FormatResourceString(out warningCode, out helpKeyword, "FatalTaskError", taskName);
-            #if DEBUG
+#if DEBUG
             message += Environment.NewLine + "This is an unhandled exception -- PLEASE OPEN A BUG.";
-            #endif
+#endif
 
             if (exception != null)
             {
@@ -569,9 +569,9 @@ internal virtual void LogTaskWarningFromException(BuildEventContext buildEventCo
         /// <param name="file"></param>
         /// <param name="messageResourceName"></param>
         /// <param name="messageArgs"></param>
-         internal virtual void LogWarning(BuildEventContext buildEventContext, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
+        internal virtual void LogWarning(BuildEventContext buildEventContext, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            LogWarning(buildEventContext,null, file, messageResourceName, messageArgs);
+            LogWarning(buildEventContext, null, file, messageResourceName, messageArgs);
         }
 
         /// <summary>
@@ -739,7 +739,7 @@ internal virtual void LogProjectStarted(int projectId, BuildEventContext parentB
             if (!OnlyLogCriticalEvents)
             {
                 ProjectStartedEventArgs e;
-              
+
                 if (!string.IsNullOrEmpty(targetNames))
                 {
                     e = new ProjectStartedEventArgs
@@ -768,7 +768,7 @@ internal virtual void LogProjectStarted(int projectId, BuildEventContext parentB
                             parentBuildEventContext
                         );
                 }
- 
+
                 e.BuildEventContext = projectBuildEventContext;
 
                 PostLoggingEvent(e);
@@ -1010,7 +1010,7 @@ internal bool FlushBuildEventsImmediatly
         protected ManualResetEvent flushRequestEvent;
 
         internal const int flushTimeoutInMS = 500;          // flush the queue at least every 1/2 second
-        internal const int flushTimeoutInTicks = 500*10000; // flush the queue at least every 1/2 second
+        internal const int flushTimeoutInTicks = 500 * 10000; // flush the queue at least every 1/2 second
         internal const int flushQueueSize = 1000;            // flush the queue every time 1000 events accumulate
 
         #endregion
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
index db90dd74a2a..8800ec38037 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
@@ -83,7 +83,7 @@ internal override bool ProcessPostedLoggingEvents()
                 // If there are event - post them to the parent
                 if (current != 0)
                 {
-                    NodeLoggingEvent [] trimmedEventArray = new NodeLoggingEvent[current];
+                    NodeLoggingEvent[] trimmedEventArray = new NodeLoggingEvent[current];
                     Array.Copy(eventArray, trimmedEventArray, current);
                     parentNode.PostLoggingMessagesToHost(trimmedEventArray);
                     current = 0;
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index afc4259b5be..d56b61119b5 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -157,7 +157,7 @@ public void LogErrorEvent(BuildErrorEventArgs e)
                 // but wants to ignore the failures.  This implies that we shouldn't be logging
                 // errors either, because you should never have a successful build with errors.
                 BuildWarningEventArgs warningEvent = new BuildWarningEventArgs
-                        (   e.Subcategory,
+                        (e.Subcategory,
                             e.Code,
                             e.File,
                             e.LineNumber,
@@ -172,7 +172,7 @@ public void LogErrorEvent(BuildErrorEventArgs e)
                 loggingServices.LogWarningEvent(warningEvent);
 
                 // Log a message explaining why we converted the previous error into a warning.
-                loggingServices.LogComment(buildEventContext,MessageImportance.Normal, "ErrorConvertedIntoWarning");
+                loggingServices.LogComment(buildEventContext, MessageImportance.Normal, "ErrorConvertedIntoWarning");
             }
             else
             {
@@ -291,7 +291,7 @@ public void LogMessageEvent(BuildMessageEventArgs e)
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
                 loggingServices.LogWarning(buildEventContext, new BuildEventFileInfo(string.Empty), "ExpectedEventToBeSerializable", e.GetType().Name);
-                    return;
+                return;
             }
             e.BuildEventContext = buildEventContext;
             loggingServices.LogMessageEvent(e);
@@ -308,7 +308,7 @@ public void LogCustomEvent(CustomBuildEventArgs e)
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
                 loggingServices.LogWarning(buildEventContext, new BuildEventFileInfo(string.Empty), "ExpectedEventToBeSerializable", e.GetType().Name);
-                    return;
+                return;
             }
 
             e.BuildEventContext = buildEventContext;
@@ -483,16 +483,16 @@ bool unloadProjectsOnCompletion
         /// <summary>
         /// Not implemented for the proxy
         /// </summary>
-	public void Yield()
-	{
-	}
+        public void Yield()
+        {
+        }
 
         /// <summary>
         /// Not implemented for the proxy
         /// </summary>
-	public void Reacquire()
-	{
-	}
+        public void Reacquire()
+        {
+        }
 
         /// <summary>
         /// Stub implementation -- forwards to engine being proxied.
@@ -515,7 +515,7 @@ public BuildEngineResult BuildProjectFilesInParallel
             (
             string[] projectFileNames,
             string[] targetNames,
-            IDictionary [] globalProperties,
+            IDictionary[] globalProperties,
             IList<string>[] removeGlobalProperties,
             string[] toolsVersions,
             bool returnTargetOutputs
@@ -567,9 +567,9 @@ public override object InitializeLifetimeService()
             if (!String.IsNullOrEmpty(initialLeaseTimeFromEnvironment))
             {
                 int leaseTimeFromEnvironment;
-                if (int.TryParse(initialLeaseTimeFromEnvironment , out leaseTimeFromEnvironment) && leaseTimeFromEnvironment > 0)
+                if (int.TryParse(initialLeaseTimeFromEnvironment, out leaseTimeFromEnvironment) && leaseTimeFromEnvironment > 0)
                 {
-                      initialLeaseTime = leaseTimeFromEnvironment;
+                    initialLeaseTime = leaseTimeFromEnvironment;
                 }
             }
 
@@ -587,9 +587,9 @@ public override object InitializeLifetimeService()
             if (!String.IsNullOrEmpty(leaseExtensionTimeFromEnvironment))
             {
                 int leaseExtensionFromEnvironment;
-                if (int.TryParse(leaseExtensionTimeFromEnvironment , out leaseExtensionFromEnvironment) && leaseExtensionFromEnvironment > 0)
+                if (int.TryParse(leaseExtensionTimeFromEnvironment, out leaseExtensionFromEnvironment) && leaseExtensionFromEnvironment > 0)
                 {
-                      leaseExtensionTime = leaseExtensionFromEnvironment;
+                    leaseExtensionTime = leaseExtensionFromEnvironment;
                 }
             }
 
diff --git a/src/Deprecated/Engine/Engine/EventSource.cs b/src/Deprecated/Engine/Engine/EventSource.cs
index b44d10aa901..29fdf230b71 100644
--- a/src/Deprecated/Engine/Engine/EventSource.cs
+++ b/src/Deprecated/Engine/Engine/EventSource.cs
@@ -584,7 +584,7 @@ internal void RaiseStronglyTypedEvent(BuildEventArgs e)
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event BuildErrorEventHandler ErrorRaised;
-        
+
         /// <summary>
         /// This event is raised to log a warning.
         /// </summary>
@@ -602,43 +602,43 @@ internal void RaiseStronglyTypedEvent(BuildEventArgs e)
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event BuildFinishedEventHandler BuildFinished;
-        
+
         /// <summary>
         /// this event is raised to log the start of a project build
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event ProjectStartedEventHandler ProjectStarted;
-        
+
         /// <summary>
         /// this event is raised to log the end of a project build
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event ProjectFinishedEventHandler ProjectFinished;
-        
+
         /// <summary>
         /// this event is raised to log the start of a target build
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event TargetStartedEventHandler TargetStarted;
-        
+
         /// <summary>
         /// this event is raised to log the end of a target build
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event TargetFinishedEventHandler TargetFinished;
-        
+
         /// <summary>
         /// this event is raised to log the start of task execution
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event TaskStartedEventHandler TaskStarted;
-        
+
         /// <summary>
         /// this event is raised to log the end of task execution
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
-        public event TaskFinishedEventHandler TaskFinished; 
-        
+        public event TaskFinishedEventHandler TaskFinished;
+
         /// <summary>
         /// this event is raised to log a custom event
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/ExecutionContext.cs b/src/Deprecated/Engine/Engine/ExecutionContext.cs
index d6fbbbf9a4c..7108b877cb4 100644
--- a/src/Deprecated/Engine/Engine/ExecutionContext.cs
+++ b/src/Deprecated/Engine/Engine/ExecutionContext.cs
@@ -17,7 +17,7 @@ internal class ExecutionContext
         /// </summary>
         internal ExecutionContext(int handleId, int nodeIndex, BuildEventContext buildEventContext)
         {
-            this.handleId  = handleId;
+            this.handleId = handleId;
             this.nodeIndex = nodeIndex;
             this.buildEventContext = buildEventContext;
         }
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index b1d2655ddb3..10c23c795e0 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -122,7 +122,7 @@ internal Expander(Expander expander, ExpanderOptions options)
         }
 
         internal Expander(Expander expander, SpecificItemDefinitionLibrary itemDefinitionLibrary)
-            : this(expander.lookup, null , expander.options)
+            : this(expander.lookup, null, expander.options)
         {
             if (implicitMetadataItemType == null)
             {
@@ -131,7 +131,7 @@ internal Expander(Expander expander, SpecificItemDefinitionLibrary itemDefinitio
             this.specificItemDefinitionLibrary = itemDefinitionLibrary;
         }
 
-#endregion
+        #endregion
 
         /// <summary>
         /// Adds metadata to the table being used by this expander.
@@ -704,7 +704,7 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
 
             return (nestLevel == 0) ? index : -1;
         }
-        
+
         /// <summary>
         /// Expand the body of the property, including any functions that it may contain
         /// </summary>
@@ -871,7 +871,7 @@ private static bool IsValidPropertyName(string propertyName)
         private string ExpandRegistryValue(string registryExpression, XmlNode node)
         {
             string registryLocation = registryExpression.Substring(9);
-            
+
             // Split off the value name -- the part after the "@" sign. If there's no "@" sign, then it's the default value name
             // we want.
             int firstAtSignOffset = registryLocation.IndexOf('@');
@@ -879,9 +879,9 @@ private string ExpandRegistryValue(string registryExpression, XmlNode node)
 
             ProjectErrorUtilities.VerifyThrowInvalidProject(firstAtSignOffset == lastAtSignOffset, node, "InvalidRegistryPropertyExpression", "$(" + registryExpression + ")", String.Empty);
 
-            string valueName = lastAtSignOffset == -1 || lastAtSignOffset == registryLocation.Length - 1 
+            string valueName = lastAtSignOffset == -1 || lastAtSignOffset == registryLocation.Length - 1
                 ? null : registryLocation.Substring(lastAtSignOffset + 1);
-            
+
             // If there's no '@', or '@' is first, then we'll use null or String.Empty for the location; otherwise
             // the location is the part before the '@'
             string registryKeyName = lastAtSignOffset != -1 ? registryLocation.Substring(0, lastAtSignOffset) : registryLocation;
@@ -1231,7 +1231,7 @@ public object Execute(Expander expander, object objectInstance, BuildPropertyGro
                     {
                         functionResult = EscapingUtilities.Escape((string)functionResult);
                     }
-                    
+
                     // There's nothing left to deal within the function expression, return the result from the execution
                     if (String.IsNullOrEmpty(remainder))
                     {
@@ -1474,7 +1474,7 @@ private static Type GetTypeFromAssembly(string typeName, string candidateAssembl
 
                 return objectType;
             }
-            
+
             /// <summary>
             /// Factory method to construct a function for property evaluation
             /// </summary>
@@ -1584,7 +1584,7 @@ private static Function ConstructFunction(string expressionFunction, string expr
             private static string[] ExtractFunctionArguments(string expressionFunction, string argumentsContent)
             {
                 List<string> arguments = new List<string>();
-                StringBuilder argumentBuilder = new StringBuilder(argumentsContent.Length); 
+                StringBuilder argumentBuilder = new StringBuilder(argumentsContent.Length);
 
                 // Iterate over the contents of the arguments extracting the
                 // the individual arguments as we go
@@ -1945,7 +1945,7 @@ private string ExpandSingleMetadata(Match itemMetadataMatch)
             {
                 metadataValue = GetDefaultMetadataValue(itemType, metadataName, metadataValue);
             }
-            
+
             return metadataValue ?? String.Empty;
         }
 
diff --git a/src/Deprecated/Engine/Engine/Import.cs b/src/Deprecated/Engine/Engine/Import.cs
index ba22f096800..246c55df3c4 100644
--- a/src/Deprecated/Engine/Engine/Import.cs
+++ b/src/Deprecated/Engine/Engine/Import.cs
@@ -55,9 +55,9 @@ public bool IsImported
         /// <owner>LukaszG</owner>
         public string ProjectPath
         {
-            get 
-            { 
-                return this.projectPathAttribute?.Value; 
+            get
+            {
+                return this.projectPathAttribute?.Value;
             }
             set
             {
@@ -94,9 +94,9 @@ public string EvaluatedProjectPath
         /// <owner>LukaszG</owner>
         public string Condition
         {
-            get 
-            { 
-                return this.conditionAttribute?.Value; 
+            get
+            {
+                return this.conditionAttribute?.Value;
             }
             set
             {
@@ -136,11 +136,11 @@ internal Import(XmlElement importElement, Project parentProject, bool isImported
                 "Need an XML node representing the <Import> element.");
 
             this.importElement = importElement;
-            
+
             // Make sure we have a valid parent Project
             ErrorUtilities.VerifyThrow(parentProject != null,
                 "Need a parent Project object to instantiate an Import.");
-            
+
             this.parentProject = parentProject;
 
             // Make sure this really is the <Import> node.
diff --git a/src/Deprecated/Engine/Engine/ImportCollection.cs b/src/Deprecated/Engine/Engine/ImportCollection.cs
index e67db1d68c2..08fe58aeba4 100644
--- a/src/Deprecated/Engine/Engine/ImportCollection.cs
+++ b/src/Deprecated/Engine/Engine/ImportCollection.cs
@@ -112,7 +112,7 @@ public object SyncRoot
         #endregion
 
         #region Members
-        
+
         /// <summary>
         /// Read-only accessor for the Project instance that this ImportCollection belongs to.
         /// </summary>
@@ -173,7 +173,7 @@ public void AddNewImport(string projectFile, string condition)
 
             XmlElement projectElement = this.parentProject.ProjectElement;
             XmlElement newImportElement = projectElement.OwnerDocument.CreateElement(XMakeElements.import, XMakeAttributes.defaultXmlNamespace);
-            
+
             if (condition != null)
             {
                 newImportElement.SetAttribute(XMakeAttributes.condition, condition);
@@ -211,7 +211,7 @@ Import importToRemove
 
             // Remove the import from our hashtable.
             this.imports.Remove(importToRemove.EvaluatedProjectPath);
-            
+
             // Dissociate the import from the parent project.
             importToRemove.ParentProject = null;
 
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index 4cc32723604..6536a6dbfee 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -239,7 +239,7 @@ internal static string MakeRelative(string basePath, string path)
 
             return result;
         }
-        
+
         /// <summary>
         /// Locate a file in either the directory specified or a location in the
         /// direcorty structure above that directory.
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index da393b51c0c..ba8aeb744bb 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -110,7 +110,7 @@ internal void PostBuildRequestToHost(BuildRequest currentRequest)
             // Add the request to the mapping hashtable so that we can recognize the outputs
             CacheScope cacheScope = localEngine.CacheManager.GetCacheScope(currentRequest.ProjectFileName, currentRequest.GlobalProperties, currentRequest.ToolsetVersion, CacheContentType.BuildResults);
             NodeRequestMapping nodeRequestMapping =
-                new NodeRequestMapping(currentRequest.HandleId, currentRequest.RequestId, cacheScope );
+                new NodeRequestMapping(currentRequest.HandleId, currentRequest.RequestId, cacheScope);
             lock (requestToLocalIdMapping)
             {
                 requestToLocalIdMapping.Add(lastRequestIdUsed, nodeRequestMapping);
@@ -317,7 +317,7 @@ internal void PostBuildResult(BuildResult buildResult)
         internal void ShutdownNode(NodeShutdownLevel shutdownLevel)
         {
             if (shutdownLevel == NodeShutdownLevel.BuildCompleteSuccess ||
-                shutdownLevel == NodeShutdownLevel.BuildCompleteFailure )
+                shutdownLevel == NodeShutdownLevel.BuildCompleteFailure)
             {
                 if (Engine.debugMode)
                 {
@@ -381,7 +381,7 @@ bool useBreadthFirstTraversal
             if (localEngine != null)
             {
                 localEngine.LoggingServices.OnlyLogCriticalEvents = this.logOnlyCriticalEvents;
-                localEngine.PostEngineCommand( new ChangeTraversalTypeCommand( useBreadthFirstTraversal, true ));
+                localEngine.PostEngineCommand(new ChangeTraversalTypeCommand(useBreadthFirstTraversal, true));
             }
         }
 
diff --git a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
index 1702e79a0a2..40d65020aad 100644
--- a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
+++ b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
@@ -46,7 +46,7 @@ internal NodeLoggingEvent()
         /// </summary>
         internal NodeLoggingEvent(BuildEventArgs eventToLog)
         {
-           this.e = eventToLog;
+            this.e = eventToLog;
         }
         #endregion
 
@@ -156,7 +156,7 @@ private BuildEventArgs GetBuildEventArgFromId(LoggingEventType id)
                 case LoggingEventType.BuildStartedEvent:
                     return new BuildStartedEventArgs(null, null);
                 case LoggingEventType.BuildWarningEvent:
-                    return new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1,null,null,null);
+                    return new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
                 case LoggingEventType.ProjectFinishedEvent:
                     return new ProjectFinishedEventArgs(null, null, null, false);
                 case LoggingEventType.ProjectStartedEvent:
@@ -249,24 +249,24 @@ internal virtual void CreateFromStream(BinaryReader reader, Hashtable loggingTyp
                         customEventsLoaded.Add(fileLocation, null);
                     }
                 }
+                if (resolveAssembly)
+                {
+                    resolver = new TaskEngineAssemblyResolver();
+                    resolver.InstallHandler();
+                    resolver.Initialize(fileLocation);
+                }
+                try
+                {
+                    e = (BuildEventArgs)binaryFormatter.Deserialize(reader.BaseStream);
+                }
+                finally
+                {
                     if (resolveAssembly)
                     {
-                        resolver = new TaskEngineAssemblyResolver();
-                        resolver.InstallHandler();
-                        resolver.Initialize(fileLocation);
-                    }
-                    try
-                    {
-                        e = (BuildEventArgs)binaryFormatter.Deserialize(reader.BaseStream);
-                    }
-                    finally
-                    {
-                        if (resolveAssembly)
-                        {
-                            resolver.RemoveHandler();
-                            resolver = null;
-                        }
+                        resolver.RemoveHandler();
+                        resolver = null;
                     }
+                }
             }
         }
         #endregion
@@ -297,7 +297,7 @@ internal NodeLoggingEventWithLoggerId()
         /// Create a wrapper for a given event associated with a particular loggerId
         /// </summary>
         internal NodeLoggingEventWithLoggerId(BuildEventArgs eventToLog, int loggerId)
-            :base(eventToLog)
+            : base(eventToLog)
         {
             this.loggerId = loggerId;
         }
diff --git a/src/Deprecated/Engine/Engine/NodeManager.cs b/src/Deprecated/Engine/Engine/NodeManager.cs
index c963d35e73c..142a5877e19 100644
--- a/src/Deprecated/Engine/Engine/NodeManager.cs
+++ b/src/Deprecated/Engine/Engine/NodeManager.cs
@@ -60,9 +60,9 @@ internal bool RegisterNodeProvider(INodeProvider nodeProviderToRegister)
             nodeProviderToRegister.AssignNodeIdentifiers(nodeIds);
 
             // Go through all of the nodes as described by nodeDescriptions and add them to out list of nodes
-            for(int i=0; i < nodeDescriptions.Length;i++)
+            for (int i = 0; i < nodeDescriptions.Length; i++)
             {
-                ProvidersNodeInformation nodeToAddFromProvider = 
+                ProvidersNodeInformation nodeToAddFromProvider =
                     new ProvidersNodeInformation(i, nodeIds[i], nodeDescriptions[i], nodeProviderToRegister);
                 nodeList.Add(nodeToAddFromProvider);
             }
@@ -79,16 +79,16 @@ internal bool RegisterNodeProvider(INodeProvider nodeProviderToRegister)
         /// <returns></returns>
         internal INodeDescription[] GetNodeDescriptions()
         {
-          // The number of node descriptions is the number of nodes from all of the node providers, plus one for the default "0" node
-          INodeDescription[] nodeDescription = new INodeDescription[nodeList.Count+1];
-          nodeDescription[0] = null;
-          for (int nodeListIndex = 0; nodeListIndex < nodeList.Count; nodeListIndex++)
-          {
-              ProvidersNodeInformation nodeInfo = nodeList[nodeListIndex];
-              // +1 because the node description already has the 0 element set to null
-              nodeDescription[nodeListIndex + 1] = nodeInfo.Description;
-          }
-          return nodeDescription;
+            // The number of node descriptions is the number of nodes from all of the node providers, plus one for the default "0" node
+            INodeDescription[] nodeDescription = new INodeDescription[nodeList.Count + 1];
+            nodeDescription[0] = null;
+            for (int nodeListIndex = 0; nodeListIndex < nodeList.Count; nodeListIndex++)
+            {
+                ProvidersNodeInformation nodeInfo = nodeList[nodeListIndex];
+                // +1 because the node description already has the 0 element set to null
+                nodeDescription[nodeListIndex + 1] = nodeInfo.Description;
+            }
+            return nodeDescription;
         }
 
         /// <summary>
@@ -153,7 +153,7 @@ internal NodeStatus[] RequestStatusForNodes(int responseTimeout)
 
         internal void PostNodeStatus(int nodeId, NodeStatus nodeStatus)
         {
-            ErrorUtilities.VerifyThrow( nodeStatus.RequestId != NodeStatus.UnrequestedStatus,
+            ErrorUtilities.VerifyThrow(nodeStatus.RequestId != NodeStatus.UnrequestedStatus,
                                         "Node manager should not receive unrequested status");
 
             NodeStatus[] currentStatus = statusForNodes;
@@ -173,8 +173,8 @@ internal void PostNodeStatus(int nodeId, NodeStatus nodeStatus)
 
         internal void PostCycleNotification
         (
-            int nodeId, 
-            TargetInProgessState child, 
+            int nodeId,
+            TargetInProgessState child,
             TargetInProgessState parent)
         {
             if (nodeId == 0)
@@ -232,7 +232,7 @@ internal void PostBuildResultToNode(int nodeIndex, BuildResult buildResult)
             ErrorUtilities.VerifyThrow(nodeIndex <= nodeList.Count, "Should not pass a node index higher then the number of nodes in nodeManager");
             if (nodeIndex != 0)
             {
-                nodeList[nodeIndex-1].NodeProvider.PostBuildResultToNode(nodeList[nodeIndex-1].NodeIndex, buildResult);
+                nodeList[nodeIndex - 1].NodeProvider.PostBuildResultToNode(nodeList[nodeIndex - 1].NodeIndex, buildResult);
             }
             else
             {
@@ -265,7 +265,7 @@ internal void ExecuteTask(TaskExecutionState taskState)
         /// </summary>
         internal void UpdateSettings
         (
-            bool enableOutofProcLogging, 
+            bool enableOutofProcLogging,
             bool enableOnlyLogCriticalEvents,
             bool useBreadthFirstTraversal
         )
@@ -284,11 +284,11 @@ internal void ChangeNodeTraversalType(bool breadthFirstTraversal)
         #endregion
 
         #region Properties
-        
+
         /// <summary>
         /// Getter access to the local node
         /// </summary>
-        internal  TaskExecutionModule TaskExecutionModule
+        internal TaskExecutionModule TaskExecutionModule
         {
             get
             {
@@ -299,7 +299,7 @@ internal  TaskExecutionModule TaskExecutionModule
                 taskExecutionModule = value;
             }
         }
-        
+
         /// <summary>
         /// Number of Nodes being managed by NodeManager
         /// </summary>
@@ -308,7 +308,7 @@ internal int MaxNodeCount
             get
             {
                 // add 1 for the local node (taskExecutionModule)
-                return nodeList.Count+1;
+                return nodeList.Count + 1;
             }
         }
         #endregion
diff --git a/src/Deprecated/Engine/Engine/NodeRequestMapping.cs b/src/Deprecated/Engine/Engine/NodeRequestMapping.cs
index f72938b9b08..db86a1b445f 100644
--- a/src/Deprecated/Engine/Engine/NodeRequestMapping.cs
+++ b/src/Deprecated/Engine/Engine/NodeRequestMapping.cs
@@ -14,7 +14,7 @@ internal class NodeRequestMapping
         #region Constructors
 
         internal NodeRequestMapping
-            (int handleId, int requestId, CacheScope resultsCache )
+            (int handleId, int requestId, CacheScope resultsCache)
         {
             ErrorUtilities.VerifyThrow(resultsCache != null, "Expect a non-null build result");
             this.handleId = handleId;
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 8be5f2364a0..31b80233308 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -69,10 +69,10 @@ public class Project
         #region Member Data
 
         // The parent Engine object for this project.
-        private Engine                      parentEngine;
+        private Engine parentEngine;
 
         // Event location contextual information for the current project instance
-        private BuildEventContext                projectBuildEventContext;
+        private BuildEventContext projectBuildEventContext;
 
         // We need to know if the projectContextId which was generated during the
         // instantiation of the project instance has been used. If the Id has been used,
@@ -85,77 +85,77 @@ public class Project
         private int projectId;
 
         // indicates if the project (file) and all its imported files are validated against a schema
-        private bool                        isValidated;
+        private bool isValidated;
 
         // the schema against which to validate the project (file) and all its imported files
-        private string                      schemaFile;
+        private string schemaFile;
 
         // The XML document for the main project file.
-        private XmlDocument                 mainProjectEntireContents;
+        private XmlDocument mainProjectEntireContents;
 
         // The <project> XML node of the main project file which was loaded
         // (as opposed to any imported project files).
-        private XmlElement                  mainProjectElement;
+        private XmlElement mainProjectElement;
 
         // The default targets, specified as an optional attribute on the
         // <Project> element.
-        private string[]                    defaultTargetNames;
+        private string[] defaultTargetNames;
 
         // The names of the targets specified in the InitialTargets attributes
         // on the <Project> node.  We separate the ones in the main project from
         // the ones in the imported projects to make the object model more sensible.
         // These ArrayLists contain strings.
-        private ArrayList                   initialTargetNamesInMainProject;
-        private ArrayList                   initialTargetNamesInImportedProjects;
+        private ArrayList initialTargetNamesInMainProject;
+        private ArrayList initialTargetNamesInImportedProjects;
 
         // The fully qualified path to the project file for this project.
         // If the project was loaded from in-memory XML, this will empty string.
-        private string                      fullFileName;
+        private string fullFileName;
 
         // This is the directory containing the project file
-        private string                      projectDirectory;
+        private string projectDirectory;
 
         // The set of global properties for this project.  For example, global
         // properties may be set at the command-line via the /p: switch.
-        private BuildPropertyGroup               globalProperties;
+        private BuildPropertyGroup globalProperties;
 
         // The set of properties coming from environment variables.
-        private BuildPropertyGroup               environmentProperties;
+        private BuildPropertyGroup environmentProperties;
 
         // The set of XMake reserved properties for this project (e.g.,
         // XMakeProjectName).
-        private BuildPropertyGroup               reservedProperties;
+        private BuildPropertyGroup reservedProperties;
 
         // The raw persisted <PropertyGroup>'s in the project file.
-        private BuildPropertyGroupCollection     rawPropertyGroups;
+        private BuildPropertyGroupCollection rawPropertyGroups;
 
         // The set of all <Target>s in the project file after they've been evaluated
         // and made useful for end-users.
-        private TargetCollection            targets;
+        private TargetCollection targets;
 
         // The name of the first target in the main project. This is used as the default
         // target when one isn't specified in some other way.
-        private string                      nameOfFirstTarget = null;
+        private string nameOfFirstTarget = null;
 
         // The final set of evaluated and expanded property values for this
         // project, which includes all global properties, environment properties,
         // reserved properties, and properties in the main project file and
         // any imported project files - taking into account property precedence
         // rules, of course.
-        internal BuildPropertyGroup              evaluatedProperties;
+        internal BuildPropertyGroup evaluatedProperties;
 
         // This hash table keeps track of the properties that are referenced inside
         // any "Condition" attribute in the entire project, and for each such
         // property, we keep the list of string values that the property is
         // being tested against.  This is how the IDE gets at the list of
         // configurations for a project.
-        private Hashtable                   conditionedPropertiesTable;
+        private Hashtable conditionedPropertiesTable;
 
         // The raw persisted <ItemGroup>'s in the project file.
-        private BuildItemGroupCollection         rawItemGroups;
+        private BuildItemGroupCollection rawItemGroups;
 
         // The raw collection of all grouping elements (ItemGroup, BuildPropertyGroup, and Choose.
-        private GroupingCollection          rawGroups;
+        private GroupingCollection rawGroups;
 
         // Each entry in this contains an BuildItemGroup.  Each of these
         // ItemGroups represents a list of "BuildItem" objects all of the same item type.
@@ -164,7 +164,7 @@ public class Project
         // (the tasks).  It represents true reality, and therefore it gets
         // re-computed every time something in the project changes (like a property
         // value for example).
-        internal Hashtable                  evaluatedItemsByName;
+        internal Hashtable evaluatedItemsByName;
 
         // All the item definitions in the logical project, including imports.
         // (Imported definitions don't need to be distinguished, since we don't have OM support
@@ -178,7 +178,7 @@ public class Project
         /// and therefore it gets re-computed every time something in the project changes
         /// (like a property value for example).
         /// </summary>
-        internal BuildItemGroup                  evaluatedItems;
+        internal BuildItemGroup evaluatedItems;
 
         // This is a Hashtable of ItemGroups.  Each BuildItemGroup contains a list of Items
         // of a the same type.  The key for the Hashtable is the "item type" string.
@@ -199,7 +199,7 @@ public class Project
         // get used for "build" purposes, since it is not entirely accurate and up-to-
         // date.  It is only to be consumed by the IDE for purposes of displaying
         // items in the Solution Explorer (for example).
-        internal Hashtable                  evaluatedItemsByNameIgnoringCondition;
+        internal Hashtable evaluatedItemsByNameIgnoringCondition;
 
         // A single BuildItemGroup containing all the items in the project, after
         // wildcard and property expansion, but ignoring "Condition"s.  So, for example,
@@ -218,52 +218,52 @@ public class Project
         // get used for "build" purposes, since it is not entirely accurate and up-to-
         // date.  It is only to be consumed by the IDE for purposes of displaying
         // items in the Solution Explorer (for example).
-        internal BuildItemGroup                  evaluatedItemsIgnoringCondition;
+        internal BuildItemGroup evaluatedItemsIgnoringCondition;
 
         // This array list contains the ordered list of <UsingTask> elements in
         // the project file and all the imported files.  When we
         // object model for these things has been worked out, there should
         // be an actual class here that we define, rather than an array list.
-        private UsingTaskCollection         usingTasks;
+        private UsingTaskCollection usingTasks;
 
         // holds all the tasks the project knows about and the assemblies they exist in
         // NOTE: tasks and their assemblies are declared in a project with the <UsingTask> tag
-        private ITaskRegistry                taskRegistry;
+        private ITaskRegistry taskRegistry;
 
         // The <ProjectExtensions> XML node if there is one.
-        private XmlNode                     projectExtensionsNode;
+        private XmlNode projectExtensionsNode;
 
         // This hash table simply keeps track of the list of imported project
         // files so that we can detect a circular import to prevent infinite
         // recursion.
-        private ImportCollection            imports;
+        private ImportCollection imports;
 
         // Tells us if anything has changed that would require us to re-read and re-
         // process the XML.  The main scenario here would be the addition or removal
         // of an <Import> tag.
-        private bool                        dirtyNeedToReprocessXml;
+        private bool dirtyNeedToReprocessXml;
 
         // Tells us if anything in this project has changed since the last time
         // we evaluated all our properties and items.  That could include all sorts
         // of things like properties (including global properties), items, etc.
         // Note: The only reason this is internal is for unit tests.
-        private bool                       dirtyNeedToReevaluate;
+        private bool dirtyNeedToReevaluate;
 
         // Tells us whether we need to re-evaluate the conditions on global warnings and errors.
-        internal bool                        dirtyNeedToReevaluateGlobalWarningsAndErrors;
+        internal bool dirtyNeedToReevaluateGlobalWarningsAndErrors;
 
         // Tells us if anything in this project has changed since the last time
         // we either loaded or saved the project file to disk.  That could include all sorts
         // of things like properties (including global properties), items, etc.
-        private bool                        dirtyNeedToSaveProjectFile;
+        private bool dirtyNeedToSaveProjectFile;
 
         // Tells us the timestamp of when the project was last touched in a way
         // that would require it to need to be saved.
-        private DateTime                    timeOfLastDirty;
+        private DateTime timeOfLastDirty;
 
         // Tells us whether the project is currently in the "reset" state, meaning
         // that all of the targets are marked NotStarted.
-        private bool                        isReset;
+        private bool isReset;
 
         // This variable indicates whether a particular project was loaded by the host
         // (e.g., the IDE) and therefore needs to be kept around permanently, or whether
@@ -273,7 +273,7 @@ public class Project
         // way for the host to change it.  The only entity that should every be changing
         // this to "false" is the Engine itself because it knows that we're just building
         // this project and don't need to keep it around for design-time scenarios.
-        private bool                        isLoadedByHost;
+        private bool isLoadedByHost;
 
         // This controls whether or not the building of targets/tasks is enabled for this
         // project.  This is for security purposes in case a host wants to closely
@@ -605,7 +605,7 @@ public string InitialTargets
             {
                 // Return the concatenation of the initial target names from the main project and the ones from 
                 // all the imported projects.  Join target names together with semicolons in between.
-                return String.Join("; ", (string[]) this.CombinedInitialTargetNames.ToArray(typeof(string)));
+                return String.Join("; ", (string[])this.CombinedInitialTargetNames.ToArray(typeof(string)));
             }
 
             set
@@ -706,7 +706,7 @@ internal bool IsBuilding
         {
             get
             {
-                return buildingCount>0;
+                return buildingCount > 0;
             }
         }
 
@@ -1211,7 +1211,7 @@ public string Xml
             {
                 using (StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture))
                 {
-                    this.Save((TextWriter) stringWriter);
+                    this.Save((TextWriter)stringWriter);
                     return stringWriter.ToString();
                 }
             }
@@ -1506,7 +1506,7 @@ internal void MarkProjectAsDirtyForReprocessXml
             (
             )
         {
-            this.MarkProjectAsDirty ();
+            this.MarkProjectAsDirty();
             this.dirtyNeedToReprocessXml = true;
         }
 
@@ -1966,7 +1966,7 @@ ProjectLoadSettings projectLoadSettings
             {
                 BuildEventFileInfo fileInfo = new BuildEventFileInfo(e);
 
-                ParentEngine.LoggingServices.LogError(projectBuildEventContext, null,fileInfo, "InvalidProjectFile", e.Message);
+                ParentEngine.LoggingServices.LogError(projectBuildEventContext, null, fileInfo, "InvalidProjectFile", e.Message);
 
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false, fileInfo,
                     "InvalidProjectFile", e.Message);
@@ -2747,7 +2747,7 @@ string itemInclude
                     // the same type as the new item being added.
                     foreach (BuildItem originalItem in itemGroup)
                     {
-                        if ( String.Equals( originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
                         {
                             // If the new item that the user is trying to add is already covered by 
                             // a wildcard in an existing item of the project, then there's really
@@ -2928,7 +2928,7 @@ BuildItem itemToRemove
                 // If the item doesn't have a parent BuildItemGroup associated with it, then it
                 // must not be a persisted item that's actually declared in the project file.
                 parentItemGroup = itemToRemove.ParentPersistedItemGroup;
-                error.VerifyThrowInvalidOperation (parentItemGroup != null, "ObjectIsNotInProject");
+                error.VerifyThrowInvalidOperation(parentItemGroup != null, "ObjectIsNotInProject");
             }
             else
             {
@@ -2954,7 +2954,7 @@ BuildItem itemToRemove
                 this.RemoveItemGroup(parentItemGroup);
             }
 
-            this.MarkProjectAsDirty ();
+            this.MarkProjectAsDirty();
         }
 
         /// <summary>
@@ -3041,7 +3041,7 @@ public void SetProjectExtensions(string id, string content)
             }
 
             // Look in the extensions node and see if there is a child that matches
-            XmlElement idElement = (XmlElement) projectExtensionsNode[id];
+            XmlElement idElement = (XmlElement)projectExtensionsNode[id];
 
             // Found anything?
             if (idElement == null)
@@ -3109,7 +3109,7 @@ public bool Build
             string targetName
             )
         {
-            return this.ParentEngine.BuildProject(this, (targetName == null) ? null : new string[] {targetName},
+            return this.ParentEngine.BuildProject(this, (targetName == null) ? null : new string[] { targetName },
                 null, BuildSettings.None);
         }
 
@@ -3233,7 +3233,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                 if (buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.BuildingCurrentTarget)
                 {
                     // Execute the next appropriate operation for this target
-                    ErrorUtilities.VerifyThrow( taskExecutionContext != null, "Task context should be non-null");
+                    ErrorUtilities.VerifyThrow(taskExecutionContext != null, "Task context should be non-null");
                     taskExecutionContext.ParentTarget.ContinueBuild(taskExecutionContext.BuildContext, taskExecutionContext);
                 }
                 else if (buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.StartingFirstTarget)
@@ -3275,7 +3275,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
             }
             finally
             {
-                if ( (exitedDueToError || buildContext.BuildComplete) &&
+                if ((exitedDueToError || buildContext.BuildComplete) &&
                      buildContext.CurrentBuildContextState != ProjectBuildState.BuildContextState.RequestFilled)
                 {
                     // If the target that threw an exception is being built due to an
@@ -3471,30 +3471,30 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
             BuildEventContext buildEventContext = null;
 
             // Determine if a project started event is required to be fired, if so we may need a new projectContextId
-             if (buildRequest.FireProjectStartedFinishedEvents)
-             {
-                 //If we have not already used the context from the project yet, lets use that as our first event context
-                 if (!haveUsedInitialProjectContextId)
-                 {
-                     buildEventContext = projectBuildEventContext;
-                     haveUsedInitialProjectContextId = true;
-                 }
-                 else // We are going to need a new Project context Id and a new buildEventContext
-                 {
-                     projectContextId = parentEngine.GetNextProjectId();
-                 }
-             }
-
-             if (buildEventContext == null)
-             {
-                 buildEventContext = new BuildEventContext
-                                   (
-                                       projectBuildEventContext.NodeId,
-                                       projectBuildEventContext.TargetId,
-                                       projectContextId,
-                                       projectBuildEventContext.TaskId
-                                    );
-             }
+            if (buildRequest.FireProjectStartedFinishedEvents)
+            {
+                //If we have not already used the context from the project yet, lets use that as our first event context
+                if (!haveUsedInitialProjectContextId)
+                {
+                    buildEventContext = projectBuildEventContext;
+                    haveUsedInitialProjectContextId = true;
+                }
+                else // We are going to need a new Project context Id and a new buildEventContext
+                {
+                    projectContextId = parentEngine.GetNextProjectId();
+                }
+            }
+
+            if (buildEventContext == null)
+            {
+                buildEventContext = new BuildEventContext
+                                  (
+                                      projectBuildEventContext.NodeId,
+                                      projectBuildEventContext.TargetId,
+                                      projectContextId,
+                                      projectBuildEventContext.TaskId
+                                   );
+            }
 
             bool exitedDueToError = true;
 
@@ -3733,8 +3733,8 @@ private void ProcessMainProjectElement
         /// <owner>RGoel</owner>
         private void ProcessProjectAttributes
         (
-            XmlElement  projectElement,
-            bool        importedProject
+            XmlElement projectElement,
+            bool importedProject
         )
         {
             // Make sure the <Project> node has been given to us.
@@ -3863,15 +3863,15 @@ bool importedProject
                             this.rawItemGroups.InsertAtEnd(newItemGroup);
                             break;
 
-                    // Process the <PropertyGroup> element.
-                    case XMakeElements.propertyGroup:
-                        BuildPropertyGroup newPropertyGroup = new BuildPropertyGroup(this, childElement, importedProject);
-                        newPropertyGroup.EnsureNoReservedProperties();
-                        this.rawPropertyGroups.InsertAtEnd(newPropertyGroup);
-                        // PropertyGroups/Chooses are evaluated immediately during this scan, as they're needed to figure out whether
-                        // we include Imports.
-                        newPropertyGroup.Evaluate(this.evaluatedProperties, this.conditionedPropertiesTable, ProcessingPass.Pass1);
-                        break;
+                        // Process the <PropertyGroup> element.
+                        case XMakeElements.propertyGroup:
+                            BuildPropertyGroup newPropertyGroup = new BuildPropertyGroup(this, childElement, importedProject);
+                            newPropertyGroup.EnsureNoReservedProperties();
+                            this.rawPropertyGroups.InsertAtEnd(newPropertyGroup);
+                            // PropertyGroups/Chooses are evaluated immediately during this scan, as they're needed to figure out whether
+                            // we include Imports.
+                            newPropertyGroup.Evaluate(this.evaluatedProperties, this.conditionedPropertiesTable, ProcessingPass.Pass1);
+                            break;
 
                         // Process the <Choose> element.
                         case XMakeElements.choose:
@@ -3936,7 +3936,7 @@ bool importedProject
                         case XMakeElements.importGroup:
                             foreach (XmlElement importGroupChild in childElement.ChildNodes)
                             {
-                                switch(importGroupChild.Name)
+                                switch (importGroupChild.Name)
                                 {
                                     case XMakeElements.import:
                                         ProcessImportElement(importGroupChild, projectDirectoryLocation, importedProject);
@@ -3977,9 +3977,9 @@ bool importedProject
         /// <param name="importedProject"></param>
         private void ProcessImportElement
         (
-            XmlElement  importElement,
-            string      projectDirectoryLocation,
-            bool        importedProject
+            XmlElement importElement,
+            string projectDirectoryLocation,
+            bool importedProject
         )
         {
             Import temp = new Import(importElement, this, importedProject);
@@ -4008,7 +4008,7 @@ bool        importedProject
 
             for (int i = 0; i < importedFilenames.Length; i++)
             {
-                string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);     
+                string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);
                 ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(importedFilename),
                     importElement, "MissingRequiredAttribute",
                     XMakeAttributes.project, XMakeElements.import);
@@ -4297,11 +4297,11 @@ private void EvaluateAllPropertyGroups
             {
                 if (propertyGroup is BuildPropertyGroup)
                 {
-                    ((BuildPropertyGroup) propertyGroup).Evaluate(this.evaluatedProperties, this.conditionedPropertiesTable, ProcessingPass.Pass1);
+                    ((BuildPropertyGroup)propertyGroup).Evaluate(this.evaluatedProperties, this.conditionedPropertiesTable, ProcessingPass.Pass1);
                 }
                 else if (propertyGroup is Choose)
                 {
-                    ((Choose) propertyGroup).Evaluate(this.evaluatedProperties, false, true, this.conditionedPropertiesTable, ProcessingPass.Pass1);
+                    ((Choose)propertyGroup).Evaluate(this.evaluatedProperties, false, true, this.conditionedPropertiesTable, ProcessingPass.Pass1);
                 }
                 else
                 {
@@ -4329,11 +4329,11 @@ bool honorCondition
             {
                 if (itemGroup is BuildItemGroup)
                 {
-                    ((BuildItemGroup) itemGroup).Evaluate(this.evaluatedProperties, this.evaluatedItemsByName, ignoreCondition, honorCondition, ProcessingPass.Pass2);
+                    ((BuildItemGroup)itemGroup).Evaluate(this.evaluatedProperties, this.evaluatedItemsByName, ignoreCondition, honorCondition, ProcessingPass.Pass2);
                 }
                 else if (itemGroup is Choose)
                 {
-                    ((Choose) itemGroup).Evaluate(this.evaluatedProperties, ignoreCondition, honorCondition, this.conditionedPropertiesTable, ProcessingPass.Pass2);
+                    ((Choose)itemGroup).Evaluate(this.evaluatedProperties, ignoreCondition, honorCondition, this.conditionedPropertiesTable, ProcessingPass.Pass2);
                 }
                 else
                 {
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index 64e6f587499..cf461ace069 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -207,7 +207,7 @@ internal bool ContainsCycle(string name)
             }
             if (!containsCycle && requiredTargets?.Count > 0)
             {
-                containsCycle = 
+                containsCycle =
                     (String.Equals(name, (string)targetNamesToBuild[indexOfTargetInProgress], StringComparison.OrdinalIgnoreCase));
             }
             return containsCycle;
@@ -244,7 +244,7 @@ internal string GetParentTarget(string name)
                 {
                     string[] requiredTargetsArray = requiredTargets.ToArray();
 
-                    for (int i = requiredTargetsArray.Length-1; i >= 0; i--)
+                    for (int i = requiredTargetsArray.Length - 1; i >= 0; i--)
                     {
                         if (string.CompareOrdinal(requiredTargetsArray[i], name) != 0)
                         {
diff --git a/src/Deprecated/Engine/Engine/ProjectManager.cs b/src/Deprecated/Engine/Engine/ProjectManager.cs
index 8a19e03eafb..0ba30f50da2 100644
--- a/src/Deprecated/Engine/Engine/ProjectManager.cs
+++ b/src/Deprecated/Engine/Engine/ProjectManager.cs
@@ -80,7 +80,7 @@ Project project
                     project_index = i;
                 }
             }
-            
+
             // The project should be in the table
             ErrorUtilities.VerifyThrow(project_index != -1, "Project missing from the list");
 
@@ -153,11 +153,11 @@ string projectFileFullPath
             )
         {
             // Get the list of projects that have this full path.
-            ArrayList projectsWithThisFullPath = (ArrayList) this.projects[projectFileFullPath];
+            ArrayList projectsWithThisFullPath = (ArrayList)this.projects[projectFileFullPath];
 
             if ((projectsWithThisFullPath?.Count > 0))
             {
-                return (Project) projectsWithThisFullPath[0];
+                return (Project)projectsWithThisFullPath[0];
             }
 
             // No project was found that matched the full path specified.
@@ -434,7 +434,7 @@ internal class ProjectEntry
             internal string toolsVersion;
             internal int nodeIndex;
         }
-        
+
         #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
index ab4840d7004..7ab5cd217bd 100644
--- a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
+++ b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.BuildEngine
     internal sealed class ProjectSchemaValidationHandler
     {
         // The parent Engine object for this project.
-        private EngineLoggingServices engineLoggingServices ;
+        private EngineLoggingServices engineLoggingServices;
 
         // the location of the MSBuild binaries
         private string binPath;
@@ -114,7 +114,7 @@ string projectFile
             validatorSettings.ValidationType = ValidationType.Schema;
             validatorSettings.XmlResolver = null;
             validatorSettings.ValidationEventHandler += this.OnSchemaValidationError;
-            
+
             if (string.IsNullOrEmpty(schemaFile))
             {
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
diff --git a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
index 2d07eef45b4..32012e92930 100644
--- a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
+++ b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
@@ -157,7 +157,7 @@ public virtual string[] GetSubKeyNames()
         public virtual RegistryKeyWrapper OpenSubKey(string name)
         {
             ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
-            
+
             RegistryKeyWrapper wrapper = this;
             string[] keyNames = name.Split(new char[] { '\\' }, StringSplitOptions.RemoveEmptyEntries);
 
@@ -224,7 +224,7 @@ private RegistryKey WrappedKey
                 return wrappedKey;
             }
         }
-    
+
         /// <summary>
         /// Returns false if this is a known exception thrown by the registry API.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/RequestRoutingContext.cs b/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
index aa5287fde18..6853bf1b6de 100644
--- a/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
+++ b/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
@@ -24,12 +24,12 @@ internal RequestRoutingContext
             int nodeIndex,
             int parentHandleId,
             int parentNodeIndex,
-            int parentRequestId, 
+            int parentRequestId,
             CacheScope cacheScope,
             BuildRequest triggeringBuildRequest,
             BuildEventContext buildEventContext
         )
-            :base(handleId, nodeIndex, buildEventContext)
+            : base(handleId, nodeIndex, buildEventContext)
         {
             this.parentHandleId = parentHandleId;
             this.parentNodeIndex = parentNodeIndex;
diff --git a/src/Deprecated/Engine/Engine/Router.cs b/src/Deprecated/Engine/Engine/Router.cs
index a01ceb26477..6a0de7bcb79 100644
--- a/src/Deprecated/Engine/Engine/Router.cs
+++ b/src/Deprecated/Engine/Engine/Router.cs
@@ -121,12 +121,12 @@ internal void PostDoneNotice(BuildRequest buildRequest)
         /// </summary>
         internal void PostDoneNotice(int nodeId, BuildResult buildResult)
         {
-               
-            
-                // Notify the scheduler that a given node(nodeId) will be getting a buildResult.
-                // This method is a no-op if the router is on a child process
-                scheduler?.NotifyOfBuildResult(nodeId, buildResult);
-            
+
+
+            // Notify the scheduler that a given node(nodeId) will be getting a buildResult.
+            // This method is a no-op if the router is on a child process
+            scheduler?.NotifyOfBuildResult(nodeId, buildResult);
+
 
             if (nodeId == EngineCallback.inProcNode)
             {
@@ -169,13 +169,13 @@ internal void PostBuildRequest(BuildRequest currentRequest, int nodeIndex)
                                     (nodeIndex, currentRequest.HandleId, currentRequest.NodeIndex,
                                      currentRequest.RequestId, cacheScope, currentRequest, null);
 
-                       
-                    
-                        // Check to see if we need to change the traversal strategy of the system
-                        // parentHandleId and node index are not used in the function so it can be ignored
-                        scheduler?.NotifyOfBuildRequest(nodeIndex, currentRequest, parentHandleId);
-                    
-                    
+
+
+                    // Check to see if we need to change the traversal strategy of the system
+                    // parentHandleId and node index are not used in the function so it can be ignored
+                    scheduler?.NotifyOfBuildRequest(nodeIndex, currentRequest, parentHandleId);
+
+
                     nodeManager.PostBuildRequestToNode(nodeIndex, currentRequest);
                 }
             }
diff --git a/src/Deprecated/Engine/Engine/Scheduler.cs b/src/Deprecated/Engine/Engine/Scheduler.cs
index 110e2dbbf84..d6fce81f824 100644
--- a/src/Deprecated/Engine/Engine/Scheduler.cs
+++ b/src/Deprecated/Engine/Engine/Scheduler.cs
@@ -275,7 +275,7 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                 }
 
                 // Dump some interesting information to the console if profile build is turned on by an environment variable
-                if (parentEngine.ProfileBuild && scheduleRecord != null && buildResult.TaskTime != 0 )
+                if (parentEngine.ProfileBuild && scheduleRecord != null && buildResult.TaskTime != 0)
                 {
                     Console.WriteLine("N " + scheduleRecord.EvaluationNode + " Name " + scheduleRecord.ProjectName + ":" +
                                       scheduleRecord.ParentKey.HandleId + ":" + scheduleRecord.ParentKey.RequestId +
@@ -303,7 +303,7 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
                     {
                         // Continue using breadth-first traversal as long as the non-blocked work load for this node is below 
                         // the nodeWorkloadProjectCount or its postBlockCount is non-zero
-                        if ((totalRequestsPerNode[i] - blockedRequestsPerNode[i]) < nodeWorkLoadProjectCount || postBlockCount[i] != 0 )
+                        if ((totalRequestsPerNode[i] - blockedRequestsPerNode[i]) < nodeWorkLoadProjectCount || postBlockCount[i] != 0)
                         {
                             useBreadthFirstTraversal = true;
                             break;
@@ -314,7 +314,7 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
                     {
                         if (Engine.debugMode)
                         {
-                             Console.WriteLine("Switching to depth first traversal because all node have workitems");
+                            Console.WriteLine("Switching to depth first traversal because all node have workitems");
                         }
                         parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal = false;
 
@@ -381,7 +381,7 @@ internal void NotifyOfBlockedNode(int nodeId)
                 Console.WriteLine("Switch to breadth first traversal is requested by " + nodeId);
             }
 
-            postBlockCount[nodeId] = nodeWorkLoadProjectCount/2;
+            postBlockCount[nodeId] = nodeWorkLoadProjectCount / 2;
         }
 
         /// <summary>
@@ -397,7 +397,7 @@ internal void DumpState()
             foreach (ScheduleRecordKey key in handleIdToScheduleRecord.Keys)
             {
                 ScheduleRecord record = handleIdToScheduleRecord[key];
-                Console.WriteLine(key.HandleId  + ":" + key.RequestId + " " + record.ProjectName + " on node " + record.EvaluationNode);
+                Console.WriteLine(key.HandleId + ":" + key.RequestId + " " + record.ProjectName + " on node " + record.EvaluationNode);
             }
         }
         #endregion
diff --git a/src/Deprecated/Engine/Engine/SchedulerRecord.cs b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
index b97261cb00a..cd6e868adda 100644
--- a/src/Deprecated/Engine/Engine/SchedulerRecord.cs
+++ b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
@@ -17,12 +17,12 @@ internal class ScheduleRecord
         #region Constructors
         internal ScheduleRecord
         (
-            ScheduleRecordKey recordKey, 
-            ScheduleRecordKey parentKey, 
+            ScheduleRecordKey recordKey,
+            ScheduleRecordKey parentKey,
             int evaluationNode,
             string projectName,
             string toolsVersion,
-            string [] targetsBuild
+            string[] targetsBuild
         )
         {
             this.recordKey = recordKey;
@@ -175,7 +175,7 @@ internal void ReportChildCompleted(ScheduleRecordKey key)
     /// This class is used as a key combining both HandleId and RequestId into a single class.
     /// </summary>
     [DebuggerDisplay("Key ({handleId},{requestId})")]
-    internal class ScheduleRecordKey 
+    internal class ScheduleRecordKey
     {
         #region Constructors
         internal ScheduleRecordKey(int handleId, int requestId)
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index 18e3a06117f..cf6f55deda7 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -55,17 +55,17 @@ internal enum BuildState
         #region Member Data
 
         // The evaluated name of the target.
-        private string                      targetName;
+        private string targetName;
 
         // The parent project.object.  We will need this in order get the
         // complete list of targets, items, properties, etc.
-        private Project                     parentProject;
+        private Project parentProject;
 
         // The parent Engine object.
-        private Engine                      parentEngine;
+        private Engine parentEngine;
 
         // The state of this target, in terms of the build.
-        private BuildState                  buildState;
+        private BuildState buildState;
 
         // The <Target> XML element, if this is a persisted item.  For virtual
         // items (i.e., those generated by tasks), this would be null.
@@ -105,7 +105,7 @@ internal enum BuildState
         private bool conditionCheckedForInvalidMetadataReferences = false;
         private TargetExecutionWrapper executionState = null;
         private List<string> batchableTargetParameters = null;
-        
+
         // TargetId
         private int id;
 
@@ -122,13 +122,13 @@ internal enum BuildState
         /// <param name="importedFromAnotherProject"></param>
         internal Target
         (
-            XmlElement  targetElement,
-            Project     project,
-            bool        importedFromAnotherProject
+            XmlElement targetElement,
+            Project project,
+            bool importedFromAnotherProject
         )
         {
             // Make sure a valid node has been given to us.
-            error.VerifyThrow(targetElement != null,"Need a valid XML node.");
+            error.VerifyThrow(targetElement != null, "Need a valid XML node.");
 
             // Make sure this really is the <target> node.
             ProjectXmlUtilities.VerifyThrowElementName(targetElement, XMakeElements.target);
@@ -145,7 +145,7 @@ bool        importedFromAnotherProject
             // The target name and target dependendencies (dependencies on other 
             // targets) are specified as attributes of the <target> element.
 
-            XmlAttribute returnsAttribute = null; 
+            XmlAttribute returnsAttribute = null;
             // Loop through all the attributes on the <target> element.
             foreach (XmlAttribute targetAttribute in targetElement.Attributes)
             {
@@ -275,7 +275,7 @@ internal int Id
         /// <value>The target name string.</value>
         public string Name
         {
-            get 
+            get
             {
                 return this.targetName;
             }
@@ -530,7 +530,7 @@ internal void ResetBuildStatus
         /// </summary>
         internal void UpdateTargetStateOnBuildCompletion
         (
-            BuildState stateOfBuild, 
+            BuildState stateOfBuild,
             List<BuildItem> targetOutputItemList
         )
         {
@@ -592,7 +592,7 @@ ProjectBuildState buildContext
                     // Only contexts which are generated from an MSBuild task could need 
                     // the outputs of this target, such contexts have a non-null evaluation
                     // request
-                    if ((buildState == BuildState.CompletedSuccessfully) && 
+                    if ((buildState == BuildState.CompletedSuccessfully) &&
                         (buildContext.BuildRequest.OutputsByTarget != null &&
                          buildContext.NameOfBlockingTarget == null))
                     {
@@ -681,7 +681,7 @@ ProjectBuildState buildContext
         /// </summary>
         /// <param name="buildContext">Context within which the target is being executed</param>
         /// <param name="taskExecutionContext">Result of last execution (multi-threaded only)</param>
-        internal void ContinueBuild( ProjectBuildState buildContext, TaskExecutionContext taskExecutionContext)
+        internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext taskExecutionContext)
         {
             executionState.ContinueBuild(buildContext, taskExecutionContext);
         }
@@ -703,7 +703,7 @@ internal bool ExecuteOneTask(XmlElement taskNode, ITaskHost hostObject)
                                     ParentProject.ProjectBuildEventContext.ProjectContextId,
                                     ParentProject.ProjectBuildEventContext.TaskId
                                 );
-            int handleId = parentEngine.EngineCallback.CreateTaskContext(ParentProject,this, null, taskNode, 
+            int handleId = parentEngine.EngineCallback.CreateTaskContext(ParentProject, this, null, taskNode,
                                                                             EngineCallback.inProcNode, targetBuildEventContext);
             TaskExecutionModule taskExecutionModule = parentEngine.NodeManager.TaskExecutionModule;
             TaskEngine taskEngine = new TaskEngine(taskNode, hostObject, parentProject.FullFileName, projectFileOfTaskNode, parentEngine.LoggingServices, handleId, taskExecutionModule, targetBuildEventContext);
@@ -723,11 +723,11 @@ internal void MarkTargetAsDirty
             (
             )
         {
-               
-            
-                // This is a change to the contents of the project file.
-                this.ParentProject?.MarkProjectAsDirty();
-            
+
+
+            // This is a change to the contents of the project file.
+            this.ParentProject?.MarkProjectAsDirty();
+
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index 4b49d144aab..1b5a8b20c3d 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -22,8 +22,8 @@ public class TargetCollection : IEnumerable, ICollection
         #region Member Data
 
         // This is the hashtable of Targets (indexed by name) contained in this collection.
-        private Hashtable       targetTable = null;
-        private Project        parentProject = null;
+        private Hashtable targetTable = null;
+        private Project parentProject = null;
 
         #endregion
 
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index e1396dbf361..d645e6e1664 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -71,7 +71,7 @@ internal Target TargetToAnalyze
             }
         }
 
-               /// <summary>
+        /// <summary>
         /// Gets the value of the target's "Inputs" attribute.
         /// </summary>
         /// <owner>SumedhK</owner>
@@ -249,7 +249,7 @@ out Hashtable upToDateTargetInputs
                     loggingService.LogComment(buildEventContext, MessageImportance.Normal,
                         "SkipTargetBecauseOutputsUpToDate",
                         TargetToAnalyze.Name);
-                    
+
                     // Log the target inputs & outputs
                     if (!loggingService.OnlyLogCriticalEvents)
                     {
@@ -288,7 +288,7 @@ private void LogReasonForBuildingTarget(DependencyAnalysisResult result)
                 if (result == DependencyAnalysisResult.FullBuild && this.dependencyAnalysisDetail.Count > 0)
                 {
                     // For the full build decision the are three possible outcomes
-                    loggingService.LogComment(buildEventContext,"BuildTargetCompletely", this.targetToAnalyze.Name);
+                    loggingService.LogComment(buildEventContext, "BuildTargetCompletely", this.targetToAnalyze.Name);
 
                     foreach (DependencyAnalysisLogDetail logDetail in this.dependencyAnalysisDetail)
                     {
@@ -476,7 +476,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfNoOutputs()
             // otherwise, don't build the target
             else
             {
-                loggingService.LogComment(buildEventContext, MessageImportance.Normal, 
+                loggingService.LogComment(buildEventContext, MessageImportance.Normal,
                     "SkipTargetBecauseNoOutputs", TargetToAnalyze.Name);
                 // detailed reason is low importance to keep log clean
                 loggingService.LogComment(buildEventContext, MessageImportance.Low,
@@ -702,7 +702,7 @@ ArrayList targetOutputItemSpecs
                 // if the target did declare inputs, but the specification evaluated to nothing
                 if (TargetInputSpecification.Length > 0)
                 {
-                    loggingService.LogComment(buildEventContext, MessageImportance.Normal, 
+                    loggingService.LogComment(buildEventContext, MessageImportance.Normal,
                         "SkipTargetBecauseNoInputs", TargetToAnalyze.Name);
                     // detailed reason is low importance to keep log clean
                     loggingService.LogComment(buildEventContext, MessageImportance.Low,
@@ -725,8 +725,8 @@ ArrayList targetOutputItemSpecs
             else
             {
                 DependencyAnalysisLogDetail dependencyAnalysisDetailEntry;
-                bool someOutOfDate =  IsAnyOutOfDate(out dependencyAnalysisDetailEntry, projectDirectory, targetInputItemSpecs, targetOutputItemSpecs);
-   
+                bool someOutOfDate = IsAnyOutOfDate(out dependencyAnalysisDetailEntry, projectDirectory, targetInputItemSpecs, targetOutputItemSpecs);
+
                 if (someOutOfDate)
                 {
                     dependencyAnalysisDetail.Add(dependencyAnalysisDetailEntry);
@@ -911,7 +911,7 @@ internal static bool IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAn
         {
             ErrorUtilities.VerifyThrow((inputs.Count > 0) && (outputs.Count > 0), "Need to specify inputs and outputs.");
 
-             // Algorithm: walk through all the outputs to find the oldest output
+            // Algorithm: walk through all the outputs to find the oldest output
             //            walk through the inputs as far as we need to until we find one that's newer (if any)
 
             // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely): 
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index 9d2ecfe4f43..c01d06f85ea 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -36,10 +36,10 @@ BuildEventContext targetBuildEventContext
         )
         {
             // Initialize the data about the target XML that has been calculated in the target class
-            this.targetClass   = targetClass;
-            this.parentEngine  = targetClass.ParentEngine;
+            this.targetClass = targetClass;
+            this.parentEngine = targetClass.ParentEngine;
             this.parentProject = targetClass.ParentProject;
-            this.targetElement   = targetElement;
+            this.targetElement = targetElement;
             this.taskElementList = taskElementList;
             this.targetParameters = targetParameters;
             this.targetBuildEventContext = targetBuildEventContext;
@@ -209,7 +209,7 @@ ProjectBuildState errorContext
 
         #region Methods for building dependencies ( InProgressBuildState.BuildingDependencies )
 
-        private void ContinueBuildingDependencies (ProjectBuildState buildContext)
+        private void ContinueBuildingDependencies(ProjectBuildState buildContext)
         {
             // Verify that the target is in the right state
             ErrorUtilities.VerifyThrow(inProgressBuildState == InProgressBuildState.BuildingDependencies, "Wrong state");
@@ -280,7 +280,7 @@ ProjectBuildState buildContext
         #endregion
 
         #region Methods for build error targets ( InProgressBuildState.BuildingErrorClause )
-        private void ContinueBuildingErrorClause (ProjectBuildState buildContext)
+        private void ContinueBuildingErrorClause(ProjectBuildState buildContext)
         {
             // Verify that the target is in the right state
             ErrorUtilities.VerifyThrow(inProgressBuildState == InProgressBuildState.BuildingErrorClause, "Wrong state");
@@ -776,7 +776,7 @@ ProjectBuildState buildContext
 
             // A TaskExecutionMode of ExecuteTaskAndGatherOutputs should have its messages logged in the context of the task and therefore should have a valid taskID
             // A TaskExecutionMode of InferOutputs or Invalid should have its messages logged in the context of the target and therefore should have an invalid taskID
-            BuildEventContext buildEventContext = PrepareBuildEventContext(executionMode == TaskExecutionMode.ExecuteTaskAndGatherOutputs ? false: true);
+            BuildEventContext buildEventContext = PrepareBuildEventContext(executionMode == TaskExecutionMode.ExecuteTaskAndGatherOutputs ? false : true);
 
             // Create the task execution context
             int handleId = parentEngine.EngineCallback.CreateTaskContext(parentProject, targetClass, buildContext,
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index 44d7273d9ff..c28d599207e 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -233,20 +233,20 @@ private AppDomain PrepareAppDomain()
                 }
                 else
                 {
-                        // Our task depend on this name to be precisely that, so if you change it make sure
-                        // you also change the checks in the tasks run in separate AppDomains. Better yet, just don't change it.
+                    // Our task depend on this name to be precisely that, so if you change it make sure
+                    // you also change the checks in the tasks run in separate AppDomains. Better yet, just don't change it.
 
-                        // Make sure we copy the appdomain configuration and send it to the appdomain we create so that if the creator of the current appdomain
-                        // has done the binding redirection in code, that we will get those settings as well.
-                        AppDomainSetup appDomainInfo = new AppDomainSetup();
+                    // Make sure we copy the appdomain configuration and send it to the appdomain we create so that if the creator of the current appdomain
+                    // has done the binding redirection in code, that we will get those settings as well.
+                    AppDomainSetup appDomainInfo = new AppDomainSetup();
 
-			// Get the current app domain setup settings
-                        byte[] currentAppdomainBytes = AppDomain.CurrentDomain.SetupInformation.GetConfigurationBytes();
+                    // Get the current app domain setup settings
+                    byte[] currentAppdomainBytes = AppDomain.CurrentDomain.SetupInformation.GetConfigurationBytes();
 
-                        //Apply the appdomain settings to the new appdomain before creating it
-                        appDomainInfo.SetConfigurationBytes(currentAppdomainBytes);
-                        taskAppDomain = AppDomain.CreateDomain("taskAppDomain", null, appDomainInfo);
-                 }
+                    //Apply the appdomain settings to the new appdomain before creating it
+                    appDomainInfo.SetConfigurationBytes(currentAppdomainBytes);
+                    taskAppDomain = AppDomain.CreateDomain("taskAppDomain", null, appDomainInfo);
+                }
             }
 
             return taskAppDomain;
@@ -278,8 +278,8 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
                     lookupHash = Utilities.CreateTableIfNecessary((Hashtable)null);
                 }
 
-		// Loop through each of the batch buckets and execute them one at a time
-                for (int i=0; i < buckets.Count; i++)
+                // Loop through each of the batch buckets and execute them one at a time
+                for (int i = 0; i < buckets.Count; i++)
                 {
                     // Execute the batch bucket, pass in which bucket we are executing so that we know when to get a new taskId for the bucket.
                     taskExecutedSuccessfully = ExecuteBucket(engineProxy, (ItemBucket)buckets[i], i, howToExecuteTask);
@@ -367,10 +367,10 @@ private bool ExecuteBucket(EngineProxy engineProxy, ItemBucket bucket, int bucke
                 // If this is the first bucket use the task context originally given to it, for the remaining buckets get a unique id for them
                 if (bucketNumber != 0)
                 {
-		    // Ask the parent engine the next Id which should be used for the taskId.
+                    // Ask the parent engine the next Id which should be used for the taskId.
                     buildEventContext = new BuildEventContext(buildEventContext.NodeId, buildEventContext.TargetId, buildEventContext.ProjectContextId, parentModule.GetNextTaskId());
 
-		    // For each batch the engineProxy needs to have the correct buildEventContext as all messages comming from a task will have the buildEventContext of the EngineProxy.
+                    // For each batch the engineProxy needs to have the correct buildEventContext as all messages comming from a task will have the buildEventContext of the EngineProxy.
                     engineProxy.BuildEventContext = buildEventContext;
                 }
 
@@ -456,13 +456,13 @@ private void UpdateContinueOnError(ItemBucket bucket, EngineProxy engineProxy)
             {
                 continueOnError =
                 (
-                    // if attribute doesn't exist, default to "false"
+                        // if attribute doesn't exist, default to "false"
                         (continueOnErrorAttribute != null)
                     &&
-                    // otherwise, convert its value to a boolean
+                        // otherwise, convert its value to a boolean
                         ConversionUtilities.ConvertStringToBool
                         (
-                    // expand embedded item vectors after expanding properties and item metadata
+                            // expand embedded item vectors after expanding properties and item metadata
                             bucket.Expander.ExpandAllIntoString(continueOnErrorAttribute)
                         )
                 );
@@ -498,7 +498,7 @@ private ITask InstantiateTask(AppDomain taskAppDomain)
 
                     task = (ITask)taskAppDomain.CreateInstanceFromAndUnwrap(TaskClass.Assembly.AssemblyFile, TaskClass.Type.FullName);
 
-                                        // this will force evaluation of the task class type and try to load the task assembly
+                    // this will force evaluation of the task class type and try to load the task assembly
                     Type taskType = task.GetType();
 
                     // If the types don't match, we have a problem. It means that our AppDomain was able to load
@@ -588,9 +588,9 @@ internal bool InitializeTask(ITask task, ItemBucket bucket, EngineProxy enginePr
 
                 loggingServices.LogFatalTaskError(buildEventContext,
                      e,
-                    // Display the task's exception stack.
-                    // Log the task line number, whatever the value of ContinueOnError;
-                    // because InitializeTask failure will be a hard error anyway.
+                     // Display the task's exception stack.
+                     // Log the task line number, whatever the value of ContinueOnError;
+                     // because InitializeTask failure will be a hard error anyway.
                      CreateBuildEventFileInfoForTask(),
                      TaskName);
 
diff --git a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
index 297ecefa3ea..46e090d4ad5 100644
--- a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
@@ -95,11 +95,11 @@ internal Assembly ResolveAssembly(object sender, ResolveEventArgs args)
                         }
                     }
                     // any problems with the task assembly? return null.
-                    catch (FileNotFoundException )
+                    catch (FileNotFoundException)
                     {
                         return null;
                     }
-                    catch (BadImageFormatException )
+                    catch (BadImageFormatException)
                     {
                         return null;
                     }
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionContext.cs b/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
index a4e3034e6d1..d496fcc67c3 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
@@ -25,14 +25,14 @@ internal class TaskExecutionContext : ExecutionContext
         internal TaskExecutionContext
         (
             Project parentProject,
-            Target  parentTarget,
+            Target parentTarget,
             XmlElement taskNode,
             ProjectBuildState buildContext,
             int handleId,
             int nodeIndex,
             BuildEventContext taskBuildEventContext
         )
-            :base(handleId, nodeIndex, taskBuildEventContext)
+            : base(handleId, nodeIndex, taskBuildEventContext)
         {
             this.parentProject = parentProject;
             this.parentTarget = parentTarget;
@@ -165,8 +165,8 @@ long executionTime
         /// <summary>
         /// Task outputs
         /// </summary>
-        private bool                taskExecutedSuccessfully;
-        private Exception           thrownException;
+        private bool taskExecutedSuccessfully;
+        private Exception thrownException;
 
         #endregion
     }
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
index 4645fa4df44..bb83490db34 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
@@ -53,7 +53,7 @@ bool profileExecution
                 this.isRunningMultipleNodes = true;
                 this.activeThreadCount = 0;
                 this.overallThreadCount = 0;
-                this.threadActiveCountEvent  = new ManualResetEvent(false);
+                this.threadActiveCountEvent = new ManualResetEvent(false);
                 this.threadOverallCountEvent = new ManualResetEvent(false);
                 this.lastTaskActivity = 0;
 
@@ -182,7 +182,7 @@ internal virtual bool BuildProjectFile
             IDictionary[] globalPropertiesPerProject,
             IDictionary[] targetOutputsPerProject,
             EngineLoggingServices loggingServices,
-            string [] toolsVersions,
+            string[] toolsVersions,
             bool useResultsCache,
             bool unloadProjectsOnCompletion,
             BuildEventContext taskContext
@@ -290,22 +290,22 @@ BuildEventContext taskContext
             return overallResult;
         }
 
-       /// <summary>
-       /// Once the buildRequests from the EngineCallback have been created they are sent to this method which will
-       /// post the build requests to the parent engine and then wait on the results to come back.
-       /// This method uses either a breadthFirst or depthFirst traversal strategy when sending buildRequests to the parent engine.
-       /// This method will start in breadthFirst traversal. It will continue to use this strategy until one of two events occur:
-       ///     1. The parent node sents a message indicating the TEM should switch to depthFirst traversal.
-       ///     2. The number of buildRequests is larger than the batchRequestSize.
-       /// In both of these cases the system will go from a breadthFirstTraversal to a depthFirst Traversal. In the second case
-       /// a message will be sent to the parent engine to switch the system to depthFirst traversal as the system is starting to
-       /// be overloaded with work.
-       /// In a depth first strategy the buildRequests will be sent to the parent engine one at a time and waiting for results for
-       /// each buildRequest sent. In a breadthFirst traversal strategy some number of the buildrequests will be sent to the parent engine
-       /// in a batch of requests. The system will then wait on the results of ALL the build requests sent before continuing
-       /// to send more build requests.
-       /// </summary>
-       private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal, BuildRequest[] buildRequests)
+        /// <summary>
+        /// Once the buildRequests from the EngineCallback have been created they are sent to this method which will
+        /// post the build requests to the parent engine and then wait on the results to come back.
+        /// This method uses either a breadthFirst or depthFirst traversal strategy when sending buildRequests to the parent engine.
+        /// This method will start in breadthFirst traversal. It will continue to use this strategy until one of two events occur:
+        ///     1. The parent node sents a message indicating the TEM should switch to depthFirst traversal.
+        ///     2. The number of buildRequests is larger than the batchRequestSize.
+        /// In both of these cases the system will go from a breadthFirstTraversal to a depthFirst Traversal. In the second case
+        /// a message will be sent to the parent engine to switch the system to depthFirst traversal as the system is starting to
+        /// be overloaded with work.
+        /// In a depth first strategy the buildRequests will be sent to the parent engine one at a time and waiting for results for
+        /// each buildRequest sent. In a breadthFirst traversal strategy some number of the buildrequests will be sent to the parent engine
+        /// in a batch of requests. The system will then wait on the results of ALL the build requests sent before continuing
+        /// to send more build requests.
+        /// </summary>
+        private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal, BuildRequest[] buildRequests)
         {
             // If the traversal strategy is breadth first and the number of requests is less than the batchRequestSize
             // or if there is only 1 build request then send ALL build requests to the parent engine and wait on the results.
@@ -446,7 +446,7 @@ public void ExecuteTask(TaskExecutionState taskState)
             // If we running in single proc mode, we should execute this task on the current thread
             if (moduleMode == TaskExecutionModuleMode.SingleProcMode)
             {
-               taskState.ExecuteTask();
+                taskState.ExecuteTask();
             }
             else
             {
@@ -499,13 +499,13 @@ internal long LastTaskActivity()
             return DateTime.Now.Ticks;
         }
 
-        internal int[] GetWaitingTaskData(List<BuildRequest []> outstandingRequests)
+        internal int[] GetWaitingTaskData(List<BuildRequest[]> outstandingRequests)
         {
             if (moduleMode != TaskExecutionModuleMode.SingleProcMode)
             {
                 return workerThread.GetWaitingTasksData(outstandingRequests);
             }
-            return new int [0];
+            return new int[0];
         }
 
         internal void Shutdown()
@@ -572,9 +572,9 @@ internal void WaitForZeroActiveThreadCount()
         /// </summary>
         internal TaskExecutionModuleMode GetExecutionModuleMode()
         {
-           // The Execution module mode is used to determine if they system is running under single proc or multiproc for the purposes of creating a new thread
-           // to execute tasks on.
-           return moduleMode;
+            // The Execution module mode is used to determine if they system is running under single proc or multiproc for the purposes of creating a new thread
+            // to execute tasks on.
+            return moduleMode;
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionState.cs b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
index 6d8bc34dbb5..7914b31edfb 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionState.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
@@ -169,7 +169,7 @@ internal virtual void ExecuteTask()
                 {
                     taskExecutedSuccessfully =
                       TaskEngineExecuteTask
-                        (   taskEngine,
+                        (taskEngine,
                             TaskExecutionMode.ExecuteTaskAndGatherOutputs,
                             lookupForExecution
                         );
@@ -230,7 +230,7 @@ Lookup lookup
                  );
         }
         #endregion
-  
+
         #endregion
 
         #region Fields set by the Engine thread
@@ -239,7 +239,7 @@ Lookup lookup
 
         private Lookup lookupForInference;
         private Lookup lookupForExecution;
-        
+
         private ITaskHost hostObject;
         private string projectFileOfTaskNode;
         private string parentProjectFullFileName;
diff --git a/src/Deprecated/Engine/Engine/TaskOutput.cs b/src/Deprecated/Engine/Engine/TaskOutput.cs
index 472c259da4f..f1b1a41a96b 100644
--- a/src/Deprecated/Engine/Engine/TaskOutput.cs
+++ b/src/Deprecated/Engine/Engine/TaskOutput.cs
@@ -81,7 +81,7 @@ internal TaskOutput(XmlElement node)
                 *  if PropertyName is specified, then ItemName cannot be specified
                 *  only Condition is truly optional
                 */
-            ProjectErrorUtilities.VerifyThrowInvalidProject((this.taskParameterAttribute != null) && (requiredData == 1), 
+            ProjectErrorUtilities.VerifyThrowInvalidProject((this.taskParameterAttribute != null) && (requiredData == 1),
                 node, "InvalidTaskOutputSpecification", taskName);
         }
 
diff --git a/src/Deprecated/Engine/Engine/TaskRegistry.cs b/src/Deprecated/Engine/Engine/TaskRegistry.cs
index ff97839c4c7..d690186d521 100644
--- a/src/Deprecated/Engine/Engine/TaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/TaskRegistry.cs
@@ -111,13 +111,13 @@ out LoadedType taskClass
             }
 
             Hashtable cachedTaskClasses = exactMatchRequired ? this.cachedTaskClassesWithExactMatch : this.cachedTaskClassesWithFuzzyMatch;
-            
+
             if (cachedTaskClasses.Contains(taskName))
             {
                 // Caller has asked us before for this same task name, and for the same value of "bool exactMatchRequired".
                 // Return whatever the previous result was, even if it was null.   Why would the result be different than
                 // it was before?  NOTE:  Hash tables CAN have "null" as their value, and this still returns "true" for Contains(...).
-                taskClass = (LoadedType) cachedTaskClasses[taskName];
+                taskClass = (LoadedType)cachedTaskClasses[taskName];
             }
             else
             {
@@ -256,7 +256,7 @@ out LoadedType taskClass
 
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, taskNode, "TaskLoadFailure", taskName, assembly.ToString(), e.Message);
                 }
-                
+
                 if (taskClass != null)
                 {
                     return true;
@@ -276,10 +276,10 @@ out LoadedType taskClass
         public void RegisterTask(UsingTask usingTask, Expander expander, EngineLoggingServices loggingServices, BuildEventContext buildEventContext)
         {
             if (
-                // if the <UsingTask> tag doesn't have a condition on it
+                    // if the <UsingTask> tag doesn't have a condition on it
                     (usingTask.Condition == null)
                     ||
-                // or if the condition holds
+                    // or if the condition holds
                     Utilities.EvaluateCondition(usingTask.Condition, usingTask.ConditionAttribute, expander,
                         null, ParserOptions.AllowProperties | ParserOptions.AllowItemLists, loggingServices, buildEventContext)
                 )
diff --git a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
index 44438b6658b..175e0ced7b8 100644
--- a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
@@ -254,7 +254,7 @@ private bool WaitAnyFast(NodeLoopExecutionMode executionMode, out int index)
         /// </summary>
         /// <param name="executionMode">Current execution mode</param>
         /// <returns>Array of handles to wait on</returns>
-        private WaitHandle [] GetHandlesArray( NodeLoopExecutionMode executionMode )
+        private WaitHandle[] GetHandlesArray(NodeLoopExecutionMode executionMode)
         {
             WaitHandle[] waitHandles = null;
 
@@ -307,7 +307,7 @@ private void NodeActionLoop
         (
             NodeLoopExecutionMode executionMode,
             int handleId,
-            BuildResult [] buildResults
+            BuildResult[] buildResults
         )
         {
             // Create an array of event to the node thread responds
@@ -350,7 +350,7 @@ BuildResult [] buildResults
                     continueExecution = false;
                 }
                 // New work item has appeared in the queue
-                else if (eventType == 1 && executionMode != NodeLoopExecutionMode.WaitingPassiveThread )
+                else if (eventType == 1 && executionMode != NodeLoopExecutionMode.WaitingPassiveThread)
                 {
                     ErrorUtilities.VerifyThrow(
                                     executionMode == NodeLoopExecutionMode.WaitingActiveThread ||
@@ -499,7 +499,7 @@ internal void WaitForResults
         (
             int handleId,
             BuildResult[] buildResults,
-            BuildRequest [] buildRequests
+            BuildRequest[] buildRequests
         )
         {
             TaskWorkerThread workerThread = GetWorkerThreadForHandleId(handleId);
@@ -519,7 +519,7 @@ BuildRequest [] buildRequests
         }
 
 
-        internal int [] GetWaitingTasksData(List<BuildRequest[]> outstandingRequests)
+        internal int[] GetWaitingTasksData(List<BuildRequest[]> outstandingRequests)
         {
             int[] waitingTasksArray;
             lock (waitingTasks)
@@ -548,7 +548,7 @@ internal int [] GetWaitingTasksData(List<BuildRequest[]> outstandingRequests)
             return waitingTasksArray;
         }
 
-        internal void PostWorkItem( TaskExecutionState workItem)
+        internal void PostWorkItem(TaskExecutionState workItem)
         {
             lock (workItemQueue)
             {
@@ -557,7 +557,7 @@ internal void PostWorkItem( TaskExecutionState workItem)
             }
         }
 
-        internal void PostBuildResult( BuildResult buildResult)
+        internal void PostBuildResult(BuildResult buildResult)
         {
             TaskWorkerThread workerThread = GetWorkerThreadForHandleId(buildResult.HandleId);
 
diff --git a/src/Deprecated/Engine/Engine/Toolset.cs b/src/Deprecated/Engine/Engine/Toolset.cs
index 6e96c01f231..f2f8dbd45cb 100644
--- a/src/Deprecated/Engine/Engine/Toolset.cs
+++ b/src/Deprecated/Engine/Engine/Toolset.cs
@@ -80,7 +80,7 @@ private set
                 // they don't end up with a double-backslash in the middle.  (It doesn't
                 // technically hurt anything, but it doesn't look nice.)
                 string toolsPathToUse = value;
-                
+
                 if (FileUtilities.EndsWithSlash(toolsPathToUse))
                 {
                     string rootPath = Path.GetPathRoot(Path.GetFullPath(toolsPathToUse));
diff --git a/src/Deprecated/Engine/Engine/ToolsetCollection.cs b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
index f269f8f34a0..b730cd6cad8 100644
--- a/src/Deprecated/Engine/Engine/ToolsetCollection.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
@@ -129,7 +129,7 @@ public void Add(Toolset item)
             }
             else
             {
-                toolsetMap.Add(item.ToolsVersion,item);
+                toolsetMap.Add(item.ToolsVersion, item);
             }
 
             // The parent engine needs to handle this as well
diff --git a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
index a1d7e31e005..401803ec18c 100644
--- a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
@@ -104,11 +104,11 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
                 {
                     InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location);
                 }
-                
+
                 yield return new PropertyDefinition(propertyElement.Name, propertyElement.Value, location);
             }
         }
-        
+
         /// <summary>
         /// Reads the application configuration file.
         /// NOTE: this is abstracted into a method to support unit testing GetToolsetDataFromConfiguration().
@@ -156,8 +156,8 @@ private ToolsetConfigurationSection ConfigurationSection
                     {
                         string location = ResourceUtilities.FormatResourceString
                                           (
-                                             "ConfigFileLocation", 
-                                             ex.Filename, 
+                                             "ConfigFileLocation",
+                                             ex.Filename,
                                              ex.Line
                                           );
 
@@ -294,7 +294,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
 
                 throw new ConfigurationErrorsException(message, element.ElementInformation.Source, element.ElementInformation.LineNumber);
             }
-            
+
             previouslySeenToolsVersions.Add(toolsVersion, string.Empty);
         }
 
@@ -410,7 +410,7 @@ internal sealed class PropertyElementCollection : ConfigurationElementCollection
             /// won't perform this check without respect for case.
             /// </summary>
             private Dictionary<string, string> previouslySeenPropertyNames = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            
+
             /// <summary>
             /// Creates a new element
             /// </summary>
@@ -462,7 +462,7 @@ private void UpdatePropertyNameMap(ConfigurationElement element)
 
                 previouslySeenPropertyNames.Add(propertyName, string.Empty);
             }
-            
+
             /// <summary>
             /// Gets the key for the element
             /// </summary>
diff --git a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
index 4935eaea24e..dc2c2c55d86 100644
--- a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
@@ -27,7 +27,7 @@ internal class ToolsetRegistryReader : ToolsetReader
     {
         // Registry location for storing tools version dependent data for msbuild
         private const string msbuildRegistryPath = @"SOFTWARE\Microsoft\MSBuild";
-        
+
         // Cached registry wrapper at root of the msbuild entries
         private RegistryKeyWrapper msbuildRegistryWrapper;
 
@@ -35,7 +35,7 @@ internal class ToolsetRegistryReader : ToolsetReader
         /// Default constructor
         /// </summary>
         internal ToolsetRegistryReader()
-            : this (new RegistryKeyWrapper(msbuildRegistryPath))
+            : this(new RegistryKeyWrapper(msbuildRegistryPath))
         {
         }
 
@@ -46,7 +46,7 @@ internal ToolsetRegistryReader()
         internal ToolsetRegistryReader(RegistryKeyWrapper msbuildRegistryWrapper)
         {
             error.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
-       
+
             this.msbuildRegistryWrapper = msbuildRegistryWrapper;
         }
 
@@ -105,7 +105,7 @@ protected override string DefaultToolsVersion
         protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string toolsVersion)
         {
             RegistryKeyWrapper toolsVersionWrapper = null;
-            
+
             try
             {
                 toolsVersionWrapper = msbuildRegistryWrapper.OpenSubKey("ToolsVersions\\" + toolsVersion);
@@ -123,7 +123,7 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
                 {
                     InvalidToolsetDefinitionException.Throw("PropertyNameInRegistryHasZeroLength", toolsVersionWrapper.Name);
                 }
-                
+
                 try
                 {
                     propertyValue = GetValue(toolsVersionWrapper, propertyName);
@@ -136,7 +136,7 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
                 yield return new PropertyDefinition(propertyName, propertyValue, toolsVersionWrapper.Name + "@" + propertyName);
             }
         }
-        
+
         /// <summary>
         /// Reads a string value from the specified registry key
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/ToolsetState.cs b/src/Deprecated/Engine/Engine/ToolsetState.cs
index c06056b601f..20b5cb37714 100644
--- a/src/Deprecated/Engine/Engine/ToolsetState.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetState.cs
@@ -102,7 +102,7 @@ internal string ToolsPath
         /// </summary>
         internal BuildPropertyGroup BuildProperties
         {
-            get 
+            get
             {
                 return this.toolset.BuildProperties;
             }
@@ -188,7 +188,7 @@ private void RegisterDefaultTasks(BuildEventContext buildEventContext)
 
                         if (defaultTasksFiles.Length == 0)
                         {
-                            loggingServices.LogWarning( buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
+                            loggingServices.LogWarning(buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                                 "DefaultTasksFileLoadFailureWarning",
                                 defaultTasksFilePattern, toolset.ToolsPath, String.Empty);
                         }
@@ -196,7 +196,7 @@ private void RegisterDefaultTasks(BuildEventContext buildEventContext)
                     // handle security problems when finding the default tasks files
                     catch (UnauthorizedAccessException e)
                     {
-                        loggingServices.LogWarning( buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
+                        loggingServices.LogWarning(buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                             "DefaultTasksFileLoadFailureWarning",
                             defaultTasksFilePattern, toolset.ToolsPath, e.Message);
                     }
@@ -208,7 +208,7 @@ private void RegisterDefaultTasks(BuildEventContext buildEventContext)
                             throw;
                         }
 
-                        loggingServices.LogWarning( buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
+                        loggingServices.LogWarning(buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                             "DefaultTasksFileLoadFailureWarning",
                             defaultTasksFilePattern, toolset.ToolsPath, e.Message);
                     }
@@ -237,7 +237,7 @@ private void RegisterDefaultTasks(BuildEventContext buildEventContext)
                                     // the <Project> tag can only the XML namespace -- no other attributes
                                     foreach (XmlAttribute projectAttribute in topLevelNode.Attributes)
                                     {
-                                        ProjectXmlUtilities.VerifyThrowProjectInvalidAttribute(projectAttribute.Name == XMakeAttributes.xmlns, projectAttribute); 
+                                        ProjectXmlUtilities.VerifyThrowProjectInvalidAttribute(projectAttribute.Name == XMakeAttributes.xmlns, projectAttribute);
                                     }
 
                                     // look at all the child tags of the <Project> root tag we found
diff --git a/src/Deprecated/Engine/Engine/UsingTask.cs b/src/Deprecated/Engine/Engine/UsingTask.cs
index 84dfde06690..6c0664ed88d 100644
--- a/src/Deprecated/Engine/Engine/UsingTask.cs
+++ b/src/Deprecated/Engine/Engine/UsingTask.cs
@@ -81,7 +81,7 @@ public string AssemblyFile
         /// </summary>
         internal XmlAttribute AssemblyFileAttribute
         {
-            get { return this.assemblyFileAttribute; } 
+            get { return this.assemblyFileAttribute; }
         }
 
         private XmlAttribute conditionAttribute = null;
@@ -174,12 +174,12 @@ internal UsingTask(XmlElement usingTaskNode, bool isImported)
                     case XMakeAttributes.assemblyFile:
                         assemblyFileAttribute = usingTaskAttribute;
                         break;
-                        
+
                     // ignore any RequiredRuntime XML attribute
                     // (we'll make this actually do something when we run on a CLR other than v2.0)
                     case XMakeAttributes.requiredRuntime:
                         // Do nothing
-                        break;                       
+                        break;
 
                     // get the condition, if any
                     case XMakeAttributes.condition:
@@ -211,7 +211,7 @@ internal UsingTask(XmlElement usingTaskNode, bool isImported)
                         break;
 
                     default:
-                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(usingTaskAttribute); 
+                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(usingTaskAttribute);
                         break;
                 }
             }
diff --git a/src/Deprecated/Engine/Engine/UsingTaskCollection.cs b/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
index a19c668c3b8..3a563243f3b 100644
--- a/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
+++ b/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
@@ -68,10 +68,10 @@ public void CopyTo(Array array, int index)
         /// <owner>LukaszG</owner>
         public int Count
         {
-            get 
+            get
             {
                 ErrorUtilities.VerifyThrow(this.usingTasks != null, "UsingTaskCollection's ArrayList not initialized!");
-                return this.usingTasks.Count; 
+                return this.usingTasks.Count;
             }
         }
 
@@ -81,10 +81,10 @@ public int Count
         /// <owner>LukaszG</owner>
         public bool IsSynchronized
         {
-            get 
+            get
             {
                 ErrorUtilities.VerifyThrow(this.usingTasks != null, "UsingTaskCollection's ArrayList not initialized!");
-                return this.usingTasks.IsSynchronized; 
+                return this.usingTasks.IsSynchronized;
             }
         }
 
@@ -137,7 +137,7 @@ internal UsingTask this[int index]
             get
             {
                 ErrorUtilities.VerifyThrow(this.usingTasks != null, "UsingTaskCollection's ArrayList not initialized!");
-                return (UsingTask) this.usingTasks[index];
+                return (UsingTask)this.usingTasks[index];
             }
         }
 
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index 79159f25c07..6b25738067b 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -55,10 +55,10 @@ string rightValueExpanded               // The fully expanded value on the right
                 // and we don't touch the table.
 
                 // Split up the leftValue into pieces based on the vertical bar character.
-                string[] leftValuePieces = leftValue.Split(new char[]{'|'});
+                string[] leftValuePieces = leftValue.Split(new char[] { '|' });
 
                 // Loop through each of the pieces.
-                for (int i = 0 ; i < leftValuePieces.Length ; i++)
+                for (int i = 0; i < leftValuePieces.Length; i++)
                 {
                     Match singlePropertyMatch = singlePropertyRegex.Match(leftValuePieces[i]);
 
@@ -91,8 +91,8 @@ string rightValueExpanded               // The fully expanded value on the right
                         string propertyName = singlePropertyMatch.Groups[1].ToString();
 
                         // Get the string collection for this property name, if one already exists.
-                        StringCollection conditionedPropertyValues = 
-                            (StringCollection) conditionedPropertiesTable[propertyName];
+                        StringCollection conditionedPropertyValues =
+                            (StringCollection)conditionedPropertiesTable[propertyName];
 
                         // If this property is not already represented in the table, add a new entry
                         // for it.
@@ -124,10 +124,10 @@ string rightValueExpanded               // The fully expanded value on the right
          */
         internal static void GatherReferencedPropertyNames
         (
-            string          condition,                  // Can be null
-            XmlAttribute    conditionAttribute,         // XML attribute on which the condition is evaluated
-            Expander        expander,                   // The set of properties to use for expansion
-            Hashtable       conditionedPropertiesTable  // Can be null
+            string condition,                  // Can be null
+            XmlAttribute conditionAttribute,         // XML attribute on which the condition is evaluated
+            Expander expander,                   // The set of properties to use for expansion
+            Hashtable conditionedPropertiesTable  // Can be null
         )
         {
             EvaluateCondition(condition, conditionAttribute, expander, conditionedPropertiesTable, ParserOptions.AllowProperties | ParserOptions.AllowItemLists, null, null);
@@ -137,9 +137,9 @@ Hashtable       conditionedPropertiesTable  // Can be null
         // and parser options
         private static volatile Hashtable[] cachedExpressionTrees = new Hashtable[8 /* == ParserOptions.AllowAll*/]
             {
-                new Hashtable(StringComparer.OrdinalIgnoreCase), new Hashtable(StringComparer.OrdinalIgnoreCase), 
-                new Hashtable(StringComparer.OrdinalIgnoreCase), new Hashtable(StringComparer.OrdinalIgnoreCase), 
-                new Hashtable(StringComparer.OrdinalIgnoreCase), new Hashtable(StringComparer.OrdinalIgnoreCase), 
+                new Hashtable(StringComparer.OrdinalIgnoreCase), new Hashtable(StringComparer.OrdinalIgnoreCase),
+                new Hashtable(StringComparer.OrdinalIgnoreCase), new Hashtable(StringComparer.OrdinalIgnoreCase),
+                new Hashtable(StringComparer.OrdinalIgnoreCase), new Hashtable(StringComparer.OrdinalIgnoreCase),
                 new Hashtable(StringComparer.OrdinalIgnoreCase), new Hashtable(StringComparer.OrdinalIgnoreCase)
             };
 
@@ -241,7 +241,7 @@ BuildEventContext buildEventContext
             Hashtable cachedExpressionTreesForCurrentOptions = cachedExpressionTrees[(int)itemListOptions];
 
             // Try and see if we have an expression tree for this condition already
-            GenericExpressionNode parsedExpression = (GenericExpressionNode) cachedExpressionTreesForCurrentOptions[condition];
+            GenericExpressionNode parsedExpression = (GenericExpressionNode)cachedExpressionTreesForCurrentOptions[condition];
 
             if (parsedExpression == null)
             {
@@ -303,7 +303,7 @@ internal static void SetXmlNodeInnerContents(XmlNode node, string s)
                     // XML.  Eat the exception and fall through below ...
                 }
             }
-                
+
             // The value does not contain valid XML markup.  Store it as text, so it gets 
             // escaped properly.
             node.InnerText = s;
diff --git a/src/Deprecated/Engine/Engine/XmlSearcher.cs b/src/Deprecated/Engine/Engine/XmlSearcher.cs
index 94cb2516e44..516ba08ad36 100644
--- a/src/Deprecated/Engine/Engine/XmlSearcher.cs
+++ b/src/Deprecated/Engine/Engine/XmlSearcher.cs
@@ -67,7 +67,7 @@ out int foundColumnNumber
 
             // Now that we know what element/attribute number we're searching for, find
             // it in the Xml document on disk, and grab the line/column number.
-            return GetLineColumnByNodeNumber(fileName, elementNumber, attributeNumber, 
+            return GetLineColumnByNodeNumber(fileName, elementNumber, attributeNumber,
                 out foundLineNumber, out foundColumnNumber);
         }
 
@@ -116,7 +116,7 @@ out int attributeNumber
             }
             else if (xmlNodeToFind.NodeType == XmlNodeType.Attribute)
             {
-                elementToFind = ((XmlAttribute) xmlNodeToFind).OwnerElement;
+                elementToFind = ((XmlAttribute)xmlNodeToFind).OwnerElement;
                 ErrorUtilities.VerifyThrow(elementToFind != null, "How can an xml attribute not have a parent?");
             }
             else
@@ -275,7 +275,7 @@ out int foundColumnNumber
                                     foundLineNumber = reader.LineNumber;
                                     foundColumnNumber = reader.LinePosition;
 
-                                    if (reader.NodeType == XmlNodeType.Element) 
+                                    if (reader.NodeType == XmlNodeType.Element)
                                     {
                                         // Do a minus-one here, because the XmlTextReader points us at the first
                                         // letter of the tag name, whereas we would prefer to point at the opening
@@ -284,7 +284,7 @@ out int foundColumnNumber
                                         foundColumnNumber--;
                                     }
                                 }
-                                else if (reader.MoveToFirstAttribute()) 
+                                else if (reader.MoveToFirstAttribute())
                                 {
                                     // Caller wants a particular attribute within the element,
                                     // and the element does have 1 or more attributes.  So let's 
@@ -292,7 +292,7 @@ out int foundColumnNumber
                                     int currentXmlAttributeNumber = 0;
 
                                     // Loop through all the XML attributes on the current element.
-                                    do 
+                                    do
                                     {
                                         // Bump the current attribute number and check to see if this
                                         // is the one.
@@ -313,7 +313,7 @@ out int foundColumnNumber
                     }
                 }
             }
-            catch (XmlException) 
+            catch (XmlException)
             {
                 // Eat the exception.  If anything fails, we simply don't surface the line/column number.
             }
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index c215f8743aa..edac5eb116f 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -113,7 +113,7 @@ bool initializationException
         private InternalLoggerException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
-            this.e = (BuildEventArgs) info.GetValue("e", typeof(BuildEventArgs));
+            this.e = (BuildEventArgs)info.GetValue("e", typeof(BuildEventArgs));
             this.errorCode = info.GetString("errorCode");
             this.helpKeyword = info.GetString("helpKeyword");
             this.initializationException = info.GetBoolean("initializationException");
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index 2926a37aa7a..0cda69d74f0 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -133,7 +133,7 @@ public InvalidProjectFileException
             string errorSubcategory,
             string errorCode,
             string helpKeyword
-        ) : 
+        ) :
             base(message)
         {
             ErrorUtilities.VerifyThrowArgumentLength(message, nameof(message));
@@ -174,7 +174,7 @@ public InvalidProjectFileException
             string errorSubcategory,
             string errorCode,
             string helpKeyword
-        ) : 
+        ) :
             base(message)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
diff --git a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
index 30e5f1a4c6a..eacdb795878 100644
--- a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
@@ -154,7 +154,7 @@ params object[] args
             string errorCode;
             string helpKeyword;
             string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, resourceName, args);
-            
+
             throw new InvalidToolsetDefinitionException(message, errorCode, innerException);
         }
 
diff --git a/src/Deprecated/Engine/Errors/RegistryException.cs b/src/Deprecated/Engine/Errors/RegistryException.cs
index 822064f0f61..8c4957f9bc0 100644
--- a/src/Deprecated/Engine/Errors/RegistryException.cs
+++ b/src/Deprecated/Engine/Errors/RegistryException.cs
@@ -51,16 +51,16 @@ public RegistryException(string message, string source)
             base.Source = source;
         }
 
-	/// <summary>
+        /// <summary>
         /// Since this class implements Iserializable this constructor is required to be implemented.
         /// </summary>
-	protected RegistryException(SerializationInfo info, StreamingContext context) : base(info, context)
+        protected RegistryException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
             // We don't have any reason at the moment to do any custom serizlization or deserialization, this methods was added
             // to conform to the implementation of the standard constructors for ISerializable classes
-        }	
-	        	
-	/// <summary>
+        }
+
+        /// <summary>
         /// Constructor that takes a string description of the registry
         /// key or value causing the error.
         /// </summary>
diff --git a/src/Deprecated/Engine/Introspector/Introspector.cs b/src/Deprecated/Engine/Introspector/Introspector.cs
index 203896320f5..78b0e130fcf 100644
--- a/src/Deprecated/Engine/Introspector/Introspector.cs
+++ b/src/Deprecated/Engine/Introspector/Introspector.cs
@@ -15,10 +15,10 @@ internal class Introspector
         #region Constructors
         internal Introspector(Engine parentEngine, ProjectManager projectManager, NodeManager nodeManager)
         {
-            this.parentEngine   = parentEngine;
+            this.parentEngine = parentEngine;
             this.projectManager = projectManager;
-            this.nodeManager    = nodeManager;
-            this.ignoreTimeout  = 0;
+            this.nodeManager = nodeManager;
+            this.ignoreTimeout = 0;
         }
         #endregion
 
@@ -31,7 +31,7 @@ internal Introspector(Engine parentEngine, ProjectManager projectManager, NodeMa
         /// to break it. If no cause for deadlock can be determined the system is shutdown.
         /// </summary>
         /// <returns>New inactivity timeout</returns>
-        internal int DetectDeadlock( int queueCounts, long lastLoopActivity, int currentTimeout)
+        internal int DetectDeadlock(int queueCounts, long lastLoopActivity, int currentTimeout)
         {
             // Don't try to detect deadlock in single threaded mode or on a child node
             if (parentEngine.Router.ChildMode || parentEngine.Router.SingleThreadedMode)
@@ -161,7 +161,7 @@ internal int DetectDeadlock( int queueCounts, long lastLoopActivity, int current
 
             // There was some activity between previous and current status checks on the local node
             if (localStatus.LastLoopActivity != previousLocalStatus.LastLoopActivity ||
-                localStatus.LastTaskActivity != previousLocalStatus.LastTaskActivity )
+                localStatus.LastTaskActivity != previousLocalStatus.LastTaskActivity)
             {
                 previousStatus = nodeStatus;
                 previousLocalStatus = localStatus;
@@ -214,7 +214,7 @@ private void AddTargetStatesToCycleDetector(NodeStatus[] nodeStatus, TargetCycle
         {
             for (int i = 0; i < nodeStatus.Length; i++)
             {
-               cycleDetector.AddTargetsToGraph(nodeStatus[i].StateOfInProgressTargets);
+                cycleDetector.AddTargetsToGraph(nodeStatus[i].StateOfInProgressTargets);
             }
         }
 
@@ -256,7 +256,7 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
         /// </summary>
         internal void SystemShutdown()
         {
-	    ErrorUtilities.LaunchMsBuildDebuggerOnFatalError();
+            ErrorUtilities.LaunchMsBuildDebuggerOnFatalError();
             nodeManager.ShutdownNodes(Node.NodeShutdownLevel.ErrorShutdown);
         }
 
@@ -272,12 +272,12 @@ internal void SystemShutdown()
         /// </summary>
         internal void BreakCycle(TargetInProgessState child, TargetInProgessState parent)
         {
-            ErrorUtilities.VerifyThrow( child.TargetId.nodeId == parentEngine.NodeId,
+            ErrorUtilities.VerifyThrow(child.TargetId.nodeId == parentEngine.NodeId,
                                         "Expect the child target to be on the node");
 
             Project parentProject = projectManager.GetProject(child.TargetId.projectId);
 
-            ErrorUtilities.VerifyThrow(parentProject  != null,
+            ErrorUtilities.VerifyThrow(parentProject != null,
                                         "Expect the parent project to be on the node");
 
             Target childTarget = parentProject.Targets[child.TargetId.name];
@@ -345,7 +345,7 @@ private int calculateNewLoopTimeout(int currentTimeout)
         {
             if (currentTimeout < maxLoopTimeout)
             {
-                currentTimeout = 2*currentTimeout;
+                currentTimeout = 2 * currentTimeout;
             }
 
             return currentTimeout;
diff --git a/src/Deprecated/Engine/Introspector/NodeStatus.cs b/src/Deprecated/Engine/Introspector/NodeStatus.cs
index f615afc8dc9..14d180ce1b5 100644
--- a/src/Deprecated/Engine/Introspector/NodeStatus.cs
+++ b/src/Deprecated/Engine/Introspector/NodeStatus.cs
@@ -153,7 +153,7 @@ internal bool HasExited
                 return this.hasExited;
             }
         }
-        
+
         /// <summary>
         /// The token of the request to which this is a response (-1 if status is unrequested)
         /// </summary>
@@ -179,7 +179,7 @@ internal int QueueDepth
         /// <summary>
         /// The state of the targets which are in progress on the node
         /// </summary>
-        internal TargetInProgessState [] StateOfInProgressTargets
+        internal TargetInProgessState[] StateOfInProgressTargets
         {
             get
             {
@@ -224,10 +224,10 @@ internal bool TraversalType
 
         #region Data
         private long statusTimeStamp; // the timestamp indicating when this status structure was filled out
-        private int  requestId; // the token of the request to which this is a response (-1 if status is unrequested)
+        private int requestId; // the token of the request to which this is a response (-1 if status is unrequested)
         private bool isActive; // is the node active
         private bool isLaunchInProgress; // is the node in the process of being launched
-        private int  queueDepth; // the number of build request in the node's queue
+        private int queueDepth; // the number of build request in the node's queue
         private long lastTaskActivityTimeStamp; // the time stamp of the last task activity
         private long lastEngineActivityTimeStamp; // the time stamp of the last engine activity
         private TargetInProgessState[] stateOfInProgressTargets;
@@ -266,8 +266,8 @@ internal void WriteToStream(BinaryWriter writer)
                     }
                     else
                     {
-                       writer.Write((byte)1);
-                       stateOfInProgressTargets[i].WriteToStream(writer);
+                        writer.Write((byte)1);
+                        stateOfInProgressTargets[i].WriteToStream(writer);
                     }
                 }
             }
diff --git a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
index 90d499820e2..5e5742c5d4d 100644
--- a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
+++ b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
@@ -32,7 +32,7 @@ internal TargetCycleDetector(EngineLoggingServices engineLoggingService, EngineC
             dependencyGraph = new Hashtable();
             outstandingExternalRequests = new Hashtable();
             cycleParent = null;
-            cycleChild  = null;
+            cycleChild = null;
         }
         #endregion
 
@@ -179,7 +179,7 @@ private void LinkCrossNodeBuildRequests()
                 TargetInProgessState.TargetIdWrapper[] parentsForBuildRequests =
                     new TargetInProgessState.TargetIdWrapper[node.targetState.ParentBuildRequests.Count];
 
-                for (int j = 0; j < node.targetState.ParentBuildRequests.Count; j++ )
+                for (int j = 0; j < node.targetState.ParentBuildRequests.Count; j++)
                 {
                     BuildRequest buildRequest = node.targetState.ParentBuildRequests[j];
                     int nodeIndex = buildRequest.NodeIndex;
@@ -210,9 +210,9 @@ private void LinkCrossNodeBuildRequests()
 
                             if (nextExecutionContext is RequestRoutingContext)
                             {
-                                nodeIndex   = nextExecutionContext.NodeIndex;
+                                nodeIndex = nextExecutionContext.NodeIndex;
                                 handleId = routingContext.ParentHandleId;
-                                requestId   = routingContext.ParentRequestId;
+                                requestId = routingContext.ParentRequestId;
                             }
                         }
                         else
@@ -293,10 +293,10 @@ private void FindBackEdges(GraphNode node)
             for (int i = 0; i < node.children.Count; i++)
             {
                 // Check for a back edge
-                if (node.children[i].traversalIndex > node.traversalIndex )
+                if (node.children[i].traversalIndex > node.traversalIndex)
                 {
                     cycleParent = node.targetState;
-                    cycleChild  = node.children[i].targetState;
+                    cycleChild = node.children[i].targetState;
                     DumpCycleSequence(node.children[i], node);
                     break;
                 }
@@ -304,7 +304,7 @@ private void FindBackEdges(GraphNode node)
                 if (node.children[i].targetState.TargetId == node.targetState.TargetId)
                 {
                     cycleParent = node.targetState;
-                    cycleChild  = node.targetState;
+                    cycleChild = node.targetState;
                     break;
                 }
             }
@@ -327,7 +327,7 @@ private void DumpCycleSequence(GraphNode parent, GraphNode child)
 
         private bool DumpCycleSequenceOutput(GraphNode parent, GraphNode child, BuildEventContext buildEventContext)
         {
-            if (parent == child )
+            if (parent == child)
             {
                 engineLoggingService.LogComment(buildEventContext, "cycleTraceTitle");
                 engineLoggingService.LogComment
@@ -408,7 +408,7 @@ internal GraphNode(TargetInProgessState targetState)
             internal bool isRoot;
             internal int traversalIndex;
 
-            internal const int InvalidIndex    = -1;
+            internal const int InvalidIndex = -1;
             internal const int InProgressIndex = -2;
             #endregion
         }
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index 6efeab91d85..1256b3607ff 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -24,10 +24,10 @@ internal TargetInProgessState()
         internal TargetInProgessState
         (
             EngineCallback engineCallback,
-            Target target, 
+            Target target,
             List<ProjectBuildState> waitingBuildStates,
             ProjectBuildState initiatingRequest,
-            BuildRequest [] outstandingBuildRequests,
+            BuildRequest[] outstandingBuildRequests,
             string projectName
         )
         {
@@ -172,7 +172,7 @@ internal TargetIdWrapper FindParentTarget
         (
             EngineCallback engineCallback,
             ProjectBuildState buildContext,
-            Target target, 
+            Target target,
             out BuildRequest parentRequest
         )
         {
@@ -310,7 +310,7 @@ ProjectBuildState projectBuildState
 
         // Mapping between list of build requests waiting on the current target and targets
         // from which these build reuquests originated
-        private TargetIdWrapper [] parentTargetsForBuildRequests;
+        private TargetIdWrapper[] parentTargetsForBuildRequests;
 
         // Name of the project containing the target (only used for logging)
         private string projectName;
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index b6f4df29c36..dd87ed172ec 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -496,7 +496,7 @@ internal BuildItem(XmlElement itemElement, bool importedFromAnotherProject, bool
         /// This constructor creates a new virtual (non-persisted) item based
         /// on a ITaskItem object that was emitted by a task.
         /// </summary>
-        public BuildItem(string itemName, ITaskItem taskItem) 
+        public BuildItem(string itemName, ITaskItem taskItem)
         {
             ErrorUtilities.VerifyThrowArgumentNull(taskItem, nameof(taskItem));
 
@@ -519,7 +519,7 @@ public BuildItem(string itemName, ITaskItem taskItem)
             rawSourceTable.Keys.CopyTo(keys, 0);
             foreach (string singleMetadataName in keys)
             {
-                string singleMetadataValue = (string) rawSourceTable[singleMetadataName];
+                string singleMetadataValue = (string)rawSourceTable[singleMetadataName];
                 rawSourceTable[singleMetadataName] = EscapingUtilities.Escape(singleMetadataValue);
             }
 
@@ -727,7 +727,7 @@ public int CustomMetadataCount
                 return GetCustomMetadataCount();
             }
         }
-        
+
         /// <summary>
         /// Read-only accessor for accessing the XML attribute for "Include".  Callers should
         /// never try and modify this.  Go through this.Include to change the include spec.
@@ -829,7 +829,7 @@ public string FinalItemSpec
         {
             get { return EscapingUtilities.UnescapeAll(FinalItemSpecEscaped); }
         }
-        
+
         /// <summary>
         /// Read-only accessor for the piece of the item's Include that resulted in
         /// this item, with properties expanded.
@@ -851,7 +851,7 @@ internal BuildItemGroup ParentPersistedItemGroup
 
             set
             {
-                ErrorUtilities.VerifyThrow( ((value == null) && (this.parentPersistedItemGroup != null)) || ((value != null) && (this.parentPersistedItemGroup == null)),
+                ErrorUtilities.VerifyThrow(((value == null) && (this.parentPersistedItemGroup != null)) || ((value != null) && (this.parentPersistedItemGroup == null)),
                     "Either new parent cannot be assigned because we already have a parent, or old parent cannot be removed because none exists.");
 
                 this.parentPersistedItemGroup = value;
@@ -875,7 +875,7 @@ internal BuildItem ParentPersistedItem
 
             set
             {
-                ErrorUtilities.VerifyThrow( ((value == null) && (this.parentPersistedItem != null)) || ((value != null) && (this.parentPersistedItem == null)),
+                ErrorUtilities.VerifyThrow(((value == null) && (this.parentPersistedItem != null)) || ((value != null) && (this.parentPersistedItem == null)),
                     "Either new parent cannot be assigned because we already have a parent, or old parent cannot be removed because none exists.");
 
                 this.parentPersistedItem = value;
@@ -894,7 +894,7 @@ internal BuildItemGroup ChildItems
             {
                 if (this.childItems == null)
                 {
-                    this.childItems = new BuildItemGroup ();
+                    this.childItems = new BuildItemGroup();
                 }
 
                 return this.childItems;
@@ -943,7 +943,7 @@ internal bool IsBackedUp
         /// 1) this method should return a clone of the metadata
         /// 2) writing to this dictionary should not be reflected in the underlying item.
         /// </remarks>
-        internal IDictionary CloneCustomMetadata() 
+        internal IDictionary CloneCustomMetadata()
         {
             IDictionary result = (IDictionary)this.evaluatedCustomMetadata.Clone();
             return MergeDefaultMetadata(result);
@@ -1061,11 +1061,11 @@ internal string ExtractRecursivePortionOfFinalItemSpecDirectory()
         /// Evaluates the item and returns a virtual group containing any resulting items.
         /// This allows an item to be evaluated without it belonging to an item group.
         /// </summary>
-        internal BuildItemGroup Evaluate(Expander expander, 
-                                        string baseDirectory, 
+        internal BuildItemGroup Evaluate(Expander expander,
+                                        string baseDirectory,
                                         bool expandMetadata,
                                         ParserOptions parserOptions,
-                                        EngineLoggingServices loggingServices, 
+                                        EngineLoggingServices loggingServices,
                                         BuildEventContext buildEventContext)
         {
             BuildItemGroup result = new BuildItemGroup();
@@ -1255,14 +1255,14 @@ public string GetMetadata(string metadataName)
             {
                 ErrorUtilities.VerifyThrow(this.unevaluatedCustomMetadata != null, "Item not initialized properly.  unevaluatedCustomMetadata is null.");
 
-                metadataValue = (string) this.unevaluatedCustomMetadata[metadataName];
+                metadataValue = (string)this.unevaluatedCustomMetadata[metadataName];
             }
 
             // If we don't have an explicit value for this metadata then try to find a default value
             if (metadataValue == null)
             {
                 metadataValue = GetDefaultMetadataValue(metadataName);
-            } 
+            }
 
             return metadataValue ?? String.Empty;
         }
@@ -1305,14 +1305,14 @@ internal string GetEvaluatedMetadataEscaped(string metadataName)
             {
                 ErrorUtilities.VerifyThrow(this.evaluatedCustomMetadata != null, "Item not initialized properly.  evaluatedCustomMetadata is null.");
 
-                metadataValue = (string) this.evaluatedCustomMetadata[metadataName];
+                metadataValue = (string)this.evaluatedCustomMetadata[metadataName];
             }
 
             // If we don't have an explicit value for this metadata then try to find a default value
             if (metadataValue == null)
             {
                 metadataValue = GetDefaultMetadataValue(metadataName);
-            }              
+            }
 
             return metadataValue ?? String.Empty;
         }
@@ -1564,7 +1564,7 @@ internal void RevertToPersistedMetadata()
                 evaluatedCustomMetadataBackup = null;
             }
         }
-        
+
         /// <summary>
         /// Sets an arbitrary metadata on the item element. These are metadata that the project author has placed on the item
         /// element that have no meaning to MSBuild. They are just arbitrary metadata that travel around with the BuildItem.
@@ -1645,7 +1645,7 @@ private string GetDefaultMetadataValue(string metadataName)
         /// <exception cref="InvalidOperationException">Thrown when the item-spec is not a path.</exception>
         private string GetItemSpecModifier(string modifier)
         {
-            string modifiedItemSpec = 
+            string modifiedItemSpec =
                 FileUtilities.GetItemSpecModifier(Project.PerThreadProjectDirectory, FinalItemSpecEscaped, modifier, ref itemSpecModifiers);
 
             if (modifiedItemSpec.Length == 0)
@@ -1901,7 +1901,7 @@ public BuildItem Clone()
         /// </summary>
         internal void UpdateBackingXml(BuildItemGroupChildXml backingXml)
         {
-            xml =  backingXml;
+            xml = backingXml;
             this.name = xml.Name;
         }
 
@@ -1928,15 +1928,15 @@ internal BuildItem VirtualClone(bool removeReferences)
                 definitionLibraryToClone = null;
             }
 
-           BuildItem virtualClone = 
-               new BuildItem
-               (
-                   null /* this is a virtual item with no backing XML */,
-                   name, Include,
-                   false, /* PERF NOTE: don't waste time creating a new custom metadata
+            BuildItem virtualClone =
+                new BuildItem
+                (
+                    null /* this is a virtual item with no backing XML */,
+                    name, Include,
+                    false, /* PERF NOTE: don't waste time creating a new custom metadata
                            * cache, because we're going to clone the current item's cache */
-                   definitionLibraryToClone
-               );
+                    definitionLibraryToClone
+                );
 
             virtualClone.SetEvaluatedItemSpecEscaped(evaluatedItemSpecEscaped);
             virtualClone.SetFinalItemSpecEscaped(FinalItemSpecEscaped);
@@ -1947,7 +1947,7 @@ internal BuildItem VirtualClone(bool removeReferences)
             virtualClone.recursivePortionOfFinalItemSpecDirectory = recursivePortionOfFinalItemSpecDirectory;
 
             ErrorUtilities.VerifyThrow(unevaluatedCustomMetadata != null && evaluatedCustomMetadata != null, "Item is not initialized properly.");
-             
+
             if (removeReferences)
             {
                 // The ItemDefinition is going to be cleared to remove a link between a project instance and the Item when it is in the cache of targetOutputs.
@@ -1961,8 +1961,8 @@ internal BuildItem VirtualClone(bool removeReferences)
                 // Cloning is cheap for CopyOnWriteHashtable so just always do it.
                 virtualClone.unevaluatedCustomMetadata = (CopyOnWriteHashtable)this.unevaluatedCustomMetadata.Clone();
                 virtualClone.evaluatedCustomMetadata = (CopyOnWriteHashtable)this.evaluatedCustomMetadata.Clone();
-           }
-   
+            }
+
             return virtualClone;
         }
 
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index ebb02833a72..94a827aa39f 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -388,11 +388,11 @@ internal void AddItem(BuildItem itemToAdd)
                 int insertionIndex = items.Count;
                 for (int i = 0; i < items.Count; i++)
                 {
-                    if ( String.Equals(itemToAdd.Name, items[i].Name, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(itemToAdd.Name, items[i].Name, StringComparison.OrdinalIgnoreCase))
                     {
                         insertionIndex = i + 1;
 
-                        if ( 0 > String.Compare(itemToAdd.Include, items[i].Include, StringComparison.OrdinalIgnoreCase))
+                        if (0 > String.Compare(itemToAdd.Include, items[i].Include, StringComparison.OrdinalIgnoreCase))
                         {
                             insertionIndex = i;
                             break;
@@ -597,7 +597,7 @@ public void Clear()
             {
                 MustNotBeImported();
 
-                foreach(BuildItem itemToRemove in items)
+                foreach (BuildItem itemToRemove in items)
                 {
                     XmlElement itemElement = itemToRemove.ItemElement;
                     MustHaveThisParentElement(itemToRemove);
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs b/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
index fa015ebcc36..408e4089ec1 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
@@ -21,7 +21,7 @@ internal class BuildItemGroupProxy : IEnumerable
         private BuildItemGroup backingItemGroup;
 
         private BuildItemGroupProxy()
-        { 
+        {
             // Do nothing
         }
 
diff --git a/src/Deprecated/Engine/Items/ItemExpander.cs b/src/Deprecated/Engine/Items/ItemExpander.cs
index dd60744cfc3..c77ab2dd34b 100644
--- a/src/Deprecated/Engine/Items/ItemExpander.cs
+++ b/src/Deprecated/Engine/Items/ItemExpander.cs
@@ -220,7 +220,7 @@ out Match itemVectorMatch
 
                 ErrorUtilities.VerifyThrow(items != null, "ItemizeItemVector shouldn't give us null.");
             }
-            
+
             return items;
         }
 
@@ -235,7 +235,7 @@ internal static bool ExpressionContainsItemVector(string expression)
             {
                 return true;
             }
-            
+
             return false;
         }
 
@@ -253,7 +253,7 @@ private static Match GetItemVectorMatches(string expression)
                 itemVectorMatch = itemVectorPattern.Match(expression);
             }
 
-            return itemVectorMatch; 
+            return itemVectorMatch;
         }
 
         /// <summary>
@@ -343,7 +343,7 @@ private string ExpandItemVector(Match itemVector)
         {
             ErrorUtilities.VerifyThrow(itemVector.Success, "Need a valid item vector.");
 
-            string separator = (itemVector.Groups["SEPARATOR_SPECIFICATION"].Length != 0) 
+            string separator = (itemVector.Groups["SEPARATOR_SPECIFICATION"].Length != 0)
                 ? itemVector.Groups["SEPARATOR"].Value
                 : ";";
 
diff --git a/src/Deprecated/Engine/Items/TaskItem.cs b/src/Deprecated/Engine/Items/TaskItem.cs
index a5a53f4da5c..21d82ae6802 100644
--- a/src/Deprecated/Engine/Items/TaskItem.cs
+++ b/src/Deprecated/Engine/Items/TaskItem.cs
@@ -119,7 +119,7 @@ public int CustomMetadataCount
                 return item.CustomMetadataCount;
             }
         }
-        
+
         /// <summary>
         /// Looks up the value of the given custom metadata.
         /// </summary>
@@ -208,14 +208,14 @@ ITaskItem destinationItem
         /// <owner>JomoF</owner>
         public IDictionary CloneCustomMetadata()
         {
-            IDictionary backingItemMetadata = item.CloneCustomMetadata(); 
+            IDictionary backingItemMetadata = item.CloneCustomMetadata();
 
             // Go through and escape the metadata as necessary.
             string[] keys = new string[backingItemMetadata.Count];
             backingItemMetadata.Keys.CopyTo(keys, 0);
             foreach (string singleMetadataName in keys)
             {
-                string singleMetadataValue = (string) backingItemMetadata[singleMetadataName];
+                string singleMetadataValue = (string)backingItemMetadata[singleMetadataName];
 
                 bool unescapingWasNecessary;
                 string singleMetadataValueUnescaped = EscapingUtilities.UnescapeAll(singleMetadataValue, out unescapingWasNecessary);
@@ -253,7 +253,7 @@ public override object InitializeLifetimeService()
 
         // the backing item
         internal BuildItem item;
-        
+
         #region Operators
 
         /// <summary>
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index 1ead6244ab7..04d8b036392 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -87,7 +87,7 @@ internal static List<string> SplitSemiColonSeparatedList(string expression)
 
             return splitList;
         }
-        
+
         /// <summary>
         /// Given a list of expressions that may contain item list expressions,
         /// returns a pair of tables of all item names found, as K=Name, V=String.Empty;
diff --git a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
index 0b219cc6f5f..531155f30ab 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
@@ -139,7 +139,7 @@ private Lookup(Lookup that)
             this.cloneTable = that.cloneTable;
         }
 
-#endregion
+        #endregion
 
         #region Properties
 
@@ -227,7 +227,7 @@ private BuildPropertyGroup SecondaryPropertySets
             set { lookupEntries.First.Next.Value.PropertySets = value; }
         }
 
-#endregion
+        #endregion
 
         #region Internal Methods
 
@@ -662,7 +662,7 @@ internal void AddNewItems(BuildItemGroup group)
         {
             MustBeOwningThread();
 
-             // Adding to outer scope could be easily implemented, but our code does not do it at present
+            // Adding to outer scope could be easily implemented, but our code does not do it at present
             MustNotBeOuterScope();
 
 #if DEBUG
@@ -802,7 +802,7 @@ internal void ModifyItems(string name, BuildItemGroup group, Dictionary<string,
             }
         }
 
-#endregion
+        #endregion
 
         #region Private Methods
 
@@ -1213,6 +1213,6 @@ internal bool TruncateLookupsAtThisScope
             set { truncateLookupsAtThisScope = value; }
         }
     }
-#endregion
+    #endregion
 
 }
diff --git a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
index d52698904d1..67eccedf36d 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
@@ -67,7 +67,7 @@ internal virtual bool IsReply
         /// <summary>
         /// Appropriate action to take if this event is received on the parent process
         /// </summary>
-        internal virtual void HostAction( IEngineCallback engineCallback, LocalNodeProvider nodeProvider, int nodeId )
+        internal virtual void HostAction(IEngineCallback engineCallback, LocalNodeProvider nodeProvider, int nodeId)
         {
             ErrorUtilities.VerifyThrow(false, "This description doesn't support this operation");
         }
@@ -113,8 +113,8 @@ internal virtual void WriteToStream(BinaryWriter writer)
 
         internal virtual void CreateFromStream(BinaryReader reader)
         {
-           callType = (LocalCallType)reader.ReadByte();
-           callNumber = reader.ReadInt32();
+            callType = (LocalCallType)reader.ReadByte();
+            callNumber = reader.ReadInt32();
         }
         #endregion
     }
@@ -196,7 +196,7 @@ internal override void WriteToStream(BinaryWriter writer)
                 if (replyData is CacheEntry[])
                 {
                     writer.Write((byte)0);
-                    CacheEntry[] cacheArray =(CacheEntry[]) replyData;
+                    CacheEntry[] cacheArray = (CacheEntry[])replyData;
                     writer.Write((Int32)cacheArray.Length);
                     for (int i = 0; i < cacheArray.Length; i++)
                     {
@@ -234,7 +234,7 @@ internal override void CreateFromStream(BinaryReader reader)
                 {
                     int numberOfEntries = reader.ReadInt32();
                     CacheEntry[] cacheArray = new CacheEntry[numberOfEntries];
-                    
+
                     for (int i = 0; i < numberOfEntries; i++)
                     {
                         if (reader.ReadByte() == 0)
@@ -266,8 +266,8 @@ internal LocalCallDescriptorForPostBuildRequests()
         {
         }
 
-        internal LocalCallDescriptorForPostBuildRequests(BuildRequest [] buildRequests)
-            :base(LocalCallType.PostBuildRequests)
+        internal LocalCallDescriptorForPostBuildRequests(BuildRequest[] buildRequests)
+            : base(LocalCallType.PostBuildRequests)
         {
             this.buildRequests = buildRequests;
         }
@@ -280,7 +280,7 @@ internal LocalCallDescriptorForPostBuildRequests(BuildRequest buildRequest)
         }
 
         #endregion
-    
+
         #region Methods
         internal override void HostAction(IEngineCallback engineCallback, LocalNodeProvider nodeProvider, int nodeId)
         {
@@ -649,7 +649,7 @@ internal LocalCallDescriptorForShutdownComplete()
         {
         }
 
-        internal LocalCallDescriptorForShutdownComplete(Node.NodeShutdownLevel shutdownLevel, int totalTaskTime )
+        internal LocalCallDescriptorForShutdownComplete(Node.NodeShutdownLevel shutdownLevel, int totalTaskTime)
             : base(LocalCallType.ShutdownComplete)
         {
             this.shutdownLevel = shutdownLevel;
@@ -693,7 +693,7 @@ internal override void CreateFromStream(BinaryReader reader)
         {
             base.CreateFromStream(reader);
             shutdownLevel = (Node.NodeShutdownLevel)reader.ReadInt32();
-            totalTaskTime = reader.ReadInt32(); 
+            totalTaskTime = reader.ReadInt32();
         }
         #endregion
     }
@@ -713,7 +713,7 @@ internal LocalCallDescriptorForInitializeNode()
 
         internal LocalCallDescriptorForInitializeNode
         (
-            Hashtable environmentVariablesToSend, 
+            Hashtable environmentVariablesToSend,
             LoggerDescription[] nodeLoggers,
             int nodeId,
             BuildPropertyGroup parentGlobalProperties,
@@ -736,7 +736,7 @@ string parentStartupDirectory
         #region Methods
         internal override void NodeAction(Node node, LocalNode localNode)
         {
-            localNode.Activate(environmentVariables, nodeLoggers, nodeId, parentGlobalProperties, 
+            localNode.Activate(environmentVariables, nodeLoggers, nodeId, parentGlobalProperties,
                                toolsetSearchLocations, parentProcessId, parentStartupDirectory);
         }
         #endregion
@@ -764,7 +764,7 @@ internal LoggerDescription[] NodeLoggers
         {
             get
             {
-                    return nodeLoggers;
+                return nodeLoggers;
             }
         }
         internal int NodeId
@@ -886,7 +886,7 @@ internal override void CreateFromStream(BinaryReader reader)
             #endregion
             toolsetSearchLocations = (ToolsetDefinitionLocations)reader.ReadByte();
             parentStartupDirectory = (string)reader.ReadString();
-          }
+        }
         #endregion
     }
     #endregion
@@ -984,8 +984,8 @@ internal int RequestId
         #region CustomSerializationToStream
         internal override void WriteToStream(BinaryWriter writer)
         {
-             base.WriteToStream(writer);
-             writer.Write((Int32)requestId);
+            base.WriteToStream(writer);
+            writer.Write((Int32)requestId);
         }
 
         internal override void CreateFromStream(BinaryReader reader)
@@ -1072,7 +1072,7 @@ internal class LocalCallDescriptorForPostIntrospectorCommand : LocalCallDescript
         internal LocalCallDescriptorForPostIntrospectorCommand(TargetInProgessState child, TargetInProgessState parent)
             : base(LocalCallType.PostIntrospectorCommand)
         {
-            this.child  = child;
+            this.child = child;
             this.parent = parent;
         }
         #endregion
@@ -1212,7 +1212,7 @@ internal override void WriteToStream(BinaryWriter writer)
                 writer.Write((Int32)entries.Length);
                 for (int i = 0; i < entries.Length; i++)
                 {
-                   CacheEntryCustomSerializer.WriteToStream(entries[i], writer);
+                    CacheEntryCustomSerializer.WriteToStream(entries[i], writer);
                 }
             }
             #endregion
@@ -1519,7 +1519,7 @@ internal override void CreateFromStream(BinaryReader reader)
             cacheContentType = (CacheContentType)reader.ReadByte();
         }
         #endregion
-        
+
     }
     #endregion
 
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 5da591534fd..8fc5507a998 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -45,42 +45,42 @@ private static void UnhandledExceptionHandler(object sender, UnhandledExceptionE
         /// </summary>
         internal static void DumpExceptionToFile(Exception ex)
         {
-                // Lock as multiple threads may throw simultaneously
-                lock (dumpFileLocker)
+            // Lock as multiple threads may throw simultaneously
+            lock (dumpFileLocker)
+            {
+                if (dumpFileName == null)
                 {
-                    if (dumpFileName == null)
-                    {
-                        Guid guid = Guid.NewGuid();
-                        string tempPath = Path.GetTempPath();
-
-                        // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
-                        // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
-                        if (!Directory.Exists(tempPath))
-                        {
-                            // If this throws, no sense catching it, we can't log it now, and we're here
-                            // because we're a child node with no console to log to, so die
-                            Directory.CreateDirectory(tempPath);
-                        }
+                    Guid guid = Guid.NewGuid();
+                    string tempPath = Path.GetTempPath();
 
-                        dumpFileName = Path.Combine(tempPath, "MSBuild_" + guid.ToString());
-
-                        using (StreamWriter writer = new StreamWriter(dumpFileName, true /*append*/))
-                        {
-                            writer.WriteLine("UNHANDLED EXCEPTIONS FROM CHILD NODE:");
-                            writer.WriteLine("===================");
-                        }
+                    // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
+                    // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
+                    if (!Directory.Exists(tempPath))
+                    {
+                        // If this throws, no sense catching it, we can't log it now, and we're here
+                        // because we're a child node with no console to log to, so die
+                        Directory.CreateDirectory(tempPath);
                     }
 
+                    dumpFileName = Path.Combine(tempPath, "MSBuild_" + guid.ToString());
+
                     using (StreamWriter writer = new StreamWriter(dumpFileName, true /*append*/))
                     {
-                        writer.WriteLine(DateTime.Now.ToLongTimeString());
-                        writer.WriteLine(ex.ToString());
+                        writer.WriteLine("UNHANDLED EXCEPTIONS FROM CHILD NODE:");
                         writer.WriteLine("===================");
                     }
                 }
+
+                using (StreamWriter writer = new StreamWriter(dumpFileName, true /*append*/))
+                {
+                    writer.WriteLine(DateTime.Now.ToLongTimeString());
+                    writer.WriteLine(ex.ToString());
+                    writer.WriteLine("===================");
+                }
+            }
         }
 
-#endregion
+        #endregion
 
         #region Constructors
 
@@ -320,7 +320,7 @@ public static void StartLocalNodeServer(int nodeNumber)
 
             globalNodeActive.Close();
             globalNodeInUse.Close();
-         }
+        }
 
         #endregion
 
@@ -370,7 +370,7 @@ private void SharedMemoryReaderThread()
                                 {
                                     // Process the reply from the parent so it can be looked in a hashtable based
                                     // on the call descriptor who requested the reply.
-                                    engineCallback.PostReplyFromParent((LocalReplyCallDescriptor) callDescriptor);
+                                    engineCallback.PostReplyFromParent((LocalReplyCallDescriptor)callDescriptor);
                                 }
                             }
                         }
@@ -413,11 +413,11 @@ internal void ShutdownNode(Node.NodeShutdownLevel shutdownLevel, bool exitProces
                             new LocalCallDescriptorForShutdownComplete(shutdownLevel, node.TotalTaskTime);
                         // Post the message indicating that the shutdown is complete
                         engineCallback.PostMessageToParent(callDescriptor, true);
-                     }
+                    }
                 }
                 catch (Exception e)
                 {
-                     if (shutdownLevel != Node.NodeShutdownLevel.ErrorShutdown)
+                    if (shutdownLevel != Node.NodeShutdownLevel.ErrorShutdown)
                     {
                         ReportNonFatalCommunicationError(e);
                     }
@@ -437,7 +437,7 @@ internal void ShutdownNode(Node.NodeShutdownLevel shutdownLevel, bool exitProces
             {
                 // Even if we completed a build, if we are goign to exit the process we need to null out the node and set the notInUseEvent, this is
                 // accomplished by calling this method again with the ErrorShutdown handle
-                if ( shutdownLevel == Node.NodeShutdownLevel.BuildCompleteSuccess || shutdownLevel == Node.NodeShutdownLevel.BuildCompleteFailure )
+                if (shutdownLevel == Node.NodeShutdownLevel.BuildCompleteSuccess || shutdownLevel == Node.NodeShutdownLevel.BuildCompleteFailure)
                 {
                     ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, false, true);
                 }
@@ -476,9 +476,9 @@ string parentStartupDirectory
                 Environment.SetEnvironmentVariable(variableName, null);
             }
 
-            foreach(string key in environmentVariables.Keys)
+            foreach (string key in environmentVariables.Keys)
             {
-                Environment.SetEnvironmentVariable(key,(string)environmentVariables[key]);
+                Environment.SetEnvironmentVariable(key, (string)environmentVariables[key]);
             }
 
             // Host the msbuild engine and system
@@ -613,7 +613,7 @@ internal static string DumpFileName
         /// Indicates the node is now in use. This means the node has recieved an activate command with initialization
         /// data from the parent procss
         /// </summary>
-        private static ManualResetEvent inUseEvent    = new ManualResetEvent(false);
+        private static ManualResetEvent inUseEvent = new ManualResetEvent(false);
 
         /// <summary>
         /// Randomly generated file name for all exceptions thrown by this node that need to be dumped to a file.
@@ -622,7 +622,7 @@ internal static string DumpFileName
         private static string dumpFileName = null;
 
         // Timeouts && Constants
-        private const int inactivityTimeout   = 60 * 1000; // 60 seconds of inactivity to exit
+        private const int inactivityTimeout = 60 * 1000; // 60 seconds of inactivity to exit
         private const int parentCheckInterval = 5 * 1000; // Check if the parent process is there every 5 seconds
 
         #endregion
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
index 000446c6fc1..72b2e84b3f3 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
@@ -61,7 +61,7 @@ internal void StartWriterThread(int nodeNumber)
             // Start the thread that will be processing the calls to the parent engine
             ThreadStart threadState = new ThreadStart(this.SharedMemoryWriterThread);
             writerThread = new Thread(threadState);
-            writerThread.Name = "MSBuild Child->Parent Writer";            
+            writerThread.Name = "MSBuild Child->Parent Writer";
             writerThread.Start();
         }
 
@@ -115,8 +115,8 @@ internal void PostReplyFromParent(LocalReplyCallDescriptor reply)
 
             lock (repliesFromParent)
             {
-                ReplyData replyData = (ReplyData) repliesFromParent[requestingCallNumber];
-                ErrorUtilities.VerifyThrow(replyData?.waitEvent != null, 
+                ReplyData replyData = (ReplyData)repliesFromParent[requestingCallNumber];
+                ErrorUtilities.VerifyThrow(replyData?.waitEvent != null,
                     "We must have an event for this call at this point");
 
                 replyData.reply = reply;
@@ -241,7 +241,7 @@ private object GetReplyForCallDescriptor(LocalCallDescriptor callDescriptor)
 
             replyFromParentArrived.Reset();
             int requestingCallNumber = callDescriptor.CallNumber;
-            
+
             ReplyData replyData = new ReplyData();
             replyData.waitEvent = replyFromParentArrived;
 
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
index 506cd32a483..fd450a0130f 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
@@ -15,13 +15,13 @@ internal class LocalNodeInfo
         #region Constructors
         internal LocalNodeInfo(int availableNodeNumberHint)
         {
-            this.nodeState              = LocalNodeProvider.NodeState.NotLaunched;
-            this.targetList             = new LinkedList<BuildRequest>();
-            this.nodeCommandQueue       = new DualQueue<LocalCallDescriptor>();
-            this.nodeHiPriCommandQueue  = new DualQueue<LocalCallDescriptor>();
-            this.nodeReserveHandle      = null;
-            this.communicationFailed    = false;
-            this.processId              = unInitializedProcessId;
+            this.nodeState = LocalNodeProvider.NodeState.NotLaunched;
+            this.targetList = new LinkedList<BuildRequest>();
+            this.nodeCommandQueue = new DualQueue<LocalCallDescriptor>();
+            this.nodeHiPriCommandQueue = new DualQueue<LocalCallDescriptor>();
+            this.nodeReserveHandle = null;
+            this.communicationFailed = false;
+            this.processId = unInitializedProcessId;
 
             // Figure out the next available node number
             ReserveNextAvailableNodeNumber(availableNodeNumberHint);
@@ -141,12 +141,12 @@ internal bool CommunicationFailed
 
         public bool ShutdownResponseReceived
         {
-            get 
+            get
             {
                 return shutdownResponseReceived;
             }
-            set 
-            { 
+            set
+            {
                 shutdownResponseReceived = value;
             }
         }
@@ -192,7 +192,7 @@ internal bool CreateSharedMemoryBuffers()
 
         internal void ReleaseNode()
         {
-            if ( nodeReserveHandle != null )
+            if (nodeReserveHandle != null)
             {
                 nodeReserveHandle.Close();
                 processId = invalidProcessId;
@@ -209,7 +209,7 @@ private void ReserveNextAvailableNodeNumber(int currentNodeNumber)
             while (nodeReserveHandle == null)
             {
                 bool createdNew;
-                nodeReserveHandle = 
+                nodeReserveHandle =
                     new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeReserveEventName(currentNodeNumber), out createdNew);
                 if (!createdNew)
                 {
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index eb73adeb434..0fbec36490e 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -66,7 +66,7 @@ string startupDirectory
             {
                 this.locationOfMSBuildExe = AppDomain.CurrentDomain.BaseDirectory;
             }
-            if ( (cpuCount - 1) <= 0)
+            if ((cpuCount - 1) <= 0)
             {
                 return;
             }
@@ -122,7 +122,7 @@ public void ApplyParameter(string parameterName, string parameterValue)
 
             if (String.Equals(parameterName, "MAXCPUCOUNT", StringComparison.OrdinalIgnoreCase))
             {
-                 try
+                try
                 {
                     this.cpuCount = Convert.ToInt32(parameterValue, CultureInfo.InvariantCulture);
                 }
@@ -166,7 +166,7 @@ public void ApplyParameter(string parameterName, string parameterValue)
 
         public INodeDescription[] QueryNodeDescriptions()
         {
-            return new INodeDescription[cpuCount-1];
+            return new INodeDescription[cpuCount - 1];
         }
 
         public void AssignNodeIdentifiers(int[] nodeIds)
@@ -409,7 +409,7 @@ private void SendShutdownRequests(Node.NodeShutdownLevel nodeShutdownLevel)
                 // before shutting down the node
                 while (nodeData[i].NodeState == NodeState.LaunchInProgress && !nodeData[i].CommunicationFailed)
                 {
-                   Thread.Sleep(500);
+                    Thread.Sleep(500);
                 }
 
                 if (nodeData[i].NodeState == NodeState.Launched)
@@ -481,7 +481,7 @@ private bool IsNodeProcessAliveOrUninitialized(int nodeId)
 
                 if (isUninitialized)
                 {
-                      return true;
+                    return true;
                 }
 
                 bool isInvalidProcessId = nodeData[nodeId].ProcessId == LocalNodeInfo.invalidProcessId;
@@ -490,7 +490,7 @@ private bool IsNodeProcessAliveOrUninitialized(int nodeId)
                 {
                     return true;
                 }
-           }
+            }
             catch (ArgumentException)
             {
                 // Process already exited
@@ -531,7 +531,7 @@ private void IncreaseActiveNodeCount()
         /// </summary>
         internal void RecordNodeResponse(int nodeId, Node.NodeShutdownLevel shutdownLevel, int totalTaskTime)
         {
-              // If the node is shutting down - decrease the count of active nodes
+            // If the node is shutting down - decrease the count of active nodes
             if (shutdownLevel == Node.NodeShutdownLevel.ErrorShutdown ||
                 shutdownLevel == Node.NodeShutdownLevel.PoliteShutdown)
             {
@@ -727,7 +727,7 @@ private void InitializeNode(int nodeIndex)
         /// for a given index. The node is running if the global mutex with a
         /// "Node_" + nodeId + "_ActiveReady" as a name was created
         /// </summary>
-        private static  bool checkIfNodeActive(int nodeNumber)
+        private static bool checkIfNodeActive(int nodeNumber)
         {
             bool nodeIsActive = false;
             EventWaitHandle nodeActiveHandle = null;
@@ -756,7 +756,7 @@ private void LaunchNode(int nodeIndex)
             EventWaitHandle nodeReadyEvent = null;
 
             string msbuildLocation = Path.Combine(locationOfMSBuildExe, "MSBuild.exe");
-            ErrorUtilities.VerifyThrow(File.Exists(msbuildLocation),"Msbuild.exe cannot be found at: "+msbuildLocation);
+            ErrorUtilities.VerifyThrow(File.Exists(msbuildLocation), "Msbuild.exe cannot be found at: " + msbuildLocation);
 
             bool exitedDueToError = true;
             try
@@ -971,13 +971,13 @@ private void SharedMemoryReaderThread()
                     nodeData[i].SharedMemoryFromNode = null;
                 }
             }
-       }
+        }
 
         #endregion
 
         #region Data
         private IEngineCallback engineCallback;
-        private  ManualResetEvent exitCommunicationThreads;
+        private ManualResetEvent exitCommunicationThreads;
 
         private ManualResetEvent responseCountChangeEvent;
         private int activeNodeCount;
diff --git a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
index 5e4c1f071fc..38100751b20 100644
--- a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
+++ b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
@@ -20,17 +20,17 @@ internal static class NativeMethods
                                                     0x0008 |
                                                     0x0010;
         internal const uint NORMAL_PRIORITY_CLASS = 0x0020;
-        internal const uint CREATE_NO_WINDOW      = 0x08000000;
+        internal const uint CREATE_NO_WINDOW = 0x08000000;
         internal const Int32 STARTF_USESTDHANDLES = 0x00000100;
         internal const uint PAGE_SIZE = 4096;
         internal const int SECURITY_DESCRIPTOR_REVISION = 1;
-        internal const int ERROR_SUCCESS          = 0;
+        internal const int ERROR_SUCCESS = 0;
 
-        internal const string  ADMINONLYSDDL      = "D:" +                    //Discretionary ACL
+        internal const string ADMINONLYSDDL = "D:" +                    //Discretionary ACL
                                                     "(A;OICI;GA;;;BA)" +       //Allow full control to administrators
                                                     "(A;OICI;GA;;;SY)";         //Allow full control to System
 
-        [DllImport("advapi32.dll", SetLastError=true)]
+        [DllImport("advapi32.dll", SetLastError = true)]
         [return: MarshalAs(UnmanagedType.Bool)]
         internal static extern bool CheckTokenMembership
         (
@@ -40,16 +40,16 @@ internal static extern bool CheckTokenMembership
             out bool IsMember
         );
 
-        [DllImport("advapi32.dll", SetLastError=true)]
+        [DllImport("advapi32.dll", SetLastError = true)]
         [return: MarshalAs(UnmanagedType.Bool)]
         internal static extern bool AllocateAndInitializeSid
         (
-            IntPtr siaNtAuthority, 
-            byte nSubAuthorityCount, 
-            int dwSubAuthority0, int dwSubAuthority1, 
-            int dwSubAuthority2, int dwSubAuthority3, 
-            int dwSubAuthority4, int dwSubAuthority5, 
-            int dwSubAuthority6, int dwSubAuthority7, 
+            IntPtr siaNtAuthority,
+            byte nSubAuthorityCount,
+            int dwSubAuthority0, int dwSubAuthority1,
+            int dwSubAuthority2, int dwSubAuthority3,
+            int dwSubAuthority4, int dwSubAuthority5,
+            int dwSubAuthority6, int dwSubAuthority7,
             out IntPtr pSid
         );
 
@@ -66,7 +66,7 @@ out IntPtr pSid
         internal static bool IsUserAdministrator()
         {
             int SECURITY_BUILTIN_DOMAIN_RID = 0x00000020;
-            int DOMAIN_ALIAS_RID_ADMINS  = 0x00000220;
+            int DOMAIN_ALIAS_RID_ADMINS = 0x00000220;
             IntPtr pNtAuthority = Marshal.AllocHGlobal(6);
             Marshal.WriteInt32(pNtAuthority, 0, 0);
             Marshal.WriteByte(pNtAuthority, 4, 0);
@@ -136,24 +136,24 @@ internal static extern bool UnmapViewOfFile
             IntPtr lpBaseAddress
         );
 
-        [DllImport("kernel32.dll",  CharSet = CharSet.Unicode)]
+        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
         [return: MarshalAs(UnmanagedType.Bool)]
         internal static extern bool CreateProcess
         (
             string lpApplicationName,
-            string lpCommandLine, 
+            string lpCommandLine,
             ref SECURITY_ATTRIBUTES lpProcessAttributes,
             ref SECURITY_ATTRIBUTES lpThreadAttributes,
             [In, MarshalAs(UnmanagedType.Bool)]
             bool bInheritHandles,
-            uint dwCreationFlags, 
-            IntPtr lpEnvironment, 
+            uint dwCreationFlags,
+            IntPtr lpEnvironment,
             string lpCurrentDirectory,
             [In] ref STARTUPINFO lpStartupInfo,
             out PROCESS_INFORMATION lpProcessInformation
         );
 
-        [DllImport("advapi32",  CharSet = CharSet.Unicode, SetLastError = true)]
+        [DllImport("advapi32", CharSet = CharSet.Unicode, SetLastError = true)]
         [return: MarshalAs(UnmanagedType.Bool)]
         internal static extern bool ConvertStringSecurityDescriptorToSecurityDescriptor
         (
diff --git a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
index 30bb926fc11..5236bf8624c 100644
--- a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
+++ b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
@@ -174,19 +174,19 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
                     Marshal.StructureToPtr(saAttr, pointerToSecurityAttributes, true);
                 }
 
-               // The file mapping has either the default (current user) security permissions or 
-               // permissions restricted to only administrator users depending on the check above.
-               // If pointerToSecurityAttributes is null the default permissions are used.
-               this.pageFileMapping =
-                    NativeMethods.CreateFileMapping
-                    (
-                        NativeMethods.InvalidHandle,
-                        pointerToSecurityAttributes,
-                        NativeMethods.PAGE_READWRITE,
-                        0,
-                        size + 4,
-                        memoryMapName
-                    );
+                // The file mapping has either the default (current user) security permissions or 
+                // permissions restricted to only administrator users depending on the check above.
+                // If pointerToSecurityAttributes is null the default permissions are used.
+                this.pageFileMapping =
+                     NativeMethods.CreateFileMapping
+                     (
+                         NativeMethods.InvalidHandle,
+                         pointerToSecurityAttributes,
+                         NativeMethods.PAGE_READWRITE,
+                         0,
+                         size + 4,
+                         memoryMapName
+                     );
 
                 // If only new mappings are allowed and the current one has been created by somebody else
                 // delete the mapping. Note that we would like to compare the GetLastError value against
@@ -218,8 +218,8 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
                         NativeMethods.FILE_MAP_ALL_ACCESS, // Give the map read, write, and copy access
                         0,  // Start mapped view at high order offset 0
                         0,  // Start mapped view at low order offset 0
-                         // The size of the shared memory plus some extra space for an int
-                         // to write the number of bytes written
+                            // The size of the shared memory plus some extra space for an int
+                            // to write the number of bytes written
                         (IntPtr)(size + 4)
                     );
 
@@ -930,8 +930,8 @@ internal void Reset()
         private Semaphore unreadBatchCounter;
 
         //Used to inform the shared memory reader threads the writer thread has written something in shared memory to read.
-	//The semaphore is incremented when the shared memory is full and when there is an unreadBatch availiable to be read or the shared memory is full.
-	//The semaphore is decremented when the shared memory reader thread is about to read from the shared memory.
+        //The semaphore is incremented when the shared memory is full and when there is an unreadBatch availiable to be read or the shared memory is full.
+        //The semaphore is decremented when the shared memory reader thread is about to read from the shared memory.
         private Semaphore readActionCounter;
 
         // Whether or not the shared memory is full
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index 16c1a4abdf4..9e8054b63ee 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -218,7 +218,7 @@ internal void WriteNewLine()
         /// </summary>
         /// <param name="resourceString"></param>
         /// <param name="args"></param>
-        internal  void WriteLinePrettyFromResource(string resourceString, params object[] args)
+        internal void WriteLinePrettyFromResource(string resourceString, params object[] args)
         {
             int indentLevel = IsVerbosityAtLeast(LoggerVerbosity.Normal) ? this.currentIndentLevel : 0;
             WriteLinePrettyFromResource(indentLevel, resourceString, args);
@@ -227,7 +227,7 @@ internal  void WriteLinePrettyFromResource(string resourceString, params object[
         /// <summary>
         /// Writes a line from a resource string to the log, using the specified indentation.
         /// </summary>
-        internal  void WriteLinePrettyFromResource(int indentLevel, string resourceString, params object[] args)
+        internal void WriteLinePrettyFromResource(int indentLevel, string resourceString, params object[] args)
         {
             string formattedString = ResourceUtilities.FormatResourceString(resourceString, args);
             WriteLinePretty(indentLevel, formattedString);
@@ -237,7 +237,7 @@ internal  void WriteLinePrettyFromResource(int indentLevel, string resourceStrin
         /// Writes to the log, using the default indentation. Does not 
         /// terminate with a newline.
         /// </summary>
-        internal  void WritePretty(string formattedString)
+        internal void WritePretty(string formattedString)
         {
             int indentLevel = IsVerbosityAtLeast(LoggerVerbosity.Normal) ? this.currentIndentLevel : 0;
             WritePretty(indentLevel, formattedString);
@@ -634,7 +634,7 @@ internal void DisplayCounters(Hashtable counters)
                 {
                     reentrantCounterExists = true;
                 }
- 
+
                 counter.PrintCounterMessage(lineWriter, setColor, resetColor);
             }
 
@@ -701,7 +701,7 @@ internal bool ReenteredScope
             /// <summary>
             /// Whether or not this task or target is executing right now.
             /// </summary>
-            internal  bool InScope 
+            internal bool InScope
             {
                 get { return inScope; }
                 set
@@ -735,29 +735,29 @@ internal  bool InScope
 
             internal virtual void PrintCounterMessage(WriteLinePrettyFromResourceDelegate WriteLinePrettyFromResource, ColorSetter setColor, ColorResetter resetColor)
             {
-                    string time;
-                    if (!reenteredScope)
-                    {
-                        // round: submillisecond values are not meaningful
-                        time = String.Format(CultureInfo.CurrentCulture,
-                            "{0,5}", Math.Round(elapsedTime.TotalMilliseconds, 0));
-                    }
-                    else
-                    {
-                        // no value available; instead display an asterisk
-                        time = "    *";
-                    }
+                string time;
+                if (!reenteredScope)
+                {
+                    // round: submillisecond values are not meaningful
+                    time = String.Format(CultureInfo.CurrentCulture,
+                        "{0,5}", Math.Round(elapsedTime.TotalMilliseconds, 0));
+                }
+                else
+                {
+                    // no value available; instead display an asterisk
+                    time = "    *";
+                }
 
-                    WriteLinePrettyFromResource
-                        (
-                            2,
-                            "PerformanceLine",
-                            time,
-                            String.Format(CultureInfo.CurrentCulture,
-                                    "{0,-40}" /* pad to 40 align left */, scopeName),
-                            String.Format(CultureInfo.CurrentCulture,
-                                    "{0,3}", calls)
-                        );
+                WriteLinePrettyFromResource
+                    (
+                        2,
+                        "PerformanceLine",
+                        time,
+                        String.Format(CultureInfo.CurrentCulture,
+                                "{0,-40}" /* pad to 40 align left */, scopeName),
+                        String.Format(CultureInfo.CurrentCulture,
+                                "{0,3}", calls)
+                    );
             }
 
             /// <summary>
@@ -957,7 +957,7 @@ internal virtual bool ApplyParameter(string parameterName, string parameterValue
 
         public abstract void BuildStartedHandler(object sender, BuildStartedEventArgs e);
 
-        public abstract  void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
+        public abstract void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
 
         public abstract void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
 
@@ -1005,13 +1005,13 @@ internal virtual bool ApplyParameter(string parameterName, string parameterValue
         /// Delegate used to change text color.
         /// </summary>
         /// <owner>t-jeffv, sumedhk</owner>
-        internal  ColorSetter setColor = null;
+        internal ColorSetter setColor = null;
 
         /// <summary>
         /// Delegate used to reset text color
         /// </summary>
         /// <owner>t-jeffv, sumedhk</owner>
-        internal  ColorResetter resetColor = null;
+        internal ColorResetter resetColor = null;
 
         /// <summary>
         /// Indicates if project header should not be displayed.
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index c82db95717a..1675d83663a 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -111,7 +111,7 @@ private void InitializeBaseConsoleLogger()
                 bool useMPLogger = false;
                 if (!string.IsNullOrEmpty(parameters))
                 {
-                    string [] parameterComponents = parameters.Split(BaseConsoleLogger.parameterDelimiters);
+                    string[] parameterComponents = parameters.Split(BaseConsoleLogger.parameterDelimiters);
                     for (int param = 0; param < parameterComponents.Length; param++)
                     {
                         if (parameterComponents[param].Length > 0)
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index f9f56bff848..290f15295d4 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.BuildEngine
     /// Logger that forwards events to a central logger (e.g ConsoleLogger)
     /// residing on the parent node.
     /// </summary>
-    public class ConfigurableForwardingLogger: IForwardingLogger
+    public class ConfigurableForwardingLogger : IForwardingLogger
     {
         #region Constructors
         /// <summary>
@@ -529,7 +529,7 @@ private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         /// Id of the node the logger is attached to
         /// </summary>
         private int nodeId;
-        
+
         #endregion
         #endregion
 
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index 2f1f212ab1b..5e47da455f8 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -171,7 +171,7 @@ public LoggerVerbosity Verbosity
             }
             set
             {
-              // Dont really care about verbosity at this point, but dont want to throw exception as it is set for all distributed loggers
+                // Dont really care about verbosity at this point, but dont want to throw exception as it is set for all distributed loggers
             }
         }
 
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 969428b2d3b..e7c2e2cc3b8 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -33,7 +33,7 @@ public FileLogger() : base(LoggerVerbosity.Normal)
         {
             this.WriteHandler = new WriteHandler(Write);
         }
-        
+
         #endregion
 
         /// <summary>
@@ -98,7 +98,7 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, e.Message);
                 fileWriter?.Close();
-                throw new LoggerException(message,e.InnerException,errorCode, helpKeyword);
+                throw new LoggerException(message, e.InnerException, errorCode, helpKeyword);
             }
         }
 
diff --git a/src/Deprecated/Engine/Logging/LogFormatter.cs b/src/Deprecated/Engine/Logging/LogFormatter.cs
index 83b8131d4fd..b61d83b1f51 100644
--- a/src/Deprecated/Engine/Logging/LogFormatter.cs
+++ b/src/Deprecated/Engine/Logging/LogFormatter.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.BuildEngine
     /// Utility helper functions for formatting logger output.
     /// </summary>
     /// <owner>JomoF</owner>
-    internal static class LogFormatter 
+    internal static class LogFormatter
     {
         /// <summary>
         /// Formats the timestamp in the log as  Hours:Minutes:Seconds.Milliseconds
@@ -42,7 +42,7 @@ internal static string FormatLogTimeStamp(DateTime timeStamp)
         /// <owner>JomoF</owner>
         /// <param name="t"></param>
         /// <returns>String representation of time-span.</returns>
-        internal static string FormatTimeSpan(TimeSpan t) 
+        internal static string FormatTimeSpan(TimeSpan t)
         {
             string rawTime = t.ToString(); // Timespan is a value type and can't be null.
             int rawTimeLength = rawTime.Length;
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index 4550081d3e9..26d3272a7e7 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -72,7 +72,7 @@ internal string Name
                 {
                     return this.loggerClassName + ":" + this.loggerAssembly.AssemblyFile;
                 }
-                else if ( !string.IsNullOrEmpty(this.loggerClassName) )
+                else if (!string.IsNullOrEmpty(this.loggerClassName))
                 {
                     return this.loggerClassName;
                 }
@@ -229,7 +229,7 @@ internal void ConvertPathsToFullPaths()
         {
             if (loggerAssembly.AssemblyFile != null)
             {
-                loggerAssembly = 
+                loggerAssembly =
                     new AssemblyLoadInfo(loggerAssembly.AssemblyName, Path.GetFullPath(loggerAssembly.AssemblyFile));
             }
         }
@@ -239,7 +239,7 @@ internal void ConvertPathsToFullPaths()
         #region Data
         private string loggerClassName;
         private string loggerSwitchParameters;
-        private AssemblyLoadInfo loggerAssembly; 
+        private AssemblyLoadInfo loggerAssembly;
         private LoggerVerbosity verbosity;
         private int loggerId;
         #endregion
@@ -305,7 +305,7 @@ internal void WriteToStream(BinaryWriter writer)
         internal void CreateFromStream(BinaryReader reader)
         {
             #region LoggerClassName
-            if (reader.ReadByte() ==0)
+            if (reader.ReadByte() == 0)
             {
                 loggerClassName = null;
             }
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index c43a46692cb..d2605b30130 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -298,8 +298,8 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
                 }
             }
 
-           ResetConsoleLoggerState();
-           CheckIfOutputSupportsAlignment();
+            ResetConsoleLoggerState();
+            CheckIfOutputSupportsAlignment();
         }
 
         /// <summary>
@@ -447,7 +447,7 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
                 if (!String.Equals(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase))
                 {
                     //If no targetName was specified then do not show the target where the error occurred
-                    if (! string.IsNullOrEmpty(valuePair.Key.TargetName))
+                    if (!string.IsNullOrEmpty(valuePair.Key.TargetName))
                     {
                         WriteMessageAligned(ResourceUtilities.FormatResourceString("ErrorWarningInTarget", valuePair.Key.TargetName), false);
                     }
@@ -479,7 +479,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
             ErrorUtilities.VerifyThrowArgumentNull(e.ParentProjectBuildEventContext, "ParentProjectBuildEventContext");
-           
+
             // Add the project to the BuildManager so we can use the start information later in the build process
             buildEventManager.AddProjectStartedEvent(e);
 
@@ -515,7 +515,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 }
                 if (e.Properties != null)
                 {
-                    WriteProperties(e, e.Properties);          
+                    WriteProperties(e, e.Properties);
                 }
 
                 if (e.Items != null)
@@ -533,8 +533,8 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
         public override void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
-            
-            
+
+
             //Get the project started event so we can use its information to properly display a project finished event
             ProjectStartedEventMinimumFields startedEvent = buildEventManager.GetProjectStartedEvent(e.BuildEventContext);
             ErrorUtilities.VerifyThrow(startedEvent != null, "Started event should not be null in the finished event handler");
@@ -562,7 +562,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                         // should be shown
                         string targets = startedEvent.TargetNames;
                         string projectName = startedEvent.ProjectFile ?? string.Empty;
-                        
+
                         // Show which targets were built as part of this project
                         if (string.IsNullOrEmpty(targets))
                         {
@@ -626,7 +626,7 @@ internal void WriteProperties(BuildEventArgs e, IEnumerable properties)
             {
                 return;
             }
-          
+
             WriteLinePrefix(e.BuildEventContext, e.Timestamp, false);
             WriteProperties(propertyList);
             ShownBuildEventContext(e.BuildEventContext);
@@ -661,7 +661,7 @@ internal void WriteItems(BuildEventArgs e, IEnumerable items)
             }
 
             SortedList itemList = ExtractItemList(items);
-  
+
             // if there are no Items to display return out of the method and dont print out anything related to displaying
             // the items, this includes the multiproc prefix information or the Initial items header
             if (itemList.Count == 0)
@@ -682,7 +682,7 @@ internal override void OutputItems(string itemType, ArrayList itemTypeList)
                 string itemString = null;
                 if (!haveWrittenItemType)
                 {
-                    itemString=itemType;
+                    itemString = itemType;
                     setColor(ConsoleColor.DarkGray);
                     WriteMessageAligned(itemType, false);
                     haveWrittenItemType = true;
@@ -692,7 +692,7 @@ internal override void OutputItems(string itemType, ArrayList itemTypeList)
                 // Indent the text by two tab lengths
                 StringBuilder result = new StringBuilder();
                 result.Append(' ', 2 * tabWidth).Append(item.ItemSpec);
-                WriteMessageAligned(result.ToString() , false);
+                WriteMessageAligned(result.ToString(), false);
             }
             resetColor();
         }
@@ -704,7 +704,7 @@ internal override void OutputItems(string itemType, ArrayList itemTypeList)
         public override void TargetStartedHandler(object sender, TargetStartedEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
-            
+
             // Add the target started information to the buildEventManager so its information can be used
             // later in the build
             buildEventManager.AddTargetStartedEvent(e);
@@ -861,7 +861,7 @@ public override void ErrorHandler(object sender, BuildErrorEventArgs e)
             {
                 targetStartedEvent.ErrorInTarget = true;
             }
-          
+
             DisplayDeferredStartedEvents(e.BuildEventContext);
 
             // Display only if showOnlyWarnings is false;
@@ -983,8 +983,8 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                 // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be 
                 // buffered until the project started event is fired
                 if (
-                       hasBuildStarted 
-                       && e.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId 
+                       hasBuildStarted
+                       && e.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId
                        && buildEventManager.GetProjectStartedEvent(e.BuildEventContext) == null
                        && IsVerbosityAtLeast(LoggerVerbosity.Normal)
                     )
@@ -1050,9 +1050,9 @@ private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
             {
                 setColor(ConsoleColor.DarkGray);
             }
-            
+
             PrintTargetNamePerMessage(e, lightenText);
-          
+
             // On diagnostic or if showEventId is set the task message should also display the taskId to assist debugging
             if ((IsVerbosityAtLeast(LoggerVerbosity.Diagnostic) || showEventId) && e.BuildEventContext.TaskId != BuildEventContext.InvalidTaskId)
             {
@@ -1081,57 +1081,57 @@ private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
 
         private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText)
         {
-                // Event Context of the current message
-                BuildEventContext currentBuildEventContext = e.BuildEventContext;
+            // Event Context of the current message
+            BuildEventContext currentBuildEventContext = e.BuildEventContext;
 
-                // Should the target name be written before the message
-                bool writeTargetName = false;
-                string targetName = string.Empty;
+            // Should the target name be written before the message
+            bool writeTargetName = false;
+            string targetName = string.Empty;
 
-                // Does the context (Project, Node, Context, Target, NOT task) of the previous event match the current message
-                bool contextAreEqual = compareContextNodeIdTargetId.Equals(currentBuildEventContext, lastDisplayedBuildEventContext ?? null);
+            // Does the context (Project, Node, Context, Target, NOT task) of the previous event match the current message
+            bool contextAreEqual = compareContextNodeIdTargetId.Equals(currentBuildEventContext, lastDisplayedBuildEventContext ?? null);
 
-                TargetStartedEventMinimumFields targetStartedEvent = null;
-                // If the previous event does not have the same target context information, the target name needs to be printed to the console
-                // to give the message some more contextual information
-                if (!contextAreEqual)
+            TargetStartedEventMinimumFields targetStartedEvent = null;
+            // If the previous event does not have the same target context information, the target name needs to be printed to the console
+            // to give the message some more contextual information
+            if (!contextAreEqual)
+            {
+                targetStartedEvent = buildEventManager.GetTargetStartedEvent(currentBuildEventContext);
+                // Some messages such as engine messages will not have a target started event, in their case, dont print the targetName
+                if (targetStartedEvent != null)
                 {
-                    targetStartedEvent = buildEventManager.GetTargetStartedEvent(currentBuildEventContext);
-                    // Some messages such as engine messages will not have a target started event, in their case, dont print the targetName
-                    if (targetStartedEvent != null)
-                    {
-                        targetName = targetStartedEvent.TargetName;
-                        writeTargetName = true;
-                    }
+                    targetName = targetStartedEvent.TargetName;
+                    writeTargetName = true;
+                }
+            }
+            else
+            {
+                writeTargetName = false;
+            }
+
+            if (writeTargetName)
+            {
+                bool prefixAlreadyWritten = WriteTargetMessagePrefix(e, targetStartedEvent.ProjectBuildEventContext, targetStartedEvent.TimeStamp);
+
+                setColor(ConsoleColor.Cyan);
+                if (IsVerbosityAtLeast(LoggerVerbosity.Diagnostic) || showEventId)
+                {
+                    WriteMessageAligned(ResourceUtilities.FormatResourceString("TargetMessageWithId", targetName, e.BuildEventContext.TargetId), prefixAlreadyWritten);
                 }
                 else
                 {
-                    writeTargetName = false;
+                    WriteMessageAligned(targetName + ":", prefixAlreadyWritten);
                 }
 
-                if (writeTargetName)
+                if (lightenText)
                 {
-                    bool prefixAlreadyWritten = WriteTargetMessagePrefix(e, targetStartedEvent.ProjectBuildEventContext, targetStartedEvent.TimeStamp);
-
-                    setColor(ConsoleColor.Cyan);
-                    if (IsVerbosityAtLeast(LoggerVerbosity.Diagnostic) || showEventId)
-                    {
-                        WriteMessageAligned(ResourceUtilities.FormatResourceString("TargetMessageWithId", targetName, e.BuildEventContext.TargetId), prefixAlreadyWritten);
-                    }
-                    else
-                    {
-                        WriteMessageAligned(targetName + ":", prefixAlreadyWritten);
-                    }
-
-                    if (lightenText)
-                    {
-                        setColor(ConsoleColor.DarkGray);
-                    }
-                    else
-                    {
-                        resetColor();
-                    }
+                    setColor(ConsoleColor.DarkGray);
+                }
+                else
+                {
+                    resetColor();
                 }
+            }
         }
 
         private bool WriteTargetMessagePrefix(BuildEventArgs e, BuildEventContext context, DateTime timeStamp)
@@ -1250,14 +1250,14 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
             {
                 //Since the target started event has been shows, the target finished event should also be shown
                 targetStartedEvent.ShowTargetFinishedEvent = true;
-               
+
                 // If there are any other started events waiting and we are the first message, show them
                 DisplayDeferredStartedEvents(targetStartedEvent.ProjectBuildEventContext);
 
                 WriteLinePrefix(targetStartedEvent.ProjectBuildEventContext, targetStartedEvent.TimeStamp, false);
-                
+
                 setColor(ConsoleColor.Cyan);
-               
+
                 ProjectStartedEventMinimumFields startedEvent = buildEventManager.GetProjectStartedEvent(e);
                 ErrorUtilities.VerifyThrow(startedEvent != null, "Project Started should not be null in deferred target started");
                 string currentProjectFile = startedEvent.ProjectFile ?? string.Empty;
@@ -1265,7 +1265,7 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
                 string targetName;
                 if (IsVerbosityAtLeast(LoggerVerbosity.Diagnostic) || showEventId)
                 {
-                   targetName = ResourceUtilities.FormatResourceString("TargetMessageWithId", targetStartedEvent.TargetName, targetStartedEvent.ProjectBuildEventContext.TargetId);
+                    targetName = ResourceUtilities.FormatResourceString("TargetMessageWithId", targetStartedEvent.TargetName, targetStartedEvent.ProjectBuildEventContext.TargetId);
                 }
                 else
                 {
@@ -1448,7 +1448,7 @@ private ProjectFullKey GetFullProjectKey(BuildEventContext e)
                 return new ProjectFullKey(startedEvent.ProjectKey, startedEvent.EntryPointKey);
             }
         }
-        
+
         /// <summary>
         /// Returns a performance counter for a given scope (either task name or target name)
         /// from the given table.
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 8470aca7630..cc708bd6fe6 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -174,7 +174,7 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
         internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields buildEvent;
-            if ( projectStartedEvents.ContainsKey(e) )
+            if (projectStartedEvents.ContainsKey(e))
             {
                 buildEvent = projectStartedEvents[e];
             }
@@ -191,7 +191,7 @@ internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventConte
         internal TargetStartedEventMinimumFields GetTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields buildEvent;
-            if ( targetStartedEvents.ContainsKey(e))
+            if (targetStartedEvents.ContainsKey(e))
             {
                 buildEvent = targetStartedEvents[e];
             }
@@ -560,7 +560,7 @@ public override bool Equals(object obj)
             {
                 return false;
             }
-           return  eventComparer.Equals(entryPointContext, key.EntryPointContext) && (String.Equals(targetName, key.TargetName, StringComparison.OrdinalIgnoreCase));
+            return eventComparer.Equals(entryPointContext, key.EntryPointContext) && (String.Equals(targetName, key.TargetName, StringComparison.OrdinalIgnoreCase));
         }
 
         public override int GetHashCode()
@@ -607,7 +607,7 @@ internal ProjectFullKey(int projectKey, int entryPointKey)
         /// <summary>
         /// Output the projectKey or the projectKey and the entrypointKey depending on the verbosity level of the logger
         /// </summary>
-        
+
         public string ToString(LoggerVerbosity verbosity)
         {
             string fullProjectKey;
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index 319e9e551e2..89a5d2ac4c6 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -194,7 +194,7 @@ private void ShowErrorWarningSummary()
             if (warningCount > 0)
             {
                 setColor(ConsoleColor.Yellow);
-                foreach(BuildWarningEventArgs warningEventArgs in warningList)
+                foreach (BuildWarningEventArgs warningEventArgs in warningList)
                 {
                     WriteLinePretty(EventArgsFormatting.FormatEventMessage(warningEventArgs, runningWithCharacterFileType));
                 }
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index d8c445e7665..806fd7d6f0e 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -116,7 +116,7 @@ internal void WriteToStream(BinaryWriter writer)
             else
             {
                 writer.Write((byte)0);
-                  writer.Write(finalValueEscaped);
+                writer.Write(finalValueEscaped);
             }
             writer.Write((Int32)type);
         }
@@ -181,8 +181,8 @@ internal static void ClearInternTable()
         /// <owner>rgoel</owner>
         internal BuildProperty
         (
-            XmlElement      propertyElement,
-            PropertyType    propertyType
+            XmlElement propertyElement,
+            PropertyType propertyType
         ) :
             this(propertyElement,
                  propertyElement != null ? Utilities.GetXmlNodeInnerContents(propertyElement) : null,
@@ -579,7 +579,7 @@ internal BuildPropertyGroup ParentPersistedPropertyGroup
 
             set
             {
-                ErrorUtilities.VerifyThrow( ((value == null) && (this.parentPersistedPropertyGroup != null)) || ((value != null) && (this.parentPersistedPropertyGroup == null)),
+                ErrorUtilities.VerifyThrow(((value == null) && (this.parentPersistedPropertyGroup != null)) || ((value != null) && (this.parentPersistedPropertyGroup == null)),
                     "Either new parent cannot be assigned because we already have a parent, or old parent cannot be removed because none exists.");
 
                 this.parentPersistedPropertyGroup = value;
@@ -699,9 +699,9 @@ BuildProperty compareToProperty
             return
                 (compareToProperty != null) &&
                 (String.Equals(compareToProperty.propertyName, this.propertyName, StringComparison.OrdinalIgnoreCase)) &&
-                (compareToProperty.propertyValue                == this.propertyValue) &&
-                (compareToProperty.FinalValue                   == this.FinalValue) &&
-                (compareToProperty.type                         == this.type);
+                (compareToProperty.propertyValue == this.propertyValue) &&
+                (compareToProperty.FinalValue == this.FinalValue) &&
+                (compareToProperty.type == this.type);
         }
 
         /// <summary>
@@ -712,7 +712,7 @@ public override string ToString
             (
             )
         {
-            return (string) this;
+            return (string)this;
         }
 
         #endregion
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index 13646e3e2a8..ace35b7b13a 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -251,7 +251,7 @@ internal BuildPropertyGroup(Project parentProject, XmlElement propertyGroupEleme
                 {
                     // Handle XML comments under the <PropertyGroup> node (just ignore them).
                     case XmlNodeType.Comment:
-                        // fall through
+                    // fall through
                     case XmlNodeType.Whitespace:
                         // ignore whitespace
                         break;
@@ -443,7 +443,7 @@ internal XmlElement ParentElement
                 {
                     if (this.propertyGroupElement.ParentNode is XmlElement)
                     {
-                        return (XmlElement) this.propertyGroupElement.ParentNode;
+                        return (XmlElement)this.propertyGroupElement.ParentNode;
                     }
                 }
 
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
index 46109721ae2..5940743aca5 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
@@ -21,7 +21,7 @@ internal class BuildPropertyGroupProxy : IEnumerable
         private BuildPropertyGroup backingPropertyGroup;
 
         private BuildPropertyGroupProxy()
-        { 
+        {
             // Do nothing
         }
 
diff --git a/src/Deprecated/Engine/Resources/AssemblyResources.cs b/src/Deprecated/Engine/Resources/AssemblyResources.cs
index 86fb684811f..f34e7776f63 100644
--- a/src/Deprecated/Engine/Resources/AssemblyResources.cs
+++ b/src/Deprecated/Engine/Resources/AssemblyResources.cs
@@ -98,7 +98,7 @@ private static string GetStringFromMSBuildExeResources(string name)
                 // Try MSBuild.exe's resources
                 resource = msbuildExeResourceManager.GetString(name, CultureInfo.CurrentUICulture);
             }
-            
+
             return resource;
         }
 
diff --git a/src/Deprecated/Engine/Resources/Constants.cs b/src/Deprecated/Engine/Resources/Constants.cs
index fa46c5249ee..fea8c02ea33 100644
--- a/src/Deprecated/Engine/Resources/Constants.cs
+++ b/src/Deprecated/Engine/Resources/Constants.cs
@@ -14,23 +14,23 @@ namespace Microsoft.Build.BuildEngine
     /// <owner>RGoel</owner>
     internal static class ReservedPropertyNames
     {
-        internal const string projectDirectory        = "MSBuildProjectDirectory";
-        internal const string projectDirectoryNoRoot  = "MSBuildProjectDirectoryNoRoot";
-        internal const string projectFile             = "MSBuildProjectFile";
-        internal const string projectExtension        = "MSBuildProjectExtension";
-        internal const string projectFullPath         = "MSBuildProjectFullPath";
-        internal const string projectName             = "MSBuildProjectName";
-        internal const string binPath                 = "MSBuildBinPath";
-        internal const string projectDefaultTargets   = "MSBuildProjectDefaultTargets";
-        internal const string extensionsPath          = "MSBuildExtensionsPath";
-        internal const string extensionsPath32        = "MSBuildExtensionsPath32";
-        internal const string toolsPath               = "MSBuildToolsPath";
-        internal const string toolsVersion            = "MSBuildToolsVersion";
-        internal const string startupDirectory        = "MSBuildStartupDirectory";
-        internal const string buildNodeCount          = "MSBuildNodeCount";
-        internal const string extensionsPathSuffix    = "MSBuild";
-        internal const string programFiles32          = "MSBuildProgramFiles32";
-        internal const string assemblyVersion         = "MSBuildAssemblyVersion";
+        internal const string projectDirectory = "MSBuildProjectDirectory";
+        internal const string projectDirectoryNoRoot = "MSBuildProjectDirectoryNoRoot";
+        internal const string projectFile = "MSBuildProjectFile";
+        internal const string projectExtension = "MSBuildProjectExtension";
+        internal const string projectFullPath = "MSBuildProjectFullPath";
+        internal const string projectName = "MSBuildProjectName";
+        internal const string binPath = "MSBuildBinPath";
+        internal const string projectDefaultTargets = "MSBuildProjectDefaultTargets";
+        internal const string extensionsPath = "MSBuildExtensionsPath";
+        internal const string extensionsPath32 = "MSBuildExtensionsPath32";
+        internal const string toolsPath = "MSBuildToolsPath";
+        internal const string toolsVersion = "MSBuildToolsVersion";
+        internal const string startupDirectory = "MSBuildStartupDirectory";
+        internal const string buildNodeCount = "MSBuildNodeCount";
+        internal const string extensionsPathSuffix = "MSBuild";
+        internal const string programFiles32 = "MSBuildProgramFiles32";
+        internal const string assemblyVersion = "MSBuildAssemblyVersion";
 
         /// <summary>
         /// Indicates if the given property is a reserved property.
@@ -73,7 +73,7 @@ internal static class Constants
         /// </summary>
         internal const string defaultFallbackToolsVersion = "4.0";
 
-        
+
         internal const string defaultSolutionWrapperProjectToolsVersion = "4.0";
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
index cf9e5f80249..1e104a7481f 100644
--- a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
@@ -101,7 +101,7 @@ public override int GetHashCode()
         /// </summary>
         /// <returns></returns>
         /// <owner>RGoel</owner>
-        public override bool Equals(Object obj) 
+        public override bool Equals(Object obj)
         {
             if (obj == null)
             {
@@ -109,7 +109,7 @@ public override bool Equals(Object obj)
             }
 
             AssemblyLoadInfo otherAssemblyInfo = obj as AssemblyLoadInfo;
-            
+
             if (otherAssemblyInfo == null)
             {
                 return false;
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index 295c9001b5a..85b8218f75b 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -62,7 +62,7 @@ internal AssemblyNameExtension(string assemblyName)
         /// Used when the assembly name comes from a user-controlled source like a project file or config file.
         /// Does extra checking on the assembly name and will throw exceptions if something is invalid.
         /// </param>
-        internal AssemblyNameExtension(string assemblyName, bool validate) 
+        internal AssemblyNameExtension(string assemblyName, bool validate)
         {
             asString = assemblyName;
 
@@ -87,7 +87,7 @@ internal static AssemblyNameExtension GetAssemblyNameEx(string path)
             }
             return new AssemblyNameExtension(assemblyName);
         }
-        
+
         /// <summary>
         /// Assume there is a string version, create the AssemblyName version.
         /// </summary>
@@ -348,7 +348,7 @@ private static int CompareBaseNamesStringWise(string asString1, string asString2
             }
 
             // If the lengths are the same then we can compare without copying.
-            if (baseLenThis == baseLenThat) 
+            if (baseLenThis == baseLenThat)
             {
                 return String.Compare(asString1, 0, asString2, 0, baseLenThis, StringComparison.OrdinalIgnoreCase);
             }
@@ -356,7 +356,7 @@ private static int CompareBaseNamesStringWise(string asString1, string asString2
             // Lengths are different, so string copy is required.
             string nameThis = asString1.Substring(0, baseLenThis);
             string nameThat = asString2.Substring(0, baseLenThat);
-            return String.Compare(nameThis, nameThat, StringComparison.OrdinalIgnoreCase);   
+            return String.Compare(nameThis, nameThat, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -392,7 +392,7 @@ internal bool Equals(AssemblyNameExtension that)
 
                 // If they weren't identical then they might still differ only by
                 // case. So we can't assume that they don't match. So fall through...
-                
+
             }
 
             // Do the names match?
diff --git a/src/Deprecated/Engine/Shared/ConversionUtilities.cs b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
index faa3cc499c3..45fcb05860b 100644
--- a/src/Deprecated/Engine/Shared/ConversionUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.BuildEngine.Shared
     /// This class contains only static methods, which are useful throughout many
     /// of the MSBuild classes and don't really belong in any specific class.   
     /// </summary>
-    internal static class ConversionUtilities 
+    internal static class ConversionUtilities
     {
         /// <summary>
         /// Converts a string to a bool.  We consider "true/false", "on/off", and 
diff --git a/src/Deprecated/Engine/Shared/EscapingUtilities.cs b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
index 3c6ecf1eb1c..437566dca93 100644
--- a/src/Deprecated/Engine/Shared/EscapingUtilities.cs
+++ b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
@@ -64,7 +64,7 @@ out bool escapingWasNecessary
             {
                 // There must be two hex characters following the percent sign
                 // for us to even consider doing anything with this.
-                if  (
+                if (
                         (indexOfPercent <= (escapedString.Length - 3)) &&
                         Uri.IsHexDigit(escapedString[indexOfPercent + 1]) &&
                         Uri.IsHexDigit(escapedString[indexOfPercent + 2])
@@ -76,7 +76,7 @@ out bool escapingWasNecessary
 
                     // Convert the %XX to an actual real character.
                     string hexString = escapedString.Substring(indexOfPercent + 1, 2);
-                    char unescapedCharacter = (char) int.Parse(hexString, System.Globalization.NumberStyles.HexNumber,
+                    char unescapedCharacter = (char)int.Parse(hexString, System.Globalization.NumberStyles.HexNumber,
                         CultureInfo.InvariantCulture);
 
                     // if the unescaped character is not on the exception list, append it
@@ -164,7 +164,7 @@ string escapedString
             if (-1 != escapedString.IndexOf('%'))
             {
                 // It has a '%' sign.  We have promise.
-                if  (
+                if (
                         (-1 != escapedString.IndexOf("%2", StringComparison.Ordinal)) ||
                         (-1 != escapedString.IndexOf("%3", StringComparison.Ordinal))
                     )
diff --git a/src/Deprecated/Engine/Shared/ExceptionHandling.cs b/src/Deprecated/Engine/Shared/ExceptionHandling.cs
index f1d72ddd637..f363fcb21fb 100644
--- a/src/Deprecated/Engine/Shared/ExceptionHandling.cs
+++ b/src/Deprecated/Engine/Shared/ExceptionHandling.cs
@@ -26,7 +26,7 @@ internal static bool IsCriticalException(Exception e)
                 e is StackOverflowException
                 || e is OutOfMemoryException
                 || e is AccessViolationException
-                // ExecutionEngineException has been deprecated by the CLR
+            // ExecutionEngineException has been deprecated by the CLR
             )
             {
                 return true;
diff --git a/src/Deprecated/Engine/Shared/FileMatcher.cs b/src/Deprecated/Engine/Shared/FileMatcher.cs
index 3292f664426..06d78b8be80 100644
--- a/src/Deprecated/Engine/Shared/FileMatcher.cs
+++ b/src/Deprecated/Engine/Shared/FileMatcher.cs
@@ -17,8 +17,8 @@ internal static class FileMatcher
     {
         private const string recursiveDirectoryMatch = "**";
         private const string dotdot = "..";
-        private static readonly string directorySeparator = new string(Path.DirectorySeparatorChar,1);
-        private static readonly string altDirectorySeparator = new string(Path.AltDirectorySeparatorChar,1);
+        private static readonly string directorySeparator = new string(Path.DirectorySeparatorChar, 1);
+        private static readonly string altDirectorySeparator = new string(Path.AltDirectorySeparatorChar, 1);
 
         private static readonly char[] wildcardCharacters = { '*', '?' };
         internal static readonly char[] directorySeparatorCharacters = { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar };
@@ -143,7 +143,7 @@ private static string[] GetAccessibleFiles
             string path,
             string filespec,     // can be null
             string projectDirectory,
-            bool   stripProjectDirectory
+            bool stripProjectDirectory
         )
         {
             try
@@ -299,7 +299,7 @@ GetFileSystemEntries getFileSystemEntries
                 // If there is a zero-length part, then that means there was an extra slash.
                 if (parts[i].Length == 0)
                 {
-                    longParts[i-startingElement] = String.Empty;
+                    longParts[i - startingElement] = String.Empty;
                 }
                 else
                 {
@@ -318,7 +318,7 @@ GetFileSystemEntries getFileSystemEntries
                         {
                             // The next part doesn't exist. Therefore, no more of the path will exist.
                             // Just return the rest.
-                            for (int j = i; j<parts.Length; ++j)
+                            for (int j = i; j < parts.Length; ++j)
                             {
                                 longParts[j - startingElement] = parts[j];
                             }
@@ -339,7 +339,7 @@ GetFileSystemEntries getFileSystemEntries
                 }
             }
 
-            return pathRoot + String.Join (directorySeparator, longParts);
+            return pathRoot + String.Join(directorySeparator, longParts);
         }
 
         /// <summary>
@@ -446,9 +446,9 @@ out string filenamePart
                  */
 
                 // We know the fixed director part now.
-                fixedDirectoryPart = filespec.Substring (0, indexOfLastDirectorySeparator + 1);
+                fixedDirectoryPart = filespec.Substring(0, indexOfLastDirectorySeparator + 1);
                 wildcardDirectoryPart = String.Empty;
-                filenamePart = filespec.Substring (indexOfLastDirectorySeparator + 1);
+                filenamePart = filespec.Substring(indexOfLastDirectorySeparator + 1);
                 return;
             }
 
@@ -469,17 +469,17 @@ out string filenamePart
                  *      dir?\**
                  */
                 fixedDirectoryPart = String.Empty;
-                wildcardDirectoryPart = filespec.Substring (0, indexOfLastDirectorySeparator + 1);
-                filenamePart = filespec.Substring (indexOfLastDirectorySeparator + 1);
+                wildcardDirectoryPart = filespec.Substring(0, indexOfLastDirectorySeparator + 1);
+                filenamePart = filespec.Substring(indexOfLastDirectorySeparator + 1);
                 return;
             }
 
             /*
              * There is at least one wildcard and one dir separator, split parts out.
              */
-            fixedDirectoryPart = filespec.Substring(0, indexOfSeparatorBeforeWildCard+1);
-            wildcardDirectoryPart = filespec.Substring(indexOfSeparatorBeforeWildCard+1, indexOfLastDirectorySeparator-indexOfSeparatorBeforeWildCard);
-            filenamePart = filespec.Substring(indexOfLastDirectorySeparator+1);
+            fixedDirectoryPart = filespec.Substring(0, indexOfSeparatorBeforeWildCard + 1);
+            wildcardDirectoryPart = filespec.Substring(indexOfSeparatorBeforeWildCard + 1, indexOfLastDirectorySeparator - indexOfSeparatorBeforeWildCard);
+            filenamePart = filespec.Substring(indexOfLastDirectorySeparator + 1);
         }
 
         /// <summary>
@@ -491,7 +491,7 @@ private static void RemoveInitialDotSlash
             string[] paths
         )
         {
-            for (int i=0; i < paths.Length; i++)
+            for (int i = 0; i < paths.Length; i++)
             {
                 if (paths[i].StartsWith(".\\", StringComparison.Ordinal))
                 {
@@ -500,7 +500,7 @@ string[] paths
             }
         }
 
-      
+
         /// <summary>
         /// Checks if the char is a DirectorySeparatorChar or a AltDirectorySeparatorChar
         /// </summary>
@@ -522,7 +522,7 @@ string projectDirectory
         )
         {
             bool directoryLastCharIsSeparator = IsDirectorySeparator(projectDirectory[projectDirectory.Length - 1]);
-             for (int i = 0; i < paths.Length; i++)
+            for (int i = 0; i < paths.Length; i++)
             {
                 if (paths[i].StartsWith(projectDirectory, StringComparison.Ordinal))
                 {
@@ -567,7 +567,7 @@ private static void GetFilesRecursive
             Regex regexFileMatch,           // can be null
             bool needsRecursion,
             string projectDirectory,
-            bool   stripProjectDirectory,
+            bool stripProjectDirectory,
             GetFileSystemEntries getFileSystemEntries
         )
         {
@@ -577,7 +577,7 @@ GetFileSystemEntries getFileSystemEntries
             ErrorUtilities.VerifyThrow((filespec != null) || (regexFileMatch != null),
                 "Need either a file-spec or a regular expression to match files.");
 
-            ErrorUtilities.VerifyThrow(remainingWildcardDirectory!=null, "Expected non-null remaning wildcard directory.");
+            ErrorUtilities.VerifyThrow(remainingWildcardDirectory != null, "Expected non-null remaning wildcard directory.");
 
             /*
              * Get the matching files.
@@ -621,7 +621,7 @@ GetFileSystemEntries getFileSystemEntries
             /*
              * Recurse into subdirectories.
              */
-            if (needsRecursion && remainingWildcardDirectory.Length>0)
+            if (needsRecursion && remainingWildcardDirectory.Length > 0)
             {
                 // Find the next directory piece.
                 string pattern = null;
@@ -1153,7 +1153,7 @@ DirectoryExists directoryExists
              * might potentially do a lot of that.
              */
             System.Collections.ArrayList arrayListOfFiles = new System.Collections.ArrayList();
-            System.Collections.IList listOfFiles = (System.Collections.IList) arrayListOfFiles;
+            System.Collections.IList listOfFiles = (System.Collections.IList)arrayListOfFiles;
 
             /*
              * Analyze the file spec and get the information we need to do the matching.
@@ -1226,7 +1226,7 @@ DirectoryExists directoryExists
                 (wildcardDirectoryPart.Length > 0) &&
                 // the specification is not a simple "**"
                 (wildcardDirectoryPart != (recursiveDirectoryMatch + directorySeparator));
-                // then we need to use the regular expression
+            // then we need to use the regular expression
 
             // if we're not using the regular expression, get the file pattern extension
             string extensionPart = matchWithRegex
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index 9c6e9ef2257..2ea549249bf 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -109,7 +109,7 @@ internal static bool IsItemSpecModifier(string name)
              * therefore is not an item spec modifier.
              * 
              */
-            switch (name.Length) 
+            switch (name.Length)
             {
                 case 7: // RootDir
                     switch (name[0])
@@ -122,12 +122,12 @@ internal static bool IsItemSpecModifier(string name)
                                 return true;
                             }
                             break;
-                        case 'r':        
+                        case 'r':
                             break;
                     }
                     break;
                 case 8: // FullPath, Filename, Identity
-     
+
                     switch (name[0])
                     {
                         default:
@@ -150,7 +150,7 @@ internal static bool IsItemSpecModifier(string name)
                                 return true;
                             }
                             break;
-                        case 'i':        
+                        case 'i':
                             break;
                     }
                     break;
@@ -165,7 +165,7 @@ internal static bool IsItemSpecModifier(string name)
                                 return true;
                             }
                             break;
-                        case 'd':        
+                        case 'd':
                             break;
                         case 'E': // Extension
                             if (name == ItemSpecModifiers.Extension)
@@ -173,9 +173,9 @@ internal static bool IsItemSpecModifier(string name)
                                 return true;
                             }
                             break;
-                        case 'e':        
+                        case 'e':
                             break;
-                    }             
+                    }
                     break;
                 case 11: // RelativeDir, CreatedTime
                     switch (name[0])
@@ -196,10 +196,10 @@ internal static bool IsItemSpecModifier(string name)
                                 return true;
                             }
                             break;
-                        case 'r':        
+                        case 'r':
                             break;
                     }
-                    break; 
+                    break;
                 case 12: // RecursiveDir, ModifiedTime, AccessedTime
 
                     switch (name[0])
@@ -212,7 +212,7 @@ internal static bool IsItemSpecModifier(string name)
                                 return true;
                             }
                             break;
-                        case 'a':        
+                        case 'a':
                             break;
                         case 'M': // ModifiedTime
                             if (name == ItemSpecModifiers.ModifiedTime)
@@ -220,7 +220,7 @@ internal static bool IsItemSpecModifier(string name)
                                 return true;
                             }
                             break;
-                        case 'm':        
+                        case 'm':
                             break;
                         case 'R': // RecursiveDir
                             if (name == ItemSpecModifiers.RecursiveDir)
@@ -228,7 +228,7 @@ internal static bool IsItemSpecModifier(string name)
                                 return true;
                             }
                             break;
-                        case 'r':        
+                        case 'r':
                             break;
                     }
                     break;
@@ -236,7 +236,7 @@ internal static bool IsItemSpecModifier(string name)
                     // Not the right length for a match.
                     return false;
             }
-                   
+
 
             // Could still be a case-insensitive match.
             bool result = ItemSpecModifiers.TableOfItemSpecModifiers.ContainsKey(name);
@@ -266,7 +266,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
             }
 
             return isItemSpecModifier;
-       }
+        }
 
         /// <summary>
         /// Performs path manipulations on the given item-spec as directed.
@@ -500,7 +500,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                     if (cachedModifiers == null)
                     {
                         cachedModifiers = new Hashtable(StringComparer.OrdinalIgnoreCase);
-     
+
                         // mark the cache to indicate the item-spec for which it was created
                         // NOTE: we've intentionally picked a key here that will never conflict with any modifier name -- if we
                         // use the item-spec as the key, it's possible for it to conflict with the name of a modifier
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index 20c1c45cb27..2ab755444f8 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -42,7 +42,7 @@ internal static class FrameworkLocationHelper
         internal const string dotNetFrameworkVersionFolderPrefixV30 = "v3.0"; // v3.0 is for WinFx.
         private const string dotNetFrameworkVersionV30 = "v3.0"; // full WinFx version to pass to NativeMethodsShared.GetRequestedRuntimeInfo().
         private const string dotNetFrameworkAssemblyFoldersRegistryKeyV30 = dotNetFrameworkAssemblyFoldersRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV30;
-        private const string dotNetFrameworkRegistryKeyV30 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV30 +"\\Setup";
+        private const string dotNetFrameworkRegistryKeyV30 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV30 + "\\Setup";
 
         private const string dotNetFrameworkSdkRegistryPathV35 = "SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v7.0A";
         internal const string fullDotNetFrameworkSdkRegistryKeyV35 = "HKEY_LOCAL_MACHINE\\" + dotNetFrameworkSdkRegistryPathV35;
@@ -357,7 +357,7 @@ internal static string PathToDotNetFrameworkReferenceAssembliesV40
 
                     if (FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV40 == null)
                     {
-                       FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV40 = GenerateReferenceAssemblyDirectory(dotNetFrameworkVersionFolderPrefixV40);
+                        FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV40 = GenerateReferenceAssemblyDirectory(dotNetFrameworkVersionFolderPrefixV40);
                     }
                 }
 
@@ -448,7 +448,7 @@ string registryKeyName
         /// <returns>True if the registry key is 1 false if it is not there. This method also return true if the complus enviornment variables are set.</returns>
         internal static bool CheckForFrameworkInstallation(string registryEntryToCheckInstall, string registryValueToCheckInstall)
         {
-             // Get the complus install root and version
+            // Get the complus install root and version
             string complusInstallRoot = Environment.GetEnvironmentVariable("COMPLUS_INSTALLROOT");
             string complusVersion = Environment.GetEnvironmentVariable("COMPLUS_VERSION");
 
diff --git a/src/Deprecated/Engine/Shared/InternalErrorException.cs b/src/Deprecated/Engine/Shared/InternalErrorException.cs
index 4cef1bf4699..774a0daaaf8 100644
--- a/src/Deprecated/Engine/Shared/InternalErrorException.cs
+++ b/src/Deprecated/Engine/Shared/InternalErrorException.cs
@@ -73,8 +73,8 @@ private InternalErrorException(SerializationInfo info, StreamingContext context)
             // Do nothing: no fields
         }
 
-	// Base implementation of GetObjectData() is sufficient; we have no fields
+        // Base implementation of GetObjectData() is sufficient; we have no fields
 
         #endregion
-   }
+    }
 }
diff --git a/src/Deprecated/Engine/Shared/LoadedType.cs b/src/Deprecated/Engine/Shared/LoadedType.cs
index 6cbb2758453..b8be93e40c7 100644
--- a/src/Deprecated/Engine/Shared/LoadedType.cs
+++ b/src/Deprecated/Engine/Shared/LoadedType.cs
@@ -70,7 +70,7 @@ public Dictionary<string, string> GetNamesOfPropertiesWithOutputAttribute()
         /// <param name="propertyName">property name</param>
         /// <returns>PropertyInfo</returns>
         public PropertyInfo GetProperty(string propertyName)
-        {   
+        {
             if (propertyInfoCache == null)
             {
                 PopulatePropertyInfoCache();
diff --git a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
index 2ca73148bb5..b4edc886547 100644
--- a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
+++ b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
@@ -147,7 +147,7 @@ internal static extern uint GetRequestedRuntimeInfo(String pExe,
         /// <summary>
         /// Gets the fully qualified filename of the currently executing .exe
         /// </summary>
-        [DllImport(kernel32Dll, SetLastError=true, CharSet = CharSet.Unicode)]
+        [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
         internal static extern int GetModuleFileName(HandleRef hModule, StringBuilder buffer, int length);
 
         [DllImport("kernel32.dll")]
diff --git a/src/Deprecated/Engine/Shared/ProjectWriter.cs b/src/Deprecated/Engine/Shared/ProjectWriter.cs
index cfd98bf6e8e..b36bd0c362c 100644
--- a/src/Deprecated/Engine/Shared/ProjectWriter.cs
+++ b/src/Deprecated/Engine/Shared/ProjectWriter.cs
@@ -33,7 +33,7 @@ internal sealed class ProjectWriter : XmlTextWriter
                 (?<TRANSFORM_SPECIFICATION>(?<ARROW>\s*->\s*)(?<TRANSFORM>'[^']*'))
                 (?<SEPARATOR_SPECIFICATION>\s*,\s*'[^']*')?
               (?<SUFFIX>\s*\))";
-                                                      // )
+        // )
 
         // regular expression used to match item vector transforms
         // internal for unit testing only
@@ -112,8 +112,8 @@ internal void Initialize(XmlDocument project, XmlDeclaration projectXmlDeclarati
             }
 
             // don't write an XML declaration unless the project already has one or has non-default encoding
-            writeXmlDeclaration = 
-                ((projectXmlDeclaration != null) || 
+            writeXmlDeclaration =
+                ((projectXmlDeclaration != null) ||
                 ((documentEncoding != Encoding.UTF8) && (documentEncoding != null)));
         }
 
@@ -183,7 +183,7 @@ public override void WriteString(string text)
                 }
 
                 // write the terminal piece of text after the last transform
-                base.WriteString(surroundingTextPieces[surroundingTextPieces.Length-1]);
+                base.WriteString(surroundingTextPieces[surroundingTextPieces.Length - 1]);
             }
             // if the string has no item vector transforms in it, write it out as usual
             else
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index 3be5976f2aa..cd0943cc076 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -127,7 +127,7 @@ internal static string FormatString(string unformatted, params object[] args)
             {
 #if DEBUG
 
-    #if VALIDATERESOURCESTRINGS
+#if VALIDATERESOURCESTRINGS
                 // The code below reveals many places in our codebase where
                 // we're not using all of the data given to us to format
                 // strings -- but there are too many to presently fix.
@@ -166,8 +166,8 @@ internal static string FormatString(string unformatted, params object[] args)
                     caughtFormatException,
                     String.Format("The provided format string '{0}' had fewer format parameters than the number of format args, '{1}'.", unformatted, args.Length)
                 );
-    #endif 
-               
+#endif
+
 #endif
                 // Format the string, using the variable arguments passed in.
                 // NOTE: all String methods are thread-safe
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 0aa3861f555..a232628c43b 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -29,8 +29,8 @@ internal class SolutionParser
         (
             "^"                                             // Beginning of line
             + "Project\\(\"(?<PROJECTTYPEGUID>.*)\"\\)"
-            +"\\s*=\\s*"                                    // Any amount of whitespace plus "=" plus any amount of whitespace
-            +"\"(?<PROJECTNAME>.*)\""
+            + "\\s*=\\s*"                                    // Any amount of whitespace plus "=" plus any amount of whitespace
+            + "\"(?<PROJECTNAME>.*)\""
             + "\\s*,\\s*"                                   // Any amount of whitespace plus "," plus any amount of whitespace
             + "\"(?<RELATIVEPATH>.*)\""
             + "\\s*,\\s*"                                   // Any amount of whitespace plus "," plus any amount of whitespace
@@ -45,13 +45,13 @@ internal class SolutionParser
         (
             "^"                                             // Beginning of line
             + "(?<PROPERTYNAME>[^=]*)"
-            +"\\s*=\\s*"                                    // Any amount of whitespace plus "=" plus any amount of whitespace
-            +"(?<PROPERTYVALUE>[^=]*)"
+            + "\\s*=\\s*"                                    // Any amount of whitespace plus "=" plus any amount of whitespace
+            + "(?<PROPERTYVALUE>[^=]*)"
             + "$"                                           // End-of-line
         );
 
         internal const int slnFileMinUpgradableVersion = 7; // Minimum version for MSBuild to give a nice message
-        internal const int slnFileMinVersion           = 9; // Minimum version for MSBuild to actually do anything useful
+        internal const int slnFileMinVersion = 9; // Minimum version for MSBuild to actually do anything useful
         internal const int slnFileMaxVersion = VisualStudioConstants.CurrentVisualStudioSolutionFileVersion;
 
         private const string vbProjectGuid = "{F184B08F-C81C-45F6-A57F-5ABD9991F28F}";
@@ -263,7 +263,7 @@ internal ProjectInSolution[] Projects
         {
             get
             {
-                return (ProjectInSolution[]) this.projectsInOrder.ToArray(typeof(ProjectInSolution));
+                return (ProjectInSolution[])this.projectsInOrder.ToArray(typeof(ProjectInSolution));
             }
         }
 
@@ -424,7 +424,7 @@ private void ParseFileHeader()
             const string slnFileHeaderNoVersion = "Microsoft Visual Studio Solution File, Format Version ";
 
             // Read the file header.  This can be on either of the first two lines.
-            for (int i=1 ; i<=2 ; i++)
+            for (int i = 1; i <= 2; i++)
             {
                 string str = ReadLine();
                 if (str == null)
@@ -472,14 +472,14 @@ private void ValidateSolutionFileVersion(string versionString)
                 // This happens if the version stamp wasn't a properly formed version number,
                 // as in "1.a.b.c".
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false, "SubCategoryForSolutionParsingErrors",
-                    new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), "SolutionParseVersionMismatchError", 
+                    new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), "SolutionParseVersionMismatchError",
                     slnFileMinUpgradableVersion, slnFileMaxVersion);
             }
             catch (ArgumentException)
             {
                 // This happens if the version stamp wasn't a properly formed version number.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false, "SubCategoryForSolutionParsingErrors",
-                    new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), "SolutionParseVersionMismatchError", 
+                    new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), "SolutionParseVersionMismatchError",
                     slnFileMinUpgradableVersion, slnFileMaxVersion);
             }
 
@@ -489,8 +489,8 @@ private void ValidateSolutionFileVersion(string versionString)
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
                 this.slnFileActualVersion >= slnFileMinUpgradableVersion,
                 "SubCategoryForSolutionParsingErrors",
-                new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), 
-                "SolutionParseVersionMismatchError", 
+                new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0),
+                "SolutionParseVersionMismatchError",
                 slnFileMinUpgradableVersion, slnFileMaxVersion);
 
             // If the solution file version is greater than the maximum one we will create a comment rather than warn
@@ -641,7 +641,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                 {
                     etpProjectDocument.Load(xmlReader);
                 }
-                
+
                 // We need to parse the .etp project file to get the names of projects contained
                 // in the .etp Project. The projects are listed under /EFPROJECT/GENERAL/References/Reference node in the .etp project file.
                 // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain 
@@ -742,7 +742,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                    etpProj.RelativePath, e.Message);
                 solutionParserWarnings.Add(warning);
                 solutionParserErrorCodes.Add(errorCode);
-            }  
+            }
         }
 
         /// <summary>
@@ -757,7 +757,7 @@ private void AddProjectToSolution(ProjectInSolution proj)
             }
             projectsInOrder.Add(proj);
         }
-        
+
         /// <summary>
         /// Checks whether a given project has a .etp extension.
         /// </summary>
@@ -951,7 +951,7 @@ string propertyValue
                             // Cut out the guid part
                             if ((indexOfOpeningBrace != -1) && (indexOfClosingBrace != -1))
                             {
-                                string referencedProjectGuid = projectReferenceEntry.Substring(indexOfOpeningBrace, 
+                                string referencedProjectGuid = projectReferenceEntry.Substring(indexOfOpeningBrace,
                                     indexOfClosingBrace - indexOfOpeningBrace + 1);
 
                                 proj.Dependencies.Add(referencedProjectGuid);
@@ -1008,10 +1008,10 @@ ProjectInSolution proj
             proj.ProjectName = match.Groups["PROJECTNAME"].Value.Trim();
             proj.RelativePath = match.Groups["RELATIVEPATH"].Value.Trim();
             proj.ProjectGuid = match.Groups["PROJECTGUID"].Value.Trim();
-            
+
             // Validate project relative path
             ValidateProjectRelativePath(proj);
-            
+
             // Figure out what type of project this is.
             if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
@@ -1189,7 +1189,7 @@ internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurati
             // the entry name instead of constructing it and looking it up. Although it's pretty unlikely that
             // this would ever be a problem, it's safer to do it the same way VS IDE does it.
             char[] configPlatformSeparators = new char[] { ConfigurationInSolution.configurationPlatformSeparator };
-            
+
             foreach (ProjectInSolution project in this.projectsInOrder)
             {
                 // Solution folders don't have configurations
@@ -1199,7 +1199,7 @@ internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurati
                     {
                         // The "ActiveCfg" entry defines the active project configuration in the given solution configuration
                         // This entry must be present for every possible solution configuration/project combination.
-                        string entryNameActiveConfig = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.ActiveCfg", 
+                        string entryNameActiveConfig = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.ActiveCfg",
                             project.ProjectGuid, solutionConfiguration.FullName);
 
                         // The "Build.0" entry tells us whether to build the project configuration in the given solution configuration.
@@ -1207,7 +1207,7 @@ internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurati
                         // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used). 
                         // The configuration name is not used, and the whole entry means "build the project configuration" 
                         // if it's present in the solution file, and "don't build" if it's not.
-                        string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0", 
+                        string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0",
                             project.ProjectGuid, solutionConfiguration.FullName);
 
                         if (rawProjectConfigurationsEntries.ContainsKey(entryNameActiveConfig))
@@ -1311,7 +1311,7 @@ internal string GetDefaultPlatformName()
         /// <owner>RGoel</owner>
         internal string GetProjectUniqueNameByGuid(string projectGuid)
         {
-            ProjectInSolution proj = (ProjectInSolution) projects[projectGuid];
+            ProjectInSolution proj = (ProjectInSolution)projects[projectGuid];
             return proj?.GetUniqueProjectName();
         }
 
@@ -1324,7 +1324,7 @@ internal string GetProjectUniqueNameByGuid(string projectGuid)
         /// <owner>RGoel</owner>
         internal string GetProjectRelativePathByGuid(string projectGuid)
         {
-            ProjectInSolution proj = (ProjectInSolution) projects[projectGuid];
+            ProjectInSolution proj = (ProjectInSolution)projects[projectGuid];
             return proj?.RelativePath;
         }
 
diff --git a/src/Deprecated/Engine/Shared/XMakeAttributes.cs b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
index 33bef0d06d8..a81b43fe819 100644
--- a/src/Deprecated/Engine/Shared/XMakeAttributes.cs
+++ b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
@@ -11,50 +11,50 @@ namespace Microsoft.Build.BuildEngine.Shared
     /// <owner>RGoel</owner>
     internal static class XMakeAttributes
     {
-        internal const string condition                 = "Condition";
-        internal const string executeTargets            = "ExecuteTargets";
-        internal const string name                      = "Name";
-        internal const string msbuildVersion            = "MSBuildVersion";
-        internal const string xmlns                     = "xmlns";
-        internal const string defaultTargets            = "DefaultTargets";
-        internal const string initialTargets            = "InitialTargets";
-        internal const string dependsOnTargets          = "DependsOnTargets";
-        internal const string beforeTargets             = "BeforeTargets";
-        internal const string afterTargets              = "AfterTargets";
-        internal const string include                   = "Include";
-        internal const string exclude                   = "Exclude";
-        internal const string remove                    = "Remove";
-        internal const string keepMetadata              = "KeepMetadata";
-        internal const string removeMetadata            = "RemoveMetadata";
-        internal const string keepDuplicates            = "KeepDuplicates";
-        internal const string inputs                    = "Inputs";
-        internal const string outputs                   = "Outputs";
-        internal const string keepDuplicateOutputs      = "KeepDuplicateOutputs";
-        internal const string assemblyName              = "AssemblyName";
-        internal const string assemblyFile              = "AssemblyFile";
-        internal const string taskName                  = "TaskName";
-        internal const string continueOnError           = "ContinueOnError";
-        internal const string project                   = "Project";
-        internal const string taskParameter             = "TaskParameter";
-        internal const string itemName                  = "ItemName";
-        internal const string propertyName              = "PropertyName";
-        internal const string toolsVersion              = "ToolsVersion";
-        internal const string requiredRuntime           = "RequiredRuntime";
-        internal const string requiredPlatform          = "RequiredPlatform";
-        internal const string runtime                   = "Runtime";
-        internal const string msbuildRuntime            = "MSBuildRuntime";
-        internal const string architecture              = "Architecture";
-        internal const string msbuildArchitecture       = "MSBuildArchitecture";
-        internal const string taskFactory               = "TaskFactory";
-        internal const string parameterType             = "ParameterType";
-        internal const string required                  = "Required";
-        internal const string output                    = "Output";
-        internal const string defaultValue              = "DefaultValue";
-        internal const string evaluate                  = "Evaluate";
-        internal const string label                     = "Label";
-        internal const string returns                   = "Returns";
+        internal const string condition = "Condition";
+        internal const string executeTargets = "ExecuteTargets";
+        internal const string name = "Name";
+        internal const string msbuildVersion = "MSBuildVersion";
+        internal const string xmlns = "xmlns";
+        internal const string defaultTargets = "DefaultTargets";
+        internal const string initialTargets = "InitialTargets";
+        internal const string dependsOnTargets = "DependsOnTargets";
+        internal const string beforeTargets = "BeforeTargets";
+        internal const string afterTargets = "AfterTargets";
+        internal const string include = "Include";
+        internal const string exclude = "Exclude";
+        internal const string remove = "Remove";
+        internal const string keepMetadata = "KeepMetadata";
+        internal const string removeMetadata = "RemoveMetadata";
+        internal const string keepDuplicates = "KeepDuplicates";
+        internal const string inputs = "Inputs";
+        internal const string outputs = "Outputs";
+        internal const string keepDuplicateOutputs = "KeepDuplicateOutputs";
+        internal const string assemblyName = "AssemblyName";
+        internal const string assemblyFile = "AssemblyFile";
+        internal const string taskName = "TaskName";
+        internal const string continueOnError = "ContinueOnError";
+        internal const string project = "Project";
+        internal const string taskParameter = "TaskParameter";
+        internal const string itemName = "ItemName";
+        internal const string propertyName = "PropertyName";
+        internal const string toolsVersion = "ToolsVersion";
+        internal const string requiredRuntime = "RequiredRuntime";
+        internal const string requiredPlatform = "RequiredPlatform";
+        internal const string runtime = "Runtime";
+        internal const string msbuildRuntime = "MSBuildRuntime";
+        internal const string architecture = "Architecture";
+        internal const string msbuildArchitecture = "MSBuildArchitecture";
+        internal const string taskFactory = "TaskFactory";
+        internal const string parameterType = "ParameterType";
+        internal const string required = "Required";
+        internal const string output = "Output";
+        internal const string defaultValue = "DefaultValue";
+        internal const string evaluate = "Evaluate";
+        internal const string label = "Label";
+        internal const string returns = "Returns";
 
-        internal const string defaultXmlNamespace       = "http://schemas.microsoft.com/developer/msbuild/2003";
+        internal const string defaultXmlNamespace = "http://schemas.microsoft.com/developer/msbuild/2003";
 
         /// <summary>
         /// Returns true if and only if the specified attribute is one of the attributes that the engine specifically recognizes
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index 3fcaa66ee3a..64073646f89 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -43,11 +43,11 @@ internal static XmlElement RenameXmlElement(XmlElement oldElement, string newEle
                 newElement.AppendChild(newChildNode);
             }
 
-               
-            
-                // Add the new element in the same place the old element was.
-                oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
-            
+
+
+            // Add the new element in the same place the old element was.
+            oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
+
 
             return newElement;
         }
@@ -231,7 +231,7 @@ string attributeName
                     }
                 }
             }
-            catch(XmlException)
+            catch (XmlException)
             {
                 // Ignore any XML exceptions as it will be caught later on
             }
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index e35df91df0e..38db7a1f864 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -184,7 +184,7 @@ private static bool IsSolutionCacheEnabled()
         /// Given a cache loaded into a project, determines whether it is up to date with respect to the projects and the solution file listed
         /// with it, and was created with the same configuration/platform and tools version values as the ones currently in use.
         /// </summary>
-        private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile,  string solutionFileDirectory, Project msbuildProject, BuildEventContext projectBuildEventContext, string fullSolutionConfigurationName, string wrapperProjectToolsVersion)
+        private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile, string solutionFileDirectory, Project msbuildProject, BuildEventContext projectBuildEventContext, string fullSolutionConfigurationName, string wrapperProjectToolsVersion)
         {
             // Check the full solution configuration matches, eg "Debug|AnyCPU"
             string cacheSolutionConfigurationName = msbuildProject.GetEvaluatedProperty(cacheSolutionConfigurationPropertyName);
@@ -209,8 +209,8 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile,  s
                 return false;
             }
 
-	    // We also store the version of MSBuild that wrote the file and verify it's the same as ours: that ensures that we 
-	    // don't read possibly incompatible caches.
+            // We also store the version of MSBuild that wrote the file and verify it's the same as ours: that ensures that we 
+            // don't read possibly incompatible caches.
             string thisVersion = Constants.AssemblyVersion;
             if (!String.Equals(cacheVersion, thisVersion, StringComparison.OrdinalIgnoreCase))
             {
@@ -1985,7 +1985,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
 
             if (configurationProperty != null)
             {
-                activeSolutionConfiguration= configurationProperty.FinalValue;
+                activeSolutionConfiguration = configurationProperty.FinalValue;
             }
             else
             {
@@ -1994,7 +1994,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
 
             if (platformProperty != null)
             {
-                activeSolutionPlatform  = platformProperty.FinalValue;
+                activeSolutionPlatform = platformProperty.FinalValue;
             }
             else
             {
@@ -2239,7 +2239,7 @@ private static void AssignDependencyLevel(ProjectInSolution project, SolutionPar
                 // First, go through dependencies and ensure they have their dependency level set correctly.
                 foreach (string dependencyGuid in project.Dependencies)
                 {
-                    ProjectInSolution referencedProject = (ProjectInSolution) solution.ProjectsByGuid[dependencyGuid];
+                    ProjectInSolution referencedProject = (ProjectInSolution)solution.ProjectsByGuid[dependencyGuid];
 
                     AssignDependencyLevel(referencedProject, solution, projectsByDependencyLevel);
 
diff --git a/src/Deprecated/Engine/Solution/VCProjectParser.cs b/src/Deprecated/Engine/Solution/VCProjectParser.cs
index 9c1d7f4ecd9..f50a4380ba1 100644
--- a/src/Deprecated/Engine/Solution/VCProjectParser.cs
+++ b/src/Deprecated/Engine/Solution/VCProjectParser.cs
@@ -7,8 +7,8 @@
 
 namespace Microsoft.Build.BuildEngine
 {
-	internal static class VCProjectParser
-	{
+    internal static class VCProjectParser
+    {
         /// <summary>
         /// For a given VC project, retrieves the projects it references 
         /// </summary>
diff --git a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
index c895729c97a..a7a302725c1 100644
--- a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
+++ b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
@@ -29,7 +29,7 @@ internal IntrinsicTask(XmlElement taskNodeXmlElement, EngineLoggingServices logg
             this.buildEventContext = eventContext;
             this.executionDirectory = executionDirectory;
             this.itemDefinitionLibrary = itemDefinitionLibrary;
-            
+
             ErrorUtilities.VerifyThrow(IsIntrinsicTaskName(taskNodeXmlElement.Name), "Only PropertyGroup and ItemGroup are known intrinsic tasks");
 
             switch (taskNodeXmlElement.Name)
@@ -70,7 +70,7 @@ internal void ExecuteTask(Lookup lookup)
         {
             ErrorUtilities.VerifyThrow(lookup != null, "Need to specify lookup.");
 
-            if ((conditionAttribute != null) 
+            if ((conditionAttribute != null)
                 && !Utilities.EvaluateCondition(conditionAttribute.Value, conditionAttribute, new Expander(lookup.ReadOnlyLookup), null, ParserOptions.AllowPropertiesAndItemLists, loggingServices, buildEventContext))
             {
                 return;
@@ -93,7 +93,7 @@ internal void ExecuteTask(Lookup lookup)
         /// Execute a PropertyGroup element, including each child property
         /// </summary>
         private void ExecutePropertyGroup(Lookup lookup)
-        {          
+        {
             foreach (BuildProperty property in backingPropertyGroup)
             {
                 ArrayList buckets = null;
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
index deb2b0749b8..1ece648583f 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
@@ -45,7 +45,7 @@ internal BuildItemGroupChildXml(XmlElement element, ChildType childTypeExpected)
             ProjectXmlUtilities.VerifyThrowProjectValidNameAndNamespace(element);
 
             this.element = element;
-    
+
             // Loop through each of the attributes on the item element.
             foreach (XmlAttribute attribute in element.Attributes)
             {
@@ -55,7 +55,7 @@ internal BuildItemGroupChildXml(XmlElement element, ChildType childTypeExpected)
                         this.includeAttribute = attribute;
                         break;
 
-                    case XMakeAttributes.exclude:  
+                    case XMakeAttributes.exclude:
                         this.excludeAttribute = attribute;
                         break;
 
@@ -159,7 +159,7 @@ internal BuildItemGroupChildXml(XmlElement element, ChildType childTypeExpected)
         internal string Name
         {
             get
-            { 
+            {
                 return element.Name;
             }
 
@@ -252,7 +252,7 @@ internal ChildType ChildType
         {
             get { return childType; }
         }
-        
+
         #endregion
 
         #region Methods
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
index 2dacb63d74e..24fb56d796d 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
@@ -19,9 +19,9 @@ internal class BuildItemGroupXml
         private XmlElement element;
         // The Condition attribute on it, if any, to save lookup
         private XmlAttribute conditionAttribute;
-        
+
         #endregion
-        
+
         #region Constructors
 
         /// <summary>
@@ -46,7 +46,7 @@ internal BuildItemGroupXml(XmlDocument owner)
         }
 
         #endregion
-        
+
         #region Properties
 
         internal string Condition
diff --git a/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs b/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
index 50cb627cc52..96c15c80d1c 100644
--- a/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
+++ b/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
@@ -65,7 +65,7 @@ internal static void VerifyThrowProjectNoChildElements(XmlElement element)
             if (childElements.Count > 0)
             {
                 ThrowProjectInvalidChildElement(element.FirstChild);
-            }            
+            }
         }
 
         /// <summary>
@@ -110,7 +110,7 @@ internal static void VerifyThrowProjectValidNamespace(XmlElement element)
         /// </summary>
         internal static void VerifyThrowProjectNoAttributes(XmlElement element)
         {
-            foreach(XmlAttribute attribute in element.Attributes)
+            foreach (XmlAttribute attribute in element.Attributes)
             {
                 ThrowProjectInvalidAttribute(attribute);
             }
diff --git a/src/Framework.UnitTests/FileClassifier_Tests.cs b/src/Framework.UnitTests/FileClassifier_Tests.cs
index de8585434e0..d53bd616907 100644
--- a/src/Framework.UnitTests/FileClassifier_Tests.cs
+++ b/src/Framework.UnitTests/FileClassifier_Tests.cs
@@ -24,7 +24,7 @@ public void IsNonModifiable_EvaluatesModifiability()
             FileClassifier classifier = new();
 
             var volume = NativeMethodsShared.IsWindows ? @"X:\" : "/home/usr";
-            classifier.RegisterImmutableDirectory($"{Path.Combine(volume,"Test1")}");
+            classifier.RegisterImmutableDirectory($"{Path.Combine(volume, "Test1")}");
             classifier.RegisterImmutableDirectory($"{Path.Combine(volume, "Test2")}");
 
             classifier.IsNonModifiable(Path.Combine(volume, "Test1", "File.ext")).ShouldBeTrue();
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index d3d5bd886bd..ef594592a74 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -75,7 +75,7 @@ public static Type GetTypeInfo(this Type t)
         public static AssemblyName CloneIfPossible(this AssemblyName assemblyNameToClone)
         {
 #if CLR2COMPATIBILITY
-            return (AssemblyName) assemblyNameToClone.Clone();
+            return (AssemblyName)assemblyNameToClone.Clone();
 #else
 
             // NOTE: In large projects, this is called a lot. Avoid calling AssemblyName.Clone
@@ -167,7 +167,7 @@ private static CultureInfo[] GetValidCultures()
 
             var allCulturesEnumValue = Enum.Parse(cultureTypesType, "AllCultures", true);
 
-            var cultures = s_cultureInfoGetCultureMethod.Invoke(null, new[] {allCulturesEnumValue}) as CultureInfo[];
+            var cultures = s_cultureInfoGetCultureMethod.Invoke(null, new[] { allCulturesEnumValue }) as CultureInfo[];
 
             FrameworkErrorUtilities.VerifyThrowInternalNull(cultures, "CultureInfo.GetCultures should work if all reflection checks pass");
 
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index df29067bea9..93ed2f228ee 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -175,7 +175,7 @@ public BuildEventContext? BuildEventContext
             set => buildEventContext = value;
         }
 
-#region CustomSerializationToStream
+        #region CustomSerializationToStream
         /// <summary>
         /// Serializes to a stream through a binary writer
         /// </summary>
@@ -249,9 +249,9 @@ internal virtual void CreateFromStream(BinaryReader reader, int version)
                 }
             }
         }
-#endregion
+        #endregion
 
-#region SetSerializationDefaults
+        #region SetSerializationDefaults
         /// <summary>
         /// Run before the object has been deserialized
         /// UNDONE (Logging.)  Can this and the next function go away, and instead return a BuildEventContext.Invalid from
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 89b8370c392..c794ca4210e 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -646,7 +646,7 @@ public void LoadAssemblyAndFindTypeStop(string assemblyPath, int numberOfPublicT
         {
             WriteEvent(88, assemblyPath, numberOfPublicTypesSearched);
         }
-        
+
         [Event(89, Keywords = Keywords.All)]
         public void MSBuildServerBuildStart(string commandLine)
         {
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index b33ff8ca3e7..284204c2338 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Framework;
 
 internal static class NativeMethods
 {
-#region Constants
+    #region Constants
 
     internal const uint ERROR_INSUFFICIENT_BUFFER = 0x8007007A;
     internal const uint STARTUP_LOADER_SAFEMODE = 0x10;
@@ -72,9 +72,9 @@ internal static class NativeMethods
     internal const uint WAIT_OBJECT_0 = 0x00000000;
     internal const uint WAIT_TIMEOUT = 0x00000102;
 
-#endregion
+    #endregion
 
-#region Enums
+    #region Enums
 
     private enum PROCESSINFOCLASS : int
     {
@@ -573,9 +573,9 @@ private static unsafe int GetLogicalCoreCountOnWindows()
         return -1;
     }
 
-#endregion
+    #endregion
 
-#region Member data
+    #region Member data
 
     internal static bool HasMaxPath => MaxPath == MAX_PATH;
 
@@ -658,7 +658,7 @@ internal static bool IsUnixLike
     internal static bool IsLinux
     {
 #if CLR2COMPATIBILITY
-            get { return false; }
+        get { return false; }
 #else
         get { return RuntimeInformation.IsOSPlatform(OSPlatform.Linux); }
 #endif
@@ -670,7 +670,7 @@ internal static bool IsLinux
     internal static bool IsBSD
     {
 #if CLR2COMPATIBILITY
-            get { return false; }
+        get { return false; }
 #else
         get
         {
@@ -722,7 +722,7 @@ internal static bool IsMono
     internal static bool IsWindows
     {
 #if CLR2COMPATIBILITY
-            get { return true; }
+        get { return true; }
 #else
         get
         {
@@ -742,7 +742,7 @@ internal static bool IsWindows
     internal static bool IsOSX
     {
 #if CLR2COMPATIBILITY
-            get { return false; }
+        get { return false; }
 #else
         get
         {
@@ -885,9 +885,9 @@ private static SystemInformationData SystemInformation
     /// </summary>
     internal static ProcessorArchitectures ProcessorArchitectureNative => SystemInformation.ProcessorArchitectureTypeNative;
 
-#endregion
+    #endregion
 
-#region Wrapper methods
+    #region Wrapper methods
 
 
     [DllImport("kernel32.dll", SetLastError = true)]
@@ -1563,7 +1563,7 @@ internal static void VerifyThrowWin32Result(int result)
     [DllImport("kernel32.dll")]
     [SupportedOSPlatform("windows")]
     internal static extern uint GetFileType(IntPtr hFile);
-    
+
     [DllImport("kernel32.dll")]
     internal static extern bool GetConsoleMode(IntPtr hConsoleHandle, out uint lpMode);
 
@@ -1734,6 +1734,6 @@ internal static bool FileOrDirectoryExistsWindows(string path)
         return GetFileAttributesEx(path, 0, ref data);
     }
 
-#endregion
+    #endregion
 
 }
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index f37093e78a0..3e1464b9b68 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -143,7 +143,7 @@ public EvaluationLocation(long id, long? parentId, EvaluationPass evaluationPass
             int? line, string elementName, string elementDescription, EvaluationLocationKind kind)
         {
             Id = id;
-            ParentId = parentId == EmptyLocation.Id? null : parentId; // The empty location doesn't count as a parent id, since it's just a dummy starting point
+            ParentId = parentId == EmptyLocation.Id ? null : parentId; // The empty location doesn't count as a parent id, since it's just a dummy starting point
             EvaluationPass = evaluationPass;
             EvaluationPassDescription = evaluationPassDescription;
             File = file;
@@ -181,7 +181,7 @@ public EvaluationLocation(EvaluationPass evaluationPass, string evaluationPassDe
         /// An empty location, used as the starting instance.
         /// </summary>
         public static EvaluationLocation EmptyLocation { get; } = CreateEmptyLocation();
-        
+
         /// <nodoc/>
         public EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
         {
@@ -240,7 +240,7 @@ public override bool Equals(object obj)
                     Line == other.Line &&
                     ElementName == other.ElementName &&
                     ElementDescription == other.ElementDescription &&
-					Kind == other.Kind;
+                    Kind == other.Kind;
             }
             return false;
         }
diff --git a/src/Framework/Sdk/SdkReference.cs b/src/Framework/Sdk/SdkReference.cs
index 3ea93024a6a..8f7e05dd7c4 100644
--- a/src/Framework/Sdk/SdkReference.cs
+++ b/src/Framework/Sdk/SdkReference.cs
@@ -125,7 +125,7 @@ public override bool Equals(object obj)
                 return true;
             }
 
-            return obj is SdkReference && Equals((SdkReference) obj);
+            return obj is SdkReference && Equals((SdkReference)obj);
         }
 
         /// <inheritdoc />
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
index 7feba81b7e6..1f51efe1033 100644
--- a/src/Framework/Sdk/SdkResultItem.cs
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -8,8 +8,8 @@
 namespace Microsoft.Build.Framework
 {
 
-    #nullable enable
-    
+#nullable enable
+
     /// <summary>
     /// The value of an item and any associated metadata to be added by an SDK resolver.  See <see cref="SdkResult.ItemsToAdd"/>
     /// </summary>
diff --git a/src/Framework/StringBuilderCache.cs b/src/Framework/StringBuilderCache.cs
index 5b21061d9ae..fe5c5e4d2ee 100644
--- a/src/Framework/StringBuilderCache.cs
+++ b/src/Framework/StringBuilderCache.cs
@@ -93,7 +93,7 @@ public static void Release(StringBuilder sb)
                 StringBuilderCache.t_cachedInstance = sb;
             }
 #if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-            MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: sb.GetHashCode(), returningCapacity: sb.Capacity, returningLength: sb.Length, type: sb.Capacity <= MAX_BUILDER_SIZE ? "sbc-return" :  "sbc-discard");
+            MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: sb.GetHashCode(), returningCapacity: sb.Capacity, returningLength: sb.Length, type: sb.Capacity <= MAX_BUILDER_SIZE ? "sbc-return" : "sbc-discard");
 #endif
         }
 
diff --git a/src/Framework/TargetStartedEventArgs.cs b/src/Framework/TargetStartedEventArgs.cs
index 2a51fddd380..6b636072926 100644
--- a/src/Framework/TargetStartedEventArgs.cs
+++ b/src/Framework/TargetStartedEventArgs.cs
@@ -148,7 +148,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             if (version > 20)
             {
                 parentTarget = reader.ReadByte() == 0 ? null : reader.ReadString();
-                buildReason = (TargetBuiltReason) reader.ReadInt32();
+                buildReason = (TargetBuiltReason)reader.ReadInt32();
             }
         }
         #endregion
diff --git a/src/Framework/VisualStudioLocationHelper.cs b/src/Framework/VisualStudioLocationHelper.cs
index 75427007b78..cdead3b9247 100644
--- a/src/Framework/VisualStudioLocationHelper.cs
+++ b/src/Framework/VisualStudioLocationHelper.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Shared
     internal class VisualStudioLocationHelper
     {
 #if FEATURE_VISUALSTUDIOSETUP
-        private const int REGDB_E_CLASSNOTREG = unchecked((int) 0x80040154);
+        private const int REGDB_E_CLASSNOTREG = unchecked((int)0x80040154);
 #endif // FEATURE_VISUALSTUDIOSETUP
 
         /// <summary>
@@ -33,7 +33,7 @@ internal static IList<VisualStudioInstance> GetInstances()
             try
             {
                 // This code is not obvious. See the sample (link above) for reference.
-                var query = (ISetupConfiguration2) GetQuery();
+                var query = (ISetupConfiguration2)GetQuery();
                 var e = query.EnumAllInstances();
 
                 int fetched;
@@ -48,7 +48,7 @@ internal static IList<VisualStudioInstance> GetInstances()
                     }
 
                     var instance = instances[0];
-                    var state = ((ISetupInstance2) instance).GetState();
+                    var state = ((ISetupInstance2)instance).GetState();
                     Version version;
 
                     try
@@ -73,7 +73,7 @@ internal static IList<VisualStudioInstance> GetInstances()
             catch (COMException)
             { }
             catch (DllNotFoundException)
-            { 
+            {
                 // This is OK, VS "15" or greater likely not installed.
             }
 #endif
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index a3240afba8f..36db0c9ee96 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -564,9 +564,9 @@ public void GraphBuildSwitchCanHaveParameters()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new List<string> { "/graph", "/graph:true;  NoBuild  ;;  ;", "/graph:foo"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string> { "/graph", "/graph:true;  NoBuild  ;;  ;", "/graph:foo" }, switches);
 
-            switches[CommandLineSwitches.ParameterizedSwitch.GraphBuild].ShouldBe(new[] {"true", "  NoBuild  ", "  ", "foo"});
+            switches[CommandLineSwitches.ParameterizedSwitch.GraphBuild].ShouldBe(new[] { "true", "  NoBuild  ", "  ", "foo" });
 
             switches.HaveErrors().ShouldBeFalse();
         }
@@ -588,9 +588,9 @@ public void InputResultsCachesSupportsMultipleOccurrence()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/irc", "/irc:a;b", "/irc:c;d"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>() { "/irc", "/irc:a;b", "/irc:c;d" }, switches);
 
-            switches[CommandLineSwitches.ParameterizedSwitch.InputResultsCaches].ShouldBe(new []{null, "a", "b", "c", "d"});
+            switches[CommandLineSwitches.ParameterizedSwitch.InputResultsCaches].ShouldBe(new[] { null, "a", "b", "c", "d" });
 
             switches.HaveErrors().ShouldBeFalse();
         }
@@ -600,9 +600,9 @@ public void OutputResultsCache()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/orc:a"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>() { "/orc:a" }, switches);
 
-            switches[CommandLineSwitches.ParameterizedSwitch.OutputResultsCache].ShouldBe(new []{"a"});
+            switches[CommandLineSwitches.ParameterizedSwitch.OutputResultsCache].ShouldBe(new[] { "a" });
 
             switches.HaveErrors().ShouldBeFalse();
         }
@@ -612,7 +612,7 @@ public void OutputResultsCachesDoesNotSupportMultipleOccurrences()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/orc:a", "/orc:b"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>() { "/orc:a", "/orc:b" }, switches);
 
             switches.HaveErrors().ShouldBeTrue();
         }
@@ -1182,7 +1182,7 @@ public void ProcessWarnAsErrorSwitchEmpty()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new List<string>(new [] { "/warnaserror" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[] { "/warnaserror" }), commandLineSwitches);
 
             ISet<string> actualWarningsAsErrors = MSBuildApp.ProcessWarnAsErrorSwitch(commandLineSwitches);
 
@@ -1275,7 +1275,7 @@ public void ProcessBooleanSwitchTest()
 
             MSBuildApp.ProcessBooleanSwitch(Array.Empty<string>(), defaultValue: false, resourceName: null).ShouldBeFalse();
 
-            MSBuildApp.ProcessBooleanSwitch(new [] { "true" }, defaultValue: false, resourceName: null).ShouldBeTrue();
+            MSBuildApp.ProcessBooleanSwitch(new[] { "true" }, defaultValue: false, resourceName: null).ShouldBeTrue();
 
             MSBuildApp.ProcessBooleanSwitch(new[] { "false" }, defaultValue: true, resourceName: null).ShouldBeFalse();
 
@@ -1285,29 +1285,29 @@ public void ProcessBooleanSwitchTest()
         public static IEnumerable<object[]> ProcessGraphBuildSwitchData()
         {
             var emptyOptions = new GraphBuildOptions();
-            var noBuildOptions = new GraphBuildOptions {Build = false};
+            var noBuildOptions = new GraphBuildOptions { Build = false };
 
-            yield return new object[] {Array.Empty<string>(), emptyOptions, null};
+            yield return new object[] { Array.Empty<string>(), emptyOptions, null };
 
-            yield return new object[] {new[] {"true"}, emptyOptions, null};
+            yield return new object[] { new[] { "true" }, emptyOptions, null };
 
-            yield return new object[] {new[] {"false"}, null, null};
+            yield return new object[] { new[] { "false" }, null, null };
 
-            yield return new object[] {new[] {"  ", "  "}, emptyOptions, null};
+            yield return new object[] { new[] { "  ", "  " }, emptyOptions, null };
 
-            yield return new object[] {new[] {"NoBuild"}, noBuildOptions, null};
+            yield return new object[] { new[] { "NoBuild" }, noBuildOptions, null };
 
-            yield return new object[] {new[] {"noBUILD"}, noBuildOptions, null};
+            yield return new object[] { new[] { "noBUILD" }, noBuildOptions, null };
 
-            yield return new object[] {new[] {"noBUILD     "}, noBuildOptions, null};
+            yield return new object[] { new[] { "noBUILD     " }, noBuildOptions, null };
 
-            yield return new object[] {new[] {"false", "true"}, null, new[] {"false"}};
+            yield return new object[] { new[] { "false", "true" }, null, new[] { "false" } };
 
-            yield return new object[] {new[] {"nobuild", "true"}, noBuildOptions, new[] {"true"}};
+            yield return new object[] { new[] { "nobuild", "true" }, noBuildOptions, new[] { "true" } };
 
-            yield return new object[] {new[] { "false", "nobuild" }, null, new[] {"false"}};
+            yield return new object[] { new[] { "false", "nobuild" }, null, new[] { "false" } };
 
-            yield return new object[] {new[] {"nobuild", "invalid"}, null, new[] {"invalid"}};
+            yield return new object[] { new[] { "nobuild", "invalid" }, null, new[] { "invalid" } };
         }
 
         [Theory]
@@ -1353,7 +1353,7 @@ public void ProcessProfileEvaluationInvalidFilename(string filename)
         {
             bool enableProfiler = false;
             Should.Throw(
-                () => MSBuildApp.ProcessProfileEvaluationSwitch(new[] {filename}, new List<ILogger>(), out enableProfiler),
+                () => MSBuildApp.ProcessProfileEvaluationSwitch(new[] { filename }, new List<ILogger>(), out enableProfiler),
                 typeof(CommandLineSwitchException));
         }
 
diff --git a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
index 0c40f0afcbc..183bfc5d902 100644
--- a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
+++ b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
@@ -275,6 +275,7 @@ public void VerifyInvalidImportNotCaughtBySchema()
             }
         }
 
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Helper Functions
 
         /// <summary>
@@ -393,6 +394,7 @@ private static string CleanupFileContents(string projectFileContents)
         private const string msbuildDefaultToolsVersion = "4.0";
 
         #endregion // Helper Functions
+#pragma warning restore format
     }
 }
 #endif
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 5849fb8f3c8..0bf46163421 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -518,7 +518,7 @@ public void Help(string indicator)
 #if FEATURE_GET_COMMANDLINE
                 @$"c:\bin\msbuild.exe {indicator} "
 #else
-                new [] {@"c:\bin\msbuild.exe", indicator}
+                new[] { @"c:\bin\msbuild.exe", indicator }
 #endif
             ).ShouldBe(MSBuildApp.ExitType.Success);
         }
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 4ec352da9a3..4e521f9d703 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -487,7 +487,7 @@ bool emptyParametersAllowed
                 if (String.Empty.Equals(switchParameters) && emptyParametersAllowed)
                 {
                     // Store a null parameter if its allowed
-                    _parameterizedSwitches[(int) parameterizedSwitch].parameters.Add(null);
+                    _parameterizedSwitches[(int)parameterizedSwitch].parameters.Add(null);
                     parametersStored = true;
                 }
                 else
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index 0fd4ea40181..e3491e54f54 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -71,7 +71,7 @@ public static MSBuildApp.ExitType Execute(
             string msbuildLocation,
             CancellationToken cancellationToken)
         {
-            MSBuildClient msbuildClient = new MSBuildClient(commandLine, msbuildLocation); 
+            MSBuildClient msbuildClient = new MSBuildClient(commandLine, msbuildLocation);
             MSBuildClientExitResult exitResult = msbuildClient.Execute(cancellationToken);
 
             if (exitResult.MSBuildClientExitType == MSBuildClientExitType.ServerBusy ||
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 10655f84b09..04e2877608c 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -238,7 +238,7 @@ IDictionary<string, TaskParameter> taskParams
                         taskRunnerFinished.Set();
                     }
                 };
-                
+
                 Thread staThread = new Thread(taskRunnerDelegate);
                 staThread.SetApartmentState(ApartmentState.STA);
                 staThread.Name = "MSBuild STA task runner thread";
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index 3f6b1cce5f7..3e61f1239e7 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -21,7 +21,7 @@ internal sealed class ProjectSchemaValidationHandler
     {
         // Set to true if there was a syntax error in the project file.
         private bool _syntaxError;
-
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Methods
 
         /// <summary>
@@ -303,6 +303,7 @@ private void OnSchemaValidationError(object sender, ValidationEventArgs args)
         }
 
         #endregion // Event Handlers
+#pragma warning restore format
     }
 }
 #endif
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index d1934341472..bcd34a2a05a 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -128,7 +128,7 @@ public enum ExitType
         private static readonly CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
 
         private static readonly char[] s_commaSemicolon = { ',', ';' };
- 
+
         /// <summary>
         /// Static constructor
         /// </summary>
@@ -246,7 +246,7 @@ string[] args
             {
                 Console.CancelKeyPress += Console_CancelKeyPress;
 
-                
+
                 // Use the client app to execute build in msbuild server. Opt-in feature.
                 exitCode = ((s_initialized && MSBuildClientApp.Execute(
 #if FEATURE_GET_COMMANDLINE
@@ -656,7 +656,8 @@ string[] commandLine
 #if FEATURE_GET_COMMANDLINE
                 MSBuildEventSource.Log.MSBuildExeStart(commandLine);
 #else
-                if (MSBuildEventSource.Log.IsEnabled()) {
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
                     MSBuildEventSource.Log.MSBuildExeStart(string.Join(" ", commandLine));
                 }
 #endif
@@ -813,9 +814,9 @@ string[] commandLine
                                     inputResultsCaches,
                                     outputResultsCache,
                                     commandLine))
-                            {
-                                exitType = ExitType.BuildError;
-                            }
+                        {
+                            exitType = ExitType.BuildError;
+                        }
                     } // end of build
 
                     DateTime t2 = DateTime.Now;
@@ -966,7 +967,8 @@ string[] commandLine
 #if FEATURE_GET_COMMANDLINE
                 MSBuildEventSource.Log.MSBuildExeStop(commandLine);
 #else
-                if (MSBuildEventSource.Log.IsEnabled()) {
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
                     MSBuildEventSource.Log.MSBuildExeStop(string.Join(" ", commandLine));
                 }
 #endif
@@ -1009,7 +1011,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
             // We're already on a threadpool thread anyway.
             WaitCallback callback = delegate
             {
-                try 
+                try
                 {
                     s_cancelComplete.Reset();
 
@@ -1375,7 +1377,7 @@ string[] commandLine
                             {
                                 if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new[]{ new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, BuildRequestDataFlags.None, graphBuildOptions);
+                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, BuildRequestDataFlags.None, graphBuildOptions);
                                 }
                                 else
                                 {
@@ -2424,7 +2426,7 @@ string commandLine
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
-                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.FancyLogger], 
+                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.FancyLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -2565,7 +2567,7 @@ internal static GraphBuildOptions ProcessGraphBuildSwitch(string[] parameters)
 
                 if (parameter.Trim().Equals("NoBuild", StringComparison.OrdinalIgnoreCase))
                 {
-                    options = options with {Build = false};
+                    options = options with { Build = false };
                 }
                 else
                 {
@@ -3052,7 +3054,7 @@ DirectoryGetFiles getFiles
                 }
                 // if there are no project, solution filter, or solution files in the directory, we can't build
                 else if (actualProjectFiles.Count == 0 &&
-                         actualSolutionFiles.Count== 0 &&
+                         actualSolutionFiles.Count == 0 &&
                          solutionFilterFiles.Count == 0)
                 {
                     InitializationException.Throw("MissingProjectError", null, null, false);
@@ -3209,7 +3211,7 @@ private static ILogger[] ProcessLoggingSwitches
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
-            bool fancyLoggerCommandLineOptIn, 
+            bool fancyLoggerCommandLineOptIn,
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3360,7 +3362,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<IL
 
             string arguments = binaryLoggerParameters[binaryLoggerParameters.Length - 1];
 
-            BinaryLogger logger = new BinaryLogger {Parameters = arguments};
+            BinaryLogger logger = new BinaryLogger { Parameters = arguments };
 
             // If we have a binary logger, force verbosity to diagnostic.
             // The only place where verbosity is used downstream is to determine whether to log task inputs.
diff --git a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
index 78492147adf..9ed203b87e1 100644
--- a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
+++ b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
@@ -10,7 +10,7 @@ namespace System.Collections.Immutable
 {
     internal static class ImmutableExtensions
     {
-        public static ImmutableDictionary<K,V> ToImmutableDictionary<K,V>(this IDictionary<K,V> dictionary)
+        public static ImmutableDictionary<K, V> ToImmutableDictionary<K, V>(this IDictionary<K, V> dictionary)
         {
             return new ImmutableDictionary<K, V>(dictionary);
         }
diff --git a/src/Samples/XmlFileLogger/ObjectModel/Project.cs b/src/Samples/XmlFileLogger/ObjectModel/Project.cs
index 1ce36edaf9a..853cb4ed678 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/Project.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/Project.cs
@@ -153,7 +153,7 @@ public override string ToString()
         /// <returns>Target node</returns>
         private Target GetOrAddTargetByName(string targetName, TargetStartedEventArgs e = null)
         {
-            Target result = _targetNameToTargetMap.GetOrAdd(targetName, key=> new Target(key, e));
+            Target result = _targetNameToTargetMap.GetOrAdd(targetName, key => new Target(key, e));
 
             if (e != null)
             {
diff --git a/src/Samples/XmlFileLogger/XmlFileLogger.cs b/src/Samples/XmlFileLogger/XmlFileLogger.cs
index e5ab9109723..df5634ab31d 100644
--- a/src/Samples/XmlFileLogger/XmlFileLogger.cs
+++ b/src/Samples/XmlFileLogger/XmlFileLogger.cs
@@ -42,16 +42,16 @@ public class XmlFileLogger : Logger
         public override void Initialize(IEventSource eventSource)
         {
             ProcessParameters();
-            
-            eventSource.BuildStarted    += (s, args) => _build = new Build(args);
-            eventSource.BuildFinished   += (o, args) => _build.CompleteBuild(args, _logFile, _errors, _warings);
 
-            eventSource.ProjectStarted  += (o, args) => TryProcessEvent(() => _build.AddProject(args));
+            eventSource.BuildStarted += (s, args) => _build = new Build(args);
+            eventSource.BuildFinished += (o, args) => _build.CompleteBuild(args, _logFile, _errors, _warings);
+
+            eventSource.ProjectStarted += (o, args) => TryProcessEvent(() => _build.AddProject(args));
             eventSource.ProjectFinished += (o, args) => TryProcessEvent(() => _build.CompleteProject(args));
-            eventSource.TargetStarted   += (o, args) => TryProcessEvent(() => _build.AddTarget(args));
-            eventSource.TargetFinished  += (o, args) => TryProcessEvent(() => _build.CompleteTarget(args));
-            eventSource.TaskStarted     += (o, args) => TryProcessEvent(() => _build.AddTask(args));
-            eventSource.TaskFinished    += (o, args) => TryProcessEvent(() => _build.CompleteTask(args));
+            eventSource.TargetStarted += (o, args) => TryProcessEvent(() => _build.AddTarget(args));
+            eventSource.TargetFinished += (o, args) => TryProcessEvent(() => _build.CompleteTarget(args));
+            eventSource.TaskStarted += (o, args) => TryProcessEvent(() => _build.AddTask(args));
+            eventSource.TaskFinished += (o, args) => TryProcessEvent(() => _build.CompleteTask(args));
 
             eventSource.TaskFinished += (o, args) => TryProcessEvent(() => _build.CompleteTask(args));
 
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs b/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
index bb50bfa5800..9324c8611a3 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
@@ -31,7 +31,7 @@ internal AssemblyFoldersFromConfig(string configFile, string targetRuntimeVersio
         {
             ErrorUtilities.VerifyThrowArgumentNull(configFile, nameof(configFile));
             ErrorUtilities.VerifyThrowArgumentNull(targetRuntimeVersion, nameof(targetRuntimeVersion));
-            
+
             var collection = AssemblyFolderCollection.Load(configFile);
             var assemblyTargets = GatherVersionStrings(targetRuntimeVersion, collection);
 
@@ -76,12 +76,12 @@ private void FindDirectories(List<AssemblyFolderItem> assemblyTargets, Func<Asse
 
         private static List<AssemblyFolderItem> GatherVersionStrings(string targetRuntimeVersion, AssemblyFolderCollection collection)
         {
-            return 
+            return
                 (from folder in collection.AssemblyFolders
                  let targetVersion = VersionUtilities.ConvertToVersion(targetRuntimeVersion)
                  let replacementVersion = GetFrameworkVersion(folder.FrameworkVersion)
                  where targetVersion != null && targetVersion >= replacementVersion
-                 orderby folder.FrameworkVersion descending 
+                 orderby folder.FrameworkVersion descending
                  select folder).ToList();
         }
 
diff --git a/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs b/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
index 5151c1ff447..1b094edb04f 100644
--- a/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
+++ b/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
@@ -5,7 +5,7 @@
 
 namespace Microsoft.Build.Shared.AssemblyFoldersFromConfig
 {
-    [DataContract(Name="AssemblyFolder", Namespace = "")]
+    [DataContract(Name = "AssemblyFolder", Namespace = "")]
     [DebuggerDisplay("{Name}: FrameworkVersion = {FrameworkVersion}, Platform = {Platform}, Path= {Path}")]
     internal class AssemblyFolderItem
     {
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index a2a6120ec55..f0e535038b6 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -130,11 +130,11 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
             if (hasAssemblyName)
             {
                 var name = info.GetString("name");
-                var publicKey = (byte[]) info.GetValue("pk", typeof(byte[]));
-                var publicKeyToken = (byte[]) info.GetValue("pkt", typeof(byte[]));
+                var publicKey = (byte[])info.GetValue("pk", typeof(byte[]));
+                var publicKeyToken = (byte[])info.GetValue("pkt", typeof(byte[]));
                 var version = (Version)info.GetValue("ver", typeof(Version));
-                var flags = (AssemblyNameFlags) info.GetInt32("flags");
-                var processorArchitecture = (ProcessorArchitecture) info.GetInt32("cpuarch");
+                var flags = (AssemblyNameFlags)info.GetInt32("flags");
+                var processorArchitecture = (ProcessorArchitecture)info.GetInt32("cpuarch");
 
                 CultureInfo cultureInfo = null;
                 var hasCultureInfo = info.GetBoolean("hasCI");
@@ -143,8 +143,8 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
                     cultureInfo = new CultureInfo(info.GetInt32("ci"));
                 }
 
-                var hashAlgorithm = (System.Configuration.Assemblies.AssemblyHashAlgorithm) info.GetInt32("hashAlg");
-                var versionCompatibility = (AssemblyVersionCompatibility) info.GetInt32("verCompat");
+                var hashAlgorithm = (System.Configuration.Assemblies.AssemblyHashAlgorithm)info.GetInt32("hashAlg");
+                var versionCompatibility = (AssemblyVersionCompatibility)info.GetInt32("verCompat");
                 var codeBase = info.GetString("codebase");
 
                 asAssemblyName = new AssemblyName
@@ -167,7 +167,7 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
             isSimpleName = info.GetBoolean("isSName");
             hasProcessorArchitectureInFusionName = info.GetBoolean("hasCpuArch");
             immutable = info.GetBoolean("immutable");
-            remappedFrom = (HashSet<AssemblyNameExtension>) info.GetValue("remapped", typeof(HashSet<AssemblyNameExtension>));
+            remappedFrom = (HashSet<AssemblyNameExtension>)info.GetValue("remapped", typeof(HashSet<AssemblyNameExtension>));
         }
 
         /// <summary>
@@ -952,8 +952,8 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)
                 info.AddValue("pk", asAssemblyName.GetPublicKey());
                 info.AddValue("pkt", asAssemblyName.GetPublicKeyToken());
                 info.AddValue("ver", asAssemblyName.Version);
-                info.AddValue("flags", (int) asAssemblyName.Flags);
-                info.AddValue("cpuarch", (int) asAssemblyName.ProcessorArchitecture);
+                info.AddValue("flags", (int)asAssemblyName.Flags);
+                info.AddValue("cpuarch", (int)asAssemblyName.ProcessorArchitecture);
 
                 info.AddValue("hasCI", asAssemblyName.CultureInfo != null);
                 if (asAssemblyName.CultureInfo != null)
@@ -984,7 +984,7 @@ public void Translate(ITranslator translator)
             translator.Translate(ref isSimpleName);
             translator.Translate(ref hasProcessorArchitectureInFusionName);
             translator.Translate(ref immutable);
-            
+
             // TODO: consider some kind of protection against infinite loop during serialization, hint: pre serialize check for cycle in graph
             translator.TranslateHashSet(ref remappedFrom,
                 (ITranslator t) => new AssemblyNameExtension(t),
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 0558d875597..335974a0774 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -229,7 +229,7 @@ public void Translate(ref byte[] byteArray)
             /// </summary>
             /// <param name="byteArray">The array to be translated.</param>
             /// <param name="length">The length of array which will be used in translation. This parameter is not used when reading</param>
-            public void Translate(ref byte[] byteArray, ref int length) 
+            public void Translate(ref byte[] byteArray, ref int length)
             {
                 Translate(ref byteArray);
                 length = byteArray.Length;
@@ -302,7 +302,7 @@ public void Translate<T>(ref List<T> list, ObjectTranslator<T> objectTranslator)
             {
                 IList<T> listAsInterface = list;
                 Translate(ref listAsInterface, objectTranslator, count => new List<T>(count));
-                list = (List<T>) listAsInterface;
+                list = (List<T>)listAsInterface;
             }
 
             public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>
@@ -558,7 +558,7 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua
                     ref copy,
                     count => new Dictionary<string, string>(count, comparer));
 
-                dictionary = (Dictionary<string, string>) copy;
+                dictionary = (Dictionary<string, string>)copy;
             }
 
             public void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> dictionaryCreator)
@@ -711,12 +711,12 @@ public void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, Str
                 }
             }
 
-        /// <summary>
-        /// Reads in the boolean which says if this object is null or not.
-        /// </summary>
-        /// <typeparam name="T">The type of object to test.</typeparam>
-        /// <returns>True if the object should be read, false otherwise.</returns>
-        public bool TranslateNullable<T>(T value)
+            /// <summary>
+            /// Reads in the boolean which says if this object is null or not.
+            /// </summary>
+            /// <typeparam name="T">The type of object to test.</typeparam>
+            /// <returns>True if the object should be read, false otherwise.</returns>
+            public bool TranslateNullable<T>(T value)
             {
                 bool haveRef = _reader.ReadBoolean();
                 return haveRef;
@@ -1136,7 +1136,7 @@ public void Translate(ref byte[] byteArray)
             /// </summary>
             /// <param name="byteArray">The array to be translated.</param>
             /// <param name="length">The length of array which will be used in translation</param>
-            public void Translate(ref byte[] byteArray, ref int length) 
+            public void Translate(ref byte[] byteArray, ref int length)
             {
                 if (!TranslateNullable(byteArray))
                 {
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 00108f00b55..e5c09321eb3 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -28,12 +28,12 @@ internal class BuildEnvironmentHelper
         /// Name of the Visual Studio (and Blend) process.
         /// VS ASP intellisense server fails without Microsoft.VisualStudio.Web.Host. Remove when issue fixed: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/574986
         /// </summary>
-        private static readonly string[] s_visualStudioProcess = {"DEVENV", "BLEND", "Microsoft.VisualStudio.Web.Host"};
+        private static readonly string[] s_visualStudioProcess = { "DEVENV", "BLEND", "Microsoft.VisualStudio.Web.Host" };
 
         /// <summary>
         /// Name of the MSBuild process(es)
         /// </summary>
-        private static readonly string[] s_msBuildProcess = {"MSBUILD", "MSBUILDTASKHOST"};
+        private static readonly string[] s_msBuildProcess = { "MSBUILD", "MSBUILDTASKHOST" };
 
         /// <summary>
         /// Name of MSBuild executable files.
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index 406784dfeab..88d99271d7e 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -57,24 +57,24 @@ internal static class CanonicalError
                 (
                 // Beginning of line and any amount of whitespace.
                 @"^\s*"
-                    // Match a [optional project number prefix 'ddd>'], single letter + colon + remaining filename, or
-                    // string with no colon followed by a colon.
+                // Match a [optional project number prefix 'ddd>'], single letter + colon + remaining filename, or
+                // string with no colon followed by a colon.
                 + @"(((?<ORIGIN>(((\d+>)?[a-zA-Z]?:[^:]*)|([^:]*))):)"
-                    // Origin may also be empty. In this case there's no trailing colon.
+                // Origin may also be empty. In this case there's no trailing colon.
                 + "|())"
-                    // Match the empty string or a string without a colon that ends with a space
+                // Match the empty string or a string without a colon that ends with a space
                 + "(?<SUBCATEGORY>(()|([^:]*? )))"
-                    // Match 'error' or 'warning'.
+                // Match 'error' or 'warning'.
                 + @"(?<CATEGORY>(error|warning))"
-                    // Match anything starting with a space that's not a colon/space, followed by a colon.
-                    // Error code is optional in which case "error"/"warning" can be followed immediately by a colon.
+                // Match anything starting with a space that's not a colon/space, followed by a colon.
+                // Error code is optional in which case "error"/"warning" can be followed immediately by a colon.
                 + @"( \s*(?<CODE>[^: ]*))?\s*:"
-                    // Whatever's left on this line, including colons.
+                // Whatever's left on this line, including colons.
                 + "(?<TEXT>.*)$",
                 RegexOptions.IgnoreCase | RegexOptions.Compiled
                 ));
 
-		private static readonly Lazy<Regex> s_originCategoryCodeTextExpression2 = new Lazy<Regex>(
+        private static readonly Lazy<Regex> s_originCategoryCodeTextExpression2 = new Lazy<Regex>(
             () => new Regex
                 (
                 @"^\s*(?<ORIGIN>(?<FILENAME>.*):(?<LOCATION>(?<LINE>[0-9]*):(?<COLUMN>[0-9]*))):(?<CATEGORY> error| warning):(?<TEXT>.*)",
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 9e8168729c9..187dfa66066 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -363,7 +363,7 @@ internal static Dictionary<string, string> GetEnvironmentVariables()
                 var vars = Environment.GetEnvironmentVariables();
                 foreach (var key in vars.Keys)
                 {
-                    table[(string) key] = (string) vars[key];
+                    table[(string)key] = (string)vars[key];
                 }
             }
 
@@ -608,7 +608,7 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, string archi
             switch (clrVersion)
             {
                 case 0:
-                    // Not a taskhost, runtime must match
+                // Not a taskhost, runtime must match
                 case 4:
                     // Default for MSBuild running on .NET Framework 4,
                     // not represented in handshake
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 4a59448c172..633b6ef92ce 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -78,7 +78,7 @@ internal static class MSBuildConstants
         /// Current version of this MSBuild Engine assembly in the form, e.g, "12.0"
         /// </summary>
         internal const string CurrentProductVersion = "17.0";
-        
+
         /// <summary>
         /// Symbol used in ProjectReferenceTarget items to represent default targets
         /// </summary>
@@ -99,7 +99,7 @@ internal static class MSBuildConstants
         /// with fallback to default targets if the ProjectReference item has no targets specified.
         /// </summary>
         internal const string ProjectReferenceTargetsOrDefaultTargetsMarker = ".projectReferenceTargetsOrDefaultTargets";
-        
+
         // One-time allocations to avoid implicit allocations for Split(), Trim().
         internal static readonly char[] SemicolonChar = { ';' };
         internal static readonly char[] SpaceChar = { ' ' };
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index 57ad7f5900f..d4b88ba7638 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -192,7 +192,7 @@ public V this[string key]
         {
             get
             {
-                TryGetValue((string) key, out V? val);
+                TryGetValue((string)key, out V? val);
                 return val;
             }
 #nullable disable
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index 62110039952..8638af3dabf 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -63,7 +63,7 @@ public void Dispose()
 
         public static CommonWriterType GetStaticWriter()
         {
-            return (CommonWriterType) CommonWriterProperty.Value.GetValue(null, null);
+            return (CommonWriterType)CommonWriterProperty.Value.GetValue(null, null);
         }
 
         // this setter is not thread safe because the assumption is that a writer is set once for the duration of the process (or multiple times from different tests which do not run in parallel).
@@ -78,7 +78,7 @@ public static void SetWriter(CommonWriterType writer)
             }
 
             // wrap with a lock so multi threaded logging does not break messages apart
-            CommonWriterProperty.Value.SetValue(null, (CommonWriterType) LockWrappedWriter);
+            CommonWriterProperty.Value.SetValue(null, (CommonWriterType)LockWrappedWriter);
 
             void LockWrappedWriter(string id, string callsite, IEnumerable<string> message)
             {
@@ -128,7 +128,7 @@ public void Log(
 #if DEBUG
             var writer = GetWriter();
 
-            writer?.Invoke(_id, CallsiteString(sourceFilePath, memberName, sourceLineNumber), new[] {message});
+            writer?.Invoke(_id, CallsiteString(sourceFilePath, memberName, sourceLineNumber), new[] { message });
 #endif
         }
 
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 8752511e6b8..33aacd4b487 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -43,9 +43,28 @@ internal static class ExceptionHandling
         private static string GetDebugDumpPath()
         {
             string debugPath =
-// Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+
+                /* Unmerged change from project 'Microsoft.Build.Engine.OM.UnitTests (net7.0)'
+                Before:
+                // Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+                After:
+                // Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+                */
+                /* Unmerged change from project 'Microsoft.Build.Engine.OM.UnitTests (net472)'
+                Before:
+                // Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+                After:
+                // Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+                */
+                /* Unmerged change from project 'MSBuildTaskHost'
+                Before:
+                // Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+                After:
+                // Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+                */
+                // Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
 #if CLR2COMPATIBILITY || MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-                        Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
                 DebugUtils.DebugPath;
 #endif
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index bb733905b22..63f42fba813 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -2675,7 +2675,7 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
 
             // Ensure that the prefix match wasn't to a distinct directory, so that
             // x\y\prefix doesn't falsely match x\y\prefixmatch.
-            if (directorySeparatorCharacters.Contains(possibleParent[possibleParent.Length-1]))
+            if (directorySeparatorCharacters.Contains(possibleParent[possibleParent.Length - 1]))
             {
                 return true;
             }
diff --git a/src/Shared/FileSystem/CachingFileSystemWrapper.cs b/src/Shared/FileSystem/CachingFileSystemWrapper.cs
index 7dc859b7a61..e121ba9e9f3 100644
--- a/src/Shared/FileSystem/CachingFileSystemWrapper.cs
+++ b/src/Shared/FileSystem/CachingFileSystemWrapper.cs
@@ -33,7 +33,7 @@ public FileAttributes GetAttributes(string path)
 
         public DateTime GetLastWriteTimeUtc(string path)
         {
-            return _lastWriteTimeCache.GetOrAdd(path, p =>_fileSystem.GetLastWriteTimeUtc(p));
+            return _lastWriteTimeCache.GetOrAdd(path, p => _fileSystem.GetLastWriteTimeUtc(p));
         }
 
         public bool DirectoryExists(string path)
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index b3cdcbcb50d..d18a507f1a8 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -36,7 +36,7 @@ internal class WindowsFileSystem : ManagedFileSystem
 
         public static new WindowsFileSystem Singleton() => WindowsFileSystem.Instance;
 
-        private WindowsFileSystem(){ }
+        private WindowsFileSystem() { }
 
         public override IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index de492cc69ac..6593890673a 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -162,6 +162,6 @@ internal static bool MeetsUncPatternMinimumRequirements(string pattern)
                 pattern[0] == _forwardSlash) &&
                 (pattern[1] == _backSlash ||
                 pattern[1] == _forwardSlash);
-       }
+        }
     }
 }
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 28f8a292848..10421dd5831 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -126,9 +126,9 @@ internal static class FrameworkLocationHelper
         private const string ToolsVersionsRegistryPath = @"SOFTWARE\Microsoft\MSBuild\ToolsVersions";
 #endif // FEATURE_WIN32_REGISTRY
 
-#endregion // Constants
+        #endregion // Constants
 
-#region Static member variables
+        #region Static member variables
 
         /// <summary>
         /// By default when a root path is not specified we would like to use the program files directory \ reference assemblies\framework as the root location
@@ -398,9 +398,9 @@ private static readonly (Version, Version)[,] s_explicitFallbackRulesForPathToDo
         private static readonly Lazy<IReadOnlyDictionary<Version, DotNetFrameworkSpec>> DotNetFrameworkSpecDict = new(() => DotNetFrameworkSpecs().ToDictionary(spec => spec.Version));
         private static readonly Lazy<IReadOnlyDictionary<Version, VisualStudioSpec>> VisualStudioSpecDict = new(() => VisualStudioSpecs.Value.ToDictionary(spec => spec.Version));
 
-#endregion // Static member variables
+        #endregion // Static member variables
 
-#region Static properties
+        #region Static properties
 
         internal static string PathToDotNetFrameworkV11
         {
@@ -622,9 +622,9 @@ private static string PathToV4ToolsInFallbackDotNetFrameworkSdk
             }
         }
 
-#endregion // Static properties
+        #endregion // Static properties
 
-#region Internal methods
+        #region Internal methods
 
         internal static string GetDotNetFrameworkSdkRootRegistryKey(Version dotNetFrameworkVersion, Version visualStudioVersion)
         {
@@ -1090,9 +1090,9 @@ private static string GetPathToBuildToolsFromRegistry(string toolsVersion, DotNe
         }
 #endif
 
-#endregion // Internal methods
+        #endregion // Internal methods
 
-#region Private methods
+        #region Private methods
 
         /// <summary>
         /// Will return the path to the dot net framework reference assemblies if they exist under the program files\reference assembies\microsoft\framework directory
@@ -1179,7 +1179,7 @@ private static void RedirectVersionsIfNecessary(ref Version dotNetFrameworkVersi
             }
         }
 
-#endregion
+        #endregion
 
         private class VisualStudioSpec
         {
@@ -1728,7 +1728,7 @@ public override string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudio
             /// </summary>
             public override string GetPathToDotNetFrameworkReferenceAssemblies()
             {
-                if (this._pathToDotNetFrameworkReferenceAssemblies== null)
+                if (this._pathToDotNetFrameworkReferenceAssemblies == null)
                 {
 #if FEATURE_WIN32_REGISTRY
                     this._pathToDotNetFrameworkReferenceAssemblies = FindRegistryValueUnderKey(
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 3a507470744..4f290074690 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -277,7 +277,7 @@ void Translate<T>(ref T value)
         /// </summary>
         /// <param name="byteArray">The array to be translated.</param>
         void Translate(ref byte[] byteArray);
-        
+
         /// <summary>
         /// Translates a byte array
         /// </summary>
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index f7279a94d50..9e931e16df2 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -31,6 +31,7 @@ namespace Microsoft.Build.Shared
     /// </comments>
     internal static class InprocTrackingNativeMethods
     {
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Delegates for the tracking functions
 
         [UnmanagedFunctionPointer(CallingConvention.StdCall)]
@@ -146,7 +147,7 @@ internal static void SetThreadCount(int threadCount)
         }
 
         #endregion // Public API
-
+#pragma warning restore format
         private static class FileTrackerDllStub
         {
             private static readonly Lazy<string> fileTrackerDllName = new Lazy<string>(() => RuntimeInformation.ProcessArchitecture == Architecture.Arm64 ? "FileTrackerA4.dll" : (IntPtr.Size == sizeof(Int32)) ? "FileTracker32.dll" : "FileTracker64.dll");
@@ -154,7 +155,7 @@ private static class FileTrackerDllStub
             // Handle for FileTracker.dll itself
             [SecurityCritical]
             private static SafeHandle s_fileTrackerDllHandle;
-
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
             #region Function pointers to native functions
 
             internal static StartTrackingContextDelegate startTrackingContextDelegate;
@@ -273,7 +274,7 @@ static FileTrackerDllStub()
             }
 
             #endregion  // Initialization code
-
+#pragma warning restore format
             // Specialized handle to make sure we free FileTracker.dll 
             [SecurityCritical]
             private class SafeLibraryHandle : SafeHandle
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 7a2b51221c5..fc0f1e28b0b 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -210,7 +210,7 @@ private static Buffer GetPooledBuffer()
             return new Buffer();
         }
 
-#region IDisposable pattern
+        #region IDisposable pattern
 
         /// <summary>
         /// Returns our buffer to the pool if we were not passed one by the caller.
@@ -226,7 +226,7 @@ protected override void Dispose(bool disposing)
             base.Dispose(disposing);
         }
 
-#endregion
+        #endregion
 
         /// <summary>
         /// Create a BinaryReader. It will either be an interning reader or standard binary reader
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 8d1e1c38e7a..88343c0d252 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -79,22 +79,22 @@ public MSBuildLoadContext(string assemblyPath)
                 // bare search directory if that fails.
                 : new[] { assemblyName.CultureName, string.Empty })
             {
-                    var candidatePath = Path.Combine(_directory,
-                        cultureSubfolder,
-                        $"{assemblyName.Name}.dll");
-
-                    if (!FileSystems.Default.FileExists(candidatePath))
-                    {
-                        continue;
-                    }
-
-                    AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
-                    if (candidateAssemblyName.Version != assemblyName.Version)
-                    {
-                        continue;
-                    }
-
-                    return LoadFromAssemblyPath(candidatePath);
+                var candidatePath = Path.Combine(_directory,
+                    cultureSubfolder,
+                    $"{assemblyName.Name}.dll");
+
+                if (!FileSystems.Default.FileExists(candidatePath))
+                {
+                    continue;
+                }
+
+                AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
+                if (candidateAssemblyName.Version != assemblyName.Version)
+                {
+                    continue;
+                }
+
+                return LoadFromAssemblyPath(candidatePath);
             }
 
             // If the Assembly is provided via a file path, the following rules are used to load the assembly:
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index aefd4aaebb2..80da618a3f3 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -31,7 +31,7 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
-#region Private Data
+        #region Private Data
 
 #if NETCOREAPP2_1_OR_GREATER || MONO
         /// <summary>
@@ -113,18 +113,18 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </summary>
         private BinaryWriter _binaryWriter;
 
-#endregion
+        #endregion
 
-#region INodeEndpoint Events
+        #region INodeEndpoint Events
 
         /// <summary>
         /// Raised when the link status has changed.
         /// </summary>
         public event LinkStatusChangedDelegate OnLinkStatusChanged;
 
-#endregion
+        #endregion
 
-#region INodeEndpoint Properties
+        #region INodeEndpoint Properties
 
         /// <summary>
         /// Returns the link status of this node.
@@ -134,13 +134,13 @@ public LinkStatus LinkStatus
             get { return _status; }
         }
 
-#endregion
+        #endregion
 
-#region Properties
+        #region Properties
 
-#endregion
+        #endregion
 
-#region INodeEndpoint Methods
+        #region INodeEndpoint Methods
 
         /// <summary>
         /// Causes this endpoint to wait for the remote endpoint to connect
@@ -193,9 +193,9 @@ public void ClientWillDisconnect()
             _isClientDisconnecting = true;
         }
 
-#endregion
+        #endregion
 
-#region Construction
+        #region Construction
 
         /// <summary>
         /// Instantiates an endpoint to act as a client
@@ -260,10 +260,10 @@ internal void InternalConstruct(string pipeName = null)
                     PipeBufferSize, // Default input buffer
                     PipeBufferSize  // Default output buffer
                 );
-             }
+            }
         }
 
-#endregion
+        #endregion
 
         /// <summary>
         /// Returns the host handshake for this node endpoint
@@ -291,7 +291,7 @@ private void RaiseLinkStatusChanged(LinkStatus newStatus)
             OnLinkStatusChanged?.Invoke(this, newStatus);
         }
 
-#region Private Methods
+        #region Private Methods
 
         /// <summary>
         /// This does the actual work of changing the status and shutting down any threads we may have for
@@ -312,7 +312,7 @@ private void InternalDisconnect()
             ChangeLinkStatus(LinkStatus.Inactive);
         }
 
-#region Asynchronous Mode Methods
+        #region Asynchronous Mode Methods
 
         /// <summary>
         /// Adds a packet to the packet queue when asynchronous mode is enabled.
@@ -454,7 +454,7 @@ private void PacketPumpProc()
                         // 2. The host is too old sending us bits we automatically reject in the handshake
                         // 3. We expected to read the EndOfHandshake signal, but we received something else
                         CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
-                        
+
                         gotValidConnection = false;
                     }
                     catch (InvalidOperationException)
@@ -676,8 +676,8 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
             while (!exitLoop);
         }
 
-#endregion
+        #endregion
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index d3ff339ced3..e42ffb9fc56 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -21,71 +21,71 @@ internal static string GetNearestPlatform(string referencedProjectPlatform, stri
             Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable, log);
 
             if (string.IsNullOrEmpty(projectReferencePlatformsMetadata) && string.IsNullOrEmpty(referencedProjectPlatform))
-                {
-                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", projectPath);
-                    return string.Empty;
-                }
+            {
+                log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", projectPath);
+                return string.Empty;
+            }
 
-                // Pull platformLookupTable metadata from the referenced project. This allows custom
-                // mappings on a per-ProjectReference basis.
-                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, log);
+            // Pull platformLookupTable metadata from the referenced project. This allows custom
+            // mappings on a per-ProjectReference basis.
+            Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, log);
 
-                HashSet<string> projectReferencePlatforms = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-                foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
-                {
-                    projectReferencePlatforms.Add(s);
-                }
+            HashSet<string> projectReferencePlatforms = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+            {
+                projectReferencePlatforms.Add(s);
+            }
 
-                string buildProjectReferenceAs = string.Empty;
+            string buildProjectReferenceAs = string.Empty;
 
-                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
-                // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
-                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
-                {
-                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
-                }
-                // Prefer matching platforms
-                else if (projectReferencePlatforms.Contains(currentProjectPlatform))
-                {
-                    buildProjectReferenceAs = currentProjectPlatform;
-                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
-                }
-                // Prioritize platformLookupTable **metadata** attached to the ProjectReference item
-                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
-                else if (projectReferenceLookupTable != null &&
-                        projectReferenceLookupTable.ContainsKey(currentProjectPlatform) &&
-                        projectReferencePlatforms.Contains(projectReferenceLookupTable[currentProjectPlatform]))
-                {
-                    buildProjectReferenceAs = projectReferenceLookupTable[currentProjectPlatform];
-                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
-                }
-                // Current project's translation table follows
-                else if (currentProjectLookupTable != null &&
-                        currentProjectLookupTable.ContainsKey(currentProjectPlatform) &&
-                        projectReferencePlatforms.Contains(currentProjectLookupTable[currentProjectPlatform]))
-                {
-                    buildProjectReferenceAs = currentProjectLookupTable[currentProjectPlatform];
-                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, platformLookupTable);
-                }
-                // AnyCPU if possible
-                else if (projectReferencePlatforms.Contains("AnyCPU"))
-                {
-                    buildProjectReferenceAs = "AnyCPU";
-                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
-                }
-                else
-                {
-                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
-                    // Platform/PlatformTarget when this is the case.
-                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
-                }
-                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
-                // If we're about to tell the reference to build using its default platform, don't pass it as a global property.
-                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(buildProjectReferenceAs, StringComparison.OrdinalIgnoreCase))
-                {
-                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
-                    buildProjectReferenceAs = string.Empty;
-                }
+            // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
+            // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
+            if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
+            {
+                log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
+            }
+            // Prefer matching platforms
+            else if (projectReferencePlatforms.Contains(currentProjectPlatform))
+            {
+                buildProjectReferenceAs = currentProjectPlatform;
+                log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
+            }
+            // Prioritize platformLookupTable **metadata** attached to the ProjectReference item
+            // before the current project's table. We do this to allow per-ProjectReference fine tuning.
+            else if (projectReferenceLookupTable != null &&
+                    projectReferenceLookupTable.ContainsKey(currentProjectPlatform) &&
+                    projectReferencePlatforms.Contains(projectReferenceLookupTable[currentProjectPlatform]))
+            {
+                buildProjectReferenceAs = projectReferenceLookupTable[currentProjectPlatform];
+                log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
+            }
+            // Current project's translation table follows
+            else if (currentProjectLookupTable != null &&
+                    currentProjectLookupTable.ContainsKey(currentProjectPlatform) &&
+                    projectReferencePlatforms.Contains(currentProjectLookupTable[currentProjectPlatform]))
+            {
+                buildProjectReferenceAs = currentProjectLookupTable[currentProjectPlatform];
+                log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, platformLookupTable);
+            }
+            // AnyCPU if possible
+            else if (projectReferencePlatforms.Contains("AnyCPU"))
+            {
+                buildProjectReferenceAs = "AnyCPU";
+                log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
+            }
+            else
+            {
+                // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
+                // Platform/PlatformTarget when this is the case.
+                log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
+            }
+            // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
+            // If we're about to tell the reference to build using its default platform, don't pass it as a global property.
+            if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(buildProjectReferenceAs, StringComparison.OrdinalIgnoreCase))
+            {
+                log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
+                buildProjectReferenceAs = string.Empty;
+            }
             return buildProjectReferenceAs;
         }
         internal static Dictionary<string, string>? ExtractLookupTable(string stringTable, TaskLoggingHelper? log = null)
diff --git a/src/Shared/RegistryDelegates.cs b/src/Shared/RegistryDelegates.cs
index 4883342d33f..38dcad887e6 100644
--- a/src/Shared/RegistryDelegates.cs
+++ b/src/Shared/RegistryDelegates.cs
@@ -7,8 +7,8 @@
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-   /// Given a registry hive and a request view open the base key for that registry location.
-   /// </summary>
+    /// Given a registry hive and a request view open the base key for that registry location.
+    /// </summary>
     internal delegate RegistryKey OpenBaseKey(RegistryHive hive, RegistryView view);
 
     /// <summary>
diff --git a/src/Shared/TaskEngineAssemblyResolver.cs b/src/Shared/TaskEngineAssemblyResolver.cs
index 9a09e33310d..3a6293f4dd8 100644
--- a/src/Shared/TaskEngineAssemblyResolver.cs
+++ b/src/Shared/TaskEngineAssemblyResolver.cs
@@ -63,7 +63,7 @@ internal void InstallHandler()
 #endif
         }
 
-        
+
 
         /// <summary>
         /// Removes the event handler.
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index ff2b4901582..32a10b29e7e 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -513,9 +513,9 @@ public void LogMessageFromResources(MessageImportance importance, string message
 #endif
         }
 
-#endregion
+        #endregion
 
-#region ExternalProjectStarted/Finished logging methods
+        #region ExternalProjectStarted/Finished logging methods
 
         /// <summary>
         /// Small helper for logging the custom ExternalProjectStarted build event
@@ -559,9 +559,9 @@ bool succeeded
             BuildEngine.LogCustomEvent(epf);
         }
 
-#endregion
+        #endregion
 
-#region Command line logging methods
+        #region Command line logging methods
 
         /// <summary>
         /// Logs the command line for a task's underlying tool/executable/shell command.
@@ -603,9 +603,9 @@ public void LogCommandLine(MessageImportance importance, string commandLine)
             BuildEngine.LogMessageEvent(e);
         }
 
-#endregion
+        #endregion
 
-#region Error logging methods
+        #region Error logging methods
 
         /// <summary>
         /// Logs an error using the specified string.
@@ -968,9 +968,9 @@ public void LogErrorFromException(Exception exception, bool showStackTrace, bool
             LogError(null, null, null, file, 0, 0, 0, 0, message);
         }
 
-#endregion
+        #endregion
 
-#region Warning logging methods
+        #region Warning logging methods
 
         /// <summary>
         /// Logs a warning using the specified string.
@@ -1301,9 +1301,9 @@ public void LogWarningFromException(Exception exception, bool showStackTrace)
             LogWarning(message);
         }
 
-#endregion
+        #endregion
 
-#region Bulk logging methods
+        #region Bulk logging methods
 
         /// <summary>
         /// Logs errors/warnings/messages for each line of text in the given file. Errors/warnings are only logged for lines that
@@ -1456,9 +1456,9 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
             return isError;
         }
 
-#endregion
+        #endregion
 
-#region Telemetry logging methods
+        #region Telemetry logging methods
 
         /// <summary>
         /// Logs telemetry with the specified event name and properties.
@@ -1470,10 +1470,10 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie
             (BuildEngine as IBuildEngine5)?.LogTelemetry(eventName, properties);
         }
 
-#endregion
+        #endregion
 
 #if FEATURE_APPDOMAIN
-#region AppDomain Code
+        #region AppDomain Code
 
         /// <summary>
         /// InitializeLifetimeService is called when the remote object is activated.
@@ -1559,7 +1559,7 @@ public void MarkAsInactive()
             }
         }
 
-#endregion
+        #endregion
 #endif
     }
 }
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index c9dd8991a6a..5a1177fe081 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -179,9 +179,9 @@ public TaskParameter(object wrappedParameter)
                     _parameterType = TaskParameterType.String;
                     _wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
                 }
-                    // Also stringify known common value types, to avoid calling
-                    // TranslateDotNet when they'll just be stringified on the
-                    // output side
+                // Also stringify known common value types, to avoid calling
+                // TranslateDotNet when they'll just be stringified on the
+                // output side
                 else if (wrappedParameterType == typeof(bool))
                 {
                     _parameterType = TaskParameterType.Bool;
@@ -549,7 +549,7 @@ private class TaskParameterTaskItem :
             ITaskItem,
             ITaskItem2
 #if !TASKHOST
-            ,IMetadataContainer
+            , IMetadataContainer
 #endif
         {
             /// <summary>
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 40d28f23b29..434e7923809 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -193,7 +193,8 @@ private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo as
 
             // Deduplicate between MSBuild assemblies and task dependencies. 
             Dictionary<string, string> assembliesDictionary = new(localAssemblies.Length + runtimeAssemblies.Length);
-            foreach (string localPath in localAssemblies) {
+            foreach (string localPath in localAssemblies)
+            {
                 assembliesDictionary.Add(Path.GetFileName(localPath), localPath);
             }
 
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 7361b94e1b5..f41ba598dd9 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -706,7 +706,7 @@ public void VerifyAssemblyNameExSerialization(string assemblyName)
             using (MemoryStream ms = new MemoryStream(bytes))
             {
                 BinaryFormatter formatter = new BinaryFormatter();
-                assemblyNameDeserialized = (AssemblyNameExtension) formatter.Deserialize(ms);
+                assemblyNameDeserialized = (AssemblyNameExtension)formatter.Deserialize(ms);
             }
 
             assemblyNameDeserialized.ShouldBe(assemblyNameOriginal);
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 7f6d55178ac..93c4eff6d19 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1524,7 +1524,7 @@ public void RemoveProjectDirectory()
             strings = FileMatcher.RemoveProjectDirectory(strings, NativeMethodsShared.IsWindows ? "c:\\" : "/").ToArray();
             Assert.Equal("1.file", strings[0]);
 
-            strings = new string[1] { NativeMethodsShared.IsWindows ? "c:\\directory\\1.file" : "/directory/1.file"};
+            strings = new string[1] { NativeMethodsShared.IsWindows ? "c:\\directory\\1.file" : "/directory/1.file" };
             strings = FileMatcher.RemoveProjectDirectory(strings, NativeMethodsShared.IsWindows ? "c:\\" : "/").ToArray();
             Assert.Equal(strings[0], NativeMethodsShared.IsWindows ? "directory\\1.file" : "directory/1.file");
 
@@ -1533,12 +1533,12 @@ public void RemoveProjectDirectory()
             Assert.Equal("1.file", strings[0]);
 
             strings = new string[1] { NativeMethodsShared.IsWindows ? "c:\\1.file" : "/1.file" };
-            strings = FileMatcher.RemoveProjectDirectory(strings, NativeMethodsShared.IsWindows ? "c:\\directory" : "/directory" ).ToArray();
+            strings = FileMatcher.RemoveProjectDirectory(strings, NativeMethodsShared.IsWindows ? "c:\\directory" : "/directory").ToArray();
             Assert.Equal(strings[0], NativeMethodsShared.IsWindows ? "c:\\1.file" : "/1.file");
 
             strings = new string[1] { NativeMethodsShared.IsWindows ? "c:\\directorymorechars\\1.file" : "/directorymorechars/1.file" };
             strings = FileMatcher.RemoveProjectDirectory(strings, NativeMethodsShared.IsWindows ? "c:\\directory" : "/directory").ToArray();
-            Assert.Equal(strings[0], NativeMethodsShared.IsWindows ? "c:\\directorymorechars\\1.file" : "/directorymorechars/1.file" );
+            Assert.Equal(strings[0], NativeMethodsShared.IsWindows ? "c:\\directorymorechars\\1.file" : "/directorymorechars/1.file");
 
             if (NativeMethodsShared.IsWindows)
             {
@@ -2080,7 +2080,7 @@ out bool isLegalFileSpec
             isLegalFileSpec.ShouldBe(expectedIsLegalFileSpec);
         }
 
-#region Support functions.
+        #region Support functions.
 
         /// <summary>
         /// This support class simulates a file system.
@@ -2761,7 +2761,7 @@ bool shouldBeRecursive
             return match.isMatch;
         }
 
-#endregion
+        #endregion
 
         private class FileSystemAdapter : IFileSystem
         {
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index bf08dd752cf..a33abfb1c22 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -268,9 +268,9 @@ public void GetDirectoryWithTrailingSlash()
         }
 
         [Theory]
-        [InlineData("foo.txt",      new[] { ".txt" })]
-        [InlineData("foo.txt",      new[] { ".TXT" })]
-        [InlineData("foo.txt",      new[] { ".EXE", ".TXT" })]
+        [InlineData("foo.txt", new[] { ".txt" })]
+        [InlineData("foo.txt", new[] { ".TXT" })]
+        [InlineData("foo.txt", new[] { ".EXE", ".TXT" })]
         public void HasExtension_WhenFileNameHasExtension_ReturnsTrue(string fileName, string[] allowedExtensions)
         {
             var result = FileUtilities.HasExtension(fileName, allowedExtensions);
@@ -282,13 +282,13 @@ public void HasExtension_WhenFileNameHasExtension_ReturnsTrue(string fileName, s
         }
 
         [Theory]
-        [InlineData("foo.txt",      new[] { ".DLL" })]
-        [InlineData("foo.txt",      new[] { ".EXE", ".DLL" })]
-        [InlineData("foo.exec",     new[] { ".exe", })]
-        [InlineData("foo.exe",      new[] { ".exec", })]
-        [InlineData("foo",          new[] { ".exe", })]
-        [InlineData("",             new[] { ".exe" })]
-        [InlineData(null,           new[] { ".exe" })]
+        [InlineData("foo.txt", new[] { ".DLL" })]
+        [InlineData("foo.txt", new[] { ".EXE", ".DLL" })]
+        [InlineData("foo.exec", new[] { ".exe", })]
+        [InlineData("foo.exe", new[] { ".exec", })]
+        [InlineData("foo", new[] { ".exe", })]
+        [InlineData("", new[] { ".exe" })]
+        [InlineData(null, new[] { ".exe" })]
         public void HasExtension_WhenFileNameDoesNotHaveExtension_ReturnsFalse(string fileName, string[] allowedExtensions)
         {
             var result = FileUtilities.HasExtension(fileName, allowedExtensions);
@@ -531,7 +531,7 @@ public void NormalizePathTooLongWithDots()
         }
 
 #if FEATURE_LEGACY_GETFULLPATH
-        [Fact(Skip="https://github.com/dotnet/msbuild/issues/4205")]
+        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/4205")]
         [PlatformSpecific(TestPlatforms.Windows)]
         public void NormalizePathBadGlobalroot()
         {
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 5af9c7c7abf..630ecd617bb 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -270,113 +270,113 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                         }
                         break;
                     case BuildErrorEventArgs e:
-                    {
-                        string logMessage = $"{e.File}({e.LineNumber},{e.ColumnNumber}): {e.Subcategory} error {e.Code}: {e.Message}";
-                        _fullLog.AppendLine(logMessage);
-                        _testOutputHelper?.WriteLine(logMessage);
+                        {
+                            string logMessage = $"{e.File}({e.LineNumber},{e.ColumnNumber}): {e.Subcategory} error {e.Code}: {e.Message}";
+                            _fullLog.AppendLine(logMessage);
+                            _testOutputHelper?.WriteLine(logMessage);
 
-                        ++ErrorCount;
-                        Errors.Add(e);
-                        break;
-                    }
+                            ++ErrorCount;
+                            Errors.Add(e);
+                            break;
+                        }
                     default:
-                    {
-                        // Log the message unless we are a build finished event and logBuildFinished is set to false.
-                        bool logMessage = !(eventArgs is BuildFinishedEventArgs) || LogBuildFinished;
-                        if (logMessage)
                         {
-                            _fullLog.AppendLine(eventArgs.Message);
-                            _testOutputHelper?.WriteLine(eventArgs.Message);
+                            // Log the message unless we are a build finished event and logBuildFinished is set to false.
+                            bool logMessage = !(eventArgs is BuildFinishedEventArgs) || LogBuildFinished;
+                            if (logMessage)
+                            {
+                                _fullLog.AppendLine(eventArgs.Message);
+                                _testOutputHelper?.WriteLine(eventArgs.Message);
+                            }
+                            break;
                         }
-                        break;
-                    }
                 }
 
                 // Log the specific type of event it was
                 switch (eventArgs)
                 {
                     case ExternalProjectStartedEventArgs args:
-                    {
-                        ExternalProjectStartedEvents.Add(args);
-                        break;
-                    }
+                        {
+                            ExternalProjectStartedEvents.Add(args);
+                            break;
+                        }
                     case ExternalProjectFinishedEventArgs finishedEventArgs:
-                    {
-                        ExternalProjectFinishedEvents.Add(finishedEventArgs);
-                        break;
-                    }
+                        {
+                            ExternalProjectFinishedEvents.Add(finishedEventArgs);
+                            break;
+                        }
                     case ProjectEvaluationStartedEventArgs evaluationStartedEventArgs:
-                    {
-                        EvaluationStartedEvents.Add(evaluationStartedEventArgs);
-                        break;
-                    }
+                        {
+                            EvaluationStartedEvents.Add(evaluationStartedEventArgs);
+                            break;
+                        }
                     case ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs:
-                    {
-                        EvaluationFinishedEvents.Add(evaluationFinishedEventArgs);
-                        break;
-                    }
+                        {
+                            EvaluationFinishedEvents.Add(evaluationFinishedEventArgs);
+                            break;
+                        }
                     case ProjectStartedEventArgs startedEventArgs:
-                    {
-                        ProjectStartedEvents.Add(startedEventArgs);
-                        break;
-                    }
+                        {
+                            ProjectStartedEvents.Add(startedEventArgs);
+                            break;
+                        }
                     case ProjectFinishedEventArgs finishedEventArgs:
-                    {
-                        ProjectFinishedEvents.Add(finishedEventArgs);
-                        break;
-                    }
+                        {
+                            ProjectFinishedEvents.Add(finishedEventArgs);
+                            break;
+                        }
                     case TargetStartedEventArgs targetStartedEventArgs:
-                    {
-                        TargetStartedEvents.Add(targetStartedEventArgs);
-                        break;
-                    }
+                        {
+                            TargetStartedEvents.Add(targetStartedEventArgs);
+                            break;
+                        }
                     case TargetFinishedEventArgs targetFinishedEventArgs:
-                    {
-                        TargetFinishedEvents.Add(targetFinishedEventArgs);
-                        break;
-                    }
+                        {
+                            TargetFinishedEvents.Add(targetFinishedEventArgs);
+                            break;
+                        }
                     case TaskStartedEventArgs taskStartedEventArgs:
-                    {
-                        TaskStartedEvents.Add(taskStartedEventArgs);
-                        break;
-                    }
+                        {
+                            TaskStartedEvents.Add(taskStartedEventArgs);
+                            break;
+                        }
                     case TaskFinishedEventArgs taskFinishedEventArgs:
-                    {
-                        TaskFinishedEvents.Add(taskFinishedEventArgs);
-                        break;
-                    }
+                        {
+                            TaskFinishedEvents.Add(taskFinishedEventArgs);
+                            break;
+                        }
                     case BuildMessageEventArgs buildMessageEventArgs:
-                    {
-                        BuildMessageEvents.Add(buildMessageEventArgs);
-                        break;
-                    }
+                        {
+                            BuildMessageEvents.Add(buildMessageEventArgs);
+                            break;
+                        }
                     case BuildStartedEventArgs buildStartedEventArgs:
-                    {
-                        BuildStartedEvents.Add(buildStartedEventArgs);
-                        break;
-                    }
-                    case BuildFinishedEventArgs buildFinishedEventArgs:
-                    {
-                        BuildFinishedEvents.Add(buildFinishedEventArgs);
-
-                        if (!AllowTaskCrashes)
                         {
-                            // We should not have any task crashes. Sometimes a test will validate that their expected error
-                            // code appeared, but not realize it then crashed.
-                            AssertLogDoesntContain("MSB4018");
+                            BuildStartedEvents.Add(buildStartedEventArgs);
+                            break;
                         }
+                    case BuildFinishedEventArgs buildFinishedEventArgs:
+                        {
+                            BuildFinishedEvents.Add(buildFinishedEventArgs);
 
-                        // We should not have any Engine crashes.
-                        AssertLogDoesntContain("MSB0001");
+                            if (!AllowTaskCrashes)
+                            {
+                                // We should not have any task crashes. Sometimes a test will validate that their expected error
+                                // code appeared, but not realize it then crashed.
+                                AssertLogDoesntContain("MSB4018");
+                            }
 
-                        // Console.Write in the context of a unit test is very expensive.  A hundred
-                        // calls to Console.Write can easily take two seconds on a fast machine.  Therefore, only
-                        // do the Console.Write once at the end of the build.
+                            // We should not have any Engine crashes.
+                            AssertLogDoesntContain("MSB0001");
 
-                        PrintFullLog();
+                            // Console.Write in the context of a unit test is very expensive.  A hundred
+                            // calls to Console.Write can easily take two seconds on a fast machine.  Therefore, only
+                            // do the Console.Write once at the end of the build.
 
-                        break;
-                    }
+                            PrintFullLog();
+
+                            break;
+                        }
                 }
             }
         }
diff --git a/src/Shared/UnitTests/PrintLineDebugger_Tests.cs b/src/Shared/UnitTests/PrintLineDebugger_Tests.cs
index a9cd5ddb7ff..fc59bd61588 100644
--- a/src/Shared/UnitTests/PrintLineDebugger_Tests.cs
+++ b/src/Shared/UnitTests/PrintLineDebugger_Tests.cs
@@ -59,7 +59,7 @@ public void CompositeWriterCanWriteToMultipleWriters()
             var writer2 = new MockWriter();
 
             var compositeWriter = new PrintLineDebuggerWriters.CompositeWriter(
-                new []
+                new[]
                 {
                     writer1.Writer(),
                     writer2.Writer()
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 0d1a3147432..055d02c5419 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -418,7 +418,7 @@ void AssertDictionaryInclusion(IDictionary superset, IDictionary subset, string
                 {
                     // workaround for https://github.com/dotnet/msbuild/pull/3866
                     // if the initial environment had empty keys, then MSBuild will accidentally remove them via Environment.SetEnvironmentVariable
-                    if (operation != "removed" || !string.IsNullOrEmpty((string) subset[key]))
+                    if (operation != "removed" || !string.IsNullOrEmpty((string)subset[key]))
                     {
                         superset.Contains(key).ShouldBe(true, $"environment variable {operation}: {key}");
                         superset[key].ShouldBe(subset[key]);
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index 54aa9961901..1b1d8546afc 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -57,7 +57,7 @@ public void Regress_Mutation_ParameterOrderDoesntMatter()
         {
             Assert.True(TypeLoader.IsPartialTypeNameMatch("Csc", "Microsoft.Build.Tasks.Csc"));
         }
-        
+
 
         [Fact]
         public void LoadNonExistingAssembly()
@@ -140,7 +140,7 @@ public void LoadOutsideAssembly()
             }
         }
 
-        [Fact (Skip = "https://github.com/dotnet/msbuild/issues/325")]
+        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/325")]
         public void LoadInsideAssemblyWhenGivenOutsideAssemblyWithSameName()
         {
             using (var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder))
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index aaa340eb2b4..b2c0414a905 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -50,11 +50,11 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
                 newElement.AppendChild(oldElement.FirstChild);
             }
 
-               
-            
-                // Add the new element in the same place the old element was.
-                oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
-            
+
+
+            // Add the new element in the same place the old element was.
+            oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
+
 
             return newElement;
         }
diff --git a/src/StringTools.UnitTests/WeakStringCache_Tests.cs b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
index b2e1da93006..4217a2a7a67 100644
--- a/src/StringTools.UnitTests/WeakStringCache_Tests.cs
+++ b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
@@ -108,7 +108,7 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
             for (int i = 0; i < numberOfStrings; i++)
             {
                 InternableString stringCopy = new InternableString(new string(cachedStrings[i].ToCharArray()));
-                string cachedStringFromCache =_cache.GetOrCreateEntry(ref stringCopy, out bool cacheHit);
+                string cachedStringFromCache = _cache.GetOrCreateEntry(ref stringCopy, out bool cacheHit);
                 cacheHit.ShouldBeFalse();
                 cachedStringFromCache.ShouldNotBeSameAs(cachedStrings[i]);
             }
diff --git a/src/StringTools/WeakStringCacheInterner.cs b/src/StringTools/WeakStringCacheInterner.cs
index 34366af3cfc..ad47f3d13c0 100644
--- a/src/StringTools/WeakStringCacheInterner.cs
+++ b/src/StringTools/WeakStringCacheInterner.cs
@@ -30,7 +30,7 @@ private enum InternResult
         /// </summary>
         private readonly WeakStringCache _weakStringCache = new WeakStringCache();
 
-#region Statistics
+        #region Statistics
         /// <summary>
         /// Number of times the regular interning path found the string in the cache.
         /// </summary>
@@ -58,7 +58,7 @@ private enum InternResult
         /// </summary>
         private Dictionary<string, int>? _internCallCountsByString;
 
-#endregion
+        #endregion
 
         /// <summary>
         /// Try to intern the string.
diff --git a/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs b/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
index a3dec6636fb..637c0fe9d94 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
@@ -28,7 +28,7 @@ public AssemblyFoldersFromConfig_Tests(ITestOutputHelper output) : base(output)
                 Path.Combine(s_rootPathPrefix, "assemblyfromconfig", "folder501000x86", "v5assembly.dll")
             });
         }
-        
+
         [Fact]
         public void AssemblyFoldersFromConfigTest()
         {
@@ -42,10 +42,10 @@ public void AssemblyFoldersFromConfigTest()
                 ResolveAssemblyReference t = new ResolveAssemblyReference
                 {
                     BuildEngine = new MockEngine(_output),
-                    Assemblies = new ITaskItem[] {new TaskItem("assemblyfromconfig2")},
-                    SearchPaths = new[] {moniker}
+                    Assemblies = new ITaskItem[] { new TaskItem("assemblyfromconfig2") },
+                    SearchPaths = new[] { moniker }
                 };
-                
+
                 Execute(t);
 
                 Assert.Single(t.ResolvedFiles);
@@ -71,8 +71,8 @@ public void AssemblyFoldersFromConfigPlatformSpecificAssemblyFirstTest()
                 ResolveAssemblyReference t = new ResolveAssemblyReference
                 {
                     BuildEngine = new MockEngine(_output),
-                    Assemblies = new ITaskItem[] {new TaskItem("assemblyfromconfig_common.dll")},
-                    SearchPaths = new[] {moniker},
+                    Assemblies = new ITaskItem[] { new TaskItem("assemblyfromconfig_common.dll") },
+                    SearchPaths = new[] { moniker },
                     TargetProcessorArchitecture = "x86"
                 };
 
@@ -145,8 +145,8 @@ public void AssemblyFoldersFromConfigFileNotFoundTest()
                 ResolveAssemblyReference t = new ResolveAssemblyReference
                 {
                     BuildEngine = new MockEngine(_output),
-                    Assemblies = new ITaskItem[] {new TaskItem("assemblyfromconfig_common.dll")},
-                    SearchPaths = new[] {moniker},
+                    Assemblies = new ITaskItem[] { new TaskItem("assemblyfromconfig_common.dll") },
+                    SearchPaths = new[] { moniker },
                     TargetProcessorArchitecture = "x86"
                 };
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 01d46289a95..63cf4070fa4 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3437,7 +3437,7 @@ public void ResolveBadImageInSecondary()
 
             // There should have been no warning about the exception because it's only a dependency
             Assert.Equal(0, engine.Warnings);
-        
+
             // There should have been no ugly callstack dumped
             engine.AssertLogDoesntContain("Microsoft.Build.UnitTests");
         }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 0ac1240605f..f8f34faa202 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -3010,26 +3010,26 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC
                     t.FindSerializationAssemblies = false;
                     t.FindRelatedFiles = false;
                     t.StateFile = null;
-	                t.Execute
-	                (
-	                    fileExists,
-	                    directoryExists,
-	                    getDirectories,
-	                    getAssemblyName,
-	                    getAssemblyMetadata,
-	#if FEATURE_WIN32_REGISTRY
-	                    getRegistrySubKeyNames,
-	                    getRegistrySubKeyDefaultValue,
-	#endif
-	                    getLastWriteTime,
-	                    getRuntimeVersion,
-	#if FEATURE_WIN32_REGISTRY
-	                    openBaseKey,
-	#endif
-	                    checkIfAssemblyIsInGac,
-	                    isWinMDFile,
-	                    readMachineTypeFromPEHeader
-	                );
+                    t.Execute
+                    (
+                        fileExists,
+                        directoryExists,
+                        getDirectories,
+                        getAssemblyName,
+                        getAssemblyMetadata,
+#if FEATURE_WIN32_REGISTRY
+                        getRegistrySubKeyNames,
+                        getRegistrySubKeyDefaultValue,
+#endif
+                        getLastWriteTime,
+                        getRuntimeVersion,
+#if FEATURE_WIN32_REGISTRY
+                        openBaseKey,
+#endif
+                        checkIfAssemblyIsInGac,
+                        isWinMDFile,
+                        readMachineTypeFromPEHeader
+                    );
 
                     // A few checks. These should always be true or it may be a perf issue for project load.
                     ITaskItem[] loadModeResolvedFiles = Array.Empty<TaskItem>();
@@ -3071,27 +3071,27 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC
                     string cache = rarCacheFile;
                     t.StateFile = cache;
                     File.Delete(t.StateFile);
-	                succeeded =
-	                    t.Execute
-	                    (
-	                        fileExists,
-	                        directoryExists,
-	                        getDirectories,
-	                        getAssemblyName,
-	                        getAssemblyMetadata,
-	#if FEATURE_WIN32_REGISTRY
-	                        getRegistrySubKeyNames,
-	                        getRegistrySubKeyDefaultValue,
-	#endif
-	                        getLastWriteTime,
-	                        getRuntimeVersion,
-	#if FEATURE_WIN32_REGISTRY
-	                        openBaseKey,
-	#endif
-	                        checkIfAssemblyIsInGac,
-	                        isWinMDFile,
-	                        readMachineTypeFromPEHeader
-	                    );
+                    succeeded =
+                        t.Execute
+                        (
+                            fileExists,
+                            directoryExists,
+                            getDirectories,
+                            getAssemblyName,
+                            getAssemblyMetadata,
+#if FEATURE_WIN32_REGISTRY
+                            getRegistrySubKeyNames,
+                            getRegistrySubKeyDefaultValue,
+#endif
+                            getLastWriteTime,
+                            getRuntimeVersion,
+#if FEATURE_WIN32_REGISTRY
+                            openBaseKey,
+#endif
+                            checkIfAssemblyIsInGac,
+                            isWinMDFile,
+                            readMachineTypeFromPEHeader
+                        );
                     if (FileUtilities.FileExistsNoThrow(t.StateFile))
                     {
                         Assert.Single(t.FilesWritten);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
index 795086814d8..048a93ecf12 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
@@ -24,9 +24,9 @@ public StronglyNamedDependency(ITestOutputHelper output) : base(output)
         /// </summary>
         /// <value></value>
         internal new string[] DefaultPaths
-            {
-                get { return new string[] { s_myApp_V10Path, @"C:\Framework\Whidbey", @"C:\Framework\Everett" }; }
-            }
+        {
+            get { return new string[] { s_myApp_V10Path, @"C:\Framework\Whidbey", @"C:\Framework\Everett" }; }
+        }
 
         /// <summary>
         /// In this case,
@@ -41,7 +41,7 @@ public StronglyNamedDependency(ITestOutputHelper output) : base(output)
         /// We automatically unify FX dependencies.
         /// </summary>
         [Fact]
-            [Trait("Category", "mono-osx-failing")]
+        [Trait("Category", "mono-osx-failing")]
         public void Exists()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -116,7 +116,7 @@ public void HighVersionDoesntExist()
 
             t.BuildEngine = engine;
             t.Assemblies = assemblyNames;
-                t.SearchPaths = new string[] { s_myApp_V10Path, @"C:\Framework\Everett" }; 
+            t.SearchPaths = new string[] { s_myApp_V10Path, @"C:\Framework\Everett" };
 
             bool succeeded = Execute(t);
 
@@ -133,8 +133,8 @@ public void VerifyAssemblyPulledOutOfFrameworkDoesntGetFrameworkFileAttribute()
         {
             MockEngine e = new MockEngine(_output);
 
-                string actualFrameworkDirectory = s_myVersion20Path;
-                string alternativeFrameworkDirectory = s_myVersion40Path;
+            string actualFrameworkDirectory = s_myVersion20Path;
+            string alternativeFrameworkDirectory = s_myVersion40Path;
 
             ITaskItem[] items = new TaskItem[] { new TaskItem(Path.Combine(actualFrameworkDirectory, "System.dll")) };
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
index c02c4e6f629..06b3b54465f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
@@ -23,8 +23,8 @@ public StronglyNamedDependencyAppConfig(ITestOutputHelper output) : base(output)
         /// </summary>
         /// <value></value>
         internal new string[] DefaultPaths
-            {
-                get { return new string[] { s_myApp_V05Path, s_myApp_V10Path, s_myComponentsV05Path, s_myComponentsV10Path, s_myComponentsV20Path, s_myComponentsV30Path }; }
+        {
+            get { return new string[] { s_myApp_V05Path, s_myApp_V10Path, s_myComponentsV05Path, s_myComponentsV10Path, s_myComponentsV20Path, s_myComponentsV30Path }; }
         }
 
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
index 89e1eb347ee..1ea5e767dd3 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
@@ -24,7 +24,7 @@ public StronglyNamedDependencyAutoUnify(ITestOutputHelper output) : base(output)
         /// <value></value>
         internal new string[] DefaultPaths
         {
-                get { return new string[] { s_myApp_V05Path, s_myApp_V10Path, s_myApp_V20Path, s_myApp_V30Path, s_myComponentsV05Path, s_myComponentsV10Path, s_myComponentsV20Path, s_myComponentsV30Path }; }
+            get { return new string[] { s_myApp_V05Path, s_myApp_V10Path, s_myApp_V20Path, s_myApp_V30Path, s_myComponentsV05Path, s_myComponentsV10Path, s_myComponentsV20Path, s_myComponentsV30Path }; }
         }
 
 
@@ -155,7 +155,7 @@ public void ExistsWithPrimaryReferenceOnBlackList()
                 Assert.Contains(Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), t.ResolvedFiles[0].ItemSpec); // "Expected the ItemSpec of the resolved file to be the item spec of the 1.0.0.0 assembly");
                 Assert.Single(t.ResolvedDependencyFiles); // "Expected there to be two resolved dependencies"
                 t.ResolvedDependencyFiles[0].GetMetadata("FusionName").ShouldBe("UnifyMe, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", StringCompareShould.IgnoreCase);
-                    t.ResolvedDependencyFiles[0].ItemSpec.ShouldBe(s_unifyMeDll_V10Path, StringCompareShould.IgnoreCase);
+                t.ResolvedDependencyFiles[0].ItemSpec.ShouldBe(s_unifyMeDll_V10Path, StringCompareShould.IgnoreCase);
 
                 engine.AssertLogDoesntContain
                     (
@@ -318,8 +318,8 @@ public void ExistsWithBothDependentReferenceOnBlackList()
                 Assert.True(succeeded);
                 Assert.Empty(t.ResolvedFiles); // "Expected there to be no resolved files"
 
-                    Assert.False(ContainsItem(t.ResolvedFiles, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"))); // "Expected the ItemSpec of the resolved file to not be the item spec of the 1.0.0.0 assembly");
-                    Assert.False(ContainsItem(t.ResolvedFiles, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"))); // "Expected the ItemSpec of the resolved file to not be the item spec of the 2.0.0.0 assembly"
+                Assert.False(ContainsItem(t.ResolvedFiles, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"))); // "Expected the ItemSpec of the resolved file to not be the item spec of the 1.0.0.0 assembly");
+                Assert.False(ContainsItem(t.ResolvedFiles, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"))); // "Expected the ItemSpec of the resolved file to not be the item spec of the 2.0.0.0 assembly"
 
                 string stringList = ResolveAssemblyReference.GenerateSubSetName(null, new ITaskItem[] { new TaskItem(subsetListPath) });
                 engine.AssertLogContains(t.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", assemblyNames[0].ItemSpec, "UniFYme, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", stringList));
@@ -392,10 +392,10 @@ public void MultipleUnifiedFromNamesMiddlePrimaryOnBlackList()
 
             Assert.True(succeeded);
             Assert.Equal(2, t.ResolvedFiles.Length); // "Expected to find two resolved assemblies"
-                Assert.True(ContainsItem(t.ResolvedFiles, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"))); // "Expected the ItemSpec of the resolved file to be the item spec of the 1.0.0.0 assembly");
-                Assert.True(ContainsItem(t.ResolvedFiles, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"))); // "Expected the ItemSpec of the resolved file to be the item spec of the 2.0.0.0 assembly");
+            Assert.True(ContainsItem(t.ResolvedFiles, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"))); // "Expected the ItemSpec of the resolved file to be the item spec of the 1.0.0.0 assembly");
+            Assert.True(ContainsItem(t.ResolvedFiles, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"))); // "Expected the ItemSpec of the resolved file to be the item spec of the 2.0.0.0 assembly");
             t.ResolvedDependencyFiles[0].GetMetadata("FusionName").ShouldBe("UnifyMe, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", StringCompareShould.IgnoreCase);
-                t.ResolvedDependencyFiles[0].ItemSpec.ShouldBe(s_unifyMeDll_V20Path, StringCompareShould.IgnoreCase);
+            t.ResolvedDependencyFiles[0].ItemSpec.ShouldBe(s_unifyMeDll_V20Path, StringCompareShould.IgnoreCase);
 
             engine.AssertLogContains
                 (
@@ -455,7 +455,7 @@ public void MultipleUnifiedFromNames()
 
             Assert.True(succeeded);
             t.ResolvedDependencyFiles[0].GetMetadata("FusionName").ShouldBe("UnifyMe, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", StringCompareShould.IgnoreCase);
-                t.ResolvedDependencyFiles[0].ItemSpec.ShouldBe(s_unifyMeDll_V30Path, StringCompareShould.IgnoreCase);
+            t.ResolvedDependencyFiles[0].ItemSpec.ShouldBe(s_unifyMeDll_V30Path, StringCompareShould.IgnoreCase);
 
             engine.AssertLogContains
                 (
diff --git a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
index 07fadfaaf21..58dcad69839 100644
--- a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
@@ -49,7 +49,7 @@ public void InvalidItemPath()
             AssignLinkMetadata t = new AssignLinkMetadata
             {
                 BuildEngine = new MockEngine(),
-                Items = new ITaskItem[] {new TaskItem(item)}
+                Items = new ITaskItem[] { new TaskItem(item) }
             };
             bool success = t.Execute();
 
@@ -69,7 +69,7 @@ public void Basic()
             AssignLinkMetadata t = new AssignLinkMetadata
             {
                 BuildEngine = new MockEngine(),
-                Items = new ITaskItem[] {new TaskItem(item)}
+                Items = new ITaskItem[] { new TaskItem(item) }
             };
             bool success = t.Execute();
 
@@ -97,7 +97,7 @@ public void InvalidItemPathWithOtherValidItem()
             AssignLinkMetadata t = new AssignLinkMetadata
             {
                 BuildEngine = new MockEngine(),
-                Items = new ITaskItem[] {new TaskItem(item1), new TaskItem(item2)}
+                Items = new ITaskItem[] { new TaskItem(item1), new TaskItem(item2) }
             };
             bool success = t.Execute();
 
@@ -121,7 +121,7 @@ public void DontOverrideLink()
             AssignLinkMetadata t = new AssignLinkMetadata
             {
                 BuildEngine = new MockEngine(),
-                Items = new ITaskItem[] {new TaskItem(item)}
+                Items = new ITaskItem[] { new TaskItem(item) }
             };
             bool success = t.Execute();
 
@@ -143,7 +143,7 @@ public void OutsideDefiningProjectCone()
             AssignLinkMetadata t = new AssignLinkMetadata
             {
                 BuildEngine = new MockEngine(),
-                Items = new ITaskItem[] {new TaskItem(item)}
+                Items = new ITaskItem[] { new TaskItem(item) }
             };
             bool success = t.Execute();
 
@@ -163,7 +163,7 @@ public void NoDefiningProjectMetadata()
             AssignLinkMetadata t = new AssignLinkMetadata
             {
                 BuildEngine = new MockEngine(),
-                Items = new ITaskItem[] {item}
+                Items = new ITaskItem[] { item }
             };
             bool success = t.Execute();
 
diff --git a/src/Tasks.UnitTests/CallTarget_Tests.cs b/src/Tasks.UnitTests/CallTarget_Tests.cs
index 884160cba26..0e5efb15b10 100644
--- a/src/Tasks.UnitTests/CallTarget_Tests.cs
+++ b/src/Tasks.UnitTests/CallTarget_Tests.cs
@@ -122,7 +122,7 @@ public void FailsWithOnlyTargetErrors()
                   </Target>
                 </Project>");
 
-            logger.ErrorCount.ShouldBe (1);
+            logger.ErrorCount.ShouldBe(1);
         }
 
         /// <summary>
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 0fbb6596700..c9dd002c555 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -54,7 +54,7 @@ public void Basic()
         /// for different codepages.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
-        [Fact (Skip = "https://github.com/dotnet/msbuild/issues/295")]
+        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/295")]
 #else
         [Fact]
 #endif
@@ -102,7 +102,7 @@ public void Regress172107()
         ///
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
-        [Fact (Skip = "https://github.com/dotnet/msbuild/issues/295")]
+        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/295")]
 #else
         [Fact]
 #endif
diff --git a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
index 8387224e404..ddad1ef5f17 100644
--- a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
+++ b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
@@ -164,7 +164,7 @@ public void EmptyError()
                 // don't set text
             };
 
-            
+
 
             bool retval = err.Execute();
 
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index c9db73aeb0d..19935a7cd3c 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -564,7 +564,7 @@ private void RunExec(bool includeNonAnsiInCommand, string expectedEncoding, stri
 
                 if (expectSuccess)
                 {
-                    ((MockEngine) exec.BuildEngine).AssertLogContains("[hello]");
+                    ((MockEngine)exec.BuildEngine).AssertLogContains("[hello]");
                 }
 
                 Assert.Equal(expectedEncoding, exec.StdOutEncoding);
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index 1b7826288e8..cf9bb59e165 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -281,7 +281,7 @@ public void AppConfigFileNotSavedWhenIdentical()
             redirectResults.TargetAppConfigContent.ShouldContain("newVersion=\"40.0.0.0\"");
 
             var oldTimestamp = DateTime.Now.Subtract(TimeSpan.FromDays(30));
-            
+
             File.SetCreationTime(outputAppConfigFile, oldTimestamp);
             File.SetLastWriteTime(outputAppConfigFile, oldTimestamp);
 
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
index 21bab8d68fd..dee7148e85f 100644
--- a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -76,7 +76,7 @@ public void ResolvesViaAnyCPUDefault()
             {
                 BuildEngine = new MockEngine(_output),
                 CurrentProjectPlatform = "x86",
-                PlatformLookupTable = "AnyCPU=x64", 
+                PlatformLookupTable = "AnyCPU=x64",
                 AnnotatedProjects = new TaskItem[] { projectReference }
             };
 
@@ -84,7 +84,7 @@ public void ResolvesViaAnyCPUDefault()
 
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("AnyCPU");
         }
-        
+
         [Fact]
         public void ResolvesViaAnyCPUDefaultWithDefaultPlatformEnabled()
         {
@@ -98,7 +98,7 @@ public void ResolvesViaAnyCPUDefaultWithDefaultPlatformEnabled()
             {
                 BuildEngine = new MockEngine(_output),
                 CurrentProjectPlatform = "x86",
-                PlatformLookupTable = "AnyCPU=x64", 
+                PlatformLookupTable = "AnyCPU=x64",
                 AnnotatedProjects = new TaskItem[] { projectReference }
             };
 
@@ -248,7 +248,7 @@ public void PlatformIsChosenAsDefault(string referencedPlatforms, string referen
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
             task.Log.HasLoggedErrors.ShouldBeFalse();
         }
-        
+
         // When `Platform` is retrieved in "GetTargetFrameworks" and that platform matches what the task has decided the project should be built as
         // through negotiation. build that project _without_ a global property for Platform.
         [Fact]
diff --git a/src/Tasks.UnitTests/Hash_Tests.cs b/src/Tasks.UnitTests/Hash_Tests.cs
index 23a45580e60..fccf1db6b08 100644
--- a/src/Tasks.UnitTests/Hash_Tests.cs
+++ b/src/Tasks.UnitTests/Hash_Tests.cs
@@ -33,7 +33,7 @@ public void HashTaskTest()
         public void HashTaskEmptyInputTest()
         {
             // Hash should be valid for empty item
-            var emptyItemHash = ExecuteHashTask(new ITaskItem[] {new TaskItem("")});
+            var emptyItemHash = ExecuteHashTask(new ITaskItem[] { new TaskItem("") });
             Assert.False(string.IsNullOrWhiteSpace(emptyItemHash));
             Assert.NotEmpty(emptyItemHash);
 
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index d736a367bab..09e3796524f 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -82,21 +82,21 @@ public void DeleteEmptyDirectory_WarnsAndContinues()
 
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
-               List<TaskItem> list = new List<TaskItem>();
+                List<TaskItem> list = new List<TaskItem>();
 
                 for (int i = 0; i < 20; i++)
-               {
+                {
                     list.Add(new TaskItem(""));
-               }
+                }
 
-               RemoveDir t = new RemoveDir();
-               t.Directories = list.ToArray();
-               t.BuildEngine = new MockEngine(_output);
-               t.Execute().ShouldBeTrue();
+                RemoveDir t = new RemoveDir();
+                t.Directories = list.ToArray();
+                t.BuildEngine = new MockEngine(_output);
+                t.Execute().ShouldBeTrue();
 
                 t.RemovedDirectories.Length.ShouldBe(0);
                 ((MockEngine)t.BuildEngine).Warnings.ShouldBe(20);
-               ((MockEngine)t.BuildEngine).AssertLogContains("MSB3232");
+                ((MockEngine)t.BuildEngine).AssertLogContains("MSB3232");
             }
         }
     }
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index b8d0750b845..8ed7527a31c 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -637,7 +637,7 @@ public void TestCheckForConflictingReferences()
             Assert.True(rcr.CheckForConflictingReferences());
             Assert.Equal(3, rcr.allProjectRefs.Count);
 
-            
+
             // duplicate refs should not be treated as conflicts
             ComReferenceInfo referenceInfo = new ComReferenceInfo(tlbRefInfo);
             rcr.allProjectRefs.Add(referenceInfo);
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index b939ba2f185..167ab7577d4 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -76,7 +76,7 @@ public void BasicResX2Resources(bool resourceReadOnly)
                 Assert.Equal(".resources", Path.GetExtension(resourcesFile));
                 resourcesFile = t.FilesWritten[0].ItemSpec;
                 Assert.Equal(".resources", Path.GetExtension(resourcesFile));
-                
+
                 Utilities.AssertStateFileWasWritten(t);
 
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ProcessingFile", resxFile, resourcesFile);
@@ -164,7 +164,7 @@ public void BasicText2Resources()
                 Assert.Equal(".resources", Path.GetExtension(resourcesFile));
                 resourcesFile = t.FilesWritten[0].ItemSpec;
                 Assert.Equal(".resources", Path.GetExtension(resourcesFile));
-                
+
                 Utilities.AssertStateFileWasWritten(t);
 
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ProcessingFile", textFile, resourcesFile);
@@ -237,7 +237,7 @@ public void ResX2ResourcesWithReferences()
 #if FEATURE_RESXREADER_LIVEDESERIALIZATION
         [Fact]
 #else
-        [Fact (Skip = "ResGen.exe not supported on .NET Core MSBuild")]
+        [Fact(Skip = "ResGen.exe not supported on .NET Core MSBuild")]
 #endif
         public void BasicResources2ResX()
         {
@@ -327,7 +327,7 @@ public void ForceOutOfDate()
 
             GenerateResource t = Utilities.CreateTask(_output);
             t.StateFile = new TaskItem(_env.GetTempFile(".cache").Path);
-            t.Sources = new ITaskItem[] {new TaskItem(resxFileInput)};
+            t.Sources = new ITaskItem[] { new TaskItem(resxFileInput) };
 
             Utilities.ExecuteTask(t);
 
@@ -336,13 +336,24 @@ public void ForceOutOfDate()
             Path.GetExtension(resourceOutput).ShouldBe(".resources");
             Path.GetExtension(t.FilesWritten[0].ItemSpec).ShouldBe(".resources");
 
+
+            /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
+            Before:
             Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
             
+            Utilities.AssertStateFileWasWritten(t);
+            After:
+            Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
+
+            Utilities.AssertStateFileWasWritten(t);
+            */
+            Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
+
             Utilities.AssertStateFileWasWritten(t);
 
             GenerateResource t2 = Utilities.CreateTask(_output);
             t2.StateFile = new TaskItem(t.StateFile);
-            t2.Sources = new ITaskItem[] {new TaskItem(resxFileInput)};
+            t2.Sources = new ITaskItem[] { new TaskItem(resxFileInput) };
 
             // Execute the task again when the input (5m ago) is newer than the previous outputs (10m ago)
             File.SetLastWriteTime(resxFileInput, DateTime.Now.Subtract(TimeSpan.FromMinutes(5)));
@@ -459,7 +470,7 @@ public void WritingNonString_WithoutProperyOrSystemResourcesExtensions_FailsUnle
                 usePreserialized,
                 _env,
                 useSystemResourcesExtensions);
- 
+
             try
             {
                 t.Sources = new ITaskItem[] { new TaskItem(resxFile) };
@@ -617,7 +628,7 @@ public void ForceSomeOutOfDate()
 
             GenerateResource createResources = Utilities.CreateTask(_output);
             createResources.StateFile = new TaskItem(cache);
-            createResources.Sources = new ITaskItem[] {new TaskItem(firstResx), new TaskItem(secondResx)};
+            createResources.Sources = new ITaskItem[] { new TaskItem(firstResx), new TaskItem(secondResx) };
 
             _output.WriteLine("Transform both");
             Utilities.ExecuteTask(createResources);
@@ -629,7 +640,7 @@ public void ForceSomeOutOfDate()
             _output.WriteLine("Create a new task to transform them again");
             GenerateResource t2 = Utilities.CreateTask(_output);
             t2.StateFile = new TaskItem(createResources.StateFile.ItemSpec);
-            t2.Sources = new ITaskItem[] {new TaskItem(firstResx), new TaskItem(secondResx)};
+            t2.Sources = new ITaskItem[] { new TaskItem(firstResx), new TaskItem(secondResx) };
 
             System.Threading.Thread.Sleep(200);
             if (!NativeMethodsShared.IsWindows)
@@ -743,7 +754,7 @@ public void NothingOutOfDate()
                 Assert.Equal(t.FilesWritten[0].ItemSpec, resourcesFile1);
                 Assert.Equal(t.OutputResources[1].ItemSpec, resourcesFile2);
                 Assert.Equal(t.FilesWritten[1].ItemSpec, resourcesFile2);
-                
+
                 Utilities.AssertStateFileWasWritten(t);
 
                 // Repeat, and it should do nothing as they are up to date
@@ -762,7 +773,7 @@ public void NothingOutOfDate()
                 Assert.Equal(t2.FilesWritten[0].ItemSpec, resourcesFile1);
                 Assert.Equal(t2.OutputResources[1].ItemSpec, resourcesFile2);
                 Assert.Equal(t2.FilesWritten[1].ItemSpec, resourcesFile2);
-                
+
                 Utilities.AssertStateFileWasWritten(t2);
 
                 Assert.True(time.Equals(File.GetLastWriteTime(t2.OutputResources[0].ItemSpec)));
@@ -1706,8 +1717,19 @@ public void FailedResXReader()
                 File.Delete(resourcesFile2);
                 bool success = t.Execute();
                 // Task should have failed
+
+                /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
+                Before:
                 Assert.False(success);
                 
+                Utilities.AssertStateFileWasWritten(t);
+                After:
+                Assert.False(success);
+
+                Utilities.AssertStateFileWasWritten(t);
+                */
+                Assert.False(success);
+
                 Utilities.AssertStateFileWasWritten(t);
 
                 // Should not have created an output for the invalid resx
@@ -1774,8 +1796,19 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
 
                 bool success = t.Execute();
                 // Task should have failed
+
+                /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
+                Before:
                 Assert.False(success);
                 
+                Utilities.AssertStateFileWasWritten(t);
+                After:
+                Assert.False(success);
+
+                Utilities.AssertStateFileWasWritten(t);
+                */
+                Assert.False(success);
+
                 Utilities.AssertStateFileWasWritten(t);
 
                 // Should not have created an output for the invalid resx
@@ -2185,7 +2218,7 @@ public void FilesWrittenSet()
                 Assert.Equal(t.FilesWritten[i].ItemSpec, t.OutputResources[i].ItemSpec);
                 Assert.True(File.Exists(t.FilesWritten[i].ItemSpec));
             }
-            
+
             Utilities.AssertStateFileWasWritten(t);
 
             // Done, so clean up.
@@ -2245,8 +2278,19 @@ public void OutputFilesPartialInputs()
                 // FilesWritten should contain only the 3 successfully output .resources and the cache
                 Assert.Equal(t.FilesWritten[0].ItemSpec, Path.ChangeExtension(t.Sources[0].ItemSpec, ".resources"));
                 Assert.Equal(t.FilesWritten[1].ItemSpec, Path.ChangeExtension(t.Sources[1].ItemSpec, ".resources"));
+
+                /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
+                Before:
                 Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
                 
+                Utilities.AssertStateFileWasWritten(t);
+                After:
+                Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
+
+                Utilities.AssertStateFileWasWritten(t);
+                */
+                Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
+
                 Utilities.AssertStateFileWasWritten(t);
 
                 // Make sure there was an error on the second resource
@@ -2911,7 +2955,7 @@ public void Regress25163_OutputResourcesContainsInvalidPathCharacters()
                 resourcesFile = Utilities.WriteTestResX(false, null, null);
 
                 t.Sources = new ITaskItem[] { new TaskItem(resourcesFile) };
-                t.OutputResources = new ITaskItem[] { new TaskItem( "||" ) };
+                t.OutputResources = new ITaskItem[] { new TaskItem("||") };
 
                 bool success = t.Execute();
 
@@ -3620,7 +3664,7 @@ public static void AssertLogContainsResource(GenerateResource t, string messageI
         {
             Assert.Contains(
                 String.Format(AssemblyResources.GetString(messageID), replacements),
-                ((MockEngine) t.BuildEngine).Log
+                ((MockEngine)t.BuildEngine).Log
             );
         }
 
@@ -3985,7 +4029,7 @@ public static string WriteTestResX(bool useType, string linkedBitmap, string ext
             {
                 if (string.IsNullOrEmpty(resgenFile))
                 {
-                        resgenFile = GetTempFileName(".resx");
+                    resgenFile = GetTempFileName(".resx");
                 }
 
                 File.WriteAllText(resgenFile, contents);
diff --git a/src/Tasks.UnitTests/SGen_Tests.cs b/src/Tasks.UnitTests/SGen_Tests.cs
index 22c5a5ea821..d8328dfc5ed 100644
--- a/src/Tasks.UnitTests/SGen_Tests.cs
+++ b/src/Tasks.UnitTests/SGen_Tests.cs
@@ -268,12 +268,12 @@ public void TestReferencesCommandLine()
             sgen.ShouldGenerateSerializer = true;
             sgen.UseProxyTypes = false;
             sgen.UseKeep = false;
-            sgen.References = new string[]{ "C:\\SomeFolder\\reference1.dll", "C:\\SomeFolder\\reference2.dll" };
+            sgen.References = new string[] { "C:\\SomeFolder\\reference1.dll", "C:\\SomeFolder\\reference2.dll" };
 
             string commandLine = sgen.CommandLine();
             string targetCommandLine = "/assembly:\"" + sgen.BuildAssemblyPath + Path.DirectorySeparatorChar
                                        + "MyAsm, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" /reference:\"C:\\SomeFolder\\reference1.dll,C:\\SomeFolder\\reference2.dll\"";
-            
+
             Assert.Equal(targetCommandLine, commandLine);
         }
 #endif
diff --git a/src/Tasks.UnitTests/TelemetryTaskTests.cs b/src/Tasks.UnitTests/TelemetryTaskTests.cs
index 49acad1db73..2d0311d6dbe 100644
--- a/src/Tasks.UnitTests/TelemetryTaskTests.cs
+++ b/src/Tasks.UnitTests/TelemetryTaskTests.cs
@@ -92,7 +92,7 @@ public void TelemetryTaskDuplicateEventDataProperty()
             // Should not contain the first value
             //
             Assert.DoesNotContain("EE2493A167D24F00996DE7C8E769EAE6", engine.Log);
-            
+
             // Should contain the second value
             //
             Assert.Contains("4ADE3D2622CA400B8B95A039DF540037", engine.Log);
diff --git a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
index 569f290286d..6243bbc1495 100644
--- a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
+++ b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
@@ -111,7 +111,7 @@ public void UseNewLineSeparatorseInResponseFile()
             };
 
             MyToolTaskExtension t = new MyToolTaskExtension(useNewLineSeparators: true, addResponseFileCommands: addResponseFileCommands);
-            
+
             string[] actual = t.GetResponseFileCommands().Split(MSBuildConstants.EnvironmentNewLine, StringSplitOptions.None);
             string[] expected =
             {
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index c954e8d3415..9f0913519d7 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -171,7 +171,7 @@ public void LogsErrorIfReadOnlyFileCannotBeOverwitten()
 
                 unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain($"D6DFD219DACE48F8B86EFCDF98433333.txt{ (NativeMethodsShared.IsMono ? "\"" : "'") } is denied", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain($"D6DFD219DACE48F8B86EFCDF98433333.txt{(NativeMethodsShared.IsMono ? "\"" : "'")} is denied", () => _mockEngine.Log);
             }
         }
 
@@ -230,14 +230,14 @@ public void CanUnzip_WithIncludeFilter()
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
                 Unzip unzip = new Unzip
-                                  {
-                                      BuildEngine = _mockEngine,
-                                      DestinationFolder = new TaskItem(destination.Path),
-                                      OverwriteReadOnlyFiles = true,
-                                      SkipUnchangedFiles = false,
-                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
-                                      Include = "BE78A17D30144B549D21F71D5C633F7D.txt"
-                                  };
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    Include = "BE78A17D30144B549D21F71D5C633F7D.txt"
+                };
 
                 unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
 
@@ -259,14 +259,14 @@ public void CanUnzip_WithExcludeFilter()
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
                 Unzip unzip = new Unzip
-                                  {
-                                      BuildEngine = _mockEngine,
-                                      DestinationFolder = new TaskItem(destination.Path),
-                                      OverwriteReadOnlyFiles = true,
-                                      SkipUnchangedFiles = false,
-                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
-                                      Exclude = "BE78A17D30144B549D21F71D5C633F7D.txt"
-                                  };
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    Exclude = "BE78A17D30144B549D21F71D5C633F7D.txt"
+                };
 
                 unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
 
@@ -292,15 +292,15 @@ public void CanUnzip_WithIncludeAndExcludeFilter()
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
                 Unzip unzip = new Unzip
-                                  {
-                                      BuildEngine = _mockEngine,
-                                      DestinationFolder = new TaskItem(destination.Path),
-                                      OverwriteReadOnlyFiles = true,
-                                      SkipUnchangedFiles = false,
-                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
-                                      Include = "*.js",
-                                      Exclude = "*.js.map;sub\\*.js"
-                                  };
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    Include = "*.js",
+                    Exclude = "*.js.map;sub\\*.js"
+                };
 
                 unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
 
@@ -325,14 +325,14 @@ public void LogsErrorIfIncludeContainsInvalidPathCharacters()
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
                 Unzip unzip = new Unzip
-                                  {
-                                      BuildEngine = _mockEngine,
-                                      DestinationFolder = new TaskItem(destination.Path),
-                                      OverwriteReadOnlyFiles = true,
-                                      SkipUnchangedFiles = false,
-                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
-                                      Include = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
-                                  };
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    Include = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
+                };
 
                 unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
 
@@ -353,14 +353,14 @@ public void LogsErrorIfIncludeContainsPropertyReferences()
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
                 Unzip unzip = new Unzip
-                                  {
-                                      BuildEngine = _mockEngine,
-                                      DestinationFolder = new TaskItem(destination.Path),
-                                      OverwriteReadOnlyFiles = true,
-                                      SkipUnchangedFiles = false,
-                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
-                                      Include = "$(Include)"
-                                  };
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    Include = "$(Include)"
+                };
 
                 unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
 
@@ -381,14 +381,14 @@ public void LogsErrorIfExcludeContainsInvalidPathCharacters()
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
                 Unzip unzip = new Unzip
-                                  {
-                                      BuildEngine = _mockEngine,
-                                      DestinationFolder = new TaskItem(destination.Path),
-                                      OverwriteReadOnlyFiles = true,
-                                      SkipUnchangedFiles = false,
-                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
-                                      Exclude = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
-                                  };
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    Exclude = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
+                };
 
                 unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
 
@@ -409,14 +409,14 @@ public void LogsErrorIfExcludeContainsPropertyReferences()
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
                 Unzip unzip = new Unzip
-                                  {
-                                      BuildEngine = _mockEngine,
-                                      DestinationFolder = new TaskItem(destination.Path),
-                                      OverwriteReadOnlyFiles = true,
-                                      SkipUnchangedFiles = false,
-                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
-                                      Exclude = "$(Include)"
-                                  };
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    Exclude = "$(Include)"
+                };
 
                 unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
 
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index b1cf9ff948b..35b49a2a38d 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -496,7 +496,7 @@ public void MultilineAttributeCSharp()
         [Trait("Category", "mono-osx-failing")]
         public void MultilineAttributeVB()
         {
-            var lines = new []{ "line 1", "line 2", "line 3" };
+            var lines = new[] { "line 1", "line 2", "line 3" };
             var multilineString = String.Join(Environment.NewLine, lines);
 
             WriteCodeFragment task = new WriteCodeFragment();
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index b3b19bf088f..07507fab720 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -872,7 +872,7 @@ public void XsltPreserveWhitespace()
             // load transformed xsl and assert it is well formatted
             {
                 XslTransformation t = new XslTransformation();
-                
+
                 t.BuildEngine = engine;
                 t.XslInputPath = xslPath;
                 t.XmlInputPaths = xmlPaths;
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 9ff2c53b1a6..6ec4429ad6f 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -309,7 +309,7 @@ protected override string GenerateFullPathToTool()
             {
                 // The bitness of al.exe should match the platform being built
                 // Yoda condition prevents null reference exception if Platform is null.
-                string archToLookFor =  "x86".Equals(Platform, StringComparison.OrdinalIgnoreCase) ? Platform :
+                string archToLookFor = "x86".Equals(Platform, StringComparison.OrdinalIgnoreCase) ? Platform :
                                         "x64".Equals(Platform, StringComparison.OrdinalIgnoreCase) ? ProcessorArchitecture.AMD64 : // x64 maps to AMD64 in GeneratePathToTool
                                         ProcessorArchitecture.CurrentProcessArchitecture;
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index d5611e3c4e0..45694f0cb88 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -120,7 +120,7 @@ private void LazyInitialize()
 
                     bool useCache = Environment.GetEnvironmentVariable("MSBUILDDISABLEASSEMBLYFOLDERSEXCACHE") == null;
                     string key = "6f7de854-47fe-4ae2-9cfe-9b33682abd91" + searchPathElement;
-                    
+
                     if (useCache && _buildEngine != null)
                     {
                         _assemblyFoldersCache = _buildEngine.GetRegisteredTaskObject(key, RegisteredTaskObjectLifetime.Build) as AssemblyFoldersFromConfigCache;
@@ -214,7 +214,7 @@ out bool userRequestedSpecificFile
                                     foundPath = candidatePath;
                                     return true;
                                 }
-                                
+
                                 // Lets see if the processor architecture matches, note this this method will cache the result when it was first called.
                                 AssemblyNameExtension foundAssembly = getAssemblyName(candidatePath);
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 681e34d39e6..767f33ac23a 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -274,10 +274,10 @@ internal static bool IsWinMDFile(
         /// </summary>
         private FrameworkName GetFrameworkName()
         {
-// Disabling use of System.Reflection in case of MONO, because
-// Assembly.GetCustomAttributes* for an attribute which belongs
-// to an assembly that mono cannot find, causes a crash!
-// Instead, opt for using PEReader and friends to get that info
+            // Disabling use of System.Reflection in case of MONO, because
+            // Assembly.GetCustomAttributes* for an attribute which belongs
+            // to an assembly that mono cannot find, causes a crash!
+            // Instead, opt for using PEReader and friends to get that info
 #if !FEATURE_ASSEMBLYLOADCONTEXT && !MONO
             if (!NativeMethodsShared.IsWindows)
             {
@@ -410,13 +410,13 @@ private void CorePopulateMetadata()
                             continue;
                         }
 
-                        var container = metadataReader.GetMemberReference((MemberReferenceHandle) ctorHandle).Parent;
+                        var container = metadataReader.GetMemberReference((MemberReferenceHandle)ctorHandle).Parent;
                         if (container.Kind != HandleKind.TypeReference)
                         {
                             continue;
                         }
 
-                        var name = metadataReader.GetTypeReference((TypeReferenceHandle) container).Name;
+                        var name = metadataReader.GetTypeReference((TypeReferenceHandle)container).Name;
                         if (!string.Equals(metadataReader.GetString(name), "TargetFrameworkAttribute"))
                         {
                             continue;
@@ -482,8 +482,8 @@ private static AssemblyName GetAssemblyName(MetadataReader metadataReader, Assem
         }
 #endif
 
-// Enabling this for MONO, because it's required by GetFrameworkName.
-// More details are in the comment for that method
+        // Enabling this for MONO, because it's required by GetFrameworkName.
+        // More details are in the comment for that method
 #if FEATURE_ASSEMBLYLOADCONTEXT || MONO
         // This method copied from DNX source: https://github.com/aspnet/dnx/blob/e0726f769aead073af2d8cd9db47b89e1745d574/src/Microsoft.Dnx.Tooling/Utils/LockFileUtils.cs#L385
         //  System.Reflection.Metadata 1.1 is expected to have an API that helps with this.
@@ -604,14 +604,14 @@ internal static string GetRuntimeVersion(string path)
                     }
 
                     return hresult == NativeMethodsShared.S_OK ? new string(runtimeVersion, 0, dwLength - 1) : string.Empty;
-                }                
+                }
             }
             else
             {
                 return ManagedRuntimeVersionReader.GetRuntimeVersion(path);
             }
 #else
-                return ManagedRuntimeVersionReader.GetRuntimeVersion(path);
+            return ManagedRuntimeVersionReader.GetRuntimeVersion(path);
 #endif
         }
 
diff --git a/src/Tasks/AssemblyDependency/DirectoryResolver.cs b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
index ccfcde1e11b..f2d9cee0b5b 100644
--- a/src/Tasks/AssemblyDependency/DirectoryResolver.cs
+++ b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
@@ -62,7 +62,7 @@ out bool userRequestedSpecificFile
                 foundPath = resolvedPath;
                 return true;
             }
-            
+
             return false;
         }
     }
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 41007129e72..6bab4cee2da 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -115,7 +115,7 @@ public override bool Execute()
                         writeOutput = false;
                     }
                 }
-                catch(System.Xml.XmlException)
+                catch (System.Xml.XmlException)
                 {
                     writeOutput = true;
                 }
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index 53bead5fd07..f48289a9686 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -188,7 +188,7 @@ internal static string RetrievePathFromFusionName(string strongName)
 
                 ErrorUtilities.VerifyThrow(hr == NativeMethodsShared.S_OK, "CreateAssemblyCache failed, hr {0}", hr);
 
-                var assemblyInfo = new ASSEMBLY_INFO { cbAssemblyInfo = (uint) Marshal.SizeOf<ASSEMBLY_INFO>() };
+                var assemblyInfo = new ASSEMBLY_INFO { cbAssemblyInfo = (uint)Marshal.SizeOf<ASSEMBLY_INFO>() };
 
                 assemblyCache.QueryAssemblyInfo(0, strongName, ref assemblyInfo);
 
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index a9021a09f9f..93321d38d9b 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -421,7 +421,7 @@ internal List<Exception> GetErrors()
         internal void AddRelatedFileExtension(string filenameExtension)
         {
 #if DEBUG
-            Debug.Assert(filenameExtension[0]=='.', "Expected extension to start with '.'");
+            Debug.Assert(filenameExtension[0] == '.', "Expected extension to start with '.'");
 #endif
             _relatedFileExtensions.Add(filenameExtension);
         }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 8408c19de17..322ee5c7cc8 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -2674,7 +2674,7 @@ out ITaskItem[] copyLocalFiles
             serializationAssemblyFiles = serializationAssemblyItems.ToArray();
             scatterFiles = scatterItems.ToArray();
 
-             // Sort for stable outputs. (These came from a dictionary, which has undefined enumeration order.)
+            // Sort for stable outputs. (These came from a dictionary, which has undefined enumeration order.)
             Array.Sort(primaryFiles, TaskItemSpecFilenameComparer.GenericComparer);
 
             // Find the copy-local items.
@@ -2932,7 +2932,7 @@ private bool VerifyArchitectureOfImplementationDll(string dllPath, string winmdF
                         dllArchitecture = SystemProcessorArchitecture.Arm;
                         break;
                     case NativeMethods.IMAGE_FILE_MACHINE_ARM64:
-                        dllArchitecture = (SystemProcessorArchitecture) 6; // There's no entry for ARM64 in SystemProcessorArchitecture, use the next available constant
+                        dllArchitecture = (SystemProcessorArchitecture)6; // There's no entry for ARM64 in SystemProcessorArchitecture, use the next available constant
                         break;
                     case NativeMethods.IMAGE_FILE_MACHINE_I386:
                         dllArchitecture = SystemProcessorArchitecture.X86;
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 76c2088bda6..ac54e1c047a 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2423,7 +2423,7 @@ out autoUnifiedRemappedAssemblyReferences
                     IReadOnlyCollection<DependentAssembly> allRemappedAssemblies = CombineRemappedAssemblies(appConfigRemappedAssemblies, autoUnifiedRemappedAssemblies);
                     List<DependentAssembly> idealAssemblyRemappings = autoUnifiedRemappedAssemblies;
                     List<AssemblyNameReference> idealAssemblyRemappingsIdentities = autoUnifiedRemappedAssemblyReferences;
-                    bool shouldRerunClosure = autoUnifiedRemappedAssemblies?.Count > 0  || excludedReferencesExist;
+                    bool shouldRerunClosure = autoUnifiedRemappedAssemblies?.Count > 0 || excludedReferencesExist;
 
                     if (!AutoUnify || !FindDependencies || shouldRerunClosure)
                     {
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index f7c09a4c3d4..55dd775623c 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -113,7 +113,7 @@ public class AssignCulture : TaskExtension
         #endregion
 
         #region ITask Members
-        
+
         /// <summary>
         /// Execute.
         /// </summary>
@@ -174,8 +174,8 @@ public override bool Execute()
 #if DEBUG
                 catch (Exception e)
                 {
-                    Debug.Assert(false, "Unexpected exception in AssignCulture.Execute. " + 
-                        "Please log a MSBuild bug specifying the steps to reproduce the problem. " + 
+                    Debug.Assert(false, "Unexpected exception in AssignCulture.Execute. " +
+                        "Please log a MSBuild bug specifying the steps to reproduce the problem. " +
                         e);
                     throw;
                 }
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 1f93054af17..e344ef1f172 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -254,7 +254,7 @@ public override bool Execute()
         #endregion
 
         #region Methods
-        
+
         /// <summary>
         /// Given a project reference task item and an XML document containing project configurations, 
         /// find the configuration for that task item.
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index b87ae941577..8cc9dc555c6 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -552,7 +552,7 @@ private void RefreshResources()
                         }
 
                         XmlNode rootNode = resourceDoc.SelectSingleNode("Resources");
-                        XmlAttribute cultureAttribute = (XmlAttribute) rootNode?.Attributes.GetNamedItem("Culture");
+                        XmlAttribute cultureAttribute = (XmlAttribute)rootNode?.Attributes.GetNamedItem("Culture");
                         if (cultureAttribute != null)
                         {
                             XmlNode stringsNode = rootNode.SelectSingleNode("Strings");
@@ -1565,7 +1565,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                         else
                         {
                             string configFileKey = string.Format(CultureInfo.InvariantCulture, "EULA{0}", eulas.Count);
-                            var de = new KeyValuePair<string ,string>(configFileKey, eulaAttribute.Value);
+                            var de = new KeyValuePair<string, string>(configFileKey, eulaAttribute.Value);
                             eulas[key] = de;
                             eulaAttribute.Value = configFileKey;
                         }
@@ -1831,7 +1831,7 @@ private XmlNode GetResourcesNodeForSettings(BuildSettings settings, BuildResults
             CultureInfo ci = Util.GetCultureInfoFromString(settings.Culture);
             CultureInfo fallbackCI = Util.GetCultureInfoFromString(settings.FallbackCulture);
             XmlNode cultureNode;
-            
+
             if (ci != null)
             {
                 // Work through the progression of parent cultures (up until but excluding the invariant culture) -> fallback culture -> parent fallback culture -> default culture -> parent default culture -> any available culture
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index c47cd7f6f9a..87971a3d5d8 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -1048,7 +1048,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> pa
                 TaskResources = AssemblyResources.PrimaryResources,
                 HelpKeywordPrefix = "MSBuild."
             };
-            
+
             log.LogErrorWithCodeFromResources("TaskFactoryNotSupportedFailure", nameof(CodeTaskFactory));
 
             return false;
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index c36685242c8..af3c2600535 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -90,10 +90,10 @@ private async Task<bool> ExecuteAsync()
             }
 
             int retryAttemptCount = 0;
-            
+
             CancellationToken cancellationToken = _cancellationTokenSource.Token;
 
-            while(true)
+            while (true)
             {
                 try
                 {
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 9e6eca86c59..222d68e8311 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -57,7 +57,7 @@ public Exec()
         private string _command;
 
         // '^' before _any_ character escapes that character, don't escape it.
-        private static readonly char[] _charactersToEscape = { '(', ')', '=', ';', '!', ',', '&', ' '};
+        private static readonly char[] _charactersToEscape = { '(', ')', '=', ';', '!', ',', '&', ' ' };
 
         #endregion
 
diff --git a/src/Tasks/GenerateLauncher.cs b/src/Tasks/GenerateLauncher.cs
index 683736168cc..857468e34bf 100644
--- a/src/Tasks/GenerateLauncher.cs
+++ b/src/Tasks/GenerateLauncher.cs
@@ -69,7 +69,7 @@ public override bool Execute()
             // If the EntryPoint specified is apphost.exe or singlefilehost.exe, we need to replace the EntryPoint
             // with the AssemblyName instead since apphost.exe/singlefilehost.exe is an intermediate file for
             // for final published {assemblyname}.exe.
-            if ((entryPointFileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) || 
+            if ((entryPointFileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) ||
                 entryPointFileName.Equals(Constants.SingleFileHostExe, StringComparison.InvariantCultureIgnoreCase)) &&
                 !string.IsNullOrEmpty(AssemblyName))
             {
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index fd9d9387867..c403af81cd9 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -56,7 +56,7 @@ namespace Microsoft.Build.Tasks
     public sealed partial class GenerateResource : TaskExtension
     {
 
-#region Fields
+        #region Fields
 
         // This cache helps us track the linked resource files listed inside of a resx resource file
         private ResGenDependencies _cache;
@@ -164,9 +164,9 @@ public sealed partial class GenerateResource : TaskExtension
         /// </summary>
         private List<ITaskItem> _satelliteInputs;
 
-#endregion  // fields
+        #endregion  // fields
 
-#region Properties
+        #region Properties
 
         /// <summary>
         /// The names of the items to be converted. The extension must be one of the
@@ -536,7 +536,7 @@ public string OutputDirectory
             set;
         }
 
-#endregion // properties
+        #endregion // properties
 
         /// <summary>
         /// Simple public constructor.
@@ -1522,7 +1522,7 @@ private bool ShouldRebuildResgenOutputFile(string sourceFilePath, string outputF
             {
                 resxFileInfo = _cache.GetResXFileInfo(sourceFilePath, UsePreserializedResources);
             }
-            catch (Exception e)  when (!ExceptionHandling.NotExpectedIoOrXmlException(e) || e is MSBuildResXException)
+            catch (Exception e) when (!ExceptionHandling.NotExpectedIoOrXmlException(e) || e is MSBuildResXException)
             {
                 // Return true, so that resource processing will display the error
                 // No point logging a duplicate error here as well
@@ -2192,7 +2192,7 @@ internal sealed class ProcessResourceFiles
         : MarshalByRefObject
 #endif
     {
-#region fields
+        #region fields
         /// <summary>
         /// List of readers used for input.
         /// </summary>
@@ -2357,7 +2357,7 @@ internal bool StronglyTypedResourceSuccessfullyCreated
         /// </summary>
         private bool _useSourcePath = false;
 
-#endregion
+        #endregion
 
         /// <summary>
         /// Process all files.
@@ -2721,7 +2721,7 @@ e is SerializationException ||
                             && GetFormat(inFile) != Format.Assembly
                             // outFileOrDir is a directory when the input file is an assembly
                             && GetFormat(outFileOrDir) != Format.Assembly)
-                            // Never delete an assembly since we don't ever actually write to assemblies.
+                        // Never delete an assembly since we don't ever actually write to assemblies.
                         {
                             RemoveCorruptedFile(outFileOrDir);
                         }
@@ -3976,7 +3976,7 @@ internal int LinePosition
                 get { return column; }
             }
         }
-#endregion // Code from ResGen.EXE
+        #endregion // Code from ResGen.EXE
     }
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index c68f60f13f9..b2a2ed0087d 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -50,7 +50,7 @@ public GetCompatiblePlatform()
 
         public override bool Execute()
         {
-            
+
             AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];
             for (int i = 0; i < AnnotatedProjects.Length; i++)
             {
diff --git a/src/Tasks/Interop.cs b/src/Tasks/Interop.cs
index 86dd1b52dab..24a20021c0a 100644
--- a/src/Tasks/Interop.cs
+++ b/src/Tasks/Interop.cs
@@ -11,29 +11,29 @@
 [ComConversionLoss]
 internal interface IInternetSecurityManager
 {
-	[MethodImpl(MethodImplOptions.InternalCall)]
-	void SetSecuritySite([In] [MarshalAs(UnmanagedType.Interface)] IInternetSecurityMgrSite pSite);
+    [MethodImpl(MethodImplOptions.InternalCall)]
+    void SetSecuritySite([In][MarshalAs(UnmanagedType.Interface)] IInternetSecurityMgrSite pSite);
 
-	[MethodImpl(MethodImplOptions.InternalCall)]
-	void GetSecuritySite([MarshalAs(UnmanagedType.Interface)] out IInternetSecurityMgrSite ppSite);
+    [MethodImpl(MethodImplOptions.InternalCall)]
+    void GetSecuritySite([MarshalAs(UnmanagedType.Interface)] out IInternetSecurityMgrSite ppSite);
 
-	[MethodImpl(MethodImplOptions.InternalCall)]
-	void MapUrlToZone([In] [MarshalAs(UnmanagedType.LPWStr)] string pwszUrl, out int pdwZone, [In] int dwFlags);
+    [MethodImpl(MethodImplOptions.InternalCall)]
+    void MapUrlToZone([In][MarshalAs(UnmanagedType.LPWStr)] string pwszUrl, out int pdwZone, [In] int dwFlags);
 
-	[MethodImpl(MethodImplOptions.InternalCall)]
-	void GetSecurityId([In] [MarshalAs(UnmanagedType.LPWStr)] string pwszUrl, out byte pbSecurityId, [In] [Out] ref int pcbSecurityId, [In] [ComAliasName("UrlMonTypeLib.ULONG_PTR")] int dwReserved);
+    [MethodImpl(MethodImplOptions.InternalCall)]
+    void GetSecurityId([In][MarshalAs(UnmanagedType.LPWStr)] string pwszUrl, out byte pbSecurityId, [In][Out] ref int pcbSecurityId, [In][ComAliasName("UrlMonTypeLib.ULONG_PTR")] int dwReserved);
 
-	[MethodImpl(MethodImplOptions.InternalCall)]
-	void ProcessUrlAction([In] [MarshalAs(UnmanagedType.LPWStr)] string pwszUrl, [In] int dwAction, out byte pPolicy, [In] int cbPolicy, [In] ref byte pContext, [In] int cbContext, [In] int dwFlags, [In] int dwReserved);
+    [MethodImpl(MethodImplOptions.InternalCall)]
+    void ProcessUrlAction([In][MarshalAs(UnmanagedType.LPWStr)] string pwszUrl, [In] int dwAction, out byte pPolicy, [In] int cbPolicy, [In] ref byte pContext, [In] int cbContext, [In] int dwFlags, [In] int dwReserved);
 
-	[MethodImpl(MethodImplOptions.InternalCall)]
-	void QueryCustomPolicy([In] [MarshalAs(UnmanagedType.LPWStr)] string pwszUrl, [In] [ComAliasName("UrlMonTypeLib.GUID")] ref GUID guidKey, [Out] IntPtr ppPolicy, out int pcbPolicy, [In] ref byte pContext, [In] int cbContext, [In] int dwReserved);
+    [MethodImpl(MethodImplOptions.InternalCall)]
+    void QueryCustomPolicy([In][MarshalAs(UnmanagedType.LPWStr)] string pwszUrl, [In][ComAliasName("UrlMonTypeLib.GUID")] ref GUID guidKey, [Out] IntPtr ppPolicy, out int pcbPolicy, [In] ref byte pContext, [In] int cbContext, [In] int dwReserved);
 
-	[MethodImpl(MethodImplOptions.InternalCall)]
-	void SetZoneMapping([In] int dwZone, [In] [MarshalAs(UnmanagedType.LPWStr)] string lpszPattern, [In] int dwFlags);
+    [MethodImpl(MethodImplOptions.InternalCall)]
+    void SetZoneMapping([In] int dwZone, [In][MarshalAs(UnmanagedType.LPWStr)] string lpszPattern, [In] int dwFlags);
 
-	[MethodImpl(MethodImplOptions.InternalCall)]
-	void GetZoneMappings([In] int dwZone, [MarshalAs(UnmanagedType.Interface)] out IEnumString ppenumString, [In] int dwFlags);
+    [MethodImpl(MethodImplOptions.InternalCall)]
+    void GetZoneMappings([In] int dwZone, [MarshalAs(UnmanagedType.Interface)] out IEnumString ppenumString, [In] int dwFlags);
 }
 
 // UrlMonTypeLib.IInternetSecurityMgrSite
@@ -44,7 +44,7 @@ internal interface IInternetSecurityManager
 internal interface IInternetSecurityMgrSite
 {
     [MethodImpl(MethodImplOptions.InternalCall)]
-    void GetWindow([Out] [ComAliasName("UrlMonTypeLib.wireHWND")] IntPtr phwnd);
+    void GetWindow([Out][ComAliasName("UrlMonTypeLib.wireHWND")] IntPtr phwnd);
 
     [MethodImpl(MethodImplOptions.InternalCall)]
     void EnableModeless([In] int fEnable);
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index ab30921344b..01fd05ceb8f 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -439,7 +439,7 @@ private void ValidateCom()
             {
                 if (assembly.ReferenceType == AssemblyReferenceType.NativeAssembly && !assembly.IsPrerequisite && !String.IsNullOrEmpty(assembly.ResolvedPath))
                 {
-                    ComInfo[] comInfoArray = ManifestReader.GetComInfo(assembly.ResolvedPath); 
+                    ComInfo[] comInfoArray = ManifestReader.GetComInfo(assembly.ResolvedPath);
                     if (comInfoArray != null)
                     {
                         foreach (ComInfo comInfo in comInfoArray)
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 54c02703f4f..623458d1f58 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -586,7 +586,7 @@ private static CspParameters CopyCspParameters(ICspAsymmetricAlgorithm cspAlgori
             return cspParameters;
         }
 
-        private static Type GetSystemCoreType(string namespaceQualifiedTypeName, bool throwOnError=true)
+        private static Type GetSystemCoreType(string namespaceQualifiedTypeName, bool throwOnError = true)
         {
 #if CNG_LIGHTUP_NO_SYSTEM_CORE
             string assemblyQualifiedTypeName = namespaceQualifiedTypeName + ", " + AssemblyRef.SystemCore;
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 6daa303b780..fb33dda7868 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -170,18 +170,18 @@ private ClassInfo GetRegisteredClassInfo(Guid clsid)
 
             using (RegistryKey userKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\CLASSES\\CLSID"))
             {
-               if (GetRegisteredClassInfo(userKey, clsid, ref info))
-               {
-                   return info;
-               }
+                if (GetRegisteredClassInfo(userKey, clsid, ref info))
+                {
+                    return info;
+                }
             }
 
             using (RegistryKey machineKey = Registry.ClassesRoot.OpenSubKey("CLSID"))
             {
-               if (GetRegisteredClassInfo(machineKey, clsid, ref info))
-               {
-                  return info;
-               }
+                if (GetRegisteredClassInfo(machineKey, clsid, ref info))
+                {
+                    return info;
+                }
             }
 
             // Check Wow6432Node of HKCR incase the COM reference is to a 32-bit binary.
diff --git a/src/Tasks/ManifestUtil/FileReference.cs b/src/Tasks/ManifestUtil/FileReference.cs
index e13dad0af4f..fc248817e8a 100644
--- a/src/Tasks/ManifestUtil/FileReference.cs
+++ b/src/Tasks/ManifestUtil/FileReference.cs
@@ -105,7 +105,7 @@ public bool IsDataFile
         [XmlIgnore]
         public TypeLib[] TypeLibs => _typeLibs;
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -143,7 +143,7 @@ public string XmlWriteableType
             set => _writeableType = value;
         }
 
-#endregion
+        #endregion
     }
 
     [ComVisible(false)]
@@ -183,7 +183,7 @@ internal ComClass(Guid tlbId, Guid clsId, string progId, string threadingModel,
         [XmlIgnore]
         public string TlbId => _tlbid;
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -230,7 +230,7 @@ public string XmlTlbId
             set => _tlbid = value;
         }
 
-#endregion
+        #endregion
     }
 
     [ComVisible(false)]
@@ -295,7 +295,7 @@ private static string FlagsFromInt(int flags)
         [XmlIgnore]
         public string Version => _version;
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -342,7 +342,7 @@ public string XmlVersion
             set => _version = value;
         }
 
-#endregion
+        #endregion
     }
 
     [ComVisible(false)]
@@ -382,7 +382,7 @@ public bool Versioned
             }
         }
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -402,7 +402,7 @@ public string XmlVersioned
             set => _versioned = value;
         }
 
-#endregion
+        #endregion
     }
 
     [ComVisible(false)]
@@ -429,7 +429,7 @@ public class ProxyStub
         [XmlIgnore]
         public string TlbId => _tlbid;
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -476,6 +476,6 @@ public string XmlTlbId
             set => _tlbid = value;
         }
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index 862fdb621ab..eb355866321 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -45,7 +45,7 @@ private MetadataReader(string path)
                     }
                 }
             }
-            catch(Exception)
+            catch (Exception)
             {
                 Close();
             }
@@ -173,7 +173,7 @@ private string GetPublicKeyToken()
                 an.SetPublicKey(pk);
                 byte[] pkt = an.GetPublicKeyToken();
 
-                publicKeyToken = BitConverter.ToString(pkt).Replace("-","");
+                publicKeyToken = BitConverter.ToString(pkt).Replace("-", "");
             }
 
             if (!String.IsNullOrEmpty(publicKeyToken))
@@ -408,7 +408,7 @@ private interface IMetaDataDispenser
         {
             int DefineScope();
             [PreserveSig]
-            int OpenScope([In][MarshalAs(UnmanagedType.LPWStr)]  string szScope, [In] UInt32 dwOpenFlags, [In] ref Guid riid, [Out][MarshalAs(UnmanagedType.Interface)] out object obj);
+            int OpenScope([In][MarshalAs(UnmanagedType.LPWStr)] string szScope, [In] UInt32 dwOpenFlags, [In] ref Guid riid, [Out][MarshalAs(UnmanagedType.Interface)] out object obj);
             int OpenScopeOnMemory();
         }
     }
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 150b0256d7c..9b33e8db9d6 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -766,7 +766,7 @@ private static void SignPEFile(X509Certificate2 cert, Uri timestampUrl, string p
             {
                 SignPEFileInternal(cert, timestampUrl, path, resources, useSha256, true);
             }
-            catch(ApplicationException) when (timestampUrl != null)
+            catch (ApplicationException) when (timestampUrl != null)
             {
                 // error, retry with signtool /t if timestamp url was given
                 SignPEFileInternal(cert, timestampUrl, path, resources, useSha256, false);
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index 351a7e7546f..1546cb6bc4d 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -193,8 +193,8 @@ private XmlElement GetInputRequestedPrivilegeElement()
 
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(_inputTrustInfoDocument.NameTable);
             XmlElement trustInfoElement = _inputTrustInfoDocument.DocumentElement;
-            XmlElement securityElement = (XmlElement) trustInfoElement?.SelectSingleNode(XPaths.securityElement, nsmgr);
-            XmlElement requestedPrivilegeElement = (XmlElement) securityElement?.SelectSingleNode(XPaths.requestedPrivilegeElement, nsmgr);
+            XmlElement securityElement = (XmlElement)trustInfoElement?.SelectSingleNode(XPaths.securityElement, nsmgr);
+            XmlElement requestedPrivilegeElement = (XmlElement)securityElement?.SelectSingleNode(XPaths.requestedPrivilegeElement, nsmgr);
             return requestedPrivilegeElement;
         }
 
@@ -245,7 +245,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
                 //  here so we can allow the passed-in node to override it if there is a comment present
                 //
                 System.Resources.ResourceManager resources = new System.Resources.ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", typeof(SecurityUtilities).Module.Assembly);
-                commentString = resources.GetString("TrustInfo.RequestedExecutionLevelComment"); 
+                commentString = resources.GetString("TrustInfo.RequestedExecutionLevelComment");
             }
             else
             {
@@ -399,7 +399,7 @@ public bool IsFullTrust
             {
 #if RUNTIME_TYPE_NETCORE
                 // Always use full-trust on .NET Core.
-               return true;
+                return true;
 #else
                 GetInputPermissionSet();
                 return _isFullTrust;
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 0c96f6289ef..85f15e08e1a 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -595,7 +595,7 @@ public static string WriteTempFile(string s)
             return path;
         }
 
-#region ItemComparer 
+        #region ItemComparer 
         private static readonly ItemComparer s_itemComparer = new ItemComparer();
         private class ItemComparer : IComparer
         {
@@ -621,7 +621,7 @@ int IComparer.Compare(object obj1, object obj2)
                 return String.Compare(item1.ItemSpec, item2.ItemSpec, StringComparison.Ordinal);
             }
         }
-#endregion
+        #endregion
 
         public static Version ConvertFrameworkVersionToString(string version)
         {
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 9c904e18ac2..a097d2713cf 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -131,52 +131,52 @@ internal static extern
         [return: MarshalAs(UnmanagedType.Bool)]
         internal static extern
         bool HeapFree(
-            [In]    IntPtr hHeap,
-            [In]    uint dwFlags,
-            [In]    IntPtr lpMem);
+            [In] IntPtr hHeap,
+            [In] uint dwFlags,
+            [In] IntPtr lpMem);
 
         [DllImport(MSCORWKS, CharSet = CharSet.Auto, SetLastError = true)]
         internal static extern
         int CertTimestampAuthenticodeLicense(
-            [In]      ref CRYPT_DATA_BLOB pSignedLicenseBlob,
-            [In]      string pwszTimestampURI,
-            [In, Out]  ref CRYPT_DATA_BLOB pTimestampSignatureBlob);
+            [In] ref CRYPT_DATA_BLOB pSignedLicenseBlob,
+            [In] string pwszTimestampURI,
+            [In, Out] ref CRYPT_DATA_BLOB pTimestampSignatureBlob);
 
         [DllImport(MSCORWKS, CharSet = CharSet.Auto, SetLastError = true)]
         internal static extern
         int CertVerifyAuthenticodeLicense(
-            [In]      ref CRYPT_DATA_BLOB pLicenseBlob,
-            [In]      uint dwFlags,
-            [In, Out]  ref AXL_SIGNER_INFO pSignerInfo,
-            [In, Out]  ref AXL_TIMESTAMPER_INFO pTimestamperInfo);
+            [In] ref CRYPT_DATA_BLOB pLicenseBlob,
+            [In] uint dwFlags,
+            [In, Out] ref AXL_SIGNER_INFO pSignerInfo,
+            [In, Out] ref AXL_TIMESTAMPER_INFO pTimestamperInfo);
 
         [DllImport(MSCORWKS, CharSet = CharSet.Auto, SetLastError = true)]
         internal static extern
         int CertFreeAuthenticodeSignerInfo(
-            [In]      ref AXL_SIGNER_INFO pSignerInfo);
+            [In] ref AXL_SIGNER_INFO pSignerInfo);
 
         [DllImport(MSCORWKS, CharSet = CharSet.Auto, SetLastError = true)]
         internal static extern
         int CertFreeAuthenticodeTimestamperInfo(
-            [In]      ref AXL_TIMESTAMPER_INFO pTimestamperInfo);
+            [In] ref AXL_TIMESTAMPER_INFO pTimestamperInfo);
 
         [DllImport(MSCORWKS, CharSet = CharSet.Auto, SetLastError = true)]
         internal static extern
         int _AxlGetIssuerPublicKeyHash(
-            [In]     IntPtr pCertContext,
+            [In] IntPtr pCertContext,
             [In, Out] ref IntPtr ppwszPublicKeyHash);
 
         [DllImport(MSCORWKS, CharSet = CharSet.Auto, SetLastError = true)]
         internal static extern
         int _AxlRSAKeyValueToPublicKeyToken(
-            [In]     ref CRYPT_DATA_BLOB pModulusBlob,
-            [In]     ref CRYPT_DATA_BLOB pExponentBlob,
+            [In] ref CRYPT_DATA_BLOB pModulusBlob,
+            [In] ref CRYPT_DATA_BLOB pExponentBlob,
             [In, Out] ref IntPtr ppwszPublicKeyToken);
 
         [DllImport(MSCORWKS, CharSet = CharSet.Auto, SetLastError = true)]
         internal static extern
         int _AxlPublicKeyBlobToPublicKeyToken(
-            [In]     ref CRYPT_DATA_BLOB pCspPublicKeyBlob,
+            [In] ref CRYPT_DATA_BLOB pCspPublicKeyBlob,
             [In, Out] ref IntPtr ppwszPublicKeyToken);
 
         // RFC3161 timestamp support
@@ -215,13 +215,13 @@ internal struct CRYPT_TIMESTAMP_PARA
         [return: MarshalAs(UnmanagedType.Bool)]
         internal static extern
         bool CryptRetrieveTimeStamp(
-            [In]     [MarshalAs(UnmanagedType.LPWStr)]  string wszUrl,
-            [In]     uint dwRetrievalFlags,
-            [In]     int dwTimeout,
-            [In]     [MarshalAs(UnmanagedType.LPStr)]   string pszHashId,
+            [In][MarshalAs(UnmanagedType.LPWStr)] string wszUrl,
+            [In] uint dwRetrievalFlags,
+            [In] int dwTimeout,
+            [In][MarshalAs(UnmanagedType.LPStr)] string pszHashId,
             [In, Out] ref CRYPT_TIMESTAMP_PARA pPara,
-            [In]     byte[] pbData,
-            [In]     int cbData,
+            [In] byte[] pbData,
+            [In] int cbData,
             [In, Out] ref IntPtr ppTsContext,
             [In, Out] ref IntPtr ppTsSigner,
             [In, Out] ref IntPtr phStore);
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index f81a61a02e1..763569413f0 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -1124,7 +1124,7 @@ public AssemblyEntry(string name, string version, string publicKeyToken, string
 
         public string FullName { get; }
         public bool InGAC { get; }
-        public bool? IsRedistRoot { get;  }
+        public bool? IsRedistRoot { get; }
         public string RedistName { get; }
         public string SimpleName { get; }
         public string FrameworkDirectory { get; }
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index a7b6a78edf4..bab104d86c4 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -120,7 +120,7 @@ public override bool Execute()
 #if DEBUG
                     catch (Exception e)
                     {
-                        Debug.Assert(false, "Unexpected exception in AssemblyRegistration.Execute. " + 
+                        Debug.Assert(false, "Unexpected exception in AssemblyRegistration.Execute. " +
                             "Please log a MSBuild bug specifying the steps to reproduce the problem. " +
                             e.Message);
                         throw;
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 530982c0f32..edd8b3a487f 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -106,7 +106,8 @@ public override void Translate(ITranslator translator)
         {
             translator.TranslateDictionary(ref resXFiles,
                 (ITranslator translator, ref string s) => translator.Translate(ref s),
-                (ITranslator translator, ref ResXFile resx) => {
+                (ITranslator translator, ref ResXFile resx) =>
+                {
                     ResXFile temp = resx ?? new();
                     temp.Translate(translator);
                     resx = temp;
@@ -114,7 +115,8 @@ public override void Translate(ITranslator translator)
                 count => new Dictionary<string, ResXFile>(count));
             translator.TranslateDictionary(ref portableLibraries,
                 (ITranslator translator, ref string s) => translator.Translate(ref s),
-                (ITranslator translator, ref PortableLibraryFile portableLibrary) => {
+                (ITranslator translator, ref PortableLibraryFile portableLibrary) =>
+                {
                     PortableLibraryFile temp = portableLibrary ?? new();
                     temp.Translate(translator);
                     portableLibrary = temp;
@@ -415,7 +417,7 @@ internal bool Equals(PortableLibraryFile otherLibrary)
                 return true;
             }
         }
-        
+
         /// <summary>
         /// Whether this cache is dirty or not.
         /// </summary>
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index b817ce6243e..7f9f39f71dd 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -141,6 +141,7 @@ internal interface IResolveComReferenceTaskContract
     /// </summary>
     public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExtension, IResolveComReferenceTaskContract
     {
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Properties
 
         public ITaskItem[] TypeLibNames { get; set; }
@@ -196,6 +197,7 @@ public override bool Execute()
         }
 
         #endregion
+#pragma warning restore format 
     }
 
 #else
@@ -205,6 +207,7 @@ public override bool Execute()
     /// </summary>
     public sealed partial class ResolveComReference : AppDomainIsolatedTaskExtension, IResolveComReferenceTaskContract, IComReferenceResolver
     {
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Properties
 
         public ITaskItem[] TypeLibNames { get; set; }
@@ -287,7 +290,7 @@ public string TargetProcessorArchitecture
         public string TargetFrameworkVersion { get; set; } = String.Empty;
 
         private Version _projectTargetFramework;
-        
+
         /// <summary>version 4.0</summary>
         private static readonly Version s_targetFrameworkVersion_40 = new Version("4.0");
 
@@ -1769,6 +1772,7 @@ internal static TYPELIBATTR TaskItemToTypeLibAttr(ITaskItem taskItem)
         }
 
         #endregion
+#pragma warning restore format 
     }
 
 #endif
diff --git a/src/Tasks/ResolveComReferenceCache.cs b/src/Tasks/ResolveComReferenceCache.cs
index 1d6d7f2f006..f00cef38e52 100644
--- a/src/Tasks/ResolveComReferenceCache.cs
+++ b/src/Tasks/ResolveComReferenceCache.cs
@@ -36,7 +36,7 @@ internal sealed class ResolveComReferenceCache : StateFileBase, ITranslatable
         /// indicates whether the cache contents have changed since it's been created
         /// </summary>
         internal bool Dirty => _dirty;
-        
+
         [NonSerialized]
         private bool _dirty;
 
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index 9960105ee1d..27ae495d151 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -27,7 +27,7 @@ public class ResolveKeySource : TaskExtension
 #if !RUNTIME_TYPE_NETCORE
         private const string pfxFileContainerPrefix = "VS_KEY_";
 #endif
-        
+
         #region Properties
 
         public string KeyFile { get; set; }
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 5944fc38e04..5769368bc52 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -127,7 +127,7 @@ public ITaskItem[] SatelliteAssemblies
 
         public string AssemblyName { get; set; }
 
-        public bool LauncherBasedDeployment {get; set; } = false;
+        public bool LauncherBasedDeployment { get; set; } = false;
 
         public string TargetFrameworkVersion
         {
@@ -853,7 +853,7 @@ public void Add(ITaskItem item)
                     }
                     else
                     {
-                       fusionName = Path.GetFileNameWithoutExtension(item.ItemSpec);
+                        fusionName = Path.GetFileNameWithoutExtension(item.ItemSpec);
                     }
                 }
 
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index a765f4a4d7a..ad3b93d17fd 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -140,10 +140,10 @@ public override bool Execute()
                     try
                     {
 #endif
-                    if (!ExtractFromManifest(NativeReferences[reference], path, containingReferenceFilesTable, containedPrerequisiteAssembliesTable, containedComComponentsTable, containedTypeLibrariesTable, containedLooseTlbFilesTable, containedLooseEtcFilesTable))
-                    {
-                        retValue = false;
-                    }
+                        if (!ExtractFromManifest(NativeReferences[reference], path, containingReferenceFilesTable, containedPrerequisiteAssembliesTable, containedComComponentsTable, containedTypeLibrariesTable, containedLooseTlbFilesTable, containedLooseEtcFilesTable))
+                        {
+                            retValue = false;
+                        }
 #if DEBUG
                     }
                     catch (Exception)
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 9a8d761b86c..dccf1790996 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -52,7 +52,7 @@ public static IReadOnlyList<IResource> ReadResources(Stream s, string filename,
             }
         }
 
-        private static void ParseAssemblyAlias(Dictionary<string,string> aliases, XElement elem)
+        private static void ParseAssemblyAlias(Dictionary<string, string> aliases, XElement elem)
         {
             string alias = elem.Attribute("alias")?.Value;
             string name = elem.Attribute("name").Value;
@@ -101,7 +101,7 @@ private static string GetFullTypeNameFromAlias(string aliasedTypeName, Dictionar
             return aliasedTypeName;
         }
 
-        private static void ParseData(string resxFilename, bool pathsRelativeToBasePath, List<IResource> resources, Dictionary<string,string> aliases, XElement elem)
+        private static void ParseData(string resxFilename, bool pathsRelativeToBasePath, List<IResource> resources, Dictionary<string, string> aliases, XElement elem)
         {
             string name = elem.Attribute("name").Value;
             string value;
diff --git a/src/Tasks/SGen.cs b/src/Tasks/SGen.cs
index 3e540d14394..3b3e015408e 100644
--- a/src/Tasks/SGen.cs
+++ b/src/Tasks/SGen.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal interface ISGenTaskContract
     {
-    #region Properties
+        #region Properties
 
         // Input files
         [Required]
@@ -64,13 +64,14 @@ internal interface ISGenTaskContract
         /// </summary>
         string[] Types { get; set; }
 
-    #endregion
+        #endregion
     }
 
 #if RUNTIME_TYPE_NETCORE
     public class SGen : ToolTaskExtension, ISGenTaskContract
     {
-    #region Properties
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
+        #region Properties
 
         [Required]
         public string BuildAssemblyName { get; set; }
@@ -105,9 +106,9 @@ public class SGen : ToolTaskExtension, ISGenTaskContract
 
         public string[] Types { get; set; }
 
-    #endregion
+        #endregion
 
-    #region Tool Members
+        #region Tool Members
 
         protected override string ToolName
         {
@@ -130,7 +131,8 @@ public override bool Execute()
             return false;
         }
 
-    #endregion
+        #endregion
+#pragma warning restore format
     }
 #else
     /// <summary>
@@ -139,6 +141,7 @@ public override bool Execute()
     public class SGen : ToolTaskExtension, ISGenTaskContract
     {
         private string _buildAssemblyPath;
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Properties
 
         // Input files
@@ -453,6 +456,7 @@ protected override string GenerateCommandLineCommands()
         }
 
         #endregion
+#pragma warning restore format
     }
 #endif
 }
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index 79e6ce9defe..0d3b4ed295d 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -60,9 +60,9 @@ internal static string GeneratePathToTool(FileExists fileExists, string currentA
                     {
                         // There may not be an arm directory so we will fall back to the x86 tool location
                         // but if there is then we should try and use it.
-                        ProcessorArchitecture.ARM   => Path.Combine(sdkToolsPath, "arm"),
+                        ProcessorArchitecture.ARM => Path.Combine(sdkToolsPath, "arm"),
                         ProcessorArchitecture.AMD64 => Path.Combine(sdkToolsPath, "x64"),
-                        ProcessorArchitecture.IA64  => Path.Combine(sdkToolsPath, "ia64"),
+                        ProcessorArchitecture.IA64 => Path.Combine(sdkToolsPath, "ia64"),
                         _ => sdkToolsPath,
                     };
                     pathToTool = Path.Combine(processorSpecificToolDirectory, toolName);
diff --git a/src/Tasks/SetRidAgnosticValueForProjects.cs b/src/Tasks/SetRidAgnosticValueForProjects.cs
index 689a4eb9711..f4ed5939025 100644
--- a/src/Tasks/SetRidAgnosticValueForProjects.cs
+++ b/src/Tasks/SetRidAgnosticValueForProjects.cs
@@ -51,7 +51,7 @@ public override bool Execute()
                     }
 
                     updatedItem.SetMetadata("IsRidAgnostic", isRidAgnosticArray[targetFrameworkIndex]);
-                    
+
                     return updatedItem;
                 })
                 .ToArray();
diff --git a/src/Tasks/SignFile.cs b/src/Tasks/SignFile.cs
index 379fe059587..448cfd706bf 100644
--- a/src/Tasks/SignFile.cs
+++ b/src/Tasks/SignFile.cs
@@ -53,8 +53,8 @@ public override bool Execute()
                 SecurityUtilities.SignFile(
                     CertificateThumbprint,
                     TimestampUrl == null ? null : new Uri(TimestampUrl),
-                    SigningTarget.ItemSpec, 
-                    TargetFrameworkVersion, 
+                    SigningTarget.ItemSpec,
+                    TargetFrameworkVersion,
                     TargetFrameworkIdentifier,
                     DisallowMansignTimestampFallback);
                 return true;
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 4d8d2de3422..42b06321054 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -99,7 +99,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                                 retVal = constructor.Invoke(new object[] { translator }) as StateFileBase;
                             }
                         }
-                        
+
                         if (retVal == null || !requiredReturnType.IsInstanceOfType(retVal))
                         {
                             log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile,
diff --git a/src/Tasks/System.Design.cs b/src/Tasks/System.Design.cs
index ba42df9c7e5..9e245d40e12 100644
--- a/src/Tasks/System.Design.cs
+++ b/src/Tasks/System.Design.cs
@@ -99,7 +99,7 @@ public MainAssemblyFallbackResourceManager(string baseName, Assembly assembly) :
 
         internal SR()
         {
-            _resources = new MainAssemblyFallbackResourceManager("System.Design", this.GetType().Assembly);            
+            _resources = new MainAssemblyFallbackResourceManager("System.Design", this.GetType().Assembly);
         }
 
         private static SR GetLoader()
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index ef519c76b0f..077ef0a8d00 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -363,7 +363,7 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             DateTime lastModified = GetAndCacheLastModified(path);
             bool isCachedInInstance = instanceLocalFileStateCache.TryGetValue(path, out FileState cachedInstanceFileState);
             bool isCachedInProcess = s_processWideFileStateCache.TryGetValue(path, out FileState cachedProcessFileState);
-            
+
             bool isInstanceFileStateUpToDate = isCachedInInstance && lastModified == cachedInstanceFileState.LastModified;
             bool isProcessFileStateUpToDate = isCachedInProcess && lastModified == cachedProcessFileState.LastModified;
 
@@ -440,7 +440,7 @@ private AssemblyNameExtension GetAssemblyName(string path)
                     }
                 }
             }
-            
+
             // Not a well-known FX assembly so now check the cache.
             FileState fileState = GetFileState(path);
             if (fileState.Assembly == null)
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 88e0ed11611..3f01e74987d 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -118,7 +118,7 @@ public override bool Execute()
 #if DEBUG
                     catch (Exception e)
                     {
-                        Debug.Assert(false, "Unexpected exception in AssemblyRegistration.Execute. " + 
+                        Debug.Assert(false, "Unexpected exception in AssemblyRegistration.Execute. " +
                             "Please log a MSBuild bug specifying the steps to reproduce the problem. " +
                             e.Message);
                         throw;
@@ -267,7 +267,7 @@ private bool Unregister(string assemblyPath, string typeLibPath)
                     else
                     {
 #if DEBUG
-                        Debug.Assert(false, "Unexpected exception in UnregisterAssembly.DoExecute. " + 
+                        Debug.Assert(false, "Unexpected exception in UnregisterAssembly.DoExecute. " +
                             "Please log a MSBuild bug specifying the steps to reproduce the problem.");
 #endif
                         throw;
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index a781f20b2c3..4f43cd7f928 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -319,7 +319,8 @@ private IReadOnlyDictionary<string, ParameterType> ExtractParameterTypes(IDictio
                         keysToRemove.Add(key);
 
                         // The parameter will have an explicit type. The metadata value is the type name.
-                        parameterTypes[parameterNameKey] = new ParameterType {
+                        parameterTypes[parameterNameKey] = new ParameterType
+                        {
                             Kind = ParameterTypeKind.Typed,
                             TypeName = value
                         };
@@ -351,7 +352,8 @@ private IReadOnlyDictionary<string, ParameterType> ExtractParameterTypes(IDictio
                         // that needs to be written to the generated file for that parameter.
                         if (string.Equals(value, "true", StringComparison.OrdinalIgnoreCase))
                         {
-                            parameterTypes[parameterNameKey] = new ParameterType {
+                            parameterTypes[parameterNameKey] = new ParameterType
+                            {
                                 Kind = ParameterTypeKind.Literal
                             };
                         }
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index eec457b6a96..1ed499cc61b 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -245,7 +245,7 @@ public TaskPropertyInfo[] GetTaskParameters()
     public sealed class XamlTaskFactory : ITaskFactory
     {
         public string FactoryName => "XamlTaskFactory";
-    
+
         public Type TaskType { get; } = null;
 
         public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost)
@@ -255,7 +255,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> pa
                 TaskResources = AssemblyResources.PrimaryResources,
                 HelpKeywordPrefix = "MSBuild."
             };
-            
+
             log.LogErrorWithCodeFromResources("TaskFactoryNotSupportedFailure", nameof(XamlTaskFactory));
 
             return false;
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index ffa2a30100c..4a79a164dbf 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -435,7 +435,7 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
 
             // Mark the Culture property as advanced
             culture.CustomAttributes.Add(editorBrowsableAdvancedAttribute);
-            
+
             /*
               // Here's what I'm trying to emit.  Since not all languages support
               // try/finally, we'll avoid our double lock pattern here.
diff --git a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
index a9b45f36e8b..74c5ac7e403 100644
--- a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
+++ b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
@@ -450,7 +450,7 @@ public void UseNewLineSeparators()
 
 
             string[] actual = c.ToString().Split(MSBuildConstants.EnvironmentNewLine, StringSplitOptions.None);
-            string[] expected = 
+            string[] expected =
             {
                 "/foo:bar",
                 "18056896847C4FFC9706F1D585C077B4",
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index f182975a6ac..e98a8129c0e 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -32,7 +32,7 @@ public void ConstructWithITaskItem()
             TaskItem to = new TaskItem((ITaskItem)from);
             to.ItemSpec.ShouldBe("Monkey.txt");
             ((string)to).ShouldBe("Monkey.txt");
-            
+
             to.GetMetadata("Dog").ShouldBe("Bingo");
             to.GetMetadata("Cat").ShouldBe("Morris");
 
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index ad43b36401b..f9e320a8af0 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -934,7 +934,7 @@ public void TestGetDotNetFrameworkSdkInstallKeyValue()
 #if FEATURE_REGISTRY_SDKS
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/995")]
 #else
-        [Fact (Skip="Registry SDKs not supported")]
+        [Fact(Skip = "Registry SDKs not supported")]
 #endif
         [PlatformSpecific(TestPlatforms.Windows)]
         public void GetPathToDotNetFrameworkSdk()
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index 14cd1e7820f..722314a5afa 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -903,7 +903,7 @@ public void FileTrackerFileIsExcludedFromDependencies()
                                       ? tempPath
                                       : FileUtilities.EnsureTrailingSlash(
                                           NativeMethodsShared.GetLongFilePath(tempPath).ToUpperInvariant());
-            
+
             // We don't want to be including these as dependencies or outputs:
             // 1. Files under %USERPROFILE%\Application Data in XP and %USERPROFILE%\AppData\Roaming in Vista and later.
             // 2. Files under %USERPROFILE%\Local Settings\Application Data in XP and %USERPROFILE%\AppData\Local in Vista and later.
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index dc79f6c8cc1..ea5ef8f34bf 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -412,7 +412,7 @@ public void InvalidReadTLogName()
 
             d.ComputeSourcesNeedingCompilation();
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have an error."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have an error."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -440,7 +440,7 @@ public void ReadTLogWithInitialEmptyLine()
                     false /* shred composite rooting markers */
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -468,7 +468,7 @@ public void ReadTLogWithEmptyLineImmediatelyAfterRoot()
                     false /* shred composite rooting markers */
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -496,7 +496,7 @@ public void ReadTLogWithEmptyLineBetweenRoots()
                     false /* shred composite rooting markers */
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -524,7 +524,7 @@ public void ReadTLogWithEmptyRoot()
                     false /* shred composite rooting markers */
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -570,7 +570,7 @@ public void InvalidWriteTLogName()
                     DependencyTestHelper.ItemArray(new TaskItem("TestFiles\\|one|.write.tlog"))
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have an error."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have an error."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -589,7 +589,7 @@ public void WriteTLogWithInitialEmptyLine()
                     DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog")))
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -608,7 +608,7 @@ public void WriteTLogWithEmptyLineImmediatelyAfterRoot()
                     DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog")))
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -627,7 +627,7 @@ public void WriteTLogWithEmptyLineBetweenRoots()
                     DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog")))
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -646,7 +646,7 @@ public void WriteTLogWithEmptyRoot()
                     DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog")))
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(d.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -3099,7 +3099,7 @@ public void InvalidFlatTrackingTLogName()
                     false /* don't skip missing files */
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(data.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -3118,7 +3118,7 @@ public void FlatTrackingTLogWithInitialEmptyLine()
                     false /* don't skip missing files */
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(data.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -3137,7 +3137,7 @@ public void FlatTrackingTLogWithEmptyLineImmediatelyAfterRoot()
                     false /* don't skip missing files */
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(data.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -3156,7 +3156,7 @@ public void FlatTrackingTLogWithEmptyLineBetweenRoots()
                     false /* don't skip missing files */
                 );
 
-            Assert.Equal(1, ((MockEngine) task.BuildEngine).Warnings); // "Should have a warning."
+            Assert.Equal(1, ((MockEngine)task.BuildEngine).Warnings); // "Should have a warning."
             Assert.Empty(data.DependencyTable); // "DependencyTable should be empty."
         }
 
@@ -3175,7 +3175,7 @@ public void FlatTrackingTLogWithEmptyRoot()
                     false /* don't skip missing files */
                 );
 
-            Assert.Equal(0, ((MockEngine) task.BuildEngine).Warnings); // "Should not warn -- root markers are ignored by default"
+            Assert.Equal(0, ((MockEngine)task.BuildEngine).Warnings); // "Should not warn -- root markers are ignored by default"
             Assert.Single(data.DependencyTable); // "DependencyTable should only contain one entry."
         }
 
@@ -3680,7 +3680,7 @@ public static ITaskItem[] ItemArray(ITaskItem item)
             return itemList.ToArray();
         }
 
-        public static MockTask MockTask => new MockTask(AssemblyResources.PrimaryResources) {BuildEngine = new MockEngine()};
+        public static MockTask MockTask => new MockTask(AssemblyResources.PrimaryResources) { BuildEngine = new MockEngine() };
 
         public static void WriteAll(string filename, string content) => File.WriteAllText(filename, content);
     }
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 2d20b9f110b..4b3d0eb2804 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -1473,7 +1473,7 @@ public static string GetFoldersInVSInstallsAsString(string minVersionString = nu
                     foldersString = string.Join(";", folders);
                 }
             }
-            catch(Exception e) when (!ExceptionHandling.IsCriticalException(e))
+            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
                 // This method will be used in vc props and we don't want to fail project load if it throws for some non critical reason.
             }
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 46495392855..a4a22eacb2d 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -23,6 +23,7 @@ namespace Microsoft.Build.Utilities
     /// </summary>
     public class CanonicalTrackedInputFiles
     {
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Member Data
         // The most recently modified output time
         private DateTime _outputNewestTime = DateTime.MinValue;
@@ -1092,7 +1093,8 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
             }
         }
         #endregion
+#pragma warning restore format
     }
 }
-
 #endif
+
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 550f3bc8d35..9307c1fb3df 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -21,6 +21,7 @@ namespace Microsoft.Build.Utilities
     /// </summary>
     public class CanonicalTrackedOutputFiles
     {
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Member Data
         // The .write. tracking log files
         private ITaskItem[] _tlogFiles;
@@ -784,6 +785,7 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
             }
         }
         #endregion
+#pragma warning restore format
     }
 }
 
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index d87e3ea9507..1c73cccd787 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -29,7 +29,7 @@ internal static class DependencyTableCache
         /// The dictionary that maps the root of the tlog filenames to the dependencytable built from their content
         /// </summary>
         internal static Dictionary<string, DependencyTableCacheEntry> DependencyTable { get; } = new Dictionary<string, DependencyTableCacheEntry>(StringComparer.OrdinalIgnoreCase);
-
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Methods
         /// <summary>
         /// Determine if a cache entry is up to date
@@ -227,6 +227,7 @@ public bool Equals(ITaskItem x, ITaskItem y)
 
         #endregion
     }
+#pragma warning restore format
 
     /// <summary>
     /// A cache entry
@@ -270,3 +271,4 @@ internal DependencyTableCacheEntry(ITaskItem[] tlogFiles, IDictionary dependency
 }
 
 #endif
+
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index bef36c0e7a9..0e823a027ab 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -65,12 +65,13 @@ public enum ExecutableType
         ManagedARM64 = 7
     }
 
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
     /// <summary>
     /// This class contains utility functions to encapsulate launching and logging for the Tracker
     /// </summary>
     public static class FileTracker
     {
-#region Static Member Data
+        #region Static Member Data
 
         // The default path to temp, used to create explicitly short and long paths
         private static readonly string s_tempPath = FileUtilities.TempFileDirectory;
@@ -142,9 +143,9 @@ private static List<string> InitializeCommonApplicationDataPaths()
             return commonApplicationDataPaths;
         }
 
-#endregion
+        #endregion
 
-#region Native method wrappers
+        #region Native method wrappers
 
         /// <summary>
         /// Stops tracking file accesses.  
@@ -209,9 +210,9 @@ public static void StartTrackingContextWithRoot(string intermediateDirectory, st
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLogs", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public static void WriteContextTLogs(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.WriteContextTLogs(intermediateDirectory, taskName);
 
-#endregion // Native method wrappers
+        #endregion // Native method wrappers
 
-#region Methods
+        #region Methods
 
         /// <summary>
         /// Test to see if the specified file is excluded from tracked dependencies
@@ -640,7 +641,7 @@ public static string TrackerArguments(string command, string arguments, string d
         public static string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName)
             => TrackerResponseFileArguments(dllName, intermediateDirectory, rootFiles, cancelEventName) + TrackerCommandArguments(command, arguments);
 
-#region StartProcess methods
+        #region StartProcess methods
 
         /// <summary>
         /// Start the process; tracking the command.  
@@ -707,7 +708,7 @@ public static Process StartProcess(string command, string arguments, ExecutableT
         public static Process StartProcess(string command, string arguments, ExecutableType toolType)
             => StartProcess(command, arguments, toolType, null, null, null, null);
 
-#endregion // StartProcess methods
+        #endregion // StartProcess methods
 
         /// <summary>
         /// Logs a message of the given importance using the specified resource string. To the specified Log.
@@ -757,9 +758,9 @@ internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, stri
             Log?.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
         }
 
-#endregion
+        #endregion
     }
-
+#pragma warning restore format
     /// <summary>
     /// Dependency filter delegate. Used during TLog saves in order for tasks to selectively remove dependencies from the written
     /// graph.
@@ -770,3 +771,4 @@ internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, stri
 }
 
 #endif
+
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 3a3b9d71130..b6fc4afa3c2 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -23,6 +23,7 @@ namespace Microsoft.Build.Utilities
     /// </summary>
     public class FlatTrackingData
     {
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Constants
         // The maximum number of outputs that should be logged, if more than this, then no outputs are logged
         private const int MaxLogCount = 100;
@@ -886,6 +887,7 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
             }
         }
         #endregion
+#pragma warning restore format
     }
 
     /// <summary>
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index ccc53acd3ae..b91028f1a1f 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -17,6 +17,7 @@ namespace Microsoft.Build.Utilities
     /// </summary>
     public static class TrackedDependencies
     {
+#pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Methods
         /// <summary>
         /// Expand wildcards in the item list.
@@ -91,5 +92,6 @@ internal static bool ItemsExist(ITaskItem[] files)
             return allExist;
         }
         #endregion
+#pragma warning restore format
     }
 }
