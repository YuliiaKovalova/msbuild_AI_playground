diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index 6cd24d2c366..34ab714f209 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -2195,7 +2195,7 @@ public void AddProperty_ExistingPropertySameName()
 </Project>");
 
             Helpers.VerifyAssertProjectContent(expected, project);
-            Assert.True(Object.ReferenceEquals(property1, property2));
+            Assert.True(ReferenceEquals(property1, property2));
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs b/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
index 29361bbf569..37330a1bb03 100644
--- a/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
@@ -73,8 +73,8 @@ public void XmlLocationsAreCached()
             ElementLocation e1 = target.Location;
             ElementLocation e2 = target.OutputsLocation;
 
-            Assert.True(Object.ReferenceEquals(e1, target.Location));
-            Assert.True(Object.ReferenceEquals(e2, target.OutputsLocation));
+            Assert.True(ReferenceEquals(e1, target.Location));
+            Assert.True(ReferenceEquals(e2, target.OutputsLocation));
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
index a7dd4f9d1d8..b154c182d23 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
@@ -159,12 +159,12 @@ public void SettingProjectDirties()
 
             try
             {
-                file1 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                file1 = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject1 = ProjectRootElement.Create();
                 importProject1.AddProperty("p", "v1");
                 importProject1.Save(file1);
 
-                file2 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject2 = ProjectRootElement.Create();
                 importProject2.AddProperty("p", "v2");
                 importProject2.Save(file2);
@@ -203,7 +203,7 @@ public void SettingConditionDirties()
 
             try
             {
-                file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                file = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject = ProjectRootElement.Create();
                 importProject.AddProperty("p", "v1");
                 importProject.Save(file);
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 271bbd11e8e..933677761d4 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -177,7 +177,7 @@ public void ConstructOverSameFileReturnsSame()
 
             ProjectRootElement projectXml2 = ProjectRootElement.Open(projectXml1.FullPath);
 
-            Assert.True(object.ReferenceEquals(projectXml1, projectXml2));
+            Assert.True(ReferenceEquals(projectXml1, projectXml2));
         }
 
         /// <summary>
@@ -193,7 +193,7 @@ public void ConstructOverSameFileReturnsSameEvenWithOneBeingRelativePath()
 
             ProjectRootElement projectXml2 = ProjectRootElement.Open(@"xyz\abc");
 
-            Assert.True(object.ReferenceEquals(projectXml1, projectXml2));
+            Assert.True(ReferenceEquals(projectXml1, projectXml2));
         }
 
         /// <summary>
@@ -209,7 +209,7 @@ public void ConstructOverSameFileReturnsSameEvenWithOneBeingRelativePath2()
 
             ProjectRootElement projectXml2 = ProjectRootElement.Open(Path.Combine(Directory.GetCurrentDirectory(), @"xyz\abc"));
 
-            Assert.True(object.ReferenceEquals(projectXml1, projectXml2));
+            Assert.True(ReferenceEquals(projectXml1, projectXml2));
         }
 
         /// <summary>
@@ -228,7 +228,7 @@ public void ConstructOverSameFileReturnsSameEvenWithOneBeingRelativePath3()
 
             ProjectRootElement projectXml2 = ProjectRootElement.Open(Path.Combine(Directory.GetCurrentDirectory(), @"xyz\abc"));
 
-            Assert.True(object.ReferenceEquals(projectXml1, projectXml2));
+            Assert.True(ReferenceEquals(projectXml1, projectXml2));
         }
 
         /// <summary>
@@ -247,7 +247,7 @@ public void ConstructOverSameFileReturnsSameEvenWithOneBeingRelativePath4()
 
             ProjectRootElement projectXml2 = ProjectRootElement.Open(@"xyz\abc");
 
-            Assert.True(object.ReferenceEquals(projectXml1, projectXml2));
+            Assert.True(ReferenceEquals(projectXml1, projectXml2));
         }
 
         /// <summary>
@@ -257,7 +257,7 @@ public void ConstructOverSameFileReturnsSameEvenWithOneBeingRelativePath4()
         public void SetFullPathProjectXmlAlreadyLoaded()
         {
             ProjectRootElement projectXml1 = ProjectRootElement.Create();
-            projectXml1.FullPath = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+            projectXml1.FullPath = FileUtilities.GetTemporaryFile();
 
             ProjectRootElement projectXml2 = ProjectRootElement.Create();
             projectXml2.FullPath = projectXml1.FullPath;
@@ -429,7 +429,7 @@ public void ValidXmlInvalidSyntaxOpenFromDiskTwice()
                 {
                     try
                     {
-                        path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                        path = FileUtilities.GetTemporaryFileName();
                         File.WriteAllText(path, content);
 
                         ProjectRootElement.Open(path);
@@ -913,11 +913,11 @@ public void SolutionCanNotBeOpened()
 
                 try
                 {
-                    tempFileSentinel = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    tempFileSentinel = FileUtilities.GetTemporaryFile();
                     solutionFile = Path.ChangeExtension(tempFileSentinel, ".sln");
                     File.Copy(tempFileSentinel, solutionFile);
 
-                    security = new FileSecurity(solutionFile, System.Security.AccessControl.AccessControlSections.All);
+                    security = new FileSecurity(solutionFile, AccessControlSections.All);
 
                     security.AddAccessRule(rule);
 
@@ -958,9 +958,9 @@ public void ProjectCanNotBeOpened()
                 try
                 {
                     // Does not have .sln or .vcproj extension so loads as project
-                    projectFile = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    projectFile = FileUtilities.GetTemporaryFile();
 
-                    security = new FileSecurity(projectFile, System.Security.AccessControl.AccessControlSections.All);
+                    security = new FileSecurity(projectFile, AccessControlSections.All);
                     security.AddAccessRule(rule);
 
                     File.SetAccessControl(projectFile, security);
@@ -994,7 +994,7 @@ public void SolutionCorrupt()
 
                 try
                 {
-                    solutionFile = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                    solutionFile = FileUtilities.GetTemporaryFileName();
 
                     // Arbitrary corrupt content
                     string content = @"Microsoft Visual Studio Solution File, Format Version 10.00
diff --git a/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs b/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
index 3e85948675a..ab7e1b4937e 100644
--- a/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
@@ -481,7 +481,7 @@ public void AddItem_MatchesWildcard()
 </Project>");
 
             Helpers.VerifyAssertProjectContent(expected, project);
-            Assert.True(object.ReferenceEquals(item1, item2));
+            Assert.True(ReferenceEquals(item1, item2));
         }
 
         /// <summary>
@@ -544,7 +544,7 @@ public void AddItem_MatchesComplicatedWildcard()
 </Project>");
 
             Helpers.VerifyAssertProjectContent(expected, project);
-            Assert.True(object.ReferenceEquals(item1, item2));
+            Assert.True(ReferenceEquals(item1, item2));
         }
 
         /// <summary>
@@ -569,7 +569,7 @@ public void AddItem_DoesntMatchComplicatedWildcard()
 </Project>");
 
             Helpers.VerifyAssertProjectContent(expected, project);
-            Assert.False(object.ReferenceEquals(item1, item2));
+            Assert.False(ReferenceEquals(item1, item2));
         }
 
         /// <summary>
@@ -896,7 +896,7 @@ public void RenameItem_NewNameContainsPropertyExpression()
 
             // The ProjectItemElement should be the same
             ProjectItemElement newItemElement = Helpers.GetFirst((Helpers.GetFirst(project.Xml.ItemGroups)).Items);
-            Assert.True(object.ReferenceEquals(item.Xml, newItemElement));
+            Assert.True(ReferenceEquals(item.Xml, newItemElement));
         }
 
         /// <summary>
@@ -924,7 +924,7 @@ public void RenameItem_NewNameContainsItemExpression()
 
             // The ProjectItemElement should be the same
             ProjectItemElement newItemElement = Helpers.GetLast((Helpers.GetLast(project.Xml.ItemGroups)).Items);
-            Assert.True(object.ReferenceEquals(item.Xml, newItemElement));
+            Assert.True(ReferenceEquals(item.Xml, newItemElement));
         }
 
         /// <summary>
@@ -950,7 +950,7 @@ public void RenameItem_NewNameContainsItemExpressionExpandingToTwoItems()
 
             // The ProjectItemElement should be the same
             ProjectItemElement newItemElement = Helpers.GetLast((Helpers.GetLast(project.Xml.ItemGroups)).Items);
-            Assert.True(object.ReferenceEquals(item.Xml, newItemElement));
+            Assert.True(ReferenceEquals(item.Xml, newItemElement));
         }
 
         /// <summary>
@@ -1187,7 +1187,7 @@ public void ChangeItemType()
 
             ProjectItemGroupElement itemGroupElement = Helpers.GetFirst(project.Xml.ItemGroups);
             Assert.Single(Helpers.MakeList(itemGroupElement.Items));
-            Assert.True(object.ReferenceEquals(itemGroupElement, item.Xml.Parent));
+            Assert.True(ReferenceEquals(itemGroupElement, item.Xml.Parent));
 
             Assert.Single(Helpers.MakeList(project.Items));
             Assert.Single(Helpers.MakeList(project.ItemsIgnoringCondition));
@@ -1195,9 +1195,9 @@ public void ChangeItemType()
             Assert.Empty(Helpers.MakeList(project.GetItems("i")));
             Assert.Empty(Helpers.MakeList(project.GetItemsIgnoringCondition("i")));
 
-            Assert.True(object.ReferenceEquals(item, Helpers.GetFirst(project.GetItems("j"))));
-            Assert.True(object.ReferenceEquals(item, Helpers.GetFirst(project.GetItemsIgnoringCondition("j"))));
-            Assert.True(object.ReferenceEquals(item, Helpers.GetFirst(project.GetItemsByEvaluatedInclude("i1"))));
+            Assert.True(ReferenceEquals(item, Helpers.GetFirst(project.GetItems("j"))));
+            Assert.True(ReferenceEquals(item, Helpers.GetFirst(project.GetItemsIgnoringCondition("j"))));
+            Assert.True(ReferenceEquals(item, Helpers.GetFirst(project.GetItemsByEvaluatedInclude("i1"))));
         }
 
         /// <summary>
@@ -1234,7 +1234,7 @@ public void ChangeItemTypeOnItemWithMetadata()
 
             // Item element identity changed unfortunately, but metadata elements should be the same objects.
             ProjectItemElement itemElement = Helpers.GetFirst(Helpers.GetFirst(project.Xml.ItemGroups).Items);
-            Assert.True(object.ReferenceEquals(itemElement, metadatumElement1.Parent));
+            Assert.True(ReferenceEquals(itemElement, metadatumElement1.Parent));
 
             Assert.Equal(2, Helpers.MakeList(itemElement.Metadata).Count);
 
@@ -1281,8 +1281,8 @@ public void ChangeItemTypeOnItemNeedingSplitting()
 
             ProjectItemGroupElement itemGroupElement = Helpers.GetFirst(project.Xml.ItemGroups);
             Assert.Equal(2, Helpers.MakeList(itemGroupElement.Items).Count);
-            Assert.True(object.ReferenceEquals(itemGroupElement, item.Xml.Parent));
-            Assert.True(object.ReferenceEquals(itemGroupElement, Helpers.GetFirst(project.GetItems("i")).Xml.Parent));
+            Assert.True(ReferenceEquals(itemGroupElement, item.Xml.Parent));
+            Assert.True(ReferenceEquals(itemGroupElement, Helpers.GetFirst(project.GetItems("i")).Xml.Parent));
         }
 
         [Theory]
@@ -1939,7 +1939,7 @@ public void AddMetadata_Existing()
 
             List<ProjectItem> items = Helpers.MakeList(project.Items);
             Assert.Equal("m2", items[0].GetMetadataValue("m"));
-            Assert.True(object.ReferenceEquals(metadatum1, metadatum2));
+            Assert.True(ReferenceEquals(metadatum1, metadatum2));
         }
 
         /// <summary>
@@ -1952,7 +1952,7 @@ public void AddItem_ExpandsToSeveral()
             Project project = new Project();
             IList<ProjectItem> items = project.AddItem("i", "a;b");
 
-            Assert.True(object.ReferenceEquals(items[0].Xml, items[1].Xml));
+            Assert.True(ReferenceEquals(items[0].Xml, items[1].Xml));
             Assert.Equal("a;b", items[0].UnevaluatedInclude);
 
             items = Helpers.MakeList(project.Items);
@@ -2402,7 +2402,7 @@ public void AddItemFast_MatchesWildcard()
 </Project>");
 
             Helpers.VerifyAssertProjectContent(expected, project);
-            Assert.True(object.ReferenceEquals(item1, item2));
+            Assert.True(ReferenceEquals(item1, item2));
         }
 
         /// <summary>
@@ -2461,7 +2461,7 @@ public void AddItemFast_MatchesComplicatedWildcard()
 </Project>");
 
             Helpers.VerifyAssertProjectContent(expected, project);
-            Assert.True(object.ReferenceEquals(item1, item2));
+            Assert.True(ReferenceEquals(item1, item2));
         }
 
         /// <summary>
@@ -2486,7 +2486,7 @@ public void AddItemFast_DoesntMatchComplicatedWildcard()
 </Project>");
 
             Helpers.VerifyAssertProjectContent(expected, project);
-            Assert.False(object.ReferenceEquals(item1, item2));
+            Assert.False(ReferenceEquals(item1, item2));
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index 168cb67c58e..2b49a998bfb 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -1448,7 +1448,7 @@ public void ProjectChangedEvent()
         [Fact]
         public void ProjectCollectionVersionIsCorrect()
         {
-            Version expectedVersion = new Version(this.GetType().GetTypeInfo().Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>().Version);
+            Version expectedVersion = new Version(GetType().GetTypeInfo().Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>().Version);
 
             ProjectCollection.Version.Major.ShouldBe(expectedVersion.Major);
             ProjectCollection.Version.Minor.ShouldBe(expectedVersion.Minor);
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
index 9d795ecaa6f..610b976cff0 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
@@ -122,7 +122,7 @@ public void UpdateMetadataImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = FileUtilities.GetTemporaryFile();
                     ProjectRootElement import = ProjectRootElement.Create(file);
                     import.AddItemDefinitionGroup().AddItemDefinition("i").AddMetadata("m", "m0");
                     import.Save();
@@ -152,7 +152,7 @@ public void SetMetadataImported()
 
             try
             {
-                file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFile();
                 ProjectRootElement import = ProjectRootElement.Create(file);
                 import.AddItemDefinitionGroup().AddItemDefinition("i").AddMetadata("m", "m0");
                 import.Save();
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 490cc3cce47..613b81c973c 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -79,7 +79,7 @@ public void ProjectGetter()
             Project project = new Project();
             ProjectItem item = project.AddItem("i", "i1")[0];
 
-            Assert.True(Object.ReferenceEquals(project, item.Project));
+            Assert.True(ReferenceEquals(project, item.Project));
         }
 
         /// <summary>
@@ -169,8 +169,8 @@ public void GetMetadataObjectsFromDefinition()
             ProjectMetadata idm0 = definition.GetMetadata("m0");
             ProjectMetadata idm1 = definition.GetMetadata("m1");
 
-            Assert.True(Object.ReferenceEquals(m0, idm0));
-            Assert.False(Object.ReferenceEquals(m1, idm1));
+            Assert.True(ReferenceEquals(m0, idm0));
+            Assert.False(ReferenceEquals(m1, idm1));
         }
 
         /// <summary>
@@ -321,7 +321,7 @@ public void BuiltInMetadataTimes()
 
             try
             {
-                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                path = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(path, String.Empty);
                 FileInfo info = new FileInfo(path);
 
@@ -1205,7 +1205,7 @@ public void CopyFromWithItemListExpressionClonesMetadata()
             Assert.Equal("m1", item2.GetMetadataValue("m"));
 
             // Should still point at the same XML items
-            Assert.True(Object.ReferenceEquals(item1.GetMetadata("m").Xml, item2.GetMetadata("m").Xml));
+            Assert.True(ReferenceEquals(item1.GetMetadata("m").Xml, item2.GetMetadata("m").Xml));
         }
 
         /// <summary>
@@ -1403,12 +1403,12 @@ public void CopyWithItemDefinition()
             Assert.Equal("", project.GetItems("m").ElementAt(1).GetMetadataValue("p"));
 
             // Should still point at the same XML metadata
-            Assert.True(Object.ReferenceEquals(project.GetItems("i").First().GetMetadata("l").Xml, project.GetItems("m").First().GetMetadata("l").Xml));
-            Assert.True(Object.ReferenceEquals(project.GetItems("i").First().GetMetadata("m").Xml, project.GetItems("m").First().GetMetadata("m").Xml));
-            Assert.True(Object.ReferenceEquals(project.GetItems("i").First().GetMetadata("n").Xml, project.GetItems("m").First().GetMetadata("n").Xml));
-            Assert.True(Object.ReferenceEquals(project.GetItems("j").First().GetMetadata("o").Xml, project.GetItems("k").First().GetMetadata("o").Xml));
-            Assert.True(Object.ReferenceEquals(project.GetItems("k").First().GetMetadata("p").Xml, project.GetItems("m").First().GetMetadata("p").Xml));
-            Assert.True(!Object.ReferenceEquals(project.GetItems("j").First().GetMetadata("p").Xml, project.GetItems("m").First().GetMetadata("p").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("i").First().GetMetadata("l").Xml, project.GetItems("m").First().GetMetadata("l").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("i").First().GetMetadata("m").Xml, project.GetItems("m").First().GetMetadata("m").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("i").First().GetMetadata("n").Xml, project.GetItems("m").First().GetMetadata("n").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("j").First().GetMetadata("o").Xml, project.GetItems("k").First().GetMetadata("o").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("k").First().GetMetadata("p").Xml, project.GetItems("m").First().GetMetadata("p").Xml));
+            Assert.True(!ReferenceEquals(project.GetItems("j").First().GetMetadata("p").Xml, project.GetItems("m").First().GetMetadata("p").Xml));
         }
 
         /// <summary>
@@ -1501,12 +1501,12 @@ public void CopyWithItemDefinition2()
             Assert.Equal("", project.GetItems("m").ElementAt(1).GetMetadataValue("p"));
 
             // Should still point at the same XML metadata
-            Assert.True(Object.ReferenceEquals(project.GetItems("i").First().GetMetadata("l").Xml, project.GetItems("m").First().GetMetadata("l").Xml));
-            Assert.True(Object.ReferenceEquals(project.GetItems("i").First().GetMetadata("m").Xml, project.GetItems("m").First().GetMetadata("m").Xml));
-            Assert.True(Object.ReferenceEquals(project.GetItems("i").First().GetMetadata("n").Xml, project.GetItems("m").First().GetMetadata("n").Xml));
-            Assert.True(Object.ReferenceEquals(project.GetItems("j").First().GetMetadata("o").Xml, project.GetItems("k").First().GetMetadata("o").Xml));
-            Assert.True(Object.ReferenceEquals(project.GetItems("k").First().GetMetadata("p").Xml, project.GetItems("m").First().GetMetadata("p").Xml));
-            Assert.True(!Object.ReferenceEquals(project.GetItems("j").First().GetMetadata("p").Xml, project.GetItems("m").First().GetMetadata("p").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("i").First().GetMetadata("l").Xml, project.GetItems("m").First().GetMetadata("l").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("i").First().GetMetadata("m").Xml, project.GetItems("m").First().GetMetadata("m").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("i").First().GetMetadata("n").Xml, project.GetItems("m").First().GetMetadata("n").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("j").First().GetMetadata("o").Xml, project.GetItems("k").First().GetMetadata("o").Xml));
+            Assert.True(ReferenceEquals(project.GetItems("k").First().GetMetadata("p").Xml, project.GetItems("m").First().GetMetadata("p").Xml));
+            Assert.True(!ReferenceEquals(project.GetItems("j").First().GetMetadata("p").Xml, project.GetItems("m").First().GetMetadata("p").Xml));
         }
 
         /// <summary>
@@ -2055,7 +2055,7 @@ public void RenameImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                    file = FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.AddItem("i", "i1");
                     import.Save(file);
@@ -2086,7 +2086,7 @@ public void SetMetadataImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                    file = FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.AddItem("i", "i1");
                     import.Save(file);
@@ -2117,7 +2117,7 @@ public void RemoveMetadataImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                    file = FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     ProjectItem item = import.AddItem("i", "i1")[0];
                     item.SetMetadataValue("m", "m0");
diff --git a/src/Build.OM.UnitTests/Definition/ProjectMetadata_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectMetadata_Tests.cs
index c0807e37e68..593007bf01e 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectMetadata_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectMetadata_Tests.cs
@@ -30,7 +30,7 @@ public void ProjectGetter()
             ProjectItem item = project.AddItem("i", "i1")[0];
             ProjectMetadata metadatum = item.SetMetadataValue("m", "m1");
 
-            Assert.True(Object.ReferenceEquals(project, metadatum.Project));
+            Assert.True(ReferenceEquals(project, metadatum.Project));
         }
 
         /// <summary>
@@ -502,13 +502,13 @@ public void SpecialCharactersInMetadataValueConstruction()
         [Fact]
         public void SpecialCharactersInMetadataValueEvaluation()
         {
-            Microsoft.Build.Evaluation.Project project = new Microsoft.Build.Evaluation.Project();
+            Project project = new Project();
             var metadata = new Dictionary<string, string>
             {
                 { "EscapedSemicolon", "%3B" }, // Microsoft.Build.Internal.Utilities.Escape(";")
                 { "EscapedDollarSign", "%24" }, // Microsoft.Build.Internal.Utilities.Escape("$")
             };
-            Microsoft.Build.Evaluation.ProjectItem item = project.AddItem(
+            ProjectItem item = project.AddItem(
                 "None",
                 "MetadataTests",
                 metadata).Single();
@@ -521,7 +521,7 @@ public void SpecialCharactersInMetadataValueEvaluation()
         /// <summary>
         /// Helper for metadata escaping tests
         /// </summary>
-        private void SpecialCharactersInMetadataValueTests(Microsoft.Build.Evaluation.ProjectItem item)
+        private void SpecialCharactersInMetadataValueTests(ProjectItem item)
         {
             Assert.Equal("%3B", item.GetMetadata("EscapedSemicolon").UnevaluatedValue);
             Assert.Equal(";", item.GetMetadata("EscapedSemicolon").EvaluatedValue);
diff --git a/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
index 3ecc456a3cb..827515e58bb 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
@@ -29,7 +29,7 @@ public void ProjectGetter()
             Project project = new Project();
             ProjectProperty property = project.SetProperty("p", "v");
 
-            Assert.True(Object.ReferenceEquals(project, property.Project));
+            Assert.True(ReferenceEquals(project, property.Project));
         }
 
         /// <summary>
@@ -262,7 +262,7 @@ public void SetPropertyImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                    file = FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.SetProperty("p", "v0");
                     import.Save(file);
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 42b01b5496e..ebc0ff95a35 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -609,11 +609,11 @@ public void BasicFromXmlFollowImport()
 
             IList<ResolvedImport> imports = project.Imports;
             imports.ShouldHaveSingleItem();
-            object.ReferenceEquals(imports.First().ImportingElement, xml.Imports.ElementAt(0)).ShouldBeTrue();
+            ReferenceEquals(imports.First().ImportingElement, xml.Imports.ElementAt(0)).ShouldBeTrue();
 
             // We can take advantage of the fact that we will get the same ProjectRootElement from the cache if we try to
             // open it with a path; get that and then compare it to what project.Imports gave us.
-            object.ReferenceEquals(imports.First().ImportedProject, ProjectRootElement.Open(importPath)).ShouldBeTrue();
+            ReferenceEquals(imports.First().ImportedProject, ProjectRootElement.Open(importPath)).ShouldBeTrue();
 
             // Test the logical project iterator
             List<ProjectElement> logicalElements = new List<ProjectElement>(project.GetLogicalProject());
@@ -1649,7 +1649,7 @@ public void ExternallyMarkDirty()
 
             ProjectProperty property2 = project.GetProperty("p");
 
-            object.ReferenceEquals(property1, property2).ShouldBeFalse(); // different object indicates reevaluation occurred
+            ReferenceEquals(property1, property2).ShouldBeFalse(); // different object indicates reevaluation occurred
         }
 
         /// <summary>
@@ -2089,7 +2089,7 @@ public void BuildEvaluationUsesCustomLoggers()
                 ObjectModelHelpers.CleanupFileContents(@"<Project xmlns='msbuildnamespace'>
                 </Project>");
 
-            string importFileName = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName() + ".proj";
+            string importFileName = FileUtilities.GetTemporaryFileName() + ".proj";
             File.WriteAllText(importFileName, importProjectContent);
 
             string projectContent =
@@ -2573,14 +2573,14 @@ public void VariousImports()
             List<ProjectElement> logicalProject = new List<ProjectElement>(project.GetLogicalProject());
 
             logicalProject.Count.ShouldBe(8); // 4 properties + 4 property groups
-            object.ReferenceEquals(zero, logicalProject[0].ContainingProject).ShouldBeTrue();
-            object.ReferenceEquals(zero, logicalProject[1].ContainingProject).ShouldBeTrue();
-            object.ReferenceEquals(one, logicalProject[2].ContainingProject).ShouldBeTrue();
-            object.ReferenceEquals(one, logicalProject[3].ContainingProject).ShouldBeTrue();
-            object.ReferenceEquals(three, logicalProject[4].ContainingProject).ShouldBeTrue();
-            object.ReferenceEquals(three, logicalProject[5].ContainingProject).ShouldBeTrue();
-            object.ReferenceEquals(two, logicalProject[6].ContainingProject).ShouldBeTrue();
-            object.ReferenceEquals(two, logicalProject[7].ContainingProject).ShouldBeTrue();
+            ReferenceEquals(zero, logicalProject[0].ContainingProject).ShouldBeTrue();
+            ReferenceEquals(zero, logicalProject[1].ContainingProject).ShouldBeTrue();
+            ReferenceEquals(one, logicalProject[2].ContainingProject).ShouldBeTrue();
+            ReferenceEquals(one, logicalProject[3].ContainingProject).ShouldBeTrue();
+            ReferenceEquals(three, logicalProject[4].ContainingProject).ShouldBeTrue();
+            ReferenceEquals(three, logicalProject[5].ContainingProject).ShouldBeTrue();
+            ReferenceEquals(two, logicalProject[6].ContainingProject).ShouldBeTrue();
+            ReferenceEquals(two, logicalProject[7].ContainingProject).ShouldBeTrue();
 
             // Clear the cache
             project.ProjectCollection.UnloadAllProjects();
@@ -2619,12 +2619,12 @@ public void LogicalProjectWithWildcardImport()
                 List<ProjectElement> logicalProject = new List<ProjectElement>(project.GetLogicalProject());
 
                 logicalProject.Count.ShouldBe(6); // 3 properties + 3 property groups
-                object.ReferenceEquals(zero, logicalProject[0].ContainingProject).ShouldBeTrue(); // PropertyGroup
-                object.ReferenceEquals(zero, logicalProject[1].ContainingProject).ShouldBeTrue(); // p = 0
-                object.ReferenceEquals(one, logicalProject[2].ContainingProject).ShouldBeTrue();  // PropertyGroup
-                object.ReferenceEquals(one, logicalProject[3].ContainingProject).ShouldBeTrue();  // p = 1
-                object.ReferenceEquals(two, logicalProject[4].ContainingProject).ShouldBeTrue();  // PropertyGroup
-                object.ReferenceEquals(two, logicalProject[5].ContainingProject).ShouldBeTrue();  // p = 2
+                ReferenceEquals(zero, logicalProject[0].ContainingProject).ShouldBeTrue(); // PropertyGroup
+                ReferenceEquals(zero, logicalProject[1].ContainingProject).ShouldBeTrue(); // p = 0
+                ReferenceEquals(one, logicalProject[2].ContainingProject).ShouldBeTrue();  // PropertyGroup
+                ReferenceEquals(one, logicalProject[3].ContainingProject).ShouldBeTrue();  // p = 1
+                ReferenceEquals(two, logicalProject[4].ContainingProject).ShouldBeTrue();  // PropertyGroup
+                ReferenceEquals(two, logicalProject[5].ContainingProject).ShouldBeTrue();  // p = 2
 
                 // Clear the cache
                 project.ProjectCollection.UnloadAllProjects();
diff --git a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
index b22c8bf0ab9..375d15c5acd 100644
--- a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
@@ -104,7 +104,7 @@ public ProtectImports_Tests()
                 </Project>";
 
             importContents = Expand(importContents);
-            _importFilename = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName() + ".targets";
+            _importFilename = Build.Shared.FileUtilities.GetTemporaryFileName() + ".targets";
             File.WriteAllText(_importFilename, importContents);
         }
 
diff --git a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
index b8845cd6244..c4c44eac2a3 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
@@ -132,7 +132,7 @@ public void AddItemWithMetadata()
 
             ProjectItemInstance returned = p.AddItem("i", "i1", metadata);
 
-            Assert.True(object.ReferenceEquals(returned, Helpers.MakeList(p.GetItems("i"))[0]));
+            Assert.True(ReferenceEquals(returned, Helpers.MakeList(p.GetItems("i"))[0]));
 
             foreach (ProjectItemInstance item in p.Items)
             {
@@ -223,7 +223,7 @@ public void CloneProjectItself()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.False(Object.ReferenceEquals(first, second));
+            Assert.False(ReferenceEquals(first, second));
         }
 
         /// <summary>
@@ -235,10 +235,10 @@ public void CloneProperties()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.False(Object.ReferenceEquals(first.GetProperty("p1"), second.GetProperty("p1")));
+            Assert.False(ReferenceEquals(first.GetProperty("p1"), second.GetProperty("p1")));
 
             ProjectPropertyInstance newProperty = first.SetProperty("p1", "v1b");
-            Assert.True(Object.ReferenceEquals(newProperty, first.GetProperty("p1")));
+            Assert.True(ReferenceEquals(newProperty, first.GetProperty("p1")));
             Assert.Equal("v1b", first.GetPropertyValue("p1"));
             Assert.Equal("v1", second.GetPropertyValue("p1"));
         }
@@ -328,7 +328,7 @@ public void CloneItems()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.False(Object.ReferenceEquals(Helpers.MakeList(first.GetItems("i"))[0], Helpers.MakeList(second.GetItems("i"))[0]));
+            Assert.False(ReferenceEquals(Helpers.MakeList(first.GetItems("i"))[0], Helpers.MakeList(second.GetItems("i"))[0]));
 
             first.AddItem("i", "i3");
             Assert.Equal(4, Helpers.MakeList(first.GetItems("i")).Count);
@@ -911,7 +911,7 @@ public void ImmutableProjectInstance_CloneImmutableFromImmutable()
             var instance = protoInstance.DeepCopy(/* inherit */);
 
             // Should not have bothered cloning
-            Assert.True(Object.ReferenceEquals(protoInstance, instance));
+            Assert.True(ReferenceEquals(protoInstance, instance));
 
             Helpers.VerifyAssertThrowsInvalidOperation(delegate () { instance.GetProperty("g").EvaluatedValue = "v2"; });
             Helpers.VerifyAssertThrowsInvalidOperation(
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index e8259bd3120..fc6a46a4889 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -361,7 +361,7 @@ public void ITaskItem2Operations()
             Assert.Equal("esca%20ped%3bitem", taskItem.EvaluatedIncludeEscaped);
             Assert.Equal("esca ped;item", taskItem.ItemSpec);
 
-            ITaskItem2 taskItem2 = new Microsoft.Build.Utilities.TaskItem(taskItem);
+            ITaskItem2 taskItem2 = new Utilities.TaskItem(taskItem);
 
             taskItem2.SetMetadataValueLiteral("m;", "m;2");
 
@@ -517,7 +517,7 @@ public void InstanceItemToUtilItemIDG()
 
             ProjectItemInstance item = GetOneItem(content);
 
-            Microsoft.Build.Utilities.TaskItem taskItem = new Microsoft.Build.Utilities.TaskItem(item);
+            Utilities.TaskItem taskItem = new Utilities.TaskItem(item);
 
             Assert.Equal(";x86;", taskItem.GetMetadata("m0"));
             Assert.Equal("foo.extension", taskItem.GetMetadata("m1"));
diff --git a/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
index 3e9ab10b3df..49a7783bd60 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
@@ -112,7 +112,7 @@ public void FileLocationAvailableEvenAfterEdits()
 
             try
             {
-                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
+                path = Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement projectXml = ProjectRootElement.Create(path);
                 projectXml.Save();
 
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index ee35a83c93a..b6f11b43cb8 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -1,10 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.IO;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
-using System.IO;
 using Xunit;
 using Xunit.Abstractions;
 using Xunit.NetCore.Extensions;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index 690150d1df6..6bcacaf63b5 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -201,49 +201,49 @@ public class TestCollectionGroup : IDisposable
 
         protected void TakeSnapshot()
         {
-            Assert.Null(this.ImmutableProjects);
+            Assert.Null(ImmutableProjects);
             var result = new Dictionary<ProjectCollectionLinker, HashSet<Project>>();
-            this.Local.Importing = false;
-            result.Add(this.Local, new HashSet<Project>(this.Local.Collection.LoadedProjects));
-            foreach (var r in this.Remote)
+            Local.Importing = false;
+            result.Add(Local, new HashSet<Project>(Local.Collection.LoadedProjects));
+            foreach (var r in Remote)
             {
                 r.Importing = false;
                 result.Add(r, new HashSet<Project>(r.Collection.LoadedProjects));
             }
 
-            this.ImmutableProjects = result;
+            ImmutableProjects = result;
         }
 
         public TestCollectionGroup(int remoteCount, int stdFilesCount)
         {
-            this.RemoteCount = 2;
+            RemoteCount = 2;
 
-            this.Group = ProjectCollectionLinker.CreateGroup();
+            Group = ProjectCollectionLinker.CreateGroup();
 
-            this.Local = this.Group.AddNew();
-            this.Remote = new ProjectCollectionLinker[this.RemoteCount];
-            for (int i = 0; i < this.RemoteCount; i++)
+            Local = Group.AddNew();
+            Remote = new ProjectCollectionLinker[RemoteCount];
+            for (int i = 0; i < RemoteCount; i++)
             {
-                this.Remote[i] = this.Group.AddNew();
+                Remote[i] = Group.AddNew();
             }
 
-            this.ImmutableDisk = new TransientIO();
-            this.Disk = this.ImmutableDisk.GetSubFolder("Mutable");
+            ImmutableDisk = new TransientIO();
+            Disk = ImmutableDisk.GetSubFolder("Mutable");
 
             List<string> stdFiles = new List<string>();
             for (int i = 0; i < stdFilesCount; i++)
             {
-                stdFiles.Add(this.ImmutableDisk.WriteProjectFile($"Proj{i}.proj", TestCollectionGroup.SampleProjectFile));
+                stdFiles.Add(ImmutableDisk.WriteProjectFile($"Proj{i}.proj", SampleProjectFile));
             }
 
-            this.StdProjectFiles = stdFiles;
+            StdProjectFiles = stdFiles;
         }
 
         private void Clear(ProjectCollectionLinker linker)
         {
             linker.Importing = false;
             HashSet<Project> toKeep = null;
-            this.ImmutableProjects?.TryGetValue(linker, out toKeep);
+            ImmutableProjects?.TryGetValue(linker, out toKeep);
             if (toKeep == null)
             {
                 linker.Collection.UnloadAllProjects();
@@ -268,20 +268,20 @@ private void Clear(ProjectCollectionLinker linker)
         }
         public void Clear()
         {
-            this.Clear(this.Local);
-            foreach (var remote in this.Remote)
+            Clear(Local);
+            foreach (var remote in Remote)
             {
-                this.Clear(remote);
+                Clear(remote);
             }
 
-            this.Group.ClearAllRemotes();
-            this.Disk.Clear();
+            Group.ClearAllRemotes();
+            Disk.Clear();
         }
 
         public void Dispose()
         {
-            this.Clear();
-            this.ImmutableDisk.Dispose();
+            Clear();
+            ImmutableDisk.Dispose();
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index bd2346f8b43..0169756c4b2 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -19,20 +19,20 @@ internal class ElementLinkPair<T> : LinkPair<T>
     {
         public ProjectXmlPair PRE { get; protected set; }
 
-        public ElementLinkPair(ProjectXmlPair pre, T view, T real) : base(view, real) { this.PRE = pre; }
+        public ElementLinkPair(ProjectXmlPair pre, T view, T real) : base(view, real) { PRE = pre; }
 
         // the PRE.CreateXX(), AppendChild, way.
         public ElementLinkPair<CT> AppendNewChaildWithVerify<CT>(ObjectType where, string id, Func<ProjectRootElement, string, CT> adder, Func<CT, string, bool> matcher)
             where CT : ProjectElement
         {
-            var appendWhere = this.Get(where) as ProjectElementContainer;
+            var appendWhere = Get(where) as ProjectElementContainer;
             Assert.NotNull(appendWhere);
 
-            var c1Where = adder(this.PRE.Get(where), id);
+            var c1Where = adder(PRE.Get(where), id);
             Assert.NotNull(c1Where);
             appendWhere.AppendChild(c1Where);
 
-            var c1 = this.QuerySingleChildrenWithValidation<CT>((t) => matcher(t, id));
+            var c1 = QuerySingleChildrenWithValidation<CT>((t) => matcher(t, id));
             Assert.Same(c1Where, c1.Get(where));
 
             return c1;
@@ -58,10 +58,10 @@ public ElementLinkPair<CT> AppendNewLabeledChaildWithVerify<CT>(ObjectType where
         public ElementLinkPair<CT> AddNewChaildWithVerify<CT>(ObjectType where, string id, Func<T, string, CT> adder, Func<CT, string, bool> matcher)
             where CT : ProjectElement
         {
-            var c1Where = adder(this.Get(where), id);
+            var c1Where = adder(Get(where), id);
             Assert.NotNull(c1Where);
 
-            var c1 = this.QuerySingleChildrenWithValidation<CT>((t) => matcher(t, id));
+            var c1 = QuerySingleChildrenWithValidation<CT>((t) => matcher(t, id));
             Assert.Same(c1Where, c1.Get(where));
 
             return c1;
@@ -149,7 +149,7 @@ public ICollection<ElementLinkPair<CT>> QueryChildrenWithValidation<CT>(Func<T,
             var realResult = new List<CT>();
             var finalResult = new List<ElementLinkPair<CT>>();
 
-            foreach (var v in getter(this.View))
+            foreach (var v in getter(View))
             {
                 if (v is CT vt)
                 {
@@ -160,7 +160,7 @@ public ICollection<ElementLinkPair<CT>> QueryChildrenWithValidation<CT>(Func<T,
                 }
             }
 
-            foreach (var r in getter(this.Real))
+            foreach (var r in getter(Real))
             {
                 if (r is CT rt)
                 {
@@ -175,7 +175,7 @@ public ICollection<ElementLinkPair<CT>> QueryChildrenWithValidation<CT>(Func<T,
 
             for (int i = 0; i < viewResult.Count; i++)
             {
-                finalResult.Add(new ElementLinkPair<CT>(this.PRE, viewResult[i], realResult[i]));
+                finalResult.Add(new ElementLinkPair<CT>(PRE, viewResult[i], realResult[i]));
             }
 
             return finalResult;
@@ -184,8 +184,8 @@ public ICollection<ElementLinkPair<CT>> QueryChildrenWithValidation<CT>(Func<T,
         public ICollection<ElementLinkPair<CT>> QueryChildrenWithValidation<CT>(Func<CT, bool> matcher)
             where CT : ProjectElement
         {
-            Assert.True(this.View is ProjectElementContainer);
-            Assert.True(this.Real is ProjectElementContainer);
+            Assert.True(View is ProjectElementContainer);
+            Assert.True(Real is ProjectElementContainer);
 
             return QueryChildrenWithValidation((t) => (t as ProjectElementContainer).AllChildren, matcher);
         }
@@ -208,15 +208,15 @@ public ElementLinkPair<CT> QuerySingleChildrenWithValidation<CT>(Func<T, IEnumer
     internal sealed class ProjectXmlPair : ElementLinkPair<ProjectRootElement>
     {
         private ProjectPair Project { get; }
-        public ProjectXmlPair(ProjectPair pair) : base(null, pair.View.Xml, pair.Real.Xml) { this.Project = pair; this.PRE = this; }
-        public ProjectXmlPair(ProjectRootElement viewXml, ProjectRootElement realXml) : base(null, viewXml, realXml) { this.PRE = this; }
+        public ProjectXmlPair(ProjectPair pair) : base(null, pair.View.Xml, pair.Real.Xml) { Project = pair; PRE = this; }
+        public ProjectXmlPair(ProjectRootElement viewXml, ProjectRootElement realXml) : base(null, viewXml, realXml) { PRE = this; }
 
         public ElementLinkPair<CT> CreateWithVerify<CT>(Func<ProjectRootElement, CT> creator)
             where CT : ProjectElement
         {
-            var view = creator(this.View);
+            var view = creator(View);
             Assert.NotNull(view);
-            var real = creator(this.Real);
+            var real = creator(Real);
             Assert.NotNull(real);
             ViewValidation.VerifyFindType(view, real);
             return new ElementLinkPair<CT>(this, view, real);
@@ -247,7 +247,7 @@ public static void VerifySameLocationWithException(Func<ElementLocation> expecte
 
         public static void VerifySameLocation(ElementLocation expected, ElementLocation actual, ValidationContext context = null)
         {
-            if (object.ReferenceEquals(expected, actual))
+            if (ReferenceEquals(expected, actual))
             {
                 return;
             }
@@ -436,7 +436,7 @@ private static void VerifyProjectElementContainerView(ProjectElementContainer vi
                 Assert.NotNull(viewChild);
                 Assert.Same(realChild.Parent, realXml);
 
-                if (!object.ReferenceEquals(viewChild.Parent, viewXml))
+                if (!ReferenceEquals(viewChild.Parent, viewXml))
                 {
                     var lm = LinkedObjectsFactory.GetLink(viewXml) as ILinkMock;
                     lm.Linker.ValidateNoDuplicates();
@@ -536,28 +536,28 @@ public static void Verify(ProjectRootElement viewXml, ProjectRootElement realXml
             Assert.Equal(realXml.TimeLastChanged, viewXml.TimeLastChanged);
             Assert.Equal(realXml.LastWriteTimeWhenRead, viewXml.LastWriteTimeWhenRead);
 
-            ViewValidation.VerifySameLocation(realXml.ProjectFileLocation, viewXml.ProjectFileLocation, context);
-            ViewValidation.VerifySameLocation(realXml.ToolsVersionLocation, viewXml.ToolsVersionLocation, context);
-            ViewValidation.VerifySameLocation(realXml.DefaultTargetsLocation, viewXml.DefaultTargetsLocation, context);
-            ViewValidation.VerifySameLocation(realXml.InitialTargetsLocation, viewXml.InitialTargetsLocation, context);
-            ViewValidation.VerifySameLocation(realXml.SdkLocation, viewXml.SdkLocation, context);
-            ViewValidation.VerifySameLocation(realXml.TreatAsLocalPropertyLocation, viewXml.TreatAsLocalPropertyLocation, context);
-
-            ViewValidation.Verify(viewXml.ChooseElements, realXml.ChooseElements, Verify, context);
-            ViewValidation.Verify(viewXml.ItemDefinitionGroups, realXml.ItemDefinitionGroups, Verify, context);
-            ViewValidation.Verify(viewXml.ItemDefinitions, realXml.ItemDefinitions, Verify, context);
-            ViewValidation.Verify(viewXml.ItemGroups, realXml.ItemGroups, Verify, context);
-            ViewValidation.Verify(viewXml.Items, realXml.Items, Verify, context);
-            ViewValidation.Verify(viewXml.ImportGroups, realXml.ImportGroups, Verify, context);
-            ViewValidation.Verify(viewXml.Imports, realXml.Imports, Verify, context);
-            ViewValidation.Verify(viewXml.PropertyGroups, realXml.PropertyGroups, Verify, context);
-            ViewValidation.Verify(viewXml.Properties, realXml.Properties, Verify, context);
-            ViewValidation.Verify(viewXml.Targets, realXml.Targets, Verify, context);
-            ViewValidation.Verify(viewXml.UsingTasks, realXml.UsingTasks, Verify, context);
-            ViewValidation.Verify(viewXml.ItemGroupsReversed, realXml.ItemGroupsReversed, Verify, context);
-            ViewValidation.Verify(viewXml.ItemDefinitionGroupsReversed, realXml.ItemDefinitionGroupsReversed, Verify, context);
-            ViewValidation.Verify(viewXml.ImportGroupsReversed, realXml.ImportGroupsReversed, Verify, context);
-            ViewValidation.Verify(viewXml.PropertyGroupsReversed, realXml.PropertyGroupsReversed, Verify, context);
+            VerifySameLocation(realXml.ProjectFileLocation, viewXml.ProjectFileLocation, context);
+            VerifySameLocation(realXml.ToolsVersionLocation, viewXml.ToolsVersionLocation, context);
+            VerifySameLocation(realXml.DefaultTargetsLocation, viewXml.DefaultTargetsLocation, context);
+            VerifySameLocation(realXml.InitialTargetsLocation, viewXml.InitialTargetsLocation, context);
+            VerifySameLocation(realXml.SdkLocation, viewXml.SdkLocation, context);
+            VerifySameLocation(realXml.TreatAsLocalPropertyLocation, viewXml.TreatAsLocalPropertyLocation, context);
+
+            Verify(viewXml.ChooseElements, realXml.ChooseElements, Verify, context);
+            Verify(viewXml.ItemDefinitionGroups, realXml.ItemDefinitionGroups, Verify, context);
+            Verify(viewXml.ItemDefinitions, realXml.ItemDefinitions, Verify, context);
+            Verify(viewXml.ItemGroups, realXml.ItemGroups, Verify, context);
+            Verify(viewXml.Items, realXml.Items, Verify, context);
+            Verify(viewXml.ImportGroups, realXml.ImportGroups, Verify, context);
+            Verify(viewXml.Imports, realXml.Imports, Verify, context);
+            Verify(viewXml.PropertyGroups, realXml.PropertyGroups, Verify, context);
+            Verify(viewXml.Properties, realXml.Properties, Verify, context);
+            Verify(viewXml.Targets, realXml.Targets, Verify, context);
+            Verify(viewXml.UsingTasks, realXml.UsingTasks, Verify, context);
+            Verify(viewXml.ItemGroupsReversed, realXml.ItemGroupsReversed, Verify, context);
+            Verify(viewXml.ItemDefinitionGroupsReversed, realXml.ItemDefinitionGroupsReversed, Verify, context);
+            Verify(viewXml.ImportGroupsReversed, realXml.ImportGroupsReversed, Verify, context);
+            Verify(viewXml.PropertyGroupsReversed, realXml.PropertyGroupsReversed, Verify, context);
         }
 
         public static void Verify(ProjectChooseElement viewXml, ProjectChooseElement realXml, ValidationContext context = null)
@@ -642,14 +642,14 @@ public static void Verify(ProjectTaskElement viewXml, ProjectTaskElement realXml
             Assert.Equal(realXml.Name, viewXml.Name);
 
             Assert.Equal(realXml.ContinueOnError, viewXml.ContinueOnError);
-            ViewValidation.VerifySameLocation(realXml.ContinueOnErrorLocation, viewXml.ContinueOnErrorLocation, context);
+            VerifySameLocation(realXml.ContinueOnErrorLocation, viewXml.ContinueOnErrorLocation, context);
             Assert.Equal(realXml.MSBuildRuntime, viewXml.MSBuildRuntime);
-            ViewValidation.VerifySameLocation(realXml.MSBuildRuntimeLocation, viewXml.MSBuildRuntimeLocation, context);
+            VerifySameLocation(realXml.MSBuildRuntimeLocation, viewXml.MSBuildRuntimeLocation, context);
 
             Assert.Equal(realXml.MSBuildArchitecture, viewXml.MSBuildArchitecture);
-            ViewValidation.VerifySameLocation(realXml.MSBuildArchitectureLocation, viewXml.MSBuildArchitectureLocation, context);
+            VerifySameLocation(realXml.MSBuildArchitectureLocation, viewXml.MSBuildArchitectureLocation, context);
 
-            ViewValidation.Verify(viewXml.Outputs, realXml.Outputs, ViewValidation.Verify, context);
+            Verify(viewXml.Outputs, realXml.Outputs, Verify, context);
 
             var realParams = realXml.Parameters;
             var viewParams = viewXml.Parameters;
@@ -689,7 +689,7 @@ public static void Verify(ProjectTaskElement viewXml, ProjectTaskElement realXml
                     var vkvp = viewPLocList[li];
 
                     Assert.Equal(rkvp.Key, vkvp.Key);
-                    ViewValidation.VerifySameLocation(rkvp.Value, vkvp.Value, context);
+                    VerifySameLocation(rkvp.Value, vkvp.Value, context);
                 }
             }
         }
@@ -767,25 +767,25 @@ public static void Verify(ProjectUsingTaskElement viewXml, ProjectUsingTaskEleme
 
 
             Assert.Equal(realXml.AssemblyFile, viewXml.AssemblyFile);
-            ViewValidation.VerifySameLocation(realXml.AssemblyFileLocation, viewXml.AssemblyFileLocation, context);
+            VerifySameLocation(realXml.AssemblyFileLocation, viewXml.AssemblyFileLocation, context);
 
             Assert.Equal(realXml.AssemblyName, viewXml.AssemblyName);
-            ViewValidation.VerifySameLocation(realXml.AssemblyNameLocation, viewXml.AssemblyNameLocation, context);
+            VerifySameLocation(realXml.AssemblyNameLocation, viewXml.AssemblyNameLocation, context);
 
             Assert.Equal(realXml.TaskName, viewXml.TaskName);
-            ViewValidation.VerifySameLocation(realXml.TaskNameLocation, viewXml.TaskNameLocation, context);
+            VerifySameLocation(realXml.TaskNameLocation, viewXml.TaskNameLocation, context);
 
             Assert.Equal(realXml.TaskFactory, viewXml.TaskFactory);
-            ViewValidation.VerifySameLocation(realXml.TaskFactoryLocation, viewXml.TaskFactoryLocation, context);
+            VerifySameLocation(realXml.TaskFactoryLocation, viewXml.TaskFactoryLocation, context);
 
             Assert.Equal(realXml.Runtime, viewXml.Runtime);
-            ViewValidation.VerifySameLocation(realXml.RuntimeLocation, viewXml.RuntimeLocation, context);
+            VerifySameLocation(realXml.RuntimeLocation, viewXml.RuntimeLocation, context);
 
             Assert.Equal(realXml.Architecture, viewXml.Architecture);
-            ViewValidation.VerifySameLocation(realXml.ArchitectureLocation, viewXml.ArchitectureLocation, context);
+            VerifySameLocation(realXml.ArchitectureLocation, viewXml.ArchitectureLocation, context);
 
-            ViewValidation.Verify(viewXml.TaskBody, realXml.TaskBody, context);
-            ViewValidation.Verify(viewXml.ParameterGroup, realXml.ParameterGroup, context);
+            Verify(viewXml.TaskBody, realXml.TaskBody, context);
+            Verify(viewXml.ParameterGroup, realXml.ParameterGroup, context);
         }
 
         public static void Verify(ProjectTargetElement viewXml, ProjectTargetElement realXml, ValidationContext context = null)
@@ -799,26 +799,26 @@ public static void Verify(ProjectTargetElement viewXml, ProjectTargetElement rea
 
 
             Assert.Equal(realXml.Name, viewXml.Name);
-            ViewValidation.VerifySameLocation(realXml.NameLocation, viewXml.NameLocation, context);
+            VerifySameLocation(realXml.NameLocation, viewXml.NameLocation, context);
             Assert.Equal(realXml.Inputs, viewXml.Inputs);
-            ViewValidation.VerifySameLocation(realXml.InputsLocation, viewXml.InputsLocation, context);
+            VerifySameLocation(realXml.InputsLocation, viewXml.InputsLocation, context);
             Assert.Equal(realXml.Outputs, viewXml.Outputs);
-            ViewValidation.VerifySameLocation(realXml.OutputsLocation, viewXml.OutputsLocation, context);
+            VerifySameLocation(realXml.OutputsLocation, viewXml.OutputsLocation, context);
             Assert.Equal(realXml.KeepDuplicateOutputs, viewXml.KeepDuplicateOutputs);
-            ViewValidation.VerifySameLocation(realXml.KeepDuplicateOutputsLocation, viewXml.KeepDuplicateOutputsLocation, context);
+            VerifySameLocation(realXml.KeepDuplicateOutputsLocation, viewXml.KeepDuplicateOutputsLocation, context);
             Assert.Equal(realXml.DependsOnTargets, viewXml.DependsOnTargets);
-            ViewValidation.VerifySameLocation(realXml.DependsOnTargetsLocation, viewXml.DependsOnTargetsLocation, context);
+            VerifySameLocation(realXml.DependsOnTargetsLocation, viewXml.DependsOnTargetsLocation, context);
             Assert.Equal(realXml.BeforeTargets, viewXml.BeforeTargets);
-            ViewValidation.VerifySameLocation(realXml.BeforeTargetsLocation, viewXml.BeforeTargetsLocation, context);
+            VerifySameLocation(realXml.BeforeTargetsLocation, viewXml.BeforeTargetsLocation, context);
             Assert.Equal(realXml.AfterTargets, viewXml.AfterTargets);
-            ViewValidation.VerifySameLocation(realXml.AfterTargetsLocation, viewXml.AfterTargetsLocation, context);
+            VerifySameLocation(realXml.AfterTargetsLocation, viewXml.AfterTargetsLocation, context);
             Assert.Equal(realXml.Returns, viewXml.Returns);
-            ViewValidation.VerifySameLocation(realXml.ReturnsLocation, viewXml.ReturnsLocation, context);
+            VerifySameLocation(realXml.ReturnsLocation, viewXml.ReturnsLocation, context);
 
-            ViewValidation.Verify(viewXml.ItemGroups, realXml.ItemGroups, ViewValidation.Verify, context);
-            ViewValidation.Verify(viewXml.PropertyGroups, realXml.PropertyGroups, ViewValidation.Verify, context);
-            ViewValidation.Verify(viewXml.OnErrors, realXml.OnErrors, ViewValidation.Verify, context);
-            ViewValidation.Verify(viewXml.Tasks, realXml.Tasks, ViewValidation.Verify, context);
+            Verify(viewXml.ItemGroups, realXml.ItemGroups, Verify, context);
+            Verify(viewXml.PropertyGroups, realXml.PropertyGroups, Verify, context);
+            Verify(viewXml.OnErrors, realXml.OnErrors, Verify, context);
+            Verify(viewXml.Tasks, realXml.Tasks, Verify, context);
         }
 
         public static void Verify(ProjectImportElement viewXml, ProjectImportElement realXml, ValidationContext context = null)
@@ -832,16 +832,16 @@ public static void Verify(ProjectImportElement viewXml, ProjectImportElement rea
 
 
             Assert.Equal(realXml.Project, viewXml.Project);
-            ViewValidation.VerifySameLocation(realXml.ProjectLocation, viewXml.ProjectLocation, context);
+            VerifySameLocation(realXml.ProjectLocation, viewXml.ProjectLocation, context);
 
             // mostly test the remoting infrastructure. Sdk Imports are not really covered by simple samples for now.
             // Todo: add mock SDK import closure to SdtGroup?
             Assert.Equal(realXml.Sdk, viewXml.Sdk);
             Assert.Equal(realXml.Version, viewXml.Version);
             Assert.Equal(realXml.MinimumVersion, viewXml.MinimumVersion);
-            ViewValidation.VerifySameLocation(realXml.SdkLocation, viewXml.SdkLocation, context);
+            VerifySameLocation(realXml.SdkLocation, viewXml.SdkLocation, context);
             Assert.Equal(realXml.ImplicitImportLocation, viewXml.ImplicitImportLocation);
-            ViewValidation.VerifyProjectElement(viewXml.OriginalElement, realXml.OriginalElement, context);
+            VerifyProjectElement(viewXml.OriginalElement, realXml.OriginalElement, context);
         }
 
         public static void Verify(ProjectImportGroupElement viewXml, ProjectImportGroupElement realXml, ValidationContext context = null)
@@ -853,7 +853,7 @@ public static void Verify(ProjectImportGroupElement viewXml, ProjectImportGroupE
 
             VerifyProjectElement(viewXml, realXml, context);
 
-            ViewValidation.Verify(viewXml.Imports, realXml.Imports, ViewValidation.Verify, context);
+            Verify(viewXml.Imports, realXml.Imports, Verify, context);
         }
 
         public static void Verify(ProjectItemDefinitionElement viewXml, ProjectItemDefinitionElement realXml, ValidationContext context = null)
@@ -866,7 +866,7 @@ public static void Verify(ProjectItemDefinitionElement viewXml, ProjectItemDefin
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.ItemType, viewXml.ItemType);
-            ViewValidation.Verify(viewXml.Metadata, realXml.Metadata, ViewValidation.Verify, context);
+            Verify(viewXml.Metadata, realXml.Metadata, Verify, context);
         }
 
         public static void Verify(ProjectItemDefinitionGroupElement viewXml, ProjectItemDefinitionGroupElement realXml, ValidationContext context = null)
@@ -878,7 +878,7 @@ public static void Verify(ProjectItemDefinitionGroupElement viewXml, ProjectItem
 
             VerifyProjectElement(viewXml, realXml, context);
 
-            ViewValidation.Verify(viewXml.ItemDefinitions, realXml.ItemDefinitions, ViewValidation.Verify, context);
+            Verify(viewXml.ItemDefinitions, realXml.ItemDefinitions, Verify, context);
         }
 
         public static void Verify(ProjectItemElement viewXml, ProjectItemElement realXml, ValidationContext context = null)
@@ -900,7 +900,7 @@ public static void Verify(ProjectItemElement viewXml, ProjectItemElement realXml
             Assert.Equal(realXml.KeepDuplicates, viewXml.KeepDuplicates);
             Assert.Equal(realXml.HasMetadata, viewXml.HasMetadata);
 
-            Verify(viewXml.Metadata, realXml.Metadata, ViewValidation.Verify, context);
+            Verify(viewXml.Metadata, realXml.Metadata, Verify, context);
 
             VerifySameLocation(realXml.IncludeLocation, viewXml.IncludeLocation, context);
             VerifySameLocation(realXml.ExcludeLocation, viewXml.ExcludeLocation, context);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
index e3531211645..995d180a159 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
@@ -24,80 +24,80 @@ public LinkPair(T view, T real)
         {
             ViewValidation.VerifyLinkedNotNull(view);
             ViewValidation.VerifyNotLinkedNotNull(real);
-            this.View = view;
-            this.Real = real;
+            View = view;
+            Real = real;
         }
 
-        public T Get(ObjectType type) => type == ObjectType.Real ? this.Real : this.View;
+        public T Get(ObjectType type) => type == ObjectType.Real ? Real : View;
         public T View { get; }
         public T Real { get; }
 
         public void VerifyNotSame(LinkPair<T> other)
         {
-            Assert.NotEqual((object)this.View, (object)other.View);
-            Assert.NotEqual((object)this.Real, (object)other.Real);
+            Assert.NotEqual((object)View, (object)other.View);
+            Assert.NotEqual((object)Real, (object)other.Real);
         }
 
         public void VerifySame(LinkPair<T> other)
         {
-            Assert.Equal((object)this.View, (object)other.View);
-            Assert.Equal((object)this.Real, (object)other.Real);
+            Assert.Equal((object)View, (object)other.View);
+            Assert.Equal((object)Real, (object)other.Real);
         }
 
         public void VerifySetter(bool finalValue, Func<T, bool> getter, Action<T, bool> setter)
         {
-            var current = getter(this.Real);
-            Assert.Equal(current, getter(this.View));
+            var current = getter(Real);
+            Assert.Equal(current, getter(View));
 
             // set via the view
-            setter(this.View, !current);
+            setter(View, !current);
 
-            Assert.Equal(!current, getter(this.View));
-            Assert.Equal(!current, getter(this.Real));
+            Assert.Equal(!current, getter(View));
+            Assert.Equal(!current, getter(Real));
 
             // set via the real.
-            setter(this.Real, current);
+            setter(Real, current);
 
-            Assert.Equal(current, getter(this.View));
-            Assert.Equal(current, getter(this.Real));
+            Assert.Equal(current, getter(View));
+            Assert.Equal(current, getter(Real));
 
-            setter(this.View, finalValue);
-            Assert.Equal(finalValue, getter(this.View));
-            Assert.Equal(finalValue, getter(this.Real));
+            setter(View, finalValue);
+            Assert.Equal(finalValue, getter(View));
+            Assert.Equal(finalValue, getter(Real));
         }
 
         public void VerifySetter(string newValue, Func<T, string> getter, Action<T, string> setter)
         {
             var newValue1 = newValue.Ver(1);
-            var current = getter(this.Real);
-            Assert.Equal(current, getter(this.View));
+            var current = getter(Real);
+            Assert.Equal(current, getter(View));
             Assert.NotEqual(current, newValue);
             Assert.NotEqual(current, newValue1);
 
             // set via the view
-            setter(this.View, newValue1);
+            setter(View, newValue1);
 
-            Assert.Equal(newValue1, getter(this.View));
-            Assert.Equal(newValue1, getter(this.Real));
+            Assert.Equal(newValue1, getter(View));
+            Assert.Equal(newValue1, getter(Real));
 
             // set via the real.
-            setter(this.Real, newValue);
+            setter(Real, newValue);
 
-            Assert.Equal(newValue, getter(this.View));
-            Assert.Equal(newValue, getter(this.Real));
-            this.Verify();
+            Assert.Equal(newValue, getter(View));
+            Assert.Equal(newValue, getter(Real));
+            Verify();
         }
 
         public virtual void Verify()
         {
-            ViewValidation.VerifyFindType(this.View, this.Real);
+            ViewValidation.VerifyFindType(View, Real);
         }
     }
 
     internal sealed class ValidationContext
     {
         public ValidationContext() { }
-        public ValidationContext(ProjectPair pair) { this.Pair = pair; }
+        public ValidationContext(ProjectPair pair) { Pair = pair; }
         public ProjectPair Pair { get; set; }
         public Action<ElementLocation, ElementLocation> ValidateLocation { get; set; }
     }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
index c461631536d..88a1b1912b6 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
@@ -20,8 +20,8 @@ public ProjectPair(Project view, Project real)
 
         public void ValidatePropertyValue(string name, string value)
         {
-            Assert.Equal(value, this.View.GetPropertyValue(name));
-            Assert.Equal(value, this.Real.GetPropertyValue(name));
+            Assert.Equal(value, View.GetPropertyValue(name));
+            Assert.Equal(value, Real.GetPropertyValue(name));
         }
 
         private ProjectItem VerifyAfterAddSingleItem(ObjectType where, ICollection<ProjectItem> added, IEnumerable<KeyValuePair<string, string>> metadata)
@@ -32,7 +32,7 @@ private ProjectItem VerifyAfterAddSingleItem(ObjectType where, ICollection<Proje
             Assert.NotNull(result);
 
             // validate there is exactly 1 item with this include in both view and real and it is the exact same object.
-            Assert.Same(result, this.GetSingleItemWithVerify(where, result.EvaluatedInclude));
+            Assert.Same(result, GetSingleItemWithVerify(where, result.EvaluatedInclude));
 
 
             if (metadata != null)
@@ -51,22 +51,22 @@ private ProjectItem VerifyAfterAddSingleItem(ObjectType where, ICollection<Proje
 
         public ProjectItem AddSingleItemWithVerify(ObjectType where, string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata = null)
         {
-            var toAdd = this.Get(where);
+            var toAdd = Get(where);
             var added = (metadata == null) ? toAdd.AddItem(itemType, unevaluatedInclude) : toAdd.AddItem(itemType, unevaluatedInclude, metadata);
             return VerifyAfterAddSingleItem(where, added, metadata);
         }
 
         public ProjectItem AddSingleItemFastWithVerify(ObjectType where, string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata = null)
         {
-            var toAdd = this.Get(where);
+            var toAdd = Get(where);
             var added = (metadata == null) ? toAdd.AddItemFast(itemType, unevaluatedInclude) : toAdd.AddItemFast(itemType, unevaluatedInclude, metadata);
             return VerifyAfterAddSingleItem(where, added, metadata);
         }
 
         public ProjectItem GetSingleItemWithVerify(ObjectType which, string evaluatedInclude)
         {
-            var realItems = this.Real.GetItemsByEvaluatedInclude(evaluatedInclude);
-            var viewItems = this.View.GetItemsByEvaluatedInclude(evaluatedInclude);
+            var realItems = Real.GetItemsByEvaluatedInclude(evaluatedInclude);
+            var viewItems = View.GetItemsByEvaluatedInclude(evaluatedInclude);
 
             ViewValidation.Verify(viewItems, realItems, ViewValidation.Verify, new ValidationContext(this));
             if (viewItems == null || viewItems.Count == 0)
@@ -80,14 +80,14 @@ public ProjectItem GetSingleItemWithVerify(ObjectType which, string evaluatedInc
 
         public ProjectProperty SetPropertyWithVerify(ObjectType where, string name, string unevaluatedValue)
         {
-            var toAdd = this.Get(where);
+            var toAdd = Get(where);
             var added = toAdd.SetProperty(name, unevaluatedValue);
             Assert.NotNull(added);
             Assert.Same(added, toAdd.GetProperty(name));
             Assert.Equal(unevaluatedValue, added.UnevaluatedValue);
 
-            var view = this.View.GetProperty(name);
-            var real = this.Real.GetProperty(name);
+            var view = View.GetProperty(name);
+            var real = Real.GetProperty(name);
             ViewValidation.Verify(view, real, new ValidationContext(this));
 
             return added;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
index 5edad4f2699..bbcb979597a 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
@@ -24,25 +24,25 @@ public class MyTestCollectionGroup : TestCollectionGroup
             public MyTestCollectionGroup()
                 : base(2, 0)
             {
-                this.Target = this.Remote[0];
-                this.Local.Importing = true;
+                Target = Remote[0];
+                Local.Importing = true;
             }
         }
 
         public MyTestCollectionGroup StdGroup { get; }
         public LinkedConstructionModify_Tests(MyTestCollectionGroup group)
         {
-            this.StdGroup = group;
+            StdGroup = group;
             group.Clear();
-            this.StdGroup.Local.Importing = true;
+            StdGroup.Local.Importing = true;
         }
 
         private ProjectPair GetNewInMemoryProject(string path)
         {
-            var tempPath = this.StdGroup.Disk.GetAbsolutePath(path);
-            var newReal = this.StdGroup.Target.LoadInMemoryWithSettings(TestCollectionGroup.SampleProjectFile);
+            var tempPath = StdGroup.Disk.GetAbsolutePath(path);
+            var newReal = StdGroup.Target.LoadInMemoryWithSettings(TestCollectionGroup.SampleProjectFile);
             newReal.Xml.FullPath = tempPath;
-            var newView = this.StdGroup.Local.GetLoadedProjects(tempPath).FirstOrDefault();
+            var newView = StdGroup.Local.GetLoadedProjects(tempPath).FirstOrDefault();
             Assert.NotNull(newView);
 
             ViewValidation.Verify(newView, newReal);
@@ -56,7 +56,7 @@ public void ProjectRootElementModify()
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
 
-            xmlPair.VerifySetter(this.StdGroup.Disk.GetAbsolutePath("tempRenamed"), (p) => p.FullPath, (p, v) => p.FullPath = v);
+            xmlPair.VerifySetter(StdGroup.Disk.GetAbsolutePath("tempRenamed"), (p) => p.FullPath, (p, v) => p.FullPath = v);
             xmlPair.VerifySetter("build", (p) => p.DefaultTargets, (p, v) => p.DefaultTargets = v);
             xmlPair.VerifySetter("init", (p) => p.InitialTargets, (p, v) => p.InitialTargets = v);
             xmlPair.VerifySetter("YetAnotherSDK", (p) => p.Sdk, (p, v) => p.Sdk = v);
@@ -65,9 +65,9 @@ public void ProjectRootElementModify()
 
             // Check PRE's Add"Foo" functionality.
             // grab some creation data
-            var newImport = this.StdGroup.Disk.GetAbsolutePath("import");
-            var newItem = this.StdGroup.Disk.GetAbsolutePath("newfile.cpp");
-            var newItemWithMetadata = this.StdGroup.Disk.GetAbsolutePath("newfile2.cpp");
+            var newImport = StdGroup.Disk.GetAbsolutePath("import");
+            var newItem = StdGroup.Disk.GetAbsolutePath("newfile.cpp");
+            var newItemWithMetadata = StdGroup.Disk.GetAbsolutePath("newfile2.cpp");
             List<KeyValuePair<string, string>> itemMetadata = new List<KeyValuePair<string, string>>()
             {
                 new KeyValuePair<string, string>("m1", "v1"),
@@ -76,58 +76,58 @@ public void ProjectRootElementModify()
             };
 
             // Imports
-            xmlPair.Add2NewChildrenWithVerify<ProjectImportElement>(newImport, (p, i) => p.AddImport(i), (pi, i) => pi.Project == i, out var import1, out var import2);
-            xmlPair.Add2NewLabeledChildrenWithVerify<ProjectImportGroupElement>("ImportGroupLabel", (p, l) => p.AddImportGroup(), out var importGroup1, out var importGroup2);
+            xmlPair.Add2NewChildrenWithVerify(newImport, (p, i) => p.AddImport(i), (pi, i) => pi.Project == i, out var import1, out var import2);
+            xmlPair.Add2NewLabeledChildrenWithVerify("ImportGroupLabel", (p, l) => p.AddImportGroup(), out var importGroup1, out var importGroup2);
 
             // Items
-            xmlPair.Add2NewChildrenWithVerify<ProjectItemElement>(newItem, (p, i) => p.AddItem("cpp", i), (pi, i) => pi.Include == i, out var item1, out var item2);
-            xmlPair.Add2NewChildrenWithVerify<ProjectItemElement>(newItemWithMetadata, (p, i) => p.AddItem("cpp", i, itemMetadata), (pi, i) => pi.Include == i, out var itemWithMetadata1, out var itemWithMetadata2);
+            xmlPair.Add2NewChildrenWithVerify(newItem, (p, i) => p.AddItem("cpp", i), (pi, i) => pi.Include == i, out var item1, out var item2);
+            xmlPair.Add2NewChildrenWithVerify(newItemWithMetadata, (p, i) => p.AddItem("cpp", i, itemMetadata), (pi, i) => pi.Include == i, out var itemWithMetadata1, out var itemWithMetadata2);
             ViewValidation.VerifyMetadata(itemMetadata, (k) => itemWithMetadata1.View.Metadata.Where((md) => md.Name == k).FirstOrDefault().Value);
-            xmlPair.Add2NewLabeledChildrenWithVerify<ProjectItemGroupElement>("ItemGroup", (p, l) => p.AddItemGroup(), out var itemGroup1, out var itemGroup2);
+            xmlPair.Add2NewLabeledChildrenWithVerify("ItemGroup", (p, l) => p.AddItemGroup(), out var itemGroup1, out var itemGroup2);
 
             // ItemDefs
-            xmlPair.Add2NewChildrenWithVerify<ProjectItemDefinitionElement>("cpp", (p, it) => p.AddItemDefinition(it), (pi, it) => pi.ItemType == it, out var itemDefinition1, out var itemDefinition2);
-            xmlPair.Add2NewLabeledChildrenWithVerify<ProjectItemDefinitionGroupElement>("ItemDefGroup", (p, l) => p.AddItemDefinitionGroup(), out var itemDefinitionGroup1, out var itemDefinitionGroup2);
+            xmlPair.Add2NewChildrenWithVerify("cpp", (p, it) => p.AddItemDefinition(it), (pi, it) => pi.ItemType == it, out var itemDefinition1, out var itemDefinition2);
+            xmlPair.Add2NewLabeledChildrenWithVerify("ItemDefGroup", (p, l) => p.AddItemDefinitionGroup(), out var itemDefinitionGroup1, out var itemDefinitionGroup2);
 
             // Property
-            xmlPair.Add2NewChildrenWithVerify<ProjectPropertyElement>("NewProp", (p, pn) => p.AddProperty(pn, $"Value{pn}"), (prop, pn) => prop.Name == pn, out var itemProp1, out var itemProp2);
-            xmlPair.Add2NewLabeledChildrenWithVerify<ProjectPropertyGroupElement>("NewPropGroup", (p, l) => p.AddPropertyGroup(), out var itemPropretyGroup1, out var itemPropretyGroup2);
+            xmlPair.Add2NewChildrenWithVerify("NewProp", (p, pn) => p.AddProperty(pn, $"Value{pn}"), (prop, pn) => prop.Name == pn, out var itemProp1, out var itemProp2);
+            xmlPair.Add2NewLabeledChildrenWithVerify("NewPropGroup", (p, l) => p.AddPropertyGroup(), out var itemPropretyGroup1, out var itemPropretyGroup2);
 
             // Target & Tasks
-            xmlPair.Add2NewChildrenWithVerify<ProjectTargetElement>("NewTarget", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n), out var newTarget1, out var newTarget2);
-            xmlPair.Add2NewChildrenWithVerify<ProjectUsingTaskElement>("NewUsingTaskFile", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => ut.TaskName == n, out var newUsinTaskFile1, out var newUsingTaskFile2);
-            xmlPair.Add2NewChildrenWithVerify<ProjectUsingTaskElement>("NewUsingTaskName", (p, n) => p.AddUsingTask(n, null, "assemblyName"), (ut, n) => ut.TaskName == n, out var newUsinTaskName1, out var newUsingTaskName2);
+            xmlPair.Add2NewChildrenWithVerify("NewTarget", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n), out var newTarget1, out var newTarget2);
+            xmlPair.Add2NewChildrenWithVerify("NewUsingTaskFile", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => ut.TaskName == n, out var newUsinTaskFile1, out var newUsingTaskFile2);
+            xmlPair.Add2NewChildrenWithVerify("NewUsingTaskName", (p, n) => p.AddUsingTask(n, null, "assemblyName"), (ut, n) => ut.TaskName == n, out var newUsinTaskName1, out var newUsingTaskName2);
 
             // loose create new element check.
 
-            xmlPair.CreateWithVerify<ProjectChooseElement>((p) => p.CreateChooseElement());
-            xmlPair.CreateWithVerify<ProjectImportElement>((p) => p.CreateImportElement("fooImport"));
-            xmlPair.CreateWithVerify<ProjectImportGroupElement>((p) => p.CreateImportGroupElement());
-            xmlPair.CreateWithVerify<ProjectItemDefinitionElement>((p) => p.CreateItemDefinitionElement("creteItemType"));
-            xmlPair.CreateWithVerify<ProjectItemDefinitionGroupElement>((p) => p.CreateItemDefinitionGroupElement());
-            xmlPair.CreateWithVerify<ProjectItemElement>((p) => p.CreateItemElement("itemType"));
-            xmlPair.CreateWithVerify<ProjectItemElement>((p) => p.CreateItemElement("itemType", "include"));
-            xmlPair.CreateWithVerify<ProjectItemGroupElement>((p) => p.CreateItemGroupElement());
-            xmlPair.CreateWithVerify<ProjectMetadataElement>((p) => p.CreateMetadataElement("metadataName"));
-            xmlPair.CreateWithVerify<ProjectMetadataElement>((p) => p.CreateMetadataElement("metadataName1", "value"));
-            xmlPair.CreateWithVerify<ProjectOnErrorElement>((p) => p.CreateOnErrorElement("target"));
-            xmlPair.CreateWithVerify<ProjectOtherwiseElement>((p) => p.CreateOtherwiseElement());
-            xmlPair.CreateWithVerify<ProjectOutputElement>((p) => p.CreateOutputElement("taskParam", "itemType", null));
-            xmlPair.CreateWithVerify<ProjectOutputElement>((p) => p.CreateOutputElement("taskParam", null, "propName"));
-            xmlPair.CreateWithVerify<ProjectExtensionsElement>((p) => p.CreateProjectExtensionsElement());
-            xmlPair.CreateWithVerify<ProjectSdkElement>((p) => p.CreateProjectSdkElement("sdkkk", "verrr"));
-            xmlPair.CreateWithVerify<ProjectPropertyElement>((p) => p.CreatePropertyElement("name"));
-            xmlPair.CreateWithVerify<ProjectPropertyGroupElement>((p) => p.CreatePropertyGroupElement());
-            xmlPair.CreateWithVerify<ProjectTargetElement>((p) => p.CreateTargetElement("target"));
-            xmlPair.CreateWithVerify<ProjectTaskElement>((p) => p.CreateTaskElement("task"));
-            xmlPair.CreateWithVerify<ProjectUsingTaskBodyElement>((p) => p.CreateUsingTaskBodyElement("eval", "body"));
-            xmlPair.CreateWithVerify<ProjectUsingTaskElement>((p) => p.CreateUsingTaskElement("taskName", "file", null));
-            xmlPair.CreateWithVerify<ProjectUsingTaskElement>((p) => p.CreateUsingTaskElement("taskName", null, "name"));
-            xmlPair.CreateWithVerify<ProjectUsingTaskElement>((p) => p.CreateUsingTaskElement("taskName", "file", null, "runtime", "arch"));
-            xmlPair.CreateWithVerify<ProjectUsingTaskElement>((p) => p.CreateUsingTaskElement("taskName", null, "name", "runtime", "arch"));
-            xmlPair.CreateWithVerify<ProjectUsingTaskParameterElement>((p) => p.CreateUsingTaskParameterElement("name", "output", "required", "paramType"));
-            xmlPair.CreateWithVerify<UsingTaskParameterGroupElement>((p) => p.CreateUsingTaskParameterGroupElement());
-            xmlPair.CreateWithVerify<ProjectWhenElement>((p) => p.CreateWhenElement("condition"));
+            xmlPair.CreateWithVerify((p) => p.CreateChooseElement());
+            xmlPair.CreateWithVerify((p) => p.CreateImportElement("fooImport"));
+            xmlPair.CreateWithVerify((p) => p.CreateImportGroupElement());
+            xmlPair.CreateWithVerify((p) => p.CreateItemDefinitionElement("creteItemType"));
+            xmlPair.CreateWithVerify((p) => p.CreateItemDefinitionGroupElement());
+            xmlPair.CreateWithVerify((p) => p.CreateItemElement("itemType"));
+            xmlPair.CreateWithVerify((p) => p.CreateItemElement("itemType", "include"));
+            xmlPair.CreateWithVerify((p) => p.CreateItemGroupElement());
+            xmlPair.CreateWithVerify((p) => p.CreateMetadataElement("metadataName"));
+            xmlPair.CreateWithVerify((p) => p.CreateMetadataElement("metadataName1", "value"));
+            xmlPair.CreateWithVerify((p) => p.CreateOnErrorElement("target"));
+            xmlPair.CreateWithVerify((p) => p.CreateOtherwiseElement());
+            xmlPair.CreateWithVerify((p) => p.CreateOutputElement("taskParam", "itemType", null));
+            xmlPair.CreateWithVerify((p) => p.CreateOutputElement("taskParam", null, "propName"));
+            xmlPair.CreateWithVerify((p) => p.CreateProjectExtensionsElement());
+            xmlPair.CreateWithVerify((p) => p.CreateProjectSdkElement("sdkkk", "verrr"));
+            xmlPair.CreateWithVerify((p) => p.CreatePropertyElement("name"));
+            xmlPair.CreateWithVerify((p) => p.CreatePropertyGroupElement());
+            xmlPair.CreateWithVerify((p) => p.CreateTargetElement("target"));
+            xmlPair.CreateWithVerify((p) => p.CreateTaskElement("task"));
+            xmlPair.CreateWithVerify((p) => p.CreateUsingTaskBodyElement("eval", "body"));
+            xmlPair.CreateWithVerify((p) => p.CreateUsingTaskElement("taskName", "file", null));
+            xmlPair.CreateWithVerify((p) => p.CreateUsingTaskElement("taskName", null, "name"));
+            xmlPair.CreateWithVerify((p) => p.CreateUsingTaskElement("taskName", "file", null, "runtime", "arch"));
+            xmlPair.CreateWithVerify((p) => p.CreateUsingTaskElement("taskName", null, "name", "runtime", "arch"));
+            xmlPair.CreateWithVerify((p) => p.CreateUsingTaskParameterElement("name", "output", "required", "paramType"));
+            xmlPair.CreateWithVerify((p) => p.CreateUsingTaskParameterGroupElement());
+            xmlPair.CreateWithVerify((p) => p.CreateWhenElement("condition"));
 
             // DeepClone
             var clone = xmlPair.View.DeepClone();
@@ -145,22 +145,22 @@ public void ProjectTargetElementModify()
 
             // create new target
             const string NewTargetName = "NewTargetName";
-            var newTarget1 = xmlPair.AddNewChaildWithVerify<ProjectTargetElement>(ObjectType.View, NewTargetName, (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
+            var newTarget1 = xmlPair.AddNewChaildWithVerify(ObjectType.View, NewTargetName, (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
 
             // add tasks to target
             const string NewTaskName = "NewTaskName";
-            newTarget1.Add2NewNamedChildrenWithVerify<ProjectTaskElement>(NewTaskName, (t, n) => t.AddTask(n), out var newTask1, out var newTask2);
+            newTarget1.Add2NewNamedChildrenWithVerify(NewTaskName, (t, n) => t.AddTask(n), out var newTask1, out var newTask2);
 
             // Add item groups
             const string NewTargetItemGroup = "NewTargetItemGroup";
-            newTarget1.Add2NewLabeledChildrenWithVerify<ProjectItemGroupElement>(NewTargetItemGroup, (t, l) => t.AddItemGroup(), out var newItemGroup1, out var newItemGroup2);
+            newTarget1.Add2NewLabeledChildrenWithVerify(NewTargetItemGroup, (t, l) => t.AddItemGroup(), out var newItemGroup1, out var newItemGroup2);
 
             // Add property groups
             const string NewPropertyGroup = "NewPropertyGroup";
-            newTarget1.Add2NewLabeledChildrenWithVerify<ProjectPropertyGroupElement>(NewPropertyGroup, (t, l) => t.AddPropertyGroup(), out var newPropertyGroup1, out var newPropertyGroup2);
+            newTarget1.Add2NewLabeledChildrenWithVerify(NewPropertyGroup, (t, l) => t.AddPropertyGroup(), out var newPropertyGroup1, out var newPropertyGroup2);
 
             // Add property groups
-            newTarget1.Append2NewChildrenWithVerify<ProjectOnErrorElement>("errTarget", (p, et) => p.CreateOnErrorElement(et), (oe, et) => oe.ExecuteTargetsAttribute == et, out var newOnErr1, out var newOnErr2);
+            newTarget1.Append2NewChildrenWithVerify("errTarget", (p, et) => p.CreateOnErrorElement(et), (oe, et) => oe.ExecuteTargetsAttribute == et, out var newOnErr1, out var newOnErr2);
 
 
             // string setters
@@ -220,29 +220,29 @@ public void ProjectTaskElementModify()
             // create new target
             const string NewTasktName = "NewTaskName";
 
-            var newTarget = xmlPair.AddNewChaildWithVerify<ProjectTargetElement>(ObjectType.View, "TargetToTestTask", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
-            var newTask = newTarget.AddNewNamedChaildWithVerify<ProjectTaskElement>(ObjectType.View, NewTasktName, (t, n) => t.AddTask(n));
+            var newTarget = xmlPair.AddNewChaildWithVerify(ObjectType.View, "TargetToTestTask", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
+            var newTask = newTarget.AddNewNamedChaildWithVerify(ObjectType.View, NewTasktName, (t, n) => t.AddTask(n));
 
             Assert.Equal(0, newTask.View.Outputs.Count);
             const string NewOutputItem = "NewOutputItem";
-            newTask.Add2NewChildrenWithVerify<ProjectOutputElement>(NewOutputItem, (t, n) => t.AddOutputItem(n, "CPP"), (oi, n) => oi.TaskParameter == n, out var newOutputItem1, out var newOutputItem2);
+            newTask.Add2NewChildrenWithVerify(NewOutputItem, (t, n) => t.AddOutputItem(n, "CPP"), (oi, n) => oi.TaskParameter == n, out var newOutputItem1, out var newOutputItem2);
             Assert.True(newOutputItem1.View.IsOutputItem);
             Assert.False(newOutputItem1.View.IsOutputProperty);
 
 
             const string NewOutputItemWithConfig = "NewOutputItemCfg";
-            newTask.Add2NewChildrenWithVerify<ProjectOutputElement>(NewOutputItemWithConfig, (t, n) => t.AddOutputItem(n, "source", "'Configuration'='Foo'"), (oi, n) => oi.TaskParameter == n, out var newOutputItemWithConfig1, out var newOutputItemWithConfig2);
+            newTask.Add2NewChildrenWithVerify(NewOutputItemWithConfig, (t, n) => t.AddOutputItem(n, "source", "'Configuration'='Foo'"), (oi, n) => oi.TaskParameter == n, out var newOutputItemWithConfig1, out var newOutputItemWithConfig2);
             Assert.True(newOutputItemWithConfig1.View.IsOutputItem);
             Assert.False(newOutputItemWithConfig1.View.IsOutputProperty);
 
             const string NewOutputProperty = "NewOutputProperty";
-            newTask.Add2NewChildrenWithVerify<ProjectOutputElement>(NewOutputProperty, (t, n) => t.AddOutputProperty(n, "taskprop"), (oi, n) => oi.TaskParameter == n, out var newOutputProp1, out var newOutputProp2);
+            newTask.Add2NewChildrenWithVerify(NewOutputProperty, (t, n) => t.AddOutputProperty(n, "taskprop"), (oi, n) => oi.TaskParameter == n, out var newOutputProp1, out var newOutputProp2);
             Assert.False(newOutputProp1.View.IsOutputItem);
             Assert.True(newOutputProp1.View.IsOutputProperty);
 
 
             const string NewOutputPropertyWithConfig = "NewOutputPropertyCfg";
-            newTask.Add2NewChildrenWithVerify<ProjectOutputElement>(NewOutputPropertyWithConfig, (t, n) => t.AddOutputProperty(n, "source", "'Configuration'='Foo'"), (oi, n) => oi.TaskParameter == n, out var newOutputPropWithConfig1, out var newOutputPropWithConfig2);
+            newTask.Add2NewChildrenWithVerify(NewOutputPropertyWithConfig, (t, n) => t.AddOutputProperty(n, "source", "'Configuration'='Foo'"), (oi, n) => oi.TaskParameter == n, out var newOutputPropWithConfig1, out var newOutputPropWithConfig2);
             Assert.False(newOutputPropWithConfig1.View.IsOutputItem);
             Assert.True(newOutputPropWithConfig1.View.IsOutputProperty);
 
@@ -316,19 +316,19 @@ public void ProjectOutputElementModify()
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
 
-            var newTarget = xmlPair.AddNewChaildWithVerify<ProjectTargetElement>(ObjectType.View, "TargetToTestTask", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
-            var newTask = newTarget.AddNewNamedChaildWithVerify<ProjectTaskElement>(ObjectType.Real, "NewTaskName", (t, n) => t.AddTask(n));
+            var newTarget = xmlPair.AddNewChaildWithVerify(ObjectType.View, "TargetToTestTask", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
+            var newTask = newTarget.AddNewNamedChaildWithVerify(ObjectType.Real, "NewTaskName", (t, n) => t.AddTask(n));
 
             const string NewOutputItem = "NewOutputItem";
             const string ItemType = "CPPSource";
-            var newOutputItem = newTask.AddNewChaildWithVerify<ProjectOutputElement>(ObjectType.View, NewOutputItem, (t, n) => t.AddOutputItem(n, ItemType), (oi, n) => oi.TaskParameter == n);
+            var newOutputItem = newTask.AddNewChaildWithVerify(ObjectType.View, NewOutputItem, (t, n) => t.AddOutputItem(n, ItemType), (oi, n) => oi.TaskParameter == n);
 
             Assert.True(newOutputItem.View.IsOutputItem);
             Assert.False(newOutputItem.View.IsOutputProperty);
 
             const string NewOutputProperty = "NewOutputProperty";
             const string PropertyName = "OutputPropName";
-            var newOutputProp = newTask.AddNewChaildWithVerify<ProjectOutputElement>(ObjectType.View, NewOutputProperty, (t, n) => t.AddOutputProperty(n, PropertyName), (oi, n) => oi.TaskParameter == n);
+            var newOutputProp = newTask.AddNewChaildWithVerify(ObjectType.View, NewOutputProperty, (t, n) => t.AddOutputProperty(n, PropertyName), (oi, n) => oi.TaskParameter == n);
             Assert.False(newOutputProp.View.IsOutputItem);
             Assert.True(newOutputProp.View.IsOutputProperty);
 
@@ -348,8 +348,8 @@ public void ProjectMetadataElementModify()
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
 
-            var item1 = xmlPair.AddNewChaildWithVerify<ProjectItemElement>(ObjectType.View, "newItem", (p, i) => p.AddItem("cpp", i), (pi, i) => pi.Include == i);
-            var metadata = item1.AddNewChaildWithVerify<ProjectMetadataElement>(ObjectType.View, "metadata", (p, n) => p.AddMetadata(n, "value"), (md, n) => md.Name == n);
+            var item1 = xmlPair.AddNewChaildWithVerify(ObjectType.View, "newItem", (p, i) => p.AddItem("cpp", i), (pi, i) => pi.Include == i);
+            var metadata = item1.AddNewChaildWithVerify(ObjectType.View, "metadata", (p, n) => p.AddMetadata(n, "value"), (md, n) => md.Name == n);
 
             metadata.VerifySetter("NewValue", (md) => md.Value, (md, v) => md.Value = v);
             metadata.VerifySetter("NewName", (md) => md.Name, (md, v) => md.Name = v);
@@ -367,7 +367,7 @@ public void ProjectChooseElementModify()
             var xmlPair = new ProjectXmlPair(pair);
 
             // slightly more verbose to validate some Create/Append intended semantic.
-            var chooseCreataed = xmlPair.CreateWithVerify<ProjectChooseElement>((p) => p.CreateChooseElement());
+            var chooseCreataed = xmlPair.CreateWithVerify((p) => p.CreateChooseElement());
             xmlPair.QueryChildrenWithValidation<ProjectChooseElement>((pc) => true, 0);
 
             xmlPair.View.AppendChild(chooseCreataed.View);
@@ -381,14 +381,14 @@ public void ProjectChooseElementModify()
             Assert.ThrowsAny<InvalidOperationException>(() => choose.View.Condition = "ccc");
 
             Assert.Empty(choose.View.WhenElements);
-            choose.Append2NewLabeledChildrenWithVerify<ProjectWhenElement>("when", (p, l) => p.CreateWhenElement($"'$(c)' == '{l}'"), out var when1, out var when2);
+            choose.Append2NewLabeledChildrenWithVerify("when", (p, l) => p.CreateWhenElement($"'$(c)' == '{l}'"), out var when1, out var when2);
             Assert.Equal(2, choose.View.WhenElements.Count);
             when1.VerifySame(choose.QuerySingleChildrenWithValidation<ProjectWhenElement>((ch) => ch.Label == when1.View.Label));
             when2.VerifySame(choose.QuerySingleChildrenWithValidation<ProjectWhenElement>((ch) => ch.Label == when2.View.Label));
 
             Assert.Null(choose.View.OtherwiseElement);
 
-            var otherWise = choose.AppendNewChaildWithVerify<ProjectOtherwiseElement>(ObjectType.View, "when", (p, l) => p.CreateOtherwiseElement(), (p, l) => true);
+            var otherWise = choose.AppendNewChaildWithVerify(ObjectType.View, "when", (p, l) => p.CreateOtherwiseElement(), (p, l) => true);
             Assert.Same(otherWise.View, choose.View.OtherwiseElement);
             Assert.Same(otherWise.Real, choose.Real.OtherwiseElement);
 
@@ -410,20 +410,20 @@ public void ProjectWhenElementModify()
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
 
-            var choose = xmlPair.AppendNewChaildWithVerify<ProjectChooseElement>(ObjectType.View, "choose", (p, s) => p.CreateChooseElement(), (p, s) => true);
-            var when = choose.AppendNewChaildWithVerify<ProjectWhenElement>(ObjectType.View, "when", (p, s) => p.CreateWhenElement("true"), (p, s) => true);
+            var choose = xmlPair.AppendNewChaildWithVerify(ObjectType.View, "choose", (p, s) => p.CreateChooseElement(), (p, s) => true);
+            var when = choose.AppendNewChaildWithVerify(ObjectType.View, "when", (p, s) => p.CreateWhenElement("true"), (p, s) => true);
 
             when.VerifySetter("Condition", (we) => we.Condition, (we, v) => we.Condition = v);
             Assert.Empty(when.View.ChooseElements);
-            when.Append2NewLabeledChildrenWithVerify<ProjectChooseElement>("choose", (p, l) => p.CreateChooseElement(), out var choose1, out var choose2);
+            when.Append2NewLabeledChildrenWithVerify("choose", (p, l) => p.CreateChooseElement(), out var choose1, out var choose2);
             Assert.Equal(2, when.View.ChooseElements.Count);
 
             Assert.Empty(when.View.ItemGroups);
-            when.Append2NewLabeledChildrenWithVerify<ProjectItemGroupElement>("itemGroup", (p, l) => p.CreateItemGroupElement(), out var itemGroup1, out var itemGroup2);
+            when.Append2NewLabeledChildrenWithVerify("itemGroup", (p, l) => p.CreateItemGroupElement(), out var itemGroup1, out var itemGroup2);
             Assert.Equal(2, when.View.ItemGroups.Count);
 
             Assert.Empty(when.View.PropertyGroups);
-            when.Append2NewLabeledChildrenWithVerify<ProjectPropertyGroupElement>("propGroup", (p, l) => p.CreatePropertyGroupElement(), out var propGroup1, out var propGroup2);
+            when.Append2NewLabeledChildrenWithVerify("propGroup", (p, l) => p.CreatePropertyGroupElement(), out var propGroup1, out var propGroup2);
             Assert.Equal(2, when.View.PropertyGroups.Count);
 
             when.Verify(); // will verify all collections.
@@ -449,19 +449,19 @@ public void ProjectOtherwiseElementModify()
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
 
-            var choose = xmlPair.AppendNewChaildWithVerify<ProjectChooseElement>(ObjectType.View, "choose", (p, s) => p.CreateChooseElement(), (p, s) => true);
-            var otherwise = choose.AppendNewChaildWithVerify<ProjectOtherwiseElement>(ObjectType.View, "when", (p, s) => p.CreateOtherwiseElement(), (p, s) => true);
+            var choose = xmlPair.AppendNewChaildWithVerify(ObjectType.View, "choose", (p, s) => p.CreateChooseElement(), (p, s) => true);
+            var otherwise = choose.AppendNewChaildWithVerify(ObjectType.View, "when", (p, s) => p.CreateOtherwiseElement(), (p, s) => true);
 
             Assert.Empty(otherwise.View.ChooseElements);
-            otherwise.Append2NewLabeledChildrenWithVerify<ProjectChooseElement>("choose", (p, l) => p.CreateChooseElement(), out var choose1, out var choose2);
+            otherwise.Append2NewLabeledChildrenWithVerify("choose", (p, l) => p.CreateChooseElement(), out var choose1, out var choose2);
             Assert.Equal(2, otherwise.View.ChooseElements.Count);
 
             Assert.Empty(otherwise.View.ItemGroups);
-            otherwise.Append2NewLabeledChildrenWithVerify<ProjectItemGroupElement>("itemGroup", (p, l) => p.CreateItemGroupElement(), out var itemGroup1, out var itemGroup2);
+            otherwise.Append2NewLabeledChildrenWithVerify("itemGroup", (p, l) => p.CreateItemGroupElement(), out var itemGroup1, out var itemGroup2);
             Assert.Equal(2, otherwise.View.ItemGroups.Count);
 
             Assert.Empty(otherwise.View.PropertyGroups);
-            otherwise.Append2NewLabeledChildrenWithVerify<ProjectPropertyGroupElement>("propGroup", (p, l) => p.CreatePropertyGroupElement(), out var propGroup1, out var propGroup2);
+            otherwise.Append2NewLabeledChildrenWithVerify("propGroup", (p, l) => p.CreatePropertyGroupElement(), out var propGroup1, out var propGroup2);
             Assert.Equal(2, otherwise.View.PropertyGroups.Count);
 
             otherwise.Verify(); // will verify all collections.
@@ -485,7 +485,7 @@ public void ProjectUsingTaskElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var usingTaskFile = xmlPair.AddNewChaildWithVerify<ProjectUsingTaskElement>(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => true);
+            var usingTaskFile = xmlPair.AddNewChaildWithVerify(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => true);
 
             usingTaskFile.VerifySetter("newArgch", (ut) => ut.Architecture, (ut, v) => ut.Architecture = v);
             usingTaskFile.VerifySetter("newTaskFactory", (ut) => ut.TaskFactory, (ut, v) => ut.TaskFactory = v);
@@ -497,19 +497,19 @@ public void ProjectUsingTaskElementModify()
             usingTaskFile.VerifySetter("newRuntime", (ut) => ut.Runtime, (ut, v) => ut.Runtime = v);
 
             Assert.Null(usingTaskFile.View.TaskBody);
-            var body = usingTaskFile.AddNewChaildWithVerify<ProjectUsingTaskBodyElement>(ObjectType.View, "eval", (ut, e) => ut.AddUsingTaskBody(e, "body"), (ut, e) => true);
+            var body = usingTaskFile.AddNewChaildWithVerify(ObjectType.View, "eval", (ut, e) => ut.AddUsingTaskBody(e, "body"), (ut, e) => true);
             Assert.Same(body.View, usingTaskFile.View.TaskBody);
             Assert.Same(body.Real, usingTaskFile.Real.TaskBody);
 
             Assert.Null(usingTaskFile.View.ParameterGroup);
-            var pg = usingTaskFile.AddNewChaildWithVerify<UsingTaskParameterGroupElement>(ObjectType.View, "pg", (ut, e) => ut.AddParameterGroup(), (ut, e) => true);
+            var pg = usingTaskFile.AddNewChaildWithVerify(ObjectType.View, "pg", (ut, e) => ut.AddParameterGroup(), (ut, e) => true);
             Assert.Same(pg.View, usingTaskFile.View.ParameterGroup);
             Assert.Same(pg.Real, usingTaskFile.Real.ParameterGroup);
 
 
             xmlPair.View.RemoveChild(usingTaskFile.View);
 
-            var usingTaskName = xmlPair.AddNewChaildWithVerify<ProjectUsingTaskElement>(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, null, "assemblyName"), (ut, n) => true);
+            var usingTaskName = xmlPair.AddNewChaildWithVerify(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, null, "assemblyName"), (ut, n) => true);
             usingTaskName.VerifySetter("newAssemblyName", (ut) => ut.AssemblyName, (ut, v) => ut.AssemblyName = v);
             Assert.ThrowsAny<InvalidOperationException>(() => usingTaskName.View.AssemblyFile = "xxx");
         }
@@ -519,10 +519,10 @@ public void ProjectUsingTaskBodyElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var usingTask = xmlPair.AddNewChaildWithVerify<ProjectUsingTaskElement>(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => true);
+            var usingTask = xmlPair.AddNewChaildWithVerify(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => true);
             // to add task body we need usingTask with factory.
             usingTask.VerifySetter("TaskFactory", (ut) => ut.TaskFactory, (ut, v) => ut.TaskFactory = v);
-            var taskBody = usingTask.AddNewChaildWithVerify<ProjectUsingTaskBodyElement>(ObjectType.View, "eval", (ut, e) => ut.AddUsingTaskBody(e, "body"), (ut, e) => true);
+            var taskBody = usingTask.AddNewChaildWithVerify(ObjectType.View, "eval", (ut, e) => ut.AddUsingTaskBody(e, "body"), (ut, e) => true);
 
 
             taskBody.VerifySetter("newBody", (tb) => tb.TaskBody, (tb, v) => tb.TaskBody = v);
@@ -534,16 +534,16 @@ public void UsingTaskParameterGroupElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var usingTask = xmlPair.AddNewChaildWithVerify<ProjectUsingTaskElement>(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => true);
+            var usingTask = xmlPair.AddNewChaildWithVerify(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => true);
             // to add task param group we need usingTask with factory.
             usingTask.VerifySetter("TaskFactory", (ut) => ut.TaskFactory, (ut, v) => ut.TaskFactory = v);
-            var taskParamGroup = usingTask.AddNewChaildWithVerify<UsingTaskParameterGroupElement>(ObjectType.View, "pg", (ut, e) => ut.AddParameterGroup(), (ut, e) => true);
+            var taskParamGroup = usingTask.AddNewChaildWithVerify(ObjectType.View, "pg", (ut, e) => ut.AddParameterGroup(), (ut, e) => true);
 
             Assert.Empty(taskParamGroup.View.Parameters);
 
-            taskParamGroup.Add2NewNamedChildrenWithVerify<ProjectUsingTaskParameterElement>("paraX", (tpg, n) => tpg.AddParameter(n), out var paraX1, out var paraX2);
+            taskParamGroup.Add2NewNamedChildrenWithVerify("paraX", (tpg, n) => tpg.AddParameter(n), out var paraX1, out var paraX2);
             Assert.Equal(2, taskParamGroup.View.Parameters.Count);
-            taskParamGroup.Add2NewNamedChildrenWithVerify<ProjectUsingTaskParameterElement>("paraY", (tpg, n) => tpg.AddParameter(n, "output", "required", "type"), out var paraY1, out var paraY2);
+            taskParamGroup.Add2NewNamedChildrenWithVerify("paraY", (tpg, n) => tpg.AddParameter(n, "output", "required", "type"), out var paraY1, out var paraY2);
             Assert.Equal(4, taskParamGroup.View.Parameters.Count);
 
             taskParamGroup.Verify();
@@ -555,10 +555,10 @@ public void ProjectUsingTaskParameterElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var usingTask = xmlPair.AddNewChaildWithVerify<ProjectUsingTaskElement>(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => true);
+            var usingTask = xmlPair.AddNewChaildWithVerify(ObjectType.View, "NewUsingTask", (p, n) => p.AddUsingTask(n, "assemblyFile", null), (ut, n) => true);
             usingTask.VerifySetter("TaskFactory", (ut) => ut.TaskFactory, (ut, v) => ut.TaskFactory = v);
-            var taskParamGroup = usingTask.AddNewChaildWithVerify<UsingTaskParameterGroupElement>(ObjectType.View, "pg", (ut, e) => ut.AddParameterGroup(), (ut, e) => true);
-            var paraElement = taskParamGroup.AddNewNamedChaildWithVerify<ProjectUsingTaskParameterElement>(ObjectType.View, "param", (tpg, n) => tpg.AddParameter(n));
+            var taskParamGroup = usingTask.AddNewChaildWithVerify(ObjectType.View, "pg", (ut, e) => ut.AddParameterGroup(), (ut, e) => true);
+            var paraElement = taskParamGroup.AddNewNamedChaildWithVerify(ObjectType.View, "param", (tpg, n) => tpg.AddParameter(n));
 
             paraElement.VerifySetter("newName", (pe) => pe.Name, (pe, v) => pe.Name = v);
             paraElement.VerifySetter("newParaType", (pe) => pe.ParameterType, (pe, v) => pe.ParameterType = v);
@@ -571,7 +571,7 @@ public void ProjectExtensionsElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var extensionXml = xmlPair.AppendNewChaildWithVerify<ProjectExtensionsElement>(ObjectType.View, "ext", (p, s) => p.CreateProjectExtensionsElement(), (pe, s) => true);
+            var extensionXml = xmlPair.AppendNewChaildWithVerify(ObjectType.View, "ext", (p, s) => p.CreateProjectExtensionsElement(), (pe, s) => true);
 
             extensionXml.VerifySetter("bla bla bla", (e) => e.Content, (e, v) => e.Content = v);
         }
@@ -581,7 +581,7 @@ public void ProjectImportElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var import = xmlPair.AddNewChaildWithVerify<ProjectImportElement>(ObjectType.View, "import", (p, s) => p.AddImport(s), (pe, s) => true);
+            var import = xmlPair.AddNewChaildWithVerify(ObjectType.View, "import", (p, s) => p.AddImport(s), (pe, s) => true);
 
             import.VerifySetter("newImport", (pi) => pi.Project, (pi, v) => pi.Project = v);
             import.VerifySetter("newSdk", (pi) => pi.Sdk, (pi, v) => pi.Sdk = v);
@@ -595,11 +595,11 @@ public void ProjectImportGroupElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var importGroup = xmlPair.AddNewChaildWithVerify<ProjectImportGroupElement>(ObjectType.View, "import", (p, s) => p.AddImportGroup(), (pe, s) => true);
+            var importGroup = xmlPair.AddNewChaildWithVerify(ObjectType.View, "import", (p, s) => p.AddImportGroup(), (pe, s) => true);
 
             Assert.Empty(importGroup.View.Imports);
 
-            importGroup.Add2NewChildrenWithVerify<ProjectImportElement>("projFile", (ig, prj) => ig.AddImport(prj), (i, prj) => i.Project == prj, out var imp1, out var imp2);
+            importGroup.Add2NewChildrenWithVerify("projFile", (ig, prj) => ig.AddImport(prj), (i, prj) => i.Project == prj, out var imp1, out var imp2);
             Assert.Equal(2, importGroup.View.Imports.Count);
         }
 
@@ -608,17 +608,17 @@ public void ProjectItemDefinitionElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var itemDef = xmlPair.AddNewChaildWithVerify<ProjectItemDefinitionElement>(ObjectType.View, "source", (p, s) => p.AddItemDefinition(s), (pe, s) => true);
+            var itemDef = xmlPair.AddNewChaildWithVerify(ObjectType.View, "source", (p, s) => p.AddItemDefinition(s), (pe, s) => true);
             Assert.Equal("source", itemDef.View.ItemType);
 
             Assert.Empty(itemDef.View.Metadata);
 
-            itemDef.Add2NewChildrenWithVerify<ProjectMetadataElement>("mshort", (id, n) => id.AddMetadata(n, $"value{n}"), (md, n) => md.Name == n, out var mdShort1, out var mdShort2);
+            itemDef.Add2NewChildrenWithVerify("mshort", (id, n) => id.AddMetadata(n, $"value{n}"), (md, n) => md.Name == n, out var mdShort1, out var mdShort2);
             Assert.Equal(2, itemDef.View.Metadata.Count);
-            itemDef.Add2NewChildrenWithVerify<ProjectMetadataElement>("mlong", (id, n) => id.AddMetadata(n, $"value{n}", false), (md, n) => md.Name == n, out var mdLong1, out var mdLong2);
+            itemDef.Add2NewChildrenWithVerify("mlong", (id, n) => id.AddMetadata(n, $"value{n}", false), (md, n) => md.Name == n, out var mdLong1, out var mdLong2);
             Assert.Equal(4, itemDef.View.Metadata.Count);
 
-            itemDef.Add2NewChildrenWithVerify<ProjectMetadataElement>("mlongAttrib", (id, n) => id.AddMetadata(n, $"value{n}", true), (md, n) => md.Name == n, out var mdAttrib1, out var mdAttrib2);
+            itemDef.Add2NewChildrenWithVerify("mlongAttrib", (id, n) => id.AddMetadata(n, $"value{n}", true), (md, n) => md.Name == n, out var mdAttrib1, out var mdAttrib2);
             Assert.Equal(6, itemDef.View.Metadata.Count);
         }
 
@@ -627,10 +627,10 @@ public void ProjectItemDefinitionGroupElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var itemDefGrp = xmlPair.AddNewChaildWithVerify<ProjectItemDefinitionGroupElement>(ObjectType.View, "grp", (p, s) => p.AddItemDefinitionGroup(), (pe, s) => true);
+            var itemDefGrp = xmlPair.AddNewChaildWithVerify(ObjectType.View, "grp", (p, s) => p.AddItemDefinitionGroup(), (pe, s) => true);
 
             Assert.Empty(itemDefGrp.View.ItemDefinitions);
-            itemDefGrp.Add2NewChildrenWithVerify<ProjectItemDefinitionElement>("src", (idg, it) => idg.AddItemDefinition(it), (id, n) => id.ItemType == n, out var itemDef1, out var itemDef2);
+            itemDefGrp.Add2NewChildrenWithVerify("src", (idg, it) => idg.AddItemDefinition(it), (id, n) => id.ItemType == n, out var itemDef1, out var itemDef2);
             Assert.Equal(2, itemDefGrp.View.ItemDefinitions.Count);
         }
 
@@ -639,11 +639,11 @@ public void ProjectItemElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var target = xmlPair.AddNewChaildWithVerify<ProjectTargetElement>(ObjectType.View, "NewTarget", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
-            var itemGrp = target.AddNewLabeledChaildWithVerify<ProjectItemGroupElement>(ObjectType.View, "tagetigrp", (p, s) => p.AddItemGroup());
-            var itemInTargt = itemGrp.AddNewChaildWithVerify<ProjectItemElement>(ObjectType.View, "targetfile.cs", (p, s) => p.AddItem("cs", s), (pe, s) => pe.Include == s);
+            var target = xmlPair.AddNewChaildWithVerify(ObjectType.View, "NewTarget", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
+            var itemGrp = target.AddNewLabeledChaildWithVerify(ObjectType.View, "tagetigrp", (p, s) => p.AddItemGroup());
+            var itemInTargt = itemGrp.AddNewChaildWithVerify(ObjectType.View, "targetfile.cs", (p, s) => p.AddItem("cs", s), (pe, s) => pe.Include == s);
 
-            var item = xmlPair.AddNewChaildWithVerify<ProjectItemElement>(ObjectType.View, "file.cpp", (p, s) => p.AddItem("cpp", s), (pe, s) => pe.Include == s);
+            var item = xmlPair.AddNewChaildWithVerify(ObjectType.View, "file.cpp", (p, s) => p.AddItem("cpp", s), (pe, s) => pe.Include == s);
 
             item.VerifySetter("newInclude", (i) => i.Include, (i, v) => i.Include = v);
             item.VerifySetter("newExclude", (i) => i.Exclude, (i, v) => i.Exclude = v);
@@ -669,11 +669,11 @@ public void ProjectItemElementModify()
             Assert.False(item.View.HasMetadata);
             Assert.Empty(item.View.Metadata);
 
-            item.Add2NewChildrenWithVerify<ProjectMetadataElement>("mshort", (id, n) => id.AddMetadata(n, $"value{n}"), (md, n) => md.Name == n, out var mdShort1, out var mdShort2);
+            item.Add2NewChildrenWithVerify("mshort", (id, n) => id.AddMetadata(n, $"value{n}"), (md, n) => md.Name == n, out var mdShort1, out var mdShort2);
             Assert.Equal(2, item.View.Metadata.Count);
-            item.Add2NewChildrenWithVerify<ProjectMetadataElement>("mlong", (id, n) => id.AddMetadata(n, $"value{n}", false), (md, n) => md.Name == n, out var mdLong1, out var mdLong2);
+            item.Add2NewChildrenWithVerify("mlong", (id, n) => id.AddMetadata(n, $"value{n}", false), (md, n) => md.Name == n, out var mdLong1, out var mdLong2);
             Assert.Equal(4, item.View.Metadata.Count);
-            item.Add2NewChildrenWithVerify<ProjectMetadataElement>("mlongAttrib", (id, n) => id.AddMetadata(n, $"value{n}", true), (md, n) => md.Name == n, out var mdAttrib1, out var mdAttrib2);
+            item.Add2NewChildrenWithVerify("mlongAttrib", (id, n) => id.AddMetadata(n, $"value{n}", true), (md, n) => md.Name == n, out var mdAttrib1, out var mdAttrib2);
             Assert.Equal(6, item.View.Metadata.Count);
 
 
@@ -691,10 +691,10 @@ public void ProjectItemGroupElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var itemGrp = xmlPair.AddNewLabeledChaildWithVerify<ProjectItemGroupElement>(ObjectType.View, "igrp", (p, s) => p.AddItemGroup());
+            var itemGrp = xmlPair.AddNewLabeledChaildWithVerify(ObjectType.View, "igrp", (p, s) => p.AddItemGroup());
 
             Assert.Empty(itemGrp.View.Items);
-            itemGrp.Add2NewChildrenWithVerify<ProjectItemElement>("file.cpp", (ig, inc) => ig.AddItem("cpp", inc), (i, inc) => i.Include == inc, out var item1, out var item2);
+            itemGrp.Add2NewChildrenWithVerify("file.cpp", (ig, inc) => ig.AddItem("cpp", inc), (i, inc) => i.Include == inc, out var item1, out var item2);
             Assert.Equal(2, itemGrp.View.Items.Count);
 
             List<KeyValuePair<string, string>> itemMetadata = new List<KeyValuePair<string, string>>()
@@ -702,7 +702,7 @@ public void ProjectItemGroupElementModify()
                 new KeyValuePair<string, string>("igm1", "v1"),
                 new KeyValuePair<string, string>("igm2", "v2"),
             };
-            itemGrp.Add2NewChildrenWithVerify<ProjectItemElement>("file.cs", (ig, inc) => ig.AddItem("cs", inc, itemMetadata), (i, inc) => i.Include == inc, out var itemWithMetadata1, out var itemWithMetadata2);
+            itemGrp.Add2NewChildrenWithVerify("file.cs", (ig, inc) => ig.AddItem("cs", inc, itemMetadata), (i, inc) => i.Include == inc, out var itemWithMetadata1, out var itemWithMetadata2);
             Assert.Equal(4, itemGrp.View.Items.Count);
             ViewValidation.VerifyMetadata(itemMetadata, (k) => itemWithMetadata1.View.Metadata.Where((md) => md.Name == k).FirstOrDefault().Value);
             ViewValidation.VerifyMetadata(itemMetadata, (k) => itemWithMetadata2.View.Metadata.Where((md) => md.Name == k).FirstOrDefault().Value);
@@ -713,8 +713,8 @@ public void ProjectPropertyElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var propGrp = xmlPair.AddNewLabeledChaildWithVerify<ProjectPropertyGroupElement>(ObjectType.View, "grp", (p, l) => p.AddPropertyGroup());
-            var prop = propGrp.AddNewChaildWithVerify<ProjectPropertyElement>(ObjectType.View, "prop", (pg, n) => pg.AddProperty(n, $"value{n}"), (p, n) => p.Name == n);
+            var propGrp = xmlPair.AddNewLabeledChaildWithVerify(ObjectType.View, "grp", (p, l) => p.AddPropertyGroup());
+            var prop = propGrp.AddNewChaildWithVerify(ObjectType.View, "prop", (pg, n) => pg.AddProperty(n, $"value{n}"), (p, n) => p.Name == n);
 
             prop.VerifySetter("newValue", (p) => p.Value, (p, v) => p.Value = v);
             prop.VerifySetter("newName", (p) => p.Name, (p, v) => p.Name = v);
@@ -726,26 +726,26 @@ public void ProjectPropertyGroupElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var propGrp = xmlPair.AddNewLabeledChaildWithVerify<ProjectPropertyGroupElement>(ObjectType.View, "grp", (p, l) => p.AddPropertyGroup());
+            var propGrp = xmlPair.AddNewLabeledChaildWithVerify(ObjectType.View, "grp", (p, l) => p.AddPropertyGroup());
 
             Assert.Empty(propGrp.View.Properties);
             Assert.Empty(propGrp.View.PropertiesReversed);
 
-            propGrp.Add2NewChildrenWithVerify<ProjectPropertyElement>("prop", (pg, n) => pg.AddProperty(n, $"value{n}"), (p, n) => p.Name == n, out var prop1, out var prop2);
+            propGrp.Add2NewChildrenWithVerify("prop", (pg, n) => pg.AddProperty(n, $"value{n}"), (p, n) => p.Name == n, out var prop1, out var prop2);
             Assert.Equal(2, propGrp.View.Properties.Count);
             Assert.Equal(2, propGrp.View.PropertiesReversed.Count);
             // set prop will add them if they dont exist
-            propGrp.Add2NewChildrenWithVerify<ProjectPropertyElement>("setnewprop", (pg, n) => pg.SetProperty(n, $"value{n}"), (p, n) => p.Name == n, out var setNewProp1, out var setNewProp2);
+            propGrp.Add2NewChildrenWithVerify("setnewprop", (pg, n) => pg.SetProperty(n, $"value{n}"), (p, n) => p.Name == n, out var setNewProp1, out var setNewProp2);
             Assert.Equal(4, propGrp.View.Properties.Count);
             Assert.Equal(4, propGrp.View.PropertiesReversed.Count);
             // Add Prop will add them even if they do already exist.
-            propGrp.Add2NewChildrenWithVerify<ProjectPropertyElement>("prop" /*same name*/, (pg, n) => pg.AddProperty(n, $"value2{n}"), (p, n) => p.Value == $"value2{n}", out var prop1_2, out var prop2_2);
+            propGrp.Add2NewChildrenWithVerify("prop" /*same name*/, (pg, n) => pg.AddProperty(n, $"value2{n}"), (p, n) => p.Value == $"value2{n}", out var prop1_2, out var prop2_2);
             Assert.Equal(6, propGrp.View.Properties.Count);
             Assert.Equal(6, propGrp.View.PropertiesReversed.Count);
             prop1_2.VerifyNotSame(prop1);
             prop2_2.VerifyNotSame(prop2);
             // set prop will override them if they do.
-            propGrp.Add2NewChildrenWithVerify<ProjectPropertyElement>("setnewprop" /*same name*/, (pg, n) => pg.SetProperty(n, $"value2{n}"), (p, n) => p.Value == $"value2{n}", out var setNewProp1_2, out var setNewProp2_2);
+            propGrp.Add2NewChildrenWithVerify("setnewprop" /*same name*/, (pg, n) => pg.SetProperty(n, $"value2{n}"), (p, n) => p.Value == $"value2{n}", out var setNewProp1_2, out var setNewProp2_2);
             Assert.Equal(6, propGrp.View.Properties.Count);
             Assert.Equal(6, propGrp.View.PropertiesReversed.Count);
             setNewProp1_2.VerifySame(setNewProp1);
@@ -757,7 +757,7 @@ public void ProjectSdkElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var sdkElement = xmlPair.AppendNewChaildWithVerify<ProjectSdkElement>(ObjectType.View, "sdk", (p, n) => p.CreateProjectSdkElement(n, "sdkVer"), (s, n) => true);
+            var sdkElement = xmlPair.AppendNewChaildWithVerify(ObjectType.View, "sdk", (p, n) => p.CreateProjectSdkElement(n, "sdkVer"), (s, n) => true);
 
             var curiousOfHowToSpecifySdk = xmlPair.View.RawXml;
 
@@ -774,8 +774,8 @@ public void ProjectOnErrorElementModify()
         {
             var pair = GetNewInMemoryProject("temp.prj");
             var xmlPair = new ProjectXmlPair(pair);
-            var newTarget = xmlPair.AddNewChaildWithVerify<ProjectTargetElement>(ObjectType.View, "TargetToTestTask", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
-            var onErr = newTarget.AppendNewChaildWithVerify<ProjectOnErrorElement>(ObjectType.View, "errTarget", (p, et) => p.CreateOnErrorElement(et), (oe, et) => oe.ExecuteTargetsAttribute == et);
+            var newTarget = xmlPair.AddNewChaildWithVerify(ObjectType.View, "TargetToTestTask", (p, n) => p.AddTarget(n), (t, n) => string.Equals(t.Name, n));
+            var onErr = newTarget.AppendNewChaildWithVerify(ObjectType.View, "errTarget", (p, et) => p.CreateOnErrorElement(et), (oe, et) => oe.ExecuteTargetsAttribute == et);
 
             onErr.VerifySetter("newErrTargt", (e) => e.ExecuteTargetsAttribute, (e, v) => e.ExecuteTargetsAttribute = v);
         }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
index 7a2cb811fe0..a8154ab9117 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
@@ -26,30 +26,30 @@ public class ROTestCollectionGroup : TestCollectionGroup
             public ROTestCollectionGroup()
                 : base(1, 0)
             {
-                this.BigFile = this.ImmutableDisk.WriteProjectFile($"Big.proj", TestCollectionGroup.BigProjectFile);
-                var projReal = this.Remote[0].LoadProjectIgnoreMissingImports(this.BigFile);
-                this.Local.Importing = true;
+                BigFile = ImmutableDisk.WriteProjectFile($"Big.proj", BigProjectFile);
+                var projReal = Remote[0].LoadProjectIgnoreMissingImports(BigFile);
+                Local.Importing = true;
                 Assert.NotNull(projReal);
-                this.RealXml = projReal.Xml;
-                Assert.NotNull(this.RealXml);
-                var projView = this.Local.GetLoadedProjects(this.BigFile).FirstOrDefault();
+                RealXml = projReal.Xml;
+                Assert.NotNull(RealXml);
+                var projView = Local.GetLoadedProjects(BigFile).FirstOrDefault();
                 Assert.NotNull(projView);
-                this.ViewXml = projView.Xml;
+                ViewXml = projView.Xml;
 
-                ViewValidation.VerifyNotLinkedNotNull(this.RealXml);
-                ViewValidation.VerifyLinkedNotNull(this.ViewXml);
+                ViewValidation.VerifyNotLinkedNotNull(RealXml);
+                ViewValidation.VerifyLinkedNotNull(ViewXml);
             }
 
             public void ResetBeforeTests()
             {
-                this.Group.ClearAllRemotes();
+                Group.ClearAllRemotes();
 
-                var projView = this.Local.GetLoadedProjects(this.BigFile).FirstOrDefault();
+                var projView = Local.GetLoadedProjects(BigFile).FirstOrDefault();
                 Assert.NotNull(projView);
-                Assert.NotSame(projView, this.ViewXml);
-                this.ViewXml = projView.Xml;
+                Assert.NotSame(projView, ViewXml);
+                ViewXml = projView.Xml;
 
-                ViewValidation.VerifyLinkedNotNull(this.ViewXml);
+                ViewValidation.VerifyLinkedNotNull(ViewXml);
             }
         }
 
@@ -57,8 +57,8 @@ public void ResetBeforeTests()
 
         public LinkedConstructionReadOnly_Tests(ROTestCollectionGroup group)
         {
-            this.StdGroup = group; // new ROTestCollectionGroup();
-            this.StdGroup.ResetBeforeTests();
+            StdGroup = group; // new ROTestCollectionGroup();
+            StdGroup.ResetBeforeTests();
             // group.Clear();
         }
 
@@ -66,8 +66,8 @@ public LinkedConstructionReadOnly_Tests(ROTestCollectionGroup group)
         [Fact]
         public void ProjectRootElemetReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             ViewValidation.Verify(preView, preReal);
         }
@@ -75,8 +75,8 @@ public void ProjectRootElemetReadOnly()
         [Fact]
         public void ProjectChooseElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             Assert.NotEmpty(preReal.ChooseElements);
 
@@ -86,8 +86,8 @@ public void ProjectChooseElementReadOnly()
         [Fact]
         public void ProjectExtensionsElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realExtensionsList = preReal.ChildrenReversed.OfType<ProjectExtensionsElement>().ToList();
             var viewExtensionsList = preView.ChildrenReversed.OfType<ProjectExtensionsElement>().ToList();
@@ -108,8 +108,8 @@ public void ProjectExtensionsElementReadOnly()
         [Fact]
         public void ProjectImportElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realImports = preReal.Imports.ToList();
             var viewImports = preView.Imports.ToList();
@@ -121,8 +121,8 @@ public void ProjectImportElementReadOnly()
         [Fact]
         public void ProjectImportGroupElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realImportGroups = preReal.ImportGroups.ToList();
             var viewImportGroups = preView.ImportGroups.ToList();
@@ -134,8 +134,8 @@ public void ProjectImportGroupElementReadOnly()
         [Fact]
         public void ProjectItemDefinitionElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realItemDefinitions = preReal.ItemDefinitions.ToList();
             var viewlItemDefinitions = preView.ItemDefinitions.ToList();
@@ -147,8 +147,8 @@ public void ProjectItemDefinitionElementReadOnly()
         [Fact]
         public void ProjectItemDefinitionGroupElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realItemDefinitionGroups = preReal.ItemDefinitionGroups.ToList();
             var viewlItemDefinitionGroups = preView.ItemDefinitionGroups.ToList();
@@ -160,8 +160,8 @@ public void ProjectItemDefinitionGroupElementReadOnly()
         [Fact]
         public void ProjectItemElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realItems = preReal.Items.ToList();
             var viewlItems = preView.Items.ToList();
@@ -173,8 +173,8 @@ public void ProjectItemElementReadOnly()
         [Fact]
         public void ProjectItemGroupElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realItemGroups = preReal.ItemGroups.ToList();
             var viewItemGroups = preView.ItemGroups.ToList();
@@ -186,8 +186,8 @@ public void ProjectItemGroupElementReadOnly()
         [Fact]
         public void ProjectPropertyElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realProperties = preReal.Properties.ToList();
             var viewProperties = preView.Properties.ToList();
@@ -199,8 +199,8 @@ public void ProjectPropertyElementReadOnly()
         [Fact]
         public void ProjectPropertyGroupElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realPropertieGroups = preReal.PropertyGroups.ToList();
             var viewPropertieGroups = preView.PropertyGroups.ToList();
@@ -212,8 +212,8 @@ public void ProjectPropertyGroupElementReadOnly()
         [Fact]
         public void ProjectOtherwiseElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectOtherwiseElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectOtherwiseElement>().ToList();
@@ -225,8 +225,8 @@ public void ProjectOtherwiseElementReadOnly()
         [Fact]
         public void ProjectProjectWhenElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectWhenElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectWhenElement>().ToList();
@@ -238,8 +238,8 @@ public void ProjectProjectWhenElementReadOnly()
         [Fact]
         public void ProjectProjectSdkElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectSdkElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectSdkElement>().ToList();
@@ -251,8 +251,8 @@ public void ProjectProjectSdkElementReadOnly()
         [Fact]
         public void ProjectTargetElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.Targets.ToList();
             var viewCollection = preView.Targets.ToList();
@@ -264,8 +264,8 @@ public void ProjectTargetElementReadOnly()
         [Fact]
         public void ProjectTaskElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectTaskElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectTaskElement>().ToList();
@@ -278,8 +278,8 @@ public void ProjectTaskElementReadOnly()
         [Fact]
         public void ProjectUsingTaskElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectUsingTaskElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectUsingTaskElement>().ToList();
@@ -291,8 +291,8 @@ public void ProjectUsingTaskElementReadOnly()
         [Fact]
         public void ProjectUsingTaskBodyElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectUsingTaskBodyElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectUsingTaskBodyElement>().ToList();
@@ -304,8 +304,8 @@ public void ProjectUsingTaskBodyElementReadOnly()
         [Fact]
         public void UsingTaskParameterGroupElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<UsingTaskParameterGroupElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<UsingTaskParameterGroupElement>().ToList();
@@ -317,8 +317,8 @@ public void UsingTaskParameterGroupElementReadOnly()
         [Fact]
         public void ProjectUsingTaskParameterElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectUsingTaskParameterElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectUsingTaskParameterElement>().ToList();
@@ -330,8 +330,8 @@ public void ProjectUsingTaskParameterElementReadOnly()
         [Fact]
         public void ProjectOnErrorElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectOnErrorElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectOnErrorElement>().ToList();
@@ -343,8 +343,8 @@ public void ProjectOnErrorElementReadOnly()
         [Fact]
         public void ProjectOutputElementReadOnly()
         {
-            var preReal = this.StdGroup.RealXml;
-            var preView = this.StdGroup.ViewXml;
+            var preReal = StdGroup.RealXml;
+            var preView = StdGroup.ViewXml;
 
             var realCollection = preReal.AllChildren.OfType<ProjectOutputElement>().ToList();
             var viewCollection = preView.AllChildren.OfType<ProjectOutputElement>().ToList();
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
index dd887f0ca16..592ca78e72c 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
@@ -22,7 +22,7 @@ public MyTestCollectionGroup() : base(2, 1) { }
         public TestCollectionGroup StdGroup { get; }
         public LinkedEvaluationModify_Tests(MyTestCollectionGroup group)
         {
-            this.StdGroup = group;
+            StdGroup = group;
             group.Clear();
         }
 
@@ -31,17 +31,17 @@ public LinkedEvaluationModify_Tests(MyTestCollectionGroup group)
         [Fact]
         public void ProjectModifyRenameAndSafeAs()
         {
-            var pcLocal = this.StdGroup.Local;
-            var pcRemote = this.StdGroup.Remote[0];
+            var pcLocal = StdGroup.Local;
+            var pcRemote = StdGroup.Remote[0];
 
-            var proj1Path = this.StdGroup.StdProjectFiles[0];
+            var proj1Path = StdGroup.StdProjectFiles[0];
             var realProj = pcRemote.LoadProject(proj1Path);
             pcLocal.Importing = true;
             var viewProj = pcLocal.Collection.GetLoadedProjects(proj1Path).FirstOrDefault();
 
 
             ViewValidation.Verify(viewProj, realProj);
-            var savedPath = this.StdGroup.Disk.GetAbsolutePath("Saved.proj");
+            var savedPath = StdGroup.Disk.GetAbsolutePath("Saved.proj");
 
             Assert.NotEqual(proj1Path, savedPath);
             Assert.Equal(proj1Path, viewProj.FullPath);
@@ -105,10 +105,10 @@ public void ProjectModifyRenameAndSafeAs()
         [Fact]
         public void ProjectItemModify()
         {
-            var pcLocal = this.StdGroup.Local;
-            var pcRemote = this.StdGroup.Remote[0];
+            var pcLocal = StdGroup.Local;
+            var pcRemote = StdGroup.Remote[0];
 
-            var proj1Path = this.StdGroup.StdProjectFiles[0];
+            var proj1Path = StdGroup.StdProjectFiles[0];
             var realProj = pcRemote.LoadProject(proj1Path);
             pcLocal.Importing = true;
             var viewProj = pcLocal.Collection.GetLoadedProjects(proj1Path).FirstOrDefault();
@@ -301,10 +301,10 @@ public void ProjectItemModify()
         [Fact]
         public void ProjectGlobalPropertyModify()
         {
-            var pcLocal = this.StdGroup.Local;
-            var pcRemote = this.StdGroup.Remote[0];
+            var pcLocal = StdGroup.Local;
+            var pcRemote = StdGroup.Remote[0];
 
-            var proj1Path = this.StdGroup.StdProjectFiles[0];
+            var proj1Path = StdGroup.StdProjectFiles[0];
             var realProj = pcRemote.LoadProject(proj1Path);
             pcLocal.Importing = true;
             var viewProj = pcLocal.Collection.GetLoadedProjects(proj1Path).FirstOrDefault();
@@ -337,10 +337,10 @@ public void ProjectGlobalPropertyModify()
         [Fact]
         public void ProjectPropertyModify()
         {
-            var pcLocal = this.StdGroup.Local;
-            var pcRemote = this.StdGroup.Remote[0];
+            var pcLocal = StdGroup.Local;
+            var pcRemote = StdGroup.Remote[0];
 
-            var proj1Path = this.StdGroup.StdProjectFiles[0];
+            var proj1Path = StdGroup.StdProjectFiles[0];
             var realProj = pcRemote.LoadProject(proj1Path);
             pcLocal.Importing = true;
             var viewProj = pcLocal.Collection.GetLoadedProjects(proj1Path).FirstOrDefault();
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
index 37578322323..d6aa252830d 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
@@ -20,30 +20,30 @@ public class ROTestCollectionGroup : TestCollectionGroup
             public ROTestCollectionGroup()
                 : base(1, 0)
             {
-                this.BigFile = this.ImmutableDisk.WriteProjectFile($"Big.proj", TestCollectionGroup.BigProjectFile);
-                var projReal = this.Remote[0].LoadProjectWithSettings(this.BigFile, ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.RecordDuplicateButNotCircularImports);
-                this.Local.Importing = true;
+                BigFile = ImmutableDisk.WriteProjectFile($"Big.proj", BigProjectFile);
+                var projReal = Remote[0].LoadProjectWithSettings(BigFile, ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.RecordDuplicateButNotCircularImports);
+                Local.Importing = true;
                 Assert.NotNull(projReal);
-                this.Real = projReal;
-                Assert.NotNull(this.Real);
-                var projView = this.Local.GetLoadedProjects(this.BigFile).FirstOrDefault();
+                Real = projReal;
+                Assert.NotNull(Real);
+                var projView = Local.GetLoadedProjects(BigFile).FirstOrDefault();
                 Assert.NotNull(projView);
-                this.View = projView;
+                View = projView;
 
-                ViewValidation.VerifyNotLinkedNotNull(this.Real);
-                ViewValidation.VerifyLinkedNotNull(this.View);
+                ViewValidation.VerifyNotLinkedNotNull(Real);
+                ViewValidation.VerifyLinkedNotNull(View);
             }
 
             public void ResetBeforeTests()
             {
-                this.Group.ClearAllRemotes();
+                Group.ClearAllRemotes();
 
-                var projView = this.Local.GetLoadedProjects(this.BigFile).FirstOrDefault();
+                var projView = Local.GetLoadedProjects(BigFile).FirstOrDefault();
                 Assert.NotNull(projView);
-                Assert.NotSame(projView, this.View);
-                this.View = projView;
+                Assert.NotSame(projView, View);
+                View = projView;
 
-                ViewValidation.VerifyLinkedNotNull(this.View);
+                ViewValidation.VerifyLinkedNotNull(View);
             }
         }
 
@@ -51,22 +51,22 @@ public void ResetBeforeTests()
 
         public LinkedEvaluationReadOnly_Tests(ROTestCollectionGroup group)
         {
-            this.StdGroup = group;
-            this.StdGroup.ResetBeforeTests();
+            StdGroup = group;
+            StdGroup.ResetBeforeTests();
         }
 
         [Fact]
         public void ProjectReadOnly_Tests()
         {
             // this is actually very elaborate and caught quite a few issues.
-            ViewValidation.Verify(this.StdGroup.View, this.StdGroup.Real);
+            ViewValidation.Verify(StdGroup.View, StdGroup.Real);
         }
 
         [Fact]
         public void ProjectItemReadOnly_Tests()
         {
-            var viewItems = this.StdGroup.View.AllEvaluatedItems;
-            var realItems = this.StdGroup.Real.AllEvaluatedItems;
+            var viewItems = StdGroup.View.AllEvaluatedItems;
+            var realItems = StdGroup.Real.AllEvaluatedItems;
 
             Assert.NotEmpty(viewItems);
             ViewValidation.Verify(viewItems, realItems);
@@ -75,8 +75,8 @@ public void ProjectItemReadOnly_Tests()
         [Fact]
         public void ProjectItemDefinitionReadOnly_Tests()
         {
-            var viewItemDefinitions = this.StdGroup.View.ItemDefinitions;
-            var realItemDefinitions = this.StdGroup.Real.ItemDefinitions;
+            var viewItemDefinitions = StdGroup.View.ItemDefinitions;
+            var realItemDefinitions = StdGroup.Real.ItemDefinitions;
 
             Assert.NotEmpty(viewItemDefinitions);
             ViewValidation.Verify(viewItemDefinitions, realItemDefinitions, ViewValidation.Verify);
@@ -85,8 +85,8 @@ public void ProjectItemDefinitionReadOnly_Tests()
         [Fact]
         public void ProjectPropertiesReadOnly_Tests()
         {
-            var viewProperties = this.StdGroup.View.Properties;
-            var realProperties = this.StdGroup.Real.Properties;
+            var viewProperties = StdGroup.View.Properties;
+            var realProperties = StdGroup.Real.Properties;
 
             Assert.NotEmpty(viewProperties);
             ViewValidation.Verify(viewProperties, realProperties);
@@ -95,8 +95,8 @@ public void ProjectPropertiesReadOnly_Tests()
         [Fact]
         public void ProjectMetadataReadOnly_Tests()
         {
-            var viewMetadata = this.StdGroup.View.AllEvaluatedItemDefinitionMetadata;
-            var realMetadata = this.StdGroup.Real.AllEvaluatedItemDefinitionMetadata;
+            var viewMetadata = StdGroup.View.AllEvaluatedItemDefinitionMetadata;
+            var realMetadata = StdGroup.Real.AllEvaluatedItemDefinitionMetadata;
 
             Assert.NotEmpty(viewMetadata);
             ViewValidation.Verify(viewMetadata, realMetadata);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
index c0dc256c99f..4faf78b4edb 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
@@ -19,18 +19,18 @@ public MyTestCollectionGroup() : base(2, 4) { }
         public TestCollectionGroup StdGroup { get; }
         public LinkedProjectCollection_Tests(MyTestCollectionGroup group)
         {
-            this.StdGroup = group;
+            StdGroup = group;
             group.Clear();
         }
 
         [Fact]
         public void EnumerationBasic()
         {
-            var pcLocal = this.StdGroup.Local;
-            var pcRemote = this.StdGroup.Remote[0];
+            var pcLocal = StdGroup.Local;
+            var pcRemote = StdGroup.Remote[0];
 
-            var proj1Path = this.StdGroup.StdProjectFiles[0];
-            var proj2Path = this.StdGroup.StdProjectFiles[1];
+            var proj1Path = StdGroup.StdProjectFiles[0];
+            var proj2Path = StdGroup.StdProjectFiles[1];
 
             var proj1 = pcLocal.LoadProject(proj1Path);
             var proj2 = pcRemote.LoadProject(proj2Path);
@@ -63,14 +63,14 @@ public void EnumerationBasic()
         [Fact]
         public void EnumerationMultiple()
         {
-            var pcLocal = this.StdGroup.Local;
-            var pcRemote0 = this.StdGroup.Remote[0];
-            var pcRemote1 = this.StdGroup.Remote[1];
+            var pcLocal = StdGroup.Local;
+            var pcRemote0 = StdGroup.Remote[0];
+            var pcRemote1 = StdGroup.Remote[1];
 
-            var proj0Path = this.StdGroup.StdProjectFiles[0];
-            var proj1Path = this.StdGroup.StdProjectFiles[1];
-            var proj2Path = this.StdGroup.StdProjectFiles[2];
-            var proj3Path = this.StdGroup.StdProjectFiles[3];
+            var proj0Path = StdGroup.StdProjectFiles[0];
+            var proj1Path = StdGroup.StdProjectFiles[1];
+            var proj2Path = StdGroup.StdProjectFiles[2];
+            var proj3Path = StdGroup.StdProjectFiles[3];
 
             var proj0local = pcLocal.LoadProject(proj0Path);
             var proj1local = pcLocal.LoadProject(proj1Path);
@@ -121,13 +121,13 @@ public void EnumerationMultiple()
         [Fact]
         public void DynamicEnumeration()
         {
-            var pcLocal = this.StdGroup.Local;
-            var pcRemote = this.StdGroup.Remote[0];
+            var pcLocal = StdGroup.Local;
+            var pcRemote = StdGroup.Remote[0];
             pcLocal.Importing = true;
 
-            var proj0Path = this.StdGroup.StdProjectFiles[0];
-            var proj1Path = this.StdGroup.StdProjectFiles[1];
-            var proj2Path = this.StdGroup.StdProjectFiles[2];
+            var proj0Path = StdGroup.StdProjectFiles[0];
+            var proj1Path = StdGroup.StdProjectFiles[1];
+            var proj2Path = StdGroup.StdProjectFiles[2];
 
             Assert.Equal(0, pcLocal.Collection.LoadedProjects.Count);
             Assert.Equal(0, pcRemote.Collection.LoadedProjects.Count);
@@ -153,62 +153,62 @@ public void DynamicEnumeration()
         [Fact]
         public void CrossLinked()
         {
-            this.StdGroup.Local.Importing = true;
+            StdGroup.Local.Importing = true;
             Array.ForEach(StdGroup.Remote, (r) => r.Importing = true);
 
-            Assert.Equal(0, this.StdGroup.Local.Collection.LoadedProjects.Count);
-            Assert.Equal(0, this.StdGroup.Remote[0].Collection.LoadedProjects.Count);
-            Assert.Equal(0, this.StdGroup.Remote[1].Collection.LoadedProjects.Count);
-
-            this.StdGroup.Local.LoadProject(this.StdGroup.StdProjectFiles[0]);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Local.Collection.LoadedProjects, 1, 0);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[0].Collection.LoadedProjects, 0, 1);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[1].Collection.LoadedProjects, 0, 1);
-            this.StdGroup.Local.VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 1, 0);
-            this.StdGroup.Remote[0].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 0, 1);
-            this.StdGroup.Remote[1].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 0, 1);
-
-            this.StdGroup.Local.LoadProject(this.StdGroup.StdProjectFiles[1]);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Local.Collection.LoadedProjects, 2, 0);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[0].Collection.LoadedProjects, 0, 2);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[1].Collection.LoadedProjects, 0, 2);
-            this.StdGroup.Local.VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[1], 1, 0);
-            this.StdGroup.Remote[0].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[1], 0, 1);
-            this.StdGroup.Remote[1].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[1], 0, 1);
-
-            this.StdGroup.Remote[0].LoadProject(this.StdGroup.StdProjectFiles[2]);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Local.Collection.LoadedProjects, 2, 1);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[0].Collection.LoadedProjects, 1, 2);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[1].Collection.LoadedProjects, 0, 3);
-            this.StdGroup.Local.VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[2], 0, 1);
-            this.StdGroup.Remote[0].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[2], 1, 0);
-            this.StdGroup.Remote[1].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[2], 0, 1);
+            Assert.Equal(0, StdGroup.Local.Collection.LoadedProjects.Count);
+            Assert.Equal(0, StdGroup.Remote[0].Collection.LoadedProjects.Count);
+            Assert.Equal(0, StdGroup.Remote[1].Collection.LoadedProjects.Count);
+
+            StdGroup.Local.LoadProject(StdGroup.StdProjectFiles[0]);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Local.Collection.LoadedProjects, 1, 0);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[0].Collection.LoadedProjects, 0, 1);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[1].Collection.LoadedProjects, 0, 1);
+            StdGroup.Local.VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 1, 0);
+            StdGroup.Remote[0].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 0, 1);
+            StdGroup.Remote[1].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 0, 1);
+
+            StdGroup.Local.LoadProject(StdGroup.StdProjectFiles[1]);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Local.Collection.LoadedProjects, 2, 0);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[0].Collection.LoadedProjects, 0, 2);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[1].Collection.LoadedProjects, 0, 2);
+            StdGroup.Local.VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[1], 1, 0);
+            StdGroup.Remote[0].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[1], 0, 1);
+            StdGroup.Remote[1].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[1], 0, 1);
+
+            StdGroup.Remote[0].LoadProject(StdGroup.StdProjectFiles[2]);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Local.Collection.LoadedProjects, 2, 1);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[0].Collection.LoadedProjects, 1, 2);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[1].Collection.LoadedProjects, 0, 3);
+            StdGroup.Local.VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[2], 0, 1);
+            StdGroup.Remote[0].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[2], 1, 0);
+            StdGroup.Remote[1].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[2], 0, 1);
 
             // load proj0 in remote[1] (already loaded in local)
-            this.StdGroup.Remote[1].LoadProject(this.StdGroup.StdProjectFiles[0]);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Local.Collection.LoadedProjects, 2, 2);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[0].Collection.LoadedProjects, 1, 3);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[1].Collection.LoadedProjects, 1, 3);
-            this.StdGroup.Local.VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 1, 1);
-            this.StdGroup.Remote[0].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 0, 2);
-            this.StdGroup.Remote[1].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 1, 1);
-
-            this.StdGroup.Local.Collection.UnloadAllProjects();
-
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Local.Collection.LoadedProjects, 0, 2);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[0].Collection.LoadedProjects, 1, 1);
-            ViewValidation.VerifyProjectCollectionLinks(this.StdGroup.Remote[1].Collection.LoadedProjects, 1, 1);
-            this.StdGroup.Local.VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 0, 1);
-            this.StdGroup.Remote[0].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 0, 1);
-            this.StdGroup.Remote[1].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[0], 1, 0);
-
-            this.StdGroup.Local.VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[1], 0, 0);
-            this.StdGroup.Remote[0].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[1], 0, 0);
-            this.StdGroup.Remote[1].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[1], 0, 0);
-
-            this.StdGroup.Local.VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[2], 0, 1);
-            this.StdGroup.Remote[0].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[2], 1, 0);
-            this.StdGroup.Remote[1].VerifyProjectCollectionLinks(this.StdGroup.StdProjectFiles[2], 0, 1);
+            StdGroup.Remote[1].LoadProject(StdGroup.StdProjectFiles[0]);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Local.Collection.LoadedProjects, 2, 2);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[0].Collection.LoadedProjects, 1, 3);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[1].Collection.LoadedProjects, 1, 3);
+            StdGroup.Local.VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 1, 1);
+            StdGroup.Remote[0].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 0, 2);
+            StdGroup.Remote[1].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 1, 1);
+
+            StdGroup.Local.Collection.UnloadAllProjects();
+
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Local.Collection.LoadedProjects, 0, 2);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[0].Collection.LoadedProjects, 1, 1);
+            ViewValidation.VerifyProjectCollectionLinks(StdGroup.Remote[1].Collection.LoadedProjects, 1, 1);
+            StdGroup.Local.VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 0, 1);
+            StdGroup.Remote[0].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 0, 1);
+            StdGroup.Remote[1].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[0], 1, 0);
+
+            StdGroup.Local.VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[1], 0, 0);
+            StdGroup.Remote[0].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[1], 0, 0);
+            StdGroup.Remote[1].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[1], 0, 0);
+
+            StdGroup.Local.VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[2], 0, 1);
+            StdGroup.Remote[0].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[2], 1, 0);
+            StdGroup.Remote[1].VerifyProjectCollectionLinks(StdGroup.StdProjectFiles[2], 0, 1);
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
index d9d8a7fc9e4..e9ca62a5493 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
@@ -32,36 +32,36 @@ public class MyTestCollectionGroup : TestCollectionGroup
             public MyTestCollectionGroup()
                 : base(2, 0)
             {
-                this.LocalBigPath = this.ImmutableDisk.WriteProjectFile($"BigLocal.proj", TestCollectionGroup.BigProjectFile);
-                this.TargetBigPath = this.ImmutableDisk.WriteProjectFile($"BigTarget.proj", TestCollectionGroup.BigProjectFile);
-                this.GuestBigPath = this.ImmutableDisk.WriteProjectFile($"BigGuest.proj", TestCollectionGroup.BigProjectFile);
+                LocalBigPath = ImmutableDisk.WriteProjectFile($"BigLocal.proj", BigProjectFile);
+                TargetBigPath = ImmutableDisk.WriteProjectFile($"BigTarget.proj", BigProjectFile);
+                GuestBigPath = ImmutableDisk.WriteProjectFile($"BigGuest.proj", BigProjectFile);
 
-                this.Target = this.Remote[0];
-                this.Guest = this.Remote[1];
+                Target = Remote[0];
+                Guest = Remote[1];
 
-                this.LocalBig = this.Local.LoadProjectIgnoreMissingImports(this.LocalBigPath);
-                this.TargetBig = this.Target.LoadProjectIgnoreMissingImports(this.TargetBigPath);
-                this.GuestBig = this.Guest.LoadProjectIgnoreMissingImports(this.GuestBigPath);
+                LocalBig = Local.LoadProjectIgnoreMissingImports(LocalBigPath);
+                TargetBig = Target.LoadProjectIgnoreMissingImports(TargetBigPath);
+                GuestBig = Guest.LoadProjectIgnoreMissingImports(GuestBigPath);
 
-                this.TakeSnapshot();
+                TakeSnapshot();
             }
 
             public void ResetBeforeTests()
             {
-                this.Clear();
-                this.Local.Importing = true;
+                Clear();
+                Local.Importing = true;
                 {
-                    var targetView = this.Local.GetLoadedProjects(this.TargetBigPath).FirstOrDefault();
+                    var targetView = Local.GetLoadedProjects(TargetBigPath).FirstOrDefault();
                     Assert.NotNull(targetView);
-                    var targetPair = new ProjectPair(targetView, this.TargetBig);
-                    this.TargetXmlPair = new ProjectXmlPair(targetPair);
+                    var targetPair = new ProjectPair(targetView, TargetBig);
+                    TargetXmlPair = new ProjectXmlPair(targetPair);
                 }
 
                 {
-                    var guestView = this.Local.GetLoadedProjects(this.GuestBigPath).FirstOrDefault();
+                    var guestView = Local.GetLoadedProjects(GuestBigPath).FirstOrDefault();
                     Assert.NotNull(guestView);
-                    var guestPair = new ProjectPair(guestView, this.GuestBig);
-                    this.GuestXmlPair = new ProjectXmlPair(guestPair);
+                    var guestPair = new ProjectPair(guestView, GuestBig);
+                    GuestXmlPair = new ProjectXmlPair(guestPair);
                 }
             }
         }
@@ -69,17 +69,17 @@ public void ResetBeforeTests()
         public MyTestCollectionGroup StdGroup { get; }
         public LinkedSpecialCasesScenarios(MyTestCollectionGroup group)
         {
-            this.StdGroup = group;
+            StdGroup = group;
             group.ResetBeforeTests();
         }
 
         private ProjectPair GetNewInMemoryProject(string path, string content = null)
         {
             content ??= TestCollectionGroup.SampleProjectFile;
-            var tempPath = this.StdGroup.Disk.GetAbsolutePath(path);
-            var newReal = this.StdGroup.Target.LoadInMemoryWithSettings(content, ProjectLoadSettings.IgnoreMissingImports);
+            var tempPath = StdGroup.Disk.GetAbsolutePath(path);
+            var newReal = StdGroup.Target.LoadInMemoryWithSettings(content, ProjectLoadSettings.IgnoreMissingImports);
             newReal.Xml.FullPath = tempPath;
-            var newView = this.StdGroup.Local.GetLoadedProjects(tempPath).FirstOrDefault();
+            var newView = StdGroup.Local.GetLoadedProjects(tempPath).FirstOrDefault();
             Assert.NotNull(newView);
 
             ViewValidation.Verify(newView, newReal);
@@ -162,7 +162,7 @@ private void CopyFromInternal(ProjectRootElement sourceProject)
 
             var ourGroup1 = xmlPair.QuerySingleChildrenWithValidation<ProjectItemGroupElement>((ig) => ig.Label == "Group1");
 
-            var newCopyFrom = xmlPair.AddNewLabeledChaildWithVerify<ProjectItemGroupElement>(ObjectType.View, "newGrop", (p, l) => p.AddItemGroup());
+            var newCopyFrom = xmlPair.AddNewLabeledChaildWithVerify(ObjectType.View, "newGrop", (p, l) => p.AddItemGroup());
 
             newCopyFrom.View.CopyFrom(existingItemGroup);
             xmlPair.QueryChildrenWithValidation<ProjectItemGroupElement>((ig) => ig.Label == "Group1", 2);
@@ -180,7 +180,7 @@ private void CopyFromInternal(ProjectRootElement sourceProject)
             Assert.True(xmlPair.View.HasUnsavedChanges);
             Assert.False(externalSource && sourceProject.HasUnsavedChanges);
 
-            var newDeepCopy = xmlPair.AddNewLabeledChaildWithVerify<ProjectItemGroupElement>(ObjectType.View, "newGrop", (p, l) => p.AddItemGroup());
+            var newDeepCopy = xmlPair.AddNewLabeledChaildWithVerify(ObjectType.View, "newGrop", (p, l) => p.AddItemGroup());
             newDeepCopy.View.DeepCopyFrom(existingItemGroup);
 
             xmlPair.QueryChildrenWithValidation<ProjectItemGroupElement>((ig) => ig.Label == "Group1", 2);
@@ -210,21 +210,21 @@ public void CloneAndAddInnerProject()
         public void CloneAndAddCrossProjectSameCollection()
         {
             // view gets "a view" object as argument from different project (but in the same collection)
-            CloneAndAddInternal(this.StdGroup.TargetXmlPair.View);
+            CloneAndAddInternal(StdGroup.TargetXmlPair.View);
         }
 
         [Fact]
         public void CloneAndAddCrossProjectLocalSource()
         {
             // view gets "a real" object as argument
-            CloneAndAddInternal(this.StdGroup.LocalBig.Xml);
+            CloneAndAddInternal(StdGroup.LocalBig.Xml);
         }
 
         [Fact]
         public void CloneAndAddCrossProjectCrossCollection()
         {
             // view gets "a view" object as argument from different project and collection (double proxy)
-            CloneAndAddInternal(this.StdGroup.GuestXmlPair.View);
+            CloneAndAddInternal(StdGroup.GuestXmlPair.View);
         }
 
 
@@ -237,19 +237,19 @@ public void CopyFromInnerProject()
         [Fact]
         public void CopyFromCrossProjectSameCollection()
         {
-            CopyFromInternal(this.StdGroup.TargetXmlPair.View);
+            CopyFromInternal(StdGroup.TargetXmlPair.View);
         }
 
         [Fact]
         public void CopyFromCrossProjectLocalSource()
         {
-            CopyFromInternal(this.StdGroup.LocalBig.Xml);
+            CopyFromInternal(StdGroup.LocalBig.Xml);
         }
 
         [Fact]
         public void CopyFromCrossProjectCrossCollection()
         {
-            CopyFromInternal(this.StdGroup.GuestXmlPair.View);
+            CopyFromInternal(StdGroup.GuestXmlPair.View);
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectChooseElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectChooseElementLink.cs
index 31086e8f06b..562185c9365 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectChooseElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectChooseElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectChooseElementLink : ProjectChooseElementLink, I
     {
         public MockProjectChooseElementLink(MockProjectChooseElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectChooseElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
index 621624db5f4..5fcf9491c16 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
@@ -15,35 +15,35 @@ internal abstract class MockProjectElementContainerLinkRemoter : MockProjectElem
 
         // ProjectElementContainerLink support
         public int Count => ContainerXml.Count;
-        public MockProjectElementLinkRemoter FirstChild => this.Export(ContainerXml.FirstChild);
-        public MockProjectElementLinkRemoter LastChild => this.Export(ContainerXml.LastChild);
+        public MockProjectElementLinkRemoter FirstChild => Export(ContainerXml.FirstChild);
+        public MockProjectElementLinkRemoter LastChild => Export(ContainerXml.LastChild);
 
         public void InsertAfterChild(MockProjectElementLinkRemoter child, MockProjectElementLinkRemoter reference)
         {
-            this.ContainerXml.InsertAfterChild(child.Import(OwningCollection), reference.Import(OwningCollection));
+            ContainerXml.InsertAfterChild(child.Import(OwningCollection), reference.Import(OwningCollection));
         }
 
         public void InsertBeforeChild(MockProjectElementLinkRemoter child, MockProjectElementLinkRemoter reference)
         {
-            this.ContainerXml.InsertBeforeChild(child.Import(OwningCollection), reference.Import(OwningCollection));
+            ContainerXml.InsertBeforeChild(child.Import(OwningCollection), reference.Import(OwningCollection));
         }
 
         public void AddInitialChild(MockProjectElementLinkRemoter child)
         {
-            ProjectElementContainerLink.AddInitialChild(this.ContainerXml, child.Import(OwningCollection));
+            ProjectElementContainerLink.AddInitialChild(ContainerXml, child.Import(OwningCollection));
         }
 
         public MockProjectElementContainerLinkRemoter DeepClone(MockProjectRootElementLinkRemoter factory, MockProjectElementContainerLinkRemoter parent)
         {
             var pre = (ProjectRootElement)factory.Import(OwningCollection);
             var pec = (ProjectElementContainer)parent.Import(OwningCollection);
-            var result = ProjectElementContainerLink.DeepClone(this.ContainerXml, pre, pec);
-            return (MockProjectElementContainerLinkRemoter)this.Export(result);
+            var result = ProjectElementContainerLink.DeepClone(ContainerXml, pre, pec);
+            return (MockProjectElementContainerLinkRemoter)Export(result);
         }
 
         public void RemoveChild(MockProjectElementLinkRemoter child)
         {
-            this.ContainerXml.RemoveChild(child.Import(this.OwningCollection));
+            ContainerXml.RemoveChild(child.Import(OwningCollection));
         }
     }
 
@@ -52,16 +52,16 @@ internal sealed class TemplateProjectElementContainerLink : ProjectElementContai
     {
         public TemplateProjectElementContainerLink(MockProjectElementContainerLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectElementContainerLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
 
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementLink.cs
index 3dc529aa1bb..74cf4fa276f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementLink.cs
@@ -13,16 +13,16 @@ internal abstract class MockProjectElementLinkRemoter : MockLinkRemoter<ProjectE
     {
         public MockProjectElementLinkRemoter Export(ProjectElement xml)
         {
-            return this.OwningCollection.ExportElement(xml);
+            return OwningCollection.ExportElement(xml);
         }
 
         public abstract ProjectElement ImportImpl(ProjectCollectionLinker remote);
 
 
         // ProjectElementLink remoting
-        public MockProjectElementContainerLinkRemoter Parent => (MockProjectElementContainerLinkRemoter)this.Export(Source.Parent);
+        public MockProjectElementContainerLinkRemoter Parent => (MockProjectElementContainerLinkRemoter)Export(Source.Parent);
 
-        public MockProjectRootElementLinkRemoter ContainingProject => (MockProjectRootElementLinkRemoter)this.Export(Source.ContainingProject);
+        public MockProjectRootElementLinkRemoter ContainingProject => (MockProjectRootElementLinkRemoter)Export(Source.ContainingProject);
 
         public string ElementName => Source.ElementName;
 
@@ -30,19 +30,19 @@ public MockProjectElementLinkRemoter Export(ProjectElement xml)
 
         public bool ExpressedAsAttribute { get => ProjectElementLink.GetExpressedAsAttribute(Source); set => ProjectElementLink.SetExpressedAsAttribute(Source, value); }
 
-        public MockProjectElementLinkRemoter PreviousSibling => this.Export(Source.PreviousSibling);
+        public MockProjectElementLinkRemoter PreviousSibling => Export(Source.PreviousSibling);
 
-        public MockProjectElementLinkRemoter NextSibling => this.Export(Source.NextSibling);
+        public MockProjectElementLinkRemoter NextSibling => Export(Source.NextSibling);
 
         public ElementLocation Location => Source.Location;
 
-        public IReadOnlyCollection<XmlAttributeLink> Attributes => ProjectItemElementLink.GetAttributes(this.Source);
+        public IReadOnlyCollection<XmlAttributeLink> Attributes => ProjectElementLink.GetAttributes(Source);
 
-        public string PureText => ProjectItemElementLink.GetPureText(this.Source);
+        public string PureText => ProjectElementLink.GetPureText(Source);
 
         public void CopyFrom(MockProjectElementLinkRemoter element)
         {
-            this.Source.CopyFrom(element.Import(this.OwningCollection));
+            Source.CopyFrom(element.Import(OwningCollection));
         }
 
         public MockProjectElementLinkRemoter CreateNewInstance(MockProjectRootElementLinkRemoter owner)
@@ -53,19 +53,19 @@ public MockProjectElementLinkRemoter CreateNewInstance(MockProjectRootElementLin
         }
 
         public ElementLocation GetAttributeLocation(string attributeName)
-            => ProjectElementLink.GetAttributeLocation(this.Source, attributeName);
+            => ProjectElementLink.GetAttributeLocation(Source, attributeName);
 
         public string GetAttributeValue(string attributeName, bool nullIfNotExists)
         {
-            return ProjectElementLink.GetAttributeValue(this.Source, attributeName, nullIfNotExists);
+            return ProjectElementLink.GetAttributeValue(Source, attributeName, nullIfNotExists);
         }
 
         public void SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param)
         {
-            ProjectElementLink.SetOrRemoveAttribute(this.Source, name, value, clearAttributeCache, reason, param);
+            ProjectElementLink.SetOrRemoveAttribute(Source, name, value, clearAttributeCache, reason, param);
             if (reason != null)
             {
-                ProjectElementLink.MarkDirty(this.Source, reason, param);
+                ProjectElementLink.MarkDirty(Source, reason, param);
             }
         }
     }
@@ -75,15 +75,15 @@ internal sealed class TemplateProjectElementLink : ProjectElementLink, ILinkMock
     {
         public TemplateProjectElementLink(MockProjectElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
 
         #region standard ProjectElementLink implementation
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectExtensionsElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectExtensionsElementLink.cs
index de6cd1c40fb..43ed5e0dc0a 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectExtensionsElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectExtensionsElementLink.cs
@@ -25,29 +25,29 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         }
 
         // ProjectExtensionsElementLink support
-        public string Content { get => this.ExtensionXml.Content; set => this.ExtensionXml.Content = value; }
-        public string GetSubElement(string name) { return this.ExtensionXml[name]; }
-        public void SetSubElement(string name, string value) { this.ExtensionXml[name] = value; }
+        public string Content { get => ExtensionXml.Content; set => ExtensionXml.Content = value; }
+        public string GetSubElement(string name) { return ExtensionXml[name]; }
+        public void SetSubElement(string name, string value) { ExtensionXml[name] = value; }
     }
 
     internal sealed class MockProjectExtensionsElementLink : ProjectExtensionsElementLink, ILinkMock, IProjectElementLinkHelper
     {
         public MockProjectExtensionsElementLink(MockProjectExtensionsElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectExtensionsElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
         // - ProjectExtensionsElementLink ------
         public override string Content { get => Proxy.Content; set => Proxy.Content = value; }
-        public override string GetSubElement(string name) { return this.Proxy.GetSubElement(name); }
-        public override void SetSubElement(string name, string value) { this.Proxy.SetSubElement(name, value); }
+        public override string GetSubElement(string name) { return Proxy.GetSubElement(name); }
+        public override void SetSubElement(string name, string value) { Proxy.SetSubElement(name, value); }
         // -------------------------------------
 
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectImportElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectImportElementLink.cs
index f922ee9a0b9..6c440e37d79 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectImportElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectImportElementLink.cs
@@ -25,26 +25,26 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         }
 
         public ImplicitImportLocation ImplicitImportLocation => ImportElementXml.ImplicitImportLocation;
-        public MockProjectElementLinkRemoter OriginalElement => this.Export(ImportElementXml.OriginalElement);
+        public MockProjectElementLinkRemoter OriginalElement => Export(ImportElementXml.OriginalElement);
     }
 
     internal sealed class MockProjectImportElementLink : ProjectImportElementLink, ILinkMock, IProjectElementLinkHelper
     {
         public MockProjectImportElementLink(MockProjectImportElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectImportElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
         // ProjectImportElementLink
         public override ImplicitImportLocation ImplicitImportLocation => Proxy.ImplicitImportLocation;
-        public override ProjectElement OriginalElement => Proxy.OriginalElement.Import(this.Linker);
+        public override ProjectElement OriginalElement => Proxy.OriginalElement.Import(Linker);
         //---------------------------
 
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectImportGroupElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectImportGroupElementLink.cs
index 6e330840bf8..cb30c917501 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectImportGroupElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectImportGroupElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectImportGroupElementLink : ProjectImportGroupElem
     {
         public MockProjectImportGroupElementLink(MockProjectImportGroupElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectImportGroupElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemDefinitionElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemDefinitionElementLink.cs
index 2fb99698599..9db2c628d89 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemDefinitionElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemDefinitionElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectItemDefinitionElementLink : ProjectItemDefiniti
     {
         public MockProjectItemDefinitionElementLink(MockProjectItemDefinitionElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectItemDefinitionElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemDefinitionGroupElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemDefinitionGroupElementLink.cs
index 88b97424784..1dbcf03eac6 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemDefinitionGroupElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemDefinitionGroupElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectItemDefinitionGroupElementLink : ProjectItemDef
     {
         public MockProjectItemDefinitionGroupElementLink(MockProjectItemDefinitionGroupElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectItemDefinitionGroupElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemElementLink.cs
index 146fa5ce523..84e46a1b791 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemElementLink.cs
@@ -26,7 +26,7 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
 
         public void ChangeItemType(string newType)
         {
-            this.ItemXml.ItemType = newType;
+            ItemXml.ItemType = newType;
         }
     }
 
@@ -34,19 +34,19 @@ internal sealed class MockProjectItemElementLink : ProjectItemElementLink, ILink
     {
         public MockProjectItemElementLink(MockProjectItemElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectItemElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         // ProjectItemElementLink -----
-        public override void ChangeItemType(string newType) { this.Proxy.ChangeItemType(newType); }
+        public override void ChangeItemType(string newType) { Proxy.ChangeItemType(newType); }
         // ----------------------------
 
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemGroupElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemGroupElementLink.cs
index 477d059db25..be42042af8f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemGroupElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectItemGroupElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectItemGroupElementLink : ProjectItemGroupElementL
     {
         public MockProjectItemGroupElementLink(MockProjectItemGroupElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectItemGroupElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
index 4272a5e7d90..dacb3bc7ce6 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
@@ -33,20 +33,20 @@ internal sealed class MockProjectMetadataElementLink : ProjectMetadataElementLin
     {
         public MockProjectMetadataElementLink(MockProjectMetadataElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectMetadataElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
-        public override string Value { get => this.Proxy.Value; set => this.Proxy.Value = value; }
+        public override string Value { get => Proxy.Value; set => Proxy.Value = value; }
         public override void ChangeName(string newName)
         {
-            this.Proxy.ChangeName(newName);
+            Proxy.ChangeName(newName);
         }
 
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOnErrorElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOnErrorElementLink.cs
index 0fb6c5e0666..a1879e7e864 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOnErrorElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOnErrorElementLink.cs
@@ -27,15 +27,15 @@ internal sealed class MockProjectOnErrorElementLink : ProjectOnErrorElementLink,
     {
         public MockProjectOnErrorElementLink(MockProjectOnErrorElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectOnErrorElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOtherwiseElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOtherwiseElementLink.cs
index 7e16caa74f6..ac3e4498d0d 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOtherwiseElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOtherwiseElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectOtherwiseElementLink : ProjectOtherwiseElementL
     {
         public MockProjectOtherwiseElementLink(MockProjectOtherwiseElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectOtherwiseElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOutputElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOutputElementLink.cs
index 1ec65066649..267e2fb6ed6 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOutputElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectOutputElementLink.cs
@@ -27,15 +27,15 @@ internal sealed class MockProjectOutputElementLink : ProjectOutputElementLink, I
     {
         public MockProjectOutputElementLink(MockProjectOutputElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectOutputElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
         // copy /paste
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
index 44d9f686880..d5d75ca8489 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
@@ -33,20 +33,20 @@ internal sealed class MockProjectPropertyElementLink : ProjectPropertyElementLin
     {
         public MockProjectPropertyElementLink(MockProjectPropertyElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectPropertyElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
-        public override string Value { get => this.Proxy.Value; set => this.Proxy.Value = value; }
+        public override string Value { get => Proxy.Value; set => Proxy.Value = value; }
         public override void ChangeName(string newName)
         {
-            this.Proxy.ChangeName(newName);
+            Proxy.ChangeName(newName);
         }
 
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyGroupElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyGroupElementLink.cs
index 1b8ec9a2e71..26032a2f68c 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyGroupElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyGroupElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectPropertyGroupElementLink : ProjectPropertyGroup
     {
         public MockProjectPropertyGroupElementLink(MockProjectPropertyGroupElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectPropertyGroupElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
index 61d4f806261..d0dda5d5825 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
@@ -29,120 +29,120 @@ public override ProjectElement ImportImpl(ProjectCollectionLinker remote)
         }
 
         // ProjectRootElementLink remoting
-        public int Version => this.ProjectXml.Version;
-        public bool HasUnsavedChanges => this.ProjectXml.HasUnsavedChanges;
-        public DateTime TimeLastChanged => this.ProjectXml.TimeLastChanged;
-        public DateTime LastWriteTimeWhenRead => this.ProjectXml.LastWriteTimeWhenRead;
-        public string DirectoryPath => this.ProjectXml.DirectoryPath;
-        public string FullPath { get => this.ProjectXml.FullPath; set => this.ProjectXml.FullPath = value; }
-        public ElementLocation ProjectFileLocation => this.ProjectXml.ProjectFileLocation;
-        public Encoding Encoding => this.ProjectXml.Encoding; // !! more complicated in reality when passing cross process.
-        public string RawXml => this.ProjectXml.RawXml;
-        public bool PreserveFormatting => this.ProjectXml.PreserveFormatting;
+        public int Version => ProjectXml.Version;
+        public bool HasUnsavedChanges => ProjectXml.HasUnsavedChanges;
+        public DateTime TimeLastChanged => ProjectXml.TimeLastChanged;
+        public DateTime LastWriteTimeWhenRead => ProjectXml.LastWriteTimeWhenRead;
+        public string DirectoryPath => ProjectXml.DirectoryPath;
+        public string FullPath { get => ProjectXml.FullPath; set => ProjectXml.FullPath = value; }
+        public ElementLocation ProjectFileLocation => ProjectXml.ProjectFileLocation;
+        public Encoding Encoding => ProjectXml.Encoding; // !! more complicated in reality when passing cross process.
+        public string RawXml => ProjectXml.RawXml;
+        public bool PreserveFormatting => ProjectXml.PreserveFormatting;
         public MockProjectChooseElementLinkRemoter CreateChooseElement()
         {
-            return (MockProjectChooseElementLinkRemoter)this.Export(this.ProjectXml.CreateChooseElement());
+            return (MockProjectChooseElementLinkRemoter)Export(ProjectXml.CreateChooseElement());
         }
         public MockProjectImportElementLinkRemoter CreateImportElement(string project)
         {
-            return (MockProjectImportElementLinkRemoter)this.Export(this.ProjectXml.CreateImportElement(project));
+            return (MockProjectImportElementLinkRemoter)Export(ProjectXml.CreateImportElement(project));
         }
         public MockProjectItemElementLinkRemoter CreateItemElement(string itemType)
         {
-            return (MockProjectItemElementLinkRemoter)this.Export(this.ProjectXml.CreateItemElement(itemType));
+            return (MockProjectItemElementLinkRemoter)Export(ProjectXml.CreateItemElement(itemType));
         }
         public MockProjectItemElementLinkRemoter CreateItemElement(string itemType, string include)
         {
-            return (MockProjectItemElementLinkRemoter)this.Export(this.ProjectXml.CreateItemElement(itemType, include));
+            return (MockProjectItemElementLinkRemoter)Export(ProjectXml.CreateItemElement(itemType, include));
         }
         public MockProjectItemDefinitionElementLinkRemoter CreateItemDefinitionElement(string itemType)
         {
-            return (MockProjectItemDefinitionElementLinkRemoter)this.Export(this.ProjectXml.CreateItemDefinitionElement(itemType));
+            return (MockProjectItemDefinitionElementLinkRemoter)Export(ProjectXml.CreateItemDefinitionElement(itemType));
         }
         public MockProjectItemDefinitionGroupElementLinkRemoter CreateItemDefinitionGroupElement()
         {
-            return (MockProjectItemDefinitionGroupElementLinkRemoter)this.Export(this.ProjectXml.CreateItemDefinitionGroupElement());
+            return (MockProjectItemDefinitionGroupElementLinkRemoter)Export(ProjectXml.CreateItemDefinitionGroupElement());
         }
         public MockProjectItemGroupElementLinkRemoter CreateItemGroupElement()
         {
-            return (MockProjectItemGroupElementLinkRemoter)this.Export(this.ProjectXml.CreateItemGroupElement());
+            return (MockProjectItemGroupElementLinkRemoter)Export(ProjectXml.CreateItemGroupElement());
         }
         public MockProjectImportGroupElementLinkRemoter CreateImportGroupElement()
         {
-            return (MockProjectImportGroupElementLinkRemoter)this.Export(this.ProjectXml.CreateImportGroupElement());
+            return (MockProjectImportGroupElementLinkRemoter)Export(ProjectXml.CreateImportGroupElement());
         }
         public MockProjectMetadataElementLinkRemoter CreateMetadataElement(string name)
         {
-            return (MockProjectMetadataElementLinkRemoter)this.Export(this.ProjectXml.CreateMetadataElement(name));
+            return (MockProjectMetadataElementLinkRemoter)Export(ProjectXml.CreateMetadataElement(name));
         }
         public MockProjectMetadataElementLinkRemoter CreateMetadataElement(string name, string unevaluatedValue)
         {
-            return (MockProjectMetadataElementLinkRemoter)this.Export(this.ProjectXml.CreateMetadataElement(name, unevaluatedValue));
+            return (MockProjectMetadataElementLinkRemoter)Export(ProjectXml.CreateMetadataElement(name, unevaluatedValue));
         }
         public MockProjectOnErrorElementLinkRemoter CreateOnErrorElement(string executeTargets)
         {
-            return (MockProjectOnErrorElementLinkRemoter)this.Export(this.ProjectXml.CreateOnErrorElement(executeTargets));
+            return (MockProjectOnErrorElementLinkRemoter)Export(ProjectXml.CreateOnErrorElement(executeTargets));
         }
         public MockProjectOtherwiseElementLinkRemoter CreateOtherwiseElement()
         {
-            return (MockProjectOtherwiseElementLinkRemoter)this.Export(this.ProjectXml.CreateOtherwiseElement());
+            return (MockProjectOtherwiseElementLinkRemoter)Export(ProjectXml.CreateOtherwiseElement());
         }
         public MockProjectOutputElementLinkRemoter CreateOutputElement(string taskParameter, string itemType, string propertyName)
         {
-            return (MockProjectOutputElementLinkRemoter)this.Export(this.ProjectXml.CreateOutputElement(taskParameter, itemType, propertyName));
+            return (MockProjectOutputElementLinkRemoter)Export(ProjectXml.CreateOutputElement(taskParameter, itemType, propertyName));
         }
         public MockProjectExtensionsElementLinkRemoter CreateProjectExtensionsElement()
         {
-            return (MockProjectExtensionsElementLinkRemoter)this.Export(this.ProjectXml.CreateProjectExtensionsElement());
+            return (MockProjectExtensionsElementLinkRemoter)Export(ProjectXml.CreateProjectExtensionsElement());
         }
         public MockProjectPropertyGroupElementLinkRemoter CreatePropertyGroupElement()
         {
-            return (MockProjectPropertyGroupElementLinkRemoter)this.Export(this.ProjectXml.CreatePropertyGroupElement());
+            return (MockProjectPropertyGroupElementLinkRemoter)Export(ProjectXml.CreatePropertyGroupElement());
         }
         public MockProjectPropertyElementLinkRemoter CreatePropertyElement(string name)
         {
-            return (MockProjectPropertyElementLinkRemoter)this.Export(this.ProjectXml.CreatePropertyElement(name));
+            return (MockProjectPropertyElementLinkRemoter)Export(ProjectXml.CreatePropertyElement(name));
         }
         public MockProjectTargetElementLinkRemoter CreateTargetElement(string name)
         {
-            return (MockProjectTargetElementLinkRemoter)this.Export(this.ProjectXml.CreateTargetElement(name));
+            return (MockProjectTargetElementLinkRemoter)Export(ProjectXml.CreateTargetElement(name));
         }
         public MockProjectTaskElementLinkRemoter CreateTaskElement(string name)
         {
-            return (MockProjectTaskElementLinkRemoter)this.Export(this.ProjectXml.CreateTaskElement(name));
+            return (MockProjectTaskElementLinkRemoter)Export(ProjectXml.CreateTaskElement(name));
         }
         public MockProjectUsingTaskElementLinkRemoter CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture)
         {
-            return (MockProjectUsingTaskElementLinkRemoter)this.Export(this.ProjectXml.CreateUsingTaskElement(taskName, assemblyFile, assemblyName, runtime, architecture));
+            return (MockProjectUsingTaskElementLinkRemoter)Export(ProjectXml.CreateUsingTaskElement(taskName, assemblyFile, assemblyName, runtime, architecture));
         }
         public MockUsingTaskParameterGroupElementLinkRemoter CreateUsingTaskParameterGroupElement()
         {
-            return (MockUsingTaskParameterGroupElementLinkRemoter)this.Export(this.ProjectXml.CreateUsingTaskParameterGroupElement());
+            return (MockUsingTaskParameterGroupElementLinkRemoter)Export(ProjectXml.CreateUsingTaskParameterGroupElement());
         }
         public MockProjectUsingTaskParameterElementLinkRemoter CreateUsingTaskParameterElement(string name, string output, string required, string parameterType)
         {
-            return (MockProjectUsingTaskParameterElementLinkRemoter)this.Export(this.ProjectXml.CreateUsingTaskParameterElement(name, output, required, parameterType));
+            return (MockProjectUsingTaskParameterElementLinkRemoter)Export(ProjectXml.CreateUsingTaskParameterElement(name, output, required, parameterType));
         }
         public MockProjectUsingTaskBodyElementLinkRemoter CreateUsingTaskBodyElement(string evaluate, string body)
         {
-            return (MockProjectUsingTaskBodyElementLinkRemoter)this.Export(this.ProjectXml.CreateUsingTaskBodyElement(evaluate, body));
+            return (MockProjectUsingTaskBodyElementLinkRemoter)Export(ProjectXml.CreateUsingTaskBodyElement(evaluate, body));
         }
         public MockProjectWhenElementLinkRemoter CreateWhenElement(string condition)
         {
-            return (MockProjectWhenElementLinkRemoter)this.Export(this.ProjectXml.CreateWhenElement(condition));
+            return (MockProjectWhenElementLinkRemoter)Export(ProjectXml.CreateWhenElement(condition));
         }
         public MockProjectSdkElementLinkRemoter CreateProjectSdkElement(string sdkName, string sdkVersion)
         {
-            return (MockProjectSdkElementLinkRemoter)this.Export(this.ProjectXml.CreateProjectSdkElement(sdkName, sdkVersion));
+            return (MockProjectSdkElementLinkRemoter)Export(ProjectXml.CreateProjectSdkElement(sdkName, sdkVersion));
         }
 
-        public void Save(Encoding saveEncoding) { this.ProjectXml.Save(saveEncoding); }
-        public void Save(TextWriter writer) { this.ProjectXml.Save(writer); }
+        public void Save(Encoding saveEncoding) { ProjectXml.Save(saveEncoding); }
+        public void Save(TextWriter writer) { ProjectXml.Save(writer); }
 
-        public void ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting) { this.ProjectXml.ReloadFrom(path, throwIfUnsavedChanges, preserveFormatting); }
-        public void ReloadFrom(XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting) { this.ProjectXml.ReloadFrom(reader, throwIfUnsavedChanges, preserveFormatting); }
+        public void ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting) { ProjectXml.ReloadFrom(path, throwIfUnsavedChanges, preserveFormatting); }
+        public void ReloadFrom(XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting) { ProjectXml.ReloadFrom(reader, throwIfUnsavedChanges, preserveFormatting); }
 
-        public void MarkDirty(string reason, string param) { ProjectElementLink.MarkDirty(this.Source, reason, param); }
+        public void MarkDirty(string reason, string param) { ProjectElementLink.MarkDirty(Source, reason, param); }
     }
 
 
@@ -150,16 +150,16 @@ internal sealed class MockProjectRootElementLink : ProjectRootElementLink, ILink
     {
         public MockProjectRootElementLink(MockProjectRootElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectRootElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
@@ -206,134 +206,134 @@ public MockProjectRootElementLink(MockProjectRootElementLinkRemoter proxy, IImpo
 
         public override ProjectChooseElement CreateChooseElement()
         {
-            return (ProjectChooseElement)this.Proxy.CreateChooseElement().Import(this.Linker);
+            return (ProjectChooseElement)Proxy.CreateChooseElement().Import(Linker);
         }
 
         public override ProjectImportElement CreateImportElement(string project)
         {
-            return (ProjectImportElement)this.Proxy.CreateImportElement(project).Import(this.Linker);
+            return (ProjectImportElement)Proxy.CreateImportElement(project).Import(Linker);
         }
 
         public override ProjectItemElement CreateItemElement(string itemType)
         {
-            return (ProjectItemElement)this.Proxy.CreateItemElement(itemType).Import(this.Linker);
+            return (ProjectItemElement)Proxy.CreateItemElement(itemType).Import(Linker);
         }
 
         public override ProjectItemElement CreateItemElement(string itemType, string include)
         {
-            return (ProjectItemElement)this.Proxy.CreateItemElement(itemType, include).Import(this.Linker);
+            return (ProjectItemElement)Proxy.CreateItemElement(itemType, include).Import(Linker);
         }
 
         public override ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType)
         {
-            return (ProjectItemDefinitionElement)this.Proxy.CreateItemDefinitionElement(itemType).Import(this.Linker);
+            return (ProjectItemDefinitionElement)Proxy.CreateItemDefinitionElement(itemType).Import(Linker);
         }
 
         public override ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement()
         {
-            return (ProjectItemDefinitionGroupElement)this.Proxy.CreateItemDefinitionGroupElement().Import(this.Linker);
+            return (ProjectItemDefinitionGroupElement)Proxy.CreateItemDefinitionGroupElement().Import(Linker);
         }
 
         public override ProjectItemGroupElement CreateItemGroupElement()
         {
-            return (ProjectItemGroupElement)this.Proxy.CreateItemGroupElement().Import(this.Linker);
+            return (ProjectItemGroupElement)Proxy.CreateItemGroupElement().Import(Linker);
         }
 
         public override ProjectImportGroupElement CreateImportGroupElement()
         {
-            return (ProjectImportGroupElement)this.Proxy.CreateImportGroupElement().Import(this.Linker);
+            return (ProjectImportGroupElement)Proxy.CreateImportGroupElement().Import(Linker);
         }
 
         public override ProjectMetadataElement CreateMetadataElement(string name)
         {
-            return (ProjectMetadataElement)this.Proxy.CreateMetadataElement(name).Import(this.Linker);
+            return (ProjectMetadataElement)Proxy.CreateMetadataElement(name).Import(Linker);
         }
 
         public override ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue)
         {
-            return (ProjectMetadataElement)this.Proxy.CreateMetadataElement(name, unevaluatedValue).Import(this.Linker);
+            return (ProjectMetadataElement)Proxy.CreateMetadataElement(name, unevaluatedValue).Import(Linker);
         }
 
         public override ProjectOnErrorElement CreateOnErrorElement(string executeTargets)
         {
-            return (ProjectOnErrorElement)this.Proxy.CreateOnErrorElement(executeTargets).Import(this.Linker);
+            return (ProjectOnErrorElement)Proxy.CreateOnErrorElement(executeTargets).Import(Linker);
         }
 
         public override ProjectOtherwiseElement CreateOtherwiseElement()
         {
-            return (ProjectOtherwiseElement)this.Proxy.CreateOtherwiseElement().Import(this.Linker);
+            return (ProjectOtherwiseElement)Proxy.CreateOtherwiseElement().Import(Linker);
         }
 
         public override ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName)
         {
-            return (ProjectOutputElement)this.Proxy.CreateOutputElement(taskParameter, itemType, propertyName).Import(this.Linker);
+            return (ProjectOutputElement)Proxy.CreateOutputElement(taskParameter, itemType, propertyName).Import(Linker);
         }
         public override ProjectExtensionsElement CreateProjectExtensionsElement()
         {
-            return (ProjectExtensionsElement)this.Proxy.CreateProjectExtensionsElement().Import(this.Linker);
+            return (ProjectExtensionsElement)Proxy.CreateProjectExtensionsElement().Import(Linker);
         }
 
         public override ProjectPropertyGroupElement CreatePropertyGroupElement()
         {
-            return (ProjectPropertyGroupElement)this.Proxy.CreatePropertyGroupElement().Import(this.Linker);
+            return (ProjectPropertyGroupElement)Proxy.CreatePropertyGroupElement().Import(Linker);
         }
 
         public override ProjectPropertyElement CreatePropertyElement(string name)
         {
-            return (ProjectPropertyElement)this.Proxy.CreatePropertyElement(name).Import(this.Linker);
+            return (ProjectPropertyElement)Proxy.CreatePropertyElement(name).Import(Linker);
         }
 
         public override ProjectTargetElement CreateTargetElement(string name)
         {
-            return (ProjectTargetElement)this.Proxy.CreateTargetElement(name).Import(this.Linker);
+            return (ProjectTargetElement)Proxy.CreateTargetElement(name).Import(Linker);
         }
         public override ProjectTaskElement CreateTaskElement(string name)
         {
-            return (ProjectTaskElement)this.Proxy.CreateTaskElement(name).Import(this.Linker);
+            return (ProjectTaskElement)Proxy.CreateTaskElement(name).Import(Linker);
         }
         public override ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture)
         {
-            return (ProjectUsingTaskElement)this.Proxy.CreateUsingTaskElement(taskName, assemblyFile, assemblyName, runtime, architecture).Import(this.Linker);
+            return (ProjectUsingTaskElement)Proxy.CreateUsingTaskElement(taskName, assemblyFile, assemblyName, runtime, architecture).Import(Linker);
         }
         public override UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement()
         {
-            return (UsingTaskParameterGroupElement)this.Proxy.CreateUsingTaskParameterGroupElement().Import(this.Linker);
+            return (UsingTaskParameterGroupElement)Proxy.CreateUsingTaskParameterGroupElement().Import(Linker);
         }
         public override ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType)
         {
-            return (ProjectUsingTaskParameterElement)this.Proxy.CreateUsingTaskParameterElement(name, output, required, parameterType).Import(this.Linker);
+            return (ProjectUsingTaskParameterElement)Proxy.CreateUsingTaskParameterElement(name, output, required, parameterType).Import(Linker);
         }
         public override ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body)
         {
-            return (ProjectUsingTaskBodyElement)this.Proxy.CreateUsingTaskBodyElement(evaluate, body).Import(this.Linker);
+            return (ProjectUsingTaskBodyElement)Proxy.CreateUsingTaskBodyElement(evaluate, body).Import(Linker);
         }
         public override ProjectWhenElement CreateWhenElement(string condition)
         {
-            return (ProjectWhenElement)this.Proxy.CreateWhenElement(condition).Import(this.Linker);
+            return (ProjectWhenElement)Proxy.CreateWhenElement(condition).Import(Linker);
         }
         public override ProjectSdkElement CreateProjectSdkElement(string sdkName, string sdkVersion)
         {
-            return (ProjectSdkElement)this.Proxy.CreateProjectSdkElement(sdkName, sdkVersion).Import(this.Linker);
+            return (ProjectSdkElement)Proxy.CreateProjectSdkElement(sdkName, sdkVersion).Import(Linker);
         }
         public override void Save(Encoding saveEncoding)
         {
-            this.Proxy.Save(saveEncoding);
+            Proxy.Save(saveEncoding);
         }
         public override void Save(TextWriter writer)
         {
-            this.Proxy.Save(writer);
+            Proxy.Save(writer);
         }
         public override void ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting)
         {
-            this.Proxy.ReloadFrom(path, throwIfUnsavedChanges, preserveFormatting);
+            Proxy.ReloadFrom(path, throwIfUnsavedChanges, preserveFormatting);
         }
         public override void ReloadFrom(XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting)
         {
-            this.Proxy.ReloadFrom(reader, throwIfUnsavedChanges, preserveFormatting);
+            Proxy.ReloadFrom(reader, throwIfUnsavedChanges, preserveFormatting);
         }
         public override void MarkDirty(string reason, string param)
         {
-            this.Proxy.MarkDirty(reason, param);
+            Proxy.MarkDirty(reason, param);
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectSdkElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectSdkElementLink.cs
index 9663cb312c9..5348481ccf2 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectSdkElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectSdkElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectSdkElementLink : ProjectSdkElementLink, ILinkMo
     {
         public MockProjectSdkElementLink(MockProjectSdkElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectSdkElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTargetElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTargetElementLink.cs
index e7b1c473978..e75ec8c51d7 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTargetElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTargetElementLink.cs
@@ -25,28 +25,28 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         }
 
 
-        public string Name { get => this.TargetXml.Name; set => this.TargetXml.Name = value; }
-        public string Returns { set => this.TargetXml.Returns = value; }
+        public string Name { get => TargetXml.Name; set => TargetXml.Name = value; }
+        public string Returns { set => TargetXml.Returns = value; }
     }
 
     internal sealed class MockProjectTargetElementLink : ProjectTargetElementLink, ILinkMock, IProjectElementLinkHelper, IProjectElementContainerLinkHelper
     {
         public MockProjectTargetElementLink(MockProjectTargetElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectTargetElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         // ProjectTargetElementLink -----
-        public override string Name { get => this.Proxy.Name; set => this.Proxy.Name = value; }
-        public override string Returns { set => this.Proxy.Returns = value; }
+        public override string Name { get => Proxy.Name; set => Proxy.Name = value; }
+        public override string Returns { set => Proxy.Returns = value; }
         // ----------------------------
 
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTaskElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTaskElementLink.cs
index 2be15a871d7..8b5ff5ece18 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTaskElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectTaskElementLink.cs
@@ -28,38 +28,38 @@ public IDictionary<string, string> Parameters
         {
             get
             {
-                var local = this.TaskXml.Parameters;
+                var local = TaskXml.Parameters;
                 return local == null ? local : new Dictionary<string, string>(local);
             }
         }
-        public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations => this.TaskXml.ParameterLocations;
-        public string GetParameter(string name) { return this.TaskXml.GetParameter(name); }
-        public void SetParameter(string name, string unevaluatedValue) { this.TaskXml.SetParameter(name, unevaluatedValue); }
-        public void RemoveParameter(string name) { this.TaskXml.RemoveParameter(name); }
-        public void RemoveAllParameters() { this.TaskXml.RemoveAllParameters(); }
+        public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations => TaskXml.ParameterLocations;
+        public string GetParameter(string name) { return TaskXml.GetParameter(name); }
+        public void SetParameter(string name, string unevaluatedValue) { TaskXml.SetParameter(name, unevaluatedValue); }
+        public void RemoveParameter(string name) { TaskXml.RemoveParameter(name); }
+        public void RemoveAllParameters() { TaskXml.RemoveAllParameters(); }
     }
 
     internal sealed class MockProjectTaskElementLink : ProjectTaskElementLink, ILinkMock, IProjectElementLinkHelper, IProjectElementContainerLinkHelper
     {
         public MockProjectTaskElementLink(MockProjectTaskElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectTaskElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         // ProjectTaskElementLink -----
-        public override IDictionary<string, string> Parameters => this.Proxy.Parameters;
-        public override IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations => this.Proxy.ParameterLocations;
-        public override string GetParameter(string name) { return this.Proxy.GetParameter(name); }
+        public override IDictionary<string, string> Parameters => Proxy.Parameters;
+        public override IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations => Proxy.ParameterLocations;
+        public override string GetParameter(string name) { return Proxy.GetParameter(name); }
         // hmm did not know can use => on functions, can clean the milion other cases some tiem ...
-        public override void SetParameter(string name, string unevaluatedValue) => this.Proxy.SetParameter(name, unevaluatedValue);
+        public override void SetParameter(string name, string unevaluatedValue) => Proxy.SetParameter(name, unevaluatedValue);
         public override void RemoveParameter(string name) => Proxy.RemoveParameter(name);
         public override void RemoveAllParameters() => Proxy.RemoveAllParameters();
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskBodyElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskBodyElementLink.cs
index e1bdae40e51..8bf00e5e8a8 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskBodyElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskBodyElementLink.cs
@@ -25,25 +25,25 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         }
 
         // ProjectUsingTaskBodyElementLink support
-        public string TaskBody { get => this.UsingTaskBodyXml.TaskBody; set => this.UsingTaskBodyXml.TaskBody = value; }
+        public string TaskBody { get => UsingTaskBodyXml.TaskBody; set => UsingTaskBodyXml.TaskBody = value; }
     }
 
     internal sealed class MockProjectUsingTaskBodyElementLink : ProjectUsingTaskBodyElementLink, ILinkMock, IProjectElementLinkHelper
     {
         public MockProjectUsingTaskBodyElementLink(MockProjectUsingTaskBodyElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectUsingTaskBodyElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
         // ProjectUsingTaskBodyElementLink
-        public override string TaskBody { get => this.Proxy.TaskBody; set => this.Proxy.TaskBody = value; }
+        public override string TaskBody { get => Proxy.TaskBody; set => Proxy.TaskBody = value; }
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskElementLink.cs
index 8948a31fdf0..0aa5d68591b 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectUsingTaskElementLink : ProjectUsingTaskElementL
     {
         public MockProjectUsingTaskElementLink(MockProjectUsingTaskElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectUsingTaskElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskParameterElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskParameterElementLink.cs
index d1b96ecefec..f5ba5d26996 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskParameterElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectUsingTaskParameterElementLink.cs
@@ -23,22 +23,22 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
             return holder.Linker.LinkFactory.Create(link);
         }
 
-        public string Name { get => this.TaskParamXml.Name; set => TaskParamXml.Name = value; }
+        public string Name { get => TaskParamXml.Name; set => TaskParamXml.Name = value; }
     }
 
     internal sealed class MockProjectUsingTaskParameterElementLink : ProjectUsingTaskParameterElementLink, ILinkMock, IProjectElementLinkHelper
     {
         public MockProjectUsingTaskParameterElementLink(MockProjectUsingTaskParameterElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectUsingTaskParameterElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
 
         public override string Name { get => Proxy.Name; set => Proxy.Name = value; }
         #region ProjectElementLink redirectors
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectWhenElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectWhenElementLink.cs
index 6d9f536f43b..da90425786a 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectWhenElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectWhenElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockProjectWhenElementLink : ProjectWhenElementLink, ILink
     {
         public MockProjectWhenElementLink(MockProjectWhenElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectWhenElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockUsingTaskParameterGroupElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockUsingTaskParameterGroupElementLink.cs
index a1926cee93d..87495ddcb54 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockUsingTaskParameterGroupElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockUsingTaskParameterGroupElementLink.cs
@@ -27,16 +27,16 @@ internal sealed class MockUsingTaskParameterGroupElementLink : UsingTaskParamete
     {
         public MockUsingTaskParameterGroupElementLink(MockUsingTaskParameterGroupElementLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockUsingTaskParameterGroupElementLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
-        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => this.Proxy;
-        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
+        MockProjectElementLinkRemoter IProjectElementLinkHelper.ElementProxy => Proxy;
+        MockProjectElementContainerLinkRemoter IProjectElementContainerLinkHelper.ContainerProxy => Proxy;
 
         #region ProjectElementLink redirectors
         private IProjectElementLinkHelper EImpl => (IProjectElementLinkHelper)this;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
index e4cdda6ef58..b9acdb0107e 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
@@ -29,16 +29,16 @@ public static ElementInfo New<T, RMock>()
 
             public ElementInfo(Type type, Func<ProjectElement, bool> checker, ExporterFactory factory)
             {
-                this.CanonicalType = type;
-                this.Checker = checker;
-                this.ExportFactory = factory;
+                CanonicalType = type;
+                Checker = checker;
+                ExportFactory = factory;
             }
 
 
             public ElementInfo(Func<ProjectElement, bool> checker, ExporterFactory factory)
             {
-                this.Checker = checker;
-                this.ExportFactory = factory;
+                Checker = checker;
+                ExportFactory = factory;
             }
 
             public Type CanonicalType { get; }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
index f8d3cb321d5..f12ac0ebdf2 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
@@ -27,10 +27,10 @@ internal sealed class RemotedResolvedImport
     {
         public RemotedResolvedImport(ResolvedImport resolvedImport, ProjectCollectionLinker exporter)
         {
-            this.ImportingElement = exporter.Export<ProjectElement, MockProjectImportElementLinkRemoter>(resolvedImport.ImportingElement);
-            this.ImportedProject = exporter.Export<ProjectElement, MockProjectRootElementLinkRemoter>(resolvedImport.ImportedProject);
-            this.IsImported = resolvedImport.IsImported;
-            this.SdkResult = resolvedImport.SdkResult;
+            ImportingElement = exporter.Export<ProjectElement, MockProjectImportElementLinkRemoter>(resolvedImport.ImportingElement);
+            ImportedProject = exporter.Export<ProjectElement, MockProjectRootElementLinkRemoter>(resolvedImport.ImportedProject);
+            IsImported = resolvedImport.IsImported;
+            SdkResult = resolvedImport.SdkResult;
         }
 
         public MockProjectImportElementLinkRemoter ImportingElement { get; }
@@ -43,9 +43,9 @@ public RemotedResolvedImport(ResolvedImport resolvedImport, ProjectCollectionLin
 
         private ResolvedImport Import(ProjectCollectionLinker importer)
         {
-            var importElement = (ProjectImportElement)importer.Import<ProjectElement, MockProjectImportElementLinkRemoter>(this.ImportingElement);
-            var projectElement = (ProjectRootElement)importer.Import<ProjectElement, MockProjectRootElementLinkRemoter>(this.ImportedProject);
-            return importer.LinkFactory.Create(importElement, projectElement, 0, this.SdkResult, this.IsImported);
+            var importElement = (ProjectImportElement)importer.Import<ProjectElement, MockProjectImportElementLinkRemoter>(ImportingElement);
+            var projectElement = (ProjectRootElement)importer.Import<ProjectElement, MockProjectRootElementLinkRemoter>(ImportedProject);
+            return importer.LinkFactory.Create(importElement, projectElement, 0, SdkResult, IsImported);
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemDefinitionLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemDefinitionLink.cs
index 1d8222f47eb..02bc6217e53 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemDefinitionLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemDefinitionLink.cs
@@ -18,38 +18,38 @@ public override ProjectItemDefinition CreateLinkedObject(IImportHolder holder)
         }
 
         // ProjectItemDefinitionLink remoting
-        public MockProjectLinkRemoter Project => this.OwningCollection.Export<Project, MockProjectLinkRemoter>(this.Source.Project);
-        public string ItemType => this.Source.ItemType;
-        public ICollection<MockProjectMetadataLinkRemoter> Metadata => this.OwningCollection.ExportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.Metadata);
+        public MockProjectLinkRemoter Project => OwningCollection.Export<Project, MockProjectLinkRemoter>(Source.Project);
+        public string ItemType => Source.ItemType;
+        public ICollection<MockProjectMetadataLinkRemoter> Metadata => OwningCollection.ExportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.Metadata);
         public MockProjectMetadataLinkRemoter GetMetadata(string name)
-            => this.OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.GetMetadata(name));
-        public string GetMetadataValue(string name) => this.Source.GetMetadataValue(name);
+            => OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.GetMetadata(name));
+        public string GetMetadataValue(string name) => Source.GetMetadataValue(name);
         public MockProjectMetadataLinkRemoter SetMetadataValue(string name, string unevaluatedValue)
-            => this.OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.SetMetadataValue(name, unevaluatedValue));
+            => OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.SetMetadataValue(name, unevaluatedValue));
     }
 
     internal sealed class MockProjectItemDefinitionLink : ProjectItemDefinitionLink, ILinkMock
     {
         public MockProjectItemDefinitionLink(MockProjectItemDefinitionLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectItemDefinitionLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
 
         // ProjectItemDefinitionLink
-        public override Project Project => this.Linker.Import<Project, MockProjectLinkRemoter>(this.Proxy.Project);
-        public override string ItemType => this.Proxy.ItemType;
+        public override Project Project => Linker.Import<Project, MockProjectLinkRemoter>(Proxy.Project);
+        public override string ItemType => Proxy.ItemType;
         public override ICollection<ProjectMetadata> Metadata
-            => this.Linker.ImportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.Metadata);
+            => Linker.ImportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.Metadata);
         public override ProjectMetadata GetMetadata(string name)
-            => this.Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.GetMetadata(name));
-        public override string GetMetadataValue(string name) => this.Proxy.GetMetadataValue(name);
+            => Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.GetMetadata(name));
+        public override string GetMetadataValue(string name) => Proxy.GetMetadataValue(name);
         public override ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
-            => this.Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.SetMetadataValue(name, unevaluatedValue));
+            => Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.SetMetadataValue(name, unevaluatedValue));
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemLink.cs
index b2e6a366b81..91c60ab9b0a 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemLink.cs
@@ -19,52 +19,52 @@ public override ProjectItem CreateLinkedObject(IImportHolder holder)
         }
 
         // ProjectItemLink remoting
-        public MockProjectLinkRemoter Project => this.OwningCollection.Export<Project, MockProjectLinkRemoter>(this.Source.Project);
-        public MockProjectItemElementLinkRemoter Xml => (MockProjectItemElementLinkRemoter)this.OwningCollection.ExportElement(this.Source.Xml);
-        public string EvaluatedInclude => this.Source.EvaluatedInclude;
-        public ICollection<MockProjectMetadataLinkRemoter> MetadataCollection => this.OwningCollection.ExportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.Metadata);
-        public ICollection<MockProjectMetadataLinkRemoter> DirectMetadata => this.OwningCollection.ExportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.DirectMetadata);
-        public bool HasMetadata(string name) => this.Source.HasMetadata(name);
+        public MockProjectLinkRemoter Project => OwningCollection.Export<Project, MockProjectLinkRemoter>(Source.Project);
+        public MockProjectItemElementLinkRemoter Xml => (MockProjectItemElementLinkRemoter)OwningCollection.ExportElement(Source.Xml);
+        public string EvaluatedInclude => Source.EvaluatedInclude;
+        public ICollection<MockProjectMetadataLinkRemoter> MetadataCollection => OwningCollection.ExportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.Metadata);
+        public ICollection<MockProjectMetadataLinkRemoter> DirectMetadata => OwningCollection.ExportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.DirectMetadata);
+        public bool HasMetadata(string name) => Source.HasMetadata(name);
         public MockProjectMetadataLinkRemoter GetMetadata(string name)
-            => this.OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.GetMetadata(name));
-        public string GetMetadataValue(string name) => this.Source.GetMetadataValue(name);
+            => OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.GetMetadata(name));
+        public string GetMetadataValue(string name) => Source.GetMetadataValue(name);
         public MockProjectMetadataLinkRemoter SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems)
-            => this.OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.SetMetadataValue(name, unevaluatedValue, propagateMetadataToSiblingItems));
-        public bool RemoveMetadata(string name) => this.Source.RemoveMetadata(name);
-        public void Rename(string name) => this.Source.Rename(name);
-        public void ChangeItemType(string newItemType) => this.Source.ItemType = newItemType;
+            => OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.SetMetadataValue(name, unevaluatedValue, propagateMetadataToSiblingItems));
+        public bool RemoveMetadata(string name) => Source.RemoveMetadata(name);
+        public void Rename(string name) => Source.Rename(name);
+        public void ChangeItemType(string newItemType) => Source.ItemType = newItemType;
     }
 
     internal sealed class MockProjectItemLink : ProjectItemLink, ILinkMock
     {
         public MockProjectItemLink(MockProjectItemLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectItemLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
 
         // ProjectItemLink
 
-        public override Project Project => this.Linker.Import<Project, MockProjectLinkRemoter>(this.Proxy.Project);
-        public override ProjectItemElement Xml => (ProjectItemElement)this.Proxy.Xml.Import(this.Linker);
-        public override string EvaluatedInclude => this.Proxy.EvaluatedInclude;
+        public override Project Project => Linker.Import<Project, MockProjectLinkRemoter>(Proxy.Project);
+        public override ProjectItemElement Xml => (ProjectItemElement)Proxy.Xml.Import(Linker);
+        public override string EvaluatedInclude => Proxy.EvaluatedInclude;
         public override ICollection<ProjectMetadata> MetadataCollection
-            => this.Linker.ImportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.MetadataCollection);
+            => Linker.ImportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.MetadataCollection);
         public override ICollection<ProjectMetadata> DirectMetadata
-            => this.Linker.ImportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.DirectMetadata);
-        public override bool HasMetadata(string name) => this.Proxy.HasMetadata(name);
+            => Linker.ImportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.DirectMetadata);
+        public override bool HasMetadata(string name) => Proxy.HasMetadata(name);
         public override ProjectMetadata GetMetadata(string name)
-            => this.Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.GetMetadata(name));
-        public override string GetMetadataValue(string name) => this.Proxy.GetMetadataValue(name);
+            => Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.GetMetadata(name));
+        public override string GetMetadataValue(string name) => Proxy.GetMetadataValue(name);
         public override ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems)
-            => this.Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.SetMetadataValue(name, unevaluatedValue, propagateMetadataToSiblingItems));
-        public override bool RemoveMetadata(string name) => this.Proxy.RemoveMetadata(name);
-        public override void Rename(string name) => this.Proxy.Rename(name);
-        public override void ChangeItemType(string newItemType) => this.Proxy.ChangeItemType(newItemType);
+            => Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.SetMetadataValue(name, unevaluatedValue, propagateMetadataToSiblingItems));
+        public override bool RemoveMetadata(string name) => Proxy.RemoveMetadata(name);
+        public override void Rename(string name) => Proxy.Rename(name);
+        public override void ChangeItemType(string newItemType) => Proxy.ChangeItemType(newItemType);
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index 11c0b2b2ff0..4d2c4ed96f9 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -25,92 +25,92 @@ public override Project CreateLinkedObject(IImportHolder holder)
         }
 
         // ProjectLink remoting
-        public MockProjectElementLinkRemoter Xml => this.OwningCollection.ExportElement(this.Source.Xml);
+        public MockProjectElementLinkRemoter Xml => OwningCollection.ExportElement(Source.Xml);
 
-        public bool ThrowInsteadOfSplittingItemElement { get => this.Source.ThrowInsteadOfSplittingItemElement; set => this.Source.ThrowInsteadOfSplittingItemElement = value; }
+        public bool ThrowInsteadOfSplittingItemElement { get => Source.ThrowInsteadOfSplittingItemElement; set => Source.ThrowInsteadOfSplittingItemElement = value; }
 
-        public bool IsDirty => this.Source.IsDirty;
+        public bool IsDirty => Source.IsDirty;
 
         // all bellow are very inefficient,
         // in reality we do cache these collections  until invalidated and use lazy access for dictionaries.
         // TODO: Might bring that infrastructure here as well ...
-        public IDictionary<string, string> GlobalProperties => this.Source.GlobalProperties;
-        public ICollection<string> ItemTypes => this.Source.ItemTypes;
+        public IDictionary<string, string> GlobalProperties => Source.GlobalProperties;
+        public ICollection<string> ItemTypes => Source.ItemTypes;
 
         public ICollection<MockProjectPropertyLinkRemoter> Properties
-            => this.OwningCollection.ExportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Source.Properties);
+            => OwningCollection.ExportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(Source.Properties);
 
-        public IDictionary<string, List<string>> ConditionedProperties => this.Source.ConditionedProperties;
+        public IDictionary<string, List<string>> ConditionedProperties => Source.ConditionedProperties;
 
         public IDictionary<string, MockProjectItemDefinitionLinkRemoter> ItemDefinitions
-            => this.OwningCollection.ExportDictionary<string, ProjectItemDefinition, MockProjectItemDefinitionLinkRemoter>(this.Source.ItemDefinitions);
+            => OwningCollection.ExportDictionary<string, ProjectItemDefinition, MockProjectItemDefinitionLinkRemoter>(Source.ItemDefinitions);
 
-        public ICollection<MockProjectItemLinkRemoter> Items => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.Items);
+        public ICollection<MockProjectItemLinkRemoter> Items => OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(Source.Items);
 
-        public ICollection<MockProjectItemLinkRemoter> ItemsIgnoringCondition => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.ItemsIgnoringCondition);
+        public ICollection<MockProjectItemLinkRemoter> ItemsIgnoringCondition => OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(Source.ItemsIgnoringCondition);
 
-        public IList<RemotedResolvedImport> Imports => this.Source.Imports.ConvertCollection<RemotedResolvedImport, ResolvedImport>((a) => a.Export(this.OwningCollection));
+        public IList<RemotedResolvedImport> Imports => Source.Imports.ConvertCollection((a) => a.Export(OwningCollection));
 
         public IList<RemotedResolvedImport> ImportsIncludingDuplicates
-            => this.Source.Imports.ConvertCollection<RemotedResolvedImport, ResolvedImport>((a) => a.Export(this.OwningCollection));
+            => Source.Imports.ConvertCollection((a) => a.Export(OwningCollection));
 
         public ICollection<MockProjectPropertyLinkRemoter> AllEvaluatedProperties
-            => this.OwningCollection.ExportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Source.AllEvaluatedProperties);
+            => OwningCollection.ExportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(Source.AllEvaluatedProperties);
 
 
         public IList<MockProjectMetadataLinkRemoter> AllEvaluatedItemDefinitionMetadata
-            => this.OwningCollection.ExportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.AllEvaluatedItemDefinitionMetadata);
+            => OwningCollection.ExportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.AllEvaluatedItemDefinitionMetadata);
 
-        public ICollection<MockProjectItemLinkRemoter> AllEvaluatedItems => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.AllEvaluatedItems);
+        public ICollection<MockProjectItemLinkRemoter> AllEvaluatedItems => OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(Source.AllEvaluatedItems);
 
-        public string ToolsVersion => this.Source.ToolsVersion;
-        public string SubToolsetVersion => this.Source.SubToolsetVersion;
-        public bool SkipEvaluation { get => this.Source.SkipEvaluation; set => this.Source.SkipEvaluation = value; }
-        public bool DisableMarkDirty { get => this.Source.DisableMarkDirty; set => this.Source.DisableMarkDirty = value; }
-        public bool IsBuildEnabled { get => this.Source.IsBuildEnabled; set => this.Source.IsBuildEnabled = value; }
-        public int LastEvaluationId => this.Source.LastEvaluationId;
+        public string ToolsVersion => Source.ToolsVersion;
+        public string SubToolsetVersion => Source.SubToolsetVersion;
+        public bool SkipEvaluation { get => Source.SkipEvaluation; set => Source.SkipEvaluation = value; }
+        public bool DisableMarkDirty { get => Source.DisableMarkDirty; set => Source.DisableMarkDirty = value; }
+        public bool IsBuildEnabled { get => Source.IsBuildEnabled; set => Source.IsBuildEnabled = value; }
+        public int LastEvaluationId => Source.LastEvaluationId;
         public IList<MockProjectItemLinkRemoter> AddItem(string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata)
-            => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.AddItem(itemType, unevaluatedInclude, metadata));
+            => OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(Source.AddItem(itemType, unevaluatedInclude, metadata));
         public IList<MockProjectItemLinkRemoter> AddItemFast(string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata)
-            => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.AddItemFast(itemType, unevaluatedInclude, metadata));
+            => OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(Source.AddItemFast(itemType, unevaluatedInclude, metadata));
 
-        public string ExpandString(string unexpandedValue) => this.Source.ExpandString(unexpandedValue);
+        public string ExpandString(string unexpandedValue) => Source.ExpandString(unexpandedValue);
 
         public ICollection<MockProjectItemLinkRemoter> GetItems(string itemType)
-            => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.GetItems(itemType));
+            => OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(Source.GetItems(itemType));
 
         public ICollection<MockProjectItemLinkRemoter> GetItemsByEvaluatedInclude(string evaluatedInclude)
-            => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.GetItemsByEvaluatedInclude(evaluatedInclude));
+            => OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(Source.GetItemsByEvaluatedInclude(evaluatedInclude));
 
         public ICollection<MockProjectItemLinkRemoter> GetItemsIgnoringCondition(string itemType)
-            => this.OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Source.GetItemsIgnoringCondition(itemType));
+            => OwningCollection.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(Source.GetItemsIgnoringCondition(itemType));
 
         public IEnumerable<MockProjectElementLinkRemoter> GetLogicalProject()
-            => this.OwningCollection.ExportCollection(this.Source.GetLogicalProject());
+            => OwningCollection.ExportCollection(Source.GetLogicalProject());
 
-        public MockProjectPropertyLinkRemoter GetProperty(string name) => this.OwningCollection.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Source.GetProperty(name));
-        public string GetPropertyValue(string name) => this.Source.GetPropertyValue(name);
-        public void MarkDirty() => this.Source.MarkDirty();
-        public void ReevaluateIfNecessary(EvaluationContext evaluationContext) => this.Source.ReevaluateIfNecessary(evaluationContext);
-        public bool RemoveGlobalProperty(string name) => this.Source.RemoveGlobalProperty(name);
+        public MockProjectPropertyLinkRemoter GetProperty(string name) => OwningCollection.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(Source.GetProperty(name));
+        public string GetPropertyValue(string name) => Source.GetPropertyValue(name);
+        public void MarkDirty() => Source.MarkDirty();
+        public void ReevaluateIfNecessary(EvaluationContext evaluationContext) => Source.ReevaluateIfNecessary(evaluationContext);
+        public bool RemoveGlobalProperty(string name) => Source.RemoveGlobalProperty(name);
 
-        public bool RemoveItem(MockProjectItemLinkRemoter item) => this.Source.RemoveItem(this.OwningCollection.Import<ProjectItem, MockProjectItemLinkRemoter>(item));
+        public bool RemoveItem(MockProjectItemLinkRemoter item) => Source.RemoveItem(OwningCollection.Import<ProjectItem, MockProjectItemLinkRemoter>(item));
 
         public void RemoveItems(IEnumerable<MockProjectItemLinkRemoter> items)
-            => this.Source.RemoveItems(this.OwningCollection.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(items));
+            => Source.RemoveItems(OwningCollection.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(items));
 
         public bool RemoveProperty(MockProjectPropertyLinkRemoter propertyRemoter)
-            => this.Source.RemoveProperty(this.OwningCollection.Import<ProjectProperty, MockProjectPropertyLinkRemoter>(propertyRemoter));
+            => Source.RemoveProperty(OwningCollection.Import<ProjectProperty, MockProjectPropertyLinkRemoter>(propertyRemoter));
 
         public void SaveLogicalProject(TextWriter writer)
         {
-            this.Source.SaveLogicalProject(writer);
+            Source.SaveLogicalProject(writer);
         }
 
-        public bool SetGlobalProperty(string name, string escapedValue) => this.Source.SetGlobalProperty(name, escapedValue);
+        public bool SetGlobalProperty(string name, string escapedValue) => Source.SetGlobalProperty(name, escapedValue);
 
         public MockProjectPropertyLinkRemoter SetProperty(string name, string unevaluatedValue)
-            => this.OwningCollection.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Source.SetProperty(name, unevaluatedValue));
+            => OwningCollection.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(Source.SetProperty(name, unevaluatedValue));
         public void Unload() { }
     }
 
@@ -118,66 +118,66 @@ internal sealed class MockProjectLink : ProjectLink, ILinkMock
     {
         public MockProjectLink(MockProjectLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
 
         #region ProjectLink
-        public override ProjectRootElement Xml => (ProjectRootElement)this.Proxy.Xml.Import(this.Linker);
+        public override ProjectRootElement Xml => (ProjectRootElement)Proxy.Xml.Import(Linker);
 
-        public override bool ThrowInsteadOfSplittingItemElement { get => this.Proxy.ThrowInsteadOfSplittingItemElement; set => this.Proxy.ThrowInsteadOfSplittingItemElement = value; }
+        public override bool ThrowInsteadOfSplittingItemElement { get => Proxy.ThrowInsteadOfSplittingItemElement; set => Proxy.ThrowInsteadOfSplittingItemElement = value; }
 
-        public override bool IsDirty => this.Proxy.IsDirty;
+        public override bool IsDirty => Proxy.IsDirty;
 
-        public override IDictionary<string, string> GlobalProperties => this.Proxy.GlobalProperties;
+        public override IDictionary<string, string> GlobalProperties => Proxy.GlobalProperties;
 
-        public override ICollection<string> ItemTypes => this.Proxy.ItemTypes;
+        public override ICollection<string> ItemTypes => Proxy.ItemTypes;
 
-        public override ICollection<ProjectProperty> Properties => this.Linker.ImportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Proxy.Properties);
+        public override ICollection<ProjectProperty> Properties => Linker.ImportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(Proxy.Properties);
 
-        public override IDictionary<string, List<string>> ConditionedProperties => this.Proxy.ConditionedProperties;
+        public override IDictionary<string, List<string>> ConditionedProperties => Proxy.ConditionedProperties;
 
         public override IDictionary<string, ProjectItemDefinition> ItemDefinitions
-            => this.Linker.ImportDictionary<string, ProjectItemDefinition, MockProjectItemDefinitionLinkRemoter>(this.Proxy.ItemDefinitions);
+            => Linker.ImportDictionary<string, ProjectItemDefinition, MockProjectItemDefinitionLinkRemoter>(Proxy.ItemDefinitions);
 
-        public override ICollection<ProjectItem> Items => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.Items);
+        public override ICollection<ProjectItem> Items => Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(Proxy.Items);
 
-        public override ICollection<ProjectItem> ItemsIgnoringCondition => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.ItemsIgnoringCondition);
+        public override ICollection<ProjectItem> ItemsIgnoringCondition => Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(Proxy.ItemsIgnoringCondition);
 
         public override IList<ResolvedImport> Imports
-            => this.Proxy.Imports.ConvertCollection<ResolvedImport, RemotedResolvedImport>((a) => a.Import(this.Linker));
+            => Proxy.Imports.ConvertCollection((a) => a.Import(Linker));
 
         public override IList<ResolvedImport> ImportsIncludingDuplicates
-            => this.Proxy.ImportsIncludingDuplicates.ConvertCollection<ResolvedImport, RemotedResolvedImport>((a) => a.Import(this.Linker));
+            => Proxy.ImportsIncludingDuplicates.ConvertCollection((a) => a.Import(Linker));
 
         public override ICollection<ProjectProperty> AllEvaluatedProperties
-            => this.Linker.ImportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Proxy.AllEvaluatedProperties);
+            => Linker.ImportCollection<ProjectProperty, MockProjectPropertyLinkRemoter>(Proxy.AllEvaluatedProperties);
         public override ICollection<ProjectMetadata> AllEvaluatedItemDefinitionMetadata
-            => this.Linker.ImportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.AllEvaluatedItemDefinitionMetadata);
+            => Linker.ImportCollection<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.AllEvaluatedItemDefinitionMetadata);
 
         public override ICollection<ProjectItem> AllEvaluatedItems
-            => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.AllEvaluatedItems);
+            => Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(Proxy.AllEvaluatedItems);
 
-        public override string ToolsVersion => this.Proxy.ToolsVersion;
+        public override string ToolsVersion => Proxy.ToolsVersion;
 
-        public override string SubToolsetVersion => this.Proxy.SubToolsetVersion;
+        public override string SubToolsetVersion => Proxy.SubToolsetVersion;
 
-        public override bool SkipEvaluation { get => this.Proxy.SkipEvaluation; set => this.Proxy.SkipEvaluation = value; }
-        public override bool DisableMarkDirty { get => this.Proxy.DisableMarkDirty; set => this.Proxy.DisableMarkDirty = value; }
-        public override bool IsBuildEnabled { get => this.Proxy.IsBuildEnabled; set => this.Proxy.IsBuildEnabled = value; }
+        public override bool SkipEvaluation { get => Proxy.SkipEvaluation; set => Proxy.SkipEvaluation = value; }
+        public override bool DisableMarkDirty { get => Proxy.DisableMarkDirty; set => Proxy.DisableMarkDirty = value; }
+        public override bool IsBuildEnabled { get => Proxy.IsBuildEnabled; set => Proxy.IsBuildEnabled = value; }
 
-        public override int LastEvaluationId => this.Proxy.LastEvaluationId;
+        public override int LastEvaluationId => Proxy.LastEvaluationId;
 
         public override IList<ProjectItem> AddItem(string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata)
-            => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.AddItem(itemType, unevaluatedInclude, metadata));
+            => Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(Proxy.AddItem(itemType, unevaluatedInclude, metadata));
 
         public override IList<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata)
-            => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.AddItemFast(itemType, unevaluatedInclude, metadata));
+            => Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(Proxy.AddItemFast(itemType, unevaluatedInclude, metadata));
 
         // Building support is not required (and technically not supported for now
         public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
@@ -186,7 +186,7 @@ public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnum
         public override IDictionary<string, ProjectTargetInstance> Targets => throw new NotImplementedException();
         // --------------------------------------------------
 
-        public override string ExpandString(string unexpandedValue) => this.Proxy.ExpandString(unexpandedValue);
+        public override string ExpandString(string unexpandedValue) => Proxy.ExpandString(unexpandedValue);
 
         public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         {
@@ -215,36 +215,36 @@ public override List<ProvenanceResult> GetItemProvenance(ProjectItem item, Evalu
         // ---------------------------------------------------------------------------------------
 
         public override ICollection<ProjectItem> GetItems(string itemType)
-            => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.GetItems(itemType));
+            => Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(Proxy.GetItems(itemType));
         public override ICollection<ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude)
-            => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.GetItemsByEvaluatedInclude(evaluatedInclude));
+            => Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(Proxy.GetItemsByEvaluatedInclude(evaluatedInclude));
 
         public override ICollection<ProjectItem> GetItemsIgnoringCondition(string itemType)
-            => this.Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(this.Proxy.GetItemsIgnoringCondition(itemType));
+            => Linker.ImportCollection<ProjectItem, MockProjectItemLinkRemoter>(Proxy.GetItemsIgnoringCondition(itemType));
 
         public override IEnumerable<ProjectElement> GetLogicalProject()
-            => this.Linker.ImportCollection<ProjectElement>(this.Proxy.GetLogicalProject());
+            => Linker.ImportCollection<ProjectElement>(Proxy.GetLogicalProject());
 
-        public override ProjectProperty GetProperty(string name) => this.Linker.Import<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Proxy.GetProperty(name));
-        public override string GetPropertyValue(string name) => this.Proxy.GetPropertyValue(name);
-        public override void MarkDirty() => this.Proxy.MarkDirty();
-        public override void ReevaluateIfNecessary(EvaluationContext evaluationContext) => this.Proxy.ReevaluateIfNecessary(evaluationContext);
-        public override bool RemoveGlobalProperty(string name) => this.Proxy.RemoveGlobalProperty(name);
+        public override ProjectProperty GetProperty(string name) => Linker.Import<ProjectProperty, MockProjectPropertyLinkRemoter>(Proxy.GetProperty(name));
+        public override string GetPropertyValue(string name) => Proxy.GetPropertyValue(name);
+        public override void MarkDirty() => Proxy.MarkDirty();
+        public override void ReevaluateIfNecessary(EvaluationContext evaluationContext) => Proxy.ReevaluateIfNecessary(evaluationContext);
+        public override bool RemoveGlobalProperty(string name) => Proxy.RemoveGlobalProperty(name);
 
         public override bool RemoveItem(ProjectItem item)
-            => this.Proxy.RemoveItem(this.Linker.Export<ProjectItem, MockProjectItemLinkRemoter>(item));
+            => Proxy.RemoveItem(Linker.Export<ProjectItem, MockProjectItemLinkRemoter>(item));
 
         public override void RemoveItems(IEnumerable<ProjectItem> items)
-            => this.Proxy.RemoveItems(this.Linker.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(items));
+            => Proxy.RemoveItems(Linker.ExportCollection<ProjectItem, MockProjectItemLinkRemoter>(items));
 
-        public override bool RemoveProperty(ProjectProperty property) => this.Proxy.RemoveProperty(this.Linker.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(property));
-        public override void SaveLogicalProject(TextWriter writer) => this.Proxy.SaveLogicalProject(writer);
+        public override bool RemoveProperty(ProjectProperty property) => Proxy.RemoveProperty(Linker.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(property));
+        public override void SaveLogicalProject(TextWriter writer) => Proxy.SaveLogicalProject(writer);
 
-        public override bool SetGlobalProperty(string name, string escapedValue) => this.Proxy.SetGlobalProperty(name, escapedValue);
+        public override bool SetGlobalProperty(string name, string escapedValue) => Proxy.SetGlobalProperty(name, escapedValue);
 
-        public override ProjectProperty SetProperty(string name, string unevaluatedValue) => this.Linker.Import<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Proxy.SetProperty(name, unevaluatedValue));
+        public override ProjectProperty SetProperty(string name, string unevaluatedValue) => Linker.Import<ProjectProperty, MockProjectPropertyLinkRemoter>(Proxy.SetProperty(name, unevaluatedValue));
 
-        public override void Unload() => this.Proxy.Unload();
+        public override void Unload() => Proxy.Unload();
         #endregion
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectMetadataLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectMetadataLink.cs
index fc4755f2a23..3155220deed 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectMetadataLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectMetadataLink.cs
@@ -22,7 +22,7 @@ public object Parent
         {
             get
             {
-                var parent = ProjectMetadataLink.GetParent(this.Source);
+                var parent = ProjectMetadataLink.GetParent(Source);
                 if (parent == null)
                 {
                     return null;
@@ -31,37 +31,37 @@ public object Parent
                 var itemParent = parent as ProjectItem;
                 if (itemParent != null)
                 {
-                    return this.OwningCollection.Export<ProjectItem, MockProjectItemLinkRemoter>(itemParent);
+                    return OwningCollection.Export<ProjectItem, MockProjectItemLinkRemoter>(itemParent);
                 }
 
-                return this.OwningCollection.Export<ProjectItemDefinition, MockProjectItemDefinitionLinkRemoter>((ProjectItemDefinition)parent);
+                return OwningCollection.Export<ProjectItemDefinition, MockProjectItemDefinitionLinkRemoter>((ProjectItemDefinition)parent);
             }
         }
 
-        public MockProjectMetadataElementLinkRemoter Xml => (MockProjectMetadataElementLinkRemoter)this.OwningCollection.ExportElement(this.Source.Xml);
-        public string EvaluatedValueEscaped => ProjectMetadataLink.GetEvaluatedValueEscaped(this.Source);
-        public MockProjectMetadataLinkRemoter Predecessor => this.OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Source.Predecessor);
+        public MockProjectMetadataElementLinkRemoter Xml => (MockProjectMetadataElementLinkRemoter)OwningCollection.ExportElement(Source.Xml);
+        public string EvaluatedValueEscaped => ProjectMetadataLink.GetEvaluatedValueEscaped(Source);
+        public MockProjectMetadataLinkRemoter Predecessor => OwningCollection.Export<ProjectMetadata, MockProjectMetadataLinkRemoter>(Source.Predecessor);
     }
 
     internal sealed class MockProjectMetadataLink : ProjectMetadataLink, ILinkMock
     {
         public MockProjectMetadataLink(MockProjectMetadataLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectMetadataLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
 
         // ProjectMetadataLink
         public override object Parent
         {
             get
             {
-                var parentRemoter = this.Proxy.Parent;
+                var parentRemoter = Proxy.Parent;
                 if (parentRemoter == null)
                 {
                     return null;
@@ -70,15 +70,15 @@ public override object Parent
                 var itemParent = parentRemoter as MockProjectItemLinkRemoter;
                 if (itemParent != null)
                 {
-                    return this.Linker.Import<ProjectItem, MockProjectItemLinkRemoter>(itemParent);
+                    return Linker.Import<ProjectItem, MockProjectItemLinkRemoter>(itemParent);
                 }
 
-                return this.Linker.Import<ProjectItemDefinition, MockProjectItemDefinitionLinkRemoter>((MockProjectItemDefinitionLinkRemoter)parentRemoter);
+                return Linker.Import<ProjectItemDefinition, MockProjectItemDefinitionLinkRemoter>((MockProjectItemDefinitionLinkRemoter)parentRemoter);
             }
         }
 
-        public override ProjectMetadataElement Xml => (ProjectMetadataElement)this.Proxy.Xml.Import(this.Linker);
-        public override string EvaluatedValueEscaped => this.Proxy.EvaluatedValueEscaped;
-        public override ProjectMetadata Predecessor => this.Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(this.Proxy.Predecessor);
+        public override ProjectMetadataElement Xml => (ProjectMetadataElement)Proxy.Xml.Import(Linker);
+        public override string EvaluatedValueEscaped => Proxy.EvaluatedValueEscaped;
+        public override ProjectMetadata Predecessor => Linker.Import<ProjectMetadata, MockProjectMetadataLinkRemoter>(Proxy.Predecessor);
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
index e0f987ce7c7..cffc67e2941 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
@@ -18,41 +18,41 @@ public override ProjectProperty CreateLinkedObject(IImportHolder holder)
         }
 
         // ProjectPropertyLink remoting
-        public MockProjectLinkRemoter Project => this.OwningCollection.Export<Project, MockProjectLinkRemoter>(this.Source.Project);
-        public MockProjectPropertyElementLinkRemoter Xml => (MockProjectPropertyElementLinkRemoter)this.ExportElement(this.Source.Xml);
-        public string Name => this.Source.Name;
-        public string EvaluatedIncludeEscaped => ProjectPropertyLink.GetEvaluatedValueEscaped(this.Source);
-        public string UnevaluatedValue { get => this.Source.UnevaluatedValue; set => this.Source.UnevaluatedValue = value; }
-        public bool IsEnvironmentProperty => this.Source.IsEnvironmentProperty;
-        public bool IsGlobalProperty => this.Source.IsGlobalProperty;
-        public bool IsReservedProperty => this.Source.IsReservedProperty;
-        public MockProjectPropertyLinkRemoter Predecessor => this.OwningCollection.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Source.Predecessor);
-        public bool IsImported => this.Source.IsImported;
+        public MockProjectLinkRemoter Project => OwningCollection.Export<Project, MockProjectLinkRemoter>(Source.Project);
+        public MockProjectPropertyElementLinkRemoter Xml => (MockProjectPropertyElementLinkRemoter)ExportElement(Source.Xml);
+        public string Name => Source.Name;
+        public string EvaluatedIncludeEscaped => ProjectPropertyLink.GetEvaluatedValueEscaped(Source);
+        public string UnevaluatedValue { get => Source.UnevaluatedValue; set => Source.UnevaluatedValue = value; }
+        public bool IsEnvironmentProperty => Source.IsEnvironmentProperty;
+        public bool IsGlobalProperty => Source.IsGlobalProperty;
+        public bool IsReservedProperty => Source.IsReservedProperty;
+        public MockProjectPropertyLinkRemoter Predecessor => OwningCollection.Export<ProjectProperty, MockProjectPropertyLinkRemoter>(Source.Predecessor);
+        public bool IsImported => Source.IsImported;
     }
 
     internal sealed class MockProjectPropertyLink : ProjectPropertyLink, ILinkMock
     {
         public MockProjectPropertyLink(MockProjectPropertyLinkRemoter proxy, IImportHolder holder)
         {
-            this.Holder = holder;
-            this.Proxy = proxy;
+            Holder = holder;
+            Proxy = proxy;
         }
 
         public IImportHolder Holder { get; }
-        public ProjectCollectionLinker Linker => this.Holder.Linker;
+        public ProjectCollectionLinker Linker => Holder.Linker;
         public MockProjectPropertyLinkRemoter Proxy { get; }
-        object ILinkMock.Remoter => this.Proxy;
+        object ILinkMock.Remoter => Proxy;
 
         // ProjectPropertyLink
-        public override Project Project => this.Linker.Import<Project, MockProjectLinkRemoter>(this.Proxy.Project);
-        public override ProjectPropertyElement Xml => (ProjectPropertyElement)this.Proxy.Xml.Import(this.Linker);
-        public override string Name => this.Proxy.Name;
-        public override string EvaluatedIncludeEscaped => this.Proxy.EvaluatedIncludeEscaped;
-        public override string UnevaluatedValue { get => this.Proxy.UnevaluatedValue; set => this.Proxy.UnevaluatedValue = value; }
-        public override bool IsEnvironmentProperty => this.Proxy.IsEnvironmentProperty;
-        public override bool IsGlobalProperty => this.Proxy.IsGlobalProperty;
-        public override bool IsReservedProperty => this.Proxy.IsReservedProperty;
-        public override ProjectProperty Predecessor => this.Linker.Import<ProjectProperty, MockProjectPropertyLinkRemoter>(this.Proxy.Predecessor);
-        public override bool IsImported => this.Proxy.IsImported;
+        public override Project Project => Linker.Import<Project, MockProjectLinkRemoter>(Proxy.Project);
+        public override ProjectPropertyElement Xml => (ProjectPropertyElement)Proxy.Xml.Import(Linker);
+        public override string Name => Proxy.Name;
+        public override string EvaluatedIncludeEscaped => Proxy.EvaluatedIncludeEscaped;
+        public override string UnevaluatedValue { get => Proxy.UnevaluatedValue; set => Proxy.UnevaluatedValue = value; }
+        public override bool IsEnvironmentProperty => Proxy.IsEnvironmentProperty;
+        public override bool IsGlobalProperty => Proxy.IsGlobalProperty;
+        public override bool IsReservedProperty => Proxy.IsReservedProperty;
+        public override ProjectProperty Predecessor => Linker.Import<ProjectProperty, MockProjectPropertyLinkRemoter>(Proxy.Predecessor);
+        public override bool IsImported => Proxy.IsImported;
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
index 05112a6ed62..471b808a1d9 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
@@ -104,19 +104,19 @@ internal interface IRemoterSource
     internal abstract class MockLinkRemoter<T> : ExportedLinksMap.LinkedObject<T>, IRemoterSource
         where T : class
     {
-        object IRemoterSource.RealObject => this.Source;
+        object IRemoterSource.RealObject => Source;
 
         public ProjectCollectionLinker OwningCollection { get; private set; }
 
         public MockProjectElementLinkRemoter ExportElement(ProjectElement obj)
-            => this.OwningCollection.ExportElement(obj);
+            => OwningCollection.ExportElement(obj);
 
-        public UInt32 HostCollectionId => this.OwningCollection.CollectionId;
+        public UInt32 HostCollectionId => OwningCollection.CollectionId;
 
         public override void Initialize(object key, T source, object context)
         {
             base.Initialize(key, source, context);
-            this.OwningCollection = (ProjectCollectionLinker)context;
+            OwningCollection = (ProjectCollectionLinker)context;
         }
 
         public abstract T CreateLinkedObject(IImportHolder holder);
@@ -154,17 +154,17 @@ internal sealed class ProjectCollectionLinker : ExternalProjectsProvider
 
         private ProjectCollectionLinker(ConnectedProjectCollections group)
         {
-            this.LinkedCollections = group;
-            this.CollectionId = (UInt32)Interlocked.Increment(ref _collecitonId);
-            this.Collection = new ProjectCollection();
-            this.LinkFactory = LinkedObjectsFactory.Get(this.Collection);
+            LinkedCollections = group;
+            CollectionId = (UInt32)Interlocked.Increment(ref _collecitonId);
+            Collection = new ProjectCollection();
+            LinkFactory = LinkedObjectsFactory.Get(Collection);
         }
 
-        public Project LoadProject(string path) => this.Collection.LoadProject(path);
+        public Project LoadProject(string path) => Collection.LoadProject(path);
 
         public Project LoadProjectIgnoreMissingImports(string path) => LoadProjectWithSettings(path, ProjectLoadSettings.IgnoreMissingImports);
 
-        public Project LoadProjectWithSettings(string path, ProjectLoadSettings settings) => new Project(path, null, null, this.Collection, settings);
+        public Project LoadProjectWithSettings(string path, ProjectLoadSettings settings) => new Project(path, null, null, Collection, settings);
 
 
         public Project LoadInMemoryWithSettings(string content, ProjectLoadSettings settings = ProjectLoadSettings.Default)
@@ -172,7 +172,7 @@ public Project LoadInMemoryWithSettings(string content, ProjectLoadSettings sett
             content = ObjectModelHelpers.CleanupFileContents(content);
             using ProjectRootElementFromString projectRootElementFromString = new(content);
             ProjectRootElement xml = projectRootElementFromString.Project;
-            Project project = new Project(xml, null, null, this.Collection, settings);
+            Project project = new Project(xml, null, null, Collection, settings);
             return project;
         }
 
@@ -186,20 +186,20 @@ public Project LoadInMemoryWithSettings(string content, ProjectLoadSettings sett
 
         public bool Importing
         {
-            get => this.importing;
+            get => importing;
             set
             {
-                if (value != this.importing)
+                if (value != importing)
                 {
-                    ExternalProjectsProvider.SetExternalProjectsProvider(this.Collection, value ? this : null);
-                    this.importing = value;
+                    SetExternalProjectsProvider(Collection, value ? this : null);
+                    importing = value;
                 }
             }
         }
 
         private void ConnectTo(ProjectCollectionLinker other)
         {
-            if (other.CollectionId == this.CollectionId)
+            if (other.CollectionId == CollectionId)
             {
                 throw new Exception("Can not connect to self");
             }
@@ -279,9 +279,9 @@ public T Import<T, RMock>(RMock remoter)
                 return null;
             }
 
-            if (remoter.HostCollectionId == this.CollectionId)
+            if (remoter.HostCollectionId == CollectionId)
             {
-                this.exported.GetActive(remoter.LocalId, out T result);
+                exported.GetActive(remoter.LocalId, out T result);
                 return result;
             }
 
@@ -345,11 +345,11 @@ public override ICollection<Project> GetLoadedProjects(string filePath)
         {
             List<Project> result = new List<Project>();
 
-            foreach (var external in this.imported.Values)
+            foreach (var external in imported.Values)
             {
                 foreach (var remote in external.Linker.ExportLoadedProjects(filePath))
                 {
-                    result.Add(this.Import<Project, MockProjectLinkRemoter>(remote));
+                    result.Add(Import<Project, MockProjectLinkRemoter>(remote));
                 }
             }
 
@@ -359,11 +359,11 @@ public override ICollection<Project> GetLoadedProjects(string filePath)
         private IReadOnlyCollection<MockProjectLinkRemoter> ExportLoadedProjects(string filePath)
         {
             List<MockProjectLinkRemoter> remoted = new List<MockProjectLinkRemoter>();
-            var toRemote = LinkedObjectsFactory.GetLocalProjects(this.Collection, filePath);
+            var toRemote = LinkedObjectsFactory.GetLocalProjects(Collection, filePath);
 
             foreach (var p in toRemote)
             {
-                remoted.Add(this.Export<Project, MockProjectLinkRemoter>(p));
+                remoted.Add(Export<Project, MockProjectLinkRemoter>(p));
             }
 
             return remoted;
@@ -383,12 +383,12 @@ public override void Initialize(uint key, RMock source, object context)
             {
                 base.Initialize(key, source, context);
 
-                this.Remoter = source;
-                this.Linker = (ProjectCollectionLinker)context;
-                this.Linked = source.CreateLinkedObject(this);
+                Remoter = source;
+                Linker = (ProjectCollectionLinker)context;
+                Linked = source.CreateLinkedObject(this);
             }
 
-            object IActiveImportDBG.Linked => this.Linked;
+            object IActiveImportDBG.Linked => Linked;
 
             public ProjectCollectionLinker Linker { get; private set; }
 
@@ -439,7 +439,7 @@ public void ClearAllRemotes()
 
         private void ClearAllRemotes()
         {
-            this.exported = ExportedLinksMap.Create();
+            exported = ExportedLinksMap.Create();
             foreach (var i in imported)
             {
                 i.Value.Clear();
@@ -451,8 +451,8 @@ private sealed class ExternalConnection
         {
             public ExternalConnection(ProjectCollectionLinker linker)
             {
-                this.Linker = linker;
-                this.ActiveImports = ImportedLinksMap.Create();
+                Linker = linker;
+                ActiveImports = ImportedLinksMap.Create();
             }
 
             public ProjectCollectionLinker Linker { get; }
@@ -461,7 +461,7 @@ public ExternalConnection(ProjectCollectionLinker linker)
 
             public void Clear()
             {
-                this.ActiveImports = ImportedLinksMap.Create();
+                ActiveImports = ImportedLinksMap.Create();
             }
         }
     }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
index 16f346a6df6..772ea99d820 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
@@ -105,7 +105,7 @@ private LinkedObject GetOrAdd(LinkedObject ro, Action<UInt32> setter)
         {
             lock (Lock)
             {
-                if (this.CollectionId == 0)
+                if (CollectionId == 0)
                 {
                     throw new ObjectDisposedException(GetType().Name);
                 }
@@ -122,7 +122,7 @@ private LinkedObject GetOrAdd(LinkedObject ro, Action<UInt32> setter)
 
         private LinkedObjectsMap(UInt32 id)
         {
-            this.CollectionId = id;
+            CollectionId = id;
         }
         private UInt32 CollectionId { get; set; }
 
@@ -151,7 +151,7 @@ public void GetActive<SourceType>(UInt32 localId, out SourceType active)
 
             lock (Lock)
             {
-                if (!this.activeLinks.TryGetValue(localId, out var holder))
+                if (!activeLinks.TryGetValue(localId, out var holder))
                 {
                     throw new ObjectDisposedException(typeof(SourceType).Name);
                 }
@@ -183,7 +183,7 @@ public bool GetOrCreate<LinkType, SourceType>(SourceType source, object context,
 
             lock (Lock)
             {
-                if (this.CollectionId == 0)
+                if (CollectionId == 0)
                 {
                     throw new ObjectDisposedException(GetType().Name);
                 }
@@ -228,11 +228,11 @@ public class LinkedObject<SourceType> : LinkedObject
         {
             public virtual void Initialize(KeyType key, SourceType source, object context)
             {
-                this.Key = key;
-                this.Source = source;
+                Key = key;
+                Source = source;
             }
 
-            public override object StrongReference => this.Source;
+            public override object StrongReference => Source;
             public SourceType Source { get; protected set; }
         }
 
@@ -240,14 +240,14 @@ public class LinkedObject : ISourceWithId
         {
             public void ActivateFast(LinkedObjectsMap<KeyType> map)
             {
-                this.CollectionId = map.CollectionId;
-                map.AddUnderLock(this, (id) => this.LocalId = id);
+                CollectionId = map.CollectionId;
+                map.AddUnderLock(this, (id) => LocalId = id);
             }
 
             public LinkedObject ActivateSlow(LinkedObjectsMap<KeyType> map)
             {
-                this.CollectionId = map.CollectionId;
-                return map.GetOrAdd(this, (id) => this.LocalId = id);
+                CollectionId = map.CollectionId;
+                return map.GetOrAdd(this, (id) => LocalId = id);
             }
 
             ~LinkedObject()
@@ -273,10 +273,10 @@ private sealed class WeakHolder
         {
             public WeakHolder(LinkedObject ro)
             {
-                this.StrongReference = ro.StrongReference;
-                this.LocalLinkId = ro.LocalId;
-                this.Key = ro.Key;
-                this.RemoterWeak = new WeakReference<LinkedObject>(ro);
+                StrongReference = ro.StrongReference;
+                LocalLinkId = ro.LocalId;
+                Key = ro.Key;
+                RemoterWeak = new WeakReference<LinkedObject>(ro);
             }
 
             public object StrongReference { get; private set; }
@@ -291,10 +291,10 @@ public WeakHolder(LinkedObject ro)
 
             public void Invalidate()
             {
-                this.StrongReference = null;
-                this.LocalLinkId = 0;
-                this.Key = default(KeyType);
-                this.RemoterWeak = null;
+                StrongReference = null;
+                LocalLinkId = 0;
+                Key = default(KeyType);
+                RemoterWeak = null;
             }
         }
     }
diff --git a/src/Build.OM.UnitTests/TransientIO.cs b/src/Build.OM.UnitTests/TransientIO.cs
index 2bf038c227c..75628c198b7 100644
--- a/src/Build.OM.UnitTests/TransientIO.cs
+++ b/src/Build.OM.UnitTests/TransientIO.cs
@@ -19,15 +19,15 @@ public class TransientIO : IDisposable
 
         private DirectoryInfo EnsureTempRoot()
         {
-            if (this.root == null)
+            if (root == null)
             {
-                this.root = new DirectoryInfo(
-                    this.Parent != null ?
-                          this.Parent.GetAbsolutePath(this.SubFolder)
+                root = new DirectoryInfo(
+                    Parent != null ?
+                          Parent.GetAbsolutePath(SubFolder)
                         : FileUtilities.GetTemporaryDirectory(true));
             }
 
-            return this.root;
+            return root;
         }
 
         private static bool IsDirSlash(char c) => c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar;
@@ -38,18 +38,18 @@ public TransientIO()
 
         private TransientIO(TransientIO parent, string subFolder)
         {
-            this.SubFolder = subFolder;
-            this.Parent = parent;
+            SubFolder = subFolder;
+            Parent = parent;
         }
 
         public bool IsControled(string path)
         {
-            if (this.root == null || path == null)
+            if (root == null || path == null)
             {
                 return false;
             }
 
-            var tempRoot = this.RootFolder;
+            var tempRoot = RootFolder;
             path = Path.GetFullPath(path);
             return path != null && tempRoot != null
                 && path.Length > tempRoot.Length
@@ -61,7 +61,7 @@ public bool IsControled(string path)
 
         public void EnsureFileLocation(string path)
         {
-            var absolute = this.GetAbsolutePath(path);
+            var absolute = GetAbsolutePath(path);
             var parent = Path.GetDirectoryName(absolute);
             if (!Directory.Exists(parent))
             {
@@ -73,11 +73,11 @@ public string GetRelativePath(string path)
         {
             var absolute = GetAbsolutePath(path);
 
-            return absolute.Substring(this.RootFolder.Length + 1);
+            return absolute.Substring(RootFolder.Length + 1);
         }
         public string GetAbsolutePath(string relative)
         {
-            var tempRoot = this.RootFolder;
+            var tempRoot = RootFolder;
 
             var absolute = Path.GetFullPath(Path.IsPathRooted(relative) ? relative : Path.Combine(tempRoot, relative));
             if (!IsControled(absolute))
@@ -90,11 +90,11 @@ public string GetAbsolutePath(string relative)
 
         public TransientIO GetSubFolder(string path)
         {
-            var subFolder = this.GetRelativePath(path);
-            if (!this.Children.TryGetValue(subFolder, out var result))
+            var subFolder = GetRelativePath(path);
+            if (!Children.TryGetValue(subFolder, out var result))
             {
                 result = new TransientIO(this, subFolder);
-                this.Children.Add(subFolder, result);
+                Children.Add(subFolder, result);
             }
 
             return result;
@@ -102,20 +102,20 @@ public TransientIO GetSubFolder(string path)
 
         public string WriteProjectFile(string path, string content)
         {
-            var absolute = this.GetAbsolutePath(path);
+            var absolute = GetAbsolutePath(path);
             content = ObjectModelHelpers.CleanupFileContents(content);
-            this.EnsureFileLocation(absolute);
+            EnsureFileLocation(absolute);
             File.WriteAllText(absolute, content);
             return absolute;
         }
 
         public void Clear()
         {
-            if (this.root != null && Directory.Exists(this.root.FullName))
+            if (root != null && Directory.Exists(root.FullName))
             {
                 // Note: FileUtilities.DeleteDirectoryNoThrow will be very slow if the directory does not exists. (it will retry with timeout in this case for ~0.5 sec).
                 // not sure if that was intentional, so have not fixed it there but instead we check exist here.
-                FileUtilities.DeleteDirectoryNoThrow(this.root.FullName, true);
+                FileUtilities.DeleteDirectoryNoThrow(root.FullName, true);
             }
 
             Reset();
@@ -123,8 +123,8 @@ public void Clear()
 
         private void Reset()
         {
-            this.root = null;
-            foreach (var child in this.Children.Values)
+            root = null;
+            foreach (var child in Children.Values)
             {
                 child.Reset();
             }
@@ -132,7 +132,7 @@ private void Reset()
 
         public void Dispose()
         {
-            this.Clear();
+            Clear();
             // this object still can be used ...
         }
     }
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index 55834d7d650..141dcfa47af 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -512,10 +512,10 @@ public void TestSerializeDictionaryStringTNoComparer()
             value["foo"] = new BaseClass(1);
             value["alpha"] = new BaseClass(2);
 
-            TranslationHelpers.GetWriteTranslator().TranslateDictionary<Dictionary<string, BaseClass>, BaseClass>(ref value, BaseClass.FactoryForDeserialization);
+            TranslationHelpers.GetWriteTranslator().TranslateDictionary(ref value, BaseClass.FactoryForDeserialization);
 
             Dictionary<string, BaseClass> deserializedValue = null;
-            TranslationHelpers.GetReadTranslator().TranslateDictionary<Dictionary<string, BaseClass>, BaseClass>(ref deserializedValue, BaseClass.FactoryForDeserialization);
+            TranslationHelpers.GetReadTranslator().TranslateDictionary(ref deserializedValue, BaseClass.FactoryForDeserialization);
 
             Assert.Equal(value.Count, deserializedValue.Count);
             Assert.Equal(0, BaseClass.Comparer.Compare(value["foo"], deserializedValue["foo"]));
@@ -532,10 +532,10 @@ public void TestSerializeDictionaryStringTNoComparerNull()
         {
             Dictionary<string, BaseClass> value = null;
 
-            TranslationHelpers.GetWriteTranslator().TranslateDictionary<Dictionary<string, BaseClass>, BaseClass>(ref value, BaseClass.FactoryForDeserialization);
+            TranslationHelpers.GetWriteTranslator().TranslateDictionary(ref value, BaseClass.FactoryForDeserialization);
 
             Dictionary<string, BaseClass> deserializedValue = null;
-            TranslationHelpers.GetReadTranslator().TranslateDictionary<Dictionary<string, BaseClass>, BaseClass>(ref deserializedValue, BaseClass.FactoryForDeserialization);
+            TranslationHelpers.GetReadTranslator().TranslateDictionary(ref deserializedValue, BaseClass.FactoryForDeserialization);
 
             Assert.Equal(value, deserializedValue);
         }
@@ -892,7 +892,7 @@ public override bool Equals(object obj)
                     return true;
                 }
 
-                if (obj.GetType() != this.GetType())
+                if (obj.GetType() != GetType())
                 {
                     return false;
                 }
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 2111a5ee369..dcab643fc52 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -4392,7 +4392,7 @@ public override bool Execute()
         [InlineData("TaskHostFactory", true)] // OOP task host, input logging enabled
         public void TaskInputLoggingIsExposedToTasks(string taskFactory, bool taskInputLoggingEnabled)
         {
-            string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
+            string projectContents = CleanupFileContents(@"<Project>
 
   <UsingTask
     TaskName=""" + typeof(LogTaskInputsCheckingTask).FullName + @"""
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index b4efa7ea860..6281b806c8d 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -195,8 +195,8 @@ public void ContinueRequestWithResources(ResourceResponse response)
 
             public void CancelRequest()
             {
-                this.BeginCancel();
-                this.WaitForCancelCompletion();
+                BeginCancel();
+                WaitForCancelCompletion();
             }
 
             public void BeginCancel()
@@ -318,13 +318,13 @@ public void Dispose()
 
         private void ConfigureEngine(IBuildRequestEngine engine)
         {
-            engine.OnNewConfigurationRequest += this.Engine_NewConfigurationRequest;
-            engine.OnRequestBlocked += this.Engine_NewRequest;
-            engine.OnRequestComplete += this.Engine_RequestComplete;
-            engine.OnRequestResumed += this.Engine_RequestResumed;
-            engine.OnStatusChanged += this.Engine_EngineStatusChanged;
-            engine.OnEngineException += this.Engine_Exception;
-            engine.OnResourceRequest += this.Engine_ResourceRequest;
+            engine.OnNewConfigurationRequest += Engine_NewConfigurationRequest;
+            engine.OnRequestBlocked += Engine_NewRequest;
+            engine.OnRequestComplete += Engine_RequestComplete;
+            engine.OnRequestResumed += Engine_RequestResumed;
+            engine.OnStatusChanged += Engine_EngineStatusChanged;
+            engine.OnEngineException += Engine_Exception;
+            engine.OnResourceRequest += Engine_ResourceRequest;
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
index 7ccbcc227b7..0c43b9a76db 100644
--- a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
@@ -69,7 +69,7 @@ public void HasLoggedErrors()
             NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 1, true);
             context.HasLoggedErrors.ShouldBeFalse();
 
-            context.LogCommentFromText(Framework.MessageImportance.High, "Test message");
+            context.LogCommentFromText(MessageImportance.High, "Test message");
             context.HasLoggedErrors.ShouldBeFalse();
 
             context.LogWarningFromText(null, null, null, null, "Test warning");
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index fb932fb70d5..09dae994e92 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -1303,7 +1303,7 @@ private void TestLogTelemetry(BuildEventContext buildEventContext, string eventN
             if (properties != null)
             {
                 // Ensure the properties were cloned into a new dictionary
-                Assert.False(Object.ReferenceEquals(actualEventArgs.Properties, properties));
+                Assert.False(ReferenceEquals(actualEventArgs.Properties, properties));
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 1f08b92bf79..3326ddfd49e 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -5,10 +5,10 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.TelemetryInfra;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 
diff --git a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
index d2241b404ae..cb81dbda862 100644
--- a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
+++ b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
@@ -84,7 +84,7 @@ public Task<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContex
         {
             if (cancellationToken.IsCancellationRequested)
             {
-                return Task<WorkUnitResult>.FromResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));
+                return Task.FromResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));
             }
 
             ProjectOnErrorInstance errorTask = task as ProjectOnErrorInstance;
@@ -117,14 +117,14 @@ public Task<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContex
                 {
                     if (taskInstance.ContinueOnError == "True")
                     {
-                        return Task<WorkUnitResult>.FromResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Continue, null));
+                        return Task.FromResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Continue, null));
                     }
 
-                    return Task<WorkUnitResult>.FromResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
+                    return Task.FromResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
                 }
             }
 
-            return Task<WorkUnitResult>.FromResult(new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null));
+            return Task.FromResult(new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null));
         }
 
         #endregion
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 5a1eb10715b..4626377ce06 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -9,8 +9,8 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 using Xunit;
+using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 74963e26794..e66cf1ed649 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -360,7 +360,7 @@ private static void VerifyLoggingPacket(BuildEventArgs buildEvent, LoggingEventT
             LogMessagePacket packet = new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(0, buildEvent));
             Assert.Equal(logEventType, packet.EventType);
             Assert.Equal(NodePacketType.LogMessage, packet.Type);
-            Assert.True(Object.ReferenceEquals(buildEvent, packet.NodeBuildEvent.Value.Value)); // "Expected buildEvent to have the same object reference as packet.BuildEvent"
+            Assert.True(ReferenceEquals(buildEvent, packet.NodeBuildEvent.Value.Value)); // "Expected buildEvent to have the same object reference as packet.BuildEvent"
         }
 
         #endregion
diff --git a/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs b/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
index cd041632de2..a1d73d9374a 100644
--- a/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
@@ -6,8 +6,8 @@
 using System.Diagnostics;
 using System.Linq;
 using System.Text;
-using Xunit;
 using Shouldly;
+using Xunit;
 
 namespace Microsoft.Build.Framework.Telemetry.Tests
 {
@@ -17,7 +17,7 @@ public class ActivityExtensionsTests
         public void WithTag_ShouldSetUnhashedValue()
         {
             var activity = new Activity("TestActivity");
-            activity.Start(); 
+            activity.Start();
 
             var telemetryItem = new TelemetryItem(
                 Name: "TestItem",
diff --git a/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs b/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
index a2ec5161797..8200014afeb 100644
--- a/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
@@ -3,11 +3,11 @@
 
 using System;
 using System.Reflection;
-using Xunit;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
+using Xunit;
 using Xunit.Abstractions;
-using Microsoft.Build.UnitTests.Shared;
-using Microsoft.Build.UnitTests;
 
 namespace Microsoft.Build.Framework.Telemetry.Tests
 {
diff --git a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
index 61ac9f125d4..d5fac65999d 100644
--- a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
@@ -53,14 +53,14 @@ public RequestBuilder_Tests()
             _host.RequestBuilder = new RequestBuilder();
             ((IBuildComponent)_host.RequestBuilder).InitializeComponent(_host);
 
-            _host.OnLoggingThreadException += this.LoggingException;
+            _host.OnLoggingThreadException += LoggingException;
 
             _newBuildRequestsEvent = new AutoResetEvent(false);
             _buildRequestCompletedEvent = new AutoResetEvent(false);
 
             _requestBuilder = (IRequestBuilder)_host.GetComponent(BuildComponentType.RequestBuilder);
-            _requestBuilder.OnBuildRequestCompleted += this.BuildRequestCompletedCallback;
-            _requestBuilder.OnNewBuildRequests += this.NewBuildRequestsCallback;
+            _requestBuilder.OnBuildRequestCompleted += BuildRequestCompletedCallback;
+            _requestBuilder.OnNewBuildRequests += NewBuildRequestsCallback;
         }
 
         public void Dispose()
@@ -367,7 +367,7 @@ public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, Buil
                 {
                     result.AddResultsForTarget(target.name, BuildResultUtilities.GetEmptyFailingTargetResult());
                 }
-                return Task<BuildResult>.FromResult(result);
+                return Task.FromResult(result);
             }
 
             if (_newRequests != null)
@@ -392,11 +392,11 @@ public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, Buil
                     {
                         result.AddResultsForTarget(target.name, BuildResultUtilities.GetEmptyFailingTargetResult());
                     }
-                    return Task<BuildResult>.FromResult(result);
+                    return Task.FromResult(result);
                 }
             }
 
-            return Task<BuildResult>.FromResult(_cache.GetResultForRequest(entry.Request));
+            return Task.FromResult(_cache.GetResultForRequest(entry.Request));
         }
 
         #endregion
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 298987ef008..f067bcec1f3 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -458,7 +458,7 @@ private sealed class MockSdkResolverLoader : SdkResolverLoader
 
             public Func<Assembly, IEnumerable<Type>> GetResolverTypesFunc { get; set; }
 
-            public Action<string, ElementLocation, List<SdkResolver>> LoadResolversAction { get; set; }
+            public Action<string, ElementLocation, List<SdkResolverBase>> LoadResolversAction { get; set; }
 
             protected override Assembly LoadResolverAssembly(string resolverPath)
             {
@@ -490,7 +490,7 @@ internal override IReadOnlyList<string> FindPotentialSdkResolvers(string rootFol
                 return base.FindPotentialSdkResolvers(rootFolder, location);
             }
 
-            protected override void LoadResolvers(string resolverPath, ElementLocation location, List<SdkResolver> resolvers)
+            protected override void LoadResolvers(string resolverPath, ElementLocation location, List<SdkResolverBase> resolvers)
             {
                 if (LoadResolversAction != null)
                 {
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 11d5207ec9b..00c2782cef6 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -68,7 +68,7 @@ public TargetBuilder_Tests()
             _nodeRequestId = 1;
             _host = new MockHost();
             _mockLogger = new MockLogger();
-            _host.OnLoggingThreadException += this.LoggingException;
+            _host.OnLoggingThreadException += LoggingException;
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index b2cb7cd17bd..abc0e1f82f0 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -59,7 +59,7 @@ public TargetEntry_Tests()
         {
             _nodeRequestId = 1;
             _host = new MockHost();
-            _host.OnLoggingThreadException += this.LoggingException;
+            _host.OnLoggingThreadException += LoggingException;
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 743e165ca0a..60521dafbe7 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -542,8 +542,8 @@ private sealed class FileWriteInfo
 
             public FileWriteInfo(string path, DateTime lastWriteTime)
             {
-                this.Path = path;
-                this.LastWriteTime = lastWriteTime;
+                Path = path;
+                LastWriteTime = lastWriteTime;
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 68a8dea7eb0..9986dd7f7a4 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -434,7 +434,7 @@ public void MSBuildLastTaskResult()
         [Fact]
         public void TasksCanAddRecursiveDirBuiltInMetadata()
         {
-            MockLogger logger = new MockLogger(this._testOutput);
+            MockLogger logger = new MockLogger(_testOutput);
 
             string projectFileContents = ObjectModelHelpers.CleanupFileContents($@"
 <Project>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index ebb24ca82e6..ad4e60cbd1c 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -47,7 +47,7 @@ public void TaskNodesDieAfterBuild()
                 string processId = projectInstance.GetPropertyValue("PID");
                 string.IsNullOrEmpty(processId).ShouldBeFalse();
                 Int32.TryParse(processId, out int pid).ShouldBeTrue();
-                Process.GetCurrentProcess().Id.ShouldNotBe<int>(pid);
+                Process.GetCurrentProcess().Id.ShouldNotBe(pid);
                 try
                 {
                     Process taskHostNode = Process.GetProcessById(pid);
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
index b6b6025441b..c475da6dcac 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
@@ -4,8 +4,8 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Xunit;
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index e643d380c7c..f5eddb4f7dc 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -109,7 +109,7 @@ public void TestLiveTargetOutputs()
             Assert.True(targetOutputItem.Equals(mockItemInCache));
 
             // Assert they are different instances.
-            Assert.False(object.ReferenceEquals(targetOutputItem, mockItemInCache));
+            Assert.False(ReferenceEquals(targetOutputItem, mockItemInCache));
         }
 
         /// <summary>
@@ -1414,7 +1414,7 @@ public BuildResult[] BuildResultsToReturn
             /// </summary>
             public Task<BuildResult[]> BuildProjects(string[] projectFiles, PropertyDictionary<ProjectPropertyInstance>[] properties, string[] toolsVersions, string[] targets, bool waitForResults, bool skipNonexistentTargets)
             {
-                return Task<BuildResult[]>.FromResult(_buildResultsToReturn);
+                return Task.FromResult(_buildResultsToReturn);
             }
 
             /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 6a652802962..fc7bdfe8f15 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -1237,7 +1237,7 @@ public void TaskFactoryWithNullTaskTypeLogsError()
             List<ProjectUsingTaskElement> elementList = new List<ProjectUsingTaskElement>();
             ProjectRootElement project = ProjectRootElement.Create();
 
-            ProjectUsingTaskElement element = project.AddUsingTask("Task1", AssemblyUtilities.GetAssemblyLocation(typeof(TaskRegistry_Tests.NullTaskTypeTaskFactory).GetTypeInfo().Assembly), null);
+            ProjectUsingTaskElement element = project.AddUsingTask("Task1", AssemblyUtilities.GetAssemblyLocation(typeof(NullTaskTypeTaskFactory).GetTypeInfo().Assembly), null);
 
             element.TaskFactory = typeof(NullTaskTypeTaskFactory).FullName;
             elementList.Add(element);
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 3ff827e24aa..9c756f8fc50 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -110,11 +110,11 @@ public void TestBinaryLoggerRoundtrip(string projectText, BinlogRoundtripTestRep
             var mockLogFromBuild = new MockLogger();
 
             var serialFromBuildText = new StringBuilder();
-            var serialFromBuild = new SerialConsoleLogger(Framework.LoggerVerbosity.Diagnostic, t => serialFromBuildText.Append(t), colorSet: null, colorReset: null);
+            var serialFromBuild = new SerialConsoleLogger(LoggerVerbosity.Diagnostic, t => serialFromBuildText.Append(t), colorSet: null, colorReset: null);
             serialFromBuild.Parameters = "NOPERFORMANCESUMMARY";
 
             var parallelFromBuildText = new StringBuilder();
-            var parallelFromBuild = new ParallelConsoleLogger(Framework.LoggerVerbosity.Diagnostic, t => parallelFromBuildText.Append(t), colorSet: null, colorReset: null);
+            var parallelFromBuild = new ParallelConsoleLogger(LoggerVerbosity.Diagnostic, t => parallelFromBuildText.Append(t), colorSet: null, colorReset: null);
             parallelFromBuild.Parameters = "NOPERFORMANCESUMMARY";
 
             // build and log into binary logger, mock logger, serial and parallel console loggers
@@ -158,11 +158,11 @@ public void TestBinaryLoggerRoundtrip(string projectText, BinlogRoundtripTestRep
             var mockLogFromPlayback = new MockLogger();
 
             var serialFromPlaybackText = new StringBuilder();
-            var serialFromPlayback = new SerialConsoleLogger(Framework.LoggerVerbosity.Diagnostic, t => serialFromPlaybackText.Append(t), colorSet: null, colorReset: null);
+            var serialFromPlayback = new SerialConsoleLogger(LoggerVerbosity.Diagnostic, t => serialFromPlaybackText.Append(t), colorSet: null, colorReset: null);
             serialFromPlayback.Parameters = "NOPERFORMANCESUMMARY";
 
             var parallelFromPlaybackText = new StringBuilder();
-            var parallelFromPlayback = new ParallelConsoleLogger(Framework.LoggerVerbosity.Diagnostic, t => parallelFromPlaybackText.Append(t), colorSet: null, colorReset: null);
+            var parallelFromPlayback = new ParallelConsoleLogger(LoggerVerbosity.Diagnostic, t => parallelFromPlaybackText.Append(t), colorSet: null, colorReset: null);
             parallelFromPlayback.Parameters = "NOPERFORMANCESUMMARY";
 
             var binaryLogReader = new BinaryLogReplayEventSource();
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 2eef5fde018..9eed5c0c244 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -140,7 +140,7 @@ public void RoundtripBuildSubmissionStartedEventArgs()
                 flag,
                 submissionId);
 
-            Roundtrip<BuildSubmissionStartedEventArgs>(args,
+            Roundtrip(args,
                 e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
                 e => TranslationHelpers.GetPropertiesString(e.EntryProjectsFullPath),
                 e => TranslationHelpers.GetPropertiesString(e.TargetNames),
@@ -164,7 +164,7 @@ public void RoundtripProjectStartedEventArgs()
                 toolsVersion: "Current");
             args.BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6);
 
-            Roundtrip<ProjectStartedEventArgs>(args,
+            Roundtrip(args,
                 e => ToString(e.BuildEventContext),
                 e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
                 e => TranslationHelpers.GetMultiItemsString(e.Items),
@@ -991,13 +991,13 @@ public void ForwardCompatibleRead_HandleAppendOnlyChanges()
             int positionAfterFirstEvent = (int)memoryStream.Position;
             memoryStream.Position = 0;
             // event type
-            Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int eventSizePos = (int)memoryStream.Position;
-            int eventSize = Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int eventSize = BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int positionAfterFirstEventSize = (int)memoryStream.Position;
             memoryStream.Position = eventSizePos;
             // the extra 4 bytes
-            Microsoft.Build.Shared.BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, eventSize + 4);
+            BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, eventSize + 4);
             memoryStream.Position.ShouldBe(positionAfterFirstEventSize, "The event size need to be overwritten in place - without overwriting any bytes after the size info");
             memoryStream.Position = positionAfterFirstEvent;
 
@@ -1051,13 +1051,13 @@ public void ForwardCompatibleRead_HandleUnknownEvent()
             int positionAfterFirstEvent = (int)memoryStream.Position;
             memoryStream.Position = 0;
             // event type
-            Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int eventSizePos = (int)memoryStream.Position;
             memoryStream.Position = 0;
 
             // some future type that is not known in current version
             BinaryLogRecordKind unknownType = (BinaryLogRecordKind)Enum.GetValues(typeof(BinaryLogRecordKind)).Cast<BinaryLogRecordKind>().Select(e => (int)e).Max() + 2;
-            Microsoft.Build.Shared.BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, (int)unknownType);
+            BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, (int)unknownType);
             memoryStream.Position.ShouldBe(eventSizePos, "The event type need to be overwritten in place - without overwriting any bytes after the type info");
             memoryStream.Position = positionAfterFirstEvent;
 
@@ -1105,8 +1105,8 @@ public void ForwardCompatibleRead_HandleMismatchedFormatOfEvent()
             int positionAfterFirstEvent = (int)memoryStream.Position;
             memoryStream.Position = 0;
             // event type
-            Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
-            int eventSize = Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int eventSize = BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             // overwrite the entire event with garbage
             binaryWriter.Write(Enumerable.Repeat(byte.MaxValue, eventSize).ToArray());
 
@@ -1157,13 +1157,13 @@ public void ForwardCompatibleRead_HandleRemovalOfDataFromEventDefinition()
             int positionAfterFirstEvent = (int)memoryStream.Position;
             memoryStream.Position = 0;
             // event type
-            Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int eventSizePos = (int)memoryStream.Position;
-            int eventSize = Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int eventSize = BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int positionAfterFirstEventSize = (int)memoryStream.Position;
             memoryStream.Position = eventSizePos;
             // simulate there are 4 bytes less in the future version of the event - while our reader expects those
-            Microsoft.Build.Shared.BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, eventSize - 4);
+            BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, eventSize - 4);
             memoryStream.Position.ShouldBe(positionAfterFirstEventSize, "The event size need to be overwritten in place - without overwriting any bytes after the size info");
             // remove the 4 bytes - so that actual size of event is inline with it's written size.
             memoryStream.Position = positionAfterFirstEvent - 4;
diff --git a/src/Build.UnitTests/BuildResultUtilities.cs b/src/Build.UnitTests/BuildResultUtilities.cs
index 8ed38e7014f..83170717508 100644
--- a/src/Build.UnitTests/BuildResultUtilities.cs
+++ b/src/Build.UnitTests/BuildResultUtilities.cs
@@ -14,17 +14,17 @@ internal sealed class BuildResultUtilities
     {
         public static TargetResult GetEmptyFailingTargetResult()
         {
-            return new TargetResult(Array.Empty<TaskItem>(), BuildResultUtilities.GetStopWithErrorResult());
+            return new TargetResult(Array.Empty<TaskItem>(), GetStopWithErrorResult());
         }
 
         public static TargetResult GetEmptySucceedingTargetResult()
         {
-            return new TargetResult(Array.Empty<TaskItem>(), BuildResultUtilities.GetSuccessResult());
+            return new TargetResult(Array.Empty<TaskItem>(), GetSuccessResult());
         }
 
         public static TargetResult GetNonEmptySucceedingTargetResult()
         {
-            return new TargetResult(new TaskItem[1] { new TaskItem("i", "v") }, BuildResultUtilities.GetSuccessResult());
+            return new TargetResult(new TaskItem[1] { new TaskItem("i", "v") }, GetSuccessResult());
         }
 
         public static WorkUnitResult GetSuccessResult()
diff --git a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
index be97777e5e3..c3d5a06ba95 100644
--- a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
+++ b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
@@ -51,7 +51,7 @@ public void MatchProperty()
             string s = "$(foo)";
             ProjectPropertyInstance value = dictionary.GetProperty(s, 2, 4);
 
-            Assert.True(Object.ReferenceEquals(p, value)); // "Should have returned the same object as was inserted"
+            Assert.True(ReferenceEquals(p, value)); // "Should have returned the same object as was inserted"
 
             Assert.Equal(MSBuildNameIgnoreCaseComparer.Default.GetHashCode("foo"), comparer.GetHashCode(s, 2, 3));
         }
diff --git a/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs b/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
index 0a9116c81d5..d4f0ca38ec5 100644
--- a/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
@@ -102,19 +102,19 @@ public void Enumerate()
             dictionary.Add("x", "x2");
             dictionary.Add("y", "y1");
 
-            List<string> values = Helpers.MakeList<string>(dictionary["x"]);
+            List<string> values = Helpers.MakeList(dictionary["x"]);
             values.Sort();
 
             Assert.Equal(2, values.Count);
             Assert.Equal("x1", values[0]);
             Assert.Equal("x2", values[1]);
 
-            values = Helpers.MakeList<string>(dictionary["y"]);
+            values = Helpers.MakeList(dictionary["y"]);
 
             Assert.Single(values);
             Assert.Equal("y1", values[0]);
 
-            values = Helpers.MakeList<string>(dictionary["z"]);
+            values = Helpers.MakeList(dictionary["z"]);
 
             Assert.Empty(values);
         }
@@ -140,7 +140,7 @@ public void MixedAddRemove()
             Assert.Equal(1, dictionary.KeyCount);
             Assert.Equal(1, dictionary.ValueCount);
 
-            List<string> values = Helpers.MakeList<string>(dictionary["x"]);
+            List<string> values = Helpers.MakeList(dictionary["x"]);
 
             Assert.Single(values);
             Assert.Equal("x2", values[0]);
diff --git a/src/Build.UnitTests/Collections/OMcollections_tests.cs b/src/Build.UnitTests/Collections/OMcollections_tests.cs
index 354a6bc9464..59260914ded 100644
--- a/src/Build.UnitTests/Collections/OMcollections_tests.cs
+++ b/src/Build.UnitTests/Collections/OMcollections_tests.cs
@@ -77,9 +77,9 @@ public void PropertyDictionarySerialization()
             properties.Set(p1);
             properties.Set(p4);
 
-            TranslationHelpers.GetWriteTranslator().TranslateDictionary<PropertyDictionary<ProjectPropertyInstance>, ProjectPropertyInstance>(ref properties, ProjectPropertyInstance.FactoryForDeserialization);
+            TranslationHelpers.GetWriteTranslator().TranslateDictionary(ref properties, ProjectPropertyInstance.FactoryForDeserialization);
             PropertyDictionary<ProjectPropertyInstance> deserializedProperties = null;
-            TranslationHelpers.GetReadTranslator().TranslateDictionary<PropertyDictionary<ProjectPropertyInstance>, ProjectPropertyInstance>(ref deserializedProperties, ProjectPropertyInstance.FactoryForDeserialization);
+            TranslationHelpers.GetReadTranslator().TranslateDictionary(ref deserializedProperties, ProjectPropertyInstance.FactoryForDeserialization);
 
             Assert.Equal(properties, deserializedProperties);
         }
@@ -92,9 +92,9 @@ public void PropertyDictionarySerializationEmpty()
         {
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            TranslationHelpers.GetWriteTranslator().TranslateDictionary<PropertyDictionary<ProjectPropertyInstance>, ProjectPropertyInstance>(ref properties, ProjectPropertyInstance.FactoryForDeserialization);
+            TranslationHelpers.GetWriteTranslator().TranslateDictionary(ref properties, ProjectPropertyInstance.FactoryForDeserialization);
             PropertyDictionary<ProjectPropertyInstance> deserializedProperties = null;
-            TranslationHelpers.GetReadTranslator().TranslateDictionary<PropertyDictionary<ProjectPropertyInstance>, ProjectPropertyInstance>(ref deserializedProperties, ProjectPropertyInstance.FactoryForDeserialization);
+            TranslationHelpers.GetReadTranslator().TranslateDictionary(ref deserializedProperties, ProjectPropertyInstance.FactoryForDeserialization);
 
             Assert.Equal(properties, deserializedProperties);
         }
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 67cce196758..80369ca4dd6 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -141,7 +141,7 @@ public ConsoleLoggerTest(ITestOutputHelper output)
         [Fact]
         public void TestEmptyProjectNameForTargetStarted()
         {
-            Microsoft.Build.Evaluation.Project project = new Microsoft.Build.Evaluation.Project();
+            Build.Evaluation.Project project = new Build.Evaluation.Project();
 
             ProjectTargetElement target = project.Xml.AddTarget("T");
             ProjectTaskElement task = target.AddTask("Message");
@@ -2459,7 +2459,7 @@ internal bool IsRunningWithCharacterFileType()
             // Get the std out handle
             IntPtr stdHandle = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
 
-            if (stdHandle != Microsoft.Build.BackEnd.NativeMethods.InvalidHandle)
+            if (stdHandle != Build.BackEnd.NativeMethods.InvalidHandle)
             {
                 uint fileType = NativeMethodsShared.GetFileType(stdHandle);
 
diff --git a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
index 71a769aed3b..e7e5bd084d3 100644
--- a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
@@ -15,9 +15,9 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.UnitTests;
+using Microsoft.VisualStudio.SolutionPersistence;
 using Microsoft.VisualStudio.SolutionPersistence.Model;
 using Microsoft.VisualStudio.SolutionPersistence.Serializer;
-using Microsoft.VisualStudio.SolutionPersistence;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -109,7 +109,7 @@ public void SolutionFilterFiltersProjects(bool graphBuild)
                     EndGlobal
                     """);
                 TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
-                    /*lang=json*/
+                                  /*lang=json*/
                                   """
                                   {
                                     "solution": {
@@ -317,7 +317,8 @@ public void SolutionFilterWithSpecialSymbolInThePath()
             EndGlobal
             """);
             TransientTestFile slnf = testEnvironment.CreateFile(folder, "SimpleSolution.slnf",
-            """
+            /*lang=json,strict*/
+                                 """
             {
                 "solution": {
                     "path": "SimpleSolution.sln",
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 11179b170c6..4524514ffb7 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -2389,8 +2389,8 @@ public void TestTargetFrameworkVersionGreaterThan4(bool useNewParser)
 
 #if FEATURE_ASPNET_COMPILER
                 Version ver = new Version("4.34");
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("AspNetCompiler.TargetingHigherFrameworksDefaultsTo40", solution.ProjectsInOrder[0].ProjectName, ver.ToString());
-                logger.AssertLogContains(message);
+                    string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("AspNetCompiler.TargetingHigherFrameworksDefaultsTo40", solution.ProjectsInOrder[0].ProjectName, ver.ToString());
+                    logger.AssertLogContains(message);
 #endif
                 }
             }
@@ -2451,7 +2451,7 @@ public void CustomTargetNamesAreInInMetaproj(bool useNewParser)
                 Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
 
                 instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
-        
+
                 Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
             }
         }
diff --git a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
index f7cb141db85..a6f99f2a080 100644
--- a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
+++ b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
@@ -1895,7 +1895,7 @@ private bool ContainsMetadata(IEnumerable<ProjectMetadata> metadata, string name
         }
     }
 
-    public class ItemDefinitionGroup : Microsoft.Build.Utilities.Task
+    public class ItemDefinitionGroup : Utilities.Task
     {
         public override bool Execute()
         {
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 39810f825d6..a61cc8c050e 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -973,8 +973,8 @@ public ProjectSpecification(string projectFilePath, string projectContents)
 
             public void Deconstruct(out string projectPath, out string projectContents)
             {
-                projectPath = this.ProjectFilePath;
-                projectContents = this.ProjectContents;
+                projectPath = ProjectFilePath;
+                projectContents = ProjectContents;
             }
         }
 
diff --git a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
index ce86f880e14..72abf5096c1 100644
--- a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
@@ -38,7 +38,7 @@ public void CopyFromClonesMetadata()
             Assert.Equal(1 + 15 /* built-in metadata */, item2.MetadataCount);
 
             // Should still point at the same XML items
-            Assert.True(Object.ReferenceEquals(item1.DirectMetadata.First().Xml, item2.DirectMetadata.First().Xml));
+            Assert.True(ReferenceEquals(item1.DirectMetadata.First().Xml, item2.DirectMetadata.First().Xml));
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
index 8255424b6a7..ca9ef24079c 100644
--- a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
+++ b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
@@ -95,7 +95,7 @@ public void ReloadProjectWithInvalidToolsVersionInFile()
 
                 Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject("c:\\123.proj", null, null);
 
-                Assert.True(Object.ReferenceEquals(project, project2));
+                Assert.True(ReferenceEquals(project, project2));
             }
             finally
             {
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 7ca7b24910b..b915fc91132 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -35,7 +35,7 @@ public void OverrideTasksAreFoundInOverridePath()
             string dir = NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2";
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             using var collection = new ProjectCollection();
-            Toolset t = new Toolset("toolsversionname", dir, new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), overrideDir, new DirectoryExists(this.directoryExists));
+            Toolset t = new Toolset("toolsversionname", dir, new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(getFiles), new LoadXmlFromPath(loadXmlFromPath), overrideDir, new DirectoryExists(directoryExists));
 
             LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
             TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, e.ProjectRootElementCache);
@@ -78,7 +78,7 @@ public void OverrideTaskPathIsRelative()
             // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             using ProjectCollection e = new ProjectCollection();
             using var collection = new ProjectCollection();
-            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), "msbuildoverridetasks", new DirectoryExists(this.directoryExists));
+            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(getFiles), new LoadXmlFromPath(loadXmlFromPath), "msbuildoverridetasks", new DirectoryExists(directoryExists));
 
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
@@ -98,7 +98,7 @@ public void OverrideTaskPathHasInvalidChars()
         {
             using ProjectCollection e = new ProjectCollection();
             using var collection = new ProjectCollection();
-            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), "k:\\||^%$#*msbuildoverridetasks", new DirectoryExists(this.directoryExists));
+            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(getFiles), new LoadXmlFromPath(loadXmlFromPath), "k:\\||^%$#*msbuildoverridetasks", new DirectoryExists(directoryExists));
 
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
@@ -117,7 +117,7 @@ public void OverrideTaskPathHasTooLongOfAPath()
             string tooLong = "c:\\" + new string('C', 6000);
             using ProjectCollection e = new ProjectCollection();
             using var collection = new ProjectCollection();
-            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), tooLong, new DirectoryExists(this.directoryExists));
+            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(getFiles), new LoadXmlFromPath(loadXmlFromPath), tooLong, new DirectoryExists(directoryExists));
 
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
@@ -137,7 +137,7 @@ public void OverrideTaskPathIsNotFound()
             // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             using ProjectCollection e = new ProjectCollection();
             using var collection = new ProjectCollection();
-            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), "k:\\Thecatinthehat", new DirectoryExists(this.directoryExists));
+            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), collection, new DirectoryGetFiles(getFiles), new LoadXmlFromPath(loadXmlFromPath), "k:\\Thecatinthehat", new DirectoryExists(directoryExists));
 
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
@@ -161,10 +161,10 @@ public void DefaultTasksAreFoundInToolsPath()
                 NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2",
                 new PropertyDictionary<ProjectPropertyInstance>(),
                 collection,
-                new DirectoryGetFiles(this.getFiles),
-                new LoadXmlFromPath(this.loadXmlFromPath),
+                new DirectoryGetFiles(getFiles),
+                new LoadXmlFromPath(loadXmlFromPath),
                 null,
-                new DirectoryExists(this.directoryExists));
+                new DirectoryExists(directoryExists));
 
             LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
             TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
@@ -195,7 +195,7 @@ public void WarningLoggedIfNoDefaultTasksFound()
             LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
 
             using var colleciton = new ProjectCollection();
-            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2\\doesntexist", new PropertyDictionary<ProjectPropertyInstance>(), colleciton, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
+            Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2\\doesntexist", new PropertyDictionary<ProjectPropertyInstance>(), colleciton, new DirectoryGetFiles(getFiles), new LoadXmlFromPath(loadXmlFromPath), null, new DirectoryExists(directoryExists));
 
             TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
@@ -218,7 +218,7 @@ public void InvalidToolPath()
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
             LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
-            Toolset t = new Toolset("toolsversionname", "invalid||path", new PropertyDictionary<ProjectPropertyInstance>(), p, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
+            Toolset t = new Toolset("toolsversionname", "invalid||path", new PropertyDictionary<ProjectPropertyInstance>(), p, new DirectoryGetFiles(getFiles), new LoadXmlFromPath(loadXmlFromPath), null, new DirectoryExists(directoryExists));
 
             TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
@@ -242,13 +242,13 @@ public void VerifyTasksFilesAreInSortedOrder()
             string dir = NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2";
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             string[] foundFiles = Toolset.GetTaskFiles(
-                new DirectoryGetFiles(this.getFiles),
+                new DirectoryGetFiles(getFiles),
                 loggingContext,
                 "*.tasks",
                 dir,
                 String.Empty);
             string[] foundoverrideFiles = Toolset.GetTaskFiles(
-                new DirectoryGetFiles(this.getFiles),
+                new DirectoryGetFiles(getFiles),
                 loggingContext,
                 "*.overridetasks",
                 overrideDir,
@@ -928,8 +928,8 @@ public void InlineTasksInDotTasksFile()
                 NativeMethodsShared.IsWindows ? "c:\\inline" : "/inline",
                 new PropertyDictionary<ProjectPropertyInstance>(),
                 collection,
-                new DirectoryGetFiles(this.getFiles),
-                new LoadXmlFromPath(this.loadXmlFromPath),
+                new DirectoryGetFiles(getFiles),
+                new LoadXmlFromPath(loadXmlFromPath),
                 null,
                 new DirectoryExists(directoryExists));
 
@@ -1089,8 +1089,8 @@ public struct DefaultTasksFile
             public string XmlContents;
             public DefaultTasksFile(string path, string xmlContents)
             {
-                this.Path = path;
-                this.XmlContents = xmlContents;
+                Path = path;
+                XmlContents = xmlContents;
             }
         }
     }
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index a456097ddbc..a0974c7547b 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -1488,7 +1488,7 @@ public void PropertyPredecessors()
             ProjectPropertyElement xml1 = project.Xml.Properties.First();
             Assert.Equal("2;2", property.EvaluatedValue);
             Assert.Equal("1", property.Predecessor.Predecessor.EvaluatedValue);
-            Assert.True(Object.ReferenceEquals(xml1, property.Predecessor.Predecessor.Xml));
+            Assert.True(ReferenceEquals(xml1, property.Predecessor.Predecessor.Xml));
             Assert.Null(property.Predecessor.Predecessor.Predecessor);
         }
 
@@ -1514,7 +1514,7 @@ public void PropertyPredecessorsAndImports()
             ProjectRootElement importXml = ProjectRootElement.Open(project.Items.ElementAt(0).Xml.ContainingProject.FullPath);
             ProjectRootElement predecessorXmlRoot = project.GetProperty("outdir").Predecessor.Xml.ContainingProject;
 
-            Assert.True(Object.ReferenceEquals(importXml, predecessorXmlRoot));
+            Assert.True(ReferenceEquals(importXml, predecessorXmlRoot));
         }
 
         /// <summary>
@@ -1565,7 +1565,7 @@ public void ItemDefinitionPredecessorToItemDefinition()
             Assert.Equal("1", metadatum.Predecessor.Predecessor.EvaluatedValue);
 
             ProjectMetadataElement xml1 = project.Xml.ItemDefinitions.ElementAt(0).Metadata.ElementAt(0);
-            Assert.True(Object.ReferenceEquals(xml1, metadatum.Predecessor.Predecessor.Xml));
+            Assert.True(ReferenceEquals(xml1, metadatum.Predecessor.Predecessor.Xml));
             Assert.Null(metadatum.Predecessor.Predecessor.Predecessor);
         }
 
@@ -1625,10 +1625,10 @@ public void ItemDefinitionPredecessorToItem()
             Assert.Equal("1", metadatum.Predecessor.Predecessor.EvaluatedValue);
 
             ProjectMetadataElement xml1 = project.Xml.ItemDefinitions.ElementAt(0).Metadata.ElementAt(0);
-            Assert.True(Object.ReferenceEquals(xml1, metadatum.Predecessor.Predecessor.Xml));
+            Assert.True(ReferenceEquals(xml1, metadatum.Predecessor.Predecessor.Xml));
 
             ProjectMetadataElement xml2 = project.Xml.Items.ElementAt(0).Metadata.ElementAt(0);
-            Assert.True(Object.ReferenceEquals(xml2, metadatum.Predecessor.Xml));
+            Assert.True(ReferenceEquals(xml2, metadatum.Predecessor.Xml));
 
             Assert.Null(metadatum.Predecessor.Predecessor.Predecessor);
         }
@@ -1663,7 +1663,7 @@ public void PredecessorOnSameItem()
             Assert.Equal("1", metadatum.Predecessor.EvaluatedValue);
 
             ProjectMetadataElement xml1 = project.Xml.Items.ElementAt(1).Metadata.ElementAt(0);
-            Assert.True(Object.ReferenceEquals(xml1, metadatum.Predecessor.Xml));
+            Assert.True(ReferenceEquals(xml1, metadatum.Predecessor.Xml));
 
             Assert.Null(metadatum.Predecessor.Predecessor);
         }
@@ -1695,7 +1695,7 @@ public void ItemPredecessorToItem()
             Assert.Equal("1", metadatum.Predecessor.EvaluatedValue);
 
             ProjectMetadataElement xml1 = project.Xml.Items.ElementAt(0).Metadata.ElementAt(0);
-            Assert.True(Object.ReferenceEquals(xml1, metadatum.Predecessor.Xml));
+            Assert.True(ReferenceEquals(xml1, metadatum.Predecessor.Xml));
 
             Assert.Null(metadatum.Predecessor.Predecessor);
         }
@@ -1882,8 +1882,8 @@ public void ItemPredecessorsAndImports()
 
                 ProjectMetadata predecessor = project.GetItems("i").ElementAt(0).GetMetadata("m").Predecessor;
 
-                Assert.True(Object.ReferenceEquals(import, predecessor.Xml.ContainingProject));
-                Assert.True(Object.ReferenceEquals(project.Xml, predecessor.Predecessor.Xml.ContainingProject));
+                Assert.True(ReferenceEquals(import, predecessor.Xml.ContainingProject));
+                Assert.True(ReferenceEquals(project.Xml, predecessor.Predecessor.Xml.ContainingProject));
             }
             finally
             {
@@ -4804,7 +4804,7 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
         [Fact]
         public void VerifyPropertyTrackingLoggingNone()
         {
-            this.VerifyPropertyTrackingLoggingScenario(
+            VerifyPropertyTrackingLoggingScenario(
                 "0",
                  (logger, _) =>
                 {
@@ -4836,7 +4836,7 @@ public void VerifyPropertyTrackingLoggingNone()
         [Fact]
         public void VerifyPropertyTrackingLoggingPropertyInitialValue()
         {
-            this.VerifyPropertyTrackingLoggingScenario(
+            VerifyPropertyTrackingLoggingScenario(
                 "2",
                 (logger, projectPath) =>
                 {
@@ -4888,7 +4888,7 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
         [Fact]
         public void VerifyPropertyTrackingLoggingEnvironmentVariableRead()
         {
-            this.VerifyPropertyTrackingLoggingScenario(
+            VerifyPropertyTrackingLoggingScenario(
                 "4",
                 (logger, _) =>
                 {
@@ -4922,7 +4922,7 @@ public void VerifyPropertyTrackingLoggingEnvironmentVariableRead()
         [Fact]
         public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
         {
-            this.VerifyPropertyTrackingLoggingScenario(
+            VerifyPropertyTrackingLoggingScenario(
                 "8",
                 (logger, _) =>
                 {
@@ -4953,7 +4953,7 @@ public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
         [Fact]
         public void VerifyPropertyTrackingLoggingAll()
         {
-            this.VerifyPropertyTrackingLoggingScenario(
+            VerifyPropertyTrackingLoggingScenario(
                 "15",
                 (logger, projectPath) =>
                 {
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 1da44037bef..e5979a27393 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -237,7 +237,7 @@ public void ExpandEmptyItemVectorFunctionWithAnyHaveMetadataValue()
             ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(project, "i");
 
             IList<ProjectItemInstance> itemsEmpty = expander.ExpandIntoItemsLeaveEscaped("@(unsetItem->AnyHaveMetadataValue('Metadatum', 'value'))", itemFactory, ExpanderOptions.ExpandItems, MockElementLocation.Instance);
-            ProjectItemInstance pii = itemsEmpty.ShouldHaveSingleItem<ProjectItemInstance>();
+            ProjectItemInstance pii = itemsEmpty.ShouldHaveSingleItem();
             pii.EvaluatedInclude.ShouldBe("false");
         }
 
@@ -1257,7 +1257,7 @@ public void StaticMethodErrorMessageHaveMethodName()
                     </Target>
                 </Project>", false);
             }
-            catch (Microsoft.Build.Exceptions.InvalidProjectFileException e)
+            catch (InvalidProjectFileException e)
             {
                 Assert.NotEqual(-1, e.Message.IndexOf("[System.IO.Path]::Combine(null, '')", StringComparison.OrdinalIgnoreCase));
                 return;
@@ -1284,7 +1284,7 @@ public void StaticMethodErrorMessageHaveMethodName1()
                     </Target>
                 </Project>", false);
             }
-            catch (Microsoft.Build.Exceptions.InvalidProjectFileException e)
+            catch (InvalidProjectFileException e)
             {
                 Assert.NotEqual(-1, e.Message.IndexOf("System.IO.Path::Combine('a','b')", StringComparison.OrdinalIgnoreCase));
                 return;
@@ -1647,7 +1647,7 @@ public void ExpandAllIntoStringExpectIdenticalReference()
             Assert.Null(string.IsInterned(expandedString));
 
             // Finally verify Expander indeed didn't create a new string.
-            Assert.True(Object.ReferenceEquals(xmlattribute.Value, expandedString));
+            Assert.True(ReferenceEquals(xmlattribute.Value, expandedString));
         }
 
         /// <summary>
@@ -2751,7 +2751,7 @@ public void PropertyFunctionStaticMethodQuoted2()
             string dateTime = "'" + _dateToParse + "'";
             string result = expander.ExpandIntoStringLeaveEscaped("$([System.DateTime]::Parse(" + dateTime + ").ToString(\"yyyy/MM/dd HH:mm:ss\"))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
-            Assert.Equal(System.DateTime.Parse(_dateToParse).ToString("yyyy/MM/dd HH:mm:ss"), result);
+            Assert.Equal(DateTime.Parse(_dateToParse).ToString("yyyy/MM/dd HH:mm:ss"), result);
         }
 
         /// <summary>
@@ -2766,7 +2766,7 @@ public void PropertyFunctionStaticMethodQuoted3()
             string dateTime = "'" + _dateToParse + "'";
             string result = expander.ExpandIntoStringLeaveEscaped("$([System.DateTime]::Parse(" + dateTime + ").ToString(\"MM.dd.yyyy\"))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
-            Assert.Equal(System.DateTime.Parse(_dateToParse).ToString("MM.dd.yyyy"), result);
+            Assert.Equal(DateTime.Parse(_dateToParse).ToString("MM.dd.yyyy"), result);
         }
 
         /// <summary>
@@ -2855,7 +2855,7 @@ public void PropertyFunctionGetFolderPath()
 
             string result = expander.ExpandIntoStringLeaveEscaped(@"$([System.Environment]::GetFolderPath(SpecialFolder.System))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
-            Assert.Equal(System.Environment.GetFolderPath(Environment.SpecialFolder.System), result);
+            Assert.Equal(Environment.GetFolderPath(Environment.SpecialFolder.System), result);
         }
 
         /// <summary>
@@ -2959,7 +2959,7 @@ public void IsFreeBSD()
             const string propertyFunction = "$([System.OperatingSystem]::IsFreeBSD())";
             bool result = false;
 #if NET5_0_OR_GREATER
-            result = System.OperatingSystem.IsFreeBSD();
+            result = OperatingSystem.IsFreeBSD();
 #else
             result = Microsoft.Build.Framework.OperatingSystem.IsFreeBSD();
 #endif
@@ -3396,7 +3396,7 @@ public void PropertyFunctionStaticMethodDirectoryNameOfFileAbove()
 
                 string result = expander.ExpandIntoStringAndUnescape(@"$([MSBuild]::GetDirectoryNameOfFileAbove($(StartingDirectory), $(FileToFind)))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
-                Assert.Equal(Microsoft.Build.Shared.FileUtilities.EnsureTrailingSlash(tempPath), Microsoft.Build.Shared.FileUtilities.EnsureTrailingSlash(result));
+                Assert.Equal(FileUtilities.EnsureTrailingSlash(tempPath), FileUtilities.EnsureTrailingSlash(result));
 
                 result = expander.ExpandIntoStringAndUnescape(@"$([MSBuild]::GetDirectoryNameOfFileAbove($(StartingDirectory), Hobbits))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index b6b49388ec7..9acf27d3fce 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -363,7 +363,7 @@ public void TwoWithContent()
             Project project;
             using (StringReader sr = new StringReader(one))
             {
-                using (XmlReader xr = XmlTextReader.Create(sr))
+                using (XmlReader xr = XmlReader.Create(sr))
                 {
                     project = new Project(xr);
                 }
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index 915e38582d5..f401e76543e 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -120,12 +120,12 @@ public void GetProjectRootElementChangedOnDisk1()
                 cache.AddEntry(xml0);
 
                 ProjectRootElement xml1 = cache.TryGet(path);
-                Assert.True(Object.ReferenceEquals(xml0, xml1));
+                Assert.True(ReferenceEquals(xml0, xml1));
 
                 File.SetLastWriteTime(path, DateTime.Now + new TimeSpan(1, 0, 0));
 
                 ProjectRootElement xml2 = cache.TryGet(path);
-                Assert.False(Object.ReferenceEquals(xml0, xml2));
+                Assert.False(ReferenceEquals(xml0, xml2));
             }
             finally
             {
@@ -154,12 +154,12 @@ public void GetProjectRootElementChangedOnDisk2()
                 cache.AddEntry(xml0);
 
                 ProjectRootElement xml1 = cache.TryGet(path);
-                Assert.True(Object.ReferenceEquals(xml0, xml1));
+                Assert.True(ReferenceEquals(xml0, xml1));
 
                 File.SetLastWriteTime(path, DateTime.Now + new TimeSpan(1, 0, 0));
 
                 ProjectRootElement xml2 = cache.TryGet(path);
-                Assert.True(Object.ReferenceEquals(xml0, xml2));
+                Assert.True(ReferenceEquals(xml0, xml2));
             }
             finally
             {
diff --git a/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
index fdde22a05a9..e3393171ada 100644
--- a/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
@@ -27,7 +27,7 @@ public void DeepClone()
 
             ProjectMetadataInstance clone = metadata.DeepClone();
 
-            Assert.False(Object.ReferenceEquals(metadata, clone));
+            Assert.False(ReferenceEquals(metadata, clone));
             Assert.Equal("m", clone.Name);
             Assert.Equal("m1", clone.EvaluatedValue);
         }
diff --git a/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
index 92ee3d73435..7681cf97e4a 100644
--- a/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
@@ -27,7 +27,7 @@ public void DeepClone()
 
             ProjectPropertyInstance clone = property.DeepClone();
 
-            Assert.False(Object.ReferenceEquals(property, clone));
+            Assert.False(ReferenceEquals(property, clone));
             Assert.Equal("p", clone.Name);
             Assert.Equal("v1", clone.EvaluatedValue);
         }
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 7699a66b623..50c5a05a970 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -176,7 +176,7 @@ public void TestDeepClone()
             TaskItem clone = parent.DeepClone();
             Assert.True(parent.Equals(clone)); // "The parent and the clone should be equal"
             Assert.True(clone.Equals(parent)); // "The parent and the clone should be equal"
-            Assert.False(object.ReferenceEquals(parent, clone)); // "The parent and the child should not be the same object"
+            Assert.False(ReferenceEquals(parent, clone)); // "The parent and the child should not be the same object"
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/MockTask.cs b/src/Build.UnitTests/MockTask.cs
index 2252c3f3e52..f353c2cd2e9 100644
--- a/src/Build.UnitTests/MockTask.cs
+++ b/src/Build.UnitTests/MockTask.cs
@@ -59,7 +59,7 @@ internal class MockTaskBase
         public bool MyBoolParam
         {
             get { return _myBoolParam; }
-            set { _myBoolParam = value; this.myBoolParamWasSet = true; }
+            set { _myBoolParam = value; myBoolParamWasSet = true; }
         }
 
         /// <summary>
@@ -68,7 +68,7 @@ public bool MyBoolParam
         public bool[] MyBoolArrayParam
         {
             get { return _myBoolArrayParam; }
-            set { _myBoolArrayParam = value; this.myBoolArrayParamWasSet = true; }
+            set { _myBoolArrayParam = value; myBoolArrayParamWasSet = true; }
         }
 
         /// <summary>
@@ -77,7 +77,7 @@ public bool[] MyBoolArrayParam
         public int MyIntParam
         {
             get { return _myIntParam; }
-            set { _myIntParam = value; this.myIntParamWasSet = true; }
+            set { _myIntParam = value; myIntParamWasSet = true; }
         }
 
         /// <summary>
@@ -86,7 +86,7 @@ public int MyIntParam
         public int[] MyIntArrayParam
         {
             get { return _myIntArrayParam; }
-            set { _myIntArrayParam = value; this.myIntArrayParamWasSet = true; }
+            set { _myIntArrayParam = value; myIntArrayParamWasSet = true; }
         }
 
         /// <summary>
@@ -95,7 +95,7 @@ public int[] MyIntArrayParam
         public string MyStringParam
         {
             get { return _myStringParam; }
-            set { _myStringParam = value; this.myStringParamWasSet = true; }
+            set { _myStringParam = value; myStringParamWasSet = true; }
         }
 
         /// <summary>
@@ -104,7 +104,7 @@ public string MyStringParam
         public string[] MyStringArrayParam
         {
             get { return _myStringArrayParam; }
-            set { _myStringArrayParam = value; this.myStringArrayParamWasSet = true; }
+            set { _myStringArrayParam = value; myStringArrayParamWasSet = true; }
         }
 
         /// <summary>
@@ -113,7 +113,7 @@ public string[] MyStringArrayParam
         public ITaskItem MyITaskItemParam
         {
             get { return _myITaskItemParam; }
-            set { _myITaskItemParam = value; this.myITaskItemParamWasSet = true; }
+            set { _myITaskItemParam = value; myITaskItemParamWasSet = true; }
         }
 
         /// <summary>
@@ -122,7 +122,7 @@ public ITaskItem MyITaskItemParam
         public ITaskItem[] MyITaskItemArrayParam
         {
             get { return _myITaskItemArrayParam; }
-            set { _myITaskItemArrayParam = value; this.myITaskItemArrayParamWasSet = true; }
+            set { _myITaskItemArrayParam = value; myITaskItemArrayParamWasSet = true; }
         }
 
         /// <summary>
@@ -132,7 +132,7 @@ public ITaskItem[] MyITaskItemArrayParam
         public bool MyRequiredBoolParam
         {
             get { return _myRequiredBoolParam; }
-            set { _myRequiredBoolParam = value; this.myRequiredBoolParamWasSet = true; }
+            set { _myRequiredBoolParam = value; myRequiredBoolParamWasSet = true; }
         }
 
         /// <summary>
@@ -142,7 +142,7 @@ public bool MyRequiredBoolParam
         public bool[] MyRequiredBoolArrayParam
         {
             get { return _myRequiredBoolArrayParam; }
-            set { _myRequiredBoolArrayParam = value; this.myRequiredBoolArrayParamWasSet = true; }
+            set { _myRequiredBoolArrayParam = value; myRequiredBoolArrayParamWasSet = true; }
         }
 
         /// <summary>
@@ -152,7 +152,7 @@ public bool[] MyRequiredBoolArrayParam
         public int MyRequiredIntParam
         {
             get { return _myRequiredIntParam; }
-            set { _myRequiredIntParam = value; this.myRequiredIntParamWasSet = true; }
+            set { _myRequiredIntParam = value; myRequiredIntParamWasSet = true; }
         }
 
         /// <summary>
@@ -162,7 +162,7 @@ public int MyRequiredIntParam
         public int[] MyRequiredIntArrayParam
         {
             get { return _myRequiredIntArrayParam; }
-            set { _myRequiredIntArrayParam = value; this.myRequiredIntArrayParamWasSet = true; }
+            set { _myRequiredIntArrayParam = value; myRequiredIntArrayParamWasSet = true; }
         }
 
         /// <summary>
@@ -172,7 +172,7 @@ public int[] MyRequiredIntArrayParam
         public string MyRequiredStringParam
         {
             get { return _myRequiredStringParam; }
-            set { _myRequiredStringParam = value; this.myRequiredStringParamWasSet = true; }
+            set { _myRequiredStringParam = value; myRequiredStringParamWasSet = true; }
         }
 
         /// <summary>
@@ -182,7 +182,7 @@ public string MyRequiredStringParam
         public string[] MyRequiredStringArrayParam
         {
             get { return _myRequiredStringArrayParam; }
-            set { _myRequiredStringArrayParam = value; this.myRequiredStringArrayParamWasSet = true; }
+            set { _myRequiredStringArrayParam = value; myRequiredStringArrayParamWasSet = true; }
         }
 
         /// <summary>
@@ -192,7 +192,7 @@ public string[] MyRequiredStringArrayParam
         public ITaskItem MyRequiredITaskItemParam
         {
             get { return _myRequiredITaskItemParam; }
-            set { _myRequiredITaskItemParam = value; this.myRequiredITaskItemParamWasSet = true; }
+            set { _myRequiredITaskItemParam = value; myRequiredITaskItemParamWasSet = true; }
         }
 
         /// <summary>
@@ -202,7 +202,7 @@ public ITaskItem MyRequiredITaskItemParam
         public ITaskItem[] MyRequiredITaskItemArrayParam
         {
             get { return _myRequiredITaskItemArrayParam; }
-            set { _myRequiredITaskItemArrayParam = value; this.myRequiredITaskItemArrayParamWasSet = true; }
+            set { _myRequiredITaskItemArrayParam = value; myRequiredITaskItemArrayParamWasSet = true; }
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/TerminalLogger_Tests.cs b/src/Build.UnitTests/TerminalLogger_Tests.cs
index 2c04241a604..c595f79af27 100644
--- a/src/Build.UnitTests/TerminalLogger_Tests.cs
+++ b/src/Build.UnitTests/TerminalLogger_Tests.cs
@@ -35,9 +35,9 @@ public class TerminalLogger_Tests : IEventSource, IDisposable
             "Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, " +
             "/p:NuGetInteractive=\"true\" for MSBuild or removing the -NonInteractive switch for `NuGet`";
 
-        private readonly string _projectFile = NativeMethods.IsUnixLike ? "/src/project.proj" : @"C:\src\project.proj";
-        private readonly string _projectFile2 = NativeMethods.IsUnixLike ? "/src/project2.proj" : @"C:\src\project2.proj";
-        private readonly string _projectFileWithNonAnsiSymbols = NativeMethods.IsUnixLike ? "/src/проектТерминал/㐇𠁠𪨰𫠊𫦠𮚮⿕.proj" : @"C:\src\проектТерминал\㐇𠁠𪨰𫠊𫦠𮚮⿕.proj";
+        private readonly string _projectFile = NativeMethodsShared.IsUnixLike ? "/src/project.proj" : @"C:\src\project.proj";
+        private readonly string _projectFile2 = NativeMethodsShared.IsUnixLike ? "/src/project2.proj" : @"C:\src\project2.proj";
+        private readonly string _projectFileWithNonAnsiSymbols = NativeMethodsShared.IsUnixLike ? "/src/проектТерминал/㐇𠁠𪨰𫠊𫦠𮚮⿕.proj" : @"C:\src\проектТерминал\㐇𠁠𪨰𫠊𫦠𮚮⿕.proj";
 
         private StringWriter _outputWriter = new();
 
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index 60ed5d2bd01..309ce61a224 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -25,7 +25,7 @@ public class UtilitiesTestStandard : UtilitiesTest
 
         public UtilitiesTestStandard(ITestOutputHelper output)
         {
-            this.loadAsReadOnly = false;
+            loadAsReadOnly = false;
             _output = output;
         }
 
@@ -61,7 +61,7 @@ public class UtilitiesTestReadOnlyLoad : UtilitiesTest
     {
         public UtilitiesTestReadOnlyLoad()
         {
-            this.loadAsReadOnly = true;
+            loadAsReadOnly = true;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 78f96a187df..afd20aba11f 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -280,7 +280,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// Creates a new unnamed build manager.
         /// Normally there is only one build manager in a process, and it is the default build manager.
-        /// Access it with <see cref="BuildManager.DefaultBuildManager"/>
+        /// Access it with <see cref="DefaultBuildManager"/>
         /// </summary>
         public BuildManager()
             : this("Unnamed")
@@ -290,7 +290,7 @@ public BuildManager()
         /// <summary>
         /// Creates a new build manager with an arbitrary distinct name.
         /// Normally there is only one build manager in a process, and it is the default build manager.
-        /// Access it with <see cref="BuildManager.DefaultBuildManager"/>
+        /// Access it with <see cref="DefaultBuildManager"/>
         /// </summary>
         public BuildManager(string hostName)
         {
@@ -336,12 +336,12 @@ private enum BuildManagerState
 
             /// <summary>
             /// This is the state the BuildManager is in after <see cref="BeginBuild(BuildParameters)"/> has been called but before <see cref="EndBuild()"/> has been called.
-            /// <see cref="BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildManager.BuildRequest(GraphBuildRequestData)"/>, and <see cref="BuildManager.EndBuild()"/> may be called in this state.
+            /// <see cref="PendBuildRequest(BuildRequestData)"/>, <see cref="BuildRequest(BuildRequestData)"/>, <see cref="PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildRequest(GraphBuildRequestData)"/>, and <see cref="EndBuild()"/> may be called in this state.
             /// </summary>
             Building,
 
             /// <summary>
-            /// This is the state the BuildManager is in after <see cref="BuildManager.EndBuild()"/> has been called but before all existing submissions have completed.
+            /// This is the state the BuildManager is in after <see cref="EndBuild()"/> has been called but before all existing submissions have completed.
             /// </summary>
             WaitingForBuildToComplete
         }
@@ -396,7 +396,7 @@ public static BuildManager DefaultBuildManager
         LegacyThreadingData IBuildComponentHost.LegacyThreadingData => _legacyThreadingData;
 
         /// <summary>
-        /// <see cref="BuildManager.BeginBuild(BuildParameters,IEnumerable{DeferredBuildMessage})"/>
+        /// <see cref="BeginBuild(BuildParameters,IEnumerable{DeferredBuildMessage})"/>
         /// </summary>
         public readonly struct DeferredBuildMessage
         {
@@ -2150,7 +2150,7 @@ private void ErrorIfState(BuildManagerState disallowedState, string exceptionRes
         }
 
         /// <summary>
-        /// Verifies the BuildManager is in the required state, and throws a <see cref="System.InvalidOperationException"/> if it is not.
+        /// Verifies the BuildManager is in the required state, and throws a <see cref="InvalidOperationException"/> if it is not.
         /// </summary>
         private void RequireState(BuildManagerState requiredState, string exceptionResouorce)
         {
@@ -2158,7 +2158,7 @@ private void RequireState(BuildManagerState requiredState, string exceptionResou
         }
 
         /// <summary>
-        /// Verifies the BuildManager is in the required state, and throws a <see cref="System.InvalidOperationException"/> if it is not.
+        /// Verifies the BuildManager is in the required state, and throws a <see cref="InvalidOperationException"/> if it is not.
         /// </summary>
         private void VerifyStateInternal(BuildManagerState requiredState)
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index 7d996548bd6..b82c89fce94 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -178,7 +178,7 @@ void Clb(BuildSubmissionBase<BuildRequestData, BuildResult> submission)
         /// <summary>
         /// Starts the request and blocks until results are available.
         /// </summary>
-        /// <exception cref="System.InvalidOperationException">The request has already been started or is already complete.</exception>
+        /// <exception cref="InvalidOperationException">The request has already been started or is already complete.</exception>
         public override BuildResult Execute()
         {
             LegacyThreadingData legacyThreadingData = ((IBuildComponentHost)BuildManager).LegacyThreadingData;
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index a87175b7936..1cad8a0dc13 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -10,8 +10,8 @@
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 2450c2debfd..f3e860cb6c7 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -6,8 +6,8 @@
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 #nullable disable
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 60b8a0dc12c..0eda3d64095 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -68,7 +68,7 @@ public void AddResult(BuildResult result)
             {
                 if (_resultsByConfiguration.TryGetValue(result.ConfigurationId, out BuildResult buildResult))
                 {
-                    if (Object.ReferenceEquals(buildResult, result))
+                    if (ReferenceEquals(buildResult, result))
                     {
                         // Merging results would be meaningless as we would be merging the object with itself.
                         return;
diff --git a/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs b/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
index 1bcd3206909..987615ce6cd 100644
--- a/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
+++ b/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
@@ -61,7 +61,7 @@ private static void TranslateTargetFinishedEvent(ITranslator translator, TargetF
                 }
             }
 
-            translator.Translate<TaskItem>(ref targetOutputs, TaskItem.FactoryForDeserialization);
+            translator.Translate(ref targetOutputs, TaskItem.FactoryForDeserialization);
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
index 2bc967775f9..ec93257ab35 100644
--- a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
@@ -84,7 +84,7 @@ public string ErrorDescription
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
-        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
 #endif
 #if NET8_0_OR_GREATER
         [Obsolete(DiagnosticId = "SYSLIB0051")]
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index ff60a441e23..c31f2f267c2 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -176,12 +176,12 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)
 
                 int childProcessId = processInfo.dwProcessId;
 
-                if (processInfo.hProcess != IntPtr.Zero && processInfo.hProcess != NativeMethods.InvalidHandle)
+                if (processInfo.hProcess != IntPtr.Zero && processInfo.hProcess != BackendNativeMethods.InvalidHandle)
                 {
                     NativeMethodsShared.CloseHandle(processInfo.hProcess);
                 }
 
-                if (processInfo.hThread != IntPtr.Zero && processInfo.hThread != NativeMethods.InvalidHandle)
+                if (processInfo.hThread != IntPtr.Zero && processInfo.hThread != BackendNativeMethods.InvalidHandle)
                 {
                     NativeMethodsShared.CloseHandle(processInfo.hThread);
                 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index dbafe43db2a..7ad7ed8364f 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -176,7 +176,7 @@ public void ShutdownAllNodes()
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            this.ComponentHost = host;
+            ComponentHost = host;
             _nodeContexts = new ConcurrentDictionary<int, NodeContext>();
         }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index b1e380b5fa2..a41b4cbd08d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -490,7 +490,7 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake han
         /// Connect to named pipe stream and ensure validate handshake and security.
         /// </summary>
         /// <remarks>
-        /// Reused by MSBuild server client <see cref="Microsoft.Build.Experimental.MSBuildClient"/>.
+        /// Reused by MSBuild server client <see cref="Experimental.MSBuildClient"/>.
         /// </remarks>
         internal static void ConnectToPipeStream(NamedPipeClientStream nodeStream, string pipeName, Handshake handshake, int timeout)
         {
@@ -821,7 +821,7 @@ private static void WriteInt32(MemoryStream stream, int value)
             private void Close()
             {
                 _clientToServerStream.Dispose();
-                if (!object.ReferenceEquals(_clientToServerStream, _serverToClientStream))
+                if (!ReferenceEquals(_clientToServerStream, _serverToClientStream))
                 {
                     _serverToClientStream.Dispose();
                 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 1d0f0f525d3..fef92a8d7c4 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -224,7 +224,7 @@ public void ShutdownAllNodes()
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            this.ComponentHost = host;
+            ComponentHost = host;
             _nodeContexts = new Dictionary<HandshakeOptions, NodeContext>();
             _nodeIdToPacketFactory = new Dictionary<int, INodePacketFactory>();
             _nodeIdToPacketHandler = new Dictionary<int, INodePacketHandler>();
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index e61db2b91b2..34573a5b64a 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -2,11 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
 
 namespace Microsoft.Build.BackEnd.Logging
diff --git a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
index 20131c8bb76..d8aa419fb4c 100644
--- a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
+++ b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
@@ -23,8 +23,8 @@ public ForwardingLoggerRecord(ILogger centralLogger, LoggerDescription forwardin
             // The logging service allows a null central logger, so we don't check for it here.
             ErrorUtilities.VerifyThrowArgumentNull(forwardingLoggerDescription);
 
-            this.CentralLogger = centralLogger;
-            this.ForwardingLoggerDescription = forwardingLoggerDescription;
+            CentralLogger = centralLogger;
+            ForwardingLoggerDescription = forwardingLoggerDescription;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index a0c565ad491..d30dc323317 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -328,7 +328,7 @@ private protected void CheckValidity()
             if (!_isValid)
             {
                 ErrorUtilities.ThrowInternalError("LoggingContext (type: {0}) was not valid during logging attempt.",
-                    this.GetType());
+                    GetType());
             }
         }
     }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 1e4121594e2..aae3522c7ba 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1356,7 +1356,7 @@ private void StartLoggingEventProcessing()
             _loggingEventProcessingCancellation = new CancellationTokenSource();
 
             _loggingEventProcessingThread = new Thread(LoggingEventProc);
-            _loggingEventProcessingThread.Name = $"MSBuild LoggingService events queue pump: {this.GetHashCode()}";
+            _loggingEventProcessingThread.Name = $"MSBuild LoggingService events queue pump: {GetHashCode()}";
             _loggingEventProcessingThread.IsBackground = true;
             _loggingEventProcessingThread.Start();
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 31c9f55eeb0..ca630ca2f1e 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -55,7 +55,7 @@ public void LogComment(BuildEventContext buildEventContext, MessageImportance im
         /// <exception cref="InternalErrorException">Message is null</exception>
         public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message)
         {
-            this.LogCommentFromText(buildEventContext, importance, message, messageArgs: null);
+            LogCommentFromText(buildEventContext, importance, message, messageArgs: null);
         }
 
         /// <summary>
@@ -509,7 +509,7 @@ public BuildEventContext LogProjectStarted(
                 evaluationId,
                 projectContextId);
 
-            this.LogProjectStarted(args);
+            LogProjectStarted(args);
 
             return args.BuildEventContext;
         }
diff --git a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
index e03c8ed13e7..232398e34d8 100644
--- a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
@@ -31,7 +31,7 @@ internal NodeLoggingContext(ILoggingService loggingService, int nodeId, bool inP
                 LoggingService.LogBuildStarted();
             }
 
-            this.IsValid = true;
+            IsValid = true;
         }
 
         /// <summary>
@@ -40,7 +40,7 @@ internal NodeLoggingContext(ILoggingService loggingService, int nodeId, bool inP
         /// <param name="success">Did the build succeed or not</param>
         internal void LogBuildFinished(bool success)
         {
-            ErrorUtilities.VerifyThrow(this.IsValid, "Build not started.");
+            ErrorUtilities.VerifyThrow(IsValid, "Build not started.");
 
             // The in-proc node will have its BuildStarted, BuildFinished events sent by the BuildManager itself.
             if (!IsInProcNode)
@@ -48,7 +48,7 @@ internal void LogBuildFinished(bool success)
                 LoggingService.LogBuildFinished(success);
             }
 
-            this.IsValid = false;
+            IsValid = false;
         }
 
         /// <summary>
@@ -65,7 +65,7 @@ internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry)
 
         internal (ProjectStartedEventArgs, ProjectLoggingContext) CreateProjectLoggingContext(BuildRequestEntry requestEntry)
         {
-            ErrorUtilities.VerifyThrow(this.IsValid, "Build not started.");
+            ErrorUtilities.VerifyThrow(IsValid, "Build not started.");
             return ProjectLoggingContext.CreateLoggingContext(this, requestEntry);
         }
 
@@ -77,7 +77,7 @@ internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry)
         /// <returns>The BuildEventContext to use for this project.</returns>
         internal ProjectLoggingContext LogProjectStarted(BuildRequest request, BuildRequestConfiguration configuration)
         {
-            ErrorUtilities.VerifyThrow(this.IsValid, "Build not started.");
+            ErrorUtilities.VerifyThrow(IsValid, "Build not started.");
 
             // If we can retrieve the evaluationId from the project, do so. Don't if it's not available or
             // if we'd have to retrieve it from the cache in order to access it.
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 22687557135..6179787492a 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -104,10 +104,10 @@ private ProjectLoggingContext(
             // No need to log a redundant message in the common case
             if (projectStarted.ToolsVersion != "Current")
             {
-                LoggingService.LogComment(this.BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", projectStarted.ToolsVersion);
+                LoggingService.LogComment(BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", projectStarted.ToolsVersion);
             }
 
-            this.IsValid = true;
+            IsValid = true;
         }
 
         /// <summary>
@@ -143,10 +143,10 @@ private ProjectLoggingContext(
             // No need to log a redundant message in the common case
             if (toolsVersion != "Current")
             {
-                LoggingService.LogComment(this.BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", toolsVersion);
+                LoggingService.LogComment(BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", toolsVersion);
             }
 
-            this.IsValid = true;
+            IsValid = true;
         }
 
         private static BuildEventContext CreateInitialContext(
@@ -260,9 +260,9 @@ private static ProjectStartedEventArgs CreateProjectStarted(
         /// <param name="success">Did the build succeede or not</param>
         internal void LogProjectFinished(bool success)
         {
-            ErrorUtilities.VerifyThrow(this.IsValid, "invalid");
+            ErrorUtilities.VerifyThrow(IsValid, "invalid");
             LoggingService.LogProjectFinished(BuildEventContext, _projectFullPath, success);
-            this.IsValid = false;
+            IsValid = false;
         }
 
         /// <summary>
@@ -270,7 +270,7 @@ internal void LogProjectFinished(bool success)
         /// </summary>
         internal TargetLoggingContext LogTargetBatchStarted(string projectFullPath, ProjectTargetInstance target, string parentTargetName, TargetBuiltReason buildReason)
         {
-            ErrorUtilities.VerifyThrow(this.IsValid, "invalid");
+            ErrorUtilities.VerifyThrow(IsValid, "invalid");
             return new TargetLoggingContext(this, projectFullPath, target, parentTargetName, buildReason);
         }
     }
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index d68f04e2bfa..213843a3dd1 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -42,7 +42,7 @@ internal TargetLoggingContext(ProjectLoggingContext projectLoggingContext, strin
             _projectLoggingContext = projectLoggingContext;
             _target = target;
 
-            this.IsValid = true;
+            IsValid = true;
         }
 
         private static BuildEventContext CreateInitialContext(ProjectLoggingContext projectLoggingContext,
@@ -62,7 +62,7 @@ private static BuildEventContext CreateInitialContext(ProjectLoggingContext proj
         internal TargetLoggingContext(ILoggingService loggingService, BuildEventContext outOfProcContext)
             : base(loggingService, outOfProcContext, true)
         {
-            this.IsValid = true;
+            IsValid = true;
         }
 
         /// <summary>
@@ -101,7 +101,7 @@ internal ProjectTargetInstance Target
         /// </summary>
         internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnumerable<TaskItem> targetOutputs)
         {
-            this.CheckValidity();
+            CheckValidity();
 
             TargetOutputItemsInstanceEnumeratorProxy targetOutputWrapper = null;
 
@@ -112,7 +112,7 @@ internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnum
             }
 
             LoggingService.LogTargetFinished(BuildEventContext, _target.Name, projectFullPath, _target.Location.File, success, targetOutputWrapper);
-            this.IsValid = false;
+            IsValid = false;
         }
 
         /// <summary>
@@ -120,7 +120,7 @@ internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnum
         /// </summary>
         internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
         {
-            this.CheckValidity();
+            CheckValidity();
 
             return new TaskLoggingContext(this, projectFullPath, task, taskAssemblyLocation);
         }
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index 43d668805e4..456f4f67274 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -40,7 +40,7 @@ internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string pr
             _targetLoggingContext = targetLoggingContext;
             _task = task;
             _taskName = GetTaskName(task);
-            this.IsValid = true;
+            IsValid = true;
         }
 
         private static BuildEventContext CreateInitialContext(TargetLoggingContext targetLoggingContext,
@@ -87,7 +87,7 @@ private static string GetTaskName(ProjectTargetInstanceChild task)
         internal TaskLoggingContext(ILoggingService loggingService, BuildEventContext outOfProcContext)
             : base(loggingService, outOfProcContext, true)
         {
-            this.IsValid = true;
+            IsValid = true;
         }
 
         /// <summary>
@@ -128,7 +128,7 @@ internal string TaskName
         /// </summary>
         internal void LogTaskBatchFinished(string projectFullPath, bool success)
         {
-            ErrorUtilities.VerifyThrow(this.IsValid, "invalid");
+            ErrorUtilities.VerifyThrow(IsValid, "invalid");
 
             LoggingService.LogTaskFinished(
                 BuildEventContext,
@@ -136,7 +136,7 @@ internal void LogTaskBatchFinished(string projectFullPath, bool success)
                 projectFullPath,
                 _task.Location.File,
                 success);
-            this.IsValid = false;
+            IsValid = false;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
index 94c1ee183ac..fdbaaeed853 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
@@ -25,9 +25,9 @@ internal abstract class IntrinsicTask
         /// <param name="logTaskInputs">Flag to determine whether or not to log task inputs.</param>
         protected IntrinsicTask(TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs)
         {
-            this.LoggingContext = loggingContext;
-            this.Project = projectInstance;
-            this.LogTaskInputs = logTaskInputs;
+            LoggingContext = loggingContext;
+            Project = projectInstance;
+            LogTaskInputs = logTaskInputs;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
index 7d5eb31fc38..2273c81f67b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
@@ -108,8 +108,8 @@ public Task<bool> ExecuteInternal()
                 targetLists: targetLists,
                 stopOnFirstFailure: false,
                 rebaseOutputs: false,
-                buildEngine: this.BuildEngine3,
-                log: this.Log,
+                buildEngine: BuildEngine3,
+                log: Log,
                 targetOutputs: _targetOutputs,
                 unloadProjectsOnCompletion: false,
                 toolsVersion: null,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/IntrinsicTaskFactory.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/IntrinsicTaskFactory.cs
index 166552fd23e..c6b0c3fefde 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/IntrinsicTaskFactory.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/IntrinsicTaskFactory.cs
@@ -22,7 +22,7 @@ internal class IntrinsicTaskFactory : ITaskFactory
         /// </summary>
         public IntrinsicTaskFactory(Type intrinsicType)
         {
-            this.TaskType = intrinsicType;
+            TaskType = intrinsicType;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index c2b180dd2b9..f4390216377 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -71,7 +71,7 @@ internal class Lookup : IPropertyProvider<ProjectPropertyInstance>, IItemProvide
         /// We have to keep them separate, because the adds and removes etc need to be applied to the table
         /// below when we leave a scope.
         /// </summary>
-        private LinkedList<Lookup.Scope> _lookupScopes = new LinkedList<Lookup.Scope>();
+        private LinkedList<Scope> _lookupScopes = new LinkedList<Scope>();
 
         /// <summary>
         /// When we are asked for all the items of a certain type using the GetItems() method, we may have to handle items
@@ -94,7 +94,7 @@ internal Lookup(IItemDictionary<ProjectItemInstance> projectItems, PropertyDicti
             ErrorUtilities.VerifyThrowInternalNull(projectItems);
             ErrorUtilities.VerifyThrowInternalNull(properties);
 
-            Lookup.Scope scope = new Lookup.Scope(this, "Lookup()", projectItems, properties);
+            Scope scope = new Scope(this, "Lookup()", projectItems, properties);
             _lookupScopes.AddFirst(scope);
         }
 
@@ -104,7 +104,7 @@ internal Lookup(IItemDictionary<ProjectItemInstance> projectItems, PropertyDicti
         private Lookup(Lookup that)
         {
             // Add the same tables from the original
-            foreach (Lookup.Scope scope in that._lookupScopes)
+            foreach (Scope scope in that._lookupScopes)
             {
                 _lookupScopes.AddLast(scope);
             }
@@ -244,7 +244,7 @@ internal Lookup Clone()
         /// Enters the scope using the specified description.
         /// Callers keep the scope in order to pass it to <see cref="LeaveScope">LeaveScope</see>.
         /// </summary>
-        internal Lookup.Scope EnterScope(string description)
+        internal Scope EnterScope(string description)
         {
             // We don't create the tables unless we need them
             Scope scope = new Scope(this, description, null, null);
@@ -258,10 +258,10 @@ internal Lookup.Scope EnterScope(string description)
         /// and secondary table are merged. This has the effect of "applying" the adds applied to the primary
         /// table into the secondary table.
         /// </summary>
-        private void LeaveScope(Lookup.Scope scopeToLeave)
+        private void LeaveScope(Scope scopeToLeave)
         {
             ErrorUtilities.VerifyThrow(_lookupScopes.Count >= 2, "Too many calls to Leave().");
-            ErrorUtilities.VerifyThrow(Object.ReferenceEquals(scopeToLeave, _lookupScopes.First.Value), "Attempting to leave with scope '{0}' but scope '{1}' is on top of the stack.", scopeToLeave.Description, _lookupScopes.First.Value.Description);
+            ErrorUtilities.VerifyThrow(ReferenceEquals(scopeToLeave, _lookupScopes.First.Value), "Attempting to leave with scope '{0}' but scope '{1}' is on top of the stack.", scopeToLeave.Description, _lookupScopes.First.Value.Description);
 
             // Our lookup works by stopping the first time it finds an item group of the appropriate type.
             // So we can't apply an add directly into the table below because that could create a new group
@@ -337,9 +337,9 @@ private void MergeScopeIntoNotLastScope()
                 }
                 else
                 {
-                    foreach (KeyValuePair<string, Dictionary<ProjectItemInstance, MetadataModifications>> entry in PrimaryModifyTable)
+                    foreach (KeyValuePair<string, ItemsMetadataUpdateDictionary> entry in PrimaryModifyTable)
                     {
-                        Dictionary<ProjectItemInstance, MetadataModifications> modifiesOfType;
+                        ItemsMetadataUpdateDictionary modifiesOfType;
                         if (SecondaryModifyTable.TryGetValue(entry.Key, out modifiesOfType))
                         {
                             // There are already modifies of this type: add to the existing table
@@ -392,7 +392,7 @@ private void MergeScopeIntoLastScope()
 
             if (PrimaryModifyTable != null)
             {
-                foreach (KeyValuePair<string, Dictionary<ProjectItemInstance, MetadataModifications>> entry in PrimaryModifyTable)
+                foreach (KeyValuePair<string, ItemsMetadataUpdateDictionary> entry in PrimaryModifyTable)
                 {
                     SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                     ApplyModificationsToTable(SecondaryTable, entry.Key, entry.Value);
@@ -470,7 +470,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
 
             List<ProjectItemInstance> allAdds = null;
             List<ProjectItemInstance> allRemoves = null;
-            Dictionary<ProjectItemInstance, MetadataModifications> allModifies = null;
+            ItemsMetadataUpdateDictionary allModifies = null;
             ICollection<ProjectItemInstance> groupFound = null;
 
             foreach (Scope scope in _lookupScopes)
@@ -500,12 +500,12 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                 // Accumulate modifications as we look downwards
                 if (scope.Modifies != null)
                 {
-                    Dictionary<ProjectItemInstance, MetadataModifications> modifies;
+                    ItemsMetadataUpdateDictionary modifies;
                     if (scope.Modifies.TryGetValue(itemType, out modifies))
                     {
                         if (modifies.Count != 0)
                         {
-                            allModifies ??= new Dictionary<ProjectItemInstance, MetadataModifications>(modifies.Count);
+                            allModifies ??= new ItemsMetadataUpdateDictionary(modifies.Count);
 
                             // We already have some modifies for this type
                             foreach (KeyValuePair<ProjectItemInstance, MetadataModifications> modify in modifies)
@@ -776,10 +776,10 @@ internal void ModifyItems(string itemType, ICollection<ProjectItemInstance> grou
             // We don't need to check whether the item is in the add table vs. the main table; either
             // way the modification will be applied.
             PrimaryModifyTable ??= new ItemTypeToItemsMetadataUpdateDictionary(MSBuildNameIgnoreCaseComparer.Default);
-            Dictionary<ProjectItemInstance, MetadataModifications> modifiesOfType;
+            ItemsMetadataUpdateDictionary modifiesOfType;
             if (!PrimaryModifyTable.TryGetValue(itemType, out modifiesOfType))
             {
-                modifiesOfType = new Dictionary<ProjectItemInstance, MetadataModifications>();
+                modifiesOfType = new ItemsMetadataUpdateDictionary();
                 PrimaryModifyTable[itemType] = modifiesOfType;
             }
 
@@ -805,7 +805,7 @@ internal void ModifyItems(string itemType, ICollection<ProjectItemInstance> grou
         /// Apply modifies to a temporary result group.
         /// Items to be modified are virtual-cloned so the original isn't changed.
         /// </summary>
-        private void ApplyModifies(ItemDictionary<ProjectItemInstance> result, Dictionary<ProjectItemInstance, MetadataModifications> allModifies)
+        private void ApplyModifies(ItemDictionary<ProjectItemInstance> result, ItemsMetadataUpdateDictionary allModifies)
         {
             // Clone, because we're modifying actual items, and this would otherwise be visible to other batches,
             // and would be "published" even if a target fails.
@@ -912,7 +912,7 @@ private void ApplyModificationsToTable(IItemDictionary<ProjectItemInstance> tabl
         /// If the item already exists in the table, merges in the modifications; if there is a conflict
         /// the mergeType indicates which should win.
         /// </summary>
-        private void MergeModificationsIntoModificationTable(Dictionary<ProjectItemInstance, MetadataModifications> modifiesOfType,
+        private void MergeModificationsIntoModificationTable(ItemsMetadataUpdateDictionary modifiesOfType,
                                                              KeyValuePair<ProjectItemInstance, MetadataModifications> modify,
                                                              ModifyMergeType mergeType)
         {
@@ -1156,7 +1156,7 @@ public IEnumerable<KeyValuePair<string, MetadataModification>> ExplicitModificat
             /// <returns>If <see cref="KeepOnlySpecified"/> is true, this will return a modification with <see cref="MetadataModification.Remove"/>
             /// set to true if the metadata has no other explicitly-specified modification.  Otherwise it will return only the explicitly-specified
             /// modification if one exists.</returns>
-            /// <exception cref="System.Collections.Generic.KeyNotFoundException">When <see cref="KeepOnlySpecified"/> if false, this is thrown if the metadata
+            /// <exception cref="KeyNotFoundException">When <see cref="KeepOnlySpecified"/> if false, this is thrown if the metadata
             /// specified does not exist when attempting to retrieve a metadata modification.</exception>
             public MetadataModification this[string metadataName]
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 1adad068292..e32f74e8fc2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -257,8 +257,8 @@ public void ContinueRequestWithResources(ResourceResponse response)
         /// </remarks>
         public void CancelRequest()
         {
-            this.BeginCancel();
-            this.WaitForCancelCompletion();
+            BeginCancel();
+            WaitForCancelCompletion();
         }
 
         /// <summary>
@@ -691,7 +691,7 @@ private void StartBuilderThread()
                     _requestTask = Task.Factory.StartNew(
                         () =>
                         {
-                            return this.RequestThreadProc(setThreadParameters: true);
+                            return RequestThreadProc(setThreadParameters: true);
                         },
                         _cancellationTokenSource.Token,
                         TaskCreationOptions.None,
@@ -703,7 +703,7 @@ private void StartBuilderThread()
                     _requestTask = Task.Factory.StartNew(
                         () =>
                         {
-                            return this.RequestThreadProc(setThreadParameters: true);
+                            return RequestThreadProc(setThreadParameters: true);
                         },
                         _cancellationTokenSource.Token,
                         TaskCreationOptions.None,
@@ -963,7 +963,7 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
                 int handle;
                 if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
                 {
-                    handle = RequestBuilder.WaitWithBuilderThreadStart(handles, true, _componentHost.LegacyThreadingData, _requestEntry.Request.SubmissionId);
+                    handle = WaitWithBuilderThreadStart(handles, true, _componentHost.LegacyThreadingData, _requestEntry.Request.SubmissionId);
                 }
                 else if (_inMSBuildCallback)
                 {
@@ -1182,7 +1182,7 @@ private async Task<BuildResult> BuildProject()
                     (_requestEntry.RequestConfiguration.ResultsNodeId != _componentHost.BuildParameters.NodeId))
                 {
                     // This indicates to the system that we will block waiting for a results transfer.  We will block here until those results become available.
-                    await BlockOnTargetInProgress(Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId, null);
+                    await BlockOnTargetInProgress(BackEnd.BuildRequest.InvalidGlobalRequestId, null);
 
                     // All of the results should now be on this node.
                     ErrorUtilities.VerifyThrow(
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 65b6903876a..aa32079f576 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -153,7 +153,7 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
                 var targetExists = _projectInstance.Targets.TryGetValue(targetName.name, out ProjectTargetInstance targetInstance);
                 if (!targetExists && entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentTargets))
                 {
-                    _projectLoggingContext.LogComment(Framework.MessageImportance.Low,
+                    _projectLoggingContext.LogComment(MessageImportance.Low,
                         "TargetSkippedWhenSkipNonexistentTargets", targetName.name);
                 }
                 else
@@ -307,7 +307,7 @@ async Task<ITargetResult[]> ITargetBuilderCallback.LegacyCallTarget(string[] tar
                 // Any targets we have pushed on at this point we need to get rid of since we aren't going to process them.
                 // If there were normal task errors, standard error handling semantics would have taken care of them.
                 // If there was an exception, such as a circular dependency error, items may still be on the stack so we must clear them.
-                while (!Object.ReferenceEquals(_targetsToBuild.Peek(), currentTargetEntry))
+                while (!ReferenceEquals(_targetsToBuild.Peek(), currentTargetEntry))
                 {
                     _targetsToBuild.Pop();
                 }
@@ -326,7 +326,7 @@ async Task<ITargetResult[]> ITargetBuilderCallback.LegacyCallTarget(string[] tar
         /// <summary>
         /// Forwarding implementation of BuildProjects
         /// </summary>
-        async Task<BuildResult[]> IRequestBuilderCallback.BuildProjects(string[] projectFiles, Microsoft.Build.Collections.PropertyDictionary<ProjectPropertyInstance>[] properties, string[] toolsVersions, string[] targets, bool waitForResults, bool skipNonexistentTargets)
+        async Task<BuildResult[]> IRequestBuilderCallback.BuildProjects(string[] projectFiles, PropertyDictionary<ProjectPropertyInstance>[] properties, string[] toolsVersions, string[] targets, bool waitForResults, bool skipNonexistentTargets)
         {
             return await _requestBuilderCallback.BuildProjects(projectFiles, properties, toolsVersions, targets, waitForResults, skipNonexistentTargets);
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 30179f2e7a9..67cb92bce9a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -190,7 +190,7 @@ internal TargetEntry(
             _state = TargetEntryState.Dependencies;
             _baseLookup = baseLookup;
             _host = host;
-            this.StopProcessingOnCompletion = stopProcessingOnCompletion;
+            StopProcessingOnCompletion = stopProcessingOnCompletion;
         }
 
         /// <summary>
@@ -325,7 +325,7 @@ internal TargetBuiltReason BuildReason
         /// <returns>True if they are equivalent, false otherwise.</returns>
         public bool Equals(TargetEntry other)
         {
-            return String.Equals(this.Name, other.Name, StringComparison.OrdinalIgnoreCase);
+            return String.Equals(Name, other.Name, StringComparison.OrdinalIgnoreCase);
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index 38c2304ecc8..81f437e059c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -32,9 +32,9 @@ internal TargetSpecification(string targetName, ElementLocation referenceLocatio
             ErrorUtilities.VerifyThrowArgumentLength(targetName);
             ErrorUtilities.VerifyThrowArgumentNull(referenceLocation);
 
-            this._targetName = targetName;
-            this._referenceLocation = referenceLocation;
-            this._targetBuiltReason = targetBuiltReason;
+            _targetName = targetName;
+            _referenceLocation = referenceLocation;
+            _targetBuiltReason = targetBuiltReason;
         }
 
         private TargetSpecification()
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index 58e250f6c97..3745d0acbcc 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -547,8 +547,8 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteInputs(
             //    typically be built out of more than one set of inputs
             if (discreteTargetInputItemSpecs.Count > 0)
             {
-                List<string> inputs = CollectionHelpers.RemoveNulls<string>(discreteTargetInputItemSpecs);
-                List<string> outputs = CollectionHelpers.RemoveNulls<string>(targetOutputItemSpecs);
+                List<string> inputs = CollectionHelpers.RemoveNulls(discreteTargetInputItemSpecs);
+                List<string> outputs = CollectionHelpers.RemoveNulls(targetOutputItemSpecs);
 
                 if (inputs.Count == 0)
                 {
@@ -745,8 +745,8 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteOutputs(
             targetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorTransformsInTargetInputs));
             targetInputItemSpecs.AddRange(discreteItemsInTargetInputs.Values);
 
-            List<string> inputs = CollectionHelpers.RemoveNulls<string>(targetInputItemSpecs);
-            List<string> outputs = CollectionHelpers.RemoveNulls<string>(targetOutputItemSpecs);
+            List<string> inputs = CollectionHelpers.RemoveNulls(targetInputItemSpecs);
+            List<string> outputs = CollectionHelpers.RemoveNulls(targetOutputItemSpecs);
 
             if (inputs.Count == 0)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 0c4bb721766..13ac415f850 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -257,7 +257,7 @@ internal bool IsOutOfProc
         /// <param name="targetOutputs">The outputs from the targets</param>
         /// <param name="toolsVersion">The tools version to use</param>
         /// <returns>True on success, false otherwise.</returns>
-        public bool BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion)
+        public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion)
         {
             VerifyActiveProxy();
             return BuildProjectFilesInParallel(
@@ -282,7 +282,7 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, Syste
         /// <param name="useResultsCache">Whether to use the results cache</param>
         /// <param name="unloadProjectsOnCompletion">Whether to unload projects when we are done.</param>
         /// <returns>True on success, false otherwise.</returns>
-        public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion)
+        public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion)
         {
             bool includeTargetOutputs = (targetOutputsPerProject != null);
 
@@ -330,7 +330,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         /// <param name="toolsVersion">The tools versions to use</param>
         /// <param name="returnTargetOutputs">Should the target outputs be returned in the BuildEngineResult</param>
         /// <returns>A structure containing the result of the build, success or failure and the list of target outputs per project</returns>
-        public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs)
+        public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs)
         {
             lock (_callbackMonitor)
             {
@@ -404,7 +404,7 @@ public void Reacquire()
         /// Thread safe.
         /// </summary>
         /// <param name="e">The event args</param>
-        public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
+        public void LogErrorEvent(BuildErrorEventArgs e)
         {
             lock (_callbackMonitor)
             {
@@ -474,7 +474,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         /// Thread safe.
         /// </summary>
         /// <param name="e">The event args</param>
-        public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
+        public void LogWarningEvent(BuildWarningEventArgs e)
         {
             lock (_callbackMonitor)
             {
@@ -515,7 +515,7 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         /// Thread safe.
         /// </summary>
         /// <param name="e">The event args</param>
-        public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
+        public void LogMessageEvent(BuildMessageEventArgs e)
         {
             lock (_callbackMonitor)
             {
@@ -556,7 +556,7 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         /// Thread safe.
         /// </summary>
         /// <param name="e">The event args</param>
-        public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
+        public void LogCustomEvent(CustomBuildEventArgs e)
         {
             lock (_callbackMonitor)
             {
@@ -601,7 +601,7 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
         /// <param name="globalProperties">The global properties to use</param>
         /// <param name="targetOutputs">The outputs from the targets</param>
         /// <returns>True on success, false otherwise.</returns>
-        public bool BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs)
+        public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs)
         {
             VerifyActiveProxy();
             return BuildProjectFile(projectFileName, targetNames, globalProperties, targetOutputs, null);
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 7ac9baffafd..04c79475a4c 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -531,7 +531,7 @@ private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest
                 SchedulableRequest requestToEvaluate = requestsToEvaluate.Pop();
 
                 // If we make it to a child which is us, then it's a circular dependency.
-                if (requestToEvaluate.BuildRequest.GlobalRequestId == this.BuildRequest.GlobalRequestId)
+                if (requestToEvaluate.BuildRequest.GlobalRequestId == BuildRequest.GlobalRequestId)
                 {
                     ThrowIndirectCircularDependency(blockingRequest, requestToEvaluate);
                 }
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 5911b984a72..c771d3ad807 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1070,7 +1070,7 @@ private void AssignUnscheduledRequestsWithSmallestFileSize(List<ScheduleResponse
                     if (requiredNodeId == InvalidNodeId || idleNodes.Contains(requiredNodeId))
                     {
                         // Look for a request with the smallest source file
-                        System.IO.FileInfo f = new FileInfo(_configCache[unscheduledRequest.BuildRequest.ConfigurationId].ProjectFullPath);
+                        FileInfo f = new FileInfo(_configCache[unscheduledRequest.BuildRequest.ConfigurationId].ProjectFullPath);
                         if (f.Length < sizeOfSmallestSourceFile)
                         {
                             sizeOfSmallestSourceFile = f.Length;
@@ -1112,7 +1112,7 @@ private void AssignUnscheduledRequestsWithLargestFileSize(List<ScheduleResponse>
                     if (requiredNodeId == InvalidNodeId || idleNodes.Contains(requiredNodeId))
                     {
                         // Look for a request with the largest source file
-                        System.IO.FileInfo f = new FileInfo(_configCache[unscheduledRequest.BuildRequest.ConfigurationId].ProjectFullPath);
+                        FileInfo f = new FileInfo(_configCache[unscheduledRequest.BuildRequest.ConfigurationId].ProjectFullPath);
                         if (f.Length > sizeOfLargestSourceFile)
                         {
                             sizeOfLargestSourceFile = f.Length;
@@ -1485,7 +1485,7 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                 // Although this request has not been scheduled, this configuration may previously have been
                 // scheduled to an existing node.  If so, we shouldn't count it in our checks for new node
                 // creation, because it'll only eventually get assigned to its existing node anyway.
-                if (assignedNodeForConfiguration != Scheduler.InvalidNodeId)
+                if (assignedNodeForConfiguration != InvalidNodeId)
                 {
                     continue;
                 }
@@ -1723,7 +1723,7 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
                     {
                         bool affinityMismatch = false;
                         int assignedNodeId = _schedulingData.GetAssignedNodeForRequestConfiguration(request.ConfigurationId);
-                        if (assignedNodeId != Scheduler.InvalidNodeId)
+                        if (assignedNodeId != InvalidNodeId)
                         {
                             if (!_availableNodes[assignedNodeId].CanServiceRequestWithAffinity(GetNodeAffinityForRequest(request)))
                             {
@@ -2526,8 +2526,8 @@ private void WriteRecursiveSummary(ILoggingService loggingService, BuildEventCon
                 prePadString.ToString(),
                 useConfigurations ? request.BuildRequest.ConfigurationId : request.BuildRequest.GlobalRequestId,
                 new String(' ', postPad),
-                String.Format(CultureInfo.InvariantCulture, "{0:0.000}", request.GetTimeSpentInState(SchedulableRequestState.Executing).TotalSeconds),
-                String.Format(CultureInfo.InvariantCulture, "{0:0.000}", request.GetTimeSpentInState(SchedulableRequestState.Executing).TotalSeconds + request.GetTimeSpentInState(SchedulableRequestState.Blocked).TotalSeconds + request.GetTimeSpentInState(SchedulableRequestState.Ready).TotalSeconds),
+                String.Format(CultureInfo.InvariantCulture, /*lang=json*/ "{0:0.000}", request.GetTimeSpentInState(SchedulableRequestState.Executing).TotalSeconds),
+                String.Format(CultureInfo.InvariantCulture, /*lang=json*/ "{0:0.000}", request.GetTimeSpentInState(SchedulableRequestState.Executing).TotalSeconds + request.GetTimeSpentInState(SchedulableRequestState.Blocked).TotalSeconds + request.GetTimeSpentInState(SchedulableRequestState.Ready).TotalSeconds),
                 _configCache[request.BuildRequest.ConfigurationId].ProjectFullPath,
                 String.Join(", ", request.BuildRequest.Targets));
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 19a63a6eb5f..430576972b0 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -53,7 +53,7 @@ public SchedulingPlan(IConfigCache configCache, SchedulingData schedulingData)
         {
             _configCache = configCache;
             _schedulingData = schedulingData;
-            this.MaximumConfigurationId = BuildRequestConfiguration.InvalidConfigurationId;
+            MaximumConfigurationId = BuildRequestConfiguration.InvalidConfigurationId;
         }
 
         public PlanConfigData GetConfiguration(int configId)
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 0f79c18d598..5d75ffbf9e8 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -72,8 +72,8 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
             }
 
             if (result != null &&
-                !SdkResolverService.IsReferenceSameVersion(sdk, result.SdkReference.Version) &&
-                !SdkResolverService.IsReferenceSameVersion(sdk, result.Version))
+                !IsReferenceSameVersion(sdk, result.SdkReference.Version) &&
+                !IsReferenceSameVersion(sdk, result.Version))
             {
                 // MSB4240: Multiple versions of the same SDK "{0}" cannot be specified. The previously resolved SDK version "{1}" from location "{2}" will be used and the version "{3}" will be ignored.
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 2472c4c0fc9..405e095a081 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
 {
     /// <summary>
     /// An implementation of <see cref="ISdkResolverService"/> that is hosted in an out-of-proc node for multi-proc builds.  This instance of the service
-    /// sends requests to the main node that SDK resolution is handled in a central location.  This instance is registered in <see cref="Microsoft.Build.Execution.OutOfProcNode"/>
+    /// sends requests to the main node that SDK resolution is handled in a central location.  This instance is registered in <see cref="Execution.OutOfProcNode"/>
     /// using a factory so that parameters can be passed to the constructor.  This service caches responses for a given build so that it can avoid sending
     /// a packet where possible.  The cache is always in effect here because the out-of-proc node is only used for builds.
     ///
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 1d6ec92f64c..859e9bb934d 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -178,7 +178,7 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
             List<SdkResolverManifest> matchingResolversManifests = new();
             foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)
             {
-                WaitIfTestRequires(); 
+                WaitIfTestRequires();
                 try
                 {
                     if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
index d341db1add7..21c9d575896 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
@@ -13,7 +13,7 @@
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
     /// <summary>
-    /// An internal implementation of <see cref="Microsoft.Build.Framework.SdkResult"/>.
+    /// An internal implementation of <see cref="Framework.SdkResult"/>.
     /// </summary>
     internal sealed class SdkResult : SdkResultBase, INodePacket
     {
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
index 56c31a7c5e4..5c8d70fc924 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResultFactory.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
     /// <summary>
-    /// An internal implementation of <see cref="Microsoft.Build.Framework.SdkResultFactory"/>.
+    /// An internal implementation of <see cref="Framework.SdkResultFactory"/>.
     /// </summary>
     internal class SdkResultFactory : SdkResultFactoryBase
     {
diff --git a/src/Build/BackEnd/Shared/BuildAbortedException.cs b/src/Build/BackEnd/Shared/BuildAbortedException.cs
index 8588ba771dd..b54f33253e1 100644
--- a/src/Build/BackEnd/Shared/BuildAbortedException.cs
+++ b/src/Build/BackEnd/Shared/BuildAbortedException.cs
@@ -111,7 +111,7 @@ protected BuildAbortedException(SerializationInfo info, StreamingContext context
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
-        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
 #endif
 #if NET8_0_OR_GREATER
         [Obsolete(DiagnosticId = "SYSLIB0051")]
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index fa76ba4765c..c3f61840841 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -64,10 +64,10 @@ internal class BuildRequest : INodePacket
         /// </summary>
         private int _nodeRequestId;
 
-        /// <inheritdoc cref="BuildRequest.Targets"/>
+        /// <inheritdoc cref="Targets"/>
         private List<string> _targets;
 
-        /// <inheritdoc cref="BuildRequest.ProxyTargets"/>
+        /// <inheritdoc cref="ProxyTargets"/>
         private ProxyTargets _proxyTargets;
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index d2c22d49f76..e4b6bf48e3d 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -300,7 +300,7 @@ public bool IsTraversal
                 if (!_isTraversalProject.HasValue)
                 {
 #if NET471_OR_GREATER
-                    if (MemoryExtensions.Equals(Microsoft.IO.Path.GetFileName(ProjectFullPath.AsSpan()), "dirs.proj".AsSpan(), StringComparison.OrdinalIgnoreCase))
+                    if (MemoryExtensions.Equals(IO.Path.GetFileName(ProjectFullPath.AsSpan()), "dirs.proj".AsSpan(), StringComparison.OrdinalIgnoreCase))
 #else
                     if (MemoryExtensions.Equals(Path.GetFileName(ProjectFullPath.AsSpan()), "dirs.proj", StringComparison.OrdinalIgnoreCase))
 #endif
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index f433ffc25ad..1ef8455bdf1 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -5,12 +5,12 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Framework;
-using System.Diagnostics.CodeAnalysis;
 
 namespace Microsoft.Build.Execution
 {
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 2f5a26be1fc..f8a7eee1d5f 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -399,7 +399,7 @@ public bool SetTaskParameters(IDictionary<string, (string, ElementLocation)> par
                 }
             }
 
-            if (this.TaskInstance is IIncrementalTask incrementalTask)
+            if (TaskInstance is IIncrementalTask incrementalTask)
             {
                 incrementalTask.FailIfNotIncremental = _buildComponentHost.BuildParameters.Question;
             }
diff --git a/src/Build/BuildCheck/API/WorkerNodeCheck.cs b/src/Build/BuildCheck/API/WorkerNodeCheck.cs
index b5c8f597d30..8c3b0baf9c4 100644
--- a/src/Build/BuildCheck/API/WorkerNodeCheck.cs
+++ b/src/Build/BuildCheck/API/WorkerNodeCheck.cs
@@ -25,7 +25,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             throw new ArgumentException("The registration context for InternalBuildAnalyzer must be of type IInternalBuildCheckRegistrationContext.", nameof(registrationContext));
         }
 
-        this.RegisterInternalActions(internalRegistrationContext);
+        RegisterInternalActions(internalRegistrationContext);
     }
 
     internal override bool IsBuiltIn => true;
diff --git a/src/Build/BuildCheck/Checks/EmbeddedResourceCheck.cs b/src/Build/BuildCheck/Checks/EmbeddedResourceCheck.cs
index aaeda56eaa6..6feb8874470 100644
--- a/src/Build/BuildCheck/Checks/EmbeddedResourceCheck.cs
+++ b/src/Build/BuildCheck/Checks/EmbeddedResourceCheck.cs
@@ -1,8 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
 using System.Collections.Generic;
+using System.IO;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
diff --git a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index fe80a4ded80..635fc4ff1a6 100644
--- a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -3,9 +3,9 @@
 
 using System.Collections.Generic;
 using System.IO;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Collections;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
diff --git a/src/Build/BuildCheck/Checks/UntrustedLocationCheck.cs b/src/Build/BuildCheck/Checks/UntrustedLocationCheck.cs
index 5dcf2c75ea9..0a1db64727a 100644
--- a/src/Build/BuildCheck/Checks/UntrustedLocationCheck.cs
+++ b/src/Build/BuildCheck/Checks/UntrustedLocationCheck.cs
@@ -39,7 +39,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
     private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         if (checkedProjects.Add(context.Data.ProjectFilePath) &&
-            context.Data.ProjectFileDirectory.StartsWith(PathsHelper.Downloads, Shared.FileUtilities.PathComparison))
+            context.Data.ProjectFileDirectory.StartsWith(PathsHelper.Downloads, FileUtilities.PathComparison))
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
@@ -81,7 +81,7 @@ private static string GetDownloadsPath()
                 string? locationFromEnv = Environment.GetEnvironmentVariable("XDG_DOWNLOAD_DIR");
                 if (locationFromEnv != null && Directory.Exists(locationFromEnv))
                 {
-                    return locationFromEnv.TrimEnd(['\\','/']);
+                    return locationFromEnv.TrimEnd(['\\', '/']);
                 }
             }
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 7100095f1b4..e440f248f9a 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -392,7 +392,7 @@ public void RemoveChecksAfterExecutedActions(List<CheckWrapper>? checksToRemove,
         private void RemoveCheck(CheckFactoryContext checkToRemove)
         {
             var tempColl = new ConcurrentBag<CheckFactoryContext>();
-            
+
             // Take items one by one and only keep those we don't want to remove
             while (_checkRegistry.TryTake(out var item))
             {
@@ -403,13 +403,13 @@ private void RemoveCheck(CheckFactoryContext checkToRemove)
                 else if (item.MaterializedCheck is not null)
                 {
                     _buildCheckCentralContext.DeregisterCheck(item.MaterializedCheck);
-                    
+
                     var telemetryData = item.MaterializedCheck.GetRuleTelemetryData();
                     foreach (var data in telemetryData)
                     {
                         _ruleTelemetryData.Add(data);
                     }
-                    
+
                     item.MaterializedCheck.Check.Dispose();
                 }
             }
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index e0179b29c5d..0030a1574cc 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -2,12 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Linq;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
-using System.Collections.Concurrent;
 using Microsoft.Build.Experimental.BuildCheck.Utilities;
-using Microsoft.Build.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index f262903c187..5379c5a4dba 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -61,7 +61,7 @@ public void ProjectFirstEncountered(BuildCheckDataSource buildCheckDataSource, I
     }
 
     public void ProcessProjectEvaluationStarted(ICheckContext checkContext, string projectFullPath)
-    { 
+    {
     }
 
     public void ProcessProjectEvaluationStarted(BuildCheckDataSource buildCheckDataSource, ICheckContext checkContext, string projectFullPath)
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index b4ead9bb81b..6f77454eaaf 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -2,8 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using System.IO;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
diff --git a/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs b/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
index c24ba4bda1d..85390fe323e 100644
--- a/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
+++ b/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
@@ -96,7 +96,7 @@ public sealed class TaskInvocationCheckData : CheckData
     /// </summary>
     /// <param name="Value">The value passed to (when <paramref name="IsOutput"/> is false) or from
     /// (when <paramref name="IsOutput"/> is true) a task. This object can be of any type supported
-    /// in task parameters: <see cref="Framework.ITaskItem"/>, <see cref="Framework.ITaskItem"/>[],
+    /// in task parameters: <see cref="ITaskItem"/>, <see cref="ITaskItem"/>[],
     /// bool, string, or anything else convertible to/from string.</param>
     /// <param name="IsOutput">True for output parameters, false for input parameters.</param>
     public record class TaskParameter(object? Value, bool IsOutput)
diff --git a/src/Build/BuildCheck/OM/PropertyReadData.cs b/src/Build/BuildCheck/OM/PropertyReadData.cs
index 531f9fdc4a4..d4198c8385f 100644
--- a/src/Build/BuildCheck/OM/PropertyReadData.cs
+++ b/src/Build/BuildCheck/OM/PropertyReadData.cs
@@ -1,8 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
diff --git a/src/Build/Collections/ArrayDictionary.cs b/src/Build/Collections/ArrayDictionary.cs
index d0f1d5e0a32..92e254a9c09 100644
--- a/src/Build/Collections/ArrayDictionary.cs
+++ b/src/Build/Collections/ArrayDictionary.cs
@@ -112,7 +112,7 @@ public void Add(KeyValuePair<TKey, TValue> item)
 
         public void Clear()
         {
-            throw new System.NotImplementedException();
+            throw new NotImplementedException();
         }
 
         public bool Contains(KeyValuePair<TKey, TValue> item)
@@ -171,12 +171,12 @@ IDictionaryEnumerator IDictionary.GetEnumerator()
 
         public bool Remove(TKey key)
         {
-            throw new System.NotImplementedException();
+            throw new NotImplementedException();
         }
 
         public bool Remove(KeyValuePair<TKey, TValue> item)
         {
-            throw new System.NotImplementedException();
+            throw new NotImplementedException();
         }
 
         public bool TryGetValue(TKey key, out TValue value)
@@ -228,9 +228,9 @@ private struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>, IDictionary
 
             public Enumerator(ArrayDictionary<TKey, TValue> dictionary, bool emitDictionaryEntries = false)
             {
-                this._dictionary = dictionary;
-                this._position = -1;
-                this._emitDictionaryEntries = emitDictionaryEntries;
+                _dictionary = dictionary;
+                _position = -1;
+                _emitDictionaryEntries = emitDictionaryEntries;
             }
 
             public KeyValuePair<TKey, TValue> Current =>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
index dc8d96f9f7c..ccf330be83d 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
@@ -75,7 +75,7 @@ namespace Microsoft.Build.Collections
     /// the same time.
     /// </summary>
     /// <typeparam name="T"></typeparam>
-    [DebuggerTypeProxy(typeof(Microsoft.Build.Collections.HashSetDebugView<>))]
+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]
     [DebuggerDisplay("Count = {Count}")]
     [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Justification = "By design")]
     [Serializable()]
@@ -180,7 +180,7 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
             }
             Initialize(suggestedCapacity);
 
-            this.UnionWith(collection);
+            UnionWith(collection);
             if ((_count == 0 && _slots.Length > HashHelpers.GetMinPrime()) ||
                 (_count > 0 && _slots.Length / _count > ShrinkThreshold))
             {
@@ -867,12 +867,12 @@ private bool AddEvenIfPresent(T value)
         /// </summary>
         internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
         {
-            if (Object.ReferenceEquals(this, other))
+            if (ReferenceEquals(this, other))
             {
                 return true;
             }
 
-            if (this.Count != other.Count)
+            if (Count != other.Count)
             {
                 return false;
             }
@@ -880,7 +880,7 @@ internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
             T ours;
             foreach (T element in other)
             {
-                if (!TryGetValue(element.Key, out ours) || !Object.ReferenceEquals(element, ours))
+                if (!TryGetValue(element.Key, out ours) || !ReferenceEquals(element, ours))
                 {
                     return false;
                 }
@@ -948,7 +948,7 @@ internal struct Slot
         [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
 #endif
-        public struct Enumerator : IEnumerator<T>, System.Collections.IEnumerator
+        public struct Enumerator : IEnumerator<T>, IEnumerator
         {
             private RetrievableEntryHashSet<T> _set;
             private int _index;
@@ -997,7 +997,7 @@ public T Current
                 }
             }
 
-            Object System.Collections.IEnumerator.Current
+            Object IEnumerator.Current
             {
                 get
                 {
@@ -1009,7 +1009,7 @@ Object System.Collections.IEnumerator.Current
                 }
             }
 
-            void System.Collections.IEnumerator.Reset()
+            void IEnumerator.Reset()
             {
                 if (_version != _set._version)
                 {
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index 6a4f1eeefda..1dfdb55e9fb 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -151,7 +151,7 @@ public ProjectElementContainer Parent
             [DebuggerStepThrough]
             get
             {
-                if (this.Link != null) { return this.Link.Parent; }
+                if (Link != null) { return Link.Parent; }
 
                 if (_parent is WrapperForProjectRootElement)
                 {
@@ -560,7 +560,7 @@ internal string GetAttributeValue(string attributeName, ref string cache)
 
         internal virtual void ClearAttributeCache()
         {
-            this._condition = null;
+            _condition = null;
         }
 
         internal void SetOrRemoveAttributeForLink(string name, string value, bool clearAttributeCache, string reason, string param)
@@ -568,7 +568,7 @@ internal void SetOrRemoveAttributeForLink(string name, string value, bool clearA
             SetOrRemoveAttribute(name, value, reason, param);
             if (clearAttributeCache)
             {
-                this.ClearAttributeCache();
+                ClearAttributeCache();
             }
         }
 
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 6c6584e52c7..9a6d706f512 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -335,7 +335,7 @@ public void RemoveChild(ProjectElement child)
         /// </summary>
         /// <remarks>
         /// It is safe to modify the children in this way
-        /// during enumeration. See <see cref="ProjectElementContainer.RemoveChild(ProjectElement)"/>.
+        /// during enumeration. See <see cref="RemoveChild(ProjectElement)"/>.
         /// </remarks>
         public void RemoveAllChildren()
         {
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index f2c221f43f9..ea8d74b1b38 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -412,7 +412,7 @@ public override void CopyFrom(ProjectElement element)
             base.CopyFrom(element);
 
             // clear cached fields
-            this.ClearAttributeCache();
+            ClearAttributeCache();
         }
 
         /// <summary>
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 903de887aac..d83b7af13b0 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1358,7 +1358,7 @@ public ProjectMetadataElement CreateMetadataElement(string name)
         /// </summary>
         public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue)
         {
-            return this.CreateMetadataElement(name, unevaluatedValue, null);
+            return CreateMetadataElement(name, unevaluatedValue, null);
         }
 
         /// <summary>
@@ -1647,7 +1647,7 @@ public ProjectRootElement DeepClone()
         /// Reload the existing project root element from its file.
         /// An <see cref="InvalidOperationException"/> is thrown if the project root element is not associated with any file on disk.
         ///
-        /// See <see cref="ProjectRootElement.ReloadFrom(XmlReader, bool, bool?)"/>
+        /// See <see cref="ReloadFrom(XmlReader, bool, bool?)"/>
         /// </summary>
         public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null)
         {
@@ -1660,7 +1660,7 @@ public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting =
         /// Reload the existing project root element from the given path
         /// An <see cref="InvalidOperationException"/> is thrown if the path does not exist.
         ///
-        /// See <see cref="ProjectRootElement.ReloadFrom(XmlReader, bool, bool?)"/>
+        /// See <see cref="ReloadFrom(XmlReader, bool, bool?)"/>
         /// </summary>
         public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null)
         {
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 4eb3b5e82bd..32dc7fc6824 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -581,7 +581,7 @@ private static bool ElementContainsInvalidNamespaceDefitions(XmlElement mainProj
             return false;
         }
 
-#endregion
+        #endregion
 
         #region Constants
 
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 01ece85d306..34c780affb0 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -98,7 +98,7 @@ public sealed partial class SolutionFile
         private const string sharedProjectGuid = "{D954291E-2A0B-460D-934E-DC6B0785DB48}";
 
         private const char CommentStartChar = '#';
-#endregion
+        #endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
         private string _solutionFilterFile;          // Could be absolute or relative path to the .SLNF file.
@@ -1467,7 +1467,7 @@ private static void ParseAspNetCompilerProperty(
                     // However, 3.5 version of Solution parser can't handle a equal sign in the value.
                     // The "=" in targetframeworkMoniker was escaped to "%3D" for Orcas
                     string targetFrameworkMoniker = TrimQuotes(propertyValue);
-                    proj.TargetFrameworkMoniker = Shared.EscapingUtilities.UnescapeAll(targetFrameworkMoniker);
+                    proj.TargetFrameworkMoniker = EscapingUtilities.UnescapeAll(targetFrameworkMoniker);
                 }
             }
         }
@@ -1893,6 +1893,6 @@ internal string GetProjectRelativePathByGuid(string projectGuid)
             return null;
         }
 
-#endregion
+        #endregion
     } // class SolutionFile
 } // namespace Microsoft.Build.Construction
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 23b235e5ad0..9c1ef812a73 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -828,7 +828,7 @@ public bool IsBuildEnabled
         /// <summary>
         /// The ID of the last evaluation for this Project.
         /// A project is always evaluated upon construction and can subsequently get evaluated multiple times via
-        /// <see cref="Project.ReevaluateIfNecessary()" />
+        /// <see cref="ReevaluateIfNecessary()" />
         ///
         /// It is an arbitrary number that changes when this project reevaluates.
         /// Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
@@ -4070,7 +4070,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// A dictionary of all of the properties read from environment variables during evaluation.
             /// </summary>
-            public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => this.Project.ProjectCollection.EnvironmentProperties;
+            public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => Project.ProjectCollection.EnvironmentProperties;
 
             /// <summary>
             /// List of names of the properties that, while global, are still treated as overridable.
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 9973e5d3d80..d3f604af555 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -298,7 +298,7 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
         /// <param name="maxNodeCount">The maximum number of nodes to use for building.</param>
         /// <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
         /// <param name="loadProjectsReadOnly">If set to true, load all projects as read-only.</param>
-        /// <param name="useAsynchronousLogging">If set to true, asynchronous logging will be used. <see cref="ProjectCollection.Dispose()"/> has to called to clear resources used by async logging.</param>
+        /// <param name="useAsynchronousLogging">If set to true, asynchronous logging will be used. <see cref="Dispose()"/> has to called to clear resources used by async logging.</param>
         /// <param name="reuseProjectRootElementCache">If set to true, it will try to reuse <see cref="ProjectRootElementCacheBase"/> singleton.</param>
         public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache)
         {
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 96aae94ac4f..41dbc5df765 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -109,8 +109,8 @@ public class ProjectItem : IItem<ProjectMetadata>, IProjectMetadataParent, IItem
         /// </summary>
         internal ProjectItem(ProjectItemElement xml, Project project)
         {
-            this._project = project;
-            this._xml = xml;
+            _project = project;
+            _xml = xml;
         }
 
         /// <summary>
@@ -248,7 +248,7 @@ public bool IsImported
         {
             get
             {
-                bool isImported = !Object.ReferenceEquals(_xml.ContainingProject, _project.Xml);
+                bool isImported = !ReferenceEquals(_xml.ContainingProject, _project.Xml);
 
                 return isImported;
             }
@@ -813,7 +813,7 @@ internal void ChangeItemType(string newItemType)
 
         /// <summary>
         /// Creates new xml objects for itself, disconnecting from the old xml objects.
-        /// Called ONLY by <see cref="Microsoft.Build.Evaluation.Project.SplitItemElementIfNecessary(ProjectItemElement)"/>
+        /// Called ONLY by <see cref="Project.SplitItemElementIfNecessary(ProjectItemElement)"/>
         /// </summary>
         /// <remarks>
         /// Called when breaking up a single ProjectItemElement that evaluates into several ProjectItems.
@@ -859,7 +859,7 @@ private string GetBuiltInMetadataEscaped(string name)
 
             if (FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name))
             {
-                value = BuiltInMetadata.GetMetadataValueEscaped(_project.DirectoryPath, _evaluatedIncludeBeforeWildcardExpansionEscaped, _evaluatedIncludeEscaped, this.Xml.ContainingProject.FullPath, name, ref _fullPath);
+                value = BuiltInMetadata.GetMetadataValueEscaped(_project.DirectoryPath, _evaluatedIncludeBeforeWildcardExpansionEscaped, _evaluatedIncludeEscaped, Xml.ContainingProject.FullPath, name, ref _fullPath);
             }
 
             return value;
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index d1cebcb95cd..bbdbdcd2d03 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -211,7 +211,7 @@ public bool IsImported
         {
             get
             {
-                bool isImported = !Object.ReferenceEquals(_xml.ContainingProject, _parent.Project.Xml);
+                bool isImported = !ReferenceEquals(_xml.ContainingProject, _parent.Project.Xml);
 
                 return isImported;
             }
@@ -277,7 +277,7 @@ internal string EvaluatedValueEscaped
         /// <returns>True if they are equivalent, false otherwise.</returns>
         bool IEquatable<ProjectMetadata>.Equals(ProjectMetadata other)
         {
-            if (Object.ReferenceEquals(this, other))
+            if (ReferenceEquals(this, other))
             {
                 return true;
             }
@@ -300,7 +300,7 @@ internal ProjectMetadata DeepClone()
         {
             // The new metadatum's predecessor is the same as its original's predecessor, just as the XML is the same
             // as its original's XML. Predecessors map to XML elements.
-            return new ProjectMetadata(_parent, this.Xml, this.EvaluatedValueEscaped, this.Predecessor);
+            return new ProjectMetadata(_parent, Xml, EvaluatedValueEscaped, Predecessor);
         }
     }
 }
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index e5e7fcc6d46..7acab03c725 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -252,7 +252,7 @@ string IValued.EscapedValue
         /// <returns>True if the properties are equivalent, false otherwise.</returns>
         bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         {
-            if (Object.ReferenceEquals(this, other))
+            if (ReferenceEquals(this, other))
             {
                 return true;
             }
@@ -474,7 +474,7 @@ public override bool IsImported
             {
                 get
                 {
-                    bool isImported = !Object.ReferenceEquals(_xml.ContainingProject, _project.Xml);
+                    bool isImported = !ReferenceEquals(_xml.ContainingProject, _project.Xml);
 
                     return isImported;
                 }
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index bd84fed6708..73a210bd28a 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -276,7 +276,7 @@ internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<Proje
             ErrorUtilities.VerifyThrowArgumentNull(globalProperties);
 
             _toolsVersion = toolsVersion;
-            this.ToolsPath = toolsPath;
+            ToolsPath = toolsPath;
             _globalProperties = globalProperties;
             _environmentProperties = environmentProperties;
             _overrideTasksPath = msbuildOverrideTasksPath;
@@ -736,7 +736,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, LoggingContext
             // Sort the file names to give a deterministic order
             if (defaultTasksFiles != null)
             {
-                Array.Sort<string>(defaultTasksFiles, StringComparer.OrdinalIgnoreCase);
+                Array.Sort(defaultTasksFiles, StringComparer.OrdinalIgnoreCase);
                 return defaultTasksFiles;
             }
             return [];
@@ -932,7 +932,7 @@ private void InitializeProperties(LoggingContext loggingContext)
 
                 // GenerateSubToolsetVersion checks the environment and global properties, so it's safe to go ahead and gather the
                 // subtoolset properties here without fearing that we'll have somehow come up with the wrong subtoolset version.
-                string subToolsetVersion = this.GenerateSubToolsetVersion();
+                string subToolsetVersion = GenerateSubToolsetVersion();
                 SubToolset subToolset;
                 ICollection<ProjectPropertyInstance> subToolsetProperties = null;
 
@@ -1044,7 +1044,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, LoggingCont
             string currentTasksFile = null;
             try
             {
-                TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<ProjectPropertyInstance, ProjectItemInstance>(
+                TaskRegistry.InitializeTaskRegistryFromUsingTaskElements(
                     loggingContext,
                     EnumerateTasksRegistrations(),
                     registry,
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 2f3ca882084..cad263b5284 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -135,7 +135,7 @@ internal static string ReadAllToolsets(
                 // assembly in API consumers.
                 //
                 // https://github.com/microsoft/MSBuildLocator/issues/159
-                [MethodImplAttribute(MethodImplOptions.NoInlining)]
+                [MethodImpl(MethodImplOptions.NoInlining)]
                 void ReadConfigToolset()
                 {
                     // Accumulation of properties is okay in the config file because it's deterministically ordered
@@ -306,7 +306,7 @@ void ReadConfigToolset()
             // There's no tools path already for 2.0, so use the path to the v2.0 .NET Framework.
             // If an old-fashioned caller sets BinPath property, or passed a BinPath to the constructor,
             // that will overwrite what we're setting here.
-            ErrorUtilities.VerifyThrow(
+            ErrorUtils.VerifyThrow(
                 Constants.defaultToolsVersion == "2.0",
                 "Getting 2.0 FX path so default should be 2.0");
             var pathToFramework = FrameworkLocationHelper.PathToDotNetFrameworkV20;
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 29879ac6180..fc84fb3681f 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -112,12 +112,12 @@ public override bool Equals(object obj)
                 return false;
             }
 
-            if (this.Line != that.Line || this.Column != that.Column)
+            if (Line != that.Line || Column != that.Column)
             {
                 return false;
             }
 
-            if (!String.Equals(this.File, that.File, StringComparison.OrdinalIgnoreCase))
+            if (!String.Equals(File, that.File, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index eb8c3356873..2cc71d56dec 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -162,7 +162,7 @@ public override void Load(string fullPath)
 
             using (var xtr = XmlReaderExtension.Create(fullPath, _loadAsReadOnly ?? false))
             {
-                this.Load(xtr.Reader);
+                Load(xtr.Reader);
             }
         }
 
@@ -179,7 +179,7 @@ internal XmlElement CreateElement(string localName, string namespaceURI, Element
         {
             if (location != null)
             {
-                this._elementLocation.Value = location;
+                _elementLocation.Value = location;
             }
             try
             {
@@ -187,7 +187,7 @@ internal XmlElement CreateElement(string localName, string namespaceURI, Element
             }
             finally
             {
-                this._elementLocation.Value = null;
+                _elementLocation.Value = null;
             }
         }
 
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 1db485e55ea..b242247e333 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -127,7 +127,7 @@ private InternalLoggerException(SerializationInfo info, StreamingContext context
         /// <param name="info"></param>
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
-        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
 #endif
 #if NET8_0_OR_GREATER
         [Obsolete(DiagnosticId = "SYSLIB0051")]
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 98550caeba2..ae03d583afd 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -109,7 +109,7 @@ private InvalidProjectFileException(SerializationInfo info, StreamingContext con
         /// <param name="info"></param>
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
-        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
 #endif
 #if NET8_0_OR_GREATER
         [Obsolete(DiagnosticId = "SYSLIB0051")]
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 8dbae22aa4a..39903b1dcf3 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -96,7 +96,7 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
         /// <param name="info"></param>
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
-        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
 #endif
 #if NET8_0_OR_GREATER
         [Obsolete(DiagnosticId = "SYSLIB0051")]
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 55cf768c60b..72334894e6a 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -81,9 +81,9 @@ internal override void ResetState()
         internal override bool DetectAnd()
         {
             // Read the state of the current node
-            bool detectedAnd = this.PossibleAndCollision;
+            bool detectedAnd = PossibleAndCollision;
             // Reset the flags on the current node
-            this.PossibleAndCollision = false;
+            PossibleAndCollision = false;
             // Process the children of the node if preset
             bool detectAndRChild = false;
             bool detectAndLChild = false;
@@ -101,9 +101,9 @@ internal override bool DetectAnd()
         internal override bool DetectOr()
         {
             // Read the state of the current node
-            bool detectedOr = this.PossibleOrCollision;
+            bool detectedOr = PossibleOrCollision;
             // Reset the flags on the current node
-            this.PossibleOrCollision = false;
+            PossibleOrCollision = false;
             // Process the children of the node if preset
             bool detectOrRChild = false;
             bool detectOrLChild = false;
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 0407cd0d7f5..cb8bc22c920 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -271,7 +271,7 @@ private OperatorExpressionNode RelationalOperation(string expression)
         private GenericExpressionNode Factor(string expression)
         {
             // Checks for TokenTypes String, Numeric, Property, ItemMetadata, and ItemList.
-            GenericExpressionNode arg = this.Arg(expression);
+            GenericExpressionNode arg = Arg(expression);
 
             // If it's one of those, return it.
             if (arg != null)
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 718ae73d23d..5e87c92dbae 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -407,7 +407,7 @@ private static bool ScanForPropertyExpressionEnd(string expression, int index, o
         /// <returns></returns>
         private bool ParseProperty()
         {
-            string propertyExpression = this.ParsePropertyOrItemMetadata();
+            string propertyExpression = ParsePropertyOrItemMetadata();
 
             if (propertyExpression == null)
             {
@@ -426,7 +426,7 @@ private bool ParseProperty()
         /// <returns></returns>
         private bool ParseItemMetadata()
         {
-            string itemMetadataExpression = this.ParsePropertyOrItemMetadata();
+            string itemMetadataExpression = ParsePropertyOrItemMetadata();
 
             if (itemMetadataExpression == null)
             {
diff --git a/src/Build/Evaluation/Conditionals/Token.cs b/src/Build/Evaluation/Conditionals/Token.cs
index 7b9728a4b3b..237e343e913 100644
--- a/src/Build/Evaluation/Conditionals/Token.cs
+++ b/src/Build/Evaluation/Conditionals/Token.cs
@@ -103,7 +103,7 @@ internal Token(TokenType type, string tokenString, bool expandable)
 
             _tokenType = type;
             _tokenString = tokenString;
-            this.Expandable = expandable;
+            Expandable = expandable;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 598c949ec54..30a4b105a5b 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -736,7 +736,7 @@ private void Evaluate()
                 using (_evaluationProfiler.TrackPass(EvaluationPass.UsingTasks))
                 {
                     // Evaluate the usingtask and add the result into the data passed in
-                    TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<P, I>(
+                    TaskRegistry.InitializeTaskRegistryFromUsingTaskElements(
                         _evaluationLoggingContext,
                         _usingTaskElements.Select(p => (p.Value, p.Key)),
                         _data.TaskRegistry,
diff --git a/src/Build/Evaluation/EvaluatorMetadataTable.cs b/src/Build/Evaluation/EvaluatorMetadataTable.cs
index 6405834f994..bcb995b13df 100644
--- a/src/Build/Evaluation/EvaluatorMetadataTable.cs
+++ b/src/Build/Evaluation/EvaluatorMetadataTable.cs
@@ -112,8 +112,8 @@ public class EvaluatorMetadata
             /// </summary>
             public EvaluatorMetadata(ProjectMetadataElement xml, string evaluatedValueEscaped)
             {
-                this.Xml = xml;
-                this.EvaluatedValueEscaped = evaluatedValueEscaped;
+                Xml = xml;
+                EvaluatedValueEscaped = evaluatedValueEscaped;
             }
 
             /// <summary>
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 7397dee024f..651fe66a5f0 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
@@ -24,11 +25,10 @@
 using Microsoft.NET.StringTools;
 using Microsoft.Win32;
 using AvailableStaticMethods = Microsoft.Build.Internal.AvailableStaticMethods;
-using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
+using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
-using System.Buffers;
 
 #nullable disable
 
@@ -494,7 +494,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, _loggingContext);
             result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
-            result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
+            result = ItemExpander.ExpandItemVectorsIntoString(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
             return result;
@@ -576,7 +576,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
             foreach (string split in splits)
             {
                 bool isTransformExpression;
-                IList<T> itemsToAdd = ItemExpander.ExpandSingleItemVectorExpressionIntoItems<I, T>(this, split, _items, itemFactory, options, false /* do not include null items */, out isTransformExpression, elementLocation);
+                IList<T> itemsToAdd = ItemExpander.ExpandSingleItemVectorExpressionIntoItems(this, split, _items, itemFactory, options, false /* do not include null items */, out isTransformExpression, elementLocation);
 
                 if ((itemsToAdd == null /* broke out early non empty */ || (itemsToAdd.Count > 0)) && (options & ExpanderOptions.BreakOnNotEmpty) != 0)
                 {
@@ -650,7 +650,7 @@ internal IList<T> ExpandExpressionCaptureIntoItems<S, T>(
             where S : class, IItem
             where T : class, IItem
         {
-            return ItemExpander.ExpandExpressionCaptureIntoItems<S, T>(expressionCapture, this, items, itemFactory, options,
+            return ItemExpander.ExpandExpressionCaptureIntoItems(expressionCapture, this, items, itemFactory, options,
                 includeNullEntries, out isTransformExpression, elementLocation);
         }
 
@@ -1213,7 +1213,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 // so that we can either maintain the object's type in the event
                 // that we have a single component, or convert to a string
                 // if concatenation is required.
-                using Expander<P, I>.SpanBasedConcatenator results = new Expander<P, I>.SpanBasedConcatenator();
+                using SpanBasedConcatenator results = new SpanBasedConcatenator();
 
                 // The sourceIndex is the zero-based index into the expression,
                 // where we've essentially read up to and copied into the target string.
@@ -2056,7 +2056,7 @@ internal static bool ExpandExpressionCapture<S>(
                     Stack<TransformFunction<S>> transformFunctionStack = PrepareTransformStackFromMatch<S>(elementLocation, expressionCapture);
 
                     // iterate over the tranform chain, creating the final items from its results
-                    foreach (KeyValuePair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
+                    foreach (KeyValuePair<string, S> itemTuple in Transform(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
                     {
                         if (!string.IsNullOrEmpty(itemTuple.Key) && (options & ExpanderOptions.BreakOnNotEmpty) != 0)
                         {
@@ -2776,7 +2776,7 @@ internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
 
                         object result = function.Execute(item.Key, expander._properties, ExpanderOptions.ExpandAll, elementLocation);
 
-                        string include = Expander<P, I>.PropertyExpander<P>.ConvertToString(result);
+                        string include = PropertyExpander<P>.ConvertToString(result);
 
                         // We pass in the existing item so we can copy over its metadata
                         if (include.Length > 0)
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index a7d9e48b9a5..b4eb90edb8d 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -156,7 +156,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
 
                     // Grab the name, but continue to verify it's a well-formed expression
                     // before we store it.
-                    string itemName = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startOfName, i - startOfName));
+                    string itemName = NET.StringTools.Strings.WeakIntern(expression.AsSpan(startOfName, i - startOfName));
 
                     SinkWhitespace(expression, ref i);
                     bool transformOrFunctionFound = true;
@@ -251,7 +251,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                     // Create an expression capture that encompasses the entire expression between the @( and the )
                     // with the item name and any separator contained within it
                     // and each transform expression contained within it (i.e. each ->XYZ)
-                    ItemExpressionCapture expressionCapture = new ItemExpressionCapture(startPoint, endPoint - startPoint, Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startPoint, endPoint - startPoint)), itemName, separator, separatorStart, transformExpressions);
+                    ItemExpressionCapture expressionCapture = new ItemExpressionCapture(startPoint, endPoint - startPoint, NET.StringTools.Strings.WeakIntern(expression.AsSpan(startPoint, endPoint - startPoint)), itemName, separator, separatorStart, transformExpressions);
                     subExpressions.Add(expressionCapture);
 
                     continue;
@@ -598,7 +598,7 @@ private static ItemExpressionCapture SinkItemFunctionExpression(string expressio
 
                     if (endFunctionArguments > startFunctionArguments)
                     {
-                        capture.FunctionArguments = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startFunctionArguments, endFunctionArguments - startFunctionArguments));
+                        capture.FunctionArguments = NET.StringTools.Strings.WeakIntern(expression.AsSpan(startFunctionArguments, endFunctionArguments - startFunctionArguments));
                     }
 
                     return capture;
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 82ad36d6650..e81b6a0664a 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -268,12 +268,12 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, BackEnd.Logging.LoggingContext loggingContext, bool isEnvironmentVariable = false, bool isCommandLineProperty = false);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false, bool isCommandLineProperty = false);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
         /// </summary>
-        P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, BackEnd.Logging.LoggingContext loggingContext);
+        P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, LoggingContext loggingContext);
 
         /// <summary>
         /// Retrieves an existing target, if any.
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 7d6b051cf99..618f1d8bc17 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -2,11 +2,14 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers.Text;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
+using System.Security.Cryptography;
 using System.Text;
 using System.Text.RegularExpressions;
 using Microsoft.Build.BackEnd.Logging;
@@ -18,12 +21,8 @@
 using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 using Microsoft.Win32;
-using System.Linq;
-
 // Needed for DoesTaskHostExistForParameters
 using NodeProviderOutOfProcTaskHost = Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost;
-using System.Security.Cryptography;
-using System.Buffers.Text;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/ItemDataCollectionValue.cs b/src/Build/Evaluation/ItemDataCollectionValue.cs
index b380c7f9d95..eb367fb1788 100644
--- a/src/Build/Evaluation/ItemDataCollectionValue.cs
+++ b/src/Build/Evaluation/ItemDataCollectionValue.cs
@@ -88,7 +88,7 @@ public void Delete(I item)
             {
                 list.Remove(item);
             }
-            else if (object.Equals(_value, item))
+            else if (Equals(_value, item))
             {
                 _value = null;
             }
@@ -104,7 +104,7 @@ public void Replace(I oldItem, I newItem)
                     list[index] = newItem;
                 }
             }
-            else if (object.Equals(_value, oldItem))
+            else if (Equals(_value, oldItem))
             {
                 _value = newItem;
             }
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 30400c410f6..d31b206aab7 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -587,7 +587,7 @@ internal MetadataTrie(MatchOnMetadataOptions options, IEnumerable<string> metada
             {
                 foreach (ItemSpec<P, I>.ReferencedItem referencedItem in frag.ReferencedItems)
                 {
-                    this.Add(metadata.Select(m => referencedItem.Item.GetMetadataValue(m)), comparer);
+                    Add(metadata.Select(m => referencedItem.Item.GetMetadataValue(m)), comparer);
                 }
             }
         }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index b4685fa40d4..6b5f2335272 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -306,7 +306,7 @@ public void RecordImportWithDuplicates(ProjectImportElement importElement, Proje
                 _wrappedData.RecordImportWithDuplicates(importElement, import, versionEvaluated);
             }
 
-            public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, BackEnd.Logging.LoggingContext loggingContext)
+            public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, LoggingContext loggingContext)
             {
                 return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped, loggingContext);
             }
diff --git a/src/Build/Evaluation/MetadataReference.cs b/src/Build/Evaluation/MetadataReference.cs
index 1c8e3b7b37e..2d24490f121 100644
--- a/src/Build/Evaluation/MetadataReference.cs
+++ b/src/Build/Evaluation/MetadataReference.cs
@@ -32,8 +32,8 @@ internal MetadataReference(
             string itemName,
             string metadataName)
         {
-            this.ItemName = itemName;
-            this.MetadataName = metadataName;
+            ItemName = itemName;
+            MetadataName = metadataName;
         }
     }
 }
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 30e364ae5bd..0b98c6451cd 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -558,7 +558,7 @@ private void RenameEntryInternal(string oldFullPathIfAny, ProjectRootElement pro
             ProjectRootElement existingWeakEntry;
             _weakCache.TryGetValue(projectRootElement.FullPath, out existingWeakEntry);
 
-            if (existingWeakEntry != null && !object.ReferenceEquals(existingWeakEntry, projectRootElement))
+            if (existingWeakEntry != null && !ReferenceEquals(existingWeakEntry, projectRootElement))
             {
                 _strongCache.Remove(existingWeakEntry);
             }
@@ -586,7 +586,7 @@ private void BoostEntryInStrongCache(ProjectRootElement projectRootElement)
 
             while (node != null)
             {
-                if (Object.ReferenceEquals(node.Value, projectRootElement))
+                if (ReferenceEquals(node.Value, projectRootElement))
                 {
                     // DebugTraceCache("Boosting: ", projectRootElement.FullPath);
                     _strongCache.Remove(node);
diff --git a/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs b/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
index c8a4a6351eb..e547183d402 100644
--- a/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
+++ b/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
@@ -36,7 +36,7 @@ internal ProjectXmlChangedEventArgs(ProjectRootElement projectXml, string unform
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectXml);
 
-            this.ProjectXml = projectXml;
+            ProjectXml = projectXml;
             _unformattedReason = unformattedReason;
             _formattingParameter = formattingParameter;
         }
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index c7b8ae0d6ad..62505de6432 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -63,7 +63,7 @@ public P GetProperty(string name)
             P prop = _wrapped.GetProperty(name);
             if (IsPropertyReadTrackingRequested)
             {
-                this.TrackPropertyRead(name, prop);
+                TrackPropertyRead(name, prop);
             }
 
             return prop;
@@ -78,7 +78,7 @@ public P GetProperty(string name, int startIndex, int endIndex)
             P prop = _wrapped.GetProperty(name, startIndex, endIndex);
             if (IsPropertyReadTrackingRequested)
             {
-                this.TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
+                TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
             }
 
             return prop;
@@ -99,11 +99,11 @@ public P SetProperty(
             P? originalProperty = _wrapped.GetProperty(name);
             P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, _evaluationLoggingContext, isEnvironmentVariable, isCommandLineProperty);
 
-            this.TrackPropertyWrite(
+            TrackPropertyWrite(
                 originalProperty,
                 newProperty,
                 null,
-                this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable, isCommandLineProperty),
+                DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable, isCommandLineProperty),
                 loggingContext);
 
             return newProperty;
@@ -121,7 +121,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
             P? originalProperty = _wrapped.GetProperty(propertyElement.Name);
             P newProperty = _wrapped.SetProperty(propertyElement, evaluatedValueEscaped, loggingContext);
 
-            this.TrackPropertyWrite(
+            TrackPropertyWrite(
                 originalProperty,
                 newProperty,
                 propertyElement.Location,
@@ -199,11 +199,11 @@ private void TrackPropertyRead(string name, P property)
             // track it as an environment variable read.
             if (IsEnvironmentVariableReadTrackingRequested && _wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && !_overwrittenEnvironmentVariables.Contains(name))
             {
-                this.TrackEnvironmentVariableRead(name);
+                TrackEnvironmentVariableRead(name);
             }
             else if (property == null)
             {
-                this.TrackUninitializedPropertyRead(name);
+                TrackUninitializedPropertyRead(name);
             }
         }
 
@@ -459,7 +459,8 @@ internal static void LogPropertyAssignment(
                         location.File,
                         location.Line,
                         location.Column,
-                        message: null) { BuildEventContext = loggingContext.BuildEventContext };
+                        message: null)
+                    { BuildEventContext = loggingContext.BuildEventContext };
 
                     loggingContext.LogBuildEvent(args);
                 }
@@ -478,7 +479,8 @@ internal static void LogPropertyAssignment(
                             location.File,
                             location.Line,
                             location.Column,
-                            message: null) { BuildEventContext = loggingContext.BuildEventContext, };
+                            message: null)
+                        { BuildEventContext = loggingContext.BuildEventContext, };
 
                         loggingContext.LogBuildEvent(args);
                     }
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 38915e44cd3..3506fa5925d 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -85,7 +85,7 @@ public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDir
 
         private MSBuildGlob(Lazy<GlobState> state)
         {
-            this._state = state;
+            _state = state;
         }
 
         /// <inheritdoc />
@@ -253,12 +253,12 @@ public static MSBuildGlob Parse(string fileSpec)
         }
 
         /// <summary>
-        ///     Return type of <see cref="MSBuildGlob.MatchInfo" />
+        ///     Return type of <see cref="MatchInfo" />
         /// </summary>
         public readonly struct MatchInfoResult
         {
             /// <summary>
-            ///     Whether the <see cref="MSBuildGlob.MatchInfo" /> argument was matched against the glob
+            ///     Whether the <see cref="MatchInfo" /> argument was matched against the glob
             /// </summary>
             public bool IsMatch { get; }
 
diff --git a/src/Build/Graph/GraphBuildSubmission.cs b/src/Build/Graph/GraphBuildSubmission.cs
index 164cfc8e377..e68281f780c 100644
--- a/src/Build/Graph/GraphBuildSubmission.cs
+++ b/src/Build/Graph/GraphBuildSubmission.cs
@@ -50,7 +50,7 @@ void Clb(BuildSubmissionBase<GraphBuildRequestData, GraphBuildResult> submission
         /// <summary>
         /// Starts the request and blocks until results are available.
         /// </summary>
-        /// <exception cref="System.InvalidOperationException">The request has already been started or is already complete.</exception>
+        /// <exception cref="InvalidOperationException">The request has already been started or is already complete.</exception>
         public override GraphBuildResult Execute()
         {
             ExecuteAsync(null, null);
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index f77da95817b..0c20dc4bad7 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -378,13 +378,13 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
             EvaluationId = project.EvaluationCounter;
 
             var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
-            this.CreatePropertiesSnapshot(project.Properties, immutable);
-            this.CreateItemDefinitionsSnapshot(project.ItemDefinitions);
+            CreatePropertiesSnapshot(project.Properties, immutable);
+            CreateItemDefinitionsSnapshot(project.ItemDefinitions);
 
             var keepEvaluationCache = (settings & ProjectInstanceSettings.ImmutableWithFastItemLookup) == ProjectInstanceSettings.ImmutableWithFastItemLookup;
-            var projectItemToInstanceMap = this.CreateItemsSnapshot(project.Items, project.ItemTypes.Count, keepEvaluationCache);
+            var projectItemToInstanceMap = CreateItemsSnapshot(project.Items, project.ItemTypes.Count, keepEvaluationCache);
 
-            this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, project.Items, projectItemToInstanceMap);
+            CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, project.Items, projectItemToInstanceMap);
 
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(project.GlobalPropertiesCount);
             foreach (var property in project.GlobalPropertiesEnumerable)
@@ -392,20 +392,20 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
                 _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
             }
 
-            this.CreateEnvironmentVariablePropertiesSnapshot(project.ProjectCollection.EnvironmentProperties);
-            this.CreateTargetsSnapshot(project.Targets, null, null, null, null);
-            this.CreateImportsSnapshot(project.Imports, project.ImportsIncludingDuplicates);
+            CreateEnvironmentVariablePropertiesSnapshot(project.ProjectCollection.EnvironmentProperties);
+            CreateTargetsSnapshot(project.Targets, null, null, null, null);
+            CreateImportsSnapshot(project.Imports, project.ImportsIncludingDuplicates);
 
-            this.Toolset = project.ProjectCollection.GetToolset(project.ToolsVersion);
-            this.SubToolsetVersion = project.SubToolsetVersion;
-            this.TaskRegistry = new TaskRegistry(Toolset, project.ProjectCollection.ProjectRootElementCache);
+            Toolset = project.ProjectCollection.GetToolset(project.ToolsVersion);
+            SubToolsetVersion = project.SubToolsetVersion;
+            TaskRegistry = new TaskRegistry(Toolset, project.ProjectCollection.ProjectRootElementCache);
 
-            this.ProjectRootElementCache = project.ProjectCollection.ProjectRootElementCache;
+            ProjectRootElementCache = project.ProjectCollection.ProjectRootElementCache;
 
-            this.EvaluatedItemElements = new List<ProjectItemElement>(project.Items.Count);
+            EvaluatedItemElements = new List<ProjectItemElement>(project.Items.Count);
             foreach (var item in project.Items)
             {
-                this.EvaluatedItemElements.Add(item.Xml);
+                EvaluatedItemElements.Add(item.Xml);
             }
 
             _usingDifferentToolsVersionFromProjectFile = false;
@@ -533,8 +533,8 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
         {
             _projectFileLocation = ElementLocation.Create(projectFile);
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalProperties.Count);
-            this.Toolset = projectToInheritFrom.Toolset;
-            this.SubToolsetVersion = projectToInheritFrom.SubToolsetVersion;
+            Toolset = projectToInheritFrom.Toolset;
+            SubToolsetVersion = projectToInheritFrom.SubToolsetVersion;
             _explicitToolsVersionSpecified = projectToInheritFrom._explicitToolsVersionSpecified;
             _properties = new PropertyDictionary<ProjectPropertyInstance>(projectToInheritFrom._properties); // This brings along the reserved properties, which are important.
             _items = new ItemDictionary<ProjectItemInstance>(); // We don't want any of the items.  That would include things like ProjectReferences, which would just pollute our own.
@@ -543,19 +543,19 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
             _environmentVariableProperties = projectToInheritFrom._environmentVariableProperties;
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(projectToInheritFrom._itemDefinitions, MSBuildNameIgnoreCaseComparer.Default);
             _hostServices = projectToInheritFrom._hostServices;
-            this.ProjectRootElementCache = projectToInheritFrom.ProjectRootElementCache;
+            ProjectRootElementCache = projectToInheritFrom.ProjectRootElementCache;
             _explicitToolsVersionSpecified = projectToInheritFrom._explicitToolsVersionSpecified;
-            this.InitialTargets = new List<string>();
-            this.DefaultTargets = new List<string>();
-            this.DefaultTargets.Add("Build");
-            this.TaskRegistry = projectToInheritFrom.TaskRegistry;
+            InitialTargets = new List<string>();
+            DefaultTargets = new List<string>();
+            DefaultTargets.Add("Build");
+            TaskRegistry = projectToInheritFrom.TaskRegistry;
             _isImmutable = projectToInheritFrom._isImmutable;
             _importPaths = projectToInheritFrom._importPaths;
             ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = projectToInheritFrom._importPathsIncludingDuplicates;
             ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
-            this.EvaluatedItemElements = new List<ProjectItemElement>();
+            EvaluatedItemElements = new List<ProjectItemElement>();
 
             IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance> thisAsIEvaluatorData = this;
             thisAsIEvaluatorData.AfterTargets = new Dictionary<string, List<TargetSpecification>>();
@@ -638,7 +638,7 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// Constructor called by Project's constructor to create a fresh instance.
         /// Properties and items are cloned immediately and only the instance data is stored.
         /// </summary>
-        internal ProjectInstance(Evaluation.Project.Data data, string directory, string fullPath, HostServices hostServices, PropertyDictionary<ProjectPropertyInstance> environmentVariableProperties, ProjectInstanceSettings settings)
+        internal ProjectInstance(Project.Data data, string directory, string fullPath, HostServices hostServices, PropertyDictionary<ProjectPropertyInstance> environmentVariableProperties, ProjectInstanceSettings settings)
         {
             ErrorUtilities.VerifyThrowInternalNull(data);
             ErrorUtilities.VerifyThrowInternalLength(directory, nameof(directory));
@@ -651,28 +651,28 @@ internal ProjectInstance(Evaluation.Project.Data data, string directory, string
             EvaluationId = data.EvaluationId;
 
             var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
-            this.CreatePropertiesSnapshot(new ReadOnlyCollection<ProjectProperty>(data.Properties), immutable);
+            CreatePropertiesSnapshot(new ReadOnlyCollection<ProjectProperty>(data.Properties), immutable);
 
-            this.CreateItemDefinitionsSnapshot(data.ItemDefinitions);
+            CreateItemDefinitionsSnapshot(data.ItemDefinitions);
 
             var keepEvaluationCache = (settings & ProjectInstanceSettings.ImmutableWithFastItemLookup) == ProjectInstanceSettings.ImmutableWithFastItemLookup;
-            var projectItemToInstanceMap = this.CreateItemsSnapshot(new ReadOnlyCollection<ProjectItem>(data.Items), data.ItemTypes.Count, keepEvaluationCache);
+            var projectItemToInstanceMap = CreateItemsSnapshot(new ReadOnlyCollection<ProjectItem>(data.Items), data.ItemTypes.Count, keepEvaluationCache);
 
-            this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, new ReadOnlyCollection<ProjectItem>(data.Items), projectItemToInstanceMap);
-            this.CreateGlobalPropertiesSnapshot(data.GlobalPropertiesDictionary);
-            this.CreateEnvironmentVariablePropertiesSnapshot(environmentVariableProperties);
-            this.CreateTargetsSnapshot(data.Targets, data.DefaultTargets, data.InitialTargets, data.BeforeTargets, data.AfterTargets);
-            this.CreateImportsSnapshot(data.ImportClosure, data.ImportClosureWithDuplicates);
+            CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, new ReadOnlyCollection<ProjectItem>(data.Items), projectItemToInstanceMap);
+            CreateGlobalPropertiesSnapshot(data.GlobalPropertiesDictionary);
+            CreateEnvironmentVariablePropertiesSnapshot(environmentVariableProperties);
+            CreateTargetsSnapshot(data.Targets, data.DefaultTargets, data.InitialTargets, data.BeforeTargets, data.AfterTargets);
+            CreateImportsSnapshot(data.ImportClosure, data.ImportClosureWithDuplicates);
 
             // Toolset and task registry are logically immutable after creation, and shareable by project instances
             //  with same evaluation (global/local properties) - which is guaranteed here (the passed in data is recreated on evaluation if needed)
-            this.Toolset = data.Toolset;
-            this.SubToolsetVersion = data.SubToolsetVersion;
-            this.TaskRegistry = data.TaskRegistry;
+            Toolset = data.Toolset;
+            SubToolsetVersion = data.SubToolsetVersion;
+            TaskRegistry = data.TaskRegistry;
 
-            this.ProjectRootElementCache = data.Project.ProjectCollection.ProjectRootElementCache;
+            ProjectRootElementCache = data.Project.ProjectCollection.ProjectRootElementCache;
 
-            this.EvaluatedItemElements = new List<ProjectItemElement>(data.EvaluatedItemElements);
+            EvaluatedItemElements = new List<ProjectItemElement>(data.EvaluatedItemElements);
 
             _usingDifferentToolsVersionFromProjectFile = data.UsingDifferentToolsVersionFromProjectFile;
             _originalProjectToolsVersion = data.OriginalProjectToolsVersion;
@@ -737,8 +737,8 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                     _environmentVariableProperties.Set(environmentProperty.DeepClone(_isImmutable));
                 }
 
-                this.DefaultTargets = new List<string>(that.DefaultTargets);
-                this.InitialTargets = new List<string>(that.InitialTargets);
+                DefaultTargets = new List<string>(that.DefaultTargets);
+                InitialTargets = new List<string>(that.InitialTargets);
                 ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
                     ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(
                     ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
@@ -748,9 +748,9 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                     ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
                         ProjectItemDefinitionInstance>)that).AfterTargets, StringComparer.OrdinalIgnoreCase);
                 // These are immutable (or logically immutable after creation) so we don't need to clone them:
-                this.TaskRegistry = that.TaskRegistry;
-                this.Toolset = that.Toolset;
-                this.SubToolsetVersion = that.SubToolsetVersion;
+                TaskRegistry = that.TaskRegistry;
+                Toolset = that.Toolset;
+                SubToolsetVersion = that.SubToolsetVersion;
                 _targets = that._targets;
                 _itemDefinitions = that._itemDefinitions;
                 _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
@@ -759,9 +759,9 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 _importPathsIncludingDuplicates = that._importPathsIncludingDuplicates;
                 ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
-                this.EvaluatedItemElements = that.EvaluatedItemElements;
+                EvaluatedItemElements = that.EvaluatedItemElements;
 
-                this.ProjectRootElementCache = that.ProjectRootElementCache;
+                ProjectRootElementCache = that.ProjectRootElementCache;
             }
             else
             {
@@ -1950,7 +1950,7 @@ public ProjectItemInstance AddItem(string itemType, string evaluatedInclude)
         {
             VerifyThrowNotImmutable();
 
-            ProjectItemInstance item = new ProjectItemInstance(this, itemType, evaluatedInclude, this.FullPath);
+            ProjectItemInstance item = new ProjectItemInstance(this, itemType, evaluatedInclude, FullPath);
             _items.Add(item);
 
             return item;
@@ -1973,7 +1973,7 @@ public ProjectItemInstance AddItem(string itemType, string evaluatedInclude, IEn
         {
             VerifyThrowNotImmutable();
 
-            ProjectItemInstance item = new ProjectItemInstance(this, itemType, evaluatedInclude, metadata, this.FullPath);
+            ProjectItemInstance item = new ProjectItemInstance(this, itemType, evaluatedInclude, metadata, FullPath);
             _items.Add(item);
 
             return item;
@@ -3104,9 +3104,9 @@ private void Initialize(
             _environmentVariableProperties = buildParameters.EnvironmentPropertiesInternal;
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
             _hostServices = buildParameters.HostServices;
-            this.ProjectRootElementCache = buildParameters.ProjectRootElementCache;
+            ProjectRootElementCache = buildParameters.ProjectRootElementCache;
             _loggingContext = new GenericLoggingContext(loggingService, buildEventContext);
-            this.EvaluatedItemElements = new List<ProjectItemElement>();
+            EvaluatedItemElements = new List<ProjectItemElement>();
 
             _explicitToolsVersionSpecified = (explicitToolsVersion != null);
             ElementLocation toolsVersionLocation = xml.Location;
@@ -3126,9 +3126,9 @@ private void Initialize(
 
             _usingDifferentToolsVersionFromProjectFile = usingDifferentToolsVersionFromProjectFile;
 
-            this.Toolset = buildParameters.GetToolset(toolsVersionToUse);
+            Toolset = buildParameters.GetToolset(toolsVersionToUse);
 
-            if (this.Toolset == null)
+            if (Toolset == null)
             {
                 string toolsVersionList = Utilities.CreateToolsVersionListString(buildParameters.Toolsets);
                 ProjectErrorUtilities.ThrowInvalidProject(toolsVersionLocation, "UnrecognizedToolsVersion", toolsVersionToUse, toolsVersionList);
@@ -3136,15 +3136,15 @@ private void Initialize(
 
             if (explicitSubToolsetVersion != null)
             {
-                this.SubToolsetVersion = explicitSubToolsetVersion;
+                SubToolsetVersion = explicitSubToolsetVersion;
             }
             else
             {
-                this.SubToolsetVersion = this.Toolset.GenerateSubToolsetVersionUsingVisualStudioVersion(globalProperties, visualStudioVersionFromSolution);
+                SubToolsetVersion = Toolset.GenerateSubToolsetVersionUsingVisualStudioVersion(globalProperties, visualStudioVersionFromSolution);
             }
 
             // Create a task registry which will fall back on the toolset task registry if necessary.
-            this.TaskRegistry = new TaskRegistry(this.Toolset, ProjectRootElementCache);
+            TaskRegistry = new TaskRegistry(Toolset, ProjectRootElementCache);
 
             if (globalProperties != null)
             {
diff --git a/src/Build/Instance/ProjectItemGroupTaskInstance.cs b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
index 11c2cc520d5..ed779dbd9da 100644
--- a/src/Build/Instance/ProjectItemGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
@@ -127,7 +127,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
-                var typeName = this.GetType().FullName;
+                var typeName = GetType().FullName;
                 translator.Translate(ref typeName);
             }
 
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 36f280f88bb..824faaa5a52 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -880,7 +880,7 @@ private TaskItem(ITranslator translator)
             /// </summary>
             private TaskItem(ITranslator translator, LookasideStringInterner interner)
             {
-                this.TranslateWithInterning(translator, interner);
+                TranslateWithInterning(translator, interner);
             }
 
             /// <summary>
@@ -999,7 +999,7 @@ string IItem.ProjectDirectory
             /// Returns some value useful for a key in a dictionary
             /// </summary>
             [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-            string Microsoft.Build.Collections.IKeyed.Key
+            string IKeyed.Key
             {
                 get { return _includeEscaped; }
             }
@@ -1586,7 +1586,7 @@ public override int GetHashCode()
             /// </summary>
             public override bool Equals(object obj)
             {
-                return this.Equals(obj as TaskItem);
+                return Equals(obj as TaskItem);
             }
 
             /// <summary>
@@ -1606,7 +1606,7 @@ public bool Equals(TaskItem other)
                     return false;
                 }
 
-                if (Object.ReferenceEquals(this, other))
+                if (ReferenceEquals(this, other))
                 {
                     return true;
                 }
@@ -1986,7 +1986,7 @@ internal ProjectItemInstanceFactory(ProjectInstance project, string itemType)
                     : this(project)
                 {
                     ErrorUtilities.VerifyThrowInternalLength(itemType, nameof(itemType));
-                    this.ItemType = itemType;
+                    ItemType = itemType;
                 }
 
                 /// <summary>
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index 15136b19c1d..8ad840127d7 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -194,7 +194,7 @@ void ITranslatable.Translate(ITranslator translator)
         /// <returns>True if they are equivalent, false otherwise.</returns>
         bool IEquatable<ProjectMetadataInstance>.Equals(ProjectMetadataInstance other)
         {
-            if (Object.ReferenceEquals(this, other))
+            if (ReferenceEquals(this, other))
             {
                 return true;
             }
diff --git a/src/Build/Instance/ProjectOnErrorInstance.cs b/src/Build/Instance/ProjectOnErrorInstance.cs
index d6d8c8d2d85..ef3d1ba7ceb 100644
--- a/src/Build/Instance/ProjectOnErrorInstance.cs
+++ b/src/Build/Instance/ProjectOnErrorInstance.cs
@@ -116,7 +116,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
-                var typeName = this.GetType().FullName;
+                var typeName = GetType().FullName;
                 translator.Translate(ref typeName);
             }
 
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
index f851d53741d..b01e3beb5a1 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
@@ -126,7 +126,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
-                var typeName = this.GetType().FullName;
+                var typeName = GetType().FullName;
                 translator.Translate(ref typeName);
             }
 
diff --git a/src/Build/Instance/ProjectTargetInstance.cs b/src/Build/Instance/ProjectTargetInstance.cs
index 4d04480d109..2913defbb68 100644
--- a/src/Build/Instance/ProjectTargetInstance.cs
+++ b/src/Build/Instance/ProjectTargetInstance.cs
@@ -543,7 +543,7 @@ internal ProjectTaskInstance AddTask(string taskName, string condition, string c
         {
             ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
             ProjectTaskInstance task = new ProjectTaskInstance(taskName, _location, condition ?? String.Empty, continueOnError ?? String.Empty, msbuildRuntime ?? String.Empty, msbuildArchitecture ?? String.Empty);
-            this.AddProjectTargetInstanceChild(task);
+            AddProjectTargetInstanceChild(task);
             return task;
         }
 
diff --git a/src/Build/Instance/ProjectTaskInstance.cs b/src/Build/Instance/ProjectTaskInstance.cs
index 840eaea157d..c3fd66bd846 100644
--- a/src/Build/Instance/ProjectTaskInstance.cs
+++ b/src/Build/Instance/ProjectTaskInstance.cs
@@ -359,7 +359,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
-                var typeName = this.GetType().FullName;
+                var typeName = GetType().FullName;
                 translator.Translate(ref typeName);
             }
 
diff --git a/src/Build/Instance/ProjectTaskOutputItemInstance.cs b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
index 88e61d74c72..249a7d1834b 100644
--- a/src/Build/Instance/ProjectTaskOutputItemInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
@@ -137,7 +137,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
-                var typeName = this.GetType().FullName;
+                var typeName = GetType().FullName;
                 translator.Translate(ref typeName);
             }
 
diff --git a/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs b/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
index e6ad926b885..c75befd6f8d 100644
--- a/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
@@ -137,7 +137,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
-                var typeName = this.GetType().FullName;
+                var typeName = GetType().FullName;
                 translator.Translate(ref typeName);
             }
 
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 784b67b200c..12065036f16 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -9,9 +9,9 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
@@ -524,14 +524,14 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
             switch (logMessagePacket.EventType)
             {
                 case LoggingEventType.BuildErrorEvent:
-                    this.BuildEngine.LogErrorEvent((BuildErrorEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
+                    BuildEngine.LogErrorEvent((BuildErrorEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
                     break;
                 case LoggingEventType.BuildWarningEvent:
-                    this.BuildEngine.LogWarningEvent((BuildWarningEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
+                    BuildEngine.LogWarningEvent((BuildWarningEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
                     break;
                 case LoggingEventType.TaskCommandLineEvent:
                 case LoggingEventType.BuildMessageEvent:
-                    this.BuildEngine.LogMessageEvent((BuildMessageEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
+                    BuildEngine.LogMessageEvent((BuildMessageEventArgs)logMessagePacket.NodeBuildEvent.Value.Value);
                     break;
                 case LoggingEventType.CustomEvent:
                     BuildEventArgs buildEvent = logMessagePacket.NodeBuildEvent.Value.Value;
@@ -540,19 +540,19 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
                     // in which case they need to be dealt with in the same way as their base type of event.
                     if (buildEvent is BuildErrorEventArgs buildErrorEventArgs)
                     {
-                        this.BuildEngine.LogErrorEvent(buildErrorEventArgs);
+                        BuildEngine.LogErrorEvent(buildErrorEventArgs);
                     }
                     else if (buildEvent is BuildWarningEventArgs buildWarningEventArgs)
                     {
-                        this.BuildEngine.LogWarningEvent(buildWarningEventArgs);
+                        BuildEngine.LogWarningEvent(buildWarningEventArgs);
                     }
                     else if (buildEvent is BuildMessageEventArgs buildMessageEventArgs)
                     {
-                        this.BuildEngine.LogMessageEvent(buildMessageEventArgs);
+                        BuildEngine.LogMessageEvent(buildMessageEventArgs);
                     }
                     else if (buildEvent is CustomBuildEventArgs customBuildEventArgs)
                     {
-                        this.BuildEngine.LogCustomEvent(customBuildEventArgs);
+                        BuildEngine.LogCustomEvent(customBuildEventArgs);
                     }
                     else
                     {
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 7b6ef85cb76..10ca5eaf217 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -152,7 +152,7 @@ internal BuildLoggingContext LoggingContext
         /// Logs an error event for the current task
         /// </summary>
         /// <param name="e">The event args</param>
-        public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
+        public void LogErrorEvent(BuildErrorEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e);
             VerifyActiveProxy();
@@ -173,7 +173,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         /// Logs a warning event for the current task
         /// </summary>
         /// <param name="e">The event args</param>
-        public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
+        public void LogWarningEvent(BuildWarningEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e);
             VerifyActiveProxy();
@@ -194,7 +194,7 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         /// Logs a message event for the current task
         /// </summary>
         /// <param name="e">The event args</param>
-        public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
+        public void LogMessageEvent(BuildMessageEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e);
             VerifyActiveProxy();
@@ -215,7 +215,7 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         /// Logs a custom event for the current task
         /// </summary>
         /// <param name="e">The event args</param>
-        public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
+        public void LogCustomEvent(CustomBuildEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e);
             VerifyActiveProxy();
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 12d084f9940..c8ade6079ea 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -273,7 +273,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
             }
 #if DEBUG
             taskRegistry._isInitialized = true;
-            taskRegistry._taskRegistrations ??= TaskRegistry.CreateRegisteredTaskDictionary();
+            taskRegistry._taskRegistrations ??= CreateRegisteredTaskDictionary();
 #endif
         }
 
@@ -426,7 +426,7 @@ private static void RegisterTasksFromUsingTaskElement
             if (projectUsingTaskXml.Count > 0)
             {
                 parameterGroupAndTaskElementRecord = new RegisteredTaskRecord.ParameterGroupAndTaskElementRecord();
-                parameterGroupAndTaskElementRecord.ExpandUsingTask<P, I>(projectUsingTaskXml, expander, expanderOptions);
+                parameterGroupAndTaskElementRecord.ExpandUsingTask(projectUsingTaskXml, expander, expanderOptions);
             }
 
             Dictionary<string, string> taskFactoryParameters = null;
@@ -655,7 +655,7 @@ private static bool IsTaskFactoryClass(Type type, object unused)
         {
             return type.GetTypeInfo().IsClass &&
                 !type.GetTypeInfo().IsAbstract &&
-                typeof(Microsoft.Build.Framework.ITaskFactory).IsAssignableFrom(type);
+                typeof(ITaskFactory).IsAssignableFrom(type);
         }
 
         /// <summary>
@@ -1183,7 +1183,7 @@ internal class Stats()
             {
                 public short ExecutedCount { get; private set; } = 0;
                 public long TotalMemoryConsumption { get; private set; } = 0;
-                private readonly Stopwatch _executedSw  = new Stopwatch();
+                private readonly Stopwatch _executedSw = new Stopwatch();
                 private long _memoryConsumptionOnStart;
 
                 public TimeSpan ExecutedTime => _executedSw.Elapsed;
@@ -1377,7 +1377,7 @@ internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile,
                                 // and the identity parameters don't match the factory's declared parameters.
                                 // This is because when the task factory is instantiated we try and load the Registered name from the task factory and fail it it cannot be loaded
                                 // therefore the fact that we have a factory means the Registered type and parameters can be created by the factory.
-                                if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Fuzzy.Equals(this.TaskIdentity, taskIdentity))
+                                if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Fuzzy.Equals(TaskIdentity, taskIdentity))
                                 {
                                     creatableByFactory = this;
                                 }
@@ -1705,14 +1705,14 @@ internal void ExpandUsingTask<P, I>(ProjectUsingTaskElement projectUsingTaskXml,
                     ProjectUsingTaskBodyElement taskElement = projectUsingTaskXml.TaskBody;
                     if (taskElement != null)
                     {
-                        EvaluateTaskBody<P, I>(expander, taskElement, expanderOptions);
+                        EvaluateTaskBody(expander, taskElement, expanderOptions);
                     }
 
                     UsingTaskParameterGroupElement parameterGroupElement = projectUsingTaskXml.ParameterGroup;
 
                     if (parameterGroupElement != null)
                     {
-                        ParseUsingTaskParameterGroupElement<P, I>(parameterGroupElement, expander, expanderOptions);
+                        ParseUsingTaskParameterGroupElement(parameterGroupElement, expander, expanderOptions);
                     }
                 }
 
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 364487c1e72..74496433615 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -150,7 +150,7 @@ internal void WriteNewLine()
         /// <param name="args"></param>
         internal void WriteLinePrettyFromResource(string resourceString, params object[] args)
         {
-            int indentLevel = IsVerbosityAtLeast(LoggerVerbosity.Normal) ? this.currentIndentLevel : 0;
+            int indentLevel = IsVerbosityAtLeast(LoggerVerbosity.Normal) ? currentIndentLevel : 0;
             WriteLinePrettyFromResource(indentLevel, resourceString, args);
         }
 
@@ -169,7 +169,7 @@ internal void WriteLinePrettyFromResource(int indentLevel, string resourceString
         /// </summary>
         internal void WritePretty(string formattedString)
         {
-            int indentLevel = IsVerbosityAtLeast(LoggerVerbosity.Normal) ? this.currentIndentLevel : 0;
+            int indentLevel = IsVerbosityAtLeast(LoggerVerbosity.Normal) ? currentIndentLevel : 0;
             WritePretty(indentLevel, formattedString);
         }
 
@@ -430,20 +430,20 @@ internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandle
 
             if (colorSet != null && canSetColor)
             {
-                this.setColor = colorSet;
+                setColor = colorSet;
             }
             else
             {
-                this.setColor = DontSetColor;
+                setColor = DontSetColor;
             }
 
             if (colorReset != null && canSetColor)
             {
-                this.resetColor = colorReset;
+                resetColor = colorReset;
             }
             else
             {
-                this.resetColor = DontResetColor;
+                resetColor = DontResetColor;
             }
         }
 
@@ -901,7 +901,7 @@ public virtual void Initialize(IEventSource eventSource)
             // Always show perf summary for diagnostic verbosity.
             if (IsVerbosityAtLeast(LoggerVerbosity.Diagnostic))
             {
-                this.showPerfSummary = true;
+                showPerfSummary = true;
             }
 
             ParseParameters();
@@ -917,7 +917,7 @@ public virtual void Initialize(IEventSource eventSource)
                     ShowSummary = false;
                 }
 
-                this.showPerfSummary = false;
+                showPerfSummary = false;
             }
 
             // If not specifically instructed otherwise, show a summary in normal
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index 1e7ab846695..1b5b46c6f13 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -248,7 +248,7 @@ public void Replay(BuildEventArgsReader reader, CancellationToken cancellationTo
 
             if (HasStructuredEventsSubscribers || !supportsForwardCompatibility)
             {
-                if (this._rawLogRecordReceived != null)
+                if (_rawLogRecordReceived != null)
                 {
                     throw new NotSupportedException(
                         ResourceUtilities.GetResourceString("Binlog_Source_MultiSubscribeError"));
@@ -266,10 +266,10 @@ public void Replay(BuildEventArgsReader reader, CancellationToken cancellationTo
             }
             else
             {
-                if (this._rawLogRecordReceived == null &&
-                    this._embeddedContentRead == null &&
-                    this._stringReadDone == null &&
-                    this._archiveFileEncountered == null)
+                if (_rawLogRecordReceived == null &&
+                    _embeddedContentRead == null &&
+                    _stringReadDone == null &&
+                    _archiveFileEncountered == null)
                 {
                     throw new NotSupportedException(
                         ResourceUtilities.GetResourceString("Binlog_Source_MissingSubscribeError"));
@@ -302,8 +302,8 @@ void IBinaryLogReplaySource.DeferredInitialize(
             Action onRawReadingPossible,
             Action onStructuredReadingOnly)
         {
-            this._onRawReadingPossible += onRawReadingPossible;
-            this._onStructuredReadingOnly += onStructuredReadingOnly;
+            _onRawReadingPossible += onRawReadingPossible;
+            _onStructuredReadingOnly += onStructuredReadingOnly;
         }
 
         private Action<EmbeddedContentEventArgs>? _embeddedContentRead;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 69afeee1674..970a8b1ad03 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -68,12 +68,12 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa
         /// <param name="fileFormatVersion">The file format version of the log file being read.</param>
         public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
         {
-            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);
+            _readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);
             // make sure the reader we're going to use wraps the transparent stream wrapper
-            this._binaryReader = binaryReader.BaseStream == _readStream
+            _binaryReader = binaryReader.BaseStream == _readStream
                 ? binaryReader
                 : new BinaryReader(_readStream);
-            this._fileFormatVersion = fileFormatVersion;
+            _fileFormatVersion = fileFormatVersion;
         }
 
         /// <summary>
@@ -1658,7 +1658,7 @@ private ITaskItem ReadTaskItem()
         private string ReadString()
         {
             string text = _binaryReader.ReadString();
-            if (this.StringReadDone != null)
+            if (StringReadDone != null)
             {
                 stringReadEventArgs.Reuse(text);
                 StringReadDone(stringReadEventArgs);
@@ -1709,7 +1709,7 @@ private string ReadString()
             // we reserve numbers 2-9 for future use.
             // the writer assigns 10 as the index of the first string
             index -= BuildEventArgsWriter.StringStartIndex;
-            if (index >= 0 && index < this.stringRecords.Count)
+            if (index >= 0 && index < stringRecords.Count)
             {
                 object storedString = stringRecords[index];
                 string result = stringStorage.Get(storedString);
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index fc44128aba0..863eb12db3d 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -128,12 +128,12 @@ public BuildEventArgsWriter(BinaryWriter binaryWriter)
 
             // this doesn't exceed 30K for smaller binlogs so seems like a reasonable
             // starting point to avoid reallocations in the common case
-            this.currentRecordStream = new MemoryStream(65536);
+            currentRecordStream = new MemoryStream(65536);
 
-            this.nameValueListStream = new MemoryStream(256);
+            nameValueListStream = new MemoryStream(256);
 
-            this.originalBinaryWriter = binaryWriter;
-            this.currentRecordWriter = new BinaryWriter(currentRecordStream);
+            originalBinaryWriter = binaryWriter;
+            currentRecordWriter = new BinaryWriter(currentRecordStream);
 
             this.binaryWriter = currentRecordWriter;
         }
@@ -144,7 +144,7 @@ public BuildEventArgsWriter(BinaryWriter binaryWriter)
         public void Write(BuildEventArgs e)
         {
             // reset the temp stream (in case last usage forgot to do so).
-            this.currentRecordStream.SetLength(0);
+            currentRecordStream.SetLength(0);
             BinaryLogRecordKind eventKind = WriteCore(e);
 
             FlushRecordToFinalStream(eventKind, currentRecordStream);
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs b/src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs
index aee71562898..fdda46571c9 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs
@@ -20,7 +20,7 @@ public interface IBuildEventArgsReaderNotifications
         /// <summary>
         /// An event that allows the caller to be notified when an embedded file is encountered in the binary log.
         /// When subscriber is OK with greedy reading entire content of the file and is interested only in the individual strings (e.g. for sensitive data redaction purposes),
-        ///  it can simplify subscribing to this event, by using handler with same signature as handler for <see cref="IBuildEventArgsReaderNotifications.StringReadDone"/> and wrapping it via
+        ///  it can simplify subscribing to this event, by using handler with same signature as handler for <see cref="StringReadDone"/> and wrapping it via
         /// <see cref="ArchiveFileEventArgsExtensions.ToArchiveFileHandler"/> extension.
         /// </summary>
         /// <example>
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index bfd1d41a51f..84e0bf02c34 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -41,9 +41,9 @@ public void Initialize(IEventSource eventSource, int nodeCount)
         /// </summary>
         private void ParseFileLoggerParameters()
         {
-            if (this.Parameters != null)
+            if (Parameters != null)
             {
-                string[] parameterComponents = this.Parameters.Split(s_fileLoggerParameterDelimiters);
+                string[] parameterComponents = Parameters.Split(s_fileLoggerParameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
diff --git a/src/Build/Logging/LogFormatter.cs b/src/Build/Logging/LogFormatter.cs
index 22c0ab05658..f04c0db100c 100644
--- a/src/Build/Logging/LogFormatter.cs
+++ b/src/Build/Logging/LogFormatter.cs
@@ -50,7 +50,7 @@ internal static string FormatTimeSpan(TimeSpan t)
         {
             string rawTime = t.ToString(); // Timespan is a value type and can't be null.
             int rawTimeLength = rawTime.Length;
-            int prettyLength = System.Math.Min(11, rawTimeLength);
+            int prettyLength = Math.Min(11, rawTimeLength);
             return rawTime.Substring(0, prettyLength);
         }
     }
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index 9b4e34e5c34..bb1156b9658 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -163,7 +163,7 @@ internal IForwardingLogger CreateForwardingLogger()
                 // Check if the class was not found in the assembly
                 if (forwardingLogger == null)
                 {
-                    InternalLoggerException.Throw(null, null, "LoggerNotFoundError", true, this.Name);
+                    InternalLoggerException.Throw(null, null, "LoggerNotFoundError", true, Name);
                 }
             }
             catch (Exception e) // Wrap other exceptions in a more meaningful exception. LoggerException and InternalLoggerException are already meaningful.
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 9e2368df650..9bb369f7334 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -268,7 +268,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
 
             // Show the performance summary if the verbosity is diagnostic or the user specifically asked for it
             // with a logger parameter.
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 ShowPerfSummary();
             }
@@ -517,7 +517,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
             // Add the project to the BuildManager so we can use the start information later in the build process
             _buildEventManager.AddProjectStartedEvent(e, _showTimeStamp || IsVerbosityAtLeast(LoggerVerbosity.Detailed));
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 // Create a new project performance counter for this project
                 MPPerformanceCounter counter = GetPerformanceCounter(e.ProjectFile, ref projectPerformanceCounters);
@@ -532,7 +532,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                     foreach (BuildMessageEventArgs message in deferredMessages)
                     {
                         // This will display the project started event before the messages is shown
-                        this.MessageHandler(sender, message);
+                        MessageHandler(sender, message);
                     }
                 }
                 _deferredMessages.Remove(e.BuildEventContext);
@@ -657,7 +657,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
             ProjectStartedEventMinimumFields startedEvent = _buildEventManager.GetProjectStartedEvent(e.BuildEventContext);
             ErrorUtilities.VerifyThrow(startedEvent != null, "Project finished event for {0} received without matching start event", e.ProjectFile);
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 // Stop the performance counter which was created in the project started event handler
                 MPPerformanceCounter counter = GetPerformanceCounter(e.ProjectFile, ref projectPerformanceCounters);
@@ -847,7 +847,7 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
             // later in the build
             _buildEventManager.AddTargetStartedEvent(e, _showTimeStamp || IsVerbosityAtLeast(LoggerVerbosity.Detailed));
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 // Create a new performance counter for this target
                 MPPerformanceCounter counter = GetPerformanceCounter(e.TargetName, ref targetPerformanceCounters);
@@ -864,7 +864,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 // Stop the performance counter started in the targetStartedEventHandler
                 MPPerformanceCounter counter = GetPerformanceCounter(e.TargetName, ref targetPerformanceCounters);
@@ -960,7 +960,7 @@ public override void TaskStartedHandler(object sender, TaskStartedEventArgs e)
                 ShownBuildEventContext(e.BuildEventContext);
             }
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 // Create a new performance counter for this task
                 MPPerformanceCounter counter = GetPerformanceCounter(e.TaskName, ref taskPerformanceCounters);
@@ -976,7 +976,7 @@ public override void TaskStartedHandler(object sender, TaskStartedEventArgs e)
         public override void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 // Stop the task performance counter which was started in the task started event
                 MPPerformanceCounter counter = GetPerformanceCounter(e.TaskName, ref taskPerformanceCounters);
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index b066b31fea4..11065a0ae46 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -514,7 +514,7 @@ internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent, bo
             _targetName = startedEvent.TargetName;
             _targetFile = startedEvent.TargetFile;
             _projectFile = startedEvent.ProjectFile;
-            this.ShowTargetFinishedEvent = false;
+            ShowTargetFinishedEvent = false;
             _errorInTarget = false;
             _message = startedEvent.Message;
             _buildEventContext = startedEvent.BuildEventContext;
@@ -628,7 +628,7 @@ public string ToString(LoggerVerbosity verbosity)
 
             if (verbosity > LoggerVerbosity.Normal)
             {
-                fullProjectKey = this.ToString();
+                fullProjectKey = ToString();
             }
             else
             {
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index 85f659336d8..bb5732002a8 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -289,7 +289,7 @@ private void GenerateProfilerReport()
 
                 // If the extension of the file is 'md', markdown content is produced. For any other case,
                 // a tab separated format is generated
-                var content = System.IO.Path.GetExtension(FileToLog) == ".md"
+                var content = Path.GetExtension(FileToLog) == ".md"
                     ? ProfilerResultPrettyPrinter.GetMarkdownContent(GetAggregatedResult())
                     : ProfilerResultPrettyPrinter.GetTsvContent(GetAggregatedResult());
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index ebd8c4520ea..30ff29cd68c 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -123,7 +123,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         {
             // Show the performance summary if the verbosity is diagnostic or the user specifically asked for it
             // with a logger parameter.
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 ShowPerfSummary();
             }
@@ -225,7 +225,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
         {
             if (!contextStack.IsEmpty())
             {
-                this.VerifyStack(contextStack.Peek().type == FrameType.Target, "Bad stack -- Top is project {0}", contextStack.Peek().ID);
+                VerifyStack(contextStack.Peek().type == FrameType.Target, "Bad stack -- Top is project {0}", contextStack.Peek().ID);
             }
 
             // if verbosity is normal, detailed or diagnostic
@@ -236,12 +236,12 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 // check for stack corruption
                 if (!contextStack.IsEmpty())
                 {
-                    this.VerifyStack(contextStack.Peek().type == FrameType.Target, "Bad stack -- Top is target {0}", contextStack.Peek().ID);
+                    VerifyStack(contextStack.Peek().type == FrameType.Target, "Bad stack -- Top is target {0}", contextStack.Peek().ID);
                 }
 
                 contextStack.Push(new Frame(FrameType.Project,
                                             false, // message not yet displayed
-                                            this.currentIndentLevel,
+                                            currentIndentLevel,
                                             e.ProjectFile,
                                             e.TargetNames,
                                             null,
@@ -252,14 +252,14 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
             {
                 contextStack.Push(new Frame(FrameType.Project,
                                             false, // message not yet displayed
-                                            this.currentIndentLevel,
+                                            currentIndentLevel,
                                             e.ProjectFile,
                                             e.TargetNames,
                                             null,
                                             GetCurrentlyBuildingProjectFile()));
             }
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 PerformanceCounter counter = GetPerformanceCounter(e.ProjectFile, ref projectPerformanceCounters);
 
@@ -290,7 +290,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
         /// <param name="e">event arguments</param>
         public override void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e)
         {
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 PerformanceCounter counter = GetPerformanceCounter(e.ProjectFile, ref projectPerformanceCounters);
 
@@ -317,8 +317,8 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
 
             Frame top = contextStack.Pop();
 
-            this.VerifyStack(top.type == FrameType.Project, "Unexpected project frame {0}", top.ID);
-            this.VerifyStack(top.ID == e.ProjectFile, "Project frame {0} expected, but was {1}.", e.ProjectFile, top.ID);
+            VerifyStack(top.type == FrameType.Project, "Unexpected project frame {0}", top.ID);
+            VerifyStack(top.ID == e.ProjectFile, "Project frame {0} expected, but was {1}.", e.ProjectFile, top.ID);
         }
 
         /// <summary>
@@ -330,7 +330,7 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
         {
             contextStack.Push(new Frame(FrameType.Target,
                                         false,
-                                        this.currentIndentLevel,
+                                        currentIndentLevel,
                                         e.TargetName,
                                         null,
                                         e.TargetFile,
@@ -342,7 +342,7 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
                 WriteTargetStarted();
             }
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 PerformanceCounter counter = GetPerformanceCounter(e.TargetName, ref targetPerformanceCounters);
 
@@ -352,7 +352,7 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
 
             // Bump up the overall number of indents, so that anything within this target will show up
             // indented.
-            this.currentIndentLevel++;
+            currentIndentLevel++;
         }
 
         /// <summary>
@@ -363,9 +363,9 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
         public override void TargetFinishedHandler(object sender, TargetFinishedEventArgs e)
         {
             // Done with the target, so shift everything left again.
-            this.currentIndentLevel--;
+            currentIndentLevel--;
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 PerformanceCounter counter = GetPerformanceCounter(e.TargetName, ref targetPerformanceCounters);
 
@@ -401,8 +401,8 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
             }
 
             Frame top = contextStack.Pop();
-            this.VerifyStack(top.type == FrameType.Target, "bad stack frame type");
-            this.VerifyStack(top.ID == e.TargetName, "bad stack frame id");
+            VerifyStack(top.type == FrameType.Target, "bad stack frame type");
+            VerifyStack(top.ID == e.TargetName, "bad stack frame id");
 
             // set the value on the Project frame, for the ProjectFinished handler
             if (targetHasErrorsOrWarnings)
@@ -426,7 +426,7 @@ public override void TaskStartedHandler(object sender, TaskStartedEventArgs e)
                 resetColor();
             }
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 PerformanceCounter counter = GetPerformanceCounter(e.TaskName, ref taskPerformanceCounters);
 
@@ -436,7 +436,7 @@ public override void TaskStartedHandler(object sender, TaskStartedEventArgs e)
 
             // Bump up the overall number of indents, so that anything within this task will show up
             // indented.
-            this.currentIndentLevel++;
+            currentIndentLevel++;
         }
 
         /// <summary>
@@ -447,9 +447,9 @@ public override void TaskStartedHandler(object sender, TaskStartedEventArgs e)
         public override void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         {
             // Done with the task, so shift everything left again.
-            this.currentIndentLevel--;
+            currentIndentLevel--;
 
-            if (this.showPerfSummary)
+            if (showPerfSummary)
             {
                 PerformanceCounter counter = GetPerformanceCounter(e.TaskName, ref taskPerformanceCounters);
 
@@ -598,19 +598,19 @@ public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
         /// </summary>
         internal void WriteProjectStarted()
         {
-            this.VerifyStack(!contextStack.IsEmpty(), "Bad project stack");
+            VerifyStack(!contextStack.IsEmpty(), "Bad project stack");
 
             // Pop the current project
             Frame outerMost = contextStack.Pop();
 
-            this.VerifyStack(!outerMost.displayed, "Bad project stack on {0}", outerMost.ID);
-            this.VerifyStack(outerMost.type == FrameType.Project, "Bad project stack");
+            VerifyStack(!outerMost.displayed, "Bad project stack on {0}", outerMost.ID);
+            VerifyStack(outerMost.type == FrameType.Project, "Bad project stack");
 
             outerMost.displayed = true;
             contextStack.Push(outerMost);
 
             WriteProjectStartedText(outerMost.ID, outerMost.targetNames, outerMost.parentProjectFile,
-                this.IsVerbosityAtLeast(LoggerVerbosity.Normal) ? outerMost.indentLevel : 0);
+                IsVerbosityAtLeast(LoggerVerbosity.Normal) ? outerMost.indentLevel : 0);
         }
 
         /// <summary>
@@ -626,7 +626,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
             {
                 setColor(ConsoleColor.Cyan);
 
-                this.VerifyStack(current != null, "Unexpected null project stack");
+                VerifyStack(current != null, "Unexpected null project stack");
 
                 WriteLinePretty(projectSeparatorLine);
 
@@ -671,13 +671,13 @@ private void WriteTargetStarted()
 
             setColor(ConsoleColor.Cyan);
 
-            if (this.Verbosity == LoggerVerbosity.Diagnostic)
+            if (Verbosity == LoggerVerbosity.Diagnostic)
             {
                 WriteLinePrettyFromResource(f.indentLevel, "TargetStartedFromFile", f.ID, f.file);
             }
             else
             {
-                WriteLinePrettyFromResource(this.IsVerbosityAtLeast(LoggerVerbosity.Normal) ? f.indentLevel : 0,
+                WriteLinePrettyFromResource(IsVerbosityAtLeast(LoggerVerbosity.Normal) ? f.indentLevel : 0,
                     "TargetStartedPrefix", f.ID);
             }
 
@@ -750,7 +750,7 @@ private void ShowDeferredMessages()
                         // we're at a higher verbosity, we can assume that all
                         // targets have already be printed.  If we're at lower
                         // verbosity we don't need to print at all.
-                        ErrorUtilities.VerifyThrow(this.Verbosity < LoggerVerbosity.Detailed,
+                        ErrorUtilities.VerifyThrow(Verbosity < LoggerVerbosity.Detailed,
                             "This target should have already been printed at a higher verbosity.");
 
                         if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
index 5b248afd5e7..5251070e70a 100644
--- a/src/Build/Logging/SimpleErrorLogger.cs
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -25,7 +25,7 @@ public sealed class SimpleErrorLogger : INodeLogger
         private readonly uint? originalConsoleMode;
         public SimpleErrorLogger()
         {
-            (acceptAnsiColorCodes, _, originalConsoleMode) = NativeMethods.QueryIsScreenAndTryEnableAnsiColorCodes(NativeMethods.StreamHandleType.StdErr);
+            (acceptAnsiColorCodes, _, originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes(NativeMethodsShared.StreamHandleType.StdErr);
         }
 
         public bool HasLoggedErrors { get; private set; } = false;
@@ -86,7 +86,7 @@ public void Initialize(IEventSource eventSource)
 
         public void Shutdown()
         {
-            NativeMethods.RestoreConsoleMode(originalConsoleMode, NativeMethods.StreamHandleType.StdErr);
+            NativeMethodsShared.RestoreConsoleMode(originalConsoleMode, NativeMethodsShared.StreamHandleType.StdErr);
         }
     }
 }
diff --git a/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs b/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
index 4661130b4c8..cc30b8171e4 100644
--- a/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
@@ -75,6 +75,6 @@ public override string ToString() =>
 
     public override int GetHashCode()
     {
-        throw new System.NotImplementedException();
+        throw new NotImplementedException();
     }
 }
diff --git a/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementLink.cs b/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementLink.cs
index ea54456f041..38b47ecb4d6 100644
--- a/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementLink.cs
+++ b/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectElementLink.cs
@@ -158,9 +158,9 @@ public struct XmlAttributeLink
     {
         public XmlAttributeLink(string localName, string value, string namespaceUri)
         {
-            this.LocalName = localName;
-            this.Value = value;
-            this.NamespaceURI = namespaceUri;
+            LocalName = localName;
+            Value = value;
+            NamespaceURI = namespaceUri;
         }
 
         public string LocalName { get; }
diff --git a/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectUsingTaskParameterElementLink.cs b/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectUsingTaskParameterElementLink.cs
index 7f56973cba1..45bc765e67b 100644
--- a/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectUsingTaskParameterElementLink.cs
+++ b/src/Build/ObjectModelRemoting/ConstructionObjectLinks/ProjectUsingTaskParameterElementLink.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.ObjectModelRemoting
     public abstract class ProjectUsingTaskParameterElementLink : ProjectElementLink
     {
         /// <summary>
-        /// Access to remote <see cref="ProjectUsingTaskParameterElementLink.Name"/>.
+        /// Access to remote <see cref="Name"/>.
         /// </summary>
         public abstract string Name { get; set; }
     }
diff --git a/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs b/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
index 24cd5b9ed0e..02616585d93 100644
--- a/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
+++ b/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
@@ -2,11 +2,11 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
 using System.Linq;
 using System.Text.Json;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
-using System.IO;
 
 namespace Microsoft.Build.TelemetryInfra;
 
@@ -14,7 +14,7 @@ internal sealed class InternalTelemetryConsumingLogger : ILogger
 {
     public LoggerVerbosity Verbosity { get; set; }
     public string? Parameters { get; set; }
-    internal static event Action<WorkerNodeTelemetryData>? TestOnly_InternalTelemetryAggregted; 
+    internal static event Action<WorkerNodeTelemetryData>? TestOnly_InternalTelemetryAggregted;
 
     public void Initialize(IEventSource eventSource)
     {
diff --git a/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs b/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
index b3522dbf64a..1d8871cbe9d 100644
--- a/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
+++ b/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
@@ -74,7 +74,7 @@ private static TaskOrTargetTelemetryKey GetKey(string name, bool isCustom, bool
         public void FinalizeProcessing(LoggingContext loggingContext)
         {
             WorkerNodeTelemetryEventArgs telemetryArgs = new(_workerNodeTelemetryData)
-                { BuildEventContext = loggingContext.BuildEventContext };
+            { BuildEventContext = loggingContext.BuildEventContext };
             loggingContext.LogBuildEvent(telemetryArgs);
         }
     }
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index e555da0aae3..41b4af4a7e4 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -184,7 +184,7 @@ internal static void VerifyThrowProjectAttributes(XmlElementWithLocation element
         {
             foreach (XmlAttributeWithLocation attribute in element.Attributes)
             {
-                ProjectXmlUtilities.VerifyThrowProjectInvalidAttribute(validAttributes.Contains(attribute.Name), attribute);
+                VerifyThrowProjectInvalidAttribute(validAttributes.Contains(attribute.Name), attribute);
             }
         }
 
diff --git a/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
index a02eb1847c7..8315825e862 100644
--- a/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
+++ b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
@@ -1,11 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Xunit;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using System;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Shouldly;
-using System;
+using Xunit;
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
diff --git a/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
index 8033a91064b..6de3c3f6432 100644
--- a/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
+++ b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
@@ -2,8 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Shouldly;
 using Xunit;
 
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
index 53b7ba1b7b3..776109be948 100644
--- a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -5,8 +5,8 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 4b5a516e649..5fbc51d7a55 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -177,7 +177,7 @@ private EmbedResourceTestOutput RunEmbeddedResourceTest(string resourceXmlToAdd,
         string[] depsFiles = Directory.GetFiles(Path.Combine(workFolder.Path, entryProjectName), $"{entryProjectName}.deps.json", SearchOption.AllDirectories);
         depsFiles.Length.ShouldBe(1);
 
-        JsonNode? depsJson = JsonObject.Parse(File.ReadAllText(depsFiles[0]));
+        JsonNode? depsJson = JsonNode.Parse(File.ReadAllText(depsFiles[0]));
 
         depsJson.ShouldNotBeNull("Valid deps.json file expected");
 
diff --git a/src/Framework.UnitTests/FileClassifier_Tests.cs b/src/Framework.UnitTests/FileClassifier_Tests.cs
index b0441062a44..409263abf8c 100644
--- a/src/Framework.UnitTests/FileClassifier_Tests.cs
+++ b/src/Framework.UnitTests/FileClassifier_Tests.cs
@@ -15,7 +15,7 @@ public class FileClassifierTests
         private sealed class FileClassifierUnderTest : FileClassifier
         {
             public void RegisterImmutableDirectory(string directory)
-                => base.RegisterImmutableDirectory(directory, false);
+                => RegisterImmutableDirectory(directory, false);
         }
 
         [Fact]
diff --git a/src/Framework.UnitTests/OperatingSystem_Tests.cs b/src/Framework.UnitTests/OperatingSystem_Tests.cs
index 4fbaf7af615..c20a288ad80 100644
--- a/src/Framework.UnitTests/OperatingSystem_Tests.cs
+++ b/src/Framework.UnitTests/OperatingSystem_Tests.cs
@@ -17,7 +17,7 @@ public class OperatingSystem_Tests
         [InlineData("macOS", false)]
         public void IsOSPlatform(string platform, bool expected)
         {
-            Microsoft.Build.Framework.OperatingSystem.IsOSPlatform(platform).ShouldBe(expected);
+            OperatingSystem.IsOSPlatform(platform).ShouldBe(expected);
         }
 
         [WindowsFullFrameworkOnlyTheory]
@@ -27,30 +27,30 @@ public void IsOSPlatform(string platform, bool expected)
         [InlineData("macOS", 0, false)]
         public void IsOSPlatformVersionAtLeast(string platform, int major, bool expected)
         {
-            Microsoft.Build.Framework.OperatingSystem.IsOSPlatformVersionAtLeast(platform, major).ShouldBe(expected);
+            OperatingSystem.IsOSPlatformVersionAtLeast(platform, major).ShouldBe(expected);
         }
 
         [WindowsFullFrameworkOnlyFact]
         public void IsWindows()
         {
-            Microsoft.Build.Framework.OperatingSystem.IsWindows().ShouldBeTrue();
+            OperatingSystem.IsWindows().ShouldBeTrue();
         }
 
         [WindowsFullFrameworkOnlyFact]
         public void IsWindowsVersionAtLeast()
         {
-            Microsoft.Build.Framework.OperatingSystem.IsWindowsVersionAtLeast(4).ShouldBeTrue();
-            Microsoft.Build.Framework.OperatingSystem.IsWindowsVersionAtLeast(999).ShouldBeFalse();
+            OperatingSystem.IsWindowsVersionAtLeast(4).ShouldBeTrue();
+            OperatingSystem.IsWindowsVersionAtLeast(999).ShouldBeFalse();
         }
 
         [WindowsFullFrameworkOnlyFact]
         public void IsOtherThanWindows()
         {
-            Microsoft.Build.Framework.OperatingSystem.IsFreeBSD().ShouldBeFalse();
-            Microsoft.Build.Framework.OperatingSystem.IsFreeBSDVersionAtLeast(0).ShouldBeFalse();
-            Microsoft.Build.Framework.OperatingSystem.IsLinux().ShouldBeFalse();
-            Microsoft.Build.Framework.OperatingSystem.IsMacOS().ShouldBeFalse();
-            Microsoft.Build.Framework.OperatingSystem.IsMacOSVersionAtLeast(0).ShouldBeFalse();
+            OperatingSystem.IsFreeBSD().ShouldBeFalse();
+            OperatingSystem.IsFreeBSDVersionAtLeast(0).ShouldBeFalse();
+            OperatingSystem.IsLinux().ShouldBeFalse();
+            OperatingSystem.IsMacOS().ShouldBeFalse();
+            OperatingSystem.IsMacOSVersionAtLeast(0).ShouldBeFalse();
         }
 #endif
     }
diff --git a/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs b/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
index 57d822d7194..941f69379c9 100644
--- a/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
@@ -1,4 +1,4 @@
-﻿﻿// Licensed to the .NET Foundation under one or more agreements.
+﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index 5eb6e996a6e..251bf2f98b5 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -152,7 +152,7 @@ private static void Initialize()
 
         private static Assembly GetEntryAssembly()
         {
-            return System.Reflection.Assembly.GetEntryAssembly();
+            return Assembly.GetEntryAssembly();
         }
 
 #if !FEATURE_CULTUREINFO_GETCULTURES
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index c302b537038..ea3a4d2ca71 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -392,7 +392,7 @@ public void Translate<T, L>(ref ICollection<T> collection, ObjectTranslator<T> o
             public void Translate(ref DateTime value)
             {
                 DateTimeKind kind = DateTimeKind.Unspecified;
-                TranslateEnum<DateTimeKind>(ref kind, 0);
+                TranslateEnum(ref kind, 0);
                 value = new DateTime(_reader.ReadInt64(), kind);
             }
 
@@ -404,7 +404,7 @@ public void Translate(ref TimeSpan value)
             {
                 long ticks = 0;
                 Translate(ref ticks);
-                value = new System.TimeSpan(ticks);
+                value = new TimeSpan(ticks);
             }
 
             // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.
@@ -1110,7 +1110,7 @@ public void Translate<T, L>(ref ICollection<T> collection, ObjectTranslator<T> o
             public void Translate(ref DateTime value)
             {
                 DateTimeKind kind = value.Kind;
-                TranslateEnum<DateTimeKind>(ref kind, (int)kind);
+                TranslateEnum(ref kind, (int)kind);
                 _writer.Write(value.Ticks);
             }
 
diff --git a/src/Framework/BuildCheck/EnumerableExtensions.cs b/src/Framework/BuildCheck/EnumerableExtensions.cs
index d74136269d9..ea8c4d73f47 100644
--- a/src/Framework/BuildCheck/EnumerableExtensions.cs
+++ b/src/Framework/BuildCheck/EnumerableExtensions.cs
@@ -36,7 +36,7 @@ public static HashSet<T> NewHashSet<T>(int capacity)
         => NewHashSet<T>(capacity, null);
 
     public static HashSet<T> NewHashSet<T>(IEqualityComparer<T> equalityComparer)
-        => NewHashSet<T>(0, equalityComparer);
+        => NewHashSet(0, equalityComparer);
 
     public static HashSet<T> NewHashSet<T>(int capacity, IEqualityComparer<T>? equalityComparer)
     {
diff --git a/src/Framework/BuildException/BuildExceptionBase.cs b/src/Framework/BuildException/BuildExceptionBase.cs
index b165050d341..67ffa2dde9d 100644
--- a/src/Framework/BuildException/BuildExceptionBase.cs
+++ b/src/Framework/BuildException/BuildExceptionBase.cs
@@ -63,7 +63,7 @@ private void InitializeFromRemoteState(BuildExceptionRemoteState remoteState)
         _remoteStackTrace = remoteState.RemoteStackTrace;
         base.Source = remoteState.Source;
         base.HelpLink = remoteState.HelpLink;
-        base.HResult = remoteState.HResult;
+        HResult = remoteState.HResult;
         if (remoteState.Source != null)
         {
             InitializeCustomState(remoteState.CustomKeyedSerializedData);
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 8e58f93835c..c2d8343bfe8 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -131,12 +131,12 @@ internal static void ApplyChangeWave()
             if (string.IsNullOrEmpty(msbuildDisableFeaturesFromVersion))
             {
                 ConversionState = ChangeWaveConversionState.Valid;
-                _cachedWave = ChangeWaves.EnableAllFeatures;
+                _cachedWave = EnableAllFeatures;
             }
             else if (!TryParseVersion(msbuildDisableFeaturesFromVersion, out _cachedWave))
             {
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
-                _cachedWave = ChangeWaves.EnableAllFeatures;
+                _cachedWave = EnableAllFeatures;
             }
             else if (_cachedWave == EnableAllFeatures || AllWaves.Contains(_cachedWave))
             {
diff --git a/src/Framework/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
index 342e07d3d67..c88a4c774ef 100644
--- a/src/Framework/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -223,10 +223,10 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
         {
             if (!NativeMethods.IsWindows)
             {
-                return EncodingUtilities.Utf8WithoutBom;
+                return Utf8WithoutBom;
             }
 
-            var defaultEncoding = EncodingUtilities.CurrentSystemOemEncoding;
+            var defaultEncoding = CurrentSystemOemEncoding;
 
             // When Windows is configured to use UTF-8 by default, the above returns
             // a UTF-8-with-BOM encoding, which cmd.exe can't interpret. Force the no-BOM
@@ -234,23 +234,23 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
             // See https://github.com/dotnet/msbuild/issues/4268
             if (defaultEncoding is UTF8Encoding e && e.GetPreamble().Length > 0)
             {
-                defaultEncoding = EncodingUtilities.Utf8WithoutBom;
+                defaultEncoding = Utf8WithoutBom;
             }
 
-            string useUtf8 = string.IsNullOrEmpty(encodingSpecification) ? EncodingUtilities.UseUtf8Detect : encodingSpecification;
+            string useUtf8 = string.IsNullOrEmpty(encodingSpecification) ? UseUtf8Detect : encodingSpecification;
 
             switch (useUtf8.ToUpperInvariant())
             {
-                case EncodingUtilities.UseUtf8Always:
-                case EncodingUtilities.UseUtf8True:
-                    return EncodingUtilities.Utf8WithoutBom;
-                case EncodingUtilities.UseUtf8Never:
-                case EncodingUtilities.UseUtf8System:
+                case UseUtf8Always:
+                case UseUtf8True:
+                    return Utf8WithoutBom;
+                case UseUtf8Never:
+                case UseUtf8System:
                     return defaultEncoding;
                 default:
-                    return EncodingUtilities.CanEncodeString(defaultEncoding.CodePage, contents)
+                    return CanEncodeString(defaultEncoding.CodePage, contents)
                         ? defaultEncoding
-                        : EncodingUtilities.Utf8WithoutBom;
+                        : Utf8WithoutBom;
             }
         }
 #nullable enable
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 5cb00f9a8b2..b38a3d5a214 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -109,7 +109,7 @@ internal override void WriteToStream(BinaryWriter writer)
             object? argsOrMessage = argumentsOrFormattedMessage;
             if (argsOrMessage is object[] arguments && arguments.Length > 0)
             {
-                base.WriteToStreamWithExplicitMessage(writer, base.Message);
+                WriteToStreamWithExplicitMessage(writer, base.Message);
                 writer.Write(arguments.Length);
 
                 foreach (object argument in arguments)
@@ -132,7 +132,7 @@ internal override void WriteToStream(BinaryWriter writer)
             }
             else
             {
-                base.WriteToStreamWithExplicitMessage(writer, (argsOrMessage is string formattedMessage) ? formattedMessage : base.Message);
+                WriteToStreamWithExplicitMessage(writer, (argsOrMessage is string formattedMessage) ? formattedMessage : base.Message);
                 writer.Write(-1);
             }
         }
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index 1d36dbdd09d..9bf40ba1a84 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -99,7 +99,7 @@ protected LoggerException(SerializationInfo info, StreamingContext context)
         /// <param name="info">Serialization info</param>
         /// <param name="context">Streaming context</param>
 #if FEATURE_SECURITY_PERMISSIONS
-        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
 #endif
 #if NET8_0_OR_GREATER
         [Obsolete(DiagnosticId = "SYSLIB0051")]
diff --git a/src/Framework/MetaProjectGeneratedEventArgs.cs b/src/Framework/MetaProjectGeneratedEventArgs.cs
index 1a529ed7171..e96089197e8 100644
--- a/src/Framework/MetaProjectGeneratedEventArgs.cs
+++ b/src/Framework/MetaProjectGeneratedEventArgs.cs
@@ -2,8 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.Shared;
 using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -27,7 +27,7 @@ public MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPa
             : base(message, null, null, MessageImportance.Low, DateTime.UtcNow, metaprojectPath)
         {
             this.metaprojectXml = metaprojectXml;
-            this.ProjectFile = metaprojectPath;
+            ProjectFile = metaprojectPath;
         }
 
         internal override void WriteToStream(BinaryWriter writer)
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index ebd415b9e3c..68c2aade48a 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -1188,9 +1188,9 @@ DateTime LastWriteFileUtcTime(string path)
                 }
 
                 WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                bool success = NativeMethods.GetFileAttributesEx(path, 0, ref data);
+                bool success = GetFileAttributesEx(path, 0, ref data);
 
-                if (success && (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0)
+                if (success && (data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                 {
                     long dt = ((long)(data.ftLastWriteTimeHigh) << 32) | ((long)data.ftLastWriteTimeLow);
                     fileModifiedTime = DateTime.FromFileTimeUtc(dt);
@@ -1390,7 +1390,7 @@ internal static int GetParentProcessId(int processId)
                 // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
                 // and could be again when FileUtilities moves to Framework
 
-                using var fileStream = new FileStream($"/proc/{processId}/stat", FileMode.Open, System.IO.FileAccess.Read);
+                using var fileStream = new FileStream($"/proc/{processId}/stat", FileMode.Open, FileAccess.Read);
                 using StreamReader r = new(fileStream);
 
                 line = r.ReadLine();
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index b4ce0636725..2b4fdd1cffb 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -185,45 +185,45 @@ public EvaluationLocation(EvaluationPass evaluationPass, string evaluationPassDe
         /// <nodoc/>
         public readonly EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
         {
-            return new EvaluationLocation(this.Id, evaluationPass, passDescription ?? PassDefaultDescription[evaluationPass],
-                this.File, this.Line, this.ElementName, this.ElementDescription, this.Kind);
+            return new EvaluationLocation(Id, evaluationPass, passDescription ?? PassDefaultDescription[evaluationPass],
+                File, Line, ElementName, ElementDescription, Kind);
         }
 
         /// <nodoc/>
         public EvaluationLocation WithParentId(long? parentId)
         {
             // Simple optimization. If the new parent id is the same as the current one, then we just return this
-            if (parentId == this.ParentId)
+            if (parentId == ParentId)
             {
                 return this;
             }
 
-            return new EvaluationLocation(this.Id, parentId, this.EvaluationPass, this.EvaluationPassDescription,
-                this.File, this.Line, this.ElementName, this.ElementDescription, this.Kind);
+            return new EvaluationLocation(Id, parentId, EvaluationPass, EvaluationPassDescription,
+                File, Line, ElementName, ElementDescription, Kind);
         }
 
         /// <nodoc/>
         public EvaluationLocation WithFile(string file)
         {
-            return new EvaluationLocation(this.Id, this.EvaluationPass, this.EvaluationPassDescription, file, null, null, null, this.Kind);
+            return new EvaluationLocation(Id, EvaluationPass, EvaluationPassDescription, file, null, null, null, Kind);
         }
 
         /// <nodoc/>
         public EvaluationLocation WithFileLineAndElement(string file, int? line, IProjectElement element)
         {
-            return CreateLocationForProject(this.Id, this.EvaluationPass, this.EvaluationPassDescription, file, line, element);
+            return CreateLocationForProject(Id, EvaluationPass, EvaluationPassDescription, file, line, element);
         }
 
         /// <nodoc/>
         public EvaluationLocation WithFileLineAndCondition(string file, int? line, string condition)
         {
-            return CreateLocationForCondition(this.Id, this.EvaluationPass, this.EvaluationPassDescription, file, line, condition);
+            return CreateLocationForCondition(Id, EvaluationPass, EvaluationPassDescription, file, line, condition);
         }
 
         /// <nodoc/>
         public EvaluationLocation WithGlob(string globDescription)
         {
-            return CreateLocationForGlob(this.Id, this.EvaluationPass, this.EvaluationPassDescription, this.File, this.Line, globDescription);
+            return CreateLocationForGlob(Id, EvaluationPass, EvaluationPassDescription, File, Line, globDescription);
         }
 
         /// <nodoc/>
@@ -249,7 +249,7 @@ public override bool Equals(object obj)
         public override string ToString()
         {
             return
-                $"{Id}\t{ParentId?.ToString() ?? string.Empty}\t{EvaluationPassDescription ?? string.Empty}\t{File ?? string.Empty}\t{Line?.ToString() ?? string.Empty}\t{ElementName ?? string.Empty}\tDescription:{ElementDescription}\t{this.EvaluationPassDescription}";
+                $"{Id}\t{ParentId?.ToString() ?? string.Empty}\t{EvaluationPassDescription ?? string.Empty}\t{File ?? string.Empty}\t{Line?.ToString() ?? string.Empty}\t{ElementName ?? string.Empty}\tDescription:{ElementDescription}\t{EvaluationPassDescription}";
         }
 
         /// <nodoc/>
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 6033d11cb53..d213e53b718 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -114,8 +114,8 @@ public ProjectStartedEventArgs(
             string? toolsVersion)
             : this(projectId, message, helpKeyword, projectFile, targetNames, properties, items, parentBuildEventContext)
         {
-            this.GlobalProperties = globalProperties;
-            this.ToolsVersion = toolsVersion;
+            GlobalProperties = globalProperties;
+            ToolsVersion = toolsVersion;
         }
 
         /// <summary>
@@ -502,7 +502,7 @@ private static void WriteCollection(BinaryWriter writer, ICollection<string>? co
             else
             {
                 int count = reader.ReadInt32();
-                HashSet<string> set = EnumerableExtensions.NewHashSet<string>(count, StringComparer.OrdinalIgnoreCase);
+                HashSet<string> set = EnumerableExtensions.NewHashSet(count, StringComparer.OrdinalIgnoreCase);
                 for (int i = 0; i < count; i++)
                 {
                     set.Add(reader.ReadString());
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 80691b8860b..41b0c42373a 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -58,7 +58,7 @@
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
 // this assembly.  We should specify this explicitly, as opposed to letting
 // tlbexp just pick whatever it wants.
-[assembly: GuidAttribute("D8A9BA71-4724-481d-9CA7-0DA23A1D615C")]
+[assembly: Guid("D8A9BA71-4724-481d-9CA7-0DA23A1D615C")]
 
 #if FEATURE_XAML_TYPES
 [assembly: XmlnsDefinition("http://schemas.microsoft.com/build/2009/properties", "Microsoft.Build.Framework.XamlTypes")]
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
index fe1e52023b6..53ac2d69574 100644
--- a/src/Framework/PropertyInitialValueSetEventArgs.cs
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -40,9 +40,9 @@ public PropertyInitialValueSetEventArgs(
             MessageImportance importance = MessageImportance.Low)
             : base(message, helpKeyword, senderName, importance)
         {
-            this.PropertyName = propertyName;
-            this.PropertyValue = propertyValue;
-            this.PropertySource = propertySource;
+            PropertyName = propertyName;
+            PropertyValue = propertyValue;
+            PropertySource = propertySource;
         }
 
         /// <summary>
diff --git a/src/Framework/StringBuilderCache.cs b/src/Framework/StringBuilderCache.cs
index 5fd67790e9d..99c7d47a1b1 100644
--- a/src/Framework/StringBuilderCache.cs
+++ b/src/Framework/StringBuilderCache.cs
@@ -41,8 +41,8 @@ public static StringBuilder Acquire(int capacity = 16 /*StringBuilder.DefaultCap
         {
             if (capacity <= MAX_BUILDER_SIZE)
             {
-                StringBuilder sb = StringBuilderCache.t_cachedInstance;
-                StringBuilderCache.t_cachedInstance = null;
+                StringBuilder sb = t_cachedInstance;
+                t_cachedInstance = null;
                 if (sb != null)
                 {
                     // Avoid StringBuilder block fragmentation by getting a new StringBuilder
@@ -89,8 +89,8 @@ public static void Release(StringBuilder sb)
             {
                 // Assert we are not replacing another string builder. That could happen when Acquire is reentered.
                 // User of StringBuilderCache has to make sure that calling method call stacks do not also use StringBuilderCache.
-                Debug.Assert(StringBuilderCache.t_cachedInstance == null, "Unexpected replacing of other StringBuilder.");
-                StringBuilderCache.t_cachedInstance = sb;
+                Debug.Assert(t_cachedInstance == null, "Unexpected replacing of other StringBuilder.");
+                t_cachedInstance = sb;
             }
 #if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
             MSBuildEventSource.Log.ReusableStringBuilderFactoryStop(hash: sb.GetHashCode(), returningCapacity: sb.Capacity, returningLength: sb.Length, type: sb.Capacity <= MAX_BUILDER_SIZE ? "sbc-return" : "sbc-discard");
diff --git a/src/Framework/Telemetry/ActivityExtensions.cs b/src/Framework/Telemetry/ActivityExtensions.cs
index aa10b1a6615..9b4e05f7c02 100644
--- a/src/Framework/Telemetry/ActivityExtensions.cs
+++ b/src/Framework/Telemetry/ActivityExtensions.cs
@@ -1,11 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Security.Cryptography;
-using System.Text;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Security.Cryptography;
+using System.Text;
 
 namespace Microsoft.Build.Framework.Telemetry
 {
diff --git a/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs b/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
index 95e38567587..e6c892a9019 100644
--- a/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
+++ b/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
@@ -22,7 +22,7 @@ public void Initialize(IEventSource eventSource)
     {
         if (BuildEventRedirector != null && eventSource is IEventSource5 eventSource5)
         {
-            eventSource5.WorkerNodeTelemetryLogged += (o,e) => BuildEventRedirector.ForwardEvent(e);
+            eventSource5.WorkerNodeTelemetryLogged += (o, e) => BuildEventRedirector.ForwardEvent(e);
         }
     }
 
diff --git a/src/Framework/Telemetry/TaskExecutionStats.cs b/src/Framework/Telemetry/TaskExecutionStats.cs
index b3f1564d615..866f3526650 100644
--- a/src/Framework/Telemetry/TaskExecutionStats.cs
+++ b/src/Framework/Telemetry/TaskExecutionStats.cs
@@ -31,9 +31,9 @@ internal static TaskExecutionStats CreateEmpty()
 
     internal void AddAnother(TaskExecutionStats another)
     {
-        this.CumulativeExecutionTime += another.CumulativeExecutionTime;
-        this.TotalMemoryConsumption += another.TotalMemoryConsumption;
-        this.ExecutionsCount += another.ExecutionsCount;
+        CumulativeExecutionTime += another.CumulativeExecutionTime;
+        TotalMemoryConsumption += another.TotalMemoryConsumption;
+        ExecutionsCount += another.ExecutionsCount;
     }
 
     // We need custom Equals for easier assertations in tests
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index bcdc4ac195c..f9c06fca7ad 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -401,7 +401,7 @@ public bool? LogPropertiesAndItemsAfterEvaluation
         private SdkReferencePropertyExpansionMode? _sdkReferencePropertyExpansionValue;
 
         /// <summary>
-        /// Overrides the default behavior of property expansion on evaluation of a <see cref="Framework.SdkReference"/>.
+        /// Overrides the default behavior of property expansion on evaluation of a <see cref="SdkReference"/>.
         /// </summary>
         /// <remarks>
         /// Escape hatch for problems arising from https://github.com/dotnet/msbuild/pull/5552.
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
index 7980bdb5485..35bddca61d7 100644
--- a/src/Framework/UninitializedPropertyReadEventArgs.cs
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -37,7 +37,7 @@ public UninitializedPropertyReadEventArgs(
             string senderName = null,
             MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
         {
-            this.PropertyName = propertyName;
+            PropertyName = propertyName;
         }
 
         /// <summary>
diff --git a/src/Framework/XamlTypes/ContentType.cs b/src/Framework/XamlTypes/ContentType.cs
index a3f55e6c143..9c7fea19c2d 100644
--- a/src/Framework/XamlTypes/ContentType.cs
+++ b/src/Framework/XamlTypes/ContentType.cs
@@ -27,10 +27,10 @@ public sealed class ContentType : ISupportInitialize, IProjectSchemaNode
         /// </summary>
         public ContentType()
         {
-            this.Metadata = new List<NameValuePair>();
+            Metadata = new List<NameValuePair>();
 
             // We must use ExecutionAndPublication thread safety here because the initializer is a destructive operation.
-            _metadata = new Lazy<Dictionary<string, string>>(this.InitializeMetadata, System.Threading.LazyThreadSafetyMode.ExecutionAndPublication);
+            _metadata = new Lazy<Dictionary<string, string>>(InitializeMetadata, System.Threading.LazyThreadSafetyMode.ExecutionAndPublication);
         }
 
         /// <summary>
@@ -156,8 +156,8 @@ public IEnumerable<object> GetSchemaObjects(Type type)
         /// </remarks>
         private Dictionary<string, string> InitializeMetadata()
         {
-            var metadata = new Dictionary<string, string>(this.Metadata.Count, StringComparer.OrdinalIgnoreCase);
-            foreach (NameValuePair pair in this.Metadata)
+            var metadata = new Dictionary<string, string>(Metadata.Count, StringComparer.OrdinalIgnoreCase);
+            foreach (NameValuePair pair in Metadata)
             {
                 metadata.Add(pair.Name, pair.Value);
             }
diff --git a/src/Framework/XamlTypes/Rule.cs b/src/Framework/XamlTypes/Rule.cs
index ae225536085..78ddb9216b7 100644
--- a/src/Framework/XamlTypes/Rule.cs
+++ b/src/Framework/XamlTypes/Rule.cs
@@ -167,7 +167,7 @@ public string HelpString
         /// </remarks>
         /// <example>
         /// For the VC++ CL task, <c>WholeProgramOptimization</c> is a boolean parameter. It's switch is <c>GL</c> and its
-        /// switch prefix (inherited from the parent <see cref="Rule.SwitchPrefix"/> since it is not overridden by <c>WholeProgramOptimization</c>)
+        /// switch prefix (inherited from the parent <see cref="SwitchPrefix"/> since it is not overridden by <c>WholeProgramOptimization</c>)
         /// is <c>/</c>. Thus the complete switch in the command line for this property would be <c>/GL</c>
         /// </example>
         public string SwitchPrefix
@@ -494,8 +494,8 @@ public BaseProperty GetProperty(string propertyName)
                 {
                     if (_propertiesByNameMap == null)
                     {
-                        var map = new Dictionary<string, BaseProperty>(this.Properties.Count, StringComparer.OrdinalIgnoreCase);
-                        foreach (var property in this.Properties)
+                        var map = new Dictionary<string, BaseProperty>(Properties.Count, StringComparer.OrdinalIgnoreCase);
+                        foreach (var property in Properties)
                         {
                             map[property.Name] = property;
                         }
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index a749bd7145f..504a7e44caf 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -26,7 +26,7 @@
 
 namespace Microsoft.Build.Engine.UnitTests
 {
-    public class SleepingTask : Microsoft.Build.Utilities.Task
+    public class SleepingTask : Utilities.Task
     {
         public int SleepTime { get; set; }
 
@@ -41,7 +41,7 @@ public override bool Execute()
         }
     }
 
-    public class ProcessIdTask : Microsoft.Build.Utilities.Task
+    public class ProcessIdTask : Utilities.Task
     {
         [Output]
         public int Pid { get; set; }
@@ -110,7 +110,7 @@ public void MSBuildServerTest()
             // Prep to kill the long-lived task we're about to start.
             TransientTestFile markerFile = _env.ExpectFile();
             string? dir = Path.GetDirectoryName(markerFile.Path);
-            using var watcher = new System.IO.FileSystemWatcher(dir!);
+            using var watcher = new FileSystemWatcher(dir!);
             watcher.Created += (o, e) =>
             {
                 _output.WriteLine($"The marker file {markerFile.Path} was created. The build task has been started. Ready to kill the server.");
@@ -191,7 +191,7 @@ public void BuildsWhileBuildIsRunningOnServer()
             _env.WithTransientProcess(pidOfServerProcess);
 
             string? dir = Path.GetDirectoryName(markerFile.Path);
-            using var watcher = new System.IO.FileSystemWatcher(dir!);
+            using var watcher = new FileSystemWatcher(dir!);
             using ManualResetEvent mre = new ManualResetEvent(false);
             watcher.Created += (o, e) =>
             {
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index bc93f3ea4aa..7c3e243e4b3 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -41,7 +41,7 @@ public class XMakeAppTests : IDisposable
         public XMakeAppTests(ITestOutputHelper output)
         {
             _output = output;
-            _env = UnitTests.TestEnvironment.Create(_output);
+            _env = TestEnvironment.Create(_output);
         }
 
         private const string AutoResponseFileName = "MSBuild.rsp";
@@ -2643,7 +2643,7 @@ public override bool Execute()
         [InlineData("/getProperty:p", false)]
         public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMessage)
         {
-            using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
 
             string projectContents = ObjectModelHelpers.CleanupFileContents("""
                                                                             <Project>
@@ -2697,7 +2697,7 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:quiet /tl", MessageImportance.High - 1)]
         public void EndToEndMinimumMessageImportance(string arguments, MessageImportance expectedMinimumMessageImportance)
         {
-            using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
 
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
 
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index fdfd2b36762..7923532594a 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -96,7 +96,7 @@ internal string CommandLineArg
         /// Serialize the contents of the class.
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
-        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
 #endif
 #if NET8_0_OR_GREATER
         [Obsolete(DiagnosticId = "SYSLIB0051")]
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index 4607ec549af..2521abe7014 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -89,7 +89,7 @@ public override string Message
         /// Serialize the contents of the class.
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
-        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
 #endif
 #if NET8_0_OR_GREATER
         [Obsolete(DiagnosticId = "SYSLIB0051")]
@@ -154,7 +154,7 @@ internal static void Throw(string messageResourceName, string invalidSwitch, Exc
                 errorMessage = ResourceUtilities.FormatString(errorMessage, (e == null) ? String.Empty : e.Message);
             }
 
-            InitializationException.Throw(errorMessage, invalidSwitch);
+            Throw(errorMessage, invalidSwitch);
         }
 
         /// <summary>
@@ -170,7 +170,7 @@ internal static void VerifyThrow(bool condition, string messageResourceName, str
 
                 errorMessage = ResourceUtilities.FormatString(errorMessage, args);
 
-                InitializationException.Throw(errorMessage, invalidSwitch);
+                Throw(errorMessage, invalidSwitch);
             }
         }
 
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index 474a0c0984d..d9226d2f61a 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -82,7 +82,7 @@ private void VerifyProjectSchema(
             XmlReaderSettings validatorSettings = new XmlReaderSettings();
             validatorSettings.ValidationType = ValidationType.Schema;
             validatorSettings.XmlResolver = null;
-            validatorSettings.ValidationEventHandler += this.OnSchemaValidationError;
+            validatorSettings.ValidationEventHandler += OnSchemaValidationError;
 
             XmlTextReader schemaReader = new XmlTextReader(schemaFile);
             schemaReader.DtdProcessing = DtdProcessing.Ignore;
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 357cb767e84..bf100e65d58 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1413,8 +1413,8 @@ internal static bool BuildProject(
                 // If the user has requested that the schema be validated, do that here.
                 if (needToValidateProject && !isSolution)
                 {
-                    Microsoft.Build.Evaluation.Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
-                    Microsoft.Build.Evaluation.Toolset toolset = projectCollection.GetToolset(toolsVersion ?? project.ToolsVersion);
+                    Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
+                    Toolset toolset = projectCollection.GetToolset(toolsVersion ?? project.ToolsVersion);
 
                     if (toolset == null)
                     {
@@ -1487,7 +1487,7 @@ internal static bool BuildProject(
                     parameters.MaxNodeCount = cpuCount;
                     parameters.Loggers = projectCollection.Loggers;
                     parameters.ForwardingLoggers = remoteLoggerRecords;
-                    parameters.ToolsetDefinitionLocations = Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile | Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry;
+                    parameters.ToolsetDefinitionLocations = ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry;
                     parameters.DetailedSummary = detailedSummary;
                     parameters.LogTaskInputs = logTaskInputs;
                     parameters.WarningsAsErrors = warningsAsErrors;
@@ -4598,7 +4598,7 @@ private static void DisplayVersionMessageIfNeeded(bool recursing, bool useTermin
 
             if (shouldShowLogo)
             {
-                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("MSBuildVersionMessage", ProjectCollection.DisplayVersion, NativeMethods.FrameworkName));
+                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("MSBuildVersionMessage", ProjectCollection.DisplayVersion, NativeMethodsShared.FrameworkName));
             }
         }
 
diff --git a/src/Samples/TaskUsageLogger/TaskUsageLogger.cs b/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
index f90686a9a3b..b174f9dc676 100644
--- a/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
+++ b/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
@@ -434,7 +434,7 @@ public TaskData(string taskName, string targetName, string filePath, string proj
             public override string ToString()
             {
                 // CSV format
-                return String.Format(CultureInfo.CurrentCulture, "{0}, {1}, {2}, {3}, {4}, {5}", this.TaskName, this.TargetName, this.FilePath, this.ProjectPath, this.TaskAssembly, this.TaskId);
+                return String.Format(CultureInfo.CurrentCulture, "{0}, {1}, {2}, {3}, {4}, {5}", TaskName, TargetName, FilePath, ProjectPath, TaskAssembly, TaskId);
             }
         }
 
diff --git a/src/Samples/XmlFileLogger/PropertyBag.cs b/src/Samples/XmlFileLogger/PropertyBag.cs
index 8ec88b0bdcc..8b5713dc09e 100644
--- a/src/Samples/XmlFileLogger/PropertyBag.cs
+++ b/src/Samples/XmlFileLogger/PropertyBag.cs
@@ -76,7 +76,7 @@ public void AddProperties(IEnumerable<KeyValuePair<string, string>> newPropertie
         /// </summary>
         /// <remarks>If the property is defined and identical in the parent, no action is taken.</remarks>
         /// <param name="newProperties">The new properties.</param>
-        /// <exception cref="System.ArgumentException">newProperties</exception>
+        /// <exception cref="ArgumentException">newProperties</exception>
         public void AddProperties(IEnumerable<DictionaryEntry> newProperties)
         {
             if (newProperties == null)
diff --git a/src/Shared/AssemblyLoadInfo.cs b/src/Shared/AssemblyLoadInfo.cs
index be467ff2a20..d2e763bd0df 100644
--- a/src/Shared/AssemblyLoadInfo.cs
+++ b/src/Shared/AssemblyLoadInfo.cs
@@ -94,7 +94,7 @@ public override bool Equals(Object obj)
                 return false;
             }
 
-            return (this.AssemblyName == otherAssemblyInfo.AssemblyName) && (this.AssemblyFile == otherAssemblyInfo.AssemblyFile);
+            return (AssemblyName == otherAssemblyInfo.AssemblyName) && (AssemblyFile == otherAssemblyInfo.AssemblyFile);
         }
 
         public void Translate(ITranslator translator)
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 12017934f1f..03bc67cfc87 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Shared
     /// <summary>
     /// Specifies the parts of the assembly name to partially match
     /// </summary>
-    [FlagsAttribute]
+    [Flags]
     internal enum PartialComparisonFlags : int
     {
         /// <summary>
@@ -448,7 +448,7 @@ internal int CompareTo(AssemblyNameExtension that)
         internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag)
         {
             // Are they identical?
-            if (this.Equals(that, considerRetargetableFlag))
+            if (Equals(that, considerRetargetableFlag))
             {
                 return 0;
             }
@@ -461,20 +461,20 @@ internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag
             }
 
             // We would like to compare the version numerically rather than alphabetically (because for example version 10.0.0. should be below 9 not between 1 and 2)
-            if (this.Version != that.Version)
+            if (Version != that.Version)
             {
-                if (this.Version == null)
+                if (Version == null)
                 {
                     // This is therefore less than that. Since this is null and that is not null
                     return -1;
                 }
 
                 // Will not return 0 as the this != that check above takes care of the case where they are equal.
-                return this.Version.CompareTo(that.Version);
+                return Version.CompareTo(that.Version);
             }
 
             // We need some final collating order for these, alphabetical by FullName seems as good as any.
-            return string.Compare(this.FullName, that.FullName, StringComparison.OrdinalIgnoreCase);
+            return string.Compare(FullName, that.FullName, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -486,7 +486,7 @@ internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag
             // Ok, so this isn't a great hashing algorithm. However, basenames with different
             // versions or PKTs are relatively uncommon and so collisions should be low.
             // Hashing on FullName is wrong because the order of tuple fields is undefined.
-            int hash = StringComparer.OrdinalIgnoreCase.GetHashCode(this.Name);
+            int hash = StringComparer.OrdinalIgnoreCase.GetHashCode(Name);
             return hash;
         }
 
@@ -548,7 +548,7 @@ private int CompareBaseNameToImpl(AssemblyNameExtension that)
             }
 
             // Fall back to comparing by name. This is the slow path.
-            return string.Compare(this.Name, that.Name, StringComparison.OrdinalIgnoreCase);
+            return string.Compare(Name, that.Name, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -686,7 +686,7 @@ internal bool Equals(AssemblyNameExtension that, bool considerRetargetableFlag)
         private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool considerRetargetableFlag)
         {
             // Pointer compare.
-            if (object.ReferenceEquals(this, that))
+            if (ReferenceEquals(this, that))
             {
                 return true;
             }
@@ -701,7 +701,7 @@ private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool con
             if (asAssemblyName != null && that.asAssemblyName != null)
             {
                 // Pointer compare.
-                if (object.ReferenceEquals(asAssemblyName, that.asAssemblyName))
+                if (ReferenceEquals(asAssemblyName, that.asAssemblyName))
                 {
                     return true;
                 }
@@ -725,7 +725,7 @@ private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool con
                 return false;
             }
 
-            if (!ignoreVersion && (this.Version != that.Version))
+            if (!ignoreVersion && (Version != that.Version))
             {
                 return false;
             }
@@ -740,7 +740,7 @@ private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool con
                 return false;
             }
 
-            if (considerRetargetableFlag && this.Retargetable != that.Retargetable)
+            if (considerRetargetableFlag && Retargetable != that.Retargetable)
             {
                 return false;
             }
@@ -896,7 +896,7 @@ internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFl
         internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag)
         {
             // Pointer compare.
-            if (object.ReferenceEquals(this, that))
+            if (ReferenceEquals(this, that))
             {
                 return true;
             }
@@ -911,7 +911,7 @@ internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFl
             if (asAssemblyName != null && that.asAssemblyName != null)
             {
                 // Pointer compare.
-                if (object.ReferenceEquals(asAssemblyName, that.asAssemblyName))
+                if (ReferenceEquals(asAssemblyName, that.asAssemblyName))
                 {
                     return true;
                 }
@@ -923,7 +923,7 @@ internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFl
                 return false;
             }
 
-            if ((comparisonFlags & PartialComparisonFlags.Version) != 0 && Version != null && this.Version != that.Version)
+            if ((comparisonFlags & PartialComparisonFlags.Version) != 0 && Version != null && Version != that.Version)
             {
                 return false;
             }
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index f864c62bb23..fdef6355f24 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -177,7 +177,7 @@ protected override void QueueTask(Task task)
                     Task t;
                     if (_queuedTasks.TryDequeue(out t))
                     {
-                        base.TryExecuteTask(t);
+                        TryExecuteTask(t);
                     }
                 });
 
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index c3615e4acf6..37c78408772 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -371,8 +371,8 @@ private static string GetMSBuildExeFromVsRoot(string visualStudioRoot)
                 "MSBuild",
                 CurrentToolsVersion,
                 "Bin",
-                NativeMethodsShared.ProcessorArchitecture == Framework.NativeMethods.ProcessorArchitectures.X64 ? "amd64" :
-                NativeMethodsShared.ProcessorArchitecture == Framework.NativeMethods.ProcessorArchitectures.ARM64 ? "arm64" : string.Empty,
+                NativeMethodsShared.ProcessorArchitecture == NativeMethodsShared.ProcessorArchitectures.X64 ? "amd64" :
+                NativeMethodsShared.ProcessorArchitecture == NativeMethodsShared.ProcessorArchitectures.ARM64 ? "arm64" : string.Empty,
                 "MSBuild.exe");
         }
 
@@ -395,7 +395,7 @@ private static bool CheckIfRunningTests()
 
                 // Check if running tests via the TestInfo class in Microsoft.Build.Framework.
                 //  See the comments on the TestInfo class for an explanation of why it works this way.
-                var frameworkAssembly = typeof(Framework.ITask).Assembly;
+                var frameworkAssembly = typeof(ITask).Assembly;
                 var testInfoType = frameworkAssembly.GetType("Microsoft.Build.Framework.TestInfo");
                 var runningTestsField = testInfoType.GetField("s_runningTests", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
 
@@ -551,8 +551,8 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
             VisualStudioInstallRootDirectory = visualStudioPath;
 
 #if !NO_FRAMEWORK_IVT
-            Framework.BuildEnvironmentState.s_runningTests = runningTests;
-            Framework.BuildEnvironmentState.s_runningInVisualStudio = runningInVisualStudio;
+            BuildEnvironmentState.s_runningTests = runningTests;
+            BuildEnvironmentState.s_runningInVisualStudio = runningInVisualStudio;
 #endif
 
             if (!string.IsNullOrEmpty(currentMSBuildExePath))
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index 4c4a8ea96cf..bc89a9901d7 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -220,22 +220,22 @@ internal Parts()
             /// <summary>
             /// The line number.
             /// </summary>
-            internal int line = Parts.numberNotSpecified;
+            internal int line = numberNotSpecified;
 
             /// <summary>
             /// The column number.
             /// </summary>
-            internal int column = Parts.numberNotSpecified;
+            internal int column = numberNotSpecified;
 
             /// <summary>
             /// The ending line number.
             /// </summary>
-            internal int endLine = Parts.numberNotSpecified;
+            internal int endLine = numberNotSpecified;
 
             /// <summary>
             /// The ending column number.
             /// </summary>
-            internal int endColumn = Parts.numberNotSpecified;
+            internal int endColumn = numberNotSpecified;
 
             /// <summary>
             /// The category/severity level
@@ -271,7 +271,7 @@ private static int ConvertToIntWithDefault(string value)
 
             if (!success || (result < 0))
             {
-                result = CanonicalError.Parts.numberNotSpecified;
+                result = Parts.numberNotSpecified;
             }
 
             return result;
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index cb1177fce58..6300d3fec62 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -496,11 +496,11 @@ bool isProvider
             {
                 if (isProvider)
                 {
-                    CommunicationsUtilities.Trace("Handshake failed on part {0}. Probably the client is a different MSBuild build.", valueRead);
+                    Trace("Handshake failed on part {0}. Probably the client is a different MSBuild build.", valueRead);
                 }
                 else
                 {
-                    CommunicationsUtilities.Trace("Expected end of handshake signal but received {0}. Probably the host is a different MSBuild build.", valueRead);
+                    Trace("Expected end of handshake signal but received {0}. Probably the host is a different MSBuild build.", valueRead);
                 }
                 throw new InvalidOperationException();
             }
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 9f1e756baeb..bf7541a61ca 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -160,11 +160,11 @@ internal static double ConvertDecimalOrHexToDouble(string number)
 
         internal static bool TryConvertDecimalOrHexToDouble(string number, out double doubleValue)
         {
-            if (ConversionUtilities.ValidDecimalNumber(number, out doubleValue))
+            if (ValidDecimalNumber(number, out doubleValue))
             {
                 return true;
             }
-            else if (ConversionUtilities.ValidHexNumber(number, out int hexValue))
+            else if (ValidHexNumber(number, out int hexValue))
             {
                 doubleValue = (double)hexValue;
                 return true;
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index c1e3d664d3e..681a3cdbbd5 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -26,7 +26,7 @@ internal sealed class CoreClrAssemblyLoader
 
         private bool _resolvingHandlerHookedUp = false;
 
-        private static readonly Version _currentAssemblyVersion = new Version(Microsoft.Build.Shared.MSBuildConstants.CurrentAssemblyVersion);
+        private static readonly Version _currentAssemblyVersion = new Version(MSBuildConstants.CurrentAssemblyVersion);
 
         public void AddDependencyLocation(string fullPath)
         {
diff --git a/src/Shared/Debugging/PrintLineDebuggerWriters.cs b/src/Shared/Debugging/PrintLineDebuggerWriters.cs
index bcdadc22a24..dbe1f29963b 100644
--- a/src/Shared/Debugging/PrintLineDebuggerWriters.cs
+++ b/src/Shared/Debugging/PrintLineDebuggerWriters.cs
@@ -36,7 +36,7 @@ public sealed class IdBasedFilesWriter
 
             public IdBasedFilesWriter(string logFileRoot)
             {
-                this.LogFileRoot = logFileRoot;
+                LogFileRoot = logFileRoot;
                 Directory.CreateDirectory(logFileRoot);
             }
 
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 16a19dcadc2..8d0c417918a 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -176,7 +176,7 @@ internal static bool IsXmlException(Exception e)
         {
             return e is XmlException
 #if FEATURE_SECURITY_PERMISSIONS
-                || e is System.Security.XmlSyntaxException
+                || e is XmlSyntaxException
 #endif
                 || e is XmlSchemaException
                 || e is UriFormatException; // XmlTextReader for example uses this under the covers
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 9d97c12de8d..6ed52b26321 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -358,7 +358,7 @@ private static IReadOnlyList<string> GetAccessibleFiles(
                 // For code access security.
                 return [];
             }
-            catch (System.UnauthorizedAccessException)
+            catch (UnauthorizedAccessException)
             {
                 // For OS security.
                 return [];
@@ -414,7 +414,7 @@ private static IReadOnlyList<string> GetAccessibleDirectories(
                 // For code access security.
                 return [];
             }
-            catch (System.UnauthorizedAccessException)
+            catch (UnauthorizedAccessException)
             {
                 // For OS security.
                 return [];
@@ -564,7 +564,7 @@ internal void SplitFileSpec(
                 filenamePart = "*.*";
             }
 
-            fixedDirectoryPart = FileMatcher.GetLongPathName(fixedDirectoryPart, _getFileSystemEntries);
+            fixedDirectoryPart = GetLongPathName(fixedDirectoryPart, _getFileSystemEntries);
         }
 
         /// <summary>
@@ -1633,7 +1633,7 @@ internal static bool IsFileNameMatch(string path, string pattern)
         {
             // Use a span-based Path.GetFileName if it is available.
 #if FEATURE_MSIOREDIST
-            return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);
+            return IsMatch(IO.Path.GetFileName(path.AsSpan()), pattern);
 #elif NETSTANDARD2_0 || NETFRAMEWORK
             return IsMatch(Path.GetFileName(path), pattern);
 #else
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index f2223635f80..c5e9dcf0401 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -16,7 +16,7 @@ internal class ManagedFileSystem : IFileSystem
     {
         private static readonly ManagedFileSystem Instance = new ManagedFileSystem();
 
-        public static ManagedFileSystem Singleton() => ManagedFileSystem.Instance;
+        public static ManagedFileSystem Singleton() => Instance;
 
         private static bool ShouldUseMicrosoftIO
         {
@@ -56,10 +56,10 @@ public byte[] ReadFileAllBytes(string path)
 
 #if FEATURE_MSIOREDIST
         private static IEnumerable<string> HandleFileLoadException(
-            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,
+            Func<string, string, IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,
             string path,
             string searchPattern,
-            Microsoft.IO.SearchOption searchOption)
+            IO.SearchOption searchOption)
         {
             try
             {
@@ -85,10 +85,10 @@ public virtual IEnumerable<string> EnumerateFiles(string path, string searchPatt
 #if FEATURE_MSIOREDIST
             return ShouldUseMicrosoftIO
                 ? HandleFileLoadException(
-                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateFiles(path, searchPattern, searchOption),
+                    (path, searchPattern, searchOption) => IO.Directory.EnumerateFiles(path, searchPattern, searchOption),
                     path,
                     searchPattern,
-                    (Microsoft.IO.SearchOption)searchOption)
+                    (IO.SearchOption)searchOption)
                 : Directory.EnumerateFiles(path, searchPattern, searchOption);
 #else
             return Directory.EnumerateFiles(path, searchPattern, searchOption);
@@ -100,10 +100,10 @@ public virtual IEnumerable<string> EnumerateDirectories(string path, string sear
 #if FEATURE_MSIOREDIST
             return ShouldUseMicrosoftIO
                 ? HandleFileLoadException(
-                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateDirectories(path, searchPattern, searchOption),
+                    (path, searchPattern, searchOption) => IO.Directory.EnumerateDirectories(path, searchPattern, searchOption),
                     path,
                     searchPattern,
-                    (Microsoft.IO.SearchOption)searchOption)
+                    (IO.SearchOption)searchOption)
                 : Directory.EnumerateDirectories(path, searchPattern, searchOption);
 #else
             return Directory.EnumerateDirectories(path, searchPattern, searchOption);
@@ -115,9 +115,9 @@ public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, strin
 #if FEATURE_MSIOREDIST
             return ShouldUseMicrosoftIO
                 ? HandleFileLoadException(
-                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption),
+                    (path, searchPattern, searchOption) => IO.Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption),
                     path,
-                    searchPattern, (Microsoft.IO.SearchOption)searchOption)
+                    searchPattern, (IO.SearchOption)searchOption)
                 : Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
 #else
             return Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 1493d0f29a8..a39d268c97a 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -34,7 +34,7 @@ internal sealed class WindowsFileSystem : ManagedFileSystem
     {
         private static readonly WindowsFileSystem Instance = new();
 
-        public static new WindowsFileSystem Singleton() => WindowsFileSystem.Instance;
+        public static new WindowsFileSystem Singleton() => Instance;
 
         private WindowsFileSystem() { }
 
@@ -61,7 +61,7 @@ public override bool DirectoryExists(string path)
         public override bool FileExists(string path)
         {
 #if NETFRAMEWORK
-            return Microsoft.IO.File.Exists(path);
+            return IO.File.Exists(path);
 #else
             return File.Exists(path);
 #endif
diff --git a/src/Shared/FileSystem/WindowsNative.cs b/src/Shared/FileSystem/WindowsNative.cs
index 5bf3f713c17..6d1ff113d81 100644
--- a/src/Shared/FileSystem/WindowsNative.cs
+++ b/src/Shared/FileSystem/WindowsNative.cs
@@ -111,7 +111,7 @@ public enum EnumerateDirectoryStatus
         /// <summary>
         /// Represents the result of attempting to enumerate a directory.
         /// </summary>
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance",
+        [SuppressMessage("Microsoft.Performance",
             "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes")]
         public struct EnumerateDirectoryResult
         {
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 458272bcc30..1f45fd00e6c 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -1318,16 +1318,16 @@ public DotNetFrameworkSpec(
                 bool hasMSBuild = true,
                 Version visualStudioVersion = null)
             {
-                this.Version = version;
-                this._visualStudioVersion = visualStudioVersion;
-                this._dotNetFrameworkRegistryKey = dotNetFrameworkRegistryKey;
-                this._dotNetFrameworkSetupRegistryInstalledName = dotNetFrameworkSetupRegistryInstalledName;
-                this.DotNetFrameworkFolderPrefix = dotNetFrameworkVersionFolderPrefix;
-                this._dotNetFrameworkSdkRegistryToolsKey = dotNetFrameworkSdkRegistryToolsKey;
-                this.DotNetFrameworkSdkRegistryInstallationFolderName = dotNetFrameworkSdkRegistryInstallationFolderName;
-                this._hasMsBuild = hasMSBuild;
-                this._pathsToDotNetFramework = new ConcurrentDictionary<DotNetFrameworkArchitecture, string>();
-                this._pathsToDotNetFrameworkSdkTools = new ConcurrentDictionary<Version, string>();
+                Version = version;
+                _visualStudioVersion = visualStudioVersion;
+                _dotNetFrameworkRegistryKey = dotNetFrameworkRegistryKey;
+                _dotNetFrameworkSetupRegistryInstalledName = dotNetFrameworkSetupRegistryInstalledName;
+                DotNetFrameworkFolderPrefix = dotNetFrameworkVersionFolderPrefix;
+                _dotNetFrameworkSdkRegistryToolsKey = dotNetFrameworkSdkRegistryToolsKey;
+                DotNetFrameworkSdkRegistryInstallationFolderName = dotNetFrameworkSdkRegistryInstallationFolderName;
+                _hasMsBuild = hasMSBuild;
+                _pathsToDotNetFramework = new ConcurrentDictionary<DotNetFrameworkArchitecture, string>();
+                _pathsToDotNetFrameworkSdkTools = new ConcurrentDictionary<Version, string>();
             }
 
             /// <summary>
@@ -1348,7 +1348,7 @@ public DotNetFrameworkSpec(
             /// <summary>
             /// Get the FrameworkName for this version of the .NET Framework.
             /// </summary>
-            private FrameworkName FrameworkName => new FrameworkName(dotNetFrameworkIdentifier, this.Version);
+            private FrameworkName FrameworkName => new FrameworkName(dotNetFrameworkIdentifier, Version);
 
             /// <summary>
             /// Gets the full registry key of this .net framework Sdk for the given visual studio version.
@@ -1365,7 +1365,7 @@ public virtual string GetDotNetFrameworkSdkRootRegistryKey(VisualStudioSpec visu
             public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture architecture)
             {
                 string cachedPath;
-                if (this._pathsToDotNetFramework.TryGetValue(architecture, out cachedPath))
+                if (_pathsToDotNetFramework.TryGetValue(architecture, out cachedPath))
                 {
                     return cachedPath;
                 }
@@ -1374,8 +1374,8 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                 // Otherwise, check to see if we're even installed.  If not, return null -- no point in setting the static
                 // variables to null when that's what they are already.
                 if (NativeMethodsShared.IsWindows && !CheckForFrameworkInstallation(
-                    this._dotNetFrameworkRegistryKey,
-                    this._dotNetFrameworkSetupRegistryInstalledName))
+                    _dotNetFrameworkRegistryKey,
+                    _dotNetFrameworkSetupRegistryInstalledName))
                 {
                     return null;
                 }
@@ -1385,7 +1385,7 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                 string generatedPathToDotNetFramework =
                                 FindDotNetFrameworkPath(
                                     Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
-                                    this.DotNetFrameworkFolderPrefix,
+                                    DotNetFrameworkFolderPrefix,
                                     Directory.Exists,
                                     Directory.GetDirectories,
                                     architecture);
@@ -1394,7 +1394,7 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                 // Note: net481 did not ship an ARM64 MSBuild.exe, so checking its dll's is the fallback for a valid install.
                 // Context: https://github.com/dotnet/msbuild/pull/7689
                 // Rollback see https://developercommunity.visualstudio.com/t/Unable-to-locate-MSBuild-path-with-Lates/10824132 
-                if (this._hasMsBuild &&
+                if (_hasMsBuild &&
                     generatedPathToDotNetFramework != null &&
                     (!File.Exists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")) &&
                      !File.Exists(Path.Combine(generatedPathToDotNetFramework, "Microsoft.Build.dll"))))
@@ -1417,7 +1417,7 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
             public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualStudioSpec)
             {
                 string cachedPath;
-                if (this._pathsToDotNetFrameworkSdkTools.TryGetValue(visualStudioSpec.Version, out cachedPath))
+                if (_pathsToDotNetFrameworkSdkTools.TryGetValue(visualStudioSpec.Version, out cachedPath))
                 {
                     return cachedPath;
                 }
@@ -1429,7 +1429,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
                     string frameworkPath = NativeMethodsShared.FrameworkBasePath;
                     if (!string.IsNullOrEmpty(frameworkPath))
                     {
-                        frameworkPath = Path.Combine(frameworkPath, this.Version.ToString());
+                        frameworkPath = Path.Combine(frameworkPath, Version.ToString());
                     }
 
                     if (!string.IsNullOrEmpty(frameworkPath) && FileSystems.Default.DirectoryExists(frameworkPath))
@@ -1444,7 +1444,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
                                               @"\",
                                               MicrosoftSDKsRegistryKey,
                                               visualStudioSpec.GetDotNetFrameworkSdkRegistryKey(Version),
-                                              this._dotNetFrameworkSdkRegistryToolsKey);
+                                              _dotNetFrameworkSdkRegistryToolsKey);
 
                     // For the Dev10 SDK, we check the registry that corresponds to the current process' bitness, rather than
                     // always the 32-bit one the way we do for Dev11 and onward, since that's what we did in Dev10 as well.
@@ -1453,7 +1453,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
 
                     generatedPathToDotNetFrameworkSdkTools = FindRegistryValueUnderKey(
                         registryPath,
-                        this.DotNetFrameworkSdkRegistryInstallationFolderName,
+                        DotNetFrameworkSdkRegistryInstallationFolderName,
                         registryView);
 
                     if (string.IsNullOrEmpty(generatedPathToDotNetFrameworkSdkTools))
@@ -1466,7 +1466,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
                         for (int i = 0; i < s_explicitFallbackRulesForPathToDotNetFrameworkSdkTools.GetLength(0); ++i)
                         {
                             var trigger = s_explicitFallbackRulesForPathToDotNetFrameworkSdkTools[i, 0];
-                            if (trigger.Item1 == this.Version && trigger.Item2 == visualStudioSpec.Version)
+                            if (trigger.Item1 == Version && trigger.Item2 == visualStudioSpec.Version)
                             {
                                 foundExplicitRule = true;
                                 var fallback = s_explicitFallbackRulesForPathToDotNetFrameworkSdkTools[i, 1];
@@ -1487,7 +1487,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
                                 // The items in the array "visualStudioSpecs" must be ordered by version. That would allow us to fallback to the previous visual studio version easily.
                                 VisualStudioSpec fallbackVisualStudioSpec = VisualStudioSpecs.Value[index - 1];
                                 generatedPathToDotNetFrameworkSdkTools = FallbackToPathToDotNetFrameworkSdkToolsInPreviousVersion(
-                                    this.Version,
+                                    Version,
                                     fallbackVisualStudioSpec.Version);
                             }
                         }
@@ -1497,12 +1497,12 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
                 if (string.IsNullOrEmpty(generatedPathToDotNetFrameworkSdkTools))
                 {
                     // Fallback to "default" ultimately.
-                    generatedPathToDotNetFrameworkSdkTools = FallbackToDefaultPathToDotNetFrameworkSdkTools(this.Version);
+                    generatedPathToDotNetFrameworkSdkTools = FallbackToDefaultPathToDotNetFrameworkSdkTools(Version);
                 }
 
                 if (!string.IsNullOrEmpty(generatedPathToDotNetFrameworkSdkTools))
                 {
-                    this._pathsToDotNetFrameworkSdkTools[visualStudioSpec.Version] = generatedPathToDotNetFrameworkSdkTools;
+                    _pathsToDotNetFrameworkSdkTools[visualStudioSpec.Version] = generatedPathToDotNetFrameworkSdkTools;
                 }
 
                 return generatedPathToDotNetFrameworkSdkTools;
@@ -1514,7 +1514,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
             /// </summary>
             public virtual string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudioSpec)
             {
-                string pathToBinRoot = this.GetPathToDotNetFrameworkSdkTools(visualStudioSpec);
+                string pathToBinRoot = GetPathToDotNetFrameworkSdkTools(visualStudioSpec);
                 if (NativeMethodsShared.IsWindows)
                 {
                     pathToBinRoot = RemoveDirectories(pathToBinRoot, 2);
@@ -1529,18 +1529,18 @@ public virtual string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudioS
             /// </summary>
             public virtual string GetPathToDotNetFrameworkReferenceAssemblies()
             {
-                if (this._pathToDotNetFrameworkReferenceAssemblies == null)
+                if (_pathToDotNetFrameworkReferenceAssemblies == null)
                 {
                     // when a user requests the 40 reference assembly path we don't need to read the redist list because we will not be chaining so we may as well just
                     // generate the path and save us some time.
-                    string referencePath = GenerateReferenceAssemblyPath(FrameworkLocationHelper.programFilesReferenceAssemblyLocation, this.FrameworkName);
+                    string referencePath = GenerateReferenceAssemblyPath(programFilesReferenceAssemblyLocation, FrameworkName);
                     if (FileSystems.Default.DirectoryExists(referencePath))
                     {
-                        this._pathToDotNetFrameworkReferenceAssemblies = FileUtilities.EnsureTrailingSlash(referencePath);
+                        _pathToDotNetFrameworkReferenceAssemblies = FileUtilities.EnsureTrailingSlash(referencePath);
                     }
                 }
 
-                return this._pathToDotNetFrameworkReferenceAssemblies;
+                return _pathToDotNetFrameworkReferenceAssemblies;
             }
 
             /// <summary>
@@ -1550,26 +1550,26 @@ public virtual string GetPathToDotNetFrameworkReferenceAssemblies()
             public virtual string GetPathToWindowsSdk()
             {
 #if FEATURE_WIN32_REGISTRY
-                if (this._pathToWindowsSdk == null)
+                if (_pathToWindowsSdk == null)
                 {
-                    ErrorUtilities.VerifyThrowArgument(this._visualStudioVersion != null, "FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk", this.Version);
+                    ErrorUtilities.VerifyThrowArgument(_visualStudioVersion != null, "FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk", Version);
 
-                    var visualStudioSpec = GetVisualStudioSpec(this._visualStudioVersion);
+                    var visualStudioSpec = GetVisualStudioSpec(_visualStudioVersion);
 
                     if (string.IsNullOrEmpty(visualStudioSpec.WindowsSdkRegistryKey) || string.IsNullOrEmpty(visualStudioSpec.WindowsSdkRegistryInstallationFolderName))
                     {
-                        ErrorUtilities.ThrowArgument("FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk", this.Version);
+                        ErrorUtilities.ThrowArgument("FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk", Version);
                     }
 
                     string registryPath = string.Join(@"\", MicrosoftSDKsRegistryKey, "Windows", visualStudioSpec.WindowsSdkRegistryKey);
 
                     // As of Dev11, the SDK reg keys are installed in the 32-bit registry.
-                    this._pathToWindowsSdk = FindRegistryValueUnderKey(
+                    _pathToWindowsSdk = FindRegistryValueUnderKey(
                         registryPath,
                         visualStudioSpec.WindowsSdkRegistryInstallationFolderName,
                         RegistryView.Registry32);
                 }
-                return this._pathToWindowsSdk;
+                return _pathToWindowsSdk;
 #else
                 return null;
 #endif
@@ -1650,7 +1650,7 @@ public override string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualS
                 {
                     _pathToDotNetFrameworkSdkTools = FindRegistryValueUnderKey(
                         dotNetFrameworkRegistryPath,
-                        this.DotNetFrameworkSdkRegistryInstallationFolderName);
+                        DotNetFrameworkSdkRegistryInstallationFolderName);
                 }
 
                 return _pathToDotNetFrameworkSdkTools;
@@ -1664,7 +1664,7 @@ public override string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualS
             /// </summary>
             public override string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudioSpec)
             {
-                return this.GetPathToDotNetFrameworkSdkTools(visualStudioSpec);
+                return GetPathToDotNetFrameworkSdkTools(visualStudioSpec);
             }
 
             /// <summary>
@@ -1672,7 +1672,7 @@ public override string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudio
             /// </summary>
             public override string GetPathToDotNetFrameworkReferenceAssemblies()
             {
-                return this.GetPathToDotNetFramework(DotNetFrameworkArchitecture.Current);
+                return GetPathToDotNetFramework(DotNetFrameworkArchitecture.Current);
             }
         }
 
@@ -1705,7 +1705,7 @@ public DotNetFrameworkSpecV3(
             /// </summary>
             public override string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudioSpec)
             {
-                string pathToBinRoot = this.GetPathToDotNetFrameworkSdkTools(visualStudioSpec);
+                string pathToBinRoot = GetPathToDotNetFrameworkSdkTools(visualStudioSpec);
                 return RemoveDirectories(pathToBinRoot, 1);
             }
 
@@ -1715,21 +1715,21 @@ public override string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudio
             /// </summary>
             public override string GetPathToDotNetFrameworkReferenceAssemblies()
             {
-                if (this._pathToDotNetFrameworkReferenceAssemblies == null)
+                if (_pathToDotNetFrameworkReferenceAssemblies == null)
                 {
 #if FEATURE_WIN32_REGISTRY
-                    this._pathToDotNetFrameworkReferenceAssemblies = FindRegistryValueUnderKey(
-                        dotNetFrameworkAssemblyFoldersRegistryPath + "\\" + this.DotNetFrameworkFolderPrefix,
+                    _pathToDotNetFrameworkReferenceAssemblies = FindRegistryValueUnderKey(
+                        dotNetFrameworkAssemblyFoldersRegistryPath + "\\" + DotNetFrameworkFolderPrefix,
                         referenceAssembliesRegistryValueName);
 #endif
 
-                    if (this._pathToDotNetFrameworkReferenceAssemblies == null)
+                    if (_pathToDotNetFrameworkReferenceAssemblies == null)
                     {
-                        this._pathToDotNetFrameworkReferenceAssemblies = GenerateReferenceAssemblyDirectory(this.DotNetFrameworkFolderPrefix);
+                        _pathToDotNetFrameworkReferenceAssemblies = GenerateReferenceAssemblyDirectory(DotNetFrameworkFolderPrefix);
                     }
                 }
 
-                return this._pathToDotNetFrameworkReferenceAssemblies;
+                return _pathToDotNetFrameworkReferenceAssemblies;
             }
         }
     }
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 307cc68bdc9..e66550d1df4 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -80,7 +80,7 @@ public override String ReadString()
             char[] resultBuffer = null;
             try
             {
-                MemoryStream memoryStream = this.BaseStream as MemoryStream;
+                MemoryStream memoryStream = BaseStream as MemoryStream;
 
                 int currPos = 0;
                 int n = 0;
diff --git a/src/Shared/LanguageParser/tokenChar.cs b/src/Shared/LanguageParser/tokenChar.cs
index 0cd62ff96e9..28cb78e80fd 100644
--- a/src/Shared/LanguageParser/tokenChar.cs
+++ b/src/Shared/LanguageParser/tokenChar.cs
@@ -34,7 +34,7 @@ internal static bool IsNewLine(char c)
         /// <returns></returns>
         internal static bool IsLetter(char c)
         {
-            UnicodeCategory cat = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);
+            UnicodeCategory cat = CharUnicodeInfo.GetUnicodeCategory(c);
 
             // From 2.4.2 of the C# Language Specification
             // letter-character:
@@ -58,7 +58,7 @@ internal static bool IsLetter(char c)
         /// <returns></returns>
         internal static bool IsDecimalDigit(char c)
         {
-            UnicodeCategory cat = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);
+            UnicodeCategory cat = CharUnicodeInfo.GetUnicodeCategory(c);
 
             // From 2.4.2 of the C# Language Specification
             // decimal-digit-character:
@@ -77,7 +77,7 @@ internal static bool IsDecimalDigit(char c)
         /// <returns></returns>
         internal static bool IsConnecting(char c)
         {
-            UnicodeCategory cat = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);
+            UnicodeCategory cat = CharUnicodeInfo.GetUnicodeCategory(c);
 
             // From 2.4.2 of the C# Language Specification
             // connecting-character:
@@ -97,7 +97,7 @@ internal static bool IsConnecting(char c)
         /// <returns></returns>
         internal static bool IsCombining(char c)
         {
-            UnicodeCategory cat = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);
+            UnicodeCategory cat = CharUnicodeInfo.GetUnicodeCategory(c);
 
             // From 2.4.2 of the C# Language Specification
             // combining-character:
@@ -117,7 +117,7 @@ internal static bool IsCombining(char c)
         /// <returns></returns>
         internal static bool IsFormatting(char c)
         {
-            UnicodeCategory cat = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);
+            UnicodeCategory cat = CharUnicodeInfo.GetUnicodeCategory(c);
 
             // From 2.4.2 of the C# Language Specification
             // formatting-character:
diff --git a/src/Shared/LanguageParser/tokenEnumerator.cs b/src/Shared/LanguageParser/tokenEnumerator.cs
index 3ae025d91b4..78053e8bbe7 100644
--- a/src/Shared/LanguageParser/tokenEnumerator.cs
+++ b/src/Shared/LanguageParser/tokenEnumerator.cs
@@ -43,15 +43,15 @@ public bool MoveNext()
             bool found = FindNextToken();
 
             // If a token was found, record the line number and text into
-            if (found && this.current != null)
+            if (found && current != null)
             {
-                this.current.Line = startLine;
+                current.Line = startLine;
 
                 // Don't record if there is already something there.
                 // This is so that FindNextToken can set the value if it wants to.
-                if (this.current.InnerText == null)
+                if (current.InnerText == null)
                 {
-                    this.current.InnerText = Reader.GetCurrentMatchedString(startPosition);
+                    current.InnerText = Reader.GetCurrentMatchedString(startPosition);
                 }
             }
             return found;
@@ -65,7 +65,7 @@ public bool MoveNext()
         public void Reset()
         {
             Reader.Reset();
-            this.current = null;
+            current = null;
         }
 
         /*
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 3c617c54014..2d063a3a070 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -432,14 +432,14 @@ internal void WriteToStream(ITranslator translator)
             bool eventCanSerializeItself = methodInfo != null;
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
-                if (_buildEvent is ProjectEvaluationStartedEventArgs
-                    or ProjectEvaluationFinishedEventArgs
-                    or ResponseFileUsedEventArgs)
-                {
-                    // switch to serialization methods that we provide in this file
-                    // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
-                    eventCanSerializeItself = false;
-                }
+            if (_buildEvent is ProjectEvaluationStartedEventArgs
+                or ProjectEvaluationFinishedEventArgs
+                or ResponseFileUsedEventArgs)
+            {
+                // switch to serialization methods that we provide in this file
+                // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
+                eventCanSerializeItself = false;
+            }
 #endif
 
             translator.Translate(ref eventCanSerializeItself);
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 7427c5ed735..db9cf26c20e 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -83,7 +83,7 @@ public MSBuildLoadContext(string assemblyPath)
                     continue;
                 }
 
-                AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
+                AssemblyName candidateAssemblyName = GetAssemblyName(candidatePath);
                 if (candidateAssemblyName.Version != assemblyName.Version)
                 {
                     continue;
@@ -101,7 +101,7 @@ public MSBuildLoadContext(string assemblyPath)
 
             if (FileSystems.Default.FileExists(assemblyNameInExecutableDirectory))
             {
-                return AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyNameInExecutableDirectory);
+                return Default.LoadFromAssemblyPath(assemblyNameInExecutableDirectory);
             }
 
             return null;
diff --git a/src/Shared/MetadataConversionUtilities.cs b/src/Shared/MetadataConversionUtilities.cs
index a932217e7bc..34e30423f28 100644
--- a/src/Shared/MetadataConversionUtilities.cs
+++ b/src/Shared/MetadataConversionUtilities.cs
@@ -39,9 +39,9 @@ internal static bool TryConvertItemMetadataToBool(
 
             try
             {
-                return Microsoft.Build.Shared.ConversionUtilities.ConvertStringToBool(metadataValue);
+                return ConversionUtilities.ConvertStringToBool(metadataValue);
             }
-            catch (System.ArgumentException e)
+            catch (ArgumentException e)
             {
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("General.InvalidAttributeMetadata", item.ItemSpec, itemMetadataName, metadataValue, "bool"), e);
             }
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index d7e77955644..c9ef73f52b4 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -107,7 +107,7 @@ internal static bool IsItemSpecModifier(string name)
                             default:
                                 return false;
                             case 'R': // RootDir
-                                if (name == FileUtilities.ItemSpecModifiers.RootDir)
+                                if (name == RootDir)
                                 {
                                     return true;
                                 }
@@ -123,11 +123,11 @@ internal static bool IsItemSpecModifier(string name)
                             default:
                                 return false;
                             case 'F': // Filename, FullPath
-                                if (name == FileUtilities.ItemSpecModifiers.FullPath)
+                                if (name == FullPath)
                                 {
                                     return true;
                                 }
-                                if (name == FileUtilities.ItemSpecModifiers.Filename)
+                                if (name == Filename)
                                 {
                                     return true;
                                 }
@@ -135,7 +135,7 @@ internal static bool IsItemSpecModifier(string name)
                             case 'f':
                                 break;
                             case 'I': // Identity
-                                if (name == FileUtilities.ItemSpecModifiers.Identity)
+                                if (name == Identity)
                                 {
                                     return true;
                                 }
@@ -150,7 +150,7 @@ internal static bool IsItemSpecModifier(string name)
                             default:
                                 return false;
                             case 'D': // Directory
-                                if (name == FileUtilities.ItemSpecModifiers.Directory)
+                                if (name == Directory)
                                 {
                                     return true;
                                 }
@@ -158,7 +158,7 @@ internal static bool IsItemSpecModifier(string name)
                             case 'd':
                                 break;
                             case 'E': // Extension
-                                if (name == FileUtilities.ItemSpecModifiers.Extension)
+                                if (name == Extension)
                                 {
                                     return true;
                                 }
@@ -173,7 +173,7 @@ internal static bool IsItemSpecModifier(string name)
                             default:
                                 return false;
                             case 'C': // CreatedTime
-                                if (name == FileUtilities.ItemSpecModifiers.CreatedTime)
+                                if (name == CreatedTime)
                                 {
                                     return true;
                                 }
@@ -181,7 +181,7 @@ internal static bool IsItemSpecModifier(string name)
                             case 'c':
                                 break;
                             case 'R': // RelativeDir
-                                if (name == FileUtilities.ItemSpecModifiers.RelativeDir)
+                                if (name == RelativeDir)
                                 {
                                     return true;
                                 }
@@ -197,7 +197,7 @@ internal static bool IsItemSpecModifier(string name)
                             default:
                                 return false;
                             case 'A': // AccessedTime
-                                if (name == FileUtilities.ItemSpecModifiers.AccessedTime)
+                                if (name == AccessedTime)
                                 {
                                     return true;
                                 }
@@ -205,7 +205,7 @@ internal static bool IsItemSpecModifier(string name)
                             case 'a':
                                 break;
                             case 'M': // ModifiedTime
-                                if (name == FileUtilities.ItemSpecModifiers.ModifiedTime)
+                                if (name == ModifiedTime)
                                 {
                                     return true;
                                 }
@@ -213,7 +213,7 @@ internal static bool IsItemSpecModifier(string name)
                             case 'm':
                                 break;
                             case 'R': // RecursiveDir
-                                if (name == FileUtilities.ItemSpecModifiers.RecursiveDir)
+                                if (name == RecursiveDir)
                                 {
                                     return true;
                                 }
@@ -253,13 +253,13 @@ internal static bool IsDefiningProjectModifier(string name)
                 switch (name.Length)
                 {
                     case 19: // DefiningProjectName
-                        if (name == FileUtilities.ItemSpecModifiers.DefiningProjectName)
+                        if (name == DefiningProjectName)
                         {
                             return true;
                         }
                         break;
                     case 23: // DefiningProjectFullPath
-                        if (name == FileUtilities.ItemSpecModifiers.DefiningProjectFullPath)
+                        if (name == DefiningProjectFullPath)
                         {
                             return true;
                         }
@@ -271,7 +271,7 @@ internal static bool IsDefiningProjectModifier(string name)
                             default:
                                 return false;
                             case 'D': // DefiningProjectDirectory
-                                if (name == FileUtilities.ItemSpecModifiers.DefiningProjectDirectory)
+                                if (name == DefiningProjectDirectory)
                                 {
                                     return true;
                                 }
@@ -279,7 +279,7 @@ internal static bool IsDefiningProjectModifier(string name)
                             case 'd':
                                 break;
                             case 'E': // DefiningProjectExtension
-                                if (name == FileUtilities.ItemSpecModifiers.DefiningProjectExtension)
+                                if (name == DefiningProjectExtension)
                                 {
                                     return true;
                                 }
@@ -389,7 +389,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
                 try
                 {
-                    if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.FullPath, StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(modifier, FullPath, StringComparison.OrdinalIgnoreCase))
                     {
                         if (fullPath != null)
                         {
@@ -406,9 +406,9 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
                         ThrowForUrl(modifiedItemSpec, itemSpec, currentDirectory);
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.RootDir, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, RootDir, StringComparison.OrdinalIgnoreCase))
                     {
-                        GetItemSpecModifier(currentDirectory, itemSpec, definingProjectEscaped, ItemSpecModifiers.FullPath, ref fullPath);
+                        GetItemSpecModifier(currentDirectory, itemSpec, definingProjectEscaped, FullPath, ref fullPath);
 
                         modifiedItemSpec = Path.GetPathRoot(fullPath);
 
@@ -422,7 +422,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec += Path.DirectorySeparatorChar;
                         }
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.Filename, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, Filename, StringComparison.OrdinalIgnoreCase))
                     {
                         // if the item-spec is a root directory, it can have no filename
                         if (IsRootDirectory(itemSpec))
@@ -437,7 +437,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = Path.GetFileNameWithoutExtension(FixFilePath(itemSpec));
                         }
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.Extension, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, Extension, StringComparison.OrdinalIgnoreCase))
                     {
                         // if the item-spec is a root directory, it can have no extension
                         if (IsRootDirectory(itemSpec))
@@ -451,13 +451,13 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = Path.GetExtension(itemSpec);
                         }
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.RelativeDir, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, RelativeDir, StringComparison.OrdinalIgnoreCase))
                     {
                         modifiedItemSpec = GetDirectory(itemSpec);
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.Directory, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, Directory, StringComparison.OrdinalIgnoreCase))
                     {
-                        GetItemSpecModifier(currentDirectory, itemSpec, definingProjectEscaped, ItemSpecModifiers.FullPath, ref fullPath);
+                        GetItemSpecModifier(currentDirectory, itemSpec, definingProjectEscaped, FullPath, ref fullPath);
 
                         modifiedItemSpec = GetDirectory(fullPath);
 
@@ -492,22 +492,22 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = modifiedItemSpec.Substring(1);
                         }
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, RecursiveDir, StringComparison.OrdinalIgnoreCase))
                     {
                         // only the BuildItem class can compute this modifier -- so leave empty
                         modifiedItemSpec = String.Empty;
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.Identity, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, Identity, StringComparison.OrdinalIgnoreCase))
                     {
                         modifiedItemSpec = itemSpec;
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.ModifiedTime, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, ModifiedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         // About to go out to the filesystem.  This means data is leaving the engine, so need
                         // to unescape first.
                         string unescapedItemSpec = EscapingUtilities.UnescapeAll(itemSpec);
 
-                        FileInfo info = FileUtilities.GetFileInfoNoThrow(unescapedItemSpec);
+                        FileInfo info = GetFileInfoNoThrow(unescapedItemSpec);
 
                         if (info != null)
                         {
@@ -519,7 +519,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = String.Empty;
                         }
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.CreatedTime, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, CreatedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         // About to go out to the filesystem.  This means data is leaving the engine, so need
                         // to unescape first.
@@ -535,7 +535,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = String.Empty;
                         }
                     }
-                    else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.AccessedTime, StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(modifier, AccessedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         // About to go out to the filesystem.  This means data is leaving the engine, so need
                         // to unescape first.
@@ -560,28 +560,28 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.DefiningProjectDirectory, StringComparison.OrdinalIgnoreCase))
+                            if (string.Equals(modifier, DefiningProjectDirectory, StringComparison.OrdinalIgnoreCase))
                             {
                                 // ItemSpecModifiers.Directory does not contain the root directory
                                 modifiedItemSpec = Path.Combine(
-                                        GetItemSpecModifier(currentDirectory, definingProjectEscaped, null, ItemSpecModifiers.RootDir),
-                                        GetItemSpecModifier(currentDirectory, definingProjectEscaped, null, ItemSpecModifiers.Directory));
+                                        GetItemSpecModifier(currentDirectory, definingProjectEscaped, null, RootDir),
+                                        GetItemSpecModifier(currentDirectory, definingProjectEscaped, null, Directory));
                             }
                             else
                             {
                                 string additionalModifier = null;
 
-                                if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.DefiningProjectFullPath, StringComparison.OrdinalIgnoreCase))
+                                if (string.Equals(modifier, DefiningProjectFullPath, StringComparison.OrdinalIgnoreCase))
                                 {
-                                    additionalModifier = ItemSpecModifiers.FullPath;
+                                    additionalModifier = FullPath;
                                 }
-                                else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.DefiningProjectName, StringComparison.OrdinalIgnoreCase))
+                                else if (string.Equals(modifier, DefiningProjectName, StringComparison.OrdinalIgnoreCase))
                                 {
-                                    additionalModifier = ItemSpecModifiers.Filename;
+                                    additionalModifier = Filename;
                                 }
-                                else if (string.Equals(modifier, FileUtilities.ItemSpecModifiers.DefiningProjectExtension, StringComparison.OrdinalIgnoreCase))
+                                else if (string.Equals(modifier, DefiningProjectExtension, StringComparison.OrdinalIgnoreCase))
                                 {
-                                    additionalModifier = ItemSpecModifiers.Extension;
+                                    additionalModifier = Extension;
                                 }
                                 else
                                 {
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 846f7716ec4..0b77ac3d4a5 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -685,8 +685,8 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
             while (!exitLoop);
         }
 
-#endregion
+        #endregion
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Shared/ProjectWriter.cs b/src/Shared/ProjectWriter.cs
index d5a5a00003f..bf18097ee7f 100644
--- a/src/Shared/ProjectWriter.cs
+++ b/src/Shared/ProjectWriter.cs
@@ -117,7 +117,7 @@ internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementD
             if (!project.PreserveWhitespace)
             {
                 // write out child elements in an indented fashion, instead of jamming all the XML into one line
-                base.Formatting = Formatting.Indented;
+                Formatting = Formatting.Indented;
             }
 
             // don't write an XML declaration unless the project already has one or has non-default encoding
@@ -158,7 +158,7 @@ public override void WriteString(string text)
                     // write each piece of the transform normally, except for the arrow -- write that without escaping
                     base.WriteString(itemVectorTransform.Groups["PREFIX"].Value);
                     base.WriteString(itemVectorTransform.Groups["TYPE"].Value);
-                    base.WriteRaw(itemVectorTransform.Groups["ARROW"].Value);
+                    WriteRaw(itemVectorTransform.Groups["ARROW"].Value);
                     base.WriteString(itemVectorTransform.Groups["TRANSFORM"].Value);
                     base.WriteString(itemVectorTransform.Groups["SEPARATOR_SPECIFICATION"].Value);
                     base.WriteString(itemVectorTransform.Groups["SUFFIX"].Value);
diff --git a/src/Shared/ReadOnlyCollection.cs b/src/Shared/ReadOnlyCollection.cs
index c1754eaf86f..7d6b432b820 100644
--- a/src/Shared/ReadOnlyCollection.cs
+++ b/src/Shared/ReadOnlyCollection.cs
@@ -118,7 +118,7 @@ public bool Contains(T item)
             // so we could just use IEnumerable.Contains<T>() here.
             if (!(_backing is ICollection<T>))
             {
-                return _backing.Contains<T>(item);
+                return _backing.Contains(item);
             }
 
             return BackingCollection.Contains(item);
diff --git a/src/Shared/ReadOnlyEmptyCollection.cs b/src/Shared/ReadOnlyEmptyCollection.cs
index 128480dca68..08631c04346 100644
--- a/src/Shared/ReadOnlyEmptyCollection.cs
+++ b/src/Shared/ReadOnlyEmptyCollection.cs
@@ -130,7 +130,7 @@ public IEnumerator<T> GetEnumerator()
         /// <summary>
         /// Get an enumerator over an empty collection
         /// </summary>
-        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+        IEnumerator IEnumerable.GetEnumerator()
         {
             return GetEnumerator();
         }
diff --git a/src/Shared/ReadOnlyEmptyDictionary.cs b/src/Shared/ReadOnlyEmptyDictionary.cs
index 46b1b2738e9..b5dbd0abfaf 100644
--- a/src/Shared/ReadOnlyEmptyDictionary.cs
+++ b/src/Shared/ReadOnlyEmptyDictionary.cs
@@ -262,7 +262,7 @@ public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
         /// <summary>
         /// Get empty enumerator
         /// </summary>
-        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+        IEnumerator IEnumerable.GetEnumerator()
         {
             return GetEnumerator();
         }
@@ -302,7 +302,7 @@ public void Remove(object key)
         /// <summary>
         /// CopyTo
         /// </summary>
-        public void CopyTo(System.Array array, int index)
+        public void CopyTo(Array array, int index)
         {
             // Nothing to do
         }
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index 10391f5d336..9a59ec891a8 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -127,7 +127,7 @@ protected Lazy<ConcurrentDictionary<object, object>> GetLazyCollectionForLifetim
                     break;
 
                 case RegisteredTaskObjectLifetime.AppDomain:
-                    dict = RegisteredTaskObjectCacheBase.s_appDomainLifetimeObjects;
+                    dict = s_appDomainLifetimeObjects;
                     break;
             }
 
diff --git a/src/Shared/TaskLoggingHelperExtension.cs b/src/Shared/TaskLoggingHelperExtension.cs
index a666e06e705..07e7d9bfd3a 100644
--- a/src/Shared/TaskLoggingHelperExtension.cs
+++ b/src/Shared/TaskLoggingHelperExtension.cs
@@ -40,9 +40,9 @@ class TaskLoggingHelperExtension : TaskLoggingHelper
         public TaskLoggingHelperExtension(ITask taskInstance, ResourceManager primaryResources, ResourceManager sharedResources, string helpKeywordPrefix) :
             base(taskInstance)
         {
-            this.TaskResources = primaryResources;
-            this.TaskSharedResources = sharedResources;
-            this.HelpKeywordPrefix = helpKeywordPrefix;
+            TaskResources = primaryResources;
+            TaskSharedResources = sharedResources;
+            HelpKeywordPrefix = helpKeywordPrefix;
         }
 
         #endregion
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index 4c607dfd2b4..9f34fe2eab2 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -71,7 +71,7 @@ private static string CreateFolderUnderTemp()
                 Directory.CreateDirectory(basePath);
             }
 
-            return FileUtilities.EnsureTrailingSlash(basePath);
+            return EnsureTrailingSlash(basePath);
         }
 
         /// <summary>
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 70002db51f0..6a59b7c2f53 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -211,7 +211,7 @@ protected override string ElementName
             /// <returns>element</returns>
             public ExtensionsPathElement GetElement(string os)
             {
-                return (ExtensionsPathElement)this.BaseGet(os);
+                return (ExtensionsPathElement)BaseGet(os);
             }
 
             /// <summary>
@@ -221,7 +221,7 @@ public ExtensionsPathElement GetElement(string os)
             /// <returns>element</returns>
             public ExtensionsPathElement GetElement(int index)
             {
-                return (ExtensionsPathElement)this.BaseGet(index);
+                return (ExtensionsPathElement)BaseGet(index);
             }
 
             /// <summary>
@@ -394,7 +394,7 @@ protected override string ElementName
             /// <returns>element</returns>
             public PropertyElement GetElement(string name)
             {
-                return (PropertyElement)this.BaseGet(name);
+                return (PropertyElement)BaseGet(name);
             }
 
             /// <summary>
@@ -404,7 +404,7 @@ public PropertyElement GetElement(string name)
             /// <returns>element</returns>
             public PropertyElement GetElement(int index)
             {
-                return (PropertyElement)this.BaseGet(index);
+                return (PropertyElement)BaseGet(index);
             }
 
             /// <summary>
@@ -565,7 +565,7 @@ protected override string ElementName
         /// <returns>element</returns>
         public ToolsetElement GetElement(string toolsVersion)
         {
-            return (ToolsetElement)this.BaseGet(toolsVersion);
+            return (ToolsetElement)BaseGet(toolsVersion);
         }
 
         /// <summary>
@@ -575,7 +575,7 @@ public ToolsetElement GetElement(string toolsVersion)
         /// <returns>element</returns>
         public ToolsetElement GetElement(int index)
         {
-            return (ToolsetElement)this.BaseGet(index);
+            return (ToolsetElement)BaseGet(index);
         }
 
         /// <summary>
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index 154c6ff6f05..79539c24cbc 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -118,7 +118,7 @@ internal static void Record(string counter)
                     Trace.WriteLine(s_slot);
                     s_slot = String.Empty;
                     Dump();
-                    Trace.WriteLine(System.Environment.StackTrace);
+                    Trace.WriteLine(Environment.StackTrace);
                     s_last = now;
                 }
             }
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 7c5efa8ce3d..6201b99c13b 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -362,7 +362,7 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName, bool useTaskHost)
                     foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)
                     {
                         // if type matches partially on its name
-                        if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))
+                        if (typeName.Length == 0 || IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))
                         {
                             return desiredTypeInAssembly.Value;
                         }
@@ -384,7 +384,7 @@ private LoadedType GetLoadedTypeFromTypeNameUsingMetadataLoadContext(string type
                     foreach (Type publicType in loadedAssembly.GetExportedTypes())
                     {
                         numberOfTypesSearched++;
-                        if (_isDesiredType(publicType, null) && (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(publicType.FullName, typeName)))
+                        if (_isDesiredType(publicType, null) && (typeName.Length == 0 || IsPartialTypeNameMatch(publicType.FullName, typeName)))
                         {
                             MSBuildEventSource.Log.CreateLoadedTypeStart(loadedAssembly.FullName);
                             LoadedType loadedType = new(publicType, _assemblyLoadInfo, loadedAssembly, _context.LoadFromAssemblyPath(microsoftBuildFrameworkPath).GetType(typeof(ITaskItem).FullName), loadedViaMetadataLoadContext: true);
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 32101d5d60e..8be50d14042 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -33,7 +33,7 @@ public void Indexer_ReferenceFound()
             // Now look for the same key we inserted
             object v2 = dictionary[k1];
 
-            Assert.True(Object.ReferenceEquals(v1, v2));
+            Assert.True(ReferenceEquals(v1, v2));
             Assert.True(dictionary.ContainsKey(k1));
         }
 
@@ -66,7 +66,7 @@ public void TryGetValue_ReferenceFound()
             bool result = dictionary.TryGetValue(k1, out v2);
 
             Assert.True(result);
-            Assert.True(Object.ReferenceEquals(v1, v2));
+            Assert.True(ReferenceEquals(v1, v2));
         }
 
         /// <summary>
@@ -101,11 +101,11 @@ public void EqualityComparer()
             // Don't create it with a literal or the compiler will intern it!
             string k2 = String.Concat("k", "ey");
 
-            Assert.False(Object.ReferenceEquals(k1, k2));
+            Assert.False(ReferenceEquals(k1, k2));
 
             object v2 = dictionary[k2];
 
-            Assert.True(Object.ReferenceEquals(v1, v2));
+            Assert.True(ReferenceEquals(v1, v2));
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 6d43904420f..e30b6fe5484 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -172,7 +172,7 @@ void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false,
         }
 
         /// <summary>
-        /// A test data class for providing data to the <see cref="FileMatcherTest.GetFilesComplexGlobbingMatching"/> test.
+        /// A test data class for providing data to the <see cref="GetFilesComplexGlobbingMatching"/> test.
         /// </summary>
         public class GetFilesComplexGlobbingMatchingInfo
         {
@@ -829,7 +829,7 @@ public void GetLongFileNameForShortLocalPath()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"D:\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt", longPath);
         }
@@ -845,7 +845,7 @@ public void GetLongFileNameForLongLocalPath()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt", longPath);
         }
@@ -861,7 +861,7 @@ public void GetLongFileNameForShortUncPath()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"\\server\share\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt", longPath);
         }
@@ -877,7 +877,7 @@ public void GetLongFileNameForLongUncPath()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt", longPath);
         }
@@ -893,7 +893,7 @@ public void GetLongFileNameForRelativePath()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\LONGSU~1\LONGFI~1.TXT",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"LongDirectoryName\LongSubDirectory\LongFileName.txt", longPath);
         }
@@ -909,7 +909,7 @@ public void GetLongFileNameForRelativePathPreservesTrailingSlash()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\LONGSU~1\",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"LongDirectoryName\LongSubDirectory\", longPath);
         }
@@ -925,7 +925,7 @@ public void GetLongFileNameForRelativePathPreservesExtraSlashes()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\\LONGSU~1\\",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"LongDirectoryName\\LongSubDirectory\\", longPath);
         }
@@ -941,7 +941,7 @@ public void GetLongFileNameForMixedLongAndShort()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"c:\apple\banana\tomato\pomegr~1\orange\",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"c:\apple\banana\tomato\pomegranate\orange\", longPath);
         }
@@ -958,7 +958,7 @@ public void GetLongFileNameWherePartOfThePathDoesntExist()
         {
             string longPath = FileMatcher.GetLongPathName(
                 @"c:\apple\banana\tomato\pomegr~1\orange\chocol~1\vanila~1",
-                new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
+                new FileMatcher.GetFileSystemEntries(GetFileSystemEntries));
 
             Assert.Equal(@"c:\apple\banana\tomato\pomegranate\orange\chocol~1\vanila~1", longPath);
         }
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index e8d2f4f4fe7..dbadb1415a2 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -36,7 +36,14 @@ public MSBuildTestAssemblyFixture()
         {
             // Set field to indicate tests are running in the TestInfo class in Microsoft.Build.Framework.
             //  See the comments on the TestInfo class for an explanation of why it works this way.
+
+/* Unmerged change from project 'Microsoft.Build.Engine.UnitTests(net9.0)'
+Before:
             var frameworkAssembly = typeof(Microsoft.Build.Framework.ITask).Assembly;
+After:
+            var frameworkAssembly = typeof(Framework.ITask).Assembly;
+*/
+            var frameworkAssembly = typeof(Build.Framework.ITask).Assembly;
             var testInfoType = frameworkAssembly.GetType("Microsoft.Build.Framework.TestInfo");
             var runningTestsField = testInfoType.GetField("s_runningTests", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
             runningTestsField.SetValue(null, true);
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index 99e1e36774d..dc909d0af35 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -37,7 +37,7 @@ internal static SortedDictionary<Version, List<string>> GatherVersionStrings(Ver
             {
                 if (version.Length > 0)
                 {
-                    Version candidateVersion = VersionUtilities.ConvertToVersion(version);
+                    Version candidateVersion = ConvertToVersion(version);
 
                     if (candidateVersion != null && (targetPlatformVersion == null || (candidateVersion <= targetPlatformVersion)))
                     {
diff --git a/src/StringTools.UnitTests/StringTools_Tests.cs b/src/StringTools.UnitTests/StringTools_Tests.cs
index 233f2a12ee0..e33019e2002 100644
--- a/src/StringTools.UnitTests/StringTools_Tests.cs
+++ b/src/StringTools.UnitTests/StringTools_Tests.cs
@@ -34,7 +34,7 @@ public void InternsStrings(string str)
             internedString1.Equals(str).ShouldBeTrue();
             string internedString2 = Strings.WeakIntern(str);
             internedString1.Equals(str).ShouldBeTrue();
-            Object.ReferenceEquals(internedString1, internedString2).ShouldBeTrue();
+            ReferenceEquals(internedString1, internedString2).ShouldBeTrue();
 
 #if !NET35_UNITTEST
             ReadOnlySpan<char> span = str.AsSpan();
@@ -42,7 +42,7 @@ public void InternsStrings(string str)
             internedString1.Equals(str).ShouldBeTrue();
             internedString2 = Strings.WeakIntern(span);
             internedString1.Equals(str).ShouldBeTrue();
-            Object.ReferenceEquals(internedString1, internedString2).ShouldBeTrue();
+            ReferenceEquals(internedString1, internedString2).ShouldBeTrue();
 #endif
         }
 
diff --git a/src/StringTools/FowlerNollVo1aHash.cs b/src/StringTools/FowlerNollVo1aHash.cs
index 5a9a876e4c0..cde063d04e2 100644
--- a/src/StringTools/FowlerNollVo1aHash.cs
+++ b/src/StringTools/FowlerNollVo1aHash.cs
@@ -1,8 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Runtime.InteropServices;
 using System;
+using System.Runtime.InteropServices;
 
 namespace Microsoft.NET.StringTools
 {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 164f91774e0..c4ed6e1e6a9 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -658,8 +658,8 @@ private enum EmbedInteropTypes_Indices
         [Fact]
         public void TestGetImageRuntimeVersion()
         {
-            string imageRuntimeReportedByAsssembly = this.GetType().Assembly.ImageRuntimeVersion;
-            string pathForAssembly = this.GetType().Assembly.Location;
+            string imageRuntimeReportedByAsssembly = GetType().Assembly.ImageRuntimeVersion;
+            string pathForAssembly = GetType().Assembly.Location;
 
             string inspectedRuntimeVersion = AssemblyInformation.GetRuntimeVersion(pathForAssembly);
             Assert.Equal(inspectedRuntimeVersion, imageRuntimeReportedByAsssembly);
@@ -2737,7 +2737,7 @@ public void MultipleToElementsUnderFrom()
                 Assert.Empty(errorFileNames); // "Expected no Error file names"
                 Assert.Single(remap);
 
-                AssemblyRemapping pair = remap.First<AssemblyRemapping>();
+                AssemblyRemapping pair = remap.First();
                 Assert.Equal("System.Xml", pair.From.Name);
                 Assert.Equal("Remapped", pair.To.Name);
                 Assert.True(pair.From.Retargetable);
@@ -2823,7 +2823,7 @@ public void DuplicateEntries()
                 Assert.Empty(errorFileNames); // "Expected no Error file names"
                 Assert.Single(remap);
 
-                AssemblyRemapping pair = remap.First<AssemblyRemapping>();
+                AssemblyRemapping pair = remap.First();
                 Assert.Equal("Remapped", pair.To.Name);
                 Assert.False(pair.To.Retargetable);
             }
@@ -2891,7 +2891,7 @@ public void FromElementButNoToElement()
                 Assert.Empty(errorFileNames); // "Expected no Error file names"
                 Assert.Single(remap);
 
-                AssemblyRemapping pair = remap.First<AssemblyRemapping>();
+                AssemblyRemapping pair = remap.First();
                 Assert.Equal("System.Xml", pair.From.Name);
                 Assert.Equal("Remapped", pair.To.Name);
                 Assert.True(pair.From.Retargetable);
@@ -3442,11 +3442,11 @@ public void PrivateItemInFrameworksGetsCopyLocalTrue()
             MockEngine engine = new MockEngine(_output);
 
             // Create the mocks.
-            Microsoft.Build.Shared.FileExists fileExists = new Microsoft.Build.Shared.FileExists(FileExists);
-            Microsoft.Build.Shared.DirectoryExists directoryExists = new Microsoft.Build.Shared.DirectoryExists(DirectoryExists);
-            Microsoft.Build.Tasks.GetDirectories getDirectories = new Microsoft.Build.Tasks.GetDirectories(GetDirectories);
-            Microsoft.Build.Tasks.GetAssemblyName getAssemblyName = new Microsoft.Build.Tasks.GetAssemblyName(GetAssemblyName);
-            Microsoft.Build.Tasks.GetAssemblyMetadata getAssemblyMetadata = new Microsoft.Build.Tasks.GetAssemblyMetadata(GetAssemblyMetadata);
+            FileExists fileExists = new FileExists(FileExists);
+            DirectoryExists directoryExists = new DirectoryExists(DirectoryExists);
+            Tasks.GetDirectories getDirectories = new Tasks.GetDirectories(GetDirectories);
+            GetAssemblyName getAssemblyName = new GetAssemblyName(GetAssemblyName);
+            GetAssemblyMetadata getAssemblyMetadata = new GetAssemblyMetadata(GetAssemblyMetadata);
 
             // Also construct a set of assembly names to pass in.
             ITaskItem[] assemblyNames = new TaskItem[]
@@ -4893,7 +4893,7 @@ public void Regress314573_VeryLongPaths()
 
             ResolveAssemblyReference t = new ResolveAssemblyReference();
 
-            MockEngine e = new (_output);
+            MockEngine e = new(_output);
             t.BuildEngine = e;
 
             t.Assemblies = [new TaskItem("A")]; // Resolved by HintPath
@@ -6323,7 +6323,7 @@ public void ReferenceTableNullDenyList()
             referenceTable.MarkReferencesForExclusion(null);
             referenceTable.RemoveReferencesMarkedForExclusion(false, String.Empty);
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
-            Assert.False(Object.ReferenceEquals(table, table2)); // "Expected Dictionary to be a different instance"
+            Assert.False(ReferenceEquals(table, table2)); // "Expected Dictionary to be a different instance"
             Assert.Equal(2, table2.Count); // "Expected there to be two elements in the Dictionary"
             Assert.True(table2.ContainsKey(engineAssemblyName)); // "Expected to find the engineAssemblyName in the referenceList"
             Assert.True(table2.ContainsKey(xmlAssemblyName)); // "Expected to find the xmlssemblyName in the referenceList"
@@ -6348,7 +6348,7 @@ public void ReferenceTableEmptyDenyList()
             referenceTable.MarkReferencesForExclusion(new Dictionary<string, string>());
             referenceTable.RemoveReferencesMarkedForExclusion(false, String.Empty);
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
-            Assert.False(Object.ReferenceEquals(table, table2)); // "Expected Dictionary to be a different instance"
+            Assert.False(ReferenceEquals(table, table2)); // "Expected Dictionary to be a different instance"
             Assert.Equal(2, table2.Count); // "Expected there to be two elements in the Dictionary"
             Assert.True(table2.ContainsKey(engineAssemblyName)); // "Expected to find the engineAssemblyName in the referenceList"
             Assert.True(table2.ContainsKey(xmlAssemblyName)); // "Expected to find the xmlssemblyName in the referenceList"
@@ -6386,7 +6386,7 @@ public void ReferenceTablePrimaryItemInDenyList()
 
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailedToResolveReferenceBecausePrimaryAssemblyInExclusionList", taskItem.ItemSpec, subSetName);
-            Assert.False(Object.ReferenceEquals(table, table2)); // "Expected dictionary to be a different instance"
+            Assert.False(ReferenceEquals(table, table2)); // "Expected dictionary to be a different instance"
             Assert.Single(table2); // "Expected there to be one elements in the dictionary"
             Assert.False(table2.ContainsKey(engineAssemblyName)); // "Expected to not find the engineAssemblyName in the referenceList"
             Assert.True(table2.ContainsKey(xmlAssemblyName)); // "Expected to find the xmlssemblyName in the referenceList"
@@ -6425,7 +6425,7 @@ public void ReferenceTablePrimaryItemInDenyListSpecificVersionTrue()
 
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailedToResolveReferenceBecausePrimaryAssemblyInExclusionList", taskItem.ItemSpec, subSetName);
-            Assert.False(Object.ReferenceEquals(table, table2)); // "Expected dictionary to be a different instance"
+            Assert.False(ReferenceEquals(table, table2)); // "Expected dictionary to be a different instance"
             Assert.Equal(2, table2.Count); // "Expected there to be two elements in the dictionary"
             Assert.True(table2.ContainsKey(engineAssemblyName)); // "Expected to find the engineAssemblyName in the referenceList"
             Assert.True(table2.ContainsKey(xmlAssemblyName)); // "Expected to find the xmlssemblyName in the referenceList"
@@ -6500,7 +6500,7 @@ public void ReferenceTablePrimaryItemInDenyListRemoveOnlyNoWarn()
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
             string subSetName = ResolveAssemblyReference.GenerateSubSetName(Array.Empty<string>(), null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailedToResolveReferenceBecausePrimaryAssemblyInExclusionList", taskItem.ItemSpec, subSetName);
-            Assert.False(Object.ReferenceEquals(table, table2)); // "Expected dictionary to be a different instance"
+            Assert.False(ReferenceEquals(table, table2)); // "Expected dictionary to be a different instance"
             Assert.Single(table2); // "Expected there to be one elements in the dictionary"
             Assert.False(table2.ContainsKey(engineAssemblyName)); // "Expected to not find the engineAssemblyName in the referenceList"
             Assert.True(table2.ContainsKey(xmlAssemblyName)); // "Expected to find the xmlssemblyName in the referenceList"
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 774d8f3d735..c7b6823e851 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -27,24 +27,24 @@ namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
     public class ResolveAssemblyReferenceTestFixture : IDisposable
     {
         // Create the mocks.
-        internal static Microsoft.Build.Shared.FileExists fileExists = new Microsoft.Build.Shared.FileExists(FileExists);
-        internal static Microsoft.Build.Shared.DirectoryExists directoryExists = new Microsoft.Build.Shared.DirectoryExists(DirectoryExists);
-        internal static Microsoft.Build.Tasks.GetDirectories getDirectories = new Microsoft.Build.Tasks.GetDirectories(GetDirectories);
-        internal static Microsoft.Build.Tasks.GetAssemblyName getAssemblyName = new Microsoft.Build.Tasks.GetAssemblyName(GetAssemblyName);
-        internal static Microsoft.Build.Tasks.GetAssemblyMetadata getAssemblyMetadata = new Microsoft.Build.Tasks.GetAssemblyMetadata(GetAssemblyMetadata);
+        internal static FileExists fileExists = new FileExists(FileExists);
+        internal static DirectoryExists directoryExists = new DirectoryExists(DirectoryExists);
+        internal static Tasks.GetDirectories getDirectories = new Tasks.GetDirectories(GetDirectories);
+        internal static GetAssemblyName getAssemblyName = new GetAssemblyName(GetAssemblyName);
+        internal static GetAssemblyMetadata getAssemblyMetadata = new GetAssemblyMetadata(GetAssemblyMetadata);
 #if FEATURE_WIN32_REGISTRY
-        internal static Microsoft.Build.Shared.GetRegistrySubKeyNames getRegistrySubKeyNames = new Microsoft.Build.Shared.GetRegistrySubKeyNames(GetRegistrySubKeyNames);
-        internal static Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue = new Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue(GetRegistrySubKeyDefaultValue);
+        internal static GetRegistrySubKeyNames getRegistrySubKeyNames = new GetRegistrySubKeyNames(GetRegistrySubKeyNames);
+        internal static GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue = new GetRegistrySubKeyDefaultValue(GetRegistrySubKeyDefaultValue);
 #endif
-        internal static Microsoft.Build.Tasks.GetLastWriteTime getLastWriteTime = new Microsoft.Build.Tasks.GetLastWriteTime(GetLastWriteTime);
-        internal static Microsoft.Build.Tasks.GetAssemblyRuntimeVersion getRuntimeVersion = new Microsoft.Build.Tasks.GetAssemblyRuntimeVersion(GetRuntimeVersion);
-        internal static Microsoft.Build.Tasks.GetAssemblyPathInGac checkIfAssemblyIsInGac = new Microsoft.Build.Tasks.GetAssemblyPathInGac(GetPathForAssemblyInGac);
+        internal static GetLastWriteTime getLastWriteTime = new GetLastWriteTime(GetLastWriteTime);
+        internal static GetAssemblyRuntimeVersion getRuntimeVersion = new GetAssemblyRuntimeVersion(GetRuntimeVersion);
+        internal static GetAssemblyPathInGac checkIfAssemblyIsInGac = new GetAssemblyPathInGac(GetPathForAssemblyInGac);
 #if FEATURE_WIN32_REGISTRY
-        internal static Microsoft.Build.Shared.OpenBaseKey openBaseKey = new Microsoft.Build.Shared.OpenBaseKey(GetBaseKey);
+        internal static OpenBaseKey openBaseKey = new OpenBaseKey(GetBaseKey);
 #endif
-        internal Microsoft.Build.UnitTests.MockEngine.GetStringDelegate resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
-        internal static Microsoft.Build.Tasks.IsWinMDFile isWinMDFile = new Microsoft.Build.Tasks.IsWinMDFile(IsWinMDFile);
-        internal static Microsoft.Build.Tasks.ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader = new Microsoft.Build.Tasks.ReadMachineTypeFromPEHeader(ReadMachineTypeFromPEHeader);
+        internal MockEngine.GetStringDelegate resourceDelegate = new MockEngine.GetStringDelegate(AssemblyResources.GetString);
+        internal static IsWinMDFile isWinMDFile = new IsWinMDFile(IsWinMDFile);
+        internal static ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader = new ReadMachineTypeFromPEHeader(ReadMachineTypeFromPEHeader);
 
         // Performance checks.
         internal static Dictionary<string, int> uniqueFileExists = null;
@@ -1076,7 +1076,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             (
                 String.Equals(path, Path.Combine(s_myVersion20Path, "BadImage.dll"), StringComparison.OrdinalIgnoreCase))
             {
-                throw new System.BadImageFormatException(@"The format of the file '" + Path.Combine(s_myVersion20Path, "BadImage.dll") + "' is invalid");
+                throw new BadImageFormatException(@"The format of the file '" + Path.Combine(s_myVersion20Path, "BadImage.dll") + "' is invalid");
             }
 
             if
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index a29f5b938fc..4321cce3d59 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -365,7 +365,7 @@ public void Regress188319()
             t.ResourceFiles = new ITaskItem[] { i };
             t.RootNamespace = "CustomToolTest";
             bool success = t.Execute(
-                new Microsoft.Build.Tasks.CreateFileStream(CreateFileStream));
+                new CreateFileStream(CreateFileStream));
 
             Assert.True(success); // "Expected the task to succeed."
 
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index 70ec1fb1452..5d17fce02d5 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -353,7 +353,7 @@ public void Regress188319()
             t.ResourceFiles = new ITaskItem[] { i };
             t.RootNamespace = "CustomToolTest";
 
-            bool success = t.Execute(new Microsoft.Build.Tasks.CreateFileStream(CreateFileStream));
+            bool success = t.Execute(new CreateFileStream(CreateFileStream));
 
             Assert.True(success); // "Expected the task to succeed."
 
diff --git a/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs b/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs
index 8d50571656d..1c8bcd0ccf3 100644
--- a/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs
@@ -10,11 +10,11 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
-using Xunit.Sdk;
-using Microsoft.Build.UnitTests.Shared;
 using Xunit.Abstractions;
+using Xunit.Sdk;
 
 namespace Microsoft.Build.Tasks.UnitTests
 {
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index 040199f9fb9..a5ad3e39eba 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -23,8 +23,8 @@ public class FakeSDKStructure : IDisposable
 
         public FakeSDKStructure()
         {
-            FakeSdkStructureRoot = FakeSDKStructure.MakeFakeSDKStructure();
-            FakeSdkStructureRoot2 = FakeSDKStructure.MakeFakeSDKStructure2();
+            FakeSdkStructureRoot = MakeFakeSDKStructure();
+            FakeSdkStructureRoot2 = MakeFakeSDKStructure2();
         }
 
         public void Dispose()
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 9a17e9b848f..ba45fb0fabf 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -1533,7 +1533,7 @@ public class BuildProjectFileTask : Task
 
         public override bool Execute()
         {
-            this.BuildEngine.BuildProjectFile(Project, Targets, null, null);
+            BuildEngine.BuildProjectFile(Project, Targets, null, null);
 
             return true;
         }
diff --git a/src/Tasks.UnitTests/MockTypeInfo.cs b/src/Tasks.UnitTests/MockTypeInfo.cs
index 3ba35b10e37..fe84f51b470 100644
--- a/src/Tasks.UnitTests/MockTypeInfo.cs
+++ b/src/Tasks.UnitTests/MockTypeInfo.cs
@@ -245,16 +245,16 @@ public void AssertAllHandlesReleased()
 
         #region IFixedTypeInfo members
 
-        void IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href)
+        void IFixedTypeInfo.GetRefTypeOfImplType(int index, out IntPtr href)
         {
             Assert.True(index >= 0 && index < _typeAttributes.cImplTypes);
 
             _faultInjector.FailurePointThrow(MockTypeLibrariesFailurePoints.ITypeInfo_GetRefTypeOfImplType);
 
-            href = ((System.IntPtr)index + s_HREF_IMPLTYPES_OFFSET);
+            href = ((IntPtr)index + s_HREF_IMPLTYPES_OFFSET);
         }
 
-        void IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out IFixedTypeInfo ppTI)
+        void IFixedTypeInfo.GetRefTypeInfo(IntPtr hRef, out IFixedTypeInfo ppTI)
         {
             _faultInjector.FailurePointThrow(MockTypeLibrariesFailurePoints.ITypeInfo_GetRefTypeInfo);
             int hRefInt = (int)hRef;
diff --git a/src/Tasks.UnitTests/MockTypeLib.cs b/src/Tasks.UnitTests/MockTypeLib.cs
index fd3fd1e5ebb..5c191de22ec 100644
--- a/src/Tasks.UnitTests/MockTypeLib.cs
+++ b/src/Tasks.UnitTests/MockTypeLib.cs
@@ -148,7 +148,7 @@ public void GetLibAttr(out IntPtr ppTLibAttr)
             _faultInjector.FailurePointThrow(MockTypeLibrariesFailurePoints.ITypeLib_GetLibAttr);
 
             ppTLibAttr = _memoryHelper.AllocateHandle(Marshal.SizeOf<TYPELIBATTR>());
-            Marshal.StructureToPtr(this.Attributes, ppTLibAttr, false);
+            Marshal.StructureToPtr(Attributes, ppTLibAttr, false);
         }
 
         public void ReleaseTLibAttr(IntPtr pTLibAttr)
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 775098727b3..babfc0bf236 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.UnitTests.ResolveSDKReference_Tests
 {
     public class ResolveSDKReferenceTestFixture
     {
-        private Microsoft.Build.UnitTests.MockEngine.GetStringDelegate _resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
+        private MockEngine.GetStringDelegate _resourceDelegate = new MockEngine.GetStringDelegate(AssemblyResources.GetString);
 
         private readonly string _sdkPath = NativeMethodsShared.IsWindows
                                      ? @"c:\SDKDirectory\GoodTestSDK\2.0\"
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 472d732a973..d9d911b6c5e 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -287,7 +287,7 @@ public void ForceOutOfDate()
                 t2.Sources = new ITaskItem[] { new TaskItem(resxFile) };
 
                 DateTime time = File.GetLastWriteTime(t.OutputResources[0].ItemSpec);
-                System.Threading.Thread.Sleep(200);
+                Thread.Sleep(200);
                 File.SetLastWriteTime(resxFile, DateTime.Now);
 
                 Utilities.ExecuteTask(t2);
@@ -337,7 +337,7 @@ public void ForceOutOfDateLinked()
                 t2.Sources = new ITaskItem[] { new TaskItem(resxFile) };
 
                 DateTime time = File.GetLastWriteTime(t.OutputResources[0].ItemSpec);
-                System.Threading.Thread.Sleep(200);
+                Thread.Sleep(200);
                 File.SetLastWriteTime(bitmap, DateTime.Now);
 
                 Utilities.ExecuteTask(t2);
@@ -391,7 +391,7 @@ public void ForceSomeOutOfDate()
                 t2.StateFile = new TaskItem(createResources.StateFile.ItemSpec);
                 t2.Sources = new ITaskItem[] { new TaskItem(firstResx), new TaskItem(secondResx) };
 
-                System.Threading.Thread.Sleep(200);
+                Thread.Sleep(200);
                 _output.WriteLine("Touch one input");
                 File.SetLastWriteTime(firstResx, DateTime.Now);
 
@@ -465,7 +465,7 @@ public void AllowLinkedNoGenerate()
                 t2.StateFile = new TaskItem(t.StateFile);
                 t2.Sources = new ITaskItem[] { new TaskItem(resxFile) };
 
-                System.Threading.Thread.Sleep(200);
+                Thread.Sleep(200);
 
                 Utilities.ExecuteTask(t2);
 
@@ -524,7 +524,7 @@ public void NothingOutOfDate()
 
                 DateTime time = File.GetLastWriteTime(t.OutputResources[0].ItemSpec);
                 DateTime time2 = File.GetLastWriteTime(t.OutputResources[1].ItemSpec);
-                System.Threading.Thread.Sleep(200);
+                Thread.Sleep(200);
 
                 Utilities.ExecuteTask(t2);
                 // Although everything was up to date, OutputResources and FilesWritten
@@ -3133,7 +3133,7 @@ public void ResgenCommandLineExceedsAllowedLength()
                 // the 28,000 command line max length limit in order to validate that resgen is behaving properly in that scenario
                 for (int x = 0; x < filesToBeCreated; x++)
                 {
-                    string fileName = new String('c', 133) + String.Format("{0:00}", x);
+                    string fileName = new String('c', 133) + String.Format(/*lang=json*/ "{0:00}", x);
                     string resxFile = MyResxFileCreator(tempFolder, fileName);
                     string resourcesFile = Path.ChangeExtension(fileName, ".resources");
                     sources.Add(new TaskItem(resxFile));
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 458fc147f78..fea43aeb859 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -3861,7 +3861,7 @@ public static string CreateBasicResourcesFile(bool useResX, ITestOutputHelper ou
             t.Sources = new ITaskItem[] { new TaskItem(sourceFile) };
 
             // phase 1, generate the .resources file (we don't care about outcomes)
-            Utilities.ExecuteTask(t);
+            ExecuteTask(t);
 
             File.Delete(sourceFile);
             return t.OutputResources[0].ItemSpec;
@@ -4002,7 +4002,7 @@ public static string GetTestTextContent(string tagName, string oneLine, bool cle
         /// </summary>
         public static string WriteTestText(string tagName, string oneLine)
         {
-            string textFile = Utilities.GetTempFileName(".txt");
+            string textFile = GetTempFileName(".txt");
             File.Delete(textFile);
             File.WriteAllText(textFile, GetTestTextContent(tagName, oneLine));
             return textFile;
@@ -4133,7 +4133,7 @@ public static string WriteTestResX(bool useType, string linkedBitmap, string ext
         /// <returns>The name of the copied file.</returns>
         public static string GetPathToCopiedSystemDLL()
         {
-            string tempSystemDLL = Utilities.GetTempFileName(".dll");
+            string tempSystemDLL = GetTempFileName(".dll");
 
             string pathToSystemDLL =
 #if FEATURE_INSTALLED_MSBUILD
@@ -4152,7 +4152,7 @@ public static string GetPathToCopiedSystemDLL()
         /// <returns>The name of the bitmap.</returns>
         public static string CreateWorldsSmallestBitmap()
         {
-            string smallestBitmapFile = Utilities.GetTempFileName(".bmp");
+            string smallestBitmapFile = GetTempFileName(".bmp");
 
             byte[] bmp = new byte[66];
             bmp[0x00] = 0x42; bmp[0x01] = 0x4D; bmp[0x02] = 0x42;
@@ -4204,12 +4204,12 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
             Assert.NotNull(strLanguage);
             Assert.NotNull(resourcesNamespace);
             // Generate Task
-            GenerateResource t = Utilities.CreateTask(output);
+            GenerateResource t = CreateTask(output);
             try
             {
-                t.StateFile = new TaskItem(Utilities.GetTempFileName(".cache"));
+                t.StateFile = new TaskItem(GetTempFileName(".cache"));
                 // Create an input text file
-                string textFile = Utilities.WriteTestText(null, null);
+                string textFile = WriteTestText(null, null);
                 // set the Sources parameter
                 t.Sources = new ITaskItem[] { new TaskItem(textFile) };
                 // Set the StronglyTypedLanguage parameter
@@ -4231,7 +4231,7 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
                 }
 
                 // Execute task
-                Utilities.ExecuteTask(t);
+                ExecuteTask(t);
 
                 // Get the OutputResources
                 string resourcesFile = t.OutputResources[0].ItemSpec;
@@ -4250,7 +4250,7 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
                 resourcesFile = t.FilesWritten[0].ItemSpec;
                 Assert.Equal(".resources", Path.GetExtension(resourcesFile));
 
-                Utilities.AssertStateFileWasWritten(t);
+                AssertStateFileWasWritten(t);
 
                 // Files written should contain STR class file
                 Assert.Equal(Path.ChangeExtension(t.Sources[0].ItemSpec, codeFileExtension), t.StronglyTypedFileName);
@@ -4262,20 +4262,20 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
                 // Verify that the STR File was generated correctly
                 string STRFile = Path.ChangeExtension(textFile, codeFileExtension);
                 // Verify that the ResourceManager in the STR class is instantiated correctly
-                Assert.Contains("ResourceManager(\"" + resourcesNamespace + "." + t.StronglyTypedClassName, Utilities.ReadFileContent(STRFile));
+                Assert.Contains("ResourceManager(\"" + resourcesNamespace + "." + t.StronglyTypedClassName, ReadFileContent(STRFile));
                 // Verify that the class name of the STR class is as expected
-                Assert.Contains("class " + Path.GetFileNameWithoutExtension(textFile).ToLower(), Utilities.ReadFileContent(STRFile).ToLower());
+                Assert.Contains("class " + Path.GetFileNameWithoutExtension(textFile).ToLower(), ReadFileContent(STRFile).ToLower());
                 // Verify that the namespace of the STR class is as expected
 
-                Assert.DoesNotContain("namespace " + resourcesNamespace.ToLower(), Utilities.ReadFileContent(STRFile).ToLower());
+                Assert.DoesNotContain("namespace " + resourcesNamespace.ToLower(), ReadFileContent(STRFile).ToLower());
                 if (classNamespace != null)
                 {
-                    Assert.Contains("namespace " + classNamespace.ToLower(), Utilities.ReadFileContent(STRFile).ToLower());
+                    Assert.Contains("namespace " + classNamespace.ToLower(), ReadFileContent(STRFile).ToLower());
                 }
 
                 // Verify log is as expected
-                Utilities.AssertLogContainsResource(t, "GenerateResource.ProcessingFile", textFile, resourcesFile);
-                Utilities.AssertLogContainsResource(t, "GenerateResource.ReadResourceMessage", 4, textFile);
+                AssertLogContainsResource(t, "GenerateResource.ProcessingFile", textFile, resourcesFile);
+                AssertLogContainsResource(t, "GenerateResource.ReadResourceMessage", 4, textFile);
 
                 string typeName;
                 if (t.StronglyTypedNamespace != null)
@@ -4289,7 +4289,7 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
 
                 typeName += t.StronglyTypedClassName;
                 // Verify that the type is generated correctly
-                Utilities.AssertLogContainsResource(t, "GenerateResource.CreatingSTR", t.StronglyTypedFileName);
+                AssertLogContainsResource(t, "GenerateResource.CreatingSTR", t.StronglyTypedFileName);
             }
             finally
             {
@@ -4329,7 +4329,7 @@ internal sealed class CommandLineBuilderHelper : CommandLineBuilder
         /// <returns>true, if given path needs to be quoted.</returns>
         internal bool DoesPathNeedQuotes(string path)
         {
-            return base.IsQuotingRequired(path);
+            return IsQuotingRequired(path);
         }
     }
 }
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index a77f9d5759e..d6367a6300e 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -775,7 +775,7 @@ private void TryLoadTaskBodyAndExpectFailure(string taskBody, string expectedErr
 
             TaskLoggingHelper log = new TaskLoggingHelper(buildEngine, TaskName)
             {
-                TaskResources = Shared.AssemblyResources.PrimaryResources
+                TaskResources = AssemblyResources.PrimaryResources
             };
 
             bool success = RoslynCodeTaskFactory.TryLoadTaskBody(log, TaskName, taskBody, new List<TaskPropertyInfo>(), out RoslynCodeTaskFactoryTaskInfo _);
@@ -801,7 +801,7 @@ private void TryLoadTaskBodyAndExpectSuccess(
 
             TaskLoggingHelper log = new TaskLoggingHelper(buildEngine, TaskName)
             {
-                TaskResources = Shared.AssemblyResources.PrimaryResources
+                TaskResources = AssemblyResources.PrimaryResources
             };
 
             bool success = RoslynCodeTaskFactory.TryLoadTaskBody(log, TaskName, taskBody, parameters ?? new List<TaskPropertyInfo>(), out RoslynCodeTaskFactoryTaskInfo taskInfo);
diff --git a/src/Tasks.UnitTests/SGen_Tests.cs b/src/Tasks.UnitTests/SGen_Tests.cs
index 75b712a53a7..ded4b021d43 100644
--- a/src/Tasks.UnitTests/SGen_Tests.cs
+++ b/src/Tasks.UnitTests/SGen_Tests.cs
@@ -50,7 +50,7 @@ internal sealed class SGenExtension : SGen
         {
             internal string CommandLine()
             {
-                return base.GenerateCommandLineCommands();
+                return GenerateCommandLineCommands();
             }
         }
 
diff --git a/src/Tasks.UnitTests/StreamMappedString_Tests.cs b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
index 2830548cab6..c2105f37c27 100644
--- a/src/Tasks.UnitTests/StreamMappedString_Tests.cs
+++ b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
@@ -320,7 +320,7 @@ public override int Read(byte[] buffer, int offset, int count)
             public override long Seek(long offset, SeekOrigin origin)
             {
                 ++_resetCount;
-                return this.Seek(offset, origin);
+                return Seek(offset, origin);
             }
 
             public override void SetLength(long value)
diff --git a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs
index 233af2b505c..879198ad024 100644
--- a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs
+++ b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs
@@ -1,8 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Resources;
 using System.Reflection;
+using System.Resources;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 
diff --git a/src/Tasks.UnitTests/Touch_Tests.cs b/src/Tasks.UnitTests/Touch_Tests.cs
index 7f6da5b32ee..8b0ef9c7380 100644
--- a/src/Tasks.UnitTests/Touch_Tests.cs
+++ b/src/Tasks.UnitTests/Touch_Tests.cs
@@ -16,12 +16,12 @@ namespace Microsoft.Build.UnitTests
 {
     public sealed class Touch_Tests
     {
-        internal static Microsoft.Build.Shared.FileExists fileExists = new Microsoft.Build.Shared.FileExists(FileExists);
-        internal static Microsoft.Build.Shared.FileCreate fileCreate = new Microsoft.Build.Shared.FileCreate(FileCreate);
-        internal static Microsoft.Build.Tasks.GetAttributes fileGetAttributes = new Microsoft.Build.Tasks.GetAttributes(GetAttributes);
-        internal static Microsoft.Build.Tasks.SetAttributes fileSetAttributes = new Microsoft.Build.Tasks.SetAttributes(SetAttributes);
-        internal static Microsoft.Build.Tasks.SetLastAccessTime setLastAccessTime = new Microsoft.Build.Tasks.SetLastAccessTime(SetLastAccessTime);
-        internal static Microsoft.Build.Tasks.SetLastWriteTime setLastWriteTime = new Microsoft.Build.Tasks.SetLastWriteTime(SetLastWriteTime);
+        internal static FileExists fileExists = new FileExists(FileExists);
+        internal static FileCreate fileCreate = new FileCreate(FileCreate);
+        internal static GetAttributes fileGetAttributes = new GetAttributes(GetAttributes);
+        internal static SetAttributes fileSetAttributes = new SetAttributes(SetAttributes);
+        internal static SetLastAccessTime setLastAccessTime = new SetLastAccessTime(SetLastAccessTime);
+        internal static SetLastWriteTime setLastWriteTime = new SetLastWriteTime(SetLastWriteTime);
 
         internal static string myexisting_txt = NativeMethodsShared.IsWindows ? @"c:\touch\myexisting.txt" : @"/touch/myexisting.txt";
         internal static string mynonexisting_txt = NativeMethodsShared.IsWindows ? @"c:\touch\mynonexisting.txt" : @"/touch/mynonexisting.txt";
@@ -111,7 +111,7 @@ private static FileAttributes GetAttributes(string path)
 
             if (path == myreadonly_txt)
             {
-                return System.IO.FileAttributes.ReadOnly;
+                return FileAttributes.ReadOnly;
             }
 
             Assert.Fail("Unexpected file attributes: " + path);
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index b7aa4258a25..9e3ee5b8b13 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -603,7 +603,7 @@ public void BadXsltFile()
         [Fact]
         public void MissingOutputFile()
         {
-            Assert.Throws<System.ArgumentNullException>(() =>
+            Assert.Throws<ArgumentNullException>(() =>
             {
                 string dir;
                 TaskItem[] xmlPaths;
diff --git a/src/Tasks/AppConfig/AppConfigException.cs b/src/Tasks/AppConfig/AppConfigException.cs
index b059713b9da..46c2d99a46d 100644
--- a/src/Tasks/AppConfig/AppConfigException.cs
+++ b/src/Tasks/AppConfig/AppConfigException.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     [Serializable]
     internal class AppConfigException :
-        System.ApplicationException
+        ApplicationException
     {
         /// <summary>
         /// The name of the app.config file.
@@ -56,7 +56,7 @@ internal int Column
         /// <summary>
         /// Construct the exception.
         /// </summary>
-        public AppConfigException(string message, string fileName, int line, int column, System.Exception inner) : base(message, inner)
+        public AppConfigException(string message, string fileName, int line, int column, Exception inner) : base(message, inner)
         {
             this.fileName = fileName;
             this.line = line;
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index 49ba2302654..8b9ed65dbbe 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -121,7 +121,7 @@ private void LazyInitialize()
             _isInitialized = true;
 
             // Crack the search path just one time.
-            Match match = s_crackAssemblyFoldersExSentinel.Value.Match(this.searchPathElement);
+            Match match = s_crackAssemblyFoldersExSentinel.Value.Match(searchPathElement);
             _wasMatch = false;
 
             if (match.Success)
@@ -162,7 +162,7 @@ private void LazyInitialize()
                     _wasMatch = true;
 
                     bool useCache = Environment.GetEnvironmentVariable("MSBUILDDISABLEASSEMBLYFOLDERSEXCACHE") == null;
-                    string key = "ca22615d-aa83-444b-80b9-b32f3d5db097" + this.searchPathElement;
+                    string key = "ca22615d-aa83-444b-80b9-b32f3d5db097" + searchPathElement;
                     if (useCache && _buildEngine != null)
                     {
                         _assemblyFoldersCache = _buildEngine.GetRegisteredTaskObject(key, RegisteredTaskObjectLifetime.Build) as AssemblyFoldersExCache;
@@ -170,7 +170,7 @@ private void LazyInitialize()
 
                     if (_assemblyFoldersCache == null)
                     {
-                        AssemblyFoldersEx assemblyFolders = new AssemblyFoldersEx(_registryKeyRoot, _targetRuntimeVersion, _registryKeySuffix, _osVersion, _platform, _getRegistrySubKeyNames, _getRegistrySubKeyDefaultValue, this.targetProcessorArchitecture, _openBaseKey);
+                        AssemblyFoldersEx assemblyFolders = new AssemblyFoldersEx(_registryKeyRoot, _targetRuntimeVersion, _registryKeySuffix, _osVersion, _platform, _getRegistrySubKeyNames, _getRegistrySubKeyDefaultValue, targetProcessorArchitecture, _openBaseKey);
                         _assemblyFoldersCache = new AssemblyFoldersExCache(assemblyFolders, fileExists);
                         if (useCache)
                         {
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index 4208cf4c72e..33650aac24d 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -97,7 +97,7 @@ private void LazyInitialize()
             _isInitialized = true;
 
             // Crack the search path just one time.
-            Match match = s_crackAssemblyFoldersFromConfigSentinel.Value.Match(this.searchPathElement);
+            Match match = s_crackAssemblyFoldersFromConfigSentinel.Value.Match(searchPathElement);
             _wasMatch = false;
 
             if (match.Success)
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 99307761f8f..289254fe887 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -3,14 +3,14 @@
 
 using System;
 using System.Collections.Generic;
+using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Xml;
 using System.Xml.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using System.IO;
-using System.Xml;
 
 #nullable disable
 
@@ -117,7 +117,7 @@ public override bool Execute()
                         writeOutput = false;
                     }
                 }
-                catch (System.Xml.XmlException)
+                catch (XmlException)
                 {
                     writeOutput = true;
                 }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 9e3b0c07d36..07637f8fdf6 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -258,7 +258,7 @@ internal ReferenceTable(
             ITaskItem[] resolvedSDKItems,
             string[] frameworkPaths,
             InstalledAssemblies installedAssemblies,
-            System.Reflection.ProcessorArchitecture targetProcessorArchitecture,
+            SystemProcessorArchitecture targetProcessorArchitecture,
             FileExists fileExists,
             DirectoryExists directoryExists,
             GetDirectories getDirectories,
@@ -319,7 +319,7 @@ internal ReferenceTable(
             _assemblyMetadataCache = assemblyMetadataCache;
 
             // Set condition for when to check assembly version against the target framework version
-            _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? ReferenceTable.s_targetFrameworkVersion_40) <= ReferenceTable.s_targetFrameworkVersion_40);
+            _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? s_targetFrameworkVersion_40) <= s_targetFrameworkVersion_40);
 
             // Convert the list of installed SDK's to a dictionary for faster lookup
             _resolvedSDKReferences = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
@@ -1027,7 +1027,7 @@ private void GetUnifiedAssemblyMetadata(
                 _assemblyMetadataCache,
                 out AssemblyNameExtension[] dependentAssemblies,
                 out scatterFiles,
-                out FrameworkName frameworkName);
+                out FrameworkNameVersioning frameworkName);
 
             reference.FrameworkNameAttribute = frameworkName;
 
@@ -2027,7 +2027,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
                         }
                         else
                         {
-                            referenceAssemblyDirectories = GetHighestVersionReferenceAssemblyDirectories(targetFrameworkMoniker, out FrameworkName highestFrameworkName);
+                            referenceAssemblyDirectories = GetHighestVersionReferenceAssemblyDirectories(targetFrameworkMoniker, out FrameworkNameVersioning highestFrameworkName);
                             if (highestFrameworkName != null)
                             {
                                 otherFrameworkName = highestFrameworkName.FullName;
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index b331aeb86be..0aed61f1392 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -252,7 +252,7 @@ public string WarnOrErrorOnTargetArchitectureMismatch
 
             set
             {
-                if (!Enum.TryParse<WarnOrErrorOnTargetArchitectureMismatchBehavior>(value, /*ignoreCase*/true, out _warnOrErrorOnTargetArchitectureMismatch))
+                if (!Enum.TryParse(value, /*ignoreCase*/true, out _warnOrErrorOnTargetArchitectureMismatch))
                 {
                     _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
                 }
@@ -1215,7 +1215,7 @@ quiet at the engine level.
                                         assemblyIdentityAttributes.Add(new XAttribute("culture", String.IsNullOrEmpty(idealRemappingPartialAssemblyName.CultureName) ? "neutral" : idealRemappingPartialAssemblyName.CultureName));
 
                                         var publicKeyToken = idealRemappingPartialAssemblyName.GetPublicKeyToken();
-                                        assemblyIdentityAttributes.Add(new XAttribute("publicKeyToken", ResolveAssemblyReference.ByteArrayToString(publicKeyToken)));
+                                        assemblyIdentityAttributes.Add(new XAttribute("publicKeyToken", ByteArrayToString(publicKeyToken)));
 
                                         var node = new XElement(
                                             ns + "assemblyBinding",
@@ -2045,7 +2045,7 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
                     break;
             }
         }
-#endregion
+        #endregion
 
         #region StateFile
         /// <summary>
@@ -2053,7 +2053,7 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
         /// </summary>
         internal void ReadStateFile(FileExists fileExists)
         {
-            _cache = SystemState.DeserializeCache<SystemState>(_stateFile, Log);
+            _cache = StateFileBase.DeserializeCache<SystemState>(_stateFile, Log);
 
             // Construct the cache only if we can't find any caches.
             if (_cache == null && AssemblyInformationCachePaths != null && AssemblyInformationCachePaths.Length > 0)
@@ -2577,8 +2577,8 @@ internal bool Execute(
                         }
                     }
 
-                    this.DependsOnSystemRuntime = useSystemRuntime.ToString();
-                    this.DependsOnNETStandard = useNetStandard.ToString();
+                    DependsOnSystemRuntime = useSystemRuntime.ToString();
+                    DependsOnNETStandard = useNetStandard.ToString();
 
                     WriteStateFile();
 
@@ -2605,7 +2605,7 @@ internal bool Execute(
                                 {
                                     assemblyName = getAssemblyName(item.ItemSpec);
                                 }
-                                catch (System.IO.FileLoadException)
+                                catch (FileLoadException)
                                 {
                                     // Its pretty hard to get here, you need an assembly that contains a valid reference
                                     // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
@@ -2613,7 +2613,7 @@ internal bool Execute(
 
                                     // ...falling through and relying on the targetAssemblyName==null behavior below...
                                 }
-                                catch (System.IO.FileNotFoundException)
+                                catch (FileNotFoundException)
                                 {
                                     // Its pretty hard to get here, also since we do a file existence check right before calling this method so it can only happen if the file got deleted between that check and this call.
                                 }
@@ -3137,23 +3137,23 @@ internal static string ProcessorArchitectureToString(SystemProcessorArchitecture
         {
             if (SystemProcessorArchitecture.Amd64 == processorArchitecture)
             {
-                return Microsoft.Build.Utilities.ProcessorArchitecture.AMD64;
+                return Utilities.ProcessorArchitecture.AMD64;
             }
             else if (SystemProcessorArchitecture.IA64 == processorArchitecture)
             {
-                return Microsoft.Build.Utilities.ProcessorArchitecture.IA64;
+                return Utilities.ProcessorArchitecture.IA64;
             }
             else if (SystemProcessorArchitecture.MSIL == processorArchitecture)
             {
-                return Microsoft.Build.Utilities.ProcessorArchitecture.MSIL;
+                return Utilities.ProcessorArchitecture.MSIL;
             }
             else if (SystemProcessorArchitecture.X86 == processorArchitecture)
             {
-                return Microsoft.Build.Utilities.ProcessorArchitecture.X86;
+                return Utilities.ProcessorArchitecture.X86;
             }
             else if (SystemProcessorArchitecture.Arm == processorArchitecture)
             {
-                return Microsoft.Build.Utilities.ProcessorArchitecture.ARM;
+                return Utilities.ProcessorArchitecture.ARM;
             }
             return String.Empty;
         }
@@ -3163,27 +3163,27 @@ internal static SystemProcessorArchitecture TargetProcessorArchitectureToEnumera
         {
             if (targetedProcessorArchitecture != null)
             {
-                if (targetedProcessorArchitecture.Equals(Microsoft.Build.Utilities.ProcessorArchitecture.AMD64, StringComparison.OrdinalIgnoreCase))
+                if (targetedProcessorArchitecture.Equals(Utilities.ProcessorArchitecture.AMD64, StringComparison.OrdinalIgnoreCase))
                 {
                     return SystemProcessorArchitecture.Amd64;
                 }
-                else if (targetedProcessorArchitecture.Equals(Microsoft.Build.Utilities.ProcessorArchitecture.IA64, StringComparison.OrdinalIgnoreCase))
+                else if (targetedProcessorArchitecture.Equals(Utilities.ProcessorArchitecture.IA64, StringComparison.OrdinalIgnoreCase))
                 {
                     return SystemProcessorArchitecture.IA64;
                 }
-                else if (targetedProcessorArchitecture.Equals(Microsoft.Build.Utilities.ProcessorArchitecture.MSIL, StringComparison.OrdinalIgnoreCase))
+                else if (targetedProcessorArchitecture.Equals(Utilities.ProcessorArchitecture.MSIL, StringComparison.OrdinalIgnoreCase))
                 {
                     return SystemProcessorArchitecture.MSIL;
                 }
-                else if (targetedProcessorArchitecture.Equals(Microsoft.Build.Utilities.ProcessorArchitecture.X86, StringComparison.OrdinalIgnoreCase))
+                else if (targetedProcessorArchitecture.Equals(Utilities.ProcessorArchitecture.X86, StringComparison.OrdinalIgnoreCase))
                 {
                     return SystemProcessorArchitecture.X86;
                 }
-                else if (targetedProcessorArchitecture.Equals(Microsoft.Build.Utilities.ProcessorArchitecture.ARM, StringComparison.OrdinalIgnoreCase))
+                else if (targetedProcessorArchitecture.Equals(Utilities.ProcessorArchitecture.ARM, StringComparison.OrdinalIgnoreCase))
                 {
                     return SystemProcessorArchitecture.Arm;
                 }
-                else if (targetedProcessorArchitecture.Equals(Microsoft.Build.Utilities.ProcessorArchitecture.ARM64, StringComparison.OrdinalIgnoreCase))
+                else if (targetedProcessorArchitecture.Equals(Utilities.ProcessorArchitecture.ARM64, StringComparison.OrdinalIgnoreCase))
                 {
                     return (SystemProcessorArchitecture)6;
                 }
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index 5cebad377ce..ba2a6a1d89d 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -61,7 +61,7 @@ protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, Fi
             this.fileExists = fileExists;
             this.getRuntimeVersion = getRuntimeVersion;
             this.targetedRuntimeVersion = targetedRuntimeVersion;
-            this.targetProcessorArchitecture = targetedProcessorArchitecture;
+            targetProcessorArchitecture = targetedProcessorArchitecture;
             this.compareProcessorArchitecture = compareProcessorArchitecture;
         }
 
diff --git a/src/Tasks/AssemblyInfo.cs b/src/Tasks/AssemblyInfo.cs
index 2fefd520e31..fe8a43da643 100644
--- a/src/Tasks/AssemblyInfo.cs
+++ b/src/Tasks/AssemblyInfo.cs
@@ -10,7 +10,7 @@
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
 // this assembly.  We should specify this explicitly, as opposed to letting
 // tlbexp just pick whatever it wants.
-[assembly: GuidAttribute("E3D4D3B9-944C-407b-A82E-B19719EA7FB3")]
+[assembly: Guid("E3D4D3B9-944C-407b-A82E-B19719EA7FB3")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
diff --git a/src/Tasks/BootstrapperUtil/Interfaces.cs b/src/Tasks/BootstrapperUtil/Interfaces.cs
index 2214a9f69c4..3a892b8a994 100644
--- a/src/Tasks/BootstrapperUtil/Interfaces.cs
+++ b/src/Tasks/BootstrapperUtil/Interfaces.cs
@@ -224,7 +224,7 @@ public interface IProductBuilderCollection
     /// </summary>
     [ComVisible(true)]
     [Guid("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
-    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
+    [InterfaceType(ComInterfaceType.InterfaceIsDual)]
     public interface IBuildResults
     {
         /// <summary>
diff --git a/src/Tasks/ComDependencyWalker.cs b/src/Tasks/ComDependencyWalker.cs
index a0cdd95b2cd..4020592ed6a 100644
--- a/src/Tasks/ComDependencyWalker.cs
+++ b/src/Tasks/ComDependencyWalker.cs
@@ -60,8 +60,8 @@ private struct AnalyzedTypesInfoKey
             public AnalyzedTypesInfoKey(Guid guid, short major, short minor, int lcid, int index)
             {
                 this.guid = guid;
-                this.wMajorVerNum = major;
-                this.wMinorVerNum = minor;
+                wMajorVerNum = major;
+                wMinorVerNum = minor;
                 this.lcid = lcid;
                 this.index = index;
             }
@@ -69,8 +69,8 @@ public AnalyzedTypesInfoKey(Guid guid, short major, short minor, int lcid, int i
             public override readonly string ToString()
             {
                 return string.Format(CultureInfo.InvariantCulture, "{0}.{1}.{2}.{3}:{4}",
-                    this.guid, this.wMajorVerNum,
-                    this.wMinorVerNum, this.lcid, this.index);
+                    guid, wMajorVerNum,
+                    wMinorVerNum, lcid, index);
             }
         }
 
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index 8a9aadf3e49..75cef57d41c 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -85,7 +85,7 @@ internal class ComReferenceInfo
         /// </summary>
         internal ComReferenceInfo()
         {
-            this.dependentWrapperPaths = new List<string>();
+            dependentWrapperPaths = new List<string>();
         }
 
         /// <summary>
@@ -93,16 +93,16 @@ internal ComReferenceInfo()
         /// </summary>
         internal ComReferenceInfo(ComReferenceInfo copyFrom)
         {
-            this.attr = copyFrom.attr;
-            this.typeLibName = copyFrom.typeLibName;
-            this.strippedTypeLibPath = copyFrom.strippedTypeLibPath;
-            this.fullTypeLibPath = copyFrom.fullTypeLibPath;
-            this.typeLibPointer = copyFrom.typeLibPointer;
-            this.primaryOfAxImpRef = copyFrom.primaryOfAxImpRef;
-            this.resolvedWrapper = copyFrom.resolvedWrapper;
-            this.taskItem = new TaskItem(copyFrom.taskItem);
-            this.dependentWrapperPaths = copyFrom.dependentWrapperPaths;
-            this.referencePathItem = copyFrom.referencePathItem;
+            attr = copyFrom.attr;
+            typeLibName = copyFrom.typeLibName;
+            strippedTypeLibPath = copyFrom.strippedTypeLibPath;
+            fullTypeLibPath = copyFrom.fullTypeLibPath;
+            typeLibPointer = copyFrom.typeLibPointer;
+            primaryOfAxImpRef = copyFrom.primaryOfAxImpRef;
+            resolvedWrapper = copyFrom.resolvedWrapper;
+            taskItem = new TaskItem(copyFrom.taskItem);
+            dependentWrapperPaths = copyFrom.dependentWrapperPaths;
+            referencePathItem = copyFrom.referencePathItem;
         }
 
         #endregion
@@ -119,14 +119,14 @@ internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYP
             ComReference.RemapAdoTypeLib(log, silent, ref remappableTlbAttr);
 
             // for attribute references, the path is not specified, so we need to get it from the registry
-            if (!ComReference.GetPathOfTypeLib(log, silent, ref remappableTlbAttr, out this.fullTypeLibPath))
+            if (!ComReference.GetPathOfTypeLib(log, silent, ref remappableTlbAttr, out fullTypeLibPath))
             {
                 return false;
             }
 
             // Now that we have the path, we can call InitializeWithPath to get the correct TYPELIBATTR set up
             // and the correct ITypeLib pointer.
-            return InitializeWithPath(log, silent, this.fullTypeLibPath, originalTaskItem, targetProcessorArchitecture);
+            return InitializeWithPath(log, silent, fullTypeLibPath, originalTaskItem, targetProcessorArchitecture);
         }
 
         /// <summary>
@@ -136,7 +136,7 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
         {
             ErrorUtilities.VerifyThrowArgumentNull(path);
 
-            this.taskItem = originalTaskItem;
+            taskItem = originalTaskItem;
 
             // Note that currently we DO NOT remap file ADO references. This is because when pointing to a file on disk,
             // it seems unnatural to remap it to something else - a file reference means "use THIS component".
@@ -145,24 +145,24 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
             // save both the stripped and full path in our object -- for the most part we just need the stripped path, but if
             // we're using tlbimp.exe, we need to pass the full path w/ type lib number to it, or it won't generate the interop
             // assembly correctly.
-            this.fullTypeLibPath = path;
-            this.strippedTypeLibPath = ComReference.StripTypeLibNumberFromPath(path, File.Exists);
+            fullTypeLibPath = path;
+            strippedTypeLibPath = ComReference.StripTypeLibNumberFromPath(path, File.Exists);
 
             // use the unstripped path to actually load the library
             switch (targetProcessorArchitecture)
             {
                 case ProcessorArchitecture.AMD64:
                 case ProcessorArchitecture.IA64:
-                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE | (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_64BIT);
+                    typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE | (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_64BIT);
                     break;
                 case ProcessorArchitecture.X86:
-                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE | (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_32BIT);
+                    typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE | (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_32BIT);
                     break;
                 case ProcessorArchitecture.ARM:
                 case ProcessorArchitecture.MSIL:
                 default:
                     // Transmit the flag directly from the .targets files and rely on tlbimp.exe to produce a good error message.
-                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE);
+                    typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE);
                     break;
             }
 
@@ -170,15 +170,15 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
             {
                 // get the type lib attributes from the retrieved interface pointer.
                 // do NOT remap file ADO references, since we'd end up with a totally different reference than specified.
-                ComReference.GetTypeLibAttrForTypeLib(ref this.typeLibPointer, out this.attr);
+                ComReference.GetTypeLibAttrForTypeLib(ref typeLibPointer, out attr);
 
                 // get the type lib name from the retrieved interface pointer
                 if (!ComReference.GetTypeLibNameForITypeLib(
                     log,
                     silent,
-                    this.typeLibPointer,
+                    typeLibPointer,
                     GetTypeLibId(log),
-                    out this.typeLibName))
+                    out typeLibName))
                 {
                     ReleaseTypeLibPtr();
                     return false;
diff --git a/src/Tasks/ComReferenceTypes.cs b/src/Tasks/ComReferenceTypes.cs
index e7fcdbe3b61..1a72dd4e73d 100644
--- a/src/Tasks/ComReferenceTypes.cs
+++ b/src/Tasks/ComReferenceTypes.cs
@@ -22,7 +22,7 @@ internal static class ComReferenceTypes
         /// </summary>
         internal static bool IsTlbImp(string refType)
         {
-            return string.Equals(refType, ComReferenceTypes.tlbimp, StringComparison.OrdinalIgnoreCase);
+            return string.Equals(refType, tlbimp, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -30,7 +30,7 @@ internal static bool IsTlbImp(string refType)
         /// </summary>
         internal static bool IsAxImp(string refType)
         {
-            return string.Equals(refType, ComReferenceTypes.aximp, StringComparison.OrdinalIgnoreCase);
+            return string.Equals(refType, aximp, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -38,7 +38,7 @@ internal static bool IsAxImp(string refType)
         /// </summary>
         internal static bool IsPia(string refType)
         {
-            return string.Equals(refType, ComReferenceTypes.primary, StringComparison.OrdinalIgnoreCase);
+            return string.Equals(refType, primary, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -46,7 +46,7 @@ internal static bool IsPia(string refType)
         /// </summary>
         internal static bool IsPiaOrTlbImp(string refType)
         {
-            return string.Equals(refType, ComReferenceTypes.primaryortlbimp, StringComparison.OrdinalIgnoreCase);
+            return string.Equals(refType, primaryortlbimp, StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 3cf26dc3eb4..e206739022e 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -686,7 +686,7 @@ void ProcessPartition()
                 }
                 finally
                 {
-                    int count = System.Threading.Interlocked.Decrement(ref activeCopyThreads);
+                    int count = Interlocked.Decrement(ref activeCopyThreads);
                     if (count == 0)
                     {
                         _signalCopyTasksCompleted.Set();
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index b975be5fd5e..33dc62e242d 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -136,7 +136,7 @@ internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         }
 
         internal static bool TryParseHashEncoding(string value, out HashEncoding encoding)
-            => Enum.TryParse<HashEncoding>(value, /*ignoreCase:*/ true, out encoding);
+            => Enum.TryParse(value, /*ignoreCase:*/ true, out encoding);
 
         internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string filePath, CancellationToken ct)
         {
diff --git a/src/Tasks/FileIO/VerifyFileHash.cs b/src/Tasks/FileIO/VerifyFileHash.cs
index 9c3eca7556b..58bd4ce7aa8 100644
--- a/src/Tasks/FileIO/VerifyFileHash.cs
+++ b/src/Tasks/FileIO/VerifyFileHash.cs
@@ -2,9 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-using System.Threading;
 
 #nullable disable
 
diff --git a/src/Tasks/GenerateLauncher.cs b/src/Tasks/GenerateLauncher.cs
index 865e5528331..cda5662f06e 100644
--- a/src/Tasks/GenerateLauncher.cs
+++ b/src/Tasks/GenerateLauncher.cs
@@ -52,7 +52,7 @@ public override bool Execute()
                 // Launcher lives next to ClickOnce bootstrapper.
                 // GetDefaultPath obtains the root ClickOnce boostrapper path.
                 LauncherPath = Path.Combine(
-                    Microsoft.Build.Tasks.Deployment.Bootstrapper.Util.GetDefaultPath(VisualStudioVersion),
+                    Deployment.Bootstrapper.Util.GetDefaultPath(VisualStudioVersion),
                     ENGINE_PATH,
                     LAUNCHER_EXE);
             }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index b7e981bea5f..17c6872fe5f 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -839,8 +839,8 @@ public override bool Execute()
                                         OutputDirectory,
                                         WarnOnBinaryFormatterUse);
 
-                            this.StronglyTypedClassName = process.StronglyTypedClassName; // in case a default was chosen
-                            this.StronglyTypedFileName = process.StronglyTypedFilename;   // in case a default was chosen
+                            StronglyTypedClassName = process.StronglyTypedClassName; // in case a default was chosen
+                            StronglyTypedFileName = process.StronglyTypedFilename;   // in case a default was chosen
                             _stronglyTypedResourceSuccessfullyCreated = process.StronglyTypedResourceSuccessfullyCreated;
                             if (process.UnsuccessfullyCreatedOutFiles != null)
                             {
@@ -1080,7 +1080,7 @@ private bool ComputePathToResGen()
             {
                 _resgenPath = SdkToolsPathUtility.GeneratePathToTool(
                     SdkToolsPathUtility.FileInfoExists,
-                    Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture,
+                    Utilities.ProcessorArchitecture.CurrentProcessArchitecture,
                     SdkToolsPath,
                     "resgen.exe",
                     Log,
@@ -1705,7 +1705,7 @@ private void UpdateNewestUncorrelatedInputWriteTime()
 
             // Check the timestamp of each of the passed-in references to find the newest;
             // and then the additional inputs
-            ITaskItem[] inputs = this.References ?? [.. (this.AdditionalInputs ?? [])];
+            ITaskItem[] inputs = References ?? [.. (AdditionalInputs ?? [])];
 
             foreach (ITaskItem input in inputs)
             {
@@ -2131,9 +2131,9 @@ private void RecordFilesWritten()
         {
             // Add any output resources that were successfully created,
             // or would have been if they weren't already up to date (important for Clean)
-            if (this.OutputResources != null)
+            if (OutputResources != null)
             {
-                foreach (ITaskItem item in this.OutputResources)
+                foreach (ITaskItem item in OutputResources)
                 {
                     _filesWritten.Add(item);
                 }
@@ -2168,7 +2168,7 @@ private void RecordFilesWritten()
                     }
                 }
 
-                _filesWritten.Add(new TaskItem(this.StronglyTypedFileName));
+                _filesWritten.Add(new TaskItem(StronglyTypedFileName));
             }
         }
 
@@ -3440,7 +3440,7 @@ private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, Str
                 {
                     _stronglyTypedFilename = GenerateDefaultStronglyTypedFilename(provider, outFile);
                 }
-                sourceFile = this.StronglyTypedFilename;
+                sourceFile = StronglyTypedFilename;
 
                 _logger.LogMessageFromResources("GenerateResource.CreatingSTR", _stronglyTypedFilename);
 
@@ -4014,7 +4014,7 @@ internal int LinePosition
                 get { return column; }
             }
         }
-#endregion // Code from ResGen.EXE
+        #endregion // Code from ResGen.EXE
     }
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
@@ -4145,7 +4145,7 @@ public Type GetType(string name, bool throwOnError, bool ignoreCase)
                 {
                     foreach (ITaskItem referencePath in _referencePaths)
                     {
-                        Assembly a = this.GetAssemblyByPath(referencePath.ItemSpec, throwOnError);
+                        Assembly a = GetAssemblyByPath(referencePath.ItemSpec, throwOnError);
                         if (a != null)
                         {
                             result = a.GetType(name, false, ignoreCase);
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 34f84047a3f..eabf196bb3b 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -1234,9 +1234,9 @@ public SDKInfo(ITranslator translator) : this()
 
             public SDKInfo(IDictionary<string, SdkReferenceInfo> pathToReferenceMetadata, IDictionary<string, List<string>> directoryToFileList, int cacheHash)
             {
-                this._pathToReferenceMetadata = pathToReferenceMetadata;
-                this._directoryToFileList = directoryToFileList;
-                this._hash = cacheHash;
+                _pathToReferenceMetadata = pathToReferenceMetadata;
+                _directoryToFileList = directoryToFileList;
+                _hash = cacheHash;
             }
 
             /// <summary>
diff --git a/src/Tasks/ManifestUtil/LauncherBuilder.cs b/src/Tasks/ManifestUtil/LauncherBuilder.cs
index c65068ddc1f..de9b2e019a5 100644
--- a/src/Tasks/ManifestUtil/LauncherBuilder.cs
+++ b/src/Tasks/ManifestUtil/LauncherBuilder.cs
@@ -53,7 +53,7 @@ public BuildResults Build(string filename, string outputPath)
                 }
 
                 // Copy setup.bin to the output directory
-                string strOutputExe = System.IO.Path.Combine(outputPath, launcherFilename);
+                string strOutputExe = Path.Combine(outputPath, launcherFilename);
                 if (!CopyLauncherToOutputDirectory(strOutputExe))
                 {
                     // Appropriate messages should have been stuffed into the results already
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 63b307cd6df..e0e48f07f9b 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -293,7 +293,7 @@ private void ResolveFiles_2(string[] searchPaths)
                         // So we use the ReadOnly flag to tell the difference between the two cases...
                         if (_readOnly)
                         {
-                            OutputMessages.AddErrorMessage("GenerateManifest.ResolveFailedInReadOnlyMode", f.ToString(), this.ToString());
+                            OutputMessages.AddErrorMessage("GenerateManifest.ResolveFailedInReadOnlyMode", f.ToString(), ToString());
                         }
                         else
                         {
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index d23e63c0870..8d819306d9f 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -290,7 +290,7 @@ public override XmlElement GetIdElement(XmlDocument document, string idValue)
                 return base.GetIdElement(document, idValue);
             }
 
-            KeyInfo keyInfo = this.KeyInfo;
+            KeyInfo keyInfo = KeyInfo;
             if (keyInfo.Id != idValue)
             {
                 return null;
@@ -462,7 +462,7 @@ private static void RemoveExistingSignature(XmlDocument manifestDom)
         /// <param name="oldCsp"></param>
         /// <param name="useSha256">Whether to use sha256</param>
         /// <returns></returns>
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Cryptographic.Standard", "CA5358:RSAProviderNeeds2048bitKey", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
+        [SuppressMessage("Microsoft.Cryptographic.Standard", "CA5358:RSAProviderNeeds2048bitKey", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
         internal static RSACryptoServiceProvider GetFixedRSACryptoServiceProvider(RSACryptoServiceProvider oldCsp, bool useSha256)
         {
             if (!useSha256)
@@ -556,7 +556,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool useS
             return ComputeHashFromManifest(manifestDom, false, useSha256);
         }
 
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Security", "CA5350:Do Not Use Weak Cryptographic Algorithms", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
+        [SuppressMessage("Security", "CA5350:Do Not Use Weak Cryptographic Algorithms", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
         private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldFormat, bool useSha256)
         {
             if (oldFormat)
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 8c761db013d..7dc39f39221 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -58,8 +58,8 @@ public interface IFixedTypeInfo
         void ReleaseVarDesc(IntPtr pVarDesc);
     }
 
-    [GuidAttribute("00020406-0000-0000-C000-000000000046")]
-    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
+    [Guid("00020406-0000-0000-C000-000000000046")]
+    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     [ComImport]
     internal interface ICreateTypeLib
     {
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 7d8e6acd7ce..7a020ac9036 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -218,7 +218,7 @@ public static RedistList GetFrameworkList20()
             string[] redistListPaths = [];
             if (frameworkVersion20Path != null)
             {
-                redistListPaths = RedistList.GetRedistListPathsFromDisk(frameworkVersion20Path);
+                redistListPaths = GetRedistListPathsFromDisk(frameworkVersion20Path);
             }
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index d8a61ab1579..6ce47b6c121 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -806,11 +806,11 @@ public PublishInfo()
             }
             public PublishInfo(ITaskItem item)
             {
-                this.key = item.ItemSpec?.ToLowerInvariant();
-                this.group = item.GetMetadata("Group");
-                this.state = StringToPublishState(item.GetMetadata("PublishState"));
-                this.includeHash = item.GetMetadata("IncludeHash");
-                this.targetPath = item.GetMetadata(ItemMetadataNames.targetPath);
+                key = item.ItemSpec?.ToLowerInvariant();
+                group = item.GetMetadata("Group");
+                state = StringToPublishState(item.GetMetadata("PublishState"));
+                includeHash = item.GetMetadata("IncludeHash");
+                targetPath = item.GetMetadata(ItemMetadataNames.targetPath);
             }
         }
         #endregion
diff --git a/src/Tasks/ResolveNonMSBuildProjectOutput.cs b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
index 6667c4bb082..dd1570a57cf 100644
--- a/src/Tasks/ResolveNonMSBuildProjectOutput.cs
+++ b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
@@ -145,7 +145,7 @@ public override bool Execute()
             }
             catch (XmlException e)
             {
-                Log.LogErrorWithCodeFromResources("General.ErrorExecutingTask", this.GetType().Name, e.Message);
+                Log.LogErrorWithCodeFromResources("General.ErrorExecutingTask", GetType().Name, e.Message);
                 return false;
             }
 
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 6a1a82c1ced..69a44ce0323 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -551,7 +551,7 @@ internal static List<string> ParseDependsOnSDK(string dependsOnSDK)
         {
             if (!String.IsNullOrEmpty(dependsOnSDK))
             {
-                return dependsOnSDK.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim()).Where(y => y.Length > 0).ToList<string>();
+                return dependsOnSDK.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim()).Where(y => y.Length > 0).ToList();
             }
 
             return new List<string>();
@@ -968,7 +968,7 @@ public bool Equals(SDKReference other)
                     return false;
                 }
 
-                if (Object.ReferenceEquals(other, this))
+                if (ReferenceEquals(other, this))
                 {
                     return true;
                 }
@@ -1124,7 +1124,7 @@ private void GetSDKManifestAttributes()
                 }
                 else
                 {
-                    Enum.TryParse<SDKType>(sdkTypeFromMetadata, out SDKType sdkType);
+                    Enum.TryParse(sdkTypeFromMetadata, out SDKType sdkType);
                     SDKType = sdkType;
                 }
 
@@ -1163,7 +1163,7 @@ private void GetSDKManifestAttributes()
             /// </summary>
             private bool ParseSupportMultipleVersions(string multipleVersionsValue)
             {
-                return !String.IsNullOrEmpty(multipleVersionsValue) && Enum.TryParse<MultipleVersionSupport>(multipleVersionsValue, /*ignoreCase*/true, out _supportsMultipleVersions);
+                return !String.IsNullOrEmpty(multipleVersionsValue) && Enum.TryParse(multipleVersionsValue, /*ignoreCase*/true, out _supportsMultipleVersions);
             }
 
             /// <summary>
diff --git a/src/Tasks/System.Design.cs b/src/Tasks/System.Design.cs
index 15ec2257b17..bb89d71c1ca 100644
--- a/src/Tasks/System.Design.cs
+++ b/src/Tasks/System.Design.cs
@@ -92,13 +92,13 @@ private class MainAssemblyFallbackResourceManager : ResourceManager
         {
             public MainAssemblyFallbackResourceManager(string baseName, Assembly assembly) : base(baseName, assembly)
             {
-                this.FallbackLocation = UltimateResourceFallbackLocation.MainAssembly;
+                FallbackLocation = UltimateResourceFallbackLocation.MainAssembly;
             }
         }
 
         internal SR()
         {
-            _resources = new MainAssemblyFallbackResourceManager("System.Design", this.GetType().Assembly);
+            _resources = new MainAssemblyFallbackResourceManager("System.Design", GetType().Assembly);
         }
 
         private static SR GetLoader()
@@ -132,7 +132,7 @@ public static string GetString(string name, params object[] args)
                 return null;
             }
 
-            string res = sys._resources.GetString(name, SR.Culture);
+            string res = sys._resources.GetString(name, Culture);
 
             if (args?.Length > 0)
             {
@@ -160,7 +160,7 @@ public static string GetString(string name)
                 return null;
             }
 
-            return sys._resources.GetString(name, SR.Culture);
+            return sys._resources.GetString(name, Culture);
         }
 
         public static string GetString(string name, out bool usedFallback)
@@ -178,7 +178,7 @@ public static object GetObject(string name)
                 return null;
             }
 
-            return sys._resources.GetObject(name, SR.Culture);
+            return sys._resources.GetObject(name, Culture);
         }
     }
 }
diff --git a/src/Tasks/TlbReference.cs b/src/Tasks/TlbReference.cs
index 30acc7f8e38..6eb4e953609 100644
--- a/src/Tasks/TlbReference.cs
+++ b/src/Tasks/TlbReference.cs
@@ -375,7 +375,7 @@ Assembly ITypeLibImporterNotifySink.ResolveRef(object objTypeLib)
         {
             // get attributes for our dependent typelib
             ITypeLib typeLib = (ITypeLib)objTypeLib;
-            ComReference.GetTypeLibAttrForTypeLib(ref typeLib, out TYPELIBATTR attr);
+            GetTypeLibAttrForTypeLib(ref typeLib, out TYPELIBATTR attr);
 
             // call our callback to do the dirty work for us
             if (!ResolverCallback.ResolveComClassicReference(attr, base.OutputDirectory, null, null, out ComReferenceWrapperInfo wrapperInfo))
diff --git a/src/Tasks/WinMDExp.cs b/src/Tasks/WinMDExp.cs
index 24fdc5dbff8..cd720059883 100644
--- a/src/Tasks/WinMDExp.cs
+++ b/src/Tasks/WinMDExp.cs
@@ -242,7 +242,7 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
         /// </summary>
         protected override string GenerateFullPathToTool()
         {
-            return SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture, SdkToolsPath, ToolExe, Log, true);
+            return SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, Utilities.ProcessorArchitecture.CurrentProcessArchitecture, SdkToolsPath, ToolExe, Log, true);
         }
 
         /// <summary>
diff --git a/src/UnitTests.Shared/BuildEventArgsExtension.cs b/src/UnitTests.Shared/BuildEventArgsExtension.cs
index ad52cea6b50..d7a56b0a73d 100644
--- a/src/UnitTests.Shared/BuildEventArgsExtension.cs
+++ b/src/UnitTests.Shared/BuildEventArgsExtension.cs
@@ -25,7 +25,7 @@ public static class BuildEventArgsExtension
         /// <returns>True if the object values are identical, false if they are not identical</returns>
         public static bool IsEquivalent(this BuildEventArgs args, BuildEventArgs other)
         {
-            if (Object.ReferenceEquals(args, other))
+            if (ReferenceEquals(args, other))
             {
                 return true;
             }
@@ -343,7 +343,7 @@ public static bool IsEquivalent(TargetFinishedEventArgs args, TargetFinishedEven
             }
 
 
-            if (!Object.ReferenceEquals(args.TargetOutputs, other.TargetOutputs))
+            if (!ReferenceEquals(args.TargetOutputs, other.TargetOutputs))
             {
                 // See if one is null, if so they are not equal
                 if (args.TargetOutputs == null || other.TargetOutputs == null)
diff --git a/src/UnitTests.Shared/DummyMappedDriveUtils.cs b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
index 90f596858d3..143ccb8915b 100644
--- a/src/UnitTests.Shared/DummyMappedDriveUtils.cs
+++ b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
@@ -23,6 +23,6 @@ public static string UpdatePathToMappedDrive(string path, char driveLetter)
 
     public static Lazy<DummyMappedDrive?> GetLazyDummyMappedDrive() => new Lazy<DummyMappedDrive?>(() =>
         {
-            return NativeMethods.IsWindows ? new DummyMappedDrive() : default;
+            return NativeMethodsShared.IsWindows ? new DummyMappedDrive() : default;
         });
 }
diff --git a/src/UnitTests.Shared/LongPathSupportDisabledFactAttribute.cs b/src/UnitTests.Shared/LongPathSupportDisabledFactAttribute.cs
index 7a14d49dd74..31a8c999575 100644
--- a/src/UnitTests.Shared/LongPathSupportDisabledFactAttribute.cs
+++ b/src/UnitTests.Shared/LongPathSupportDisabledFactAttribute.cs
@@ -22,19 +22,19 @@ public LongPathSupportDisabledFactAttribute(string? additionalMessage = null, bo
         {
             if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
             {
-                this.Skip = "This test only runs on Windows and when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+                Skip = "This test only runs on Windows and when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
                 return;
             }
 
             if (fullFrameworkOnly && !CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
             {
-                this.Skip = "This test only runs on full .NET Framework and when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+                Skip = "This test only runs on full .NET Framework and when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
                 return;
             }
 
             if (!NativeMethodsShared.IsMaxPathLegacyWindows())
             {
-                this.Skip = "This test only runs when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+                Skip = "This test only runs when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
             }
         }
     }
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index 375c84d6779..ea09981e137 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -90,7 +90,7 @@ private static bool IsBuiltInItemMetadataName(string metadataName)
             {
                 s_builtInMetadataNames = new Hashtable();
 
-                Utilities.TaskItem dummyTaskItem = new Utilities.TaskItem();
+                TaskItem dummyTaskItem = new TaskItem();
                 foreach (string builtInMetadataName in dummyTaskItem.MetadataNames)
                 {
                     s_builtInMetadataNames[builtInMetadataName] = string.Empty;
@@ -519,7 +519,7 @@ private static List<ITaskItem> ParseExpectedItemsString(string expectedItemsStri
                     int indexOfColon = singleExpectedItemStringTrimmed.IndexOf(": ");
                     if (indexOfColon == -1)
                     {
-                        expectedItems.Add(new Utilities.TaskItem(singleExpectedItemStringTrimmed));
+                        expectedItems.Add(new TaskItem(singleExpectedItemStringTrimmed));
                     }
                     else
                     {
@@ -531,7 +531,7 @@ private static List<ITaskItem> ParseExpectedItemsString(string expectedItemsStri
                         // The metadata is the part after the colon.
                         string itemMetadataString = singleExpectedItemStringTrimmed.Substring(indexOfColon + 1);
 
-                        ITaskItem expectedItem = new Utilities.TaskItem(itemSpec);
+                        ITaskItem expectedItem = new TaskItem(itemSpec);
 
                         string[] itemMetadataPieces = itemMetadataString.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
                         foreach (string itemMetadataPiece in itemMetadataPieces)
@@ -590,7 +590,7 @@ public static void AssertFileExistsInTempProjectDirectory(string fileRelativePat
         /// <returns></returns>
         public static string CleanupFileContents([StringSyntax(StringSyntaxAttribute.Xml)] string projectFileContents)
         {
-            StringBuilder temp = new (projectFileContents);
+            StringBuilder temp = new(projectFileContents);
 
             // Replace reverse-single-quotes with double-quotes.
             temp.Replace('`', '"');
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index e0879c00028..ccefa49156c 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -3,12 +3,12 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.Shared;
 using System.IO;
+using System.Linq;
 using System.Reflection;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Xunit.Abstractions;
-using System.Linq;
 
 #nullable disable
 
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 857e4462047..75ccaa5d5f8 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -1065,7 +1065,7 @@ private sealed class ToolTaskSetsTerminationTimeout : ToolTask
             public ToolTaskSetsTerminationTimeout()
                 : base()
             {
-                base.TaskResources = AssemblyResources.PrimaryResources;
+                TaskResources = AssemblyResources.PrimaryResources;
             }
 
             /// <summary>
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 0ba128f9f33..8ea43807fad 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -2698,7 +2698,7 @@ public void SaveCompactedReadTlog()
             // All the tlogs need to still be there even after compaction
             // It's OK for them to be empty, but their absence might mean a partial clean
             // A missing tlog would mean a clean build
-            Assert.True(Microsoft.Build.Utilities.TrackedDependencies.ItemsExist(tlogs));
+            Assert.True(Utilities.TrackedDependencies.ItemsExist(tlogs));
 
             // There should be no difference in the out of date files after compaction
             CanonicalTrackedInputFiles d1 = new CanonicalTrackedInputFiles(
@@ -2816,7 +2816,7 @@ public void SaveCompactedWriteTlog()
             // All the tlogs need to still be there even after compaction
             // It's OK for them to be empty, but their absence might mean a partial clean
             // A missing tlog would mean a clean build
-            Assert.True(Microsoft.Build.Utilities.TrackedDependencies.ItemsExist(tlogs));
+            Assert.True(Utilities.TrackedDependencies.ItemsExist(tlogs));
 
             // All log information should now be in the tlog[0]
             ITaskItem[] tlogs2 = {
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 598b9539c43..d7fcd0bf847 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -449,7 +449,7 @@ public static IDictionary<string, Tuple<string, string>> GetPlatformExtensionSDK
             {
                 foreach (KeyValuePair<string, string> extension in moniker.ExtensionSDKs)
                 {
-                    extensionSDKsAndVersions[extension.Key] = Tuple.Create<string, string>(extension.Value, moniker.TargetPlatformVersion.ToString());
+                    extensionSDKsAndVersions[extension.Key] = Tuple.Create(extension.Value, moniker.TargetPlatformVersion.ToString());
                 }
             }
             return extensionSDKsAndVersions;
@@ -469,13 +469,13 @@ private static IEnumerable<TargetPlatformSDK> GetTargetPlatformMonikers(string[]
             IEnumerable<TargetPlatformSDK> targetPlatformSDKs = RetrieveTargetPlatformList(diskRoots, extensionDiskRoots, registryRoot);
 
             return targetPlatformSDKs
-                .Where<TargetPlatformSDK>(platformSDK =>
+                .Where(platformSDK =>
                     string.IsNullOrEmpty(platformSDK.TargetPlatformIdentifier)
                     ||
                     (
                         platformSDK.TargetPlatformIdentifier.Equals(targetPlatformIdentifier, StringComparison.OrdinalIgnoreCase)
                         && platformSDK.TargetPlatformVersion <= targetPlatformVersion) || platformSDK.ContainsPlatform(targetPlatformIdentifier, targetPlatformVersionString))
-                .OrderBy<TargetPlatformSDK, Version>(platform => platform.TargetPlatformVersion);
+                .OrderBy(platform => platform.TargetPlatformVersion);
         }
 
         /// <summary>
@@ -523,7 +523,7 @@ public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string t
             ErrorUtilities.VerifyThrowArgumentLength(sdkMoniker);
 
             IEnumerable<TargetPlatformSDK> targetPlatforms = RetrieveTargetPlatformList(diskRoots, extensionDiskRoots, registryRoot);
-            var targetPlatformMoniker = targetPlatforms.Where<TargetPlatformSDK>(
+            var targetPlatformMoniker = targetPlatforms.Where(
                 platform =>
                     (
                         string.IsNullOrEmpty(platform.TargetPlatformIdentifier)
@@ -531,8 +531,8 @@ public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string t
                         (platform.TargetPlatformIdentifier.Equals(targetPlatformIdentifier, StringComparison.OrdinalIgnoreCase)
                         && platform.TargetPlatformVersion <= targetPlatformVersion))
                     && platform.ExtensionSDKs.ContainsKey(sdkMoniker))
-                .OrderByDescending<TargetPlatformSDK, Version>(platform => platform.TargetPlatformVersion)
-                .DefaultIfEmpty(null).FirstOrDefault<TargetPlatformSDK>();
+                .OrderByDescending(platform => platform.TargetPlatformVersion)
+                .DefaultIfEmpty(null).FirstOrDefault();
 
             if (targetPlatformMoniker != null)
             {
@@ -769,7 +769,7 @@ public static IList<string> GetSDKDesignTimeFolders(string sdkRoot, string targe
         public static IList<TargetPlatformSDK> GetTargetPlatformSdks(string[] diskRoots, string registryRoot)
         {
             IEnumerable<TargetPlatformSDK> targetPlatforms = RetrieveTargetPlatformList(diskRoots, null, registryRoot);
-            return targetPlatforms.Where<TargetPlatformSDK>(platform => platform.Path != null).ToList<TargetPlatformSDK>();
+            return targetPlatforms.Where(platform => platform.Path != null).ToList();
         }
 
         /// <summary>
@@ -1588,7 +1588,7 @@ private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIde
             IEnumerable<TargetPlatformSDK> targetPlatforms = RetrieveTargetPlatformList(diskRoots, multiPlatformDiskRoots, registryRoot);
 
             TargetPlatformSDK matchingSdk = targetPlatforms
-                .FirstOrDefault<TargetPlatformSDK>(platform =>
+                .FirstOrDefault(platform =>
                     string.Equals(platform.TargetPlatformIdentifier, targetPlatformIdentifier, StringComparison.OrdinalIgnoreCase)
                     && Equals(platform.TargetPlatformVersion, targetPlatformVersion));
 
@@ -1598,7 +1598,7 @@ private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIde
             if (matchingSdk == null)
             {
                 string versionString = targetPlatformVersion.ToString();
-                matchingSdk = targetPlatforms.FirstOrDefault<TargetPlatformSDK>(platform => platform.ContainsPlatform(targetPlatformIdentifier, versionString));
+                matchingSdk = targetPlatforms.FirstOrDefault(platform => platform.ContainsPlatform(targetPlatformIdentifier, versionString));
             }
             return matchingSdk;
         }
@@ -2597,7 +2597,7 @@ internal static void GatherSDKListFromDirectory(List<string> diskroots, Dictiona
                     // Get a list of subdirectories under the root path and identifier, Ie. c:\Program files\Microsoft SDKs\Windows we should see things like, V8.0, 8.0, 9.0 ect.
                     // Only grab the folders that have a version number (they can start with a v or not).
 
-                    SortedDictionary<Version, List<string>> versionsInRoot = VersionUtilities.GatherVersionStrings(null, rootPathWithIdentifier.GetDirectories().Select<DirectoryInfo, string>(directory => directory.Name));
+                    SortedDictionary<Version, List<string>> versionsInRoot = VersionUtilities.GatherVersionStrings(null, rootPathWithIdentifier.GetDirectories().Select(directory => directory.Name));
 
                     ErrorUtilities.DebugTraceMessage("GatherSDKListFromDirectory", "Found '{0}' version folders under the identifier path '{1}'. ", versionsInRoot.Count, rootPathWithIdentifier);
 
@@ -3370,18 +3370,18 @@ internal static string GetPathToDotNetFrameworkSdkFile(string fileName, string p
         /// </summary>
         /// <param name="architecture"></param>
         /// <returns></returns>
-        internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture(DotNetFrameworkArchitecture architecture)
+        internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture(UtilitiesDotNetFrameworkArchitecture architecture)
         {
             switch (architecture)
             {
-                case DotNetFrameworkArchitecture.Bitness32:
+                case UtilitiesDotNetFrameworkArchitecture.Bitness32:
                     if (ProcessorArchitecture.CurrentProcessArchitecture == ProcessorArchitecture.ARM ||
                         ProcessorArchitecture.CurrentProcessArchitecture == ProcessorArchitecture.ARM64)
                     {
                         return ProcessorArchitecture.ARM;
                     }
                     return ProcessorArchitecture.X86;
-                case DotNetFrameworkArchitecture.Bitness64:
+                case UtilitiesDotNetFrameworkArchitecture.Bitness64:
                     // We need to know which 64-bit architecture we're on.
                     return NativeMethodsShared.ProcessorArchitectureNative switch
                     {
@@ -3395,7 +3395,7 @@ internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture
                         // unknown architecture? return null
                         _ => null,
                     };
-                case DotNetFrameworkArchitecture.Current:
+                case UtilitiesDotNetFrameworkArchitecture.Current:
                     return ProcessorArchitecture.CurrentProcessArchitecture;
             }
 
@@ -3441,7 +3441,7 @@ public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFramew
         /// <param name="architecture">Desired architecture of the resultant file.</param>
         /// <returns>Path to the appropriate Windows SDK file</returns>
         [Obsolete("Consider using GetPlatformSDKLocationFile instead")]
-        public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture)
+        public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, UtilitiesDotNetFrameworkArchitecture architecture)
             => GetPathToWindowsSdkFile(
                 fileName,
                 version,
@@ -3460,7 +3460,7 @@ public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFramew
         /// <param name="canFallBackIfNecessary"><code>true</code> to fallback, otherwise <code>false</code>.</param>
         /// <returns>Path to the appropriate Windows SDK file</returns>
         [Obsolete("Consider using GetPlatformSDKLocationFile instead")]
-        private static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary)
+        private static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, UtilitiesDotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary)
         {
             string pathToSdk = GetPathToWindowsSdk(version, visualStudioVersion);
             string filePath = null;
@@ -3999,6 +3999,6 @@ public int Compare(string versionX, string versionY)
             }
         }
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index c0dbc002dcc..e498f2070de 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -212,7 +212,7 @@ public virtual string ToolExe
         /// Project visible property that allows the user to specify an amount of time after which the task executable
         /// is terminated.
         /// </summary>
-        /// <value>Time-out in milliseconds. Default is <see cref="System.Threading.Timeout.Infinite"/> (no time-out).</value>
+        /// <value>Time-out in milliseconds. Default is <see cref="Timeout.Infinite"/> (no time-out).</value>
         public virtual int Timeout { set; get; } = System.Threading.Timeout.Infinite;
 
         /// <summary>
@@ -770,7 +770,7 @@ protected virtual int ExecuteTool(
                 }
 
                 // Call user-provided hook for code that should execute immediately after the process starts
-                this.ProcessStarted();
+                ProcessStarted();
 
                 // sign up for stderr callbacks
                 proc.BeginErrorReadLine();
@@ -1351,7 +1351,7 @@ public override bool Execute()
                 // parameters; if it didn't, at least emit a generic message.
                 if (!Log.HasLoggedErrors)
                 {
-                    LogPrivate.LogErrorWithCodeFromResources("ToolTask.ValidateParametersFailed", this.GetType().FullName);
+                    LogPrivate.LogErrorWithCodeFromResources("ToolTask.ValidateParametersFailed", GetType().FullName);
                 }
                 return false;
             }
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
index a74228cb0ec..5d62ac6b73d 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
@@ -39,7 +39,7 @@ protected override async Task AfterTestAssemblyStartingAsync()
                                                                                     .Cast<AssemblyFixtureAttribute>()
                                                                                     .ToList();
 
-                this.assemblyFixtureAttributes = fixturesAttrs;
+                assemblyFixtureAttributes = fixturesAttrs;
 
                 // Instantiate all the fixtures
                 foreach (var fixtureAttr in fixturesAttrs.Where(a => a.LifetimeScope == AssemblyFixtureAttribute.Scope.Assembly))
