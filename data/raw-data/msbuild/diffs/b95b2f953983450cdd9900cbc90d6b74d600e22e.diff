diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 74a8ad6e500..73a849c1573 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1973,7 +1973,9 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
                         }
 
                         var request = new BuildRequestData(
-                            node.ProjectInstance,
+                            node.ProjectInstance.FullPath,
+                            node.ProjectInstance.GlobalProperties,
+                            node.ProjectInstance.ToolsVersion,
                             targetList.ToArray(),
                             graphBuildRequestData.HostServices,
                             graphBuildRequestData.Flags);
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 9d1cefe040d..4d142d10a11 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -75,12 +75,17 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
         {
             EnsureNotDisposed();
 
+            if (_globalProjectCacheDescriptor != null)
+            {
+                _ = GetProjectCachePluginAsync(_globalProjectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken);
+            }
+
             Parallel.ForEach(
                 projectGraph.ProjectNodes,
                 s_parallelOptions,
                 node =>
                 {
-                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in node.ProjectInstance.ProjectCacheDescriptors)
                     {
                         // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
                         _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index a9d31698a28..845d92e0f13 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -566,7 +566,7 @@ private bool ParseItemList()
             {
                 return false;
             }
-            _lookahead = new Token(Token.TokenType.ItemList, _expression.Substring(start, _parsePoint - start));
+            _lookahead = new Token(Token.TokenType.ItemList, Microsoft.NET.StringTools.Strings.WeakIntern(_expression.AsSpan(start, _parsePoint - start)));
             return true;
         }
 
@@ -599,7 +599,7 @@ private bool ParseQuotedString()
                     // If it's %(a.b) the name is just 'b'
                     if (_parsePoint + 3 < _expression.Length)
                     {
-                        name = _expression.Substring(_parsePoint + 2, endOfName - _parsePoint - 2 + 1);
+                        name = Microsoft.NET.StringTools.Strings.WeakIntern(_expression.AsSpan(_parsePoint + 2, endOfName - _parsePoint - 2 + 1));
                     }
 
                     if (!CheckForUnexpectedMetadata(name))
@@ -649,7 +649,7 @@ private bool ParseQuotedString()
                 // Not useful to set unexpectedlyFound here. By definition it got to the end of the string.
                 return false;
             }
-            string originalTokenString = _expression.Substring(start, _parsePoint - start);
+            string originalTokenString = Microsoft.NET.StringTools.Strings.WeakIntern(_expression.AsSpan(start, _parsePoint - start));
 
             _lookahead = new Token(Token.TokenType.String, originalTokenString, expandable);
             _parsePoint++;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 0ad3b7ceba5..53df8bc0c5c 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3294,7 +3294,7 @@ internal static Function<T> ExtractPropertyFunction(
                         ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidFunctionStaticMethodSyntax", expressionFunction, String.Empty);
                     }
 
-                    var typeName = expressionRoot.Slice(1, typeEndIndex - 1).ToString();
+                    var typeName = Strings.WeakIntern(expressionRoot.Slice(1, typeEndIndex - 1));
                     var methodStartIndex = typeEndIndex + 1;
 
                     if (expressionRoot.Length > methodStartIndex + 2 && expressionRoot[methodStartIndex] == ':' && expressionRoot[methodStartIndex + 1] == ':')
@@ -3352,7 +3352,7 @@ internal static Function<T> ExtractPropertyFunction(
                     var rootEndIndex = expressionRoot.IndexOf('.');
 
                     // If this is an instance function rather than a static, then we'll capture the name of the property referenced
-                    var functionReceiver = expressionRoot.Slice(0, rootEndIndex).Trim().ToString();
+                    var functionReceiver = Strings.WeakIntern(expressionRoot.Slice(0, rootEndIndex).Trim());
 
                     // If propertyValue is null (we're not recursing), then we're expecting a valid property name
                     if (propertyValue == null && !IsValidPropertyName(functionReceiver))
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index c555a10d0e2..3b275537ec5 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -156,10 +156,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
 
                     // Grab the name, but continue to verify it's a well-formed expression
                     // before we store it.
-                    string name = expression.Substring(startOfName, i - startOfName);
-
-                    // return the item that we're working with
-                    string itemName = name;
+                    string itemName = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startOfName, i - startOfName));
 
                     SinkWhitespace(expression, ref i);
                     bool transformOrFunctionFound = true;
@@ -254,7 +251,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                     // Create an expression capture that encompases the entire expression between the @( and the )
                     // with the item name and any separator contained within it
                     // and each transform expression contained within it (i.e. each ->XYZ)
-                    ItemExpressionCapture expressionCapture = new ItemExpressionCapture(startPoint, endPoint - startPoint, expression.Substring(startPoint, endPoint - startPoint), itemName, separator, separatorStart, transformExpressions);
+                    ItemExpressionCapture expressionCapture = new ItemExpressionCapture(startPoint, endPoint - startPoint, Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startPoint, endPoint - startPoint)), itemName, separator, separatorStart, transformExpressions);
                     subExpressions.Add(expressionCapture);
 
                     continue;
@@ -597,11 +594,11 @@ private static ItemExpressionCapture SinkItemFunctionExpression(string expressio
                     int endFunctionArguments = i - 1;
 
                     ItemExpressionCapture capture = new ItemExpressionCapture(startTransform, i - startTransform, expression.Substring(startTransform, i - startTransform));
-                    capture.FunctionName = expression.Substring(startTransform, endFunctionName - startTransform);
+                    capture.FunctionName = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startTransform, endFunctionName - startTransform));
 
                     if (endFunctionArguments > startFunctionArguments)
                     {
-                        capture.FunctionArguments = expression.Substring(startFunctionArguments, endFunctionArguments - startFunctionArguments);
+                        capture.FunctionArguments = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startFunctionArguments, endFunctionArguments - startFunctionArguments));
                     }
 
                     return capture;
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 717bbdabd05..91c8a5b8509 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -157,14 +157,19 @@ private void AddEdgesFromProjectReferenceItems(Dictionary<ConfigurationMetadata,
                     {
                         foreach (var transitiveProjectReference in GetTransitiveProjectReferencesExcludingSelf(allParsedProjects[referenceInfo.ReferenceConfiguration]))
                         {
+                            var projectRefSnapshot = new ProjectReferenceSnapshot(new Dictionary<string, string>()
+                            {
+                                { ProjectInterpretation.FullPathMetadataName, referenceInfo.ReferenceConfiguration.ProjectFullPath },
+                                { ProjectInterpretation.ToolsVersionMetadataName, "" },
+                            })
+                            {
+                                ItemType = ProjectInterpretation.TransitiveReferenceItemName,
+                                EvaluatedInclude = currentNode.ProjectInstance.FullPath,
+                            };
+
                             currentNode.AddProjectReference(
                                 transitiveProjectReference,
-                                new ProjectItemInstance(
-                                    project: currentNode.ProjectInstance,
-                                    itemType: ProjectInterpretation.TransitiveReferenceItemName,
-                                    includeEscaped: referenceInfo.ReferenceConfiguration.ProjectFullPath,
-                                    directMetadata: null,
-                                    definingFileEscaped: currentNode.ProjectInstance.FullPath),
+                                projectRefSnapshot,
                                 edges);
                         }
                     }
@@ -235,13 +240,16 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                 {
                     foreach (var referencedNode in referencedNodes)
                     {
-                        var stubItem = new ProjectItemInstance(
-                            referencingNode.ProjectInstance,
-                            SolutionItemReference,
-                            referencedNode.ProjectInstance.FullPath,
-                            referencingNode.ProjectInstance.FullPath);
-
-                        referencingNode.AddProjectReference(referencedNode, stubItem, edges);
+                        var projectRefSnapshot = new ProjectReferenceSnapshot(new Dictionary<string, string>()
+                        {
+                            { ProjectInterpretation.FullPathMetadataName, referencedNode.ProjectInstance.FullPath },
+                            { ProjectInterpretation.ToolsVersionMetadataName, "" },
+                        })
+                        {
+                            ItemType = SolutionItemReference,
+                            EvaluatedInclude = referencedNode.ProjectInstance.FullPath
+                        };
+                        referencingNode.AddProjectReference(referencedNode, projectRefSnapshot, edges);
                     }
                 }
             }
@@ -643,26 +651,26 @@ private static PropertyDictionary<ProjectPropertyInstance> CreatePropertyDiction
 
         internal sealed class GraphEdges
         {
-            private ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance> ReferenceItems =
-                new ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance>();
+            private ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectReferenceSnapshot> ReferenceItems =
+                new ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectReferenceSnapshot>();
 
             internal int Count => ReferenceItems.Count;
 
-            public ProjectItemInstance this[(ProjectGraphNode node, ProjectGraphNode reference) key]
+            public ProjectReferenceSnapshot this[(ProjectGraphNode node, ProjectGraphNode reference) key]
             {
                 get
                 {
-                    ErrorUtilities.VerifyThrow(ReferenceItems.TryGetValue(key, out ProjectItemInstance referenceItem), "All requested keys should exist");
+                    ErrorUtilities.VerifyThrow(ReferenceItems.TryGetValue(key, out ProjectReferenceSnapshot referenceItem), "All requested keys should exist");
                     return referenceItem;
                 }
             }
 
-            public void AddOrUpdateEdge((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance edge)
+            public void AddOrUpdateEdge((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectReferenceSnapshot edge)
             {
                 ReferenceItems.AddOrUpdate(
                     key,
-                    addValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance referenceItem) => referenceItem,
-                    updateValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance existingItem, ProjectItemInstance newItem) =>
+                    addValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectReferenceSnapshot referenceItem) => referenceItem,
+                    updateValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectReferenceSnapshot existingItem, ProjectReferenceSnapshot newItem) =>
                     {
                         string existingTargetsMetadata = existingItem.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
                         string newTargetsMetadata = newItem.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
@@ -676,7 +684,7 @@ public void AddOrUpdateEdge((ProjectGraphNode node, ProjectGraphNode reference)
                         existingTargetsMetadata = GetEffectiveTargets(key.reference, existingTargetsMetadata);
                         newTargetsMetadata = GetEffectiveTargets(key.reference, newTargetsMetadata);
 
-                        ProjectItemInstance mergedItem = existingItem.DeepClone();
+                        ProjectReferenceSnapshot mergedItem = existingItem;
                         mergedItem.SetMetadata(ItemMetadataNames.ProjectReferenceTargetsMetadataName, $"{existingTargetsMetadata};{newTargetsMetadata}");
                         return mergedItem;
 
@@ -700,7 +708,7 @@ public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
 
             internal bool HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
 
-            internal IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> TestOnly_AsConfigurationMetadata()
+            internal IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectReferenceSnapshot> TestOnly_AsConfigurationMetadata()
             {
                 return ReferenceItems.ToImmutableDictionary(
                     kvp => (kvp.Key.Item1.ToConfigurationMetadata(), kvp.Key.Item2.ToConfigurationMetadata()),
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 39993e3a4fc..1c4ab035786 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -707,7 +707,7 @@ void ThrowOnEmptyTargetNames(ICollection<string> targetNames)
             }
         }
 
-        private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string> targets, List<string> defaultTargets, ProjectItemInstance graphEdge)
+        private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string> targets, List<string> defaultTargets, ProjectReferenceSnapshot graphEdge)
         {
             var i = 0;
             while (i < targets.Count)
@@ -721,7 +721,7 @@ private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string>
                 }
                 else if (targets[i].Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, StringComparison.OrdinalIgnoreCase))
                 {
-                    var targetsString = graphEdge.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
+                    var targetsString = graphEdge.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName); ;
 
                     var expandedTargets = string.IsNullOrEmpty(targetsString)
                         ? defaultTargets
diff --git a/src/Build/Graph/ProjectGraphNode.cs b/src/Build/Graph/ProjectGraphNode.cs
index c60d10e41aa..8cf4e781f30 100644
--- a/src/Build/Graph/ProjectGraphNode.cs
+++ b/src/Build/Graph/ProjectGraphNode.cs
@@ -3,133 +3,208 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Evaluation;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Shared;
+using static Microsoft.Build.Graph.ProjectInterpretation;
 
 #nullable disable
 
 namespace Microsoft.Build.Graph
 {
-    /// <summary>
-    /// Represents the node for a particular project in a project graph.
-    /// A node is defined by (ProjectPath, ToolsVersion, GlobalProperties).
-    /// </summary>
-    [DebuggerDisplay(@"{DebugString()}")]
-    public sealed class ProjectGraphNode
+    public class ProjectReferenceSnapshot
     {
-        private readonly HashSet<ProjectGraphNode> _projectReferences = new HashSet<ProjectGraphNode>();
-        private readonly HashSet<ProjectGraphNode> _referencingProjects = new HashSet<ProjectGraphNode>();
+        public string EvaluatedInclude = "";
+        public string ItemType = "";
 
-        // No public creation.
-        internal ProjectGraphNode(ProjectInstance projectInstance)
+        private Dictionary<string, string> Metadata;
+
+        public ProjectReferenceSnapshot(Dictionary<string, string> metadata)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectInstance, nameof(projectInstance));
-            ProjectInstance = projectInstance;
+            Metadata = metadata;
         }
 
-        /// <summary>
-        /// Gets an unordered collection of graph nodes for projects which this project references.
-        /// </summary>
-        public IReadOnlyCollection<ProjectGraphNode> ProjectReferences => _projectReferences;
-
-        /// <summary>
-        /// Gets a list of graph nodes for projects that have a project reference for this project
-        /// </summary>
-        public IReadOnlyCollection<ProjectGraphNode> ReferencingProjects => _referencingProjects;
+        public ProjectReferenceSnapshot(ProjectItemInstance projectReferenceTarget)
+        {
+            Metadata = new()
+            {
+                { ItemMetadataNames.ProjectReferenceTargetsMetadataName, projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName) },
+                { "SkipNonexistentTargets" , projectReferenceTarget.GetMetadataValue("SkipNonexistentTargets") },
+                { ProjectReferenceTargetIsOuterBuildMetadataName, projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName) },
+                { ItemMetadataNames.PropertiesMetadataName , projectReferenceTarget.GetMetadataValue(ItemMetadataNames.PropertiesMetadataName) },
+                { ItemMetadataNames.AdditionalPropertiesMetadataName , projectReferenceTarget.GetMetadataValue(ItemMetadataNames.AdditionalPropertiesMetadataName) },
+                { ItemMetadataNames.UndefinePropertiesMetadataName , projectReferenceTarget.GetMetadataValue(ItemMetadataNames.UndefinePropertiesMetadataName) },
+                { FullPathMetadataName , projectReferenceTarget.GetMetadataValue(FullPathMetadataName) },
+                { ProjectMetadataName , projectReferenceTarget.GetMetadataValue(ProjectMetadataName) },
+                { ToolsVersionMetadataName ,projectReferenceTarget.GetMetadataValue(ToolsVersionMetadataName) },
+                { SetPlatformMetadataName , projectReferenceTarget.GetMetadataValue(SetPlatformMetadataName) },
+                { GlobalPropertiesToRemoveMetadataName , projectReferenceTarget.GetMetadataValue(GlobalPropertiesToRemoveMetadataName) },
+                { OverridePlatformNegotiationValue , projectReferenceTarget.GetMetadataValue(OverridePlatformNegotiationValue) },
+                { SetConfigurationMetadataName , projectReferenceTarget.GetMetadataValue(SetConfigurationMetadataName) },
+                { SetTargetFrameworkMetadataName ,projectReferenceTarget.GetMetadataValue(SetTargetFrameworkMetadataName) },
+            };
+        }
 
-        internal class ProjectInstanceSnapshot
+        public string GetMetadataValue(string metadataName)
         {
-            public ProjectInstanceSnapshot(ProjectInstance instance)
+            if (Metadata.TryGetValue(metadataName, out string result))
             {
-                FullPath = instance.FullPath;
-                DefaultTargets = instance.DefaultTargets;
-                ProjectFileLocation = instance.ProjectFileLocation;
-                GlobalPropertiesDictionary = instance.GlobalPropertiesDictionary;
+                return result;
+            }
 
-                var innerBuildPropValue = instance.GetPropertyValue(PropertyNames.InnerBuildProperty);
-                Properties = new()
+            return string.Empty;
+            // throw new System.Exception($"Metadata Not Found {metadataName} in {ItemType}::{EvaluatedInclude} snapshot.");
+        }
+
+        public void SetMetadata(string key, string value)
+        {
+            Metadata[key] = value;
+        }
+    }
+
+    public class ProjectInstanceSnapshot
+    {
+        public ProjectInstanceSnapshot(ProjectInstance instance)
+        {
+            FullPath = instance.FullPath;
+            DefaultTargets = instance.DefaultTargets;
+            ProjectFileLocation = instance.ProjectFileLocation;
+            GlobalPropertiesDictionary = instance.GlobalPropertiesDictionary;
+            GlobalProperties = instance.GlobalProperties;
+            ToolsVersion = instance.ToolsVersion;
+
+            var innerBuildPropName = instance.GetPropertyValue(PropertyNames.InnerBuildProperty);
+            var innerBuildPropValue = instance.GetPropertyValue(innerBuildPropName);
+
+            instance.GetPropertyValue(instance.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));
+
+            var innerBuildPropValues1 = instance.GetPropertyValue(PropertyNames.InnerBuildPropertyValues);
+            var innerBuildPropValues2 = instance.GetPropertyValue(innerBuildPropValues1);
+            var isOuterBuild = string.IsNullOrWhiteSpace(innerBuildPropValue) && !string.IsNullOrWhiteSpace(innerBuildPropValues2);
+            var isInnerBuild = !string.IsNullOrWhiteSpace(innerBuildPropValue);
+
+            ProjectType = isOuterBuild
+                ? ProjectType.OuterBuild
+                : isInnerBuild
+                    ? ProjectType.InnerBuild
+                    : ProjectType.NonMultitargeting;
+
+            Targets = instance.Targets.Keys.ToList();
+            Properties = new()
                 {
-                    { ProjectInterpretation.AddTransitiveProjectReferencesInStaticGraphPropertyName, instance.GetPropertyValue(ProjectInterpretation.AddTransitiveProjectReferencesInStaticGraphPropertyName) },
-                    { ProjectInterpretation.EnableDynamicPlatformResolutionPropertyName, instance.GetPropertyValue(ProjectInterpretation.EnableDynamicPlatformResolutionPropertyName) },
-                    { PropertyNames.InnerBuildProperty, innerBuildPropValue },
-                    { innerBuildPropValue, instance.GetPropertyValue(innerBuildPropValue) },
+                    { AddTransitiveProjectReferencesInStaticGraphPropertyName, instance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName) },
+                    { EnableDynamicPlatformResolutionPropertyName, instance.GetPropertyValue(EnableDynamicPlatformResolutionPropertyName) },
+                    { "TargetFrameworks", instance.GetPropertyValue("TargetFrameworks") },
+                    { PropertyNames.InnerBuildProperty, innerBuildPropName },
+                    { PropertyNames.InnerBuildPropertyValues, innerBuildPropValues1 },
                     { "UsingMicrosoftNETSdk", instance.GetPropertyValue("UsingMicrosoftNETSdk") },
                     { "DisableTransitiveProjectReferences", instance.GetPropertyValue("DisableTransitiveProjectReferences") },
-                    { "UsingMicrosoftNETSdk", instance.GetPropertyValue("UsingMicrosoftNETSdk") },
+                    { SolutionProjectGenerator.CurrentSolutionConfigurationContents, instance.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents) },
+                    { "Platform", instance.GetPropertyValue("Platform") },
+                    { "Configuration", instance.GetPropertyValue("Configuration") },
+                    { "PlatformLookupTable", instance.GetPropertyValue("PlatformLookupTable") },
                 };
 
-                foreach(ProjectItemInstance projectItemInstance in instance.GetItems(ItemTypeNames.ProjectReferenceTargets))
-                {
-                    string targetsMetadataValue = projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
-                    bool skipNonexistentTargets = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue("SkipNonexistentTargets"));
-                    bool targetsAreForOuterBuild = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName));
-                    TargetSpecification[] targets = ExpressionShredder.SplitSemiColonSeparatedList(targetsMetadataValue)
-                        .Select(t => new TargetSpecification(t, skipNonexistentTargets)).ToArray();
+            Properties[innerBuildPropValue] = innerBuildPropValue;
+            Properties[innerBuildPropValues1] = innerBuildPropValues2;
 
-                    ProjectReferenceByTargets.Add(item)
+            var projectReferenceTargets = instance.GetItems(ItemTypeNames.ProjectReference).ToList();
 
-                }
-
-                ProjectReferenceByTargets = new()
-                {
+            ProjectReferenceByTargets = new(projectReferenceTargets.Count) { };
 
-                };
-
-                // GetItems + ItemTypeNames.ProjectCachePlugin
-                /*
-                 *             if (string.IsNullOrWhiteSpace(projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName)) &&
-                MSBuildStringIsTrue(projectInstance.GetPropertyValue("UsingMicrosoftNETSdk")) &&
-                MSBuildStringIsFalse(projectInstance.GetPropertyValue("DisableTransitiveProjectReferences")))
+            foreach (ProjectItemInstance projectReferenceTarget in instance.GetItems(ItemTypeNames.ProjectReference))
             {
-                return true;
+                ProjectReferenceByTargets.Add(new ProjectReferenceSnapshot(projectReferenceTarget)
+                {
+                    ItemType = projectReferenceTarget.ItemType,
+                    EvaluatedInclude = projectReferenceTarget.EvaluatedInclude,
+                });
             }
 
-                project.GetItems(ItemTypeNames.ProjectReferenceTargets);
+            var items = instance.GetItems(ItemTypeNames.ProjectCachePlugin);
+            ProjectCacheDescriptors = new(items.Count);
+            foreach (ProjectItemInstance item in items)
+            {
+                string pluginPath = FileUtilities.NormalizePath(System.IO.Path.Combine(item.Project.Directory, item.EvaluatedInclude));
 
-            return MSBuildStringIsTrue(
-                projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName));
+                var pluginSettings = new Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
+                foreach (ProjectMetadataInstance metadatum in item.Metadata)
+                {
+                    pluginSettings.Add(metadatum.Name, metadatum.EvaluatedValue);
+                }
 
-                requesterInstance.GetItems(ItemTypeNames.ProjectReference);
-                 */
+                ProjectCacheDescriptors.Add(ProjectCacheDescriptor.FromAssemblyPath(pluginPath, pluginSettings));
             }
+        }
 
-            public string FullPath;
-            public List<string> DefaultTargets;
-            public Construction.ElementLocation ProjectFileLocation;
-            public Collections.PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary;
-            public Dictionary<string,string> GlobalProperties;
-            public Dictionary<string, string> Properties;
-            public List<ProjectReferenceItem> ProjectReferenceByTargets;
-
-            public class ProjectReferenceItem
+        public string FullPath;
+        public string ToolsVersion;
+        public List<string> Targets;
+        internal ProjectType ProjectType;
+        public List<string> DefaultTargets;
+        public Construction.ElementLocation ProjectFileLocation;
+        internal Collections.PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary;
+        public IDictionary<string, string> GlobalProperties;
+        public Dictionary<string, string> Properties;
+        public List<ProjectReferenceSnapshot> ProjectReferenceByTargets;
+        public List<ProjectCacheDescriptor> ProjectCacheDescriptors;
+
+        public string GetPropertyValue(string propertyName)
+        {
+            if (Properties.TryGetValue(propertyName, out string result))
             {
-                public string Identity;
-                public string Targets;
-                public string 
+                return result;
             }
 
-            public string GetPropertyValue(string propertyName)
-            {
-                return Properties[propertyName];
-            }
+            throw new System.Exception($"Property Not Found {propertyName} in snapshot.");
+        }
+    }
+
+    /// <summary>
+    /// Represents the node for a particular project in a project graph.
+    /// A node is defined by (ProjectPath, ToolsVersion, GlobalProperties).
+    /// </summary>
+    [DebuggerDisplay(@"{DebugString()}")]
+    public sealed class ProjectGraphNode
+    {
+        private readonly HashSet<ProjectGraphNode> _projectReferences = new HashSet<ProjectGraphNode>();
+        private readonly HashSet<ProjectGraphNode> _referencingProjects = new HashSet<ProjectGraphNode>();
+
+        // No public creation.
+        internal ProjectGraphNode(ProjectInstance projectInstance)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(projectInstance, nameof(projectInstance));
+            ProjectInstance = new(projectInstance);
         }
 
+        /// <summary>
+        /// Gets an unordered collection of graph nodes for projects which this project references.
+        /// </summary>
+        public IReadOnlyCollection<ProjectGraphNode> ProjectReferences => _projectReferences;
+
+        /// <summary>
+        /// Gets a list of graph nodes for projects that have a project reference for this project
+        /// </summary>
+        public IReadOnlyCollection<ProjectGraphNode> ReferencingProjects => _referencingProjects;
+
+
         /// <summary>
         /// Gets the evaluated project instance represented by this node in the graph.
         /// </summary>
-        public ProjectInstance ProjectInstance { get; }
+        public ProjectInstanceSnapshot ProjectInstance { get; }
 
         private string DebugString()
         {
             var truncatedProjectFile = FileUtilities.TruncatePathToTrailingSegments(ProjectInstance.FullPath, 2);
 
             return
-                $"{truncatedProjectFile}, #GlobalProps={ProjectInstance.GlobalProperties.Count}, #Props={ProjectInstance.Properties.Count}, #Items={ProjectInstance.Items.Count}, #in={ReferencingProjects.Count}, #out={ProjectReferences.Count}";
+                $"{truncatedProjectFile}, #GlobalProps={ProjectInstance.GlobalProperties.Count}, #Props={ProjectInstance.Properties.Count}, #in={ReferencingProjects.Count}, #out={ProjectReferences.Count}";
         }
 
-        internal void AddProjectReference(ProjectGraphNode reference, ProjectItemInstance projectReferenceItem, GraphBuilder.GraphEdges edges)
+        internal void AddProjectReference(ProjectGraphNode reference, ProjectReferenceSnapshot projectReferenceItem, GraphBuilder.GraphEdges edges)
         {
             _projectReferences.Add(reference);
             reference._referencingProjects.Add(this);
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 3173e2e02f6..6fcb01a815b 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -21,13 +21,13 @@ namespace Microsoft.Build.Graph
 {
     internal sealed class ProjectInterpretation
     {
-        private const string FullPathMetadataName = "FullPath";
-        private const string ToolsVersionMetadataName = "ToolsVersion";
-        private const string SetConfigurationMetadataName = "SetConfiguration";
-        private const string SetPlatformMetadataName = "SetPlatform";
-        private const string SetTargetFrameworkMetadataName = "SetTargetFramework";
-        private const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
-        private const string ProjectReferenceTargetIsOuterBuildMetadataName = "OuterBuild";
+        internal const string FullPathMetadataName = "FullPath";
+        internal const string ToolsVersionMetadataName = "ToolsVersion";
+        internal const string SetConfigurationMetadataName = "SetConfiguration";
+        internal const string SetPlatformMetadataName = "SetPlatform";
+        internal const string SetTargetFrameworkMetadataName = "SetTargetFramework";
+        internal const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
+        internal const string ProjectReferenceTargetIsOuterBuildMetadataName = "OuterBuild";
         private const string InnerBuildReferenceItemName = "_ProjectSelfReference";
         internal static string TransitiveReferenceItemName = "_TransitiveProjectReference";
         internal const string AddTransitiveProjectReferencesInStaticGraphPropertyName = "AddTransitiveProjectReferencesInStaticGraph";
@@ -35,9 +35,9 @@ internal sealed class ProjectInterpretation
         private const string PlatformMetadataName = "Platform";
         private const string PlatformsMetadataName = "Platforms";
         internal const string EnableDynamicPlatformResolutionPropertyName = "EnableDynamicPlatformResolution";
-        private const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
+        internal const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
         private const string ShouldUnsetParentConfigurationAndPlatformPropertyName = "ShouldUnsetParentConfigurationAndPlatform";
-        private const string ProjectMetadataName = "Project";
+        internal const string ProjectMetadataName = "Project";
         private const string ConfigurationMetadataName = "Configuration";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
@@ -57,7 +57,7 @@ internal enum ProjectType
             NonMultitargeting,
         }
 
-        internal readonly record struct ReferenceInfo(ConfigurationMetadata ReferenceConfiguration, ProjectItemInstance ProjectReferenceItem);
+        internal readonly record struct ReferenceInfo(ConfigurationMetadata ReferenceConfiguration, ProjectReferenceSnapshot ProjectReferenceItem);
 
         private readonly struct TargetSpecification
         {
@@ -78,23 +78,23 @@ public TargetSpecification(string target, bool skipIfNonexistent)
             public bool SkipIfNonexistent { get; }
         }
 
-        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection projectCollection, ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory)
+        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstanceSnapshot requesterInstance, ProjectCollection projectCollection, ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory)
         {
-            IEnumerable<ProjectItemInstance> projectReferenceItems;
+            IEnumerable<ProjectReferenceSnapshot> projectReferenceItems;
             IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
 
-            switch (GetProjectType(requesterInstance))
+            switch (requesterInstance.ProjectType)
             {
                 case ProjectType.OuterBuild:
                     projectReferenceItems = ConstructInnerBuildReferences(requesterInstance);
                     break;
                 case ProjectType.InnerBuild:
                     globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));
-                    projectReferenceItems = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
+                    projectReferenceItems = requesterInstance.ProjectReferenceByTargets;
                     break;
                 case ProjectType.NonMultitargeting:
                     globalPropertiesModifiers = ModifierForNonMultitargetingNodes;
-                    projectReferenceItems = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
+                    projectReferenceItems = requesterInstance.ProjectReferenceByTargets;
                     break;
                 default:
                     throw new ArgumentOutOfRangeException();
@@ -107,7 +107,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                 solutionConfiguration = new SolutionConfiguration(solutionConfigurationXml);
             }
 
-            foreach (ProjectItemInstance projectReferenceItem in projectReferenceItems)
+            foreach (ProjectReferenceSnapshot projectReferenceItem in projectReferenceItems)
             {
                 if (!String.IsNullOrEmpty(projectReferenceItem.GetMetadataValue(ToolsVersionMetadataName)))
                 {
@@ -165,7 +165,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                 }
 
                 // Note: Dynamic platform resolution is not enabled for sln-based builds.
-                else if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && enableDynamicPlatformResolution)
+                else if (string.IsNullOrEmpty(projectReferenceItem.GetMetadataValue(SetPlatformMetadataName)) && enableDynamicPlatformResolution)
                 {
                     string requesterPlatform = requesterInstance.GetPropertyValue("Platform");
                     string requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
@@ -185,6 +185,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                     }
                     else
                     {
+                        // referenceGlobalProperties[PlatformMetadataName] = selectedPlatform;
                         SetProperty(referenceGlobalProperties, PlatformMetadataName, selectedPlatform);
                     }
                 }
@@ -201,35 +202,21 @@ static void SetProperty(PropertyDictionary<ProjectPropertyInstance> properties,
             }
         }
 
-        internal static string GetInnerBuildPropertyValue(ProjectInstance project)
+        internal static string GetInnerBuildPropertyValue(ProjectInstanceSnapshot project)
         {
             return project.GetPropertyValue(GetInnerBuildPropertyName(project));
         }
 
-        internal static string GetInnerBuildPropertyName(ProjectInstance project)
+        internal static string GetInnerBuildPropertyName(ProjectInstanceSnapshot project)
         {
             return project.GetPropertyValue(PropertyNames.InnerBuildProperty);
         }
 
-        internal static string GetInnerBuildPropertyValues(ProjectInstance project)
+        internal static string GetInnerBuildPropertyValues(ProjectInstanceSnapshot project)
         {
             return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));
         }
 
-        internal static ProjectType GetProjectType(ProjectInstance project)
-        {
-            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));
-            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));
-
-            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $"A project cannot be an outer and inner build at the same time: ${project.FullPath}");
-
-            return isOuterBuild
-                ? ProjectType.OuterBuild
-                : isInnerBuild
-                    ? ProjectType.InnerBuild
-                    : ProjectType.NonMultitargeting;
-        }
-
         /// <summary>
         /// To avoid calling nuget at graph construction time, the graph is initially constructed with nodes referencing outer build nodes which in turn
         /// reference inner build nodes. However at build time, the inner builds are referenced directly by the nodes referencing the outer build.
@@ -242,7 +229,7 @@ public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject>
             {
                 ProjectGraphNode outerBuild = node.Value.GraphNode;
 
-                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)
+                if (outerBuild.ProjectInstance.ProjectType == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)
                 {
                     foreach (ProjectGraphNode innerBuild in outerBuild.ProjectReferences)
                     {
@@ -252,7 +239,7 @@ public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject>
                             // Decided to use the outerBuildBuildReferencingProject -> outerBuild edge in order to preserve any extra metadata
                             // information that may be present on the edge, like the "Targets" metadata which specifies what
                             // targets to call on the references.
-                            ProjectItemInstance newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
+                            ProjectReferenceSnapshot newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
 
                             if (outerBuildReferencingProject.ProjectReferences.Contains(innerBuild))
                             {
@@ -273,7 +260,7 @@ public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject>
             }
         }
 
-        private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(ProjectInstance outerBuild)
+        private static IEnumerable<ProjectReferenceSnapshot> ConstructInnerBuildReferences(ProjectInstanceSnapshot outerBuild)
         {
             var globalPropertyName = GetInnerBuildPropertyName(outerBuild);
             var globalPropertyValues = GetInnerBuildPropertyValues(outerBuild);
@@ -283,12 +270,18 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
 
             foreach (var globalPropertyValue in ExpressionShredder.SplitSemiColonSeparatedList(globalPropertyValues))
             {
-                yield return new ProjectItemInstance(
-                    project: outerBuild,
-                    itemType: InnerBuildReferenceItemName,
-                    includeEscaped: outerBuild.FullPath,
-                    directMetadata: new[] { new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}") },
-                    definingFileEscaped: outerBuild.FullPath);
+                var prSnapshot = new ProjectReferenceSnapshot(new Dictionary<string, string>()
+                {
+                    { FullPathMetadataName, outerBuild.FullPath },
+                    { ItemMetadataNames.PropertiesMetadataName , $"{globalPropertyName}={globalPropertyValue}" },
+                    { "ToolsVersion", "" },
+                })
+                {
+                    ItemType = InnerBuildReferenceItemName,
+                    EvaluatedInclude = outerBuild.FullPath
+                };
+
+                yield return prSnapshot;
             }
         }
 
@@ -300,7 +293,7 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
         /// </remarks>
         private static GlobalPropertyPartsForMSBuildTask ProjectReferenceGlobalPropertiesModifier(
             GlobalPropertyPartsForMSBuildTask defaultParts,
-            ProjectItemInstance projectReference)
+            ProjectReferenceSnapshot projectReference)
         {
             // ProjectReference defines yet another metadata name containing properties to undefine. Merge it in if non empty.
             var globalPropertiesToRemove = SplitPropertyNames(projectReference.GetMetadataValue(GlobalPropertiesToRemoveMetadataName));
@@ -360,7 +353,7 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
             }
         }
 
-        private delegate GlobalPropertyPartsForMSBuildTask GlobalPropertiesModifier(GlobalPropertyPartsForMSBuildTask defaultParts, ProjectItemInstance projectReference);
+        private delegate GlobalPropertyPartsForMSBuildTask GlobalPropertiesModifier(GlobalPropertyPartsForMSBuildTask defaultParts, ProjectReferenceSnapshot projectReference);
 
         /// <summary>
         ///     Gets the effective global properties for an item that will get passed to <see cref="MSBuild.Projects"/>.
@@ -370,7 +363,7 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
         ///     and the <paramref name="globalPropertyModifiers"/> parameter can contain other mutations done at build time in targets / tasks
         /// </remarks>
         private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(
-            ProjectItemInstance projectReference,
+            ProjectReferenceSnapshot projectReference,
             PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,
             bool allowCollectionReuse,
             IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers)
@@ -482,16 +475,16 @@ private TargetsToPropagate(ImmutableList<TargetSpecification> outerBuildTargets,
             /// <param name="project">Project containing the PRT protocol</param>
             /// <param name="entryTargets">Targets with which <paramref name="project"/> will get called</param>
             /// <returns></returns>
-            public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance project, ImmutableList<string> entryTargets)
+            public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstanceSnapshot project, ImmutableList<string> entryTargets)
             {
                 ImmutableList<TargetSpecification>.Builder targetsForOuterBuild = ImmutableList.CreateBuilder<TargetSpecification>();
                 ImmutableList<TargetSpecification>.Builder targetsForInnerBuild = ImmutableList.CreateBuilder<TargetSpecification>();
 
-                ICollection<ProjectItemInstance> projectReferenceTargets = project.GetItems(ItemTypeNames.ProjectReferenceTargets);
+                var projectReferenceTargets = project.ProjectReferenceByTargets;
 
                 foreach (string entryTarget in entryTargets)
                 {
-                    foreach (ProjectItemInstance projectReferenceTarget in projectReferenceTargets)
+                    foreach (var projectReferenceTarget in projectReferenceTargets)
                     {
                         if (projectReferenceTarget.EvaluatedInclude.Equals(entryTarget, StringComparison.OrdinalIgnoreCase))
                         {
@@ -515,18 +508,18 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj
                 return new TargetsToPropagate(targetsForOuterBuild.ToImmutable(), targetsForInnerBuild.ToImmutable());
             }
 
-            public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)
+            public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstanceSnapshot reference)
             {
                 ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)
                 {
                     // Keep targets that are non-skippable or that exist but are skippable.
                     return targets
-                        .Where(t => !t.SkipIfNonexistent || reference.Targets.ContainsKey(t.Target))
+                        .Where(t => !t.SkipIfNonexistent || reference.Targets.Contains(t.Target))
                         .Select(t => t.Target)
                         .ToImmutableList();
                 }
 
-                return GetProjectType(reference) switch
+                return reference.ProjectType switch
                 {
                     ProjectType.InnerBuild => RemoveNonexistentTargetsIfSkippable(_allTargets),
                     ProjectType.OuterBuild => RemoveNonexistentTargetsIfSkippable(_outerBuildTargets),
@@ -536,10 +529,10 @@ ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSp
             }
         }
 
-        public bool RequiresTransitiveProjectReferences(ProjectInstance projectInstance)
+        public bool RequiresTransitiveProjectReferences(ProjectInstanceSnapshot projectInstance)
         {
             // Outer builds do not get edges based on ProjectReference or their transitive closure, only inner builds do.
-            if (GetProjectType(projectInstance) == ProjectType.OuterBuild)
+            if (projectInstance.ProjectType == ProjectType.OuterBuild)
             {
                 return false;
             }
