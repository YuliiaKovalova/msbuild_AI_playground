diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 58a0d5dcf37..33dbaa5c380 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -1466,7 +1466,7 @@ public void VenusProject()
             Assert.Equal("", releaseAspNetCompilerParameters.aspNetAPTCA);
             Assert.Equal("", releaseAspNetCompilerParameters.aspNetFixedNames);
 
-            ArrayList aspNetProjectReferences = solution.ProjectsInOrder[0].ProjectReferences;
+            List<string> aspNetProjectReferences = solution.ProjectsInOrder[0].ProjectReferences;
             Assert.Equal(2, aspNetProjectReferences.Count);
             Assert.Equal("{FD705688-88D1-4C22-9BFF-86235D89C2FC}", aspNetProjectReferences[0]);
             Assert.Equal("{F0726D09-042B-4A7A-8A01-6BED2422BD5D}", aspNetProjectReferences[1]);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index a8e41aeb6d9..f410f85e447 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -2,12 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-using System.Text;
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -709,10 +706,6 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
         /// <summary>
         /// Determines if the target needs to be built/rebuilt/skipped if it has discrete outputs.
         /// </summary>
-        /// <param name="itemVectorsInTargetInputs"></param>
-        /// <param name="itemVectorTransformsInTargetInputs"></param>
-        /// <param name="discreteItemsInTargetInputs"></param>
-        /// <param name="targetOutputItemSpecs"></param>
         /// <returns>Indication of how to build the target.</returns>
         private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteOutputs
         (
@@ -722,14 +715,14 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteOutputs
             List<string> targetOutputItemSpecs
         )
         {
-            DependencyAnalysisResult result = DependencyAnalysisResult.SkipUpToDate;
+            DependencyAnalysisResult result;
 
             List<string> targetInputItemSpecs = GetItemSpecsFromItemVectors(itemVectorsInTargetInputs);
             targetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorTransformsInTargetInputs));
             targetInputItemSpecs.AddRange(discreteItemsInTargetInputs.Values);
 
-            List<string> inputs = CollectionHelpers.RemoveNulls<string>(targetInputItemSpecs);
-            List<string> outputs = CollectionHelpers.RemoveNulls<string>(targetOutputItemSpecs);
+            List<string> inputs = CollectionHelpers.RemoveNulls(targetInputItemSpecs);
+            List<string> outputs = CollectionHelpers.RemoveNulls(targetOutputItemSpecs);
 
             if (inputs.Count == 0)
             {
@@ -742,8 +735,7 @@ List<string> targetOutputItemSpecs
             }
 
             // if any input is newer than any output, do a full build
-            DependencyAnalysisLogDetail dependencyAnalysisDetailEntry;
-            bool someOutOfDate = IsAnyOutOfDate(out dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
+            bool someOutOfDate = IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
 
             if (someOutOfDate)
             {
@@ -897,11 +889,6 @@ private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionColle
         /// <summary>
         /// Finds the differences in the keys between the two given hashtables.
         /// </summary>
-        /// <param name="h1"></param>
-        /// <param name="h2"></param>
-        /// <param name="commonKeys"></param>
-        /// <param name="uniqueKeysInH1"></param>
-        /// <param name="uniqueKeysInH2"></param>
         private static void DiffHashtables<K, V>(IDictionary<K, V> h1, IDictionary<K, V> h2, out List<K> commonKeys, out List<K> uniqueKeysInH1, out List<K> uniqueKeysInH2) where K : class, IEquatable<K> where V : class
         {
             commonKeys = new List<K>();
@@ -1214,21 +1201,22 @@ private int CompareLastWriteTimes(string path1, string path2, out bool path1Does
         #endregion
 
         // the project whose target we are analyzing.
-        private ProjectInstance _project;
+        private readonly ProjectInstance _project;
         // the target to analyze
-        private ProjectTargetInstance _targetToAnalyze;
+        private readonly ProjectTargetInstance _targetToAnalyze;
 
         // the value of the target's "Inputs" attribute
-        private string _targetInputSpecification;
+        private readonly string _targetInputSpecification;
         // the value of the target's "Outputs" attribute
-        private string _targetOutputSpecification;
+        private readonly string _targetOutputSpecification;
+
         // Details of the dependency analysis for logging
-        private ArrayList _dependencyAnalysisDetail = new ArrayList();
+        private readonly List<DependencyAnalysisLogDetail> _dependencyAnalysisDetail = new List<DependencyAnalysisLogDetail>();
 
         // Engine logging service which to log message to
-        private ILoggingService _loggingService;
+        private readonly ILoggingService _loggingService;
         // Event context information where event is raised from
-        private BuildEventContext _buildEventContext;
+        private readonly BuildEventContext _buildEventContext;
 
         /// <summary>
         /// By default we do not sort target inputs and outputs as it has significant perf impact.
@@ -1239,13 +1227,13 @@ private int CompareLastWriteTimes(string path1, string path2, out bool path1Does
         /// <summary>
         /// The unique target inputs.
         /// </summary>
-        private IDictionary<string, object> _uniqueTargetInputs =
+        private readonly IDictionary<string, object> _uniqueTargetInputs =
                    (s_sortInputsOutputs ? (IDictionary<string, object>)new SortedDictionary<string, object>(StringComparer.OrdinalIgnoreCase) : (IDictionary<string, object>)new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase));
 
         /// <summary>
         /// The unique target outputs.
         /// </summary>
-        private IDictionary<string, object> _uniqueTargetOutputs =
+        private readonly IDictionary<string, object> _uniqueTargetOutputs =
                    (s_sortInputsOutputs ? (IDictionary<string, object>)new SortedDictionary<string, object>(StringComparer.OrdinalIgnoreCase) : (IDictionary<string, object>)new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase));
     }
 
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 3ea27d063cf..7222a9970ee 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -115,7 +115,6 @@ internal ProjectInSolution(SolutionFile solution)
             _relativePath = null;
             ProjectGuid = null;
             _dependencies = new List<string>();
-            ProjectReferences = new ArrayList();
             ParentProjectGuid = null;
             _uniqueProjectName = null;
             ParentSolution = solution;
@@ -200,7 +199,7 @@ internal set
         /// either specified as Dependencies above, or as ProjectReferences in the
         /// project file, which the solution doesn't have insight into. 
         /// </summary>
-        internal ArrayList ProjectReferences { get; }
+        internal List<string> ProjectReferences { get; } = new List<string>();
 
         internal SolutionFile ParentSolution { get; set; }
 
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 0c1b3c8df00..7c681f87742 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Shared;
@@ -16,12 +15,10 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal sealed class FunctionCallExpressionNode : OperatorExpressionNode
     {
-        private ArrayList _arguments;
-        private string _functionName;
+        private readonly List<GenericExpressionNode> _arguments;
+        private readonly string _functionName;
 
-        private FunctionCallExpressionNode() { }
-
-        internal FunctionCallExpressionNode(string functionName, ArrayList arguments)
+        internal FunctionCallExpressionNode(string functionName, List<GenericExpressionNode> arguments)
         {
             _functionName = functionName;
             _arguments = arguments;
@@ -42,7 +39,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     // Expand the items and use DefaultIfEmpty in case there is nothing returned
                     // Then check if everything is not null (because the list was empty), not
                     // already loaded into the cache, and exists
-                    var list = ExpandArgumentAsFileList((GenericExpressionNode) _arguments[0], state);
+                    List<string> list = ExpandArgumentAsFileList(_arguments[0], state);
                     if (list == null)
                     {
                         return false;
@@ -76,7 +73,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 VerifyArgumentCount(1, state);
 
                 // Expand properties and items, and verify the result is an appropriate scalar
-                string expandedValue = ExpandArgumentForScalarParameter("HasTrailingSlash", (GenericExpressionNode)_arguments[0], state);
+                string expandedValue = ExpandArgumentForScalarParameter("HasTrailingSlash", _arguments[0], state);
 
                 // Is the last character a backslash?
                 if (expandedValue.Length != 0)
@@ -113,7 +110,10 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
         /// <param name="state"></param>
         /// <param name="isFilePath">True if this is afile name and the path should be normalized</param>
         /// <returns>Scalar result</returns>
-        private string ExpandArgumentForScalarParameter(string function, GenericExpressionNode argumentNode, ConditionEvaluator.IConditionEvaluationState state,
+        private static string ExpandArgumentForScalarParameter(
+            string function,
+            GenericExpressionNode argumentNode,
+            ConditionEvaluator.IConditionEvaluationState state,
             bool isFilePath = true)
         {
             string argument = argumentNode.GetUnexpandedValue(state);
@@ -148,7 +148,7 @@ private string ExpandArgumentForScalarParameter(string function, GenericExpressi
             return expandedValue;
         }
 
-        private List<string> ExpandArgumentAsFileList(GenericExpressionNode argumentNode, ConditionEvaluator.IConditionEvaluationState state, bool isFilePath = true)
+        private static List<string> ExpandArgumentAsFileList(GenericExpressionNode argumentNode, ConditionEvaluator.IConditionEvaluationState state, bool isFilePath = true)
         {
             string argument = argumentNode.GetUnexpandedValue(state);
 
@@ -157,8 +157,7 @@ private List<string> ExpandArgumentAsFileList(GenericExpressionNode argumentNode
             {
                 argument = FileUtilities.FixFilePath(argument);
             }
-
-
+            
             IList<TaskItem> expanded = state.ExpandIntoTaskItems(argument);
             var expandedCount = expanded.Count;
 
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 502d832621b..a08bb69f08e 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -1,14 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Globalization;
-using System.Collections;
-using System.Xml;
 using System;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -46,11 +43,11 @@ internal sealed class Parser
         private Scanner _lexer;
         private ParserOptions _options;
         private ElementLocation _elementLocation;
-        internal int errorPosition = 0; // useful for unit tests
+        internal int errorPosition; // useful for unit tests
 
         #region REMOVE_COMPAT_WARNING
 
-        private bool _warnedForExpression = false;
+        private bool _warnedForExpression;
 
         private BuildEventContext _logBuildEventContext;
         /// <summary>
@@ -274,7 +271,7 @@ private OperatorExpressionNode RelationalOperation(string expression)
         private GenericExpressionNode Factor(string expression)
         {
             // Checks for TokenTypes String, Numeric, Property, ItemMetadata, and ItemList.
-            GenericExpressionNode arg = this.Arg(expression);
+            GenericExpressionNode arg = Arg(expression);
 
             // If it's one of those, return it.
             if (arg != null)
@@ -292,7 +289,7 @@ private GenericExpressionNode Factor(string expression)
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", _lexer.IsNextString(), errorPosition);
                     return null;
                 }
-                ArrayList arglist = new ArrayList();
+                var arglist = new List<GenericExpressionNode>();
                 Arglist(expression, arglist);
                 if (!Same(expression, Token.TokenType.RightParenthesis))
                 {
@@ -333,13 +330,15 @@ private GenericExpressionNode Factor(string expression)
             return null;
         }
 
-        private void Arglist(string expression, ArrayList arglist)
+        private void Arglist(string expression, List<GenericExpressionNode> arglist)
         {
             if (!_lexer.IsNext(Token.TokenType.RightParenthesis))
+            {
                 Args(expression, arglist);
+            }
         }
 
-        private void Args(string expression, ArrayList arglist)
+        private void Args(string expression, List<GenericExpressionNode> arglist)
         {
             GenericExpressionNode arg = Arg(expression);
             arglist.Add(arg);
@@ -402,4 +401,4 @@ private bool Same(string expression, Token.TokenType token)
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 6bb67875599..24d17cde38d 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -494,7 +494,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
             // Add the project to the BuildManager so we can use the start information later in the build process
             _buildEventManager.AddProjectStartedEvent(e, _showTimeStamp || IsVerbosityAtLeast(LoggerVerbosity.Detailed));
 
-
+            
             if (this.showPerfSummary)
             {
                 // Create a new project performance counter for this project
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 96e35cb8ad1..0df9330de86 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -8559,8 +8559,8 @@ public void VerifyGetSimpleNamesIsSorted()
                 AssemblyTableInfo tableInfo = new AssemblyTableInfo(redistFile, "DoesNotExist");
                 RedistList redist = RedistList.GetRedistList(new AssemblyTableInfo[] { tableInfo });
 
-                AssemblyEntry[] entryArray = redist.FindAssemblyNameFromSimpleName("System");
-                Assert.Equal(6, entryArray.Length);
+                List<AssemblyEntry> entryArray = redist.FindAssemblyNameFromSimpleName("System").ToList();
+                Assert.Equal(6, entryArray.Count);
                 AssemblyNameExtension a1 = new AssemblyNameExtension(entryArray[0].FullName);
                 AssemblyNameExtension a2 = new AssemblyNameExtension(entryArray[1].FullName);
                 AssemblyNameExtension a3 = new AssemblyNameExtension(entryArray[2].FullName);
diff --git a/src/Tasks/AppConfig/DependentAssembly.cs b/src/Tasks/AppConfig/DependentAssembly.cs
index 261d832cd33..2337cafd376 100644
--- a/src/Tasks/AppConfig/DependentAssembly.cs
+++ b/src/Tasks/AppConfig/DependentAssembly.cs
@@ -108,12 +108,12 @@ internal void Read(XmlReader reader)
                     redirects.Add(bindingRedirect);
                 }
             }
-            BindingRedirects = redirects.ToArray();
+            BindingRedirects = redirects;
         }
 
         /// <summary>
         /// The binding redirects.
         /// </summary>
-        internal BindingRedirect[] BindingRedirects { set; get; }
+        internal List<BindingRedirect> BindingRedirects { set; get; }
     }
 }
diff --git a/src/Tasks/AppConfig/RuntimeSection.cs b/src/Tasks/AppConfig/RuntimeSection.cs
index cc19f814167..a78dcdfd35d 100644
--- a/src/Tasks/AppConfig/RuntimeSection.cs
+++ b/src/Tasks/AppConfig/RuntimeSection.cs
@@ -11,12 +11,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal sealed class RuntimeSection
     {
-        /// <summary>
-        /// List of dependent assemblies. Type is DependentAssembly.
-        /// </summary>
-        private readonly List<DependentAssembly> _dependentAssemblies = new List<DependentAssembly>();
-
-        /// <summary>
+       /// <summary>
         /// The reader is positioned on a &lt;runtime&gt; element--read it.
         /// </summary>
         internal void Read(XmlReader reader)
@@ -39,7 +34,7 @@ internal void Read(XmlReader reader)
                     // Otherwise, this section is no use.
                     if (dependentAssembly.PartialAssemblyName != null)
                     {
-                        _dependentAssemblies.Add(dependentAssembly);
+                        DependentAssemblies.Add(dependentAssembly);
                     }
                 }
             }
@@ -48,6 +43,6 @@ internal void Read(XmlReader reader)
         /// <summary>
         /// Return the collection of dependent assemblies for this runtime element.
         /// </summary>
-        internal DependentAssembly[] DependentAssemblies => _dependentAssemblies.ToArray();
+        internal List<DependentAssembly> DependentAssemblies { get; } = new List<DependentAssembly>();
     }
 }
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index 1ed24824d38..c35edb4fd13 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections;
+using System.Collections.Generic;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -92,23 +93,17 @@ internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssembl
             {
                 // If there are multiple entries in the redist list for this assembly, let's
                 // pick the one with the highest version and resolve it.
-
-                AssemblyEntry[] assemblyEntries = installedAssemblies.FindAssemblyNameFromSimpleName(assemblyName.Name);
-
-                if (assemblyEntries.Length != 0)
+                foreach (AssemblyEntry a in installedAssemblies.FindAssemblyNameFromSimpleName(assemblyName.Name))
                 {
-                    for (int i = 0; i < assemblyEntries.Length; ++i)
-                    {
-                        var current = new AssemblyNameExtension(assemblyEntries[i].FullName);
+                    var current = new AssemblyNameExtension(a.FullName);
 
-                        // If the current version is higher than the previously looked at.
-                        if (current.Version != null && current.Version.CompareTo(assemblyNameToUse.Version) > 0)
+                    // If the current version is higher than the previously looked at.
+                    if (current.Version != null && current.Version.CompareTo(assemblyNameToUse.Version) > 0)
+                    {
+                        // Only compare the Culture and the public key token, the simple names will ALWAYS be the same and the version we do not care about.
+                        if (assemblyName.PartialNameCompare(current, PartialComparisonFlags.Culture | PartialComparisonFlags.PublicKeyToken))
                         {
-                            // Only compare the Culture and the public key token, the simple names will ALWAYS be the same and the version we do not care about.
-                            if (assemblyName.PartialNameCompare(current, PartialComparisonFlags.Culture | PartialComparisonFlags.PublicKeyToken))
-                            {
-                                assemblyNameToUse = current;
-                            }
+                            assemblyNameToUse = current;
                         }
                     }
                 }
diff --git a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
index a37a9cc6c0b..83d49173b71 100644
--- a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
+++ b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -101,9 +103,7 @@ internal AssemblyEntry FindHighestVersionInRedistList(AssemblyNameExtension asse
 
             // Look up an assembly with the same base name in the installedAssemblyTables.
             // This list should be sorted alphabetically by simple name and then greatest verion
-            AssemblyEntry[] tableCandidates = _redistList.FindAssemblyNameFromSimpleName(assemblyName.Name);
-
-            foreach (AssemblyEntry tableCandidate in tableCandidates)
+            foreach (AssemblyEntry tableCandidate in _redistList.FindAssemblyNameFromSimpleName(assemblyName.Name))
             {
                 // Make an AssemblyNameExtension for comparing.
                 AssemblyNameExtension mostRecentAssemblyNameCandidate = tableCandidate.AssemblyNameExtension;
@@ -135,13 +135,12 @@ internal bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName)
         /// <summary>
         /// Find every assembly full name in the redist list that matches the given simple name.
         /// </summary>
-        /// <param name="simpleName"></param>
         /// <returns>The array of assembly names.</returns>
-        internal AssemblyEntry[] FindAssemblyNameFromSimpleName(string simpleName)
+        internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simpleName)
         {
             if (_redistList == null)
             {
-                return Array.Empty<AssemblyEntry>();
+                return Enumerable.Empty<AssemblyEntry>();
             }
 
             return _redistList.FindAssemblyNameFromSimpleName(simpleName);
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 4eae100cefe..a7d78cf5333 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -623,18 +623,12 @@ internal ITaskItem PrimarySourceItem
         /// This item shouldn't be passed to compilers and so forth. 
         /// </summary>
         /// <value>'true' if this reference points to a bad image.</value>
-        internal bool IsBadImage { get; private set; } = false;
+        internal bool IsBadImage { get; private set; }
 
         /// <summary>
         ///  If true, then this item conflicted with another item and lost.
         /// </summary>
-        internal bool IsConflictVictim
-        {
-            get
-            {
-                return ConflictVictorName != null;
-            }
-        }
+        internal bool IsConflictVictim => ConflictVictorName != null;
 
         /// <summary>
         /// Add a conflict victim to this reference
@@ -647,18 +641,18 @@ internal void AddConflictVictim(AssemblyNameExtension victim)
         /// <summary>
         /// Return the list of conflict victims.
         /// </summary>
-        internal AssemblyNameExtension[] GetConflictVictims()
+        internal List<AssemblyNameExtension> GetConflictVictims()
         {
-            return _conflictVictims.ToArray();
+            return _conflictVictims;
         }
 
         /// <summary>
-        ///  The name of the assembly that won over this reference.
+        /// The name of the assembly that won over this reference.
         /// </summary>
-        internal AssemblyNameExtension ConflictVictorName { get; set; } = null;
+        internal AssemblyNameExtension ConflictVictorName { get; set; }
 
         /// <summary>
-        ///  The reason why this reference lost to another reference.
+        /// The reason why this reference lost to another reference.
         /// </summary>
         internal ConflictLossReason ConflictLossExplanation { get; set; } = ConflictLossReason.DidntLose;
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index dcd79313b6e..003638e03c5 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -42,7 +42,8 @@ internal sealed class ReferenceTable
         private readonly HashSet<string> _externallyResolvedPrimaryReferences = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>The table of remapped assemblies. Used for Unification.</summary>
-        private DependentAssembly[] _remappedAssemblies = Array.Empty<DependentAssembly>();
+        private List<DependentAssembly> _remappedAssemblies = new List<DependentAssembly>();
+
         /// <summary>If true, then search for dependencies.</summary>
         private readonly bool _findDependencies;
         /// <summary>
@@ -275,7 +276,7 @@ internal ReferenceTable
             _assemblyMetadataCache = assemblyMetadataCache;
 
             // Set condition for when to check assembly version against the target framework version 
-            _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? ReferenceTable.s_targetFrameworkVersion_40) <= ReferenceTable.s_targetFrameworkVersion_40);
+            _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? s_targetFrameworkVersion_40) <= s_targetFrameworkVersion_40);
 
             // Convert the list of installed SDK's to a dictionary for faster lookup
             _resolvedSDKReferences = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
@@ -531,7 +532,7 @@ ITaskItem referenceAssemblyName
             string itemSpec = referenceAssemblyName.ItemSpec;
             string fusionName = referenceAssemblyName.GetMetadata(ItemMetadataNames.fusionName);
             bool result = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.IgnoreVersionForFrameworkReference, out bool metadataFound);
-            bool ignoreVersionForFrameworkReference = false;
+            bool ignoreVersionForFrameworkReference;
 
             if (metadataFound)
             {
@@ -791,7 +792,7 @@ private static void TryGatherAssemblyNameEssentials(string fusionName, ref Assem
             }
             catch (FileLoadException)
             {
-                // Not a valid AssemblyName. Maybe its a file name.
+                // Not a valid AssemblyName. Maybe it's a file name.
                 // TryGatherAssemblyNameEssentials
                 return;
             }
@@ -1589,7 +1590,7 @@ private static void RemoveDependencies(Reference removedReference, Dictionary<As
         /// <param name="exceptions">Errors encountered while computing closure.</param>
         internal void ComputeClosure
         (
-            DependentAssembly[] remappedAssembliesValue,
+            List<DependentAssembly> remappedAssembliesValue,
             ITaskItem[] referenceAssemblyFiles,
             ITaskItem[] referenceAssemblyNames,
             ArrayList exceptions
@@ -1816,8 +1817,8 @@ private int ResolveConflictsBetweenReferences()
         /// </summary>
         internal void ResolveConflicts
         (
-            out DependentAssembly[] idealRemappings,
-            out AssemblyNameReference[] conflictingReferences
+            out List<DependentAssembly> idealRemappings,
+            out List<AssemblyNameReference> conflictingReferences
         )
         {
             idealRemappings = null;
@@ -1913,13 +1914,13 @@ out AssemblyNameReference[] conflictingReferences
                     OldVersionHigh = assemblyNameReference.assemblyName.AssemblyName.Version,
                     NewVersion = assemblyNameReference.assemblyName.AssemblyName.Version
                 };
-                remapping.BindingRedirects = new[] { bindingRedirect };
+                remapping.BindingRedirects = new List<BindingRedirect> { bindingRedirect };
 
                 idealRemappingsList.Add(remapping);
             }
 
-            idealRemappings = idealRemappingsList.ToArray();
-            conflictingReferences = assemblyNamesList.ToArray();
+            idealRemappings = idealRemappingsList;
+            conflictingReferences = assemblyNamesList;
         }
 
         /// <summary>
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 80b7f38c503..d8dc9ea4492 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -51,14 +51,7 @@ public class ResolveAssemblyReference : TaskExtension
         /// <summary>
         /// Cache of system state information, used to optimize performance.
         /// </summary>
-        private SystemState _cache = null;
-
-        /// <summary>
-        /// Construct
-        /// </summary>
-        public ResolveAssemblyReference()
-        {
-        }
+        private SystemState _cache;
 
         #region Properties
 
@@ -87,7 +80,6 @@ public ResolveAssemblyReference()
         private ITaskItem[] _serializationAssemblyFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _scatterFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _copyLocalFiles = Array.Empty<TaskItem>();
-        private ITaskItem[] _suggestedRedirects = Array.Empty<TaskItem>();
         private string[] _targetFrameworkSubsets = Array.Empty<string>();
         private string[] _fullTargetFrameworkSubsetNames = Array.Empty<string>();
         private string _targetedFrameworkMoniker = String.Empty;
@@ -701,11 +693,7 @@ public string TargetFrameworkMoniker
         /// <summary>
         /// The display name of the target framework moniker, if any. This is only for logging.
         /// </summary>
-        public string TargetFrameworkMonikerDisplayName
-        {
-            get;
-            set;
-        }
+        public string TargetFrameworkMonikerDisplayName { get; set; }
 
         /// <summary>
         /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring 
@@ -868,15 +856,12 @@ public ITaskItem[] CopyLocalFiles
         ///  MaxVersion - the maximum version number.
         /// </summary>
         [Output]
-        public ITaskItem[] SuggestedRedirects
-        {
-            get { return _suggestedRedirects; }
-        }
+        public ITaskItem[] SuggestedRedirects { get; private set; } = Array.Empty<TaskItem>();
 
         /// <summary>
         /// Storage for names of all files writen to disk.
         /// </summary>
-        private ArrayList _filesWritten = new ArrayList();
+        private readonly ArrayList _filesWritten = new ArrayList();
 
         /// <summary>
         /// The names of all files written to disk.
@@ -923,8 +908,8 @@ public String DependsOnNETStandard
         private bool LogResults
         (
             ReferenceTable dependencyTable,
-            DependentAssembly[] idealAssemblyRemappings,
-            AssemblyNameReference[] idealAssemblyRemappingsIdentities,
+            List<DependentAssembly> idealAssemblyRemappings,
+            List<AssemblyNameReference> idealAssemblyRemappingsIdentities,
             ArrayList generalResolutionExceptions
         )
         {
@@ -994,15 +979,15 @@ quiet at the engine level.
                         var ns = XNamespace.Get("urn:schemas-microsoft-com:asm.v1");
 
                         // A high-priority message for each individual redirect.
-                        for (int i = 0; i < idealAssemblyRemappings.Length; i++)
+                        for (int i = 0; i < idealAssemblyRemappings.Count; i++)
                         {
                             DependentAssembly idealRemapping = idealAssemblyRemappings[i];
                             AssemblyName idealRemappingPartialAssemblyName = idealRemapping.PartialAssemblyName;
                             Reference reference = idealAssemblyRemappingsIdentities[i].reference;
 
-                            AssemblyNameExtension[] conflictVictims = reference.GetConflictVictims();
+                            List<AssemblyNameExtension> conflictVictims = reference.GetConflictVictims();
 
-                            for (int j = 0; j < idealRemapping.BindingRedirects.Length; j++)
+                            for (int j = 0; j < idealRemapping.BindingRedirects.Count; j++)
                             {
                                 foreach (AssemblyNameExtension conflictVictim in conflictVictims)
                                 {
@@ -1042,10 +1027,9 @@ quiet at the engine level.
                                         assemblyIdentityAttributes.Add(new XAttribute("name", idealRemappingPartialAssemblyName.Name));
 
                                         // We use "neutral" for "Invariant Language (Invariant Country)" in assembly names.
-                                        var cultureString = idealRemappingPartialAssemblyName.CultureName;
                                         assemblyIdentityAttributes.Add(new XAttribute("culture", String.IsNullOrEmpty(idealRemappingPartialAssemblyName.CultureName) ? "neutral" : idealRemappingPartialAssemblyName.CultureName));
 
-                                        var publicKeyToken = idealRemappingPartialAssemblyName.GetPublicKeyToken();
+                                        byte[] publicKeyToken = idealRemappingPartialAssemblyName.GetPublicKeyToken();
                                         assemblyIdentityAttributes.Add(new XAttribute("publicKeyToken", ResolveAssemblyReference.ByteArrayToString(publicKeyToken)));
 
                                         var node = new XElement(
@@ -1065,7 +1049,7 @@ quiet at the engine level.
                                 }
                             }
 
-                            if (conflictVictims.Length == 0)
+                            if (conflictVictims.Count == 0)
                             {
                                 // This warning is logged regardless of AutoUnify since it means a conflict existed where the reference
                                 // chosen was not the conflict victor in a version comparison, in other words it was older.
@@ -1074,7 +1058,7 @@ quiet at the engine level.
                         }
 
                         // Log the warning
-                        if (idealAssemblyRemappings.Length > 0 && foundAtLeastOneValidBindingRedirect)
+                        if (idealAssemblyRemappings.Count > 0 && foundAtLeastOneValidBindingRedirect)
                         {
                             if (SupportsBindingRedirectGeneration)
                             {
@@ -1869,8 +1853,7 @@ private void WriteStateFile()
         /// <summary>
         /// Read the app.config and get any assembly remappings from it.
         /// </summary>
-        /// <returns></returns>
-        private DependentAssembly[] GetAssemblyRemappingsFromAppConfig()
+        private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         {
             if (_appConfigFile != null)
             {
@@ -1964,9 +1947,8 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         }
                     }
 
-
                     // Validate the contents of the InstalledAssemblyTables parameter.
-                    AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(_ignoreDefaultInstalledAssemblyTables, _installedAssemblyTables, new GetListPath(RedistList.GetRedistListPathsFromDisk), TargetFrameworkDirectories);
+                    AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(_ignoreDefaultInstalledAssemblyTables, _installedAssemblyTables, RedistList.GetRedistListPathsFromDisk, TargetFrameworkDirectories);
                     AssemblyTableInfo[] whiteListSubsetTableInfo = null;
 
                     InstalledAssemblies installedAssemblies = null;
@@ -2090,7 +2072,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     FilterBySubtypeAndTargetFramework();
 
                     // Compute the set of bindingRedirect remappings.
-                    DependentAssembly[] appConfigRemappedAssemblies = null;
+                    List<DependentAssembly> appConfigRemappedAssemblies = null;
                     if (FindDependencies)
                     {
                         try
@@ -2112,7 +2094,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             : null;
 
                     // Start the table of dependencies with all of the primary references.
-                    ReferenceTable dependencyTable = new ReferenceTable
+                    var dependencyTable = new ReferenceTable
                     (
                         BuildEngine,
                         _findDependencies,
@@ -2161,10 +2143,10 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     ArrayList generalResolutionExceptions = new ArrayList();
 
                     subsetOrProfileName = targetingSubset && String.IsNullOrEmpty(_targetedFrameworkMoniker) ? subsetOrProfileName : _targetedFrameworkMoniker;
-                    bool excludedReferencesExist = false;
+                    bool excludedReferencesExist;
 
-                    DependentAssembly[] autoUnifiedRemappedAssemblies = null;
-                    AssemblyNameReference[] autoUnifiedRemappedAssemblyReferences = null;
+                    List<DependentAssembly> autoUnifiedRemappedAssemblies = null;
+                    List<AssemblyNameReference> autoUnifiedRemappedAssemblyReferences = null;
                     if (AutoUnify && FindDependencies)
                     {
                         // Compute all dependencies.
@@ -2197,7 +2179,6 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             dependencyTable.RemoveReferencesMarkedForExclusion(true /* Remove the reference and do not warn*/, subsetOrProfileName);
                         }
 
-
                         // Based on the closure, get a table of ideal remappings needed to 
                         // produce zero conflicts.
                         dependencyTable.ResolveConflicts
@@ -2207,7 +2188,7 @@ out autoUnifiedRemappedAssemblyReferences
                         );
                     }
 
-                    DependentAssembly[] allRemappedAssemblies = CombineRemappedAssemblies(appConfigRemappedAssemblies, autoUnifiedRemappedAssemblies);
+                    List<DependentAssembly> allRemappedAssemblies = CombineRemappedAssemblies(appConfigRemappedAssemblies, autoUnifiedRemappedAssemblies);
 
                     // Compute all dependencies.
                     dependencyTable.ComputeClosure(allRemappedAssemblies, _assemblyFiles, _assemblyNames, generalResolutionExceptions);
@@ -2232,13 +2213,10 @@ out autoUnifiedRemappedAssemblyReferences
                     }
 
                     // Resolve any conflicts.
-                    DependentAssembly[] idealAssemblyRemappings = null;
-                    AssemblyNameReference[] idealAssemblyRemappingsIdentities = null;
-
                     dependencyTable.ResolveConflicts
                     (
-                        out idealAssemblyRemappings,
-                        out idealAssemblyRemappingsIdentities
+                        out List<DependentAssembly> idealAssemblyRemappings,
+                        out List<AssemblyNameReference> idealAssemblyRemappingsIdentities
                     );
 
                     // Build the output tables.
@@ -2259,8 +2237,8 @@ out _copyLocalFiles
                         // Build the table of suggested redirects. If we're auto-unifying, we want to output all the 
                         // assemblies that we auto-unified so that GenerateBindingRedirects can consume them, 
                         // not just the required ones for build to succeed
-                        DependentAssembly[] remappings = AutoUnify ? autoUnifiedRemappedAssemblies : idealAssemblyRemappings;
-                        AssemblyNameReference[] remappedReferences = AutoUnify ? autoUnifiedRemappedAssemblyReferences : idealAssemblyRemappingsIdentities;
+                        List<DependentAssembly> remappings = AutoUnify ? autoUnifiedRemappedAssemblies : idealAssemblyRemappings;
+                        List<AssemblyNameReference> remappedReferences = AutoUnify ? autoUnifiedRemappedAssemblyReferences : idealAssemblyRemappingsIdentities;
                         PopulateSuggestedRedirects(remappings, remappedReferences);
                     }
 
@@ -2319,8 +2297,8 @@ out _copyLocalFiles
                         }
                     }
 
-                    this.DependsOnSystemRuntime = useSystemRuntime.ToString();
-                    this.DependsOnNETStandard = useNetStandard.ToString();
+                    DependsOnSystemRuntime = useSystemRuntime.ToString();
+                    DependsOnNETStandard = useNetStandard.ToString();
 
                     WriteStateFile();
 
@@ -2347,7 +2325,7 @@ out _copyLocalFiles
                                 {
                                     assemblyName = getAssemblyName(item.ItemSpec);
                                 }
-                                catch (System.IO.FileLoadException)
+                                catch (FileLoadException)
                                 {
                                     // Its pretty hard to get here, you need an assembly that contains a valid reference
                                     // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
@@ -2418,7 +2396,7 @@ out _copyLocalFiles
         /// <param name="getAssemblyMetadata">the delegate to access assembly metadata</param>
         /// <param name="assemblyMetadataCache">Cache of pre-extracted assembly metadata.</param>
         /// <returns>list of dependencies</returns>
-        private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, FileExists fileExists, GetAssemblyMetadata getAssemblyMetadata, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
+        private static AssemblyNameExtension[] GetDependencies(Reference resolvedReference, FileExists fileExists, GetAssemblyMetadata getAssemblyMetadata, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
         {
             AssemblyNameExtension[] result = null;
             if (resolvedReference != null && resolvedReference.IsPrimary && !resolvedReference.IsBadImage)
@@ -2448,7 +2426,7 @@ private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, Fil
         /// <summary>
         /// Combines two DependentAssembly arrays into one.
         /// </summary>
-        private static DependentAssembly[] CombineRemappedAssemblies(DependentAssembly[] first, DependentAssembly[] second)
+        private static List<DependentAssembly> CombineRemappedAssemblies(List<DependentAssembly> first, List<DependentAssembly> second)
         {
             if (first == null)
                 return second;
@@ -2456,9 +2434,9 @@ private static DependentAssembly[] CombineRemappedAssemblies(DependentAssembly[]
             if (second == null)
                 return first;
 
-            DependentAssembly[] combined = new DependentAssembly[first.Length + second.Length];
-            first.CopyTo(combined, 0);
-            second.CopyTo(combined, first.Length);
+            var combined = new List<DependentAssembly>(first.Count + second.Count);
+            combined.AddRange(first);
+            combined.AddRange(second);
 
             return combined;
         }
@@ -2720,26 +2698,26 @@ private bool ShouldUseSubsetBlackList()
         /// </summary>
         /// <param name="idealAssemblyRemappings">The list of ideal remappings.</param>
         /// <param name="idealAssemblyRemappedReferences">The list of of references to ideal assembly remappings.</param>
-        private void PopulateSuggestedRedirects(DependentAssembly[] idealAssemblyRemappings, AssemblyNameReference[] idealAssemblyRemappedReferences)
+        private void PopulateSuggestedRedirects(List<DependentAssembly> idealAssemblyRemappings, List<AssemblyNameReference> idealAssemblyRemappedReferences)
         {
-            ArrayList holdSuggestedRedirects = new ArrayList();
+            var holdSuggestedRedirects = new List<ITaskItem>();
             if (idealAssemblyRemappings != null)
             {
-                for (int i = 0; i < idealAssemblyRemappings.Length; i++)
+                for (int i = 0; i < idealAssemblyRemappings.Count; i++)
                 {
                     DependentAssembly idealRemapping = idealAssemblyRemappings[i];
                     string itemSpec = idealRemapping.PartialAssemblyName.ToString();
 
                     Reference reference = idealAssemblyRemappedReferences[i].reference;
-                    AssemblyNameExtension[] conflictVictims = reference.GetConflictVictims();
+                    List<AssemblyNameExtension> conflictVictims = reference.GetConflictVictims();
 
                     // Skip any remapping that has no conflict victims since a redirect will not help.
-                    if (null == conflictVictims || 0 == conflictVictims.Length)
+                    if (null == conflictVictims || 0 == conflictVictims.Count)
                     {
                         continue;
                     }
 
-                    for (int j = 0; j < idealRemapping.BindingRedirects.Length; j++)
+                    for (int j = 0; j < idealRemapping.BindingRedirects.Count; j++)
                     {
                         ITaskItem suggestedRedirect = new TaskItem();
                         suggestedRedirect.ItemSpec = itemSpec;
@@ -2748,10 +2726,9 @@ private void PopulateSuggestedRedirects(DependentAssembly[] idealAssemblyRemappi
                     }
                 }
             }
-            _suggestedRedirects = (ITaskItem[])holdSuggestedRedirects.ToArray(typeof(ITaskItem));
+            SuggestedRedirects = holdSuggestedRedirects.ToArray();
         }
 
-
         /// <summary>
         /// Process TargetFrameworkDirectories and an array of InstalledAssemblyTables.
         /// The goal is this:  for each installed assembly table (whether found on disk
@@ -2761,7 +2738,7 @@ private void PopulateSuggestedRedirects(DependentAssembly[] idealAssemblyRemappi
         /// <returns>Array of AssemblyTableInfo objects (Describe the path and framework directory of a redist or subset list xml file) </returns>
         private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAssemblyTables, ITaskItem[] assemblyTables, GetListPath GetAssemblyListPaths, string[] targetFrameworkDirectories)
         {
-            Dictionary<string, AssemblyTableInfo> tableMap = new Dictionary<string, AssemblyTableInfo>(StringComparer.OrdinalIgnoreCase);
+            var tableMap = new Dictionary<string, AssemblyTableInfo>(StringComparer.OrdinalIgnoreCase);
 
             if (!ignoreInstalledAssemblyTables)
             {
@@ -2805,7 +2782,7 @@ private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAs
                 tableMap[installedAssemblyTable.ItemSpec] = new AssemblyTableInfo(installedAssemblyTable.ItemSpec, frameworkDirectory);
             }
 
-            AssemblyTableInfo[] extensions = new AssemblyTableInfo[tableMap.Count];
+            var extensions = new AssemblyTableInfo[tableMap.Count];
             tableMap.Values.CopyTo(extensions, 0);
 
             return extensions;
@@ -2853,11 +2830,11 @@ private bool IsAvailableForTargetFramework(string assemblyFXVersionAsString)
         /// </summary>
         private void FilterBySubtypeAndTargetFramework()
         {
-            ArrayList assembliesLeft = new ArrayList();
+            var assembliesLeft = new List<ITaskItem>();
             foreach (ITaskItem assembly in Assemblies)
             {
                 string subType = assembly.GetMetadata(ItemMetadataNames.subType);
-                if (subType != null && subType.Length > 0)
+                if (!string.IsNullOrEmpty(subType))
                 {
                     Log.LogMessageFromResources(MessageImportance.Normal, "ResolveAssemblyReference.IgnoringBecauseNonEmptySubtype", assembly.ItemSpec, subType);
                 }
@@ -2872,7 +2849,7 @@ private void FilterBySubtypeAndTargetFramework()
             }
 
             // Save the array of assemblies filtered by SubType==''.
-            _assemblyNames = (ITaskItem[])assembliesLeft.ToArray(typeof(ITaskItem));
+            _assemblyNames = assembliesLeft.ToArray();
         }
 
         /// <summary>
@@ -2949,7 +2926,7 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr
         /// Execute the task.
         /// </summary>
         /// <returns>True if there was success.</returns>
-        override public bool Execute()
+        public override bool Execute()
         {
             return Execute
             (
diff --git a/src/Tasks/CallTarget.cs b/src/Tasks/CallTarget.cs
index f08f0d933fa..5752e2b47a0 100644
--- a/src/Tasks/CallTarget.cs
+++ b/src/Tasks/CallTarget.cs
@@ -73,8 +73,8 @@ public override bool Execute()
             // the targets together, or we call the engine separately for each target.
             List<string[]> targetLists = MSBuild.CreateTargetLists(Targets, RunEachTargetSeparately);
 
-            var singleProject = new ITaskItem[1];
-            singleProject[0] = null;
+            var singleProject = new List<ITaskItem>(1) { null };
+
             // Build the specified targets in the current project.
             return MSBuild.ExecuteTargets
                 (
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 68d49af11bf..7924f390287 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -77,12 +77,12 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         /// <summary>
         /// Merged set of assembly reference paths (default + specified)
         /// </summary>
-        private string[] _referencedAssemblies;
+        private List<string> _referencedAssemblies;
 
         /// <summary>
         /// Merged set of namespaces (default + specified) 
         /// </summary>
-        private string[] _usingNamespaces;
+        private List<string> _usingNamespaces;
 
         /// <summary>
         /// Type of code fragment, ie   Fragment, Class, Method
@@ -445,7 +445,7 @@ private static void CreateProperty(CodeTypeDeclaration codeTypeDeclaration, Task
         /// Extract the <Reference /> elements from the <UsingTask />
         /// </summary>
         /// <returns>string[] of reference paths</returns>
-        private string[] ExtractReferencedAssemblies()
+        private List<string> ExtractReferencedAssemblies()
         {
             XmlNodeList referenceNodes = _taskNode.SelectNodes("//*[local-name()='Reference']");
             var references = new List<string>();
@@ -469,14 +469,14 @@ private string[] ExtractReferencedAssemblies()
                 references.Add(attribute.Value);
             }
 
-            return references.ToArray();
+            return references;
         }
 
         /// <summary>
         /// Extract the <Using /> elements from the <UsingTask />
         /// </summary>
         /// <returns>string[] of using's</returns>
-        private string[] ExtractUsingNamespaces()
+        private List<string> ExtractUsingNamespaces()
         {
             XmlNodeList usingNodes = _taskNode.SelectNodes("//*[local-name()='Using']");
 
@@ -500,7 +500,7 @@ private string[] ExtractUsingNamespaces()
                 usings.Add(attribute.Value);
             }
 
-            return usings.ToArray();
+            return usings;
         }
 
         /// <summary>
@@ -720,7 +720,7 @@ private void AddReferenceAssemblyToReferenceList(List<string> referenceAssemblyL
         private Assembly CompileInMemoryAssembly()
         {
             // Combine our default assembly references with those specified
-            List<string> finalReferencedAssemblies = new List<string>();
+            var finalReferencedAssemblies = new List<string>();
             CombineReferencedAssemblies(finalReferencedAssemblies);
 
             // Combine our default using's with those specified
@@ -875,10 +875,10 @@ private string[] CombineUsingNamespaces()
 
             if (_usingNamespaces != null)
             {
-                usingNamespaceCount += _usingNamespaces.Length;
+                usingNamespaceCount += _usingNamespaces.Count;
             }
 
-            string[] finalUsingNamespaces = new string[usingNamespaceCount];
+            var finalUsingNamespaces = new string[usingNamespaceCount];
             _defaultUsingNamespaces.CopyTo(finalUsingNamespaces, 0);
             _usingNamespaces?.CopyTo(finalUsingNamespaces, _defaultUsingNamespaces.Length);
 
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 1750bdac7f5..ba5b91afb4d 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -250,7 +250,7 @@ public override bool Execute()
             List<string[]> targetLists = CreateTargetLists(Targets, RunEachTargetSeparately);
 
             bool success = true;
-            ITaskItem[] singleProject = null;
+            List<ITaskItem> singleProject = null;
             bool[] skipProjects = null;
 
             if (BuildInParallel)
@@ -263,7 +263,7 @@ public override bool Execute()
             }
             else
             {
-                singleProject = new ITaskItem[1];
+                singleProject = new List<ITaskItem>(1) { null };
             }
 
             // Read in each project file.  If there are any errors opening the file or parsing the XML,
@@ -357,22 +357,21 @@ private bool BuildProjectsInParallel(Dictionary<string, string> propertiesTable,
         {
             // There were some projects that were skipped so we need to recreate the
             // project array with those projects removed
-            var projectsToBuildList = new List<ITaskItem>();
+            var projectsToBuildInParallel = new List<ITaskItem>();
             for (int i = 0; i < Projects.Length; i++)
             {
                 if (!skipProjects[i])
                 {
-                    projectsToBuildList.Add(Projects[i]);
+                    projectsToBuildInParallel.Add(Projects[i]);
                 }
             }
-            ITaskItem[] projectToBuildInParallel = projectsToBuildList.ToArray();
 
             // Make the call to build the projects
-            if (projectToBuildInParallel.Length > 0)
+            if (projectsToBuildInParallel.Count > 0)
             {
                 if (!ExecuteTargets
                                 (
-                                projectToBuildInParallel,
+                                projectsToBuildInParallel,
                                 propertiesTable,
                                 undefinePropertiesArray,
                                 targetLists,
@@ -466,7 +465,7 @@ internal static List<string[]> CreateTargetLists(string[] targets, bool runEachT
         /// <returns>True if the operation was successful</returns>
         internal static bool ExecuteTargets
             (
-            ITaskItem[] projects,
+            List<ITaskItem> projects,
             Dictionary<string, string> propertiesTable,
             string[] undefineProperties,
             List<string[]> targetLists,
@@ -485,11 +484,11 @@ string toolsVersion
             // We don't log a message about the project and targets we're going to
             // build, because it'll all be in the immediately subsequent ProjectStarted event.
 
-            var projectDirectory = new string[projects.Length];
-            var projectNames = new string[projects.Length];
-            var toolsVersions = new string[projects.Length];
-            var projectProperties = new Dictionary<string, string>[projects.Length];
-            var undefinePropertiesPerProject = new IList<string>[projects.Length];
+            var projectDirectory = new string[projects.Count];
+            var projectNames = new string[projects.Count];
+            var toolsVersions = new string[projects.Count];
+            var projectProperties = new Dictionary<string, string>[projects.Count];
+            var undefinePropertiesPerProject = new IList<string>[projects.Count];
 
             for (int i = 0; i < projectNames.Length; i++)
             {
@@ -610,7 +609,7 @@ string toolsVersion
                 // If the engine was able to satisfy the build request
                 if (currentTargetResult)
                 {
-                    for (int i = 0; i < projects.Length; i++)
+                    for (int i = 0; i < projects.Count; i++)
                     {
                         IEnumerable<string> nonNullTargetList = targetList ?? targetOutputsPerProject[i].Keys;
 
diff --git a/src/Tasks/ManifestUtil/CompatibleFrameworkCollection.cs b/src/Tasks/ManifestUtil/CompatibleFrameworkCollection.cs
index fd08bc8446e..0bd16d486c3 100644
--- a/src/Tasks/ManifestUtil/CompatibleFrameworkCollection.cs
+++ b/src/Tasks/ManifestUtil/CompatibleFrameworkCollection.cs
@@ -12,7 +12,7 @@ public sealed class CompatibleFrameworkCollection : IEnumerable
     {
         private readonly List<CompatibleFramework> _list = new List<CompatibleFramework>();
 
-        internal CompatibleFrameworkCollection(CompatibleFramework[] compatibleFrameworks)
+        internal CompatibleFrameworkCollection(IEnumerable<CompatibleFramework> compatibleFrameworks)
         {
             if (compatibleFrameworks == null)
             {
@@ -39,10 +39,5 @@ public IEnumerator GetEnumerator()
         {
             return _list.GetEnumerator();
         }
-
-        internal CompatibleFramework[] ToArray()
-        {
-            return _list.ToArray();
-        }
     }
 }
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index bc4ad3a9d42..3136826605e 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -318,7 +318,7 @@ public CompatibleFrameworkCollection CompatibleFrameworks
             {
                 if (_compatibleFrameworkList == null && _compatibleFrameworks != null)
                 {
-                    _compatibleFrameworkList = new CompatibleFrameworkCollection(_compatibleFrameworks.ToArray());
+                    _compatibleFrameworkList = new CompatibleFrameworkCollection(_compatibleFrameworks);
                 }
                 return _compatibleFrameworkList;
             }
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 02d1951e168..2b4fba76c6a 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -463,15 +463,9 @@ public string GetUnifiedAssemblyName(string assemblyName)
         /// <summary>
         /// Find every assembly full name that matches the given simple name.
         /// </summary>
-        /// <param name="simpleName"></param>
-        /// <returns>The array of assembly names.</returns>
-        internal AssemblyEntry[] FindAssemblyNameFromSimpleName
-        (
-            string simpleName
-        )
+        /// <returns>The list of assembly names.</returns>
+        internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simpleName)
         {
-            var candidateNames = new List<AssemblyEntry>();
-
             if (_simpleNameMap.TryGetValue(simpleName, out int index))
             {
                 for (int i = index; i < _assemblyList.Count; ++i)
@@ -481,11 +475,9 @@ string simpleName
                     {
                         break;
                     }
-                    candidateNames.Add(entry);
+                    yield return entry;
                 }
             }
-
-            return candidateNames.ToArray();
         }
 
         /// <summary>
@@ -946,8 +938,8 @@ internal class SubsetListFinder
         // K: target framework directory + subsetNames, V: subset list paths found on disk underneath the subsetList folder
         private static Dictionary<string, string[]> s_subsetListPathCache;
 
-        // Locl for subsetListPathCache
-        private static readonly Object s_subsetListPathCacheLock = new Object();
+        // Lock for subsetListPathCache
+        private static readonly object s_subsetListPathCacheLock = new object();
 
         // Folder to look for the subset lists in under the target framework directories
         private const string subsetListFolder = "SubsetList";
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 8ba560eba27..f0f0be57877 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -315,7 +315,7 @@ private static string GetItemTargetPath(ITaskItem item)
             return targetPath;
         }
 
-        private void GetOutputAssemblies(List<PublishInfo> publishInfos, ref List<ITaskItem> assemblyList)
+        private void GetOutputAssemblies(List<PublishInfo> publishInfos, List<ITaskItem> assemblyList)
         {
             var assemblyMap = new AssemblyMap();
 
@@ -407,8 +407,8 @@ private void GetOutputAssemblies(List<PublishInfo> publishInfos, ref List<ITaskI
         private ITaskItem[] GetOutputAssembliesAndSatellites(List<PublishInfo> assemblyPublishInfos, List<PublishInfo> satellitePublishInfos)
         {
             var assemblyList = new List<ITaskItem>();
-            GetOutputAssemblies(assemblyPublishInfos, ref assemblyList);
-            GetOutputSatellites(satellitePublishInfos, ref assemblyList);
+            GetOutputAssemblies(assemblyPublishInfos, assemblyList);
+            GetOutputSatellites(satellitePublishInfos, assemblyList);
             return assemblyList.ToArray();
         }
 
@@ -478,7 +478,7 @@ private ITaskItem[] GetOutputFiles(List<PublishInfo> publishInfos)
             return fileList.ToArray();
         }
 
-        private void GetOutputSatellites(List<PublishInfo> publishInfos, ref List<ITaskItem> assemblyList)
+        private void GetOutputSatellites(List<PublishInfo> publishInfos, List<ITaskItem> assemblyList)
         {
             var satelliteMap = new FileMap();
 
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index cd81dd7f370..d0b314407b2 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -406,7 +406,7 @@ public override bool Execute()
                         // Only log a warning or error if there were incompatible references
                         if (listOfIncompatibleReferences.Count > 0)
                         {
-                            string incompatibleReferencesDelimited = String.Join(", ", listOfIncompatibleReferences.ToArray());
+                            string incompatibleReferencesDelimited = String.Join(", ", listOfIncompatibleReferences);
                             if (notCompatibleReference.SupportsMultipleVersions == MultipleVersionSupport.Error)
                             {
                                 Log.LogErrorWithCodeFromResources("ResolveSDKReference.CannotReferenceTwoSDKsSameFamily", notCompatibleReference.SDKName, incompatibleReferencesDelimited, notCompatibleReference.ProductFamilyName);
@@ -435,7 +435,7 @@ public override bool Execute()
                     // Only log a warning or error if there were incompatible references
                     if (listOfIncompatibleReferences.Count > 0)
                     {
-                        string incompatibleReferencesDelimited = String.Join(", ", listOfIncompatibleReferences.ToArray());
+                        string incompatibleReferencesDelimited = string.Join(", ", listOfIncompatibleReferences);
                         if (notCompatibleReference.SupportsMultipleVersions == MultipleVersionSupport.Error)
                         {
                             Log.LogErrorWithCodeFromResources("ResolveSDKReference.CannotReferenceTwoSDKsSameName", notCompatibleReference.SDKName, incompatibleReferencesDelimited);
@@ -451,7 +451,7 @@ public override bool Execute()
             AddMetadataToReferences(Log, sdkReferenceItems, _runtimeReferenceOnlyDependenciesByName, "RuntimeReferenceOnly", "true");
 
             // Gather the ResolvedItems from the SDKReference where the reference was resolved.
-            ResolvedSDKReferences = sdkReferenceItems.Where(x => x.Resolved).Select(x => x.ResolvedItem).ToArray<ITaskItem>();
+            ResolvedSDKReferences = sdkReferenceItems.Where(x => x.Resolved).Select(x => x.ResolvedItem).ToArray();
 
             VerifySDKDependsOn(Log, sdkReferenceItems);
 
@@ -1340,9 +1340,9 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                         // For testing especially it's nice to have a set order of what the generated appxlocation string will be at the end
                         var architectureLocations = new SortedDictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
-                        List<string> appxLocationComponents = new List<string>();
+                        var appxLocationComponents = new List<string>();
 
-                        foreach (var appxLocation in AppxLocationsFromManifest)
+                        foreach (KeyValuePair<string, string> appxLocation in AppxLocationsFromManifest)
                         {
                             if (!String.IsNullOrEmpty(appxLocation.Key))
                             {
@@ -1400,7 +1400,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                             }
                         }
 
-                        foreach (var location in architectureLocations)
+                        foreach (KeyValuePair<string, string> location in architectureLocations)
                         {
                             appxLocationComponents.Add(location.Key);
                             appxLocationComponents.Add(location.Value);
@@ -1434,10 +1434,9 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                 ResolvedItem.SetMetadata("Version", Version);
 
                 // Check to see if the copy local metadata has been set in the project file.
-                bool result;
-                bool hasExpandReferenceAssemblies = bool.TryParse(ReferenceItem.GetMetadata(SDKManifest.Attributes.ExpandReferenceAssemblies), out result);
-                bool hasCopyRedist = bool.TryParse(ReferenceItem.GetMetadata(SDKManifest.Attributes.CopyRedist), out result);
-                bool hasCopyLocalExpandedReferenceAssemblies = bool.TryParse(ReferenceItem.GetMetadata(SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies), out result);
+                bool hasExpandReferenceAssemblies = bool.TryParse(ReferenceItem.GetMetadata(SDKManifest.Attributes.ExpandReferenceAssemblies), out _);
+                bool hasCopyRedist = bool.TryParse(ReferenceItem.GetMetadata(SDKManifest.Attributes.CopyRedist), out _);
+                bool hasCopyLocalExpandedReferenceAssemblies = bool.TryParse(ReferenceItem.GetMetadata(SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies), out _);
 
                 bool referenceItemHasSDKName = sdkNamesOnReferenceItems.Contains(SDKName);
 
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 74f784cd581..62efbb81fd8 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -226,12 +226,12 @@ internal static string GetSourceCode(RoslynCodeTaskFactoryTaskInfo taskInfo, ICo
                 codeTypeDeclaration.Members.Add(new CodeSnippetTypeMember(taskInfo.SourceCode));
             }
 
-            CodeNamespace codeNamespace = new CodeNamespace("InlineCode");
+            var codeNamespace = new CodeNamespace("InlineCode");
             codeNamespace.Imports.AddRange(DefaultNamespaces.Union(taskInfo.Namespaces, StringComparer.OrdinalIgnoreCase).Select(i => new CodeNamespaceImport(i)).ToArray());
 
             codeNamespace.Types.Add(codeTypeDeclaration);
 
-            CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
+            var codeCompileUnit = new CodeCompileUnit();
 
             codeCompileUnit.Namespaces.Add(codeNamespace);
 
@@ -680,7 +680,7 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
                     managedCompiler.NoLogo = true;
                     managedCompiler.Optimize = false;
                     managedCompiler.OutputAssembly = new TaskItem(assemblyPath);
-                    managedCompiler.References = references.ToArray();
+                    managedCompiler.References = references;
                     managedCompiler.Sources = new ITaskItem[] { new TaskItem(sourceCodePath) };
                     managedCompiler.TargetType = "Library";
                     managedCompiler.UseSharedCompilation = false;
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 2012bfee446..aaa00a4bbe3 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Concurrent;
+using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
@@ -152,7 +153,7 @@ internal FileState(DateTime lastModified)
             /// </summary>
             internal FileState(SerializationInfo info, StreamingContext context)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
                 lastModified = new DateTime(info.GetInt64("mod"), (DateTimeKind)info.GetInt32("modk"));
                 assemblyName = (AssemblyNameExtension)info.GetValue("an", typeof(AssemblyNameExtension));
@@ -174,7 +175,7 @@ internal FileState(SerializationInfo info, StreamingContext context)
             [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
             public void GetObjectData(SerializationInfo info, StreamingContext context)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
                 info.AddValue("mod", lastModified.Ticks);
                 info.AddValue("modk", (int)lastModified.Kind);
@@ -243,7 +244,7 @@ internal SystemState()
         /// </summary>
         internal SystemState(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             instanceLocalFileStateCache = (Hashtable)info.GetValue("fileState", typeof(Hashtable));
             isDirty = false;
@@ -254,8 +255,6 @@ internal SystemState(SerializationInfo info, StreamingContext context)
         /// This is used to optimize IO in the case of files requested from one 
         /// of the FX folders.
         /// </summary>
-        /// <param name="providedFrameworkPaths"></param>
-        /// <param name="installedAssemblyTables"></param>
         internal void SetInstalledAssemblyInformation
         (
             AssemblyTableInfo[] installedAssemblyTableInfos
@@ -270,7 +269,7 @@ AssemblyTableInfo[] installedAssemblyTableInfos
         [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
         public void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             info.AddValue("fileState", instanceLocalFileStateCache);
         }
@@ -287,7 +286,7 @@ internal bool IsDirty
         /// <summary>
         /// Set the GetLastWriteTime delegate.
         /// </summary>
-        /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
+        /// <param name="getLastWriteTimeValue">Delegate used to get the last write time.</param>
         internal void SetGetLastWriteTime(GetLastWriteTime getLastWriteTimeValue)
         {
             getLastWriteTime = getLastWriteTimeValue;
@@ -296,7 +295,7 @@ internal void SetGetLastWriteTime(GetLastWriteTime getLastWriteTimeValue)
         /// <summary>
         /// Cache the results of a GetAssemblyName delegate. 
         /// </summary>
-        /// <param name="getAssemblyName">The delegate.</param>
+        /// <param name="getAssemblyNameValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
         internal GetAssemblyName CacheDelegate(GetAssemblyName getAssemblyNameValue)
         {
@@ -307,7 +306,7 @@ internal GetAssemblyName CacheDelegate(GetAssemblyName getAssemblyNameValue)
         /// <summary>
         /// Cache the results of a GetAssemblyMetadata delegate. 
         /// </summary>
-        /// <param name="getAssemblyMetadata">The delegate.</param>
+        /// <param name="getAssemblyMetadataValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
         internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetadataValue)
         {
@@ -318,7 +317,7 @@ internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetada
         /// <summary>
         /// Cache the results of a FileExists delegate. 
         /// </summary>
-        /// <param name="fileExists">The delegate.</param>
+        /// <param name="fileExistsValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
         internal FileExists CacheDelegate(FileExists fileExistsValue)
         {
@@ -335,7 +334,7 @@ public DirectoryExists CacheDelegate(DirectoryExists directoryExistsValue)
         /// <summary>
         /// Cache the results of a GetDirectories delegate. 
         /// </summary>
-        /// <param name="getDirectories">The delegate.</param>
+        /// <param name="getDirectoriesValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
         internal GetDirectories CacheDelegate(GetDirectories getDirectoriesValue)
         {
@@ -380,15 +379,14 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
         {
             // Is it in the process-wide cache?
             FileState cacheFileState = null;
-            FileState processFileState = null;
-            SystemState.s_processWideFileStateCache.TryGetValue(path, out processFileState);
-            FileState instanceLocalFileState = instanceLocalFileState = (FileState)instanceLocalFileStateCache[path];
+            s_processWideFileStateCache.TryGetValue(path, out FileState processFileState);
+            FileState instanceLocalFileState = (FileState)instanceLocalFileStateCache[path];
 
             // Sync the caches.
             if (processFileState == null && instanceLocalFileState != null)
             {
                 cacheFileState = instanceLocalFileState;
-                SystemState.s_processWideFileStateCache[path] = instanceLocalFileState;
+                s_processWideFileStateCache[path] = instanceLocalFileState;
             }
             else if (processFileState != null && instanceLocalFileState == null)
             {
@@ -405,7 +403,7 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
                 else
                 {
                     cacheFileState = instanceLocalFileState;
-                    SystemState.s_processWideFileStateCache[path] = instanceLocalFileState;
+                    s_processWideFileStateCache[path] = instanceLocalFileState;
                 }
             }
 
@@ -414,7 +412,7 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             {
                 cacheFileState = new FileState(getLastWriteTime(path));
                 instanceLocalFileStateCache[path] = cacheFileState;
-                SystemState.s_processWideFileStateCache[path] = cacheFileState;
+                s_processWideFileStateCache[path] = cacheFileState;
                 isDirty = true;
             }
             else
@@ -425,7 +423,7 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
                 {
                     cacheFileState = new FileState(getLastWriteTime(path));
                     instanceLocalFileStateCache[path] = cacheFileState;
-                    SystemState.s_processWideFileStateCache[path] = cacheFileState;
+                    s_processWideFileStateCache[path] = cacheFileState;
                     isDirty = true;
                 }
             }
@@ -433,32 +431,6 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             return cacheFileState;
         }
 
-        private FileState GetFileStateFromProcessWideCache(string path, FileState template)
-        {
-            // When reading from the process-wide cache, we always check to see if our data
-            // is up-to-date to avoid getting stale data from a previous build.
-            DateTime lastModified = getLastWriteTime(path);
-
-            // Has another build seen this file before?
-            FileState state;
-            if (!s_processWideFileStateCache.TryGetValue(path, out state) || state.LastModified != lastModified)
-            {   // We've never seen it before, or we're out of date
-
-                state = CreateFileState(lastModified, template);
-                s_processWideFileStateCache[path] = state;
-            }
-
-            return state;
-        }
-
-        private FileState CreateFileState(DateTime lastModified, FileState template)
-        {
-            if (template != null && template.LastModified == lastModified)
-                return template;    // Our serialized data is up-to-date
-
-            return new FileState(lastModified);
-        }
-
         /// <summary>
         /// Cached implementation of GetAssemblyName.
         /// </summary>
@@ -473,25 +445,24 @@ private AssemblyNameExtension GetAssemblyName(string path)
                 string extension = Path.GetExtension(path);
                 if (String.Compare(extension, ".dll", StringComparison.OrdinalIgnoreCase) == 0)
                 {
-                    AssemblyEntry[] assemblyNames = redistList.FindAssemblyNameFromSimpleName
+                    IEnumerable<AssemblyEntry> assemblyNames = redistList.FindAssemblyNameFromSimpleName
                         (
                             Path.GetFileNameWithoutExtension(path)
                         );
 
-                    for (int i = 0; i < assemblyNames.Length; ++i)
+                    foreach (AssemblyEntry a in assemblyNames)
                     {
                         string filename = Path.GetFileName(path);
-                        string pathFromRedistList = Path.Combine(assemblyNames[i].FrameworkDirectory, filename);
+                        string pathFromRedistList = Path.Combine(a.FrameworkDirectory, filename);
 
                         if (String.Equals(path, pathFromRedistList, StringComparison.OrdinalIgnoreCase))
                         {
-                            return new AssemblyNameExtension(assemblyNames[i].FullName);
+                            return new AssemblyNameExtension(a.FullName);
                         }
                     }
                 }
             }
-
-
+            
             // Not a well-known FX assembly so now check the cache.
             FileState fileState = GetFileState(path);
             if (fileState.Assembly == null)
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
index fa3739dea4d..2d406c80951 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -52,7 +52,7 @@ internal static bool RootContainsAllSubRootComponents(string compositeRoot, stri
         /// <param name="outputNewestFilename">Name of the most recently modified file.</param>
         /// <param name="outputNewestTime">Timestamp of the most recently modified file.</param>
         /// <returns>True if all members of 'files' exist, false otherwise</returns>
-        internal static bool FilesExistAndRecordNewestWriteTime(ITaskItem[] files, TaskLoggingHelper log, out DateTime outputNewestTime, out string outputNewestFilename)
+        internal static bool FilesExistAndRecordNewestWriteTime(ICollection<ITaskItem> files, TaskLoggingHelper log, out DateTime outputNewestTime, out string outputNewestFilename)
             => FilesExistAndRecordRequestedWriteTime(files, log, true /* return information about the newest file */, out outputNewestTime, out outputNewestFilename);
 
         /// <summary>
@@ -65,10 +65,10 @@ internal static bool FilesExistAndRecordNewestWriteTime(ITaskItem[] files, TaskL
         /// <param name="outputOldestFilename">Name of the least recently modified file.</param>
         /// <param name="outputOldestTime">Timestamp of the least recently modified file.</param>
         /// <returns>True if all members of 'files' exist, false otherwise</returns>
-        internal static bool FilesExistAndRecordOldestWriteTime(ITaskItem[] files, TaskLoggingHelper log, out DateTime outputOldestTime, out string outputOldestFilename)
+        internal static bool FilesExistAndRecordOldestWriteTime(ICollection<ITaskItem> files, TaskLoggingHelper log, out DateTime outputOldestTime, out string outputOldestFilename)
             => FilesExistAndRecordRequestedWriteTime(files, log, false /* return information about the oldest file */, out outputOldestTime, out outputOldestFilename);
 
-        private static bool FilesExistAndRecordRequestedWriteTime(ITaskItem[] files, TaskLoggingHelper log, bool getNewest, out DateTime requestedTime, out string requestedFilename)
+        private static bool FilesExistAndRecordRequestedWriteTime(ICollection<ITaskItem> files, TaskLoggingHelper log, bool getNewest, out DateTime requestedTime, out string requestedFilename)
         {
             bool allExist = true;
             requestedTime = getNewest ? DateTime.MinValue : DateTime.MaxValue;
@@ -76,7 +76,7 @@ private static bool FilesExistAndRecordRequestedWriteTime(ITaskItem[] files, Tas
 
             // No output files for the source were tracked
             // safely assume that this is because we didn't track them because they weren't compiled
-            if (files == null || files.Length == 0)
+            if (files == null || files.Count == 0)
             {
                 allExist = false;
             }
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 49b299ca234..5ec095c77ce 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -377,7 +377,6 @@ private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(b
 
             // We have our set of outputs, construct our array
             sourcesNeedingCompilationList.AddRange(sourcesNeedingCompilation.Values);
-            ITaskItem[] sourcesNeedingCompilationArray = sourcesNeedingCompilationList.ToArray();
 
             // now that we have our dependencies, we need to check if any of them are newer than the outputs.
             DateTime newestSourceDependencyTime;
@@ -386,7 +385,7 @@ private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(b
             string oldestOutputFile = string.Empty;
 
             if (
-                CanonicalTrackedFilesHelper.FilesExistAndRecordNewestWriteTime(sourcesNeedingCompilationArray, _log, out newestSourceDependencyTime, out newestSourceDependencyFile) &&
+                CanonicalTrackedFilesHelper.FilesExistAndRecordNewestWriteTime(sourcesNeedingCompilationList, _log, out newestSourceDependencyTime, out newestSourceDependencyFile) &&
                 CanonicalTrackedFilesHelper.FilesExistAndRecordOldestWriteTime(_outputFileGroup, _log, out oldestOutputTime, out oldestOutputFile)
                 )
             {
@@ -408,7 +407,7 @@ private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(b
                 // We have our set of outputs, log the details
                 FileTracker.LogMessageFromResources(_log, MessageImportance.Low, "Tracking_InputsFor", upperSourcesRoot);
 
-                foreach (ITaskItem inputItem in sourcesNeedingCompilationArray)
+                foreach (ITaskItem inputItem in sourcesNeedingCompilationList)
                 {
                     FileTracker.LogMessage(_log, MessageImportance.Low, "\t" + inputItem);
                 }
