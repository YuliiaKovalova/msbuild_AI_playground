diff --git a/src/Build.OM.UnitTests/AssemblyInfo.cs b/src/Build.OM.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/Build.OM.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index b5266a013fc..36c8a20a7f0 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -11,7 +11,7 @@
     <AssemblyName>Microsoft.Build.Engine.OM.UnitTests</AssemblyName>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
 
-    <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_OM_UNITTESTS</DefineConstants>
+    <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_OM_UNITTESTS;NO_FRAMEWORK_IVT</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -37,9 +37,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\Constants.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
     </Compile>
@@ -61,30 +58,15 @@
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedTraits.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\EngineTestEnvironment.cs">
       <Link>EngineTestEnvironment.cs</Link>
     </Compile>
     <Compile Include="..\Shared\UnitTests\TestEnvironment.cs">
       <Link>TestEnvironment.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs" />
     <Compile Include="..\Shared\FileUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Build.UnitTests/AssemblyInfo.cs b/src/Build.UnitTests/AssemblyInfo.cs
index 2ea5c6cf42b..7f6f30fcef9 100644
--- a/src/Build.UnitTests/AssemblyInfo.cs
+++ b/src/Build.UnitTests/AssemblyInfo.cs
@@ -1,6 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.CompilerServices;
-
-[assembly: InternalsVisibleTo("Microsoft.Build.Framework.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index eb37f60b029..9ccf30da8e2 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
diff --git a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
index a0a2965cc3b..68439641529 100644
--- a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -10,7 +11,7 @@
 namespace Microsoft.Build.UnitTests.BackEnd
 {
     /// <summary>
-    /// Tests for logging contexts. 
+    /// Tests for logging contexts.
     /// </summary>
     public class LoggingContext_Tests
     {
@@ -22,7 +23,7 @@ public LoggingContext_Tests(ITestOutputHelper outputHelper)
         }
 
         /// <summary>
-        /// A few simple tests for NodeLoggingContexts. 
+        /// A few simple tests for NodeLoggingContexts.
         /// </summary>
         [Fact]
         public void CreateValidNodeLoggingContexts()
@@ -47,9 +48,9 @@ public void CreateValidNodeLoggingContexts()
         }
 
         /// <summary>
-        /// Verifies that if an invalid node ID is passed to the NodeLoggingContext, it throws 
-        /// an exception -- this is to guarantee that if we're passing around invalid node IDs, 
-        /// we'll know about it.  
+        /// Verifies that if an invalid node ID is passed to the NodeLoggingContext, it throws
+        /// an exception -- this is to guarantee that if we're passing around invalid node IDs,
+        /// we'll know about it.
         /// </summary>
         [Fact]
         public void InvalidNodeIdOnNodeLoggingContext()
diff --git a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
index 801c8bedb38..82720f575ba 100644
--- a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 4005633d981..6791d729dd8 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 using Xunit;
diff --git a/src/Build.UnitTests/ChangeWaves_Tests.cs b/src/Build.UnitTests/ChangeWaves_Tests.cs
index d561fcaf9ef..9b151a10fc7 100644
--- a/src/Build.UnitTests/ChangeWaves_Tests.cs
+++ b/src/Build.UnitTests/ChangeWaves_Tests.cs
@@ -3,6 +3,7 @@
 
 using Xunit;
 using Shouldly;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.UnitTests;
diff --git a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
index 85ae11ffcdf..ca9c3f60b06 100644
--- a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
+++ b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
 using Xunit;
diff --git a/src/Build.UnitTests/Collections/OMcollections_tests.cs b/src/Build.UnitTests/Collections/OMcollections_tests.cs
index 4dfcbb75209..90a169b7a64 100644
--- a/src/Build.UnitTests/Collections/OMcollections_tests.cs
+++ b/src/Build.UnitTests/Collections/OMcollections_tests.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.Collections;
 using System;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
 using System.Collections;
 using System.Linq;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index 505088d7f86..ae23198472c 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index 1291e457fef..dfab66d8dbd 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -6,6 +6,7 @@
 using System.IO;
 
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
@@ -99,7 +100,7 @@ public void AddEntryStrongReference()
             GC.Collect();
 
             Assert.Null(ProjectCollection.GlobalProjectCollection.ProjectRootElementCache.TryGet(projectPath));
-        }   
+        }
 
         /// <summary>
         /// Cache should not return a ProjectRootElement if the file it was loaded from has since changed -
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index ed3030d0aa9..a25dec785b1 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -19,7 +19,7 @@
 using SdkResolverContext = Microsoft.Build.Framework.SdkResolverContext;
 using SdkResult = Microsoft.Build.Framework.SdkResult;
 using SdkResultFactory = Microsoft.Build.Framework.SdkResultFactory;
-using SdkReferencePropertyExpansionMode = Microsoft.Build.Utilities.EscapeHatches.SdkReferencePropertyExpansionMode;
+using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
 {
@@ -297,7 +297,7 @@ public void ProjectWithInvalidSdkName()
 
                 Project project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(content))));
             });
-            
+
             Assert.Equal("MSB4229", exception.ErrorCode);
         }
 
@@ -475,7 +475,7 @@ public void IgnoreMissingImportsSdkNotFoundDoesNotThrow()
                 loadSettings: ProjectLoadSettings.IgnoreMissingImports);
 
             project.GetPropertyValue("Success").ShouldBe("true");
-            
+
             ProjectImportedEventArgs[] events = logger.BuildMessageEvents.OfType<ProjectImportedEventArgs>().ToArray();
 
             // There are two implicit imports so there should be two logged ProjectImportedEventArgs
diff --git a/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
index f38192ebbb3..28fd32be143 100644
--- a/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 28af920a861..8846401318e 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
@@ -193,7 +194,7 @@ public void ConstructWithProjectInstanceFactory_FactoryReturnsNull_Throws()
                     (projectPath, globalProperties, projectCollection) => null));
             }
         }
-        
+
         /// <summary>
         ///   1
         ///  / \
@@ -763,7 +764,7 @@ public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()
                 var root1 = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: new Dictionary<string, string[]> {{"A", new[] {"B"}}}, defaultTargets: "A").Path;
                 var root2 = CreateProjectFile(env: env, projectNumber: 2, projectReferences: new[] {3}, projectReferenceTargets: new Dictionary<string, string[]> {{"B", new[] {"C"}}, {"X", new[] {"Y"}}}, defaultTargets: "X").Path;
                 CreateProjectFile(env: env, projectNumber: 3);
-                
+
 
                 var projectGraph = new ProjectGraph(new []{root1, root2});
                 projectGraph.ProjectNodes.Count.ShouldBe(3);
@@ -870,7 +871,7 @@ public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()
                     extraContent: ProjectReferenceTargetsWithMultitargeting)
                     .Path;
                 CreateProjectFile(env, 2);
-                
+
                 var projectGraph = new ProjectGraph(root1);
 
                 var dot = projectGraph.ToDot();
@@ -910,8 +911,8 @@ public void GetTargetsListInnerBuildToInnerBuild()
                     projectReferenceTargets: null,
                     defaultTargets: null,
                     extraContent: singleTargetedSpec);
-                
-                
+
+
                 var projectGraph = new ProjectGraph(root1);
 
                 var dot = projectGraph.ToDot();
@@ -945,7 +946,7 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()
                     projectReferenceTargets: null,
                     defaultTargets: null,
                     extraContent: OuterBuildSpecificationWithProjectReferenceTargets);
-                
+
                 var projectGraph = new ProjectGraph(root1);
 
                 var dot = projectGraph.ToDot();
@@ -1117,7 +1118,7 @@ public void GetTargetListsForComplexMultitargetingGraph()
                     projectReferenceTargets: null,
                     defaultTargets: null,
                     extraContent: OuterBuildSpecificationWithProjectReferenceTargets);
-                
+
                 var projectGraph = new ProjectGraph(new[] {root1, root2});
 
                 var dot = projectGraph.ToDot();
@@ -1555,7 +1556,7 @@ public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
             var dot = graph.ToDot();
 
             graph.ProjectNodes.Count.ShouldBe(3);
-            
+
             var outerBuild = graph.GraphRoots.First();
 
             AssertOuterBuildAsRoot(outerBuild, graph);
@@ -2300,7 +2301,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             foreach (var inner1 in innerBuildsFor1)
             {
-                // Outer build targets are added to inner builds because 
+                // Outer build targets are added to inner builds because
                 targetLists[inner1].ShouldBe(new[] {"BuildForOuterBuild", "Build"});
             }
 
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index 869a90027cf..8fb33e821cd 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
@@ -39,9 +40,9 @@ public void ErrorPosition()
                 { " $(",                    "2",    "AllowAll"},              // Position of $
                 { " $",                     "2",    "AllowAll"},              // Position of $
                 { " @(foo)",                "2",    "AllowProperties"},       // Position of @
-                { " '@(foo)'",              "3",    "AllowProperties"},       // Position of @    
+                { " '@(foo)'",              "3",    "AllowProperties"},       // Position of @
                 /* test escaped chars: message shows them escaped so count should include them */
-                { "'%24%28x' == '%24(x''",   "21",  "AllowAll"}               // Position of extra quote 
+                { "'%24%28x' == '%24(x''",   "21",  "AllowAll"}               // Position of extra quote
             };
 
             // Some errors are caught by the Parser, not merely by the Lexer/Scanner. So we have to do a full Parse,
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 21e9b159651..7462770fbd9 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System;
 using System.Resources;
 using System.Runtime.CompilerServices;
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 2dbcd31ea0e..7fe3d19fcf0 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -11,6 +11,7 @@
 using System.Threading.Tasks.Dataflow;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Utilities;
@@ -202,7 +203,7 @@ public void InitializeForBuild(NodeLoggingContext loggingContext)
         /// Cleans up after a build but leaves the engine thread running.  Aborts
         /// any outstanding requests.  Blocks until the engine has cleaned up
         /// everything.  After this method is called, InitializeForBuild may be
-        /// called to start a new build, or the component may be shut down.        
+        /// called to start a new build, or the component may be shut down.
         /// </summary>
         /// <remarks>
         /// Called by the Node.  Non-overlapping with other calls from the Node.
@@ -347,13 +348,13 @@ public void SubmitBuildRequest(BuildRequest request)
 
                         TraceEngine("Request {0}({1}) (nr {2}) retrieved results for configuration {3} from node {4} for transfer.", request.GlobalRequestId, request.ConfigurationId, request.NodeRequestId, request.ConfigurationId, _componentHost.BuildParameters.NodeId);
 
-                        // If this is the inproc node, we've already set the configuration's ResultsNodeId to the correct value in 
-                        // HandleRequestBlockedOnResultsTransfer, and don't want to set it again, because we actually have less 
-                        // information available to us now.  
+                        // If this is the inproc node, we've already set the configuration's ResultsNodeId to the correct value in
+                        // HandleRequestBlockedOnResultsTransfer, and don't want to set it again, because we actually have less
+                        // information available to us now.
                         //
-                        // On the other hand, if this is not the inproc node, we want to make sure that our copy of this configuration 
-                        // knows that its results are no longer on this node.  Since we don't know enough here to know where the 
-                        // results are going, we satisfy ourselves with marking that they are simply "not here". 
+                        // On the other hand, if this is not the inproc node, we want to make sure that our copy of this configuration
+                        // knows that its results are no longer on this node.  Since we don't know enough here to know where the
+                        // results are going, we satisfy ourselves with marking that they are simply "not here".
                         if (_componentHost.BuildParameters.NodeId != Scheduler.InProcNodeId)
                         {
                             config.ResultsNodeId = Scheduler.ResultsTransferredId;
@@ -394,7 +395,7 @@ public void UnblockBuildRequest(BuildRequestUnblocker unblocker)
                     ErrorUtilities.VerifyThrow(_requestsByGlobalRequestId.ContainsKey(unblocker.BlockedRequestId), "Request {0} is not known to the engine.", unblocker.BlockedRequestId);
                     BuildRequestEntry entry = _requestsByGlobalRequestId[unblocker.BlockedRequestId];
 
-                    // Are we resuming execution or reporting results?  
+                    // Are we resuming execution or reporting results?
                     if (unblocker.Result == null)
                     {
                         // We are resuming execution.
@@ -414,7 +415,7 @@ public void UnblockBuildRequest(BuildRequestUnblocker unblocker)
                     }
                     else
                     {
-                        // We must be reporting results.                 
+                        // We must be reporting results.
                         BuildResult result = unblocker.Result;
 
                         if (result.NodeRequestId == BuildRequest.ResultsTransferNodeRequestId)
@@ -434,7 +435,7 @@ public void UnblockBuildRequest(BuildRequestUnblocker unblocker)
                             ((IBuildResults)result).SavedEnvironmentVariables = null;
                             ((IBuildResults)result).SavedCurrentDirectory = null;
 
-                            // Our results node is now this node, since we've just cached those results                        
+                            // Our results node is now this node, since we've just cached those results
                             resultsCache.AddResult(result);
                             config.ResultsNodeId = _componentHost.BuildParameters.NodeId;
 
@@ -763,7 +764,7 @@ private void EvaluateRequestStates()
                 _requestsByGlobalRequestId.Remove(completedEntry.Request.GlobalRequestId);
             }
 
-            // If we completed a request, that means we may be able to unload the configuration if there is memory pressure.  Further we 
+            // If we completed a request, that means we may be able to unload the configuration if there is memory pressure.  Further we
             // will also cache any result items we can find since they are rarely used.
             if (completedEntries.Count > 0)
             {
@@ -790,7 +791,7 @@ private void EvaluateRequestStates()
             }
 
             // Finally, raise the completed events so they occur AFTER the state of the engine has changed,
-            // otherwise the client might observe the engine as being active after having received 
+            // otherwise the client might observe the engine as being active after having received
             // completed notifications for all requests, which would be odd.
             foreach (BuildRequestEntry completedEntry in completedEntries)
             {
@@ -915,12 +916,12 @@ private void ActivateBuildRequest(BuildRequestEntry entry)
                 // Set the request builder.
                 entry.Builder = GetRequestBuilder();
 
-                // Now call into the request builder to do the building            
+                // Now call into the request builder to do the building
                 entry.Builder.BuildRequest(_nodeLoggingContext, entry);
             }
             else
             {
-                // We are resuming the build request                
+                // We are resuming the build request
                 entry.Builder.ContinueRequest();
             }
 
@@ -1022,7 +1023,7 @@ private void IssueUnsubmittedRequests()
         {
             // We will only submit as many items as were in the queue at the time this method was called.
             // This prevents us from a) having to lock the queue for the whole loop or b) getting into
-            // an endless loop where another thread pushes requests into the queue as fast as we can 
+            // an endless loop where another thread pushes requests into the queue as fast as we can
             // discharge them.
             int countToSubmit = _unsubmittedRequests.Count;
             while (countToSubmit != 0)
@@ -1092,12 +1093,12 @@ private void IssueUnsubmittedRequests()
         /// When we receive a build request, we first have to determine if we already have a configuration which matches the
         /// one used by the request.  We do this because everywhere we deal with requests and results beyond this function, we
         /// use configuration ids, which are assigned once by the Build Manager and are global to the system.  If we do
-        /// not have a global configuration id, we can't check to see if we already have build results for the request, so we 
+        /// not have a global configuration id, we can't check to see if we already have build results for the request, so we
         /// cannot send the request out.  Thus, first we determine the configuration id.
-        /// 
+        ///
         /// Assuming we don't have the global configuration id locally, we will send the configuration to the Build Manager.
         /// It will look up or assign the global configuration id and send it back to us.
-        /// 
+        ///
         /// Once we have the global configuration id, we can then look up results locally.  If we have enough results to fulfill
         /// the request, we give them back to the request, otherwise we have to forward the request to the Build Mangager
         /// for scheduling.
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 3472c8ff01d..12237b65bec 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -6,6 +6,7 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Utilities;
 
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index f3e2c331c50..e0e9059c984 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Text;
 using System.Globalization;
+using System.Runtime.InteropServices;
 using System.Security;
 using System.Text.Json;
 using System.Text.RegularExpressions;
@@ -114,6 +115,12 @@ public sealed class SolutionFile
         private Version _currentVisualStudioVersion;
         private int _currentLineNumber;
 
+        // TODO: Unify to NativeMethodsShared.OSUsesCaseSensitive paths
+        // when possible.
+        private static StringComparer _pathComparer = RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
+            ? StringComparer.Ordinal
+            : StringComparer.OrdinalIgnoreCase;
+
         #endregion
 
         #region Constructors
@@ -202,7 +209,12 @@ internal string FullPath
             {
                 // Should already be canonicalized to a full path
                 ErrorUtilities.VerifyThrowInternalRooted(value);
-                if (FileUtilities.IsSolutionFilterFilename(value))
+                // To reduce code duplication, this should be
+                //   if (FileUtilities.IsSolutionFilterFilename(value))
+                // But that's in Microsoft.Build.Framework and this codepath
+                // is called from old versions of NuGet that can't resolve
+                // Framework (see https://github.com/dotnet/msbuild/issues/5313).
+                if (value.EndsWith(".slnf", StringComparison.OrdinalIgnoreCase))
                 {
                     ParseSolutionFilter(value);
                 }
@@ -386,7 +398,7 @@ private void ParseSolutionFilter(string solutionFilterFile)
 
                 SolutionFileDirectory = Path.GetDirectoryName(_solutionFile);
 
-                _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                _solutionFilter = new HashSet<string>(_pathComparer);
                 foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
                 {
                     _solutionFilter.Add(FileUtilities.FixFilePath(project.GetString()));
@@ -549,7 +561,7 @@ internal void ParseSolution()
 
             if (_solutionFilter != null)
             {
-                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, _pathComparer);
                 foreach (ProjectInSolution project in _projectsInOrder)
                 {
                     projectPaths.Add(FileUtilities.FixFilePath(project.RelativePath));
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 990a8b686cb..e2df26e70dd 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
@@ -135,8 +136,8 @@ private ToolsetConfigurationSection ConfigurationSection
                     }
                     catch (ConfigurationException ex)
                     {
-                        // ConfigurationException is obsolete, but we catch it rather than 
-                        // ConfigurationErrorsException (which is what we throw below) because it is more 
+                        // ConfigurationException is obsolete, but we catch it rather than
+                        // ConfigurationErrorsException (which is what we throw below) because it is more
                         // general and we don't want to miss catching some other derived exception.
                         InvalidToolsetDefinitionException.Throw(ex, "ConfigFileReadError", ElementLocation.Create(ex.Source, ex.Line, 0).LocationString, ex.BareMessage);
                     }
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 5d24ea0949b..04af6a1a016 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -5,6 +5,7 @@
 using System;
 using System.Diagnostics;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
@@ -18,7 +19,7 @@ namespace Microsoft.Build.Evaluation
     ///    do {
     ///      s.Advance();
     ///    while (s.IsNext(Token.EndOfInput));
-    /// 
+    ///
     ///  After Advance() is called, you can get the current token (s.CurrentToken),
     ///  check it's type (s.IsNext()), get the string for it (s.NextString()).
     /// </summary>
@@ -112,7 +113,7 @@ internal int GetErrorPosition()
             return _errorPosition;
         }
 
-        // The string (usually a single character) we found unexpectedly. 
+        // The string (usually a single character) we found unexpectedly.
         // We might want to show it in the error message, to help the user spot the error.
         internal string UnexpectedlyFound
         {
@@ -265,7 +266,7 @@ internal bool Advance()
         }
 
         /// <summary>
-        /// Parses either the $(propertyname) syntax or the %(metadataname) syntax, 
+        /// Parses either the $(propertyname) syntax or the %(metadataname) syntax,
         /// and returns the parsed string beginning with the '$' or '%', and ending with the
         /// closing parenthesis.
         /// </summary>
@@ -552,7 +553,7 @@ private bool ParseItemList()
         }
 
         /// <summary>
-        /// Parse any part of the conditional expression that is quoted. It may contain a property, item, or 
+        /// Parse any part of the conditional expression that is quoted. It may contain a property, item, or
         /// metadata element that needs expansion during evaluation.
         /// </summary>
         private bool ParseQuotedString()
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index e72f28469c6..895624f438e 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -32,7 +32,7 @@
 using Constants = Microsoft.Build.Internal.Constants;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
-using SdkReferencePropertyExpansionMode = Microsoft.Build.Utilities.EscapeHatches.SdkReferencePropertyExpansionMode;
+using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
 
 namespace Microsoft.Build.Evaluation
 {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 1e18aba7c7c..1e88d32aa72 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -112,9 +113,9 @@ internal enum ExpanderOptions
     /// Encapsulates the data necessary for expansion.
     /// </summary>
     /// <remarks>
-    /// Requires the caller to explicitly state what they wish to expand at the point of expansion (explicitly does not have a field for ExpanderOptions). 
+    /// Requires the caller to explicitly state what they wish to expand at the point of expansion (explicitly does not have a field for ExpanderOptions).
     /// Callers typically use a single expander in many locations, and this forces the caller to make explicit what they wish to expand at the point of expansion.
-    /// 
+    ///
     /// Requires the caller to have previously provided the necessary material for the expansion requested.
     /// For example, if the caller requests ExpanderOptions.ExpandItems, the Expander will throw if it was not given items.
     /// </remarks>
@@ -413,8 +414,8 @@ internal static bool ExpressionContainsItemVector(string expression)
         /// <summary>
         /// Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options.
         /// This is the standard form. Before using the expanded value, it must be unescaped, and this does that for you.
-        /// 
-        /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.        
+        ///
+        /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
         internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
@@ -427,7 +428,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         /// Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options.
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
-        /// 
+        ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
         internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
@@ -493,7 +494,7 @@ internal IList<TaskItem> ExpandIntoTaskItemsLeaveEscaped(string expression, Expa
         /// and produces a list of items of the type for which it was specialized.
         /// If the expression is empty, returns an empty list.
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
-        /// 
+        ///
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
@@ -549,25 +550,25 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
 
         /// <summary>
         /// This is a specialized method for the use of TargetUpToDateChecker and Evaluator.EvaluateItemXml only.
-        /// 
+        ///
         /// Extracts the items in the given SINGLE item vector.
         /// For example, expands @(Compile->'%(foo)') to a set of items derived from the items in the "Compile" list.
         ///
         /// If there is in fact more than one vector in the expression, throws InvalidProjectFileException.
-        /// 
+        ///
         /// If there are no item expressions in the expression (for example a literal "foo.cpp"), returns null.
         /// If expression expands to no items, returns an empty list.
         /// If item expansion is not allowed by the provided options, returns null.
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
-        /// 
+        ///
         /// If the expression is a transform, any transformations to an expression that evaluates to nothing (i.e., because
-        /// an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means 
+        /// an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means
         /// that the length of the returned list is always the same as the length of the referenced item list in the input string.
         /// That's important for any correlation the caller wants to do.
-        /// 
+        ///
         /// If expression was a transform, 'isTransformExpression' is true, otherwise false.
         ///
-        /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
+        /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not
         /// have an item type set on it, it will be given the item type of the item vector to use.
         /// </summary>
         /// <typeparam name="T">Type of the items that should be returned.</typeparam>
@@ -1140,7 +1141,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 // where we've essentially read up to and copied into the target string.
                 int sourceIndex = 0;
 
-                // Search for "$(" in the expression.  Loop until we don't find it 
+                // Search for "$(" in the expression.  Loop until we don't find it
                 // any more.
                 while (propertyStartIndex != -1)
                 {
@@ -1170,9 +1171,9 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                     {
                         // Aha, we found the closing parenthesis.  All the stuff in
                         // between the "$(" and the ")" constitutes the property body.
-                        // Note: Current propertyStartIndex points to the "$", and 
+                        // Note: Current propertyStartIndex points to the "$", and
                         // propertyEndIndex points to the ")".  That's why we have to
-                        // add 2 for the start of the substring, and subtract 2 for 
+                        // add 2 for the start of the substring, and subtract 2 for
                         // the length.
                         string propertyBody;
 
@@ -1202,7 +1203,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
 
                         // Compat hack: WebProjects may have an import with a condition like:
-                        //       Condition=" '$(Solutions.VSVersion)' == '8.0'" 
+                        //       Condition=" '$(Solutions.VSVersion)' == '8.0'"
                         // These would have been '' in prior versions of msbuild but would be treated as a possible string function in current versions.
                         // Be compatible by returning an empty string here.
                         else if ((propertyEndIndex - (propertyStartIndex + 2)) == 19 && String.Equals(expression, "$(Solutions.VSVersion)", StringComparison.Ordinal))
@@ -1351,7 +1352,7 @@ internal static object ExpandPropertyBody(
                     }
                 }
 
-                // Find the property value in our property collection.  This 
+                // Find the property value in our property collection.  This
                 // will automatically return "" (empty string) if the property
                 // doesn't exist in the collection, and we're not executing a static function
                 if (!String.IsNullOrEmpty(propertyName))
@@ -1485,11 +1486,11 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 else if (property == null)
                 {
                     // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
-                    // 
-                    // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently 
+                    //
+                    // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
                     // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
-                    // 
-                    // Another pattern used is where a property concatonates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of 
+                    //
+                    // Another pattern used is where a property concatonates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
                     // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
                     if (usedUninitializedProperties.Warn && usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName != null)
                     {
@@ -1671,13 +1672,13 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         /// Expands item expressions, like @(Compile), possibly with transforms and/or separators.
         ///
         /// Item vectors are composed of a name, an optional transform, and an optional separator i.e.
-        /// 
+        ///
         ///     @(&lt;name&gt;->'&lt;transform&gt;','&lt;separator&gt;')
-        ///     
+        ///
         /// If a separator is not specified it defaults to a semi-colon. The transform expression is also optional, but if
         /// specified, it allows each item in the vector to have its item-spec converted to a different form. The transform
         /// expression can reference any custom metadata defined on the item, as well as the pre-defined item-spec modifiers.
-        /// 
+        ///
         /// NOTE:
         /// 1) white space between &lt;name&gt;, &lt;transform&gt; and &lt;separator&gt; is ignored
         ///    i.e. @(&lt;name&gt;, '&lt;separator&gt;') is valid
@@ -1687,19 +1688,19 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         ///    to empty strings
         ///
         /// if @(files) is a vector for the files a.txt and b.txt, then:
-        /// 
+        ///
         ///     "my list: @(files)"                                 expands to string     "my list: a.txt;b.txt"
-        /// 
+        ///
         ///     "my list: @(files,' ')"                             expands to string      "my list: a.txt b.txt"
-        /// 
+        ///
         ///     "my list: @(files, '')"                             expands to string      "my list: a.txtb.txt"
-        /// 
+        ///
         ///     "my list: @(files, '; ')"                           expands to string      "my list: a.txt; b.txt"
-        /// 
+        ///
         ///     "my list: @(files->'%(Filename)')"                  expands to string      "my list: a;b"
-        /// 
+        ///
         ///     "my list: @(files -> 'temp\%(Filename).xml', ' ')   expands to string      "my list: temp\a.xml temp\b.xml"
-        /// 
+        ///
         ///     "my list: @(files->'')                              expands to string      "my list: ;".
         /// </summary>
         /// <remarks>
@@ -1739,23 +1740,23 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
 
             /// <summary>
             /// Expands any item vector in the expression into items.
-            /// 
+            ///
             /// For example, expands @(Compile->'%(foo)') to a set of items derived from the items in the "Compile" list.
-            /// 
+            ///
             /// If there is no item vector in the expression (for example a literal "foo.cpp"), returns null.
             /// If the item vector expression expands to no items, returns an empty list.
             /// If item expansion is not allowed by the provided options, returns null.
             /// If there is an item vector but concatenated with something else, throws InvalidProjectFileException.
             /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
-            /// 
+            ///
             /// If the expression is a transform, any transformations to an expression that evaluates to nothing (i.e., because
-            /// an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means 
+            /// an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means
             /// that the length of the returned list is always the same as the length of the referenced item list in the input string.
             /// That's important for any correlation the caller wants to do.
-            /// 
+            ///
             /// If expression was a transform, 'isTransformExpression' is true, otherwise false.
             ///
-            /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
+            /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not
             /// have an item type set on it, it will be given the item type of the item vector to use.
             /// </summary>
             /// <typeparam name="S">Type of the items provided by the item source used for expansion.</typeparam>
@@ -1823,7 +1824,7 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                 isTransformExpression = false;
                 bool brokeEarlyNonEmpty;
 
-                // If the incoming factory doesn't have an item type that it can use to 
+                // If the incoming factory doesn't have an item type that it can use to
                 // create items, it's our indication that the caller wants its items to have the type of the
                 // expression being expanded. For example, items from expanding "@(Compile") should
                 // have the item type "Compile".
@@ -1837,7 +1838,7 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                 if (expressionCapture.Separator != null)
                 {
                     // Reference contains a separator, for example @(Compile, ';').
-                    // We need to flatten the list into 
+                    // We need to flatten the list into
                     // a scalar and then create a single item. Basically we need this
                     // to be able to convert item lists with user specified separators into properties.
                     string expandedItemVector;
@@ -1902,18 +1903,18 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
             /// <summary>
             /// Expands an expression capture into a list of items
             /// If the capture uses a separator, then all the items are concatenated into one string using that separator.
-            /// 
+            ///
             /// Returns true if ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and so it broke out early.
             /// </summary>
             /// <param name="isTransformExpression"></param>
             /// <param name="itemsFromCapture">
             /// List of items.
-            /// 
+            ///
             /// Item1 represents the item string, escaped
             /// Item2 represents the original item.
-            /// 
+            ///
             /// Item1 differs from Item2's string when it is coming from a transform.
-            /// 
+            ///
             /// </param>
             /// <param name="expander">The expander whose state will be used to expand any transforms.</param>
             /// <param name="expressionCapture">The <see cref="ExpandSingleItemVectorExpressionIntoExpressionCapture"/> representing the structure of an item expression.</param>
@@ -2152,7 +2153,7 @@ ExpanderOptions options
                         builder.Append(";");
                     }
                 }
-                
+
                 return false;
             }
 
@@ -2298,8 +2299,8 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                         }
                         catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
                         {
-                            // InvalidOperationException is how GetItemSpecModifier communicates invalid conditions upwards, so 
-                            // we do not want to rethrow in that case.  
+                            // InvalidOperationException is how GetItemSpecModifier communicates invalid conditions upwards, so
+                            // we do not want to rethrow in that case.
                             if (ExceptionHandling.NotExpectedException(e) && !(e is InvalidOperationException))
                             {
                                 throw;
@@ -2867,7 +2868,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
             }
 
             /// <summary>
-            /// Represents all the components of a transform function, including the ability to execute it. 
+            /// Represents all the components of a transform function, including the ability to execute it.
             /// </summary>
             /// <typeparam name="S">class, IItem.</typeparam>
             internal class TransformFunction<S>
@@ -3014,7 +3015,7 @@ private static class RegularExpressions
             /// <summary>
             /// Regular expression used to match item metadata references embedded in strings.
             /// For example, %(Compile.DependsOn) or %(DependsOn).
-            /// </summary> 
+            /// </summary>
             internal static readonly Lazy<Regex> ItemMetadataPattern = new Lazy<Regex>(
                 () => new Regex(ItemMetadataSpecification,
                     RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
@@ -3052,17 +3053,17 @@ private static class RegularExpressions
             /// <summary>
             /// Complete description of an item metadata reference, including the optional qualifying item type.
             /// For example, %(Compile.DependsOn) or %(DependsOn).
-            /// </summary> 
+            /// </summary>
             private const string ItemMetadataSpecification = @"%\(\s* (?<ITEM_SPECIFICATION>(?<ITEM_TYPE>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @")\s*\.\s*)? (?<NAME>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @") \s*\)";
 
             /// <summary>
-            /// description of an item vector with a transform, left hand side. 
-            /// </summary> 
+            /// description of an item vector with a transform, left hand side.
+            /// </summary>
             private const string ItemVectorWithTransformLHS = @"@\(\s*" + ProjectWriter.itemTypeOrMetadataNameSpecification + @"\s*->\s*'[^']*";
 
             /// <summary>
-            /// description of an item vector with a transform, right hand side. 
-            /// </summary> 
+            /// description of an item vector with a transform, right hand side.
+            /// </summary>
             private const string ItemVectorWithTransformRHS = @"[^']*'(\s*,\s*'[^']*')?\s*\)";
 
             /**************************************************************************************************************************
@@ -3430,10 +3431,10 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     }
 
                     // Handle special cases where the object type needs to affect the choice of method
-                    // The default binder and method invoke, often chooses the incorrect Equals and CompareTo and 
+                    // The default binder and method invoke, often chooses the incorrect Equals and CompareTo and
                     // fails the comparison, because what we have on the right is generally a string.
                     // This special casing is to realize that its a comparison that is taking place and handle the
-                    // argument type coercion accordingly; effectively pre-preparing the argument type so 
+                    // argument type coercion accordingly; effectively pre-preparing the argument type so
                     // that it matches the left hand side ready for the default binder’s method invoke.
                     if (objectInstance != null && args.Length == 1 && (String.Equals("Equals", _methodMethodName, StringComparison.OrdinalIgnoreCase) || String.Equals("CompareTo", _methodMethodName, StringComparison.OrdinalIgnoreCase)))
                     {
@@ -3510,7 +3511,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                                 if ((_bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                                 {
                                     // The standard binder failed, so do our best to coerce types into the arguments for the function
-                                    // This may happen if the types need coercion, but it may also happen if the object represents a type that contains open type parameters, that is, ContainsGenericParameters returns true. 
+                                    // This may happen if the types need coercion, but it may also happen if the object represents a type that contains open type parameters, that is, ContainsGenericParameters returns true.
                                     functionResult = LateBindExecute(ex, _bindingFlags, objectInstance, args, false /* is not constructor */);
                                 }
                                 else
@@ -4589,7 +4590,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
                 Type receiverType;
                 Tuple<string, Type> cachedTypeInformation;
 
-                // If we don't have a type name, we already know that we won't be able to find a type.  
+                // If we don't have a type name, we already know that we won't be able to find a type.
                 // Go ahead and return here -- otherwise the Type.GetType() calls below will throw.
                 if (string.IsNullOrWhiteSpace(typeName))
                 {
@@ -4811,7 +4812,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                 BindingFlags defaultBindingFlags = BindingFlags.IgnoreCase | BindingFlags.Public;
 
                 ReadOnlySpan<char> expressionFunctionAsSpan = expressionFunction.AsSpan();
-                
+
                 ReadOnlySpan<char> expressionSubstringAsSpan = argumentStartIndex > -1 ? expressionFunctionAsSpan.Slice(methodStartIndex, argumentStartIndex - methodStartIndex) : ReadOnlySpan<char>.Empty;
 
                 // There are arguments that need to be passed to the function
@@ -4939,7 +4940,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                             // We'll also allow the user to specify the leaf or full type name on the enum
                             string argument = args[n].ToString().Replace('|', ',').Replace(typeFullName, "").Replace(typeLeafName, "");
 
-                            // Parse the string representation of the argument into the destination enum                                
+                            // Parse the string representation of the argument into the destination enum
                             coercedArguments[n] = Enum.Parse(enumType, argument);
                         }
                         else
@@ -5169,7 +5170,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
     /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized. 
+    /// This class wraps information about properties which have been used before they are initialized.
     /// </summary>
     internal class UsedUninitializedProperties
     {
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index aa1cdeaa90b..479d5578559 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -7,6 +7,7 @@
 using System.Runtime.InteropServices;
 using System.Text.RegularExpressions;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index b50ed189861..c67b057ae9e 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -3,6 +3,7 @@
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -19,7 +20,7 @@ internal partial class LazyItemEvaluator<P, I, M, D>
         class IncludeOperation : LazyItemOperation
         {
             readonly int _elementOrder;
-            
+
             readonly string _rootDirectory;
 
             readonly ImmutableSegmentedList<string> _excludes;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index d63e2a31c38..1669c835072 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using System.Collections.Generic;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index 35b2ffa899f..349a561c231 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using System.Collections.Immutable;
 using System.Linq;
 using Microsoft.Build.Utilities;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index ada3da6a27f..f0a16524b5a 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Eventing;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
@@ -277,13 +278,13 @@ public OrderedItemDataCollection.Builder GetItemData(ImmutableHashSet<string> gl
                 // Cache results only on the LazyItemOperations whose results are required by an external caller (via GetItems). This means:
                 //   - Callers of GetItems who have announced ahead of time that they would reference an operation (via MarkAsReferenced())
                 // This includes: item references (Include="@(foo)") and metadata conditions (Condition="@(foo->Count()) == 0")
-                // Without ahead of time notifications more computation is done than needed when the results of a future operation are requested 
+                // Without ahead of time notifications more computation is done than needed when the results of a future operation are requested
                 // The future operation is part of another item list referencing this one (making this operation part of the tail).
                 // The future operation will compute this list but since no ahead of time notifications have been made by callers, it won't cache the
                 // intermediary operations that would be requested by those callers.
                 //   - Callers of GetItems that cannot announce ahead of time. This includes item referencing conditions on
                 // Item Groups and Item Elements. However, those conditions are performed eagerly outside of the LazyItemEvaluator, so they will run before
-                // any item referencing operations from inside the LazyItemEvaluator. This 
+                // any item referencing operations from inside the LazyItemEvaluator. This
                 //
                 // If the head of this LazyItemList is uncached, then the tail may contain cached and un-cached nodes.
                 // In this case we have to compute the head plus the part of the tail up to the first cached operation.
@@ -302,7 +303,7 @@ public OrderedItemDataCollection.Builder GetItemData(ImmutableHashSet<string> gl
                 else
                 {
                     // tell the cache that this operation's result is needed by an external caller
-                    // this is required for callers that cannot tell the item list ahead of time that 
+                    // this is required for callers that cannot tell the item list ahead of time that
                     // they would be using an operation
                     MarkAsReferenced();
 
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 3fdf05a6b9c..706933b8c43 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 28f1d0d9d5f..1f7480ffc0c 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -1003,7 +1003,7 @@ public virtual void Initialize(IEventSource eventSource)
                 eventSource.CustomEventRaised += CustomEventHandler;
                 eventSource.StatusEventRaised += StatusEventHandler;
 
-                bool logPropertiesAndItemsAfterEvaluation = Utilities.Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
+                bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
                 if (logPropertiesAndItemsAfterEvaluation && eventSource is IEventSource4 eventSource4)
                 {
                     eventSource4.IncludeEvaluationPropertiesAndItems();
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index cf89522d904..cbfee6c66db 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -102,9 +102,6 @@
     <Compile Include="..\Shared\StringBuilderCache.cs">
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedUtilities\Traits.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
     <Compile Include="..\Shared\TaskHostTaskCancelled.cs" />
@@ -145,9 +142,6 @@
     </Compile>
     <Compile Include="..\Shared\ReuseableStringBuilder.cs" />
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>SharedUtilities\VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="BackEnd\BuildManager\BuildManager.cs" />
     <Compile Include="BackEnd\BuildManager\BuildParameters.cs" />
@@ -724,21 +718,10 @@
     <Compile Include="..\Shared\IElementLocation.cs">
       <Link>SharedUtilities\IElementLocation.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-      <Link>Errors\InternalErrorException.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\LoadedType.cs">
       <Link>SharedUtilities\LoadedType.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <Link>SharedUtilities\NativeMethodsShared.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <Link>SharedUtilities\AssemblyUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>InprocTrackingNativeMethods.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 40347473d2a..180e3c29fda 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Utilities;
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 3bb52fd3d73..a318ddb8117 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -4,6 +4,8 @@
 using System;
 using System.IO;
 using System.Reflection;
+
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
diff --git a/src/Framework.UnitTests/AssemblyInfo.cs b/src/Framework.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/Framework.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index 7be18a10802..2ce98b0c404 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -37,18 +37,13 @@
     <Compile Include="..\Shared\FileUtilities.cs" />
     <Compile Include="..\Shared\TempFileUtilities.cs" />
     <Compile Include="..\Shared\ErrorUtilities.cs" />
-    <Compile Include="..\Shared\NativeMethodsShared.cs" />
     <Compile Include="..\Shared\EscapingUtilities.cs" />
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs" />
-    <Compile Include="..\Shared\AssemblyUtilities.cs" />
     <Compile Include="..\Shared\ResourceUtilities.cs" />
-    <Compile Include="..\Shared\InternalErrorException.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs" />
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs" />
     <Compile Include="..\Shared\StringBuilderCache.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
     <Compile Include="..\Shared\UnitTests\AssemblyResources.cs" />
-    <Compile Include="..\Shared\Traits.cs" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Shared/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
similarity index 93%
rename from src/Shared/AssemblyUtilities.cs
rename to src/Framework/AssemblyUtilities.cs
index 46d679293c5..cc87eb6448a 100644
--- a/src/Shared/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -6,6 +6,8 @@
 using System.Linq;
 using System.Reflection;
 
+using Microsoft.Build.Framework;
+
 // Declare this to get init properties. See https://github.com/dotnet/roslyn/issues/45510#issuecomment-694977239
 namespace System.Runtime.CompilerServices
 {
@@ -148,7 +150,7 @@ private static Assembly GetEntryAssembly()
 #else
             var getEntryAssembly = typeof(Assembly).GetMethod("GetEntryAssembly");
 
-            ErrorUtilities.VerifyThrowInternalNull(getEntryAssembly, "Assembly does not have the method GetEntryAssembly");
+            FrameworkErrorUtilities.VerifyThrowInternalNull(getEntryAssembly, "Assembly does not have the method GetEntryAssembly");
 
             return (Assembly) getEntryAssembly.Invoke(null, Array.Empty<object>());
 #endif
@@ -159,7 +161,7 @@ private static CultureInfo[] GetValidCultures()
         {
             var cultureTypesType = s_cultureInfoGetCultureMethod?.GetParameters().FirstOrDefault()?.ParameterType;
 
-            ErrorUtilities.VerifyThrow(cultureTypesType?.Name == "CultureTypes" &&
+            FrameworkErrorUtilities.VerifyThrow(cultureTypesType?.Name == "CultureTypes" &&
                                        Enum.IsDefined(cultureTypesType, "AllCultures"),
                                        "GetCulture is expected to accept CultureTypes.AllCultures");
 
@@ -167,7 +169,7 @@ private static CultureInfo[] GetValidCultures()
 
             var cultures = s_cultureInfoGetCultureMethod.Invoke(null, new[] {allCulturesEnumValue}) as CultureInfo[];
 
-            ErrorUtilities.VerifyThrowInternalNull(cultures, "CultureInfo.GetCultures should work if all reflection checks pass");
+            FrameworkErrorUtilities.VerifyThrowInternalNull(cultures, "CultureInfo.GetCultures should work if all reflection checks pass");
 
             return cultures;
         }
diff --git a/src/Framework/BuildEnvironmentState.cs b/src/Framework/BuildEnvironmentState.cs
new file mode 100644
index 00000000000..fae6127700e
--- /dev/null
+++ b/src/Framework/BuildEnvironmentState.cs
@@ -0,0 +1,17 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Class to encapsulate state that was stored in BuildEnvironmentHelper.
+    /// </summary>
+    /// <remarks>
+    /// This should be deleted when BuildEnvironmentHelper can be moved into Framework.
+    /// </remarks>
+    internal static class BuildEnvironmentState
+    {
+        internal static bool s_runningInVisualStudio = false;
+        internal static bool s_runningTests = false;
+    }
+}
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index d97becfa1d0..90eed3b8aad 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Linq;
 
-namespace Microsoft.Build.Utilities
+namespace Microsoft.Build.Framework
 {
     internal enum ChangeWaveConversionState
     {
diff --git a/src/Framework/ErrorUtilities.cs b/src/Framework/ErrorUtilities.cs
new file mode 100644
index 00000000000..8611d41a549
--- /dev/null
+++ b/src/Framework/ErrorUtilities.cs
@@ -0,0 +1,75 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Framework
+{
+    // TODO: this should be unified with Shared\ErrorUtilities.cs, but it is hard to untangle everything
+    //       because some of the errors there will use localized resources from different assemblies,
+    //       which won't be referenceable in Framework.
+
+    internal class FrameworkErrorUtilities
+    {
+        /// <summary>
+        /// Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
+        /// and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
+        /// then we can give them this undocumented environment variable as an immediate workaround.
+        /// </summary>
+        private static readonly bool s_throwExceptions = string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
+
+        /// <summary>
+        /// This method should be used in places where one would normally put
+        /// an "assert". It should be used to validate that our assumptions are
+        /// true, where false would indicate that there must be a bug in our
+        /// code somewhere. This should not be used to throw errors based on bad
+        /// user input or anything that the user did wrong.
+        /// </summary>
+        /// <param name="condition"></param>
+        /// <param name="unformattedMessage"></param>
+        internal static void VerifyThrow
+        (
+            bool condition,
+            string unformattedMessage
+        )
+        {
+            if (!condition)
+            {
+                // PERF NOTE: explicitly passing null for the arguments array
+                // prevents memory allocation
+                ThrowInternalError(unformattedMessage, null, null);
+            }
+        }
+
+        /// <summary>
+        /// Helper to throw an InternalErrorException when the specified parameter is null.
+        /// This should be used ONLY if this would indicate a bug in MSBuild rather than
+        /// anything caused by user action.
+        /// </summary>
+        /// <param name="parameter">The value of the argument.</param>
+        /// <param name="parameterName">Parameter that should not be null</param>
+        internal static void VerifyThrowInternalNull(object parameter, string parameterName)
+        {
+            if (parameter == null)
+            {
+                ThrowInternalError("{0} unexpectedly null", innerException: null, args: parameterName);
+            }
+        }
+
+        /// <summary>
+        /// Throws InternalErrorException.
+        /// This is only for situations that would mean that there is a bug in MSBuild itself.
+        /// </summary>
+        internal static void ThrowInternalError(string message, Exception innerException, params object[] args)
+        {
+            if (s_throwExceptions)
+            {
+                throw new InternalErrorException(string.Format(message, args), innerException);
+            }
+        }
+    }
+}
diff --git a/src/Shared/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
similarity index 86%
rename from src/Shared/InternalErrorException.cs
rename to src/Framework/InternalErrorException.cs
index 448cc5f6a46..7c6f9a27d21 100644
--- a/src/Shared/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -5,25 +5,19 @@
 using System.Diagnostics;
 using System.Runtime.Serialization;
 
-namespace Microsoft.Build.Shared
+namespace Microsoft.Build.Framework
 {
     /// <summary>
     /// This exception is to be thrown whenever an assumption we have made in the code turns out to be false. Thus, if this
     /// exception ever gets thrown, it is because of a bug in our own code, not because of something the user or project author
     /// did wrong.
-    /// 
-    /// !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
-    /// WARNING: When this file is shared into multiple assemblies each assembly will view this as a different type.
-    ///          Don't throw this exception from one assembly and catch it in another.
-    /// !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
-    ///     
     /// </summary>
     [Serializable]
     internal sealed class InternalErrorException : Exception
     {
         /// <summary>
         /// Default constructor.
-        /// SHOULD ONLY BE CALLED BY DESERIALIZER. 
+        /// SHOULD ONLY BE CALLED BY DESERIALIZER.
         /// SUPPLY A MESSAGE INSTEAD.
         /// </summary>
         internal InternalErrorException() : base()
@@ -76,21 +70,21 @@ private InternalErrorException(SerializationInfo info, StreamingContext context)
         #region ConsiderDebuggerLaunch
         /// <summary>
         /// A fatal internal error due to a bug has occurred. Give the dev a chance to debug it, if possible.
-        /// 
+        ///
         /// Will in all cases launch the debugger, if the environment variable "MSBUILDLAUNCHDEBUGGER" is set.
-        /// 
+        ///
         /// In DEBUG build, will always launch the debugger, unless we are in razzle (_NTROOT is set) or in NUnit,
         /// or MSBUILDDONOTLAUNCHDEBUGGER is set (that could be useful in suite runs).
         /// We don't launch in retail or LKG so builds don't jam; they get a callstack, and continue or send a mail, etc.
         /// We don't launch in NUnit as tests often intentionally cause InternalErrorExceptions.
-        /// 
-        /// Because we only call this method from this class, just before throwing an InternalErrorException, there is 
+        ///
+        /// Because we only call this method from this class, just before throwing an InternalErrorException, there is
         /// no danger that this suppression will cause a bug to only manifest itself outside NUnit
         /// (which would be most unfortunate!). Do not make this non-private.
-        /// 
+        ///
         /// Unfortunately NUnit can't handle unhandled exceptions like InternalErrorException on anything other than
         /// the main test thread. However, there's still a callstack displayed before it quits.
-        /// 
+        ///
         /// If it is going to launch the debugger, it first does a Debug.Fail to give information about what needs to
         /// be debugged -- the exception hasn't been thrown yet. This automatically displays the current callstack.
         /// </summary>
@@ -120,7 +114,7 @@ private static void LaunchDebugger(string message, string innerMessage)
             Debug.Fail(message, innerMessage);
             Debugger.Launch();
 #else
-            Console.WriteLine("MSBuild Failure: " + message);    
+            Console.WriteLine("MSBuild Failure: " + message);
             if (!string.IsNullOrEmpty(innerMessage))
             {
                 Console.WriteLine(innerMessage);
@@ -134,6 +128,6 @@ private static void LaunchDebugger(string message, string innerMessage)
         }
         #endregion
 
-        private static bool RunningTests() => BuildEnvironmentHelper.Instance.RunningTests;
+        private static bool RunningTests() => BuildEnvironmentState.s_runningTests;
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 30bd9fd64f2..df75564473e 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -22,11 +22,17 @@
     <PackageReference Include="Microsoft.CodeAnalysis.Collections" PrivateAssets="all" />
   </ItemGroup>
 
-  <ItemGroup>
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
+    <PackageReference Include="System.Security.Permissions" />
+    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
+    <PackageReference Include="Microsoft.Win32.Registry" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- Promote CompilerServices.Unsafe from the old version we get from System.Memory on net472. -->
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
-    <PackageReference Include="System.Security.Permissions" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
-    <Reference Include="System.Xaml" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
+    <Reference Include="System.Xaml" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
new file mode 100644
index 00000000000..f4fc0639973
--- /dev/null
+++ b/src/Framework/NativeMethods.cs
@@ -0,0 +1,1693 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Diagnostics.CodeAnalysis;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.InteropServices;
+using System.Text;
+using System.Threading;
+
+using Microsoft.Build.Shared;
+using Microsoft.Win32;
+using Microsoft.Win32.SafeHandles;
+
+using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
+
+namespace Microsoft.Build.Framework;
+internal static class NativeMethods
+{
+    #region Constants
+
+    internal const uint ERROR_INSUFFICIENT_BUFFER = 0x8007007A;
+    internal const uint STARTUP_LOADER_SAFEMODE = 0x10;
+    internal const uint S_OK = 0x0;
+    internal const uint S_FALSE = 0x1;
+    internal const uint ERROR_ACCESS_DENIED = 0x5;
+    internal const uint ERROR_FILE_NOT_FOUND = 0x80070002;
+    internal const uint FUSION_E_PRIVATE_ASM_DISALLOWED = 0x80131044; // Tried to find unsigned assembly in GAC
+    internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
+    internal const uint FILE_TYPE_CHAR = 0x0002;
+    internal const Int32 STD_OUTPUT_HANDLE = -11;
+    internal const uint RPC_S_CALLPENDING = 0x80010115;
+    internal const uint E_ABORT = (uint)0x80004004;
+
+    internal const int FILE_ATTRIBUTE_READONLY = 0x00000001;
+    internal const int FILE_ATTRIBUTE_DIRECTORY = 0x00000010;
+    internal const int FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400;
+
+    /// <summary>
+    /// Default buffer size to use when dealing with the Windows API.
+    /// </summary>
+    internal const int MAX_PATH = 260;
+
+    private const string kernel32Dll = "kernel32.dll";
+    private const string mscoreeDLL = "mscoree.dll";
+
+    private const string WINDOWS_FILE_SYSTEM_REGISTRY_KEY = @"SYSTEM\CurrentControlSet\Control\FileSystem";
+    private const string WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME = "LongPathsEnabled";
+
+    internal static DateTime MinFileDate { get; } = DateTime.FromFileTimeUtc(0);
+
+#if FEATURE_HANDLEREF
+    internal static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
+#endif
+
+    internal static IntPtr NullIntPtr = new IntPtr(0);
+
+    // As defined in winnt.h:
+    internal const ushort PROCESSOR_ARCHITECTURE_INTEL = 0;
+    internal const ushort PROCESSOR_ARCHITECTURE_ARM = 5;
+    internal const ushort PROCESSOR_ARCHITECTURE_IA64 = 6;
+    internal const ushort PROCESSOR_ARCHITECTURE_AMD64 = 9;
+    internal const ushort PROCESSOR_ARCHITECTURE_ARM64 = 12;
+
+    internal const uint INFINITE = 0xFFFFFFFF;
+    internal const uint WAIT_ABANDONED_0 = 0x00000080;
+    internal const uint WAIT_OBJECT_0 = 0x00000000;
+    internal const uint WAIT_TIMEOUT = 0x00000102;
+
+#if FEATURE_CHARSET_AUTO
+    internal const CharSet AutoOrUnicode = CharSet.Auto;
+#else
+        internal const CharSet AutoOrUnicode = CharSet.Unicode;
+#endif
+
+    #endregion
+
+    #region Enums
+
+    private enum PROCESSINFOCLASS : int
+    {
+        ProcessBasicInformation = 0,
+        ProcessQuotaLimits,
+        ProcessIoCounters,
+        ProcessVmCounters,
+        ProcessTimes,
+        ProcessBasePriority,
+        ProcessRaisePriority,
+        ProcessDebugPort,
+        ProcessExceptionPort,
+        ProcessAccessToken,
+        ProcessLdtInformation,
+        ProcessLdtSize,
+        ProcessDefaultHardErrorMode,
+        ProcessIoPortHandlers, // Note: this is kernel mode only
+        ProcessPooledUsageAndLimits,
+        ProcessWorkingSetWatch,
+        ProcessUserModeIOPL,
+        ProcessEnableAlignmentFaultFixup,
+        ProcessPriorityClass,
+        ProcessWx86Information,
+        ProcessHandleCount,
+        ProcessAffinityMask,
+        ProcessPriorityBoost,
+        MaxProcessInfoClass
+    };
+
+    private enum eDesiredAccess : int
+    {
+        DELETE = 0x00010000,
+        READ_CONTROL = 0x00020000,
+        WRITE_DAC = 0x00040000,
+        WRITE_OWNER = 0x00080000,
+        SYNCHRONIZE = 0x00100000,
+        STANDARD_RIGHTS_ALL = 0x001F0000,
+
+        PROCESS_TERMINATE = 0x0001,
+        PROCESS_CREATE_THREAD = 0x0002,
+        PROCESS_SET_SESSIONID = 0x0004,
+        PROCESS_VM_OPERATION = 0x0008,
+        PROCESS_VM_READ = 0x0010,
+        PROCESS_VM_WRITE = 0x0020,
+        PROCESS_DUP_HANDLE = 0x0040,
+        PROCESS_CREATE_PROCESS = 0x0080,
+        PROCESS_SET_QUOTA = 0x0100,
+        PROCESS_SET_INFORMATION = 0x0200,
+        PROCESS_QUERY_INFORMATION = 0x0400,
+        PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF
+    }
+#pragma warning disable 0649, 0169
+    internal enum LOGICAL_PROCESSOR_RELATIONSHIP
+    {
+        RelationProcessorCore,
+        RelationNumaNode,
+        RelationCache,
+        RelationProcessorPackage,
+        RelationGroup,
+        RelationAll = 0xffff
+    }
+    internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
+    {
+        public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
+        public uint Size;
+        public PROCESSOR_RELATIONSHIP Processor;
+    }
+    [StructLayout(LayoutKind.Sequential)]
+    internal unsafe struct PROCESSOR_RELATIONSHIP
+    {
+        public byte Flags;
+        private byte EfficiencyClass;
+        private fixed byte Reserved[20];
+        public ushort GroupCount;
+        public IntPtr GroupInfo;
+    }
+#pragma warning restore 0169, 0149
+
+    /// <summary>
+    /// Flags for CoWaitForMultipleHandles
+    /// </summary>
+    [Flags]
+    public enum COWAIT_FLAGS : int
+    {
+        /// <summary>
+        /// Exit when a handle is signaled.
+        /// </summary>
+        COWAIT_NONE = 0,
+
+        /// <summary>
+        /// Exit when all handles are signaled AND a message is received.
+        /// </summary>
+        COWAIT_WAITALL = 0x00000001,
+
+        /// <summary>
+        /// Exit when an RPC call is serviced.
+        /// </summary>
+        COWAIT_ALERTABLE = 0x00000002
+    }
+
+    /// <summary>
+    /// Processor architecture values
+    /// </summary>
+    internal enum ProcessorArchitectures
+    {
+        // Intel 32 bit
+        X86,
+
+        // AMD64 64 bit
+        X64,
+
+        // Itanium 64
+        IA64,
+
+        // ARM
+        ARM,
+
+        // ARM64
+        ARM64,
+
+        // Who knows
+        Unknown
+    }
+
+    #endregion
+
+    #region Structs
+
+    /// <summary>
+    /// Structure that contain information about the system on which we are running
+    /// </summary>
+    [StructLayout(LayoutKind.Sequential)]
+    internal struct SYSTEM_INFO
+    {
+        // This is a union of a DWORD and a struct containing 2 WORDs.
+        internal ushort wProcessorArchitecture;
+        internal ushort wReserved;
+
+        internal uint dwPageSize;
+        internal IntPtr lpMinimumApplicationAddress;
+        internal IntPtr lpMaximumApplicationAddress;
+        internal IntPtr dwActiveProcessorMask;
+        internal uint dwNumberOfProcessors;
+        internal uint dwProcessorType;
+        internal uint dwAllocationGranularity;
+        internal ushort wProcessorLevel;
+        internal ushort wProcessorRevision;
+    }
+
+    /// <summary>
+    /// Wrap the intptr returned by OpenProcess in a safe handle.
+    /// </summary>
+    internal class SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid
+    {
+        // Create a SafeHandle, informing the base class
+        // that this SafeHandle instance "owns" the handle,
+        // and therefore SafeHandle should call
+        // our ReleaseHandle method when the SafeHandle
+        // is no longer in use
+        private SafeProcessHandle() : base(true)
+        {
+        }
+        protected override bool ReleaseHandle()
+        {
+            return CloseHandle(handle);
+        }
+    }
+
+    /// <summary>
+    /// Contains information about the current state of both physical and virtual memory, including extended memory
+    /// </summary>
+    [StructLayout(LayoutKind.Sequential, CharSet = AutoOrUnicode)]
+    internal class MemoryStatus
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="T:MemoryStatus"/> class.
+        /// </summary>
+        public MemoryStatus()
+        {
+#if (CLR2COMPATIBILITY)
+            _length = (uint)Marshal.SizeOf(typeof(MemoryStatus));
+#else
+            _length = (uint)Marshal.SizeOf<MemoryStatus>();
+#endif
+        }
+
+        /// <summary>
+        /// Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
+        /// </summary>
+        private uint _length;
+
+        /// <summary>
+        /// Number between 0 and 100 that specifies the approximate percentage of physical
+        /// memory that is in use (0 indicates no memory use and 100 indicates full memory use).
+        /// </summary>
+        public uint MemoryLoad;
+
+        /// <summary>
+        /// Total size of physical memory, in bytes.
+        /// </summary>
+        public ulong TotalPhysical;
+
+        /// <summary>
+        /// Size of physical memory available, in bytes.
+        /// </summary>
+        public ulong AvailablePhysical;
+
+        /// <summary>
+        /// Size of the committed memory limit, in bytes. This is physical memory plus the
+        /// size of the page file, minus a small overhead.
+        /// </summary>
+        public ulong TotalPageFile;
+
+        /// <summary>
+        /// Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
+        /// </summary>
+        public ulong AvailablePageFile;
+
+        /// <summary>
+        /// Total size of the user mode portion of the virtual address space of the calling process, in bytes.
+        /// </summary>
+        public ulong TotalVirtual;
+
+        /// <summary>
+        /// Size of unreserved and uncommitted memory in the user mode portion of the virtual
+        /// address space of the calling process, in bytes.
+        /// </summary>
+        public ulong AvailableVirtual;
+
+        /// <summary>
+        /// Size of unreserved and uncommitted memory in the extended portion of the virtual
+        /// address space of the calling process, in bytes.
+        /// </summary>
+        public ulong AvailableExtendedVirtual;
+    }
+
+    [StructLayout(LayoutKind.Sequential)]
+    private struct PROCESS_BASIC_INFORMATION
+    {
+        public uint ExitStatus;
+        public IntPtr PebBaseAddress;
+        public UIntPtr AffinityMask;
+        public int BasePriority;
+        public UIntPtr UniqueProcessId;
+        public UIntPtr InheritedFromUniqueProcessId;
+
+        public uint Size
+        {
+            get
+            {
+                unsafe
+                {
+                    return (uint)sizeof(PROCESS_BASIC_INFORMATION);
+                }
+            }
+        }
+    };
+
+    /// <summary>
+    /// Contains information about a file or directory; used by GetFileAttributesEx.
+    /// </summary>
+    [StructLayout(LayoutKind.Sequential)]
+    public struct WIN32_FILE_ATTRIBUTE_DATA
+    {
+        internal int fileAttributes;
+        internal uint ftCreationTimeLow;
+        internal uint ftCreationTimeHigh;
+        internal uint ftLastAccessTimeLow;
+        internal uint ftLastAccessTimeHigh;
+        internal uint ftLastWriteTimeLow;
+        internal uint ftLastWriteTimeHigh;
+        internal uint fileSizeHigh;
+        internal uint fileSizeLow;
+    }
+
+    /// <summary>
+    /// Contains the security descriptor for an object and specifies whether
+    /// the handle retrieved by specifying this structure is inheritable.
+    /// </summary>
+    [StructLayout(LayoutKind.Sequential)]
+    internal class SecurityAttributes
+    {
+        public SecurityAttributes()
+        {
+#if (CLR2COMPATIBILITY)
+            _nLength = (uint)Marshal.SizeOf(typeof(SecurityAttributes));
+#else
+            _nLength = (uint)Marshal.SizeOf<SecurityAttributes>();
+#endif
+        }
+
+        private uint _nLength;
+
+        public IntPtr lpSecurityDescriptor;
+
+        public bool bInheritHandle;
+    }
+
+    private class SystemInformationData
+    {
+        /// <summary>
+        /// Architecture as far as the current process is concerned.
+        /// It's x86 in wow64 (native architecture is x64 in that case).
+        /// Otherwise it's the same as the native architecture.
+        /// </summary>
+        public readonly ProcessorArchitectures ProcessorArchitectureType;
+
+        /// <summary>
+        /// Actual architecture of the system.
+        /// </summary>
+        public readonly ProcessorArchitectures ProcessorArchitectureTypeNative;
+
+        /// <summary>
+        /// Convert SYSTEM_INFO architecture values to the internal enum
+        /// </summary>
+        /// <param name="arch"></param>
+        /// <returns></returns>
+        private static ProcessorArchitectures ConvertSystemArchitecture(ushort arch)
+        {
+            return arch switch
+            {
+                PROCESSOR_ARCHITECTURE_INTEL => ProcessorArchitectures.X86,
+                PROCESSOR_ARCHITECTURE_AMD64 => ProcessorArchitectures.X64,
+                PROCESSOR_ARCHITECTURE_ARM => ProcessorArchitectures.ARM,
+                PROCESSOR_ARCHITECTURE_IA64 => ProcessorArchitectures.IA64,
+                PROCESSOR_ARCHITECTURE_ARM64 => ProcessorArchitectures.ARM64,
+                _ => ProcessorArchitectures.Unknown,
+            };
+        }
+
+        /// <summary>
+        /// Read system info values
+        /// </summary>
+        public SystemInformationData()
+        {
+            ProcessorArchitectureType = ProcessorArchitectures.Unknown;
+            ProcessorArchitectureTypeNative = ProcessorArchitectures.Unknown;
+
+            if (IsWindows)
+            {
+                var systemInfo = new SYSTEM_INFO();
+
+                GetSystemInfo(ref systemInfo);
+                ProcessorArchitectureType = ConvertSystemArchitecture(systemInfo.wProcessorArchitecture);
+
+                GetNativeSystemInfo(ref systemInfo);
+                ProcessorArchitectureTypeNative = ConvertSystemArchitecture(systemInfo.wProcessorArchitecture);
+            }
+            else
+            {
+                ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
+#if !NET35
+                // Get the architecture from the runtime.
+                processorArchitecture = RuntimeInformation.OSArchitecture switch
+                {
+                    Architecture.Arm => ProcessorArchitectures.ARM,
+                    Architecture.Arm64 => ProcessorArchitectures.ARM64,
+                    Architecture.X64 => ProcessorArchitectures.X64,
+                    Architecture.X86 => ProcessorArchitectures.X86,
+                    _ => ProcessorArchitectures.Unknown,
+                };
+#endif
+                // Fall back to 'uname -m' to get the architecture.
+                if (processorArchitecture == ProcessorArchitectures.Unknown)
+                {
+                    try
+                    {
+                        // On Unix run 'uname -m' to get the architecture. It's common for Linux and Mac
+                        using (
+                            var proc =
+                                Process.Start(
+                                    new ProcessStartInfo("uname")
+                                    {
+                                        Arguments = "-m",
+                                        UseShellExecute = false,
+                                        RedirectStandardOutput = true,
+                                        CreateNoWindow = true
+                                    }))
+                        {
+                            string arch = null;
+                            if (proc != null)
+                            {
+                                arch = proc.StandardOutput.ReadLine();
+                                proc.WaitForExit();
+                            }
+
+                            if (!string.IsNullOrEmpty(arch))
+                            {
+                                if (arch.StartsWith("x86_64", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.X64;
+                                }
+                                else if (arch.StartsWith("ia64", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.IA64;
+                                }
+                                else if (arch.StartsWith("arm", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.ARM;
+                                }
+                                else if (arch.StartsWith("aarch64", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.ARM64;
+                                }
+                                else if (arch.StartsWith("i", StringComparison.OrdinalIgnoreCase)
+                                        && arch.EndsWith("86", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.X86;
+                                }
+                            }
+                        }
+                    }
+                    catch
+                    {
+                        // Best effort: fall back to Unknown
+                    }
+                }
+
+                ProcessorArchitectureTypeNative = ProcessorArchitectureType = processorArchitecture;
+            }
+        }
+    }
+
+    public static int GetLogicalCoreCount()
+    {
+        int numberOfCpus = Environment.ProcessorCount;
+#if !MONO
+        // .NET Core on Windows returns a core count limited to the current NUMA node
+        //     https://github.com/dotnet/runtime/issues/29686
+        // so always double-check it.
+        if (IsWindows
+#if NETFRAMEWORK
+            // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
+            // So if we get a high core count on full framework, double-check it.
+            && (numberOfCpus >= 32)
+#endif
+            )
+        {
+            var result = GetLogicalCoreCountOnWindows();
+            if (result != -1)
+            {
+                numberOfCpus = result;
+            }
+        }
+#endif
+
+        return numberOfCpus;
+    }
+
+    /// <summary>
+    /// Get the exact physical core count on Windows
+    /// Useful for getting the exact core count in 32 bits processes,
+    /// as Environment.ProcessorCount has a 32-core limit in that case.
+    /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
+    /// </summary>
+    private unsafe static int GetLogicalCoreCountOnWindows()
+    {
+        uint len = 0;
+        const int ERROR_INSUFFICIENT_BUFFER = 122;
+
+        if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref len) &&
+            Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)
+        {
+            // Allocate that much space
+            var buffer = new byte[len];
+            fixed (byte* bufferPtr = buffer)
+            {
+                // Call GetLogicalProcessorInformationEx with the allocated buffer
+                if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, (IntPtr)bufferPtr, ref len))
+                {
+                    // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how
+                    // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.
+                    int processorCount = 0;
+                    byte* ptr = bufferPtr;
+                    byte* endPtr = bufferPtr + len;
+                    while (ptr < endPtr)
+                    {
+                        var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;
+                        if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)
+                        {
+                            // Flags is 0 if the core has a single logical proc, LTP_PC_SMT if more than one
+                            // for now, assume "more than 1" == 2, as it has historically been for hyperthreading
+                            processorCount += (current->Processor.Flags == 0) ? 1 : 2;
+                        }
+                        ptr += current->Size;
+                    }
+                    return processorCount;
+                }
+            }
+        }
+
+        return -1;
+    }
+
+    #endregion
+
+    #region Member data
+
+    internal static bool HasMaxPath => MaxPath == MAX_PATH;
+
+    /// <summary>
+    /// Gets the max path limit of the current OS.
+    /// </summary>
+    internal static int MaxPath
+    {
+        get
+        {
+            if (!IsMaxPathSet)
+            {
+                SetMaxPath();
+            }
+            return _maxPath;
+        }
+    }
+
+    /// <summary>
+    /// Cached value for MaxPath.
+    /// </summary>
+    private static int _maxPath;
+
+    private static bool IsMaxPathSet { get; set; }
+
+    private static readonly object MaxPathLock = new object();
+
+    private static void SetMaxPath()
+    {
+        lock (MaxPathLock)
+        {
+            if (!IsMaxPathSet)
+            {
+                bool isMaxPathRestricted = Traits.Instance.EscapeHatches.DisableLongPaths || IsMaxPathLegacyWindows();
+                _maxPath = isMaxPathRestricted ? MAX_PATH : int.MaxValue;
+                IsMaxPathSet = true;
+            }
+        }
+    }
+
+    internal static bool IsMaxPathLegacyWindows()
+    {
+        try
+        {
+            return IsWindows && !IsLongPathsEnabledRegistry();
+        }
+        catch
+        {
+            return true;
+        }
+    }
+
+    // CA1416 warns about code that can only run on Windows, but we verified we're running on Windows before this.
+    // This is the most reasonable way to resolve this part because other ways would require ifdef'ing on NET472.
+#pragma warning disable CA1416
+    private static bool IsLongPathsEnabledRegistry()
+    {
+        using (RegistryKey fileSystemKey = Registry.LocalMachine.OpenSubKey(WINDOWS_FILE_SYSTEM_REGISTRY_KEY))
+        {
+            object longPathsEnabledValue = fileSystemKey?.GetValue(WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME, 0);
+            return fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1;
+        }
+    }
+#pragma warning restore CA1416
+
+    /// <summary>
+    /// Cached value for IsUnixLike (this method is called frequently during evaluation).
+    /// </summary>
+    private static readonly bool s_isUnixLike = IsLinux || IsOSX || IsBSD;
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under a Unix-like system (Mac, Linux, etc.)
+    /// </summary>
+    internal static bool IsUnixLike
+    {
+        get { return s_isUnixLike; }
+    }
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under Linux
+    /// </summary>
+    internal static bool IsLinux
+    {
+#if CLR2COMPATIBILITY
+            get { return false; }
+#else
+        get { return RuntimeInformation.IsOSPlatform(OSPlatform.Linux); }
+#endif
+    }
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under flavor of BSD (NetBSD, OpenBSD, FreeBSD)
+    /// </summary>
+    internal static bool IsBSD
+    {
+#if CLR2COMPATIBILITY
+            get { return false; }
+#else
+        get
+        {
+            return RuntimeInformation.IsOSPlatform(OSPlatform.Create("FREEBSD")) ||
+                   RuntimeInformation.IsOSPlatform(OSPlatform.Create("NETBSD")) ||
+                   RuntimeInformation.IsOSPlatform(OSPlatform.Create("OPENBSD"));
+        }
+#endif
+    }
+
+    private static readonly object IsMonoLock = new object();
+
+    private static bool? _isMono;
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under MONO
+    /// </summary>
+    internal static bool IsMono
+    {
+        get
+        {
+            if (_isMono != null) return _isMono.Value;
+
+            lock (IsMonoLock)
+            {
+                if (_isMono == null)
+                {
+                    // There could be potentially expensive TypeResolve events, so cache IsMono.
+                    // Also, VS does not host Mono runtimes, so turn IsMono off when msbuild is running under VS
+                    _isMono = !BuildEnvironmentState.s_runningInVisualStudio &&
+                              Type.GetType("Mono.Runtime") != null;
+                }
+            }
+
+            return _isMono.Value;
+        }
+    }
+
+#if !CLR2COMPATIBILITY
+    private static bool? _isWindows;
+#endif
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under some version of Windows
+    /// </summary>
+    internal static bool IsWindows
+    {
+#if CLR2COMPATIBILITY
+            get { return true; }
+#else
+        get
+        {
+            if (_isWindows == null)
+            {
+                _isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
+            }
+            return _isWindows.Value;
+        }
+#endif
+    }
+
+#if !CLR2COMPATIBILITY
+    private static bool? _isOSX;
+#endif
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under Mac OSX
+    /// </summary>
+    internal static bool IsOSX
+    {
+#if CLR2COMPATIBILITY
+            get { return false; }
+#else
+        get
+        {
+            if (_isOSX == null)
+            {
+                _isOSX = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
+            }
+            return _isOSX.Value;
+        }
+#endif
+    }
+
+    /// <summary>
+    /// Gets a string for the current OS. This matches the OS env variable
+    /// for Windows (Windows_NT).
+    /// </summary>
+    internal static string OSName
+    {
+        get { return IsWindows ? "Windows_NT" : "Unix"; }
+    }
+
+    /// <summary>
+    /// OS name that can be used for the msbuildExtensionsPathSearchPaths element
+    /// for a toolset
+    /// </summary>
+    internal static string GetOSNameForExtensionsPath()
+    {
+        return IsOSX ? "osx" : IsUnixLike ? "unix" : "windows";
+    }
+
+    internal static bool OSUsesCaseSensitivePaths
+    {
+        get { return IsLinux; }
+    }
+
+    /// <summary>
+    /// The base directory for all framework paths in Mono
+    /// </summary>
+    private static string s_frameworkBasePath;
+
+    /// <summary>
+    /// The directory of the current framework
+    /// </summary>
+    private static string s_frameworkCurrentPath;
+
+    /// <summary>
+    /// Gets the currently running framework path
+    /// </summary>
+    internal static string FrameworkCurrentPath
+    {
+        get
+        {
+            if (s_frameworkCurrentPath == null)
+            {
+                var baseTypeLocation = AssemblyUtilities.GetAssemblyLocation(typeof(string).GetTypeInfo().Assembly);
+
+                s_frameworkCurrentPath =
+                    Path.GetDirectoryName(baseTypeLocation)
+                    ?? string.Empty;
+            }
+
+            return s_frameworkCurrentPath;
+        }
+    }
+
+    /// <summary>
+    /// Gets the base directory of all Mono frameworks
+    /// </summary>
+    internal static string FrameworkBasePath
+    {
+        get
+        {
+            if (s_frameworkBasePath == null)
+            {
+                var dir = FrameworkCurrentPath;
+                if (dir != string.Empty)
+                {
+                    dir = Path.GetDirectoryName(dir);
+                }
+
+                s_frameworkBasePath = dir ?? string.Empty;
+            }
+
+            return s_frameworkBasePath;
+        }
+    }
+
+    /// <summary>
+    /// System information, initialized when required.
+    /// </summary>
+    /// <remarks>
+    /// Initially implemented as <see cref="Lazy{SystemInformationData}"/>, but
+    /// that's .NET 4+, and this is used in MSBuildTaskHost.
+    /// </remarks>
+    private static SystemInformationData SystemInformation
+    {
+        get
+        {
+            if (!_systemInformationInitialized)
+            {
+                lock (SystemInformationLock)
+                {
+                    if (!_systemInformationInitialized)
+                    {
+                        _systemInformation = new SystemInformationData();
+                        _systemInformationInitialized = true;
+                    }
+                }
+            }
+            return _systemInformation;
+        }
+    }
+
+    private static SystemInformationData _systemInformation;
+    private static bool _systemInformationInitialized;
+    private static readonly object SystemInformationLock = new object();
+
+    /// <summary>
+    /// Architecture getter
+    /// </summary>
+    internal static ProcessorArchitectures ProcessorArchitecture => SystemInformation.ProcessorArchitectureType;
+
+    /// <summary>
+    /// Native architecture getter
+    /// </summary>
+    internal static ProcessorArchitectures ProcessorArchitectureNative => SystemInformation.ProcessorArchitectureTypeNative;
+
+    #endregion
+
+    #region Wrapper methods
+
+    /// <summary>
+    /// Really truly non pumping wait.
+    /// Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
+    /// single SafeHandles.
+    /// </summary>
+    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
+    public static extern Int32 WaitForMultipleObjects(uint handle, IntPtr[] handles, bool waitAll, uint milliseconds);
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern void GetSystemInfo(ref SYSTEM_INFO lpSystemInfo);
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
+
+    /// <summary>
+    /// Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
+    /// if the directory does not exist, then false is returned and fileModifiedTimeUtc is set DateTime.MinValue.
+    /// </summary>
+    /// <param name="fullPath">Full path to the file in the filesystem</param>
+    /// <param name="fileModifiedTimeUtc">The UTC last write time for the directory</param>
+    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, out DateTime fileModifiedTimeUtc)
+    {
+        // This code was copied from the reference manager, if there is a bug fix in that code, see if the same fix should also be made
+        // there
+        if (IsWindows)
+        {
+            fileModifiedTimeUtc = DateTime.MinValue;
+
+            WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+            bool success = GetFileAttributesEx(fullPath, 0, ref data);
+            if (success)
+            {
+                if ((data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
+                {
+                    long dt = ((long)(data.ftLastWriteTimeHigh) << 32) | ((long)data.ftLastWriteTimeLow);
+                    fileModifiedTimeUtc = DateTime.FromFileTimeUtc(dt);
+                }
+                else
+                {
+                    // Path does not point to a directory
+                    success = false;
+                }
+            }
+
+            return success;
+        }
+
+        if (Directory.Exists(fullPath))
+        {
+            fileModifiedTimeUtc = Directory.GetLastWriteTimeUtc(fullPath);
+            return true;
+        }
+        else
+        {
+            fileModifiedTimeUtc = DateTime.MinValue;
+            return false;
+        }
+    }
+
+    /// <summary>
+    /// Takes the path and returns the short path
+    /// </summary>
+    internal static string GetShortFilePath(string path)
+    {
+        if (!IsWindows)
+        {
+            return path;
+        }
+
+        if (path != null)
+        {
+            int length = GetShortPathName(path, null, 0);
+            int errorCode = Marshal.GetLastWin32Error();
+
+            if (length > 0)
+            {
+                StringBuilder fullPathBuffer = new StringBuilder(length);
+                length = GetShortPathName(path, fullPathBuffer, length);
+                errorCode = Marshal.GetLastWin32Error();
+
+                if (length > 0)
+                {
+                    string fullPath = fullPathBuffer.ToString();
+                    path = fullPath;
+                }
+            }
+
+            if (length == 0 && errorCode != 0)
+            {
+                ThrowExceptionForErrorCode(errorCode);
+            }
+        }
+
+        return path;
+    }
+
+    /// <summary>
+    /// Takes the path and returns a full path
+    /// </summary>
+    /// <param name="path"></param>
+    /// <returns></returns>
+    internal static string GetLongFilePath(string path)
+    {
+        if (IsUnixLike)
+        {
+            return path;
+        }
+
+        if (path != null)
+        {
+            int length = GetLongPathName(path, null, 0);
+            int errorCode = Marshal.GetLastWin32Error();
+
+            if (length > 0)
+            {
+                StringBuilder fullPathBuffer = new StringBuilder(length);
+                length = GetLongPathName(path, fullPathBuffer, length);
+                errorCode = Marshal.GetLastWin32Error();
+
+                if (length > 0)
+                {
+                    string fullPath = fullPathBuffer.ToString();
+                    path = fullPath;
+                }
+            }
+
+            if (length == 0 && errorCode != 0)
+            {
+                ThrowExceptionForErrorCode(errorCode);
+            }
+        }
+
+        return path;
+    }
+
+    /// <summary>
+    /// Retrieves the current global memory status.
+    /// </summary>
+    internal static MemoryStatus GetMemoryStatus()
+    {
+        if (IsWindows)
+        {
+            MemoryStatus status = new MemoryStatus();
+            bool returnValue = GlobalMemoryStatusEx(status);
+            if (!returnValue)
+            {
+                return null;
+            }
+
+            return status;
+        }
+
+        return null;
+    }
+
+    /// <summary>
+    /// Get the last write time of the fullpath to the file.
+    /// </summary>
+    /// <param name="fullPath">Full path to the file in the filesystem</param>
+    /// <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
+    /// <remarks>
+    /// This method should be accurate for regular files and symlinks, but can report incorrect data
+    /// if the file's content was modified by writing to it through a different link, unless
+    /// MSBUILDALWAYSCHECKCONTENTTIMESTAMP=1.
+    /// </remarks>
+    internal static DateTime GetLastWriteFileUtcTime(string fullPath)
+    {
+        DateTime fileModifiedTime = DateTime.MinValue;
+
+        if (IsWindows)
+        {
+            if (Traits.Instance.EscapeHatches.AlwaysUseContentTimestamp)
+            {
+                return GetContentLastWriteFileUtcTime(fullPath);
+            }
+
+            WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+            bool success = GetFileAttributesEx(fullPath, 0, ref data);
+
+            if (success && (data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
+            {
+                long dt = ((long)(data.ftLastWriteTimeHigh) << 32) | ((long)data.ftLastWriteTimeLow);
+                fileModifiedTime = DateTime.FromFileTimeUtc(dt);
+
+                // If file is a symlink _and_ we're not instructed to do the wrong thing, get a more accurate timestamp.
+                if ((data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT && !Traits.Instance.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime)
+                {
+                    fileModifiedTime = GetContentLastWriteFileUtcTime(fullPath);
+                }
+            }
+
+            return fileModifiedTime;
+        }
+        else
+        {
+            return File.Exists(fullPath)
+                    ? File.GetLastWriteTimeUtc(fullPath)
+                    : DateTime.MinValue;
+        }
+    }
+
+    /// <summary>
+    /// Get the last write time of the content pointed to by a file path.
+    /// </summary>
+    /// <param name="fullPath">Full path to the file in the filesystem</param>
+    /// <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
+    /// <remarks>
+    /// This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
+    /// See https://github.com/Microsoft/msbuild/issues/2052.
+    /// </remarks>
+    private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
+    {
+        DateTime fileModifiedTime = DateTime.MinValue;
+
+        using (SafeFileHandle handle =
+            CreateFile(fullPath,
+                GENERIC_READ,
+                FILE_SHARE_READ,
+                IntPtr.Zero,
+                OPEN_EXISTING,
+                FILE_ATTRIBUTE_NORMAL, /* No FILE_FLAG_OPEN_REPARSE_POINT; read through to content */
+                IntPtr.Zero))
+        {
+            if (!handle.IsInvalid)
+            {
+                FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime;
+                if (GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime))
+                {
+                    long fileTime = ((long)(uint)ftLastWriteTime.dwHighDateTime) << 32 |
+                                    (long)(uint)ftLastWriteTime.dwLowDateTime;
+                    fileModifiedTime =
+                        DateTime.FromFileTimeUtc(fileTime);
+                }
+            }
+        }
+
+        return fileModifiedTime;
+    }
+
+    /// <summary>
+    /// Did the HRESULT succeed
+    /// </summary>
+    public static bool HResultSucceeded(int hr)
+    {
+        return hr >= 0;
+    }
+
+    /// <summary>
+    /// Did the HRESULT Fail
+    /// </summary>
+    public static bool HResultFailed(int hr)
+    {
+        return hr < 0;
+    }
+
+    /// <summary>
+    /// Given an error code, converts it to an HRESULT and throws the appropriate exception.
+    /// </summary>
+    /// <param name="errorCode"></param>
+    public static void ThrowExceptionForErrorCode(int errorCode)
+    {
+        // See ndp\clr\src\bcl\system\io\__error.cs for this code as it appears in the CLR.
+
+        // Something really bad went wrong with the call
+        // translate the error into an exception
+
+        // Convert the errorcode into an HRESULT (See MakeHRFromErrorCode in Win32Native.cs in
+        // ndp\clr\src\bcl\microsoft\win32)
+        errorCode = unchecked(((int)0x80070000) | errorCode);
+
+        // Throw an exception as best we can
+        Marshal.ThrowExceptionForHR(errorCode);
+    }
+
+    /// <summary>
+    /// Kills the specified process by id and all of its children recursively.
+    /// </summary>
+    internal static void KillTree(int processIdToKill)
+    {
+        // Note that GetProcessById does *NOT* internally hold on to the process handle.
+        // Only when you create the process using the Process object
+        // does the Process object retain the original handle.
+
+        Process thisProcess;
+        try
+        {
+            thisProcess = Process.GetProcessById(processIdToKill);
+        }
+        catch (ArgumentException)
+        {
+            // The process has already died for some reason.  So shrug and assume that any child processes
+            // have all also either died or are in the process of doing so.
+            return;
+        }
+
+        try
+        {
+            DateTime myStartTime = thisProcess.StartTime;
+
+            // Grab the process handle.  We want to keep this open for the duration of the function so that
+            // it cannot be reused while we are running.
+            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill);
+            if (hProcess.IsInvalid)
+            {
+                return;
+            }
+
+            try
+            {
+                try
+                {
+                    // Kill this process, so that no further children can be created.
+                    thisProcess.Kill();
+                }
+                catch (Win32Exception e)
+                {
+                    // Access denied is potentially expected -- it happens when the process that
+                    // we're attempting to kill is already dead.  So just ignore in that case.
+                    if (e.NativeErrorCode != ERROR_ACCESS_DENIED)
+                    {
+                        throw;
+                    }
+                }
+
+                // Now enumerate our children.  Children of this process are any process which has this process id as its parent
+                // and which also started after this process did.
+                List<KeyValuePair<int, SafeProcessHandle>> children = GetChildProcessIds(processIdToKill, myStartTime);
+
+                try
+                {
+                    foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)
+                    {
+                        KillTree(childProcessInfo.Key);
+                    }
+                }
+                finally
+                {
+                    foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)
+                    {
+                        childProcessInfo.Value.Dispose();
+                    }
+                }
+            }
+            finally
+            {
+                // Release the handle.  After this point no more children of this process exist and this process has also exited.
+                hProcess.Dispose();
+            }
+        }
+        finally
+        {
+            thisProcess.Dispose();
+        }
+    }
+
+    /// <summary>
+    /// Returns the parent process id for the specified process.
+    /// Returns zero if it cannot be gotten for some reason.
+    /// </summary>
+    internal static int GetParentProcessId(int processId)
+    {
+        int ParentID = 0;
+#if !CLR2COMPATIBILITY
+        if (IsUnixLike)
+        {
+            string line = null;
+
+            try
+            {
+                // /proc/<processID>/stat returns a bunch of space separated fields. Get that string
+
+                // TODO: this was
+                // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
+                // and could be again when FileUtilities moves to Framework
+
+                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, FileAccess.Read);
+                using StreamReader r = new(fileStream);
+
+                line = r.ReadLine();
+            }
+            catch // Ignore errors since the process may have terminated
+            {
+            }
+
+            if (!string.IsNullOrWhiteSpace(line))
+            {
+                // One of the fields is the process name. It may contain any characters, but since it's
+                // in parenthesis, we can finds its end by looking for the last parenthesis. After that,
+                // there comes a space, then the second fields separated by a space is the parent id.
+                string[] statFields = line.Substring(line.LastIndexOf(')')).Split(MSBuildConstants.SpaceChar, 4);
+                if (statFields.Length >= 3)
+                {
+                    ParentID = Int32.Parse(statFields[2]);
+                }
+            }
+        }
+        else
+#endif
+        {
+            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);
+
+            if (!hProcess.IsInvalid)
+            {
+                try
+                {
+                    // UNDONE: NtQueryInformationProcess will fail if we are not elevated and other process is. Advice is to change to use ToolHelp32 API's
+                    // For now just return zero and worst case we will not kill some children.
+                    PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
+                    int pSize = 0;
+
+                    if (0 == NtQueryInformationProcess(hProcess, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, pbi.Size, ref pSize))
+                    {
+                        ParentID = (int)pbi.InheritedFromUniqueProcessId;
+                    }
+                }
+                finally
+                {
+                    hProcess.Dispose();
+                }
+            }
+        }
+
+        return ParentID;
+    }
+
+    /// <summary>
+    /// Returns an array of all the immediate child processes by id.
+    /// NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
+    /// </summary>
+    internal static List<KeyValuePair<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime)
+    {
+        List<KeyValuePair<int, SafeProcessHandle>> myChildren = new List<KeyValuePair<int, SafeProcessHandle>>();
+
+        foreach (Process possibleChildProcess in Process.GetProcesses())
+        {
+            using (possibleChildProcess)
+            {
+                // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.
+                // This way, any handle we pass back is guaranteed to be one of our actual children.
+                SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id);
+                if (childHandle.IsInvalid)
+                {
+                    continue;
+                }
+
+                bool keepHandle = false;
+                try
+                {
+                    if (possibleChildProcess.StartTime > parentStartTime)
+                    {
+                        int childParentProcessId = GetParentProcessId(possibleChildProcess.Id);
+                        if (childParentProcessId != 0)
+                        {
+                            if (parentProcessId == childParentProcessId)
+                            {
+                                // Add this one
+                                myChildren.Add(new KeyValuePair<int, SafeProcessHandle>(possibleChildProcess.Id, childHandle));
+                                keepHandle = true;
+                            }
+                        }
+                    }
+                }
+                finally
+                {
+                    if (!keepHandle)
+                    {
+                        childHandle.Dispose();
+                    }
+                }
+            }
+        }
+
+        return myChildren;
+    }
+
+    /// <summary>
+    /// Internal, optimized GetCurrentDirectory implementation that simply delegates to the native method
+    /// </summary>
+    /// <returns></returns>
+    internal unsafe static string GetCurrentDirectory()
+    {
+#if FEATURE_LEGACY_GETCURRENTDIRECTORY
+        if (IsWindows)
+        {
+            int bufferSize = GetCurrentDirectoryWin32(0, null);
+            char* buffer = stackalloc char[bufferSize];
+            int pathLength = GetCurrentDirectoryWin32(bufferSize, buffer);
+            return new string(buffer, startIndex: 0, length: pathLength);
+        }
+#endif
+        return Directory.GetCurrentDirectory();
+    }
+
+    private unsafe static int GetCurrentDirectoryWin32(int nBufferLength, char* lpBuffer)
+    {
+        int pathLength = GetCurrentDirectory(nBufferLength, lpBuffer);
+        VerifyThrowWin32Result(pathLength);
+        return pathLength;
+    }
+
+    internal unsafe static string GetFullPath(string path)
+    {
+        int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
+        char* buffer = stackalloc char[bufferSize];
+        int fullPathLength = GetFullPathWin32(path, bufferSize, buffer, IntPtr.Zero);
+        // Avoid creating new strings unnecessarily
+        return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
+    }
+
+    private unsafe static int GetFullPathWin32(string target, int bufferLength, char* buffer, IntPtr mustBeZero)
+    {
+        int pathLength = GetFullPathName(target, bufferLength, buffer, mustBeZero);
+        VerifyThrowWin32Result(pathLength);
+        return pathLength;
+    }
+
+    /// <summary>
+    /// Compare an unsafe char buffer with a <see cref="System.String"/> to see if their contents are identical.
+    /// </summary>
+    /// <param name="buffer">The beginning of the char buffer.</param>
+    /// <param name="len">The length of the buffer.</param>
+    /// <param name="s">The string.</param>
+    /// <returns>True only if the contents of <paramref name="s"/> and the first <paramref name="len"/> characters in <paramref name="buffer"/> are identical.</returns>
+    private unsafe static bool AreStringsEqual(char* buffer, int len, string s)
+    {
+        if (len != s.Length)
+        {
+            return false;
+        }
+
+        foreach (char ch in s)
+        {
+            if (ch != *buffer++)
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    internal static void VerifyThrowWin32Result(int result)
+    {
+        bool isError = result == 0;
+        if (isError)
+        {
+            int code = Marshal.GetLastWin32Error();
+            ThrowExceptionForErrorCode(code);
+        }
+    }
+
+    #endregion
+
+    #region PInvoke
+
+    /// <summary>
+    /// Gets the current OEM code page which is used by console apps
+    /// (as opposed to the Windows/ANSI code page)
+    /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
+    /// that needs to be used for instance when writing to batch files
+    /// </summary>
+    [DllImport(kernel32Dll)]
+    internal static extern int GetOEMCP();
+
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    [return: MarshalAs(UnmanagedType.Bool)]
+    internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);
+
+    [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
+    private static extern uint SearchPath
+    (
+        string path,
+        string fileName,
+        string extension,
+        int numBufferChars,
+        [Out] StringBuilder buffer,
+        int[] filePart
+    );
+
+    [DllImport("kernel32.dll", PreserveSig = true, SetLastError = true)]
+    [return: MarshalAs(UnmanagedType.Bool)]
+    internal static extern bool FreeLibrary([In] IntPtr module);
+
+    [DllImport("kernel32.dll", PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true, CharSet = CharSet.Ansi, SetLastError = true)]
+    internal static extern IntPtr GetProcAddress(IntPtr module, string procName);
+
+    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, PreserveSig = true, SetLastError = true)]
+    internal static extern IntPtr LoadLibrary(string fileName);
+
+    [DllImport(mscoreeDLL, SetLastError = true, CharSet = CharSet.Unicode)]
+    internal static extern uint GetRequestedRuntimeInfo(String pExe,
+                                            String pwszVersion,
+                                            String pConfigurationFile,
+                                            uint startupFlags,
+                                            uint runtimeInfoFlags,
+                                            [Out] StringBuilder pDirectory,
+                                            int dwDirectory,
+                                            out uint dwDirectoryLength,
+                                            [Out] StringBuilder pVersion,
+                                            int cchBuffer,
+                                            out uint dwlength);
+
+    /// <summary>
+    /// Gets the fully qualified filename of the currently executing .exe
+    /// </summary>
+    [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
+    internal static extern int GetModuleFileName(
+#if FEATURE_HANDLEREF
+            HandleRef hModule,
+#else
+            IntPtr hModule,
+#endif
+            [Out] StringBuilder buffer, int length);
+
+    [DllImport("kernel32.dll")]
+    internal static extern IntPtr GetStdHandle(int nStdHandle);
+
+    [DllImport("kernel32.dll")]
+    internal static extern uint GetFileType(IntPtr hFile);
+
+    [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    internal unsafe static extern int GetCurrentDirectory(int nBufferLength, char* lpBuffer);
+
+    [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = "SetCurrentDirectory")]
+    [return: MarshalAs(UnmanagedType.Bool)]
+    internal static extern bool SetCurrentDirectoryWindows(string path);
+
+    internal static bool SetCurrentDirectory(string path)
+    {
+        if (IsWindows)
+        {
+            return SetCurrentDirectoryWindows(path);
+        }
+
+        // Make sure this does not throw
+        try
+        {
+            Directory.SetCurrentDirectory(path);
+        }
+        catch
+        {
+        }
+        return true;
+    }
+
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    internal static unsafe extern int GetFullPathName(string target, int bufferLength, char* buffer, IntPtr mustBeZero);
+
+    [DllImport("KERNEL32.DLL")]
+    private static extern SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);
+
+    [DllImport("NTDLL.DLL")]
+    private static extern int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, ref PROCESS_BASIC_INFORMATION pbi, uint cb, ref int pSize);
+
+    [return: MarshalAs(UnmanagedType.Bool)]
+    [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
+    private static extern bool GlobalMemoryStatusEx([In, Out] MemoryStatus lpBuffer);
+
+    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
+    internal static extern int GetShortPathName(string path, [Out] StringBuilder fullpath, [In] int length);
+
+    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
+    internal static extern int GetLongPathName([In] string path, [Out] StringBuilder fullpath, [In] int length);
+
+    [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
+    internal static extern bool CreatePipe(out SafeFileHandle hReadPipe, out SafeFileHandle hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
+
+    [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
+    internal static extern bool ReadFile(SafeFileHandle hFile, byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);
+
+    /// <summary>
+    /// CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
+    /// VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
+    /// build thread which the main thread (blocked on BuildSubmission.Execute) must service.
+    /// </summary>
+    [DllImport("ole32.dll")]
+    public static extern int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, [MarshalAs(UnmanagedType.LPArray)] IntPtr[] pHandles, out int pdwIndex);
+
+    internal const uint GENERIC_READ = 0x80000000;
+    internal const uint FILE_SHARE_READ = 0x1;
+    internal const uint FILE_ATTRIBUTE_NORMAL = 0x80;
+    internal const uint FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000;
+    internal const uint OPEN_EXISTING = 3;
+
+    [DllImport("kernel32.dll", CharSet = AutoOrUnicode, CallingConvention = CallingConvention.StdCall,
+        SetLastError = true)]
+    internal static extern SafeFileHandle CreateFile(
+        string lpFileName,
+        uint dwDesiredAccess,
+        uint dwShareMode,
+        IntPtr lpSecurityAttributes,
+        uint dwCreationDisposition,
+        uint dwFlagsAndAttributes,
+        IntPtr hTemplateFile
+        );
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern bool GetFileTime(
+        SafeFileHandle hFile,
+        out FILETIME lpCreationTime,
+        out FILETIME lpLastAccessTime,
+        out FILETIME lpLastWriteTime
+        );
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    [return: MarshalAs(UnmanagedType.Bool)]
+    internal static extern bool CloseHandle(IntPtr hObject);
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
+
+    #endregion
+
+    #region Extensions
+
+    /// <summary>
+    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
+    /// servicing COM calls from other threads.
+    /// </summary>
+    [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Scope = "member", Target = "Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle,System.Int32)", Justification = "This is necessary and it has been used for a long time. No need to change it now.")]
+    internal static bool MsgWaitOne(this WaitHandle handle)
+    {
+        return handle.MsgWaitOne(Timeout.Infinite);
+    }
+
+    /// <summary>
+    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
+    /// servicing COM calls from other threads.
+    /// </summary>
+    internal static bool MsgWaitOne(this WaitHandle handle, TimeSpan timeout)
+    {
+        return MsgWaitOne(handle, (int)timeout.TotalMilliseconds);
+    }
+
+    /// <summary>
+    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
+    /// servicing COM calls from other threads.
+    /// </summary>
+    [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Justification = "Necessary to avoid pumping")]
+    internal static bool MsgWaitOne(this WaitHandle handle, int timeout)
+    {
+        // CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
+        // VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
+        // build thread which the main thread (blocked on BuildSubmission.Execute) must service.
+        int waitIndex;
+#if FEATURE_HANDLE_SAFEWAITHANDLE
+        IntPtr handlePtr = handle.SafeWaitHandle.DangerousGetHandle();
+#else
+            IntPtr handlePtr = handle.GetSafeWaitHandle().DangerousGetHandle();
+#endif
+        int returnValue = CoWaitForMultipleHandles(COWAIT_FLAGS.COWAIT_NONE, timeout, 1, new IntPtr[] { handlePtr }, out waitIndex);
+
+        if (!(returnValue == 0 || ((uint)returnValue == RPC_S_CALLPENDING && timeout != Timeout.Infinite)))
+        {
+           throw new InternalErrorException($"Received {returnValue} from CoWaitForMultipleHandles, but expected 0 (S_OK)");
+        }
+
+        return returnValue == 0;
+    }
+
+    #endregion
+
+    #region helper methods
+
+    internal static bool DirectoryExists(string fullPath)
+    {
+        return IsWindows
+            ? DirectoryExistsWindows(fullPath)
+            : Directory.Exists(fullPath);
+    }
+
+    internal static bool DirectoryExistsWindows(string fullPath)
+    {
+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+        bool success = GetFileAttributesEx(fullPath, 0, ref data);
+        return success && (data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
+    }
+
+    internal static bool FileExists(string fullPath)
+    {
+        return IsWindows
+            ? FileExistsWindows(fullPath)
+            : File.Exists(fullPath);
+    }
+
+    internal static bool FileExistsWindows(string fullPath)
+    {
+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+        bool success = GetFileAttributesEx(fullPath, 0, ref data);
+        return success && (data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0;
+    }
+
+    internal static bool FileOrDirectoryExists(string path)
+    {
+        return IsWindows
+            ? FileOrDirectoryExistsWindows(path)
+            : File.Exists(path) || Directory.Exists(path);
+    }
+
+    internal static bool FileOrDirectoryExistsWindows(string path)
+    {
+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+        return GetFileAttributesEx(path, 0, ref data);
+    }
+
+    #endregion
+
+}
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 5ab3c12ac9a..79b1e377c75 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -45,6 +45,11 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+// Ideally we wouldn't need to IVT to OM.UnitTests, which is supposed to test
+// only the public surface area of Microsoft.Build. However, there's a bunch
+// of shared code in Framework that's used there, and we can still avoid IVT
+// from Microsoft.Build to OM.UnitTests.
+[assembly: InternalsVisibleTo("Microsoft.Build.Engine.OM.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/Shared/Traits.cs b/src/Framework/Traits.cs
similarity index 92%
rename from src/Shared/Traits.cs
rename to src/Framework/Traits.cs
index d1fc45ffe12..cce067219e0 100644
--- a/src/Shared/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,9 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Shared;
+using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Utilities
+namespace Microsoft.Build.Framework
 {
     /// <summary>
     ///     Represents toggleable features of the MSBuild engine
@@ -16,7 +16,7 @@ public static Traits Instance
         {
             get
             {
-                if (BuildEnvironmentHelper.Instance.RunningTests)
+                if (BuildEnvironmentState.s_runningTests)
                 {
                     return new Traits();
                 }
@@ -343,7 +343,7 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
                 return result;
             }
 
-            ErrorUtilities.ThrowInternalError($"Environment variable \"{environmentVariable}\" should have values \"true\", \"false\" or undefined");
+            ThrowInternalError($"Environment variable \"{environmentVariable}\" should have values \"true\", \"false\" or undefined");
 
             return null;
         }
@@ -367,7 +367,7 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
                 return ProjectInstanceTranslationMode.Partial;
             }
 
-            ErrorUtilities.ThrowInternalError($"Invalid escape hatch for project instance translation: {mode}");
+            ThrowInternalError($"Invalid escape hatch for project instance translation: {mode}");
 
             return null;
         }
@@ -407,7 +407,7 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
                 return SdkReferencePropertyExpansionMode.ExpandLeaveEscaped;
             }
 
-            ErrorUtilities.ThrowInternalError($"Invalid escape hatch for SdkReference property expansion: {mode}");
+            ThrowInternalError($"Invalid escape hatch for SdkReference property expansion: {mode}");
 
             return null;
         }
@@ -425,5 +425,30 @@ public enum SdkReferencePropertyExpansionMode
             ExpandUnescape,
             ExpandLeaveEscaped
         }
+
+        /// <summary>
+        /// Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
+        /// and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
+        /// then we can give them this undocumented environment variable as an immediate workaround.
+        /// </summary>
+        /// <remarks>
+        /// Clone from ErrorUtilities which isn't (yet?) available in Framework.
+        /// </remarks>
+
+        private static readonly bool s_throwExceptions = String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
+
+        /// <summary>
+        /// Throws InternalErrorException.
+        /// </summary>
+        /// <remarks>
+        /// Clone of ErrorUtilities.ThrowInternalError which isn't (yet?) available in Framework.
+        /// </remarks>
+        internal static void ThrowInternalError(string message)
+        {
+            if (s_throwExceptions)
+            {
+                throw new InternalErrorException(message);
+            }
+        }
     }
 }
diff --git a/src/Shared/VisualStudioLocationHelper.cs b/src/Framework/VisualStudioLocationHelper.cs
similarity index 100%
rename from src/Shared/VisualStudioLocationHelper.cs
rename to src/Framework/VisualStudioLocationHelper.cs
diff --git a/src/MSBuild.UnitTests/AssemblyInfo.cs b/src/MSBuild.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/MSBuild.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/MSBuild/AssemblyInfo.cs b/src/MSBuild/AssemblyInfo.cs
index 67d13ed587e..b30ea61e1dc 100644
--- a/src/MSBuild/AssemblyInfo.cs
+++ b/src/MSBuild/AssemblyInfo.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System;
 using System.Resources;
 using System.Runtime.CompilerServices;
@@ -9,8 +11,8 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: NeutralResourcesLanguage("en")]
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index ed8140f861a..4361f23bd06 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -105,23 +105,13 @@
     <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\ExceptionHandling.cs" />
-    <Compile Include="..\Shared\InternalErrorException.cs" />
     <Compile Include="..\Shared\EventArgsFormatting.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs">
       <Link>TempFileUtilities.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -158,9 +148,6 @@
     <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedTraits.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index d4212f1d09b..e747dbcc9a3 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -15,7 +15,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
 #endif
diff --git a/src/MSBuildTaskHost/AssemblyInfo.cs b/src/MSBuildTaskHost/AssemblyInfo.cs
index 11f47e95489..32460f62989 100644
--- a/src/MSBuildTaskHost/AssemblyInfo.cs
+++ b/src/MSBuildTaskHost/AssemblyInfo.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System.Runtime.CompilerServices;
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index b26225401f6..091fbda3b3e 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -16,7 +16,7 @@
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
 
     <EnableDefaultItems>false</EnableDefaultItems>
-    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST</DefineConstants>
+    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST;NO_FRAMEWORK_IVT</DefineConstants>
     <!-- Need pointers for getting environment block -->
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <!-- It is vital that msbuildtaskhost.exe is allowed to use the full 4GB on 64 bit machines in order to help avoid
@@ -39,6 +39,9 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\BuildEnvironmentState.cs">
+      <Link>BuildEnvironmentState.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\AssemblyNameComparer.cs">
       <Link>AssemblyNameComparer.cs</Link>
     </Compile>
@@ -54,7 +57,7 @@
     <Compile Include="..\Framework\ITaskItem2.cs">
       <Link>ITaskItem2.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs" />
+    <Compile Include="..\Framework\AssemblyUtilities.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
@@ -96,7 +99,7 @@
       <Link>ITranslator.cs</Link>
     </Compile>
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
-    <Compile Include="..\Shared\InternalErrorException.cs">
+    <Compile Include="..\Framework\InternalErrorException.cs">
       <Link>InternalErrorException.cs</Link>
     </Compile>
     <Compile Include="..\Shared\InterningBinaryReader.cs">
@@ -109,7 +112,7 @@
       <Link>Modifiers.cs</Link>
     </Compile>
     <Compile Include="..\Shared\NamedPipeUtil.cs" />
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
+    <Compile Include="..\Framework\NativeMethods.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
     <Compile Include="..\Shared\NodeBuildComplete.cs">
@@ -145,10 +148,10 @@
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs">
       <Link>TaskParameterTypeVerifier.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedTraits.cs</Link>
+    <Compile Include="..\Framework\Traits.cs">
+      <Link>FrameworkTraits.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
+    <Compile Include="..\Framework\VisualStudioLocationHelper.cs">
       <Link>VisualStudioLocationHelper.cs</Link>
     </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index f35dc2f8a6e..6f305333738 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -7,6 +7,8 @@
 using System.Linq;
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
+
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
@@ -505,6 +507,11 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
             CurrentMSBuildExePath = currentMSBuildExePath;
             VisualStudioInstallRootDirectory = visualStudioPath;
 
+#if !NO_FRAMEWORK_IVT
+            Framework.BuildEnvironmentState.s_runningTests = true;
+            Framework.BuildEnvironmentState.s_runningInVisualStudio = runningInVisualStudio;
+#endif
+
             if (!string.IsNullOrEmpty(currentMSBuildExePath))
             {
                 currentMSBuildExeFile = new FileInfo(currentMSBuildExePath);
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 3c472f898d0..487080a3dff 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -11,9 +11,9 @@
 using System.Security.Principal;
 using System.Threading;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Reflection;
-using Microsoft.Build.Utilities;
 
 #if !CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Debugging;
@@ -218,8 +218,8 @@ internal static Dictionary<string, string> GetEnvironmentVariables()
                         // Copy strings out, parsing into pairs and inserting into the table.
                         // The first few environment variable entries start with an '='!
                         // The current working directory of every drive (except for those drives
-                        // you haven't cd'ed into in your DOS window) are stored in the 
-                        // environment block (as =C:=pwd) and the program's exit code is 
+                        // you haven't cd'ed into in your DOS window) are stored in the
+                        // environment block (as =C:=pwd) and the program's exit code is
                         // as well (=ExitCode=00000000)  Skip all that start with =.
                         // Read docs about Environment Blocks on MSDN's CreateProcess page.
 
@@ -233,8 +233,8 @@ internal static Dictionary<string, string> GetEnvironmentVariables()
                             int startKey = i;
 
                             // Skip to key
-                            // On some old OS, the environment block can be corrupted. 
-                            // Some lines will not have '=', so we need to check for '\0'. 
+                            // On some old OS, the environment block can be corrupted.
+                            // Some lines will not have '=', so we need to check for '\0'.
                             while (*(pEnvironmentBlock + i) != '=' && *(pEnvironmentBlock + i) != '\0')
                             {
                                 i++;
@@ -311,7 +311,7 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)
                     }
                 }
 
-                // Then, make sure the old ones have their old values. 
+                // Then, make sure the old ones have their old values.
                 foreach (KeyValuePair<string, string> entry in newEnvironment)
                 {
                     Environment.SetEnvironmentVariable(entry.Key, entry.Value);
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 060a61a061c..cd02dba6528 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -1,5 +1,6 @@
 ﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 using System;
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
index aa83426e5af..0ba09dac396 100644
--- a/src/Shared/Debugging/DebugUtils.cs
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -1,7 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Utilities;
+using Microsoft.Build.Framework;
 using System;
 using System.Diagnostics;
 using System.IO;
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 05dcb114de3..ec9ea9a668c 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -8,6 +8,8 @@
 using System.Globalization;
 using System.Threading;
 
+using Microsoft.Build.Framework;
+
 #if BUILDINGAPPXTASKS
 namespace Microsoft.Build.AppxPackage.Shared
 #else
@@ -56,7 +58,7 @@ internal static void VerifyThrowInternalError(bool condition, string message, pa
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
         internal static void ThrowInternalError(string message, params object[] args)
@@ -68,7 +70,7 @@ internal static void ThrowInternalError(string message, params object[] args)
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
         internal static void ThrowInternalError(string message, Exception innerException, params object[] args)
@@ -80,7 +82,7 @@ internal static void ThrowInternalError(string message, Exception innerException
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// Indicates the code path followed should not have been possible.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
@@ -93,7 +95,7 @@ internal static void ThrowInternalErrorUnreachable()
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// Indicates the code path followed should not have been possible.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
@@ -106,7 +108,7 @@ internal static void VerifyThrowInternalErrorUnreachable(bool condition)
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// Indicates the code path followed should not have been possible.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
@@ -461,7 +463,7 @@ object arg3
 
         /// <summary>
         /// Throws an ArgumentException that can include an inner exception.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -477,7 +479,7 @@ params object[] args
 
         /// <summary>
         /// Throws an ArgumentException that can include an inner exception.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -783,7 +785,7 @@ internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T
             }
         }
 #endif
-        
+
         /// <summary>
         /// Throws an ArgumentNullException if the given string parameter is null
         /// and ArgumentException if it has zero length.
@@ -801,7 +803,7 @@ internal static void VerifyThrowArgumentInvalidPath(string parameter, string par
         }
 
         /// <summary>
-        /// Throws an ArgumentException if the string has zero length, unless it is 
+        /// Throws an ArgumentException if the string has zero length, unless it is
         /// null, in which case no exception is thrown.
         /// </summary>
         internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)
@@ -831,7 +833,7 @@ internal static void VerifyThrowArgumentNull(object parameter, string parameterN
         {
             if (parameter == null && s_throwExceptions)
             {
-                // Most ArgumentNullException overloads append its own rather clunky multi-line message. 
+                // Most ArgumentNullException overloads append its own rather clunky multi-line message.
                 // So use the one overload that doesn't.
                 throw new ArgumentNullException(
                     ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, parameterName),
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 8ba3e225520..f359e71a71d 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.AppxPackage.Shared
 #if !CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Debugging;
 #endif
-using Microsoft.Build.Utilities;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Shared
 #endif
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index cca9caee3b3..f228386a909 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -10,13 +10,14 @@
 using System.Text.RegularExpressions;
 using System.Collections.Generic;
 using System.Threading.Tasks;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-    /// Functions for matching file names with patterns. 
+    /// Functions for matching file names with patterns.
     /// </summary>
     internal class FileMatcher
     {
@@ -317,7 +318,7 @@ private static bool ShouldEnforceMatching(string searchPattern)
         /// <summary>
         /// Same as Directory.EnumerateFiles(...) except that files that
         /// aren't accessible are skipped instead of throwing an exception.
-        /// 
+        ///
         /// Other exceptions are passed through.
         /// </summary>
         /// <param name="path">The path.</param>
@@ -387,7 +388,7 @@ bool stripProjectDirectory
         /// <summary>
         /// Same as Directory.EnumerateDirectories(...) except that files that
         /// aren't accessible are skipped instead of throwing an exception.
-        /// 
+        ///
         /// Other exceptions are passed through.
         /// </summary>
         /// <param name="path">The path.</param>
@@ -581,7 +582,7 @@ internal void SplitFileSpec(
                 out filenamePart
             );
 
-            /* 
+            /*
              * Handle the special case in which filenamePart is '**'.
              * In this case, filenamePart becomes '*.*' and the '**' is appended
              * to the end of the wildcardDirectory part.
@@ -622,12 +623,12 @@ out string filenamePart
             {
                 /*
                  * No dir separator found. This is either this form,
-                 * 
+                 *
                  *      Source.cs
                  *      *.cs
-                 * 
+                 *
                  *  or this form,
-                 * 
+                 *
                  *     **
                  */
                 fixedDirectoryPart = string.Empty;
@@ -648,14 +649,14 @@ out string filenamePart
                  * wildcard is after the dir separator.
                  *
                  * The form is one of these:
-                 * 
+                 *
                  *      dir1\Source.cs
                  *      dir1\*.cs
-                 * 
+                 *
                  * Where the trailing spec is meant to be a filename. Or,
-                 * 
+                 *
                  *      dir1\**
-                 * 
+                 *
                  * Where the trailing spec is meant to be any file recursively.
                  */
 
@@ -675,11 +676,11 @@ out string filenamePart
             {
                 /*
                  * There is no separator before the wildcard, so the form is like this:
-                 * 
+                 *
                  *      dir?\Source.cs
-                 * 
+                 *
                  * or this,
-                 * 
+                 *
                  *      dir?\**
                  */
                 fixedDirectoryPart = string.Empty;
@@ -697,7 +698,7 @@ out string filenamePart
         }
 
         /// <summary>
-        /// Removes the leading ".\" from all of the paths in the array. 
+        /// Removes the leading ".\" from all of the paths in the array.
         /// </summary>
         /// <param name="paths">Paths to remove .\ from.</param>
         private static IEnumerable<string> RemoveInitialDotSlash
@@ -728,7 +729,7 @@ internal static bool IsDirectorySeparator(char c)
             return c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar;
         }
         /// <summary>
-        /// Removes the current directory converting the file back to relative path 
+        /// Removes the current directory converting the file back to relative path
         /// </summary>
         /// <param name="paths">Paths to remove current directory from.</param>
         /// <param name="projectDirectory"></param>
@@ -837,7 +838,7 @@ struct RecursionState
         }
 
         /// <summary>
-        /// Get all files that match either the file-spec or the regular expression. 
+        /// Get all files that match either the file-spec or the regular expression.
         /// </summary>
         /// <param name="listOfFiles">List of files that gets populated.</param>
         /// <param name="recursionState">Information about the search</param>
@@ -986,7 +987,7 @@ private void GetFilesRecursive(
                     }
                 }
 
-                // We never want to strip the project directory from the leaves, because the current 
+                // We never want to strip the project directory from the leaves, because the current
                 // process directory maybe different
                 GetFilesRecursive(
                     listOfFiles,
@@ -1171,7 +1172,7 @@ RecursionState recursionState
                         //        foo\**\bar
                         //
                         // back into remainingWildcardDirectory.
-                        // This is a performance optimization. We don't want to enumerate everything if we 
+                        // This is a performance optimization. We don't want to enumerate everything if we
                         // don't have to.
                         recursionState.RemainingWildcardDirectory = indexOfNextSlash != -1 ? recursionState.RemainingWildcardDirectory.Substring(indexOfNextSlash + 1) : string.Empty;
                     }
@@ -1190,7 +1191,7 @@ RecursionState recursionState
         /// a sub-directory containing wildcard characters,
         /// and a filename which may contain wildcard characters,
         /// create a regular expression that will match that file spec.
-        /// 
+        ///
         /// PERF WARNING: this method is called in performance-critical
         /// scenarios, so keep it fast and cheap
         /// </summary>
@@ -1227,9 +1228,9 @@ string filenamePart
 
         /// <summary>
         /// Determine if the filespec is legal according to the following conditions:
-        /// 
+        ///
         /// (1) It is not legal for there to be a ".." after a wildcard.
-        /// 
+        ///
         /// (2) By definition, "**" must appear alone between directory slashes.If there is any remaining "**" then this is not
         ///     a valid filespec.
         /// </summary>
@@ -1273,7 +1274,7 @@ private static bool HasMisplacedRecursiveOperator(string str)
         /// Append the regex equivalents for character sequences in the fixed directory part of a filespec:
         ///
         /// (1) The leading \\ in UNC paths, so that the doubled slash isn't reduced in the last step
-        /// 
+        ///
         /// (2) Common filespec characters
         /// </summary>
         private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBuilder regex, string fixedDir)
@@ -1300,7 +1301,7 @@ private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBui
         /// (1) The leading **\ if existing
         ///
         /// (2) Each occurrence of recursive wildcard \**\
-        /// 
+        ///
         /// (3) Common filespec characters
         /// </summary>
         private static void AppendRegularExpressionFromWildcardDirectory(ReuseableStringBuilder regex, string wildcardDir)
@@ -1343,7 +1344,7 @@ private static void AppendRegularExpressionFromWildcardDirectory(ReuseableString
         ///
         ///     but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful
         ///     not to match 'foo.txt' by modifying the generated regex for wildcard characters * and ?
-        /// 
+        ///
         /// (2) Common filespec characters
         ///
         /// (3) Ignore the .* portion of any *.* sequence when no trailing dot exists
@@ -1422,7 +1423,7 @@ private static bool IsSpecialRegexCharacter(char ch) =>
         ///     This is an identity, so for example, these two are equivalent,
         ///
         ///         dir1\.\dir2 == dir1\dir2
-        /// 
+        ///
         ///     (2) \\ -> \
         ///         Double directory separators are treated as a single directory separator,
         ///         so, for example, this is an identity:
@@ -1432,7 +1433,7 @@ private static bool IsSpecialRegexCharacter(char ch) =>
         ///         The single exemption is for UNC path names, like this:
         ///
         ///             \\server\share != \server\share
-        /// 
+        ///
         ///         This case is handled by isUncPath in
         ///         a prior step.
         ///
@@ -1472,9 +1473,9 @@ private static int LastIndexOfDirectorySequence(string str, int startIndex)
         /// <summary>
         /// Given an index at a directory separator or start of a recursive operator,
         /// iteratively skip to the end of three sequences:
-        /// 
+        ///
         /// (1), (2) Both sequences handled by IndexOfNextNonCollapsibleChar
-        /// 
+        ///
         /// (3) \**\**\ -> \**\
         ///              This is an identity, so for example, these two are equivalent,
         ///
@@ -1515,7 +1516,7 @@ private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int start
         }
 
         /// <summary>
-        /// Given a filespec, get the information needed for file matching. 
+        /// Given a filespec, get the information needed for file matching.
         /// </summary>
         /// <param name="filespec">The filespec.</param>
         /// <param name="regexFileMatch">Receives the regular expression.</param>
@@ -1616,7 +1617,7 @@ internal static bool RawFileSpecIsValid(string filespec)
 
             /*
              * Check for patterns in the filespec that are explicitly illegal.
-             * 
+             *
              * Any path with "..." in it is illegal.
              */
             if (-1 != filespec.IndexOf("...", StringComparison.Ordinal))
@@ -1627,9 +1628,9 @@ internal static bool RawFileSpecIsValid(string filespec)
             /*
              * If there is a ':' anywhere but the second character, this is an illegal pattern.
              * Catches this case among others,
-             * 
+             *
              *        http://www.website.com
-             * 
+             *
              */
             int rightmostColon = filespec.LastIndexOf(":", StringComparison.Ordinal);
 
@@ -1933,7 +1934,7 @@ public TaskOptions(int maxTasks)
         }
 
         /// <summary>
-        /// Given a filespec, find the files that match. 
+        /// Given a filespec, find the files that match.
         /// Will never throw IO exceptions: if there is no match, returns the input verbatim.
         /// </summary>
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
@@ -2309,7 +2310,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
         }
 
         /// <summary>
-        /// Given a filespec, find the files that match. 
+        /// Given a filespec, find the files that match.
         /// Will never throw IO exceptions: if there is no match, returns the input verbatim.
         /// </summary>
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index d5d80a07e35..982a7d97273 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,7 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Utilities;
+using Microsoft.Build.Framework;
 using System;
 using System.Collections.Generic;
 using System.IO;
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 952fd9963d4..5d90ac65a18 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -17,7 +17,7 @@
 using System.Runtime.CompilerServices;
 using System.Text;
 using System.Threading;
-using Microsoft.Build.Utilities;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
@@ -1061,7 +1061,7 @@ internal static string MakeRelative(string basePath, string path)
             {
                 return ".";
             }
-            
+
             // If the paths have no component in common, the only valid relative path is the full path.
             if (index == 0)
             {
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
deleted file mode 100644
index 810125d90ac..00000000000
--- a/src/Shared/NativeMethodsShared.cs
+++ /dev/null
@@ -1,1708 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.IO;
-using System.Runtime.InteropServices;
-using System.Text;
-using System.Threading;
-using System.Reflection;
-using Microsoft.Win32;
-using Microsoft.Win32.SafeHandles;
-
-using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
-using Microsoft.Build.Utilities;
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// Interop methods.
-    /// </summary>
-    internal static class NativeMethodsShared
-    {
-        #region Constants
-
-        internal const uint ERROR_INSUFFICIENT_BUFFER = 0x8007007A;
-        internal const uint STARTUP_LOADER_SAFEMODE = 0x10;
-        internal const uint S_OK = 0x0;
-        internal const uint S_FALSE = 0x1;
-        internal const uint ERROR_ACCESS_DENIED = 0x5;
-        internal const uint ERROR_FILE_NOT_FOUND = 0x80070002;
-        internal const uint FUSION_E_PRIVATE_ASM_DISALLOWED = 0x80131044; // Tried to find unsigned assembly in GAC
-        internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
-        internal const uint FILE_TYPE_CHAR = 0x0002;
-        internal const Int32 STD_OUTPUT_HANDLE = -11;
-        internal const uint RPC_S_CALLPENDING = 0x80010115;
-        internal const uint E_ABORT = (uint)0x80004004;
-
-        internal const int FILE_ATTRIBUTE_READONLY = 0x00000001;
-        internal const int FILE_ATTRIBUTE_DIRECTORY = 0x00000010;
-        internal const int FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400;
-
-        /// <summary>
-        /// Default buffer size to use when dealing with the Windows API.
-        /// </summary>
-        internal const int MAX_PATH = 260;
-
-        private const string kernel32Dll = "kernel32.dll";
-        private const string mscoreeDLL = "mscoree.dll";
-
-        private const string WINDOWS_FILE_SYSTEM_REGISTRY_KEY = @"SYSTEM\CurrentControlSet\Control\FileSystem";
-        private const string WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME = "LongPathsEnabled";
-
-        internal static DateTime MinFileDate { get; } = DateTime.FromFileTimeUtc(0);
-
-#if FEATURE_HANDLEREF
-        internal static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
-#endif
-
-        internal static IntPtr NullIntPtr = new IntPtr(0);
-
-        // As defined in winnt.h:
-        internal const ushort PROCESSOR_ARCHITECTURE_INTEL = 0;
-        internal const ushort PROCESSOR_ARCHITECTURE_ARM = 5;
-        internal const ushort PROCESSOR_ARCHITECTURE_IA64 = 6;
-        internal const ushort PROCESSOR_ARCHITECTURE_AMD64 = 9;
-        internal const ushort PROCESSOR_ARCHITECTURE_ARM64 = 12;
-
-        internal const uint INFINITE = 0xFFFFFFFF;
-        internal const uint WAIT_ABANDONED_0 = 0x00000080;
-        internal const uint WAIT_OBJECT_0 = 0x00000000;
-        internal const uint WAIT_TIMEOUT = 0x00000102;
-
-#if FEATURE_CHARSET_AUTO
-        internal const CharSet AutoOrUnicode = CharSet.Auto;
-#else
-        internal const CharSet AutoOrUnicode = CharSet.Unicode;
-#endif
-
-        #endregion
-
-        #region Enums
-
-        private enum PROCESSINFOCLASS : int
-        {
-            ProcessBasicInformation = 0,
-            ProcessQuotaLimits,
-            ProcessIoCounters,
-            ProcessVmCounters,
-            ProcessTimes,
-            ProcessBasePriority,
-            ProcessRaisePriority,
-            ProcessDebugPort,
-            ProcessExceptionPort,
-            ProcessAccessToken,
-            ProcessLdtInformation,
-            ProcessLdtSize,
-            ProcessDefaultHardErrorMode,
-            ProcessIoPortHandlers, // Note: this is kernel mode only
-            ProcessPooledUsageAndLimits,
-            ProcessWorkingSetWatch,
-            ProcessUserModeIOPL,
-            ProcessEnableAlignmentFaultFixup,
-            ProcessPriorityClass,
-            ProcessWx86Information,
-            ProcessHandleCount,
-            ProcessAffinityMask,
-            ProcessPriorityBoost,
-            MaxProcessInfoClass
-        };
-
-        private enum eDesiredAccess : int
-        {
-            DELETE = 0x00010000,
-            READ_CONTROL = 0x00020000,
-            WRITE_DAC = 0x00040000,
-            WRITE_OWNER = 0x00080000,
-            SYNCHRONIZE = 0x00100000,
-            STANDARD_RIGHTS_ALL = 0x001F0000,
-
-            PROCESS_TERMINATE = 0x0001,
-            PROCESS_CREATE_THREAD = 0x0002,
-            PROCESS_SET_SESSIONID = 0x0004,
-            PROCESS_VM_OPERATION = 0x0008,
-            PROCESS_VM_READ = 0x0010,
-            PROCESS_VM_WRITE = 0x0020,
-            PROCESS_DUP_HANDLE = 0x0040,
-            PROCESS_CREATE_PROCESS = 0x0080,
-            PROCESS_SET_QUOTA = 0x0100,
-            PROCESS_SET_INFORMATION = 0x0200,
-            PROCESS_QUERY_INFORMATION = 0x0400,
-            PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF
-        }
-#pragma warning disable 0649, 0169
-        internal enum LOGICAL_PROCESSOR_RELATIONSHIP
-        {
-            RelationProcessorCore,
-            RelationNumaNode,
-            RelationCache,
-            RelationProcessorPackage,
-            RelationGroup,
-            RelationAll = 0xffff
-        }
-        internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
-        {
-            public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
-            public uint Size;
-            public PROCESSOR_RELATIONSHIP Processor;
-        }
-        [StructLayout(LayoutKind.Sequential)]
-        internal unsafe struct PROCESSOR_RELATIONSHIP
-        {
-            public byte Flags;
-            private byte EfficiencyClass;
-            private fixed byte Reserved[20];
-            public ushort GroupCount;
-            public IntPtr GroupInfo;
-        }
-#pragma warning restore 0169, 0149
-
-        /// <summary>
-        /// Flags for CoWaitForMultipleHandles
-        /// </summary>
-        [Flags]
-        public enum COWAIT_FLAGS : int
-        {
-            /// <summary>
-            /// Exit when a handle is signaled.
-            /// </summary>
-            COWAIT_NONE = 0,
-
-            /// <summary>
-            /// Exit when all handles are signaled AND a message is received.
-            /// </summary>
-            COWAIT_WAITALL = 0x00000001,
-
-            /// <summary>
-            /// Exit when an RPC call is serviced.
-            /// </summary>
-            COWAIT_ALERTABLE = 0x00000002
-        }
-
-        /// <summary>
-        /// Processor architecture values
-        /// </summary>
-        internal enum ProcessorArchitectures
-        {
-            // Intel 32 bit
-            X86,
-
-            // AMD64 64 bit
-            X64,
-
-            // Itanium 64
-            IA64,
-
-            // ARM
-            ARM,
-
-            // ARM64
-            ARM64,
-
-            // Who knows
-            Unknown
-        }
-
-        #endregion
-
-        #region Structs
-
-        /// <summary>
-        /// Structure that contain information about the system on which we are running
-        /// </summary>
-        [StructLayout(LayoutKind.Sequential)]
-        internal struct SYSTEM_INFO
-        {
-            // This is a union of a DWORD and a struct containing 2 WORDs.
-            internal ushort wProcessorArchitecture;
-            internal ushort wReserved;
-
-            internal uint dwPageSize;
-            internal IntPtr lpMinimumApplicationAddress;
-            internal IntPtr lpMaximumApplicationAddress;
-            internal IntPtr dwActiveProcessorMask;
-            internal uint dwNumberOfProcessors;
-            internal uint dwProcessorType;
-            internal uint dwAllocationGranularity;
-            internal ushort wProcessorLevel;
-            internal ushort wProcessorRevision;
-        }
-
-        /// <summary>
-        /// Wrap the intptr returned by OpenProcess in a safe handle.
-        /// </summary>
-        internal class SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid
-        {
-            // Create a SafeHandle, informing the base class
-            // that this SafeHandle instance "owns" the handle,
-            // and therefore SafeHandle should call
-            // our ReleaseHandle method when the SafeHandle
-            // is no longer in use
-            private SafeProcessHandle() : base(true)
-            {
-            }
-            protected override bool ReleaseHandle()
-            {
-                return CloseHandle(handle);
-            }
-        }
-
-        /// <summary>
-        /// Contains information about the current state of both physical and virtual memory, including extended memory
-        /// </summary>
-        [StructLayout(LayoutKind.Sequential, CharSet = AutoOrUnicode)]
-        internal class MemoryStatus
-        {
-            /// <summary>
-            /// Initializes a new instance of the <see cref="T:MemoryStatus"/> class.
-            /// </summary>
-            public MemoryStatus()
-            {
-#if (CLR2COMPATIBILITY)
-            _length = (uint)Marshal.SizeOf(typeof(NativeMethodsShared.MemoryStatus));
-#else
-            _length = (uint)Marshal.SizeOf<NativeMethodsShared.MemoryStatus>();
-#endif
-            }
-
-            /// <summary>
-            /// Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
-            /// </summary>
-            private uint _length;
-
-            /// <summary>
-            /// Number between 0 and 100 that specifies the approximate percentage of physical
-            /// memory that is in use (0 indicates no memory use and 100 indicates full memory use).
-            /// </summary>
-            public uint MemoryLoad;
-
-            /// <summary>
-            /// Total size of physical memory, in bytes.
-            /// </summary>
-            public ulong TotalPhysical;
-
-            /// <summary>
-            /// Size of physical memory available, in bytes.
-            /// </summary>
-            public ulong AvailablePhysical;
-
-            /// <summary>
-            /// Size of the committed memory limit, in bytes. This is physical memory plus the
-            /// size of the page file, minus a small overhead.
-            /// </summary>
-            public ulong TotalPageFile;
-
-            /// <summary>
-            /// Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
-            /// </summary>
-            public ulong AvailablePageFile;
-
-            /// <summary>
-            /// Total size of the user mode portion of the virtual address space of the calling process, in bytes.
-            /// </summary>
-            public ulong TotalVirtual;
-
-            /// <summary>
-            /// Size of unreserved and uncommitted memory in the user mode portion of the virtual
-            /// address space of the calling process, in bytes.
-            /// </summary>
-            public ulong AvailableVirtual;
-
-            /// <summary>
-            /// Size of unreserved and uncommitted memory in the extended portion of the virtual
-            /// address space of the calling process, in bytes.
-            /// </summary>
-            public ulong AvailableExtendedVirtual;
-        }
-
-        [StructLayout(LayoutKind.Sequential)]
-        private struct PROCESS_BASIC_INFORMATION
-        {
-            public uint ExitStatus;
-            public IntPtr PebBaseAddress;
-            public UIntPtr AffinityMask;
-            public int BasePriority;
-            public UIntPtr UniqueProcessId;
-            public UIntPtr InheritedFromUniqueProcessId;
-
-            public uint Size
-            {
-                get
-                {
-                    unsafe
-                    {
-                        return (uint)sizeof(PROCESS_BASIC_INFORMATION);
-                    }
-                }
-            }
-        };
-
-        /// <summary>
-        /// Contains information about a file or directory; used by GetFileAttributesEx.
-        /// </summary>
-        [StructLayout(LayoutKind.Sequential)]
-        public struct WIN32_FILE_ATTRIBUTE_DATA
-        {
-            internal int fileAttributes;
-            internal uint ftCreationTimeLow;
-            internal uint ftCreationTimeHigh;
-            internal uint ftLastAccessTimeLow;
-            internal uint ftLastAccessTimeHigh;
-            internal uint ftLastWriteTimeLow;
-            internal uint ftLastWriteTimeHigh;
-            internal uint fileSizeHigh;
-            internal uint fileSizeLow;
-        }
-
-        /// <summary>
-        /// Contains the security descriptor for an object and specifies whether
-        /// the handle retrieved by specifying this structure is inheritable.
-        /// </summary>
-        [StructLayout(LayoutKind.Sequential)]
-        internal class SecurityAttributes
-        {
-            public SecurityAttributes()
-            {
-#if (CLR2COMPATIBILITY)
-            _nLength = (uint)Marshal.SizeOf(typeof(NativeMethodsShared.SecurityAttributes));
-#else
-            _nLength = (uint)Marshal.SizeOf<NativeMethodsShared.SecurityAttributes>();
-#endif
-            }
-
-            private uint _nLength;
-
-            public IntPtr lpSecurityDescriptor;
-
-            public bool bInheritHandle;
-        }
-
-        private class SystemInformationData
-        {
-            /// <summary>
-            /// Architecture as far as the current process is concerned.
-            /// It's x86 in wow64 (native architecture is x64 in that case).
-            /// Otherwise it's the same as the native architecture.
-            /// </summary>
-            public readonly ProcessorArchitectures ProcessorArchitectureType;
-
-            /// <summary>
-            /// Actual architecture of the system.
-            /// </summary>
-            public readonly ProcessorArchitectures ProcessorArchitectureTypeNative;
-
-            /// <summary>
-            /// Convert SYSTEM_INFO architecture values to the internal enum
-            /// </summary>
-            /// <param name="arch"></param>
-            /// <returns></returns>
-            private static ProcessorArchitectures ConvertSystemArchitecture(ushort arch)
-            {
-                return arch switch
-                {
-                    PROCESSOR_ARCHITECTURE_INTEL => ProcessorArchitectures.X86,
-                    PROCESSOR_ARCHITECTURE_AMD64 => ProcessorArchitectures.X64,
-                    PROCESSOR_ARCHITECTURE_ARM => ProcessorArchitectures.ARM,
-                    PROCESSOR_ARCHITECTURE_IA64 => ProcessorArchitectures.IA64,
-                    PROCESSOR_ARCHITECTURE_ARM64 => ProcessorArchitectures.ARM64,
-                    _ => ProcessorArchitectures.Unknown,
-                };
-            }
-
-            /// <summary>
-            /// Read system info values
-            /// </summary>
-            public SystemInformationData()
-            {
-                ProcessorArchitectureType = ProcessorArchitectures.Unknown;
-                ProcessorArchitectureTypeNative = ProcessorArchitectures.Unknown;
-
-                if (IsWindows)
-                {
-                    var systemInfo = new SYSTEM_INFO();
-
-                    GetSystemInfo(ref systemInfo);
-                    ProcessorArchitectureType = ConvertSystemArchitecture(systemInfo.wProcessorArchitecture);
-
-                    GetNativeSystemInfo(ref systemInfo);
-                    ProcessorArchitectureTypeNative = ConvertSystemArchitecture(systemInfo.wProcessorArchitecture);
-                }
-                else
-                {
-                    ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
-#if !NET35
-                    // Get the architecture from the runtime.
-                    processorArchitecture = RuntimeInformation.OSArchitecture switch
-                    {
-                        Architecture.Arm => ProcessorArchitectures.ARM,
-                        Architecture.Arm64 =>  ProcessorArchitectures.ARM64,
-                        Architecture.X64 => ProcessorArchitectures.X64,
-                        Architecture.X86 => ProcessorArchitectures.X86,
-                        _ => ProcessorArchitectures.Unknown,
-                    };
-#endif
-                    // Fall back to 'uname -m' to get the architecture.
-                    if (processorArchitecture == ProcessorArchitectures.Unknown)
-                    {
-                        try
-                        {
-                            // On Unix run 'uname -m' to get the architecture. It's common for Linux and Mac
-                            using (
-                                var proc =
-                                    Process.Start(
-                                        new ProcessStartInfo("uname")
-                                        {
-                                            Arguments = "-m",
-                                            UseShellExecute = false,
-                                            RedirectStandardOutput = true,
-                                            CreateNoWindow = true
-                                        }))
-                            {
-                                string arch = null;
-                                if (proc != null)
-                                {
-                                    arch = proc.StandardOutput.ReadLine();
-                                    proc.WaitForExit();
-                                }
-
-                                if (!string.IsNullOrEmpty(arch))
-                                {
-                                    if (arch.StartsWith("x86_64", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.X64;
-                                    }
-                                    else if (arch.StartsWith("ia64", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.IA64;
-                                    }
-                                    else if (arch.StartsWith("arm", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.ARM;
-                                    }
-                                    else if (arch.StartsWith("aarch64", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.ARM64;
-                                    }
-                                    else if (arch.StartsWith("i", StringComparison.OrdinalIgnoreCase)
-                                            && arch.EndsWith("86", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.X86;
-                                    }
-                                }
-                            }
-                        }
-                        catch
-                        {
-                            // Best effort: fall back to Unknown
-                        }
-                    }
-
-                    ProcessorArchitectureTypeNative = ProcessorArchitectureType = processorArchitecture;
-                }
-            }
-        }
-
-        public static int GetLogicalCoreCount()
-        {
-            int numberOfCpus = Environment.ProcessorCount;
-#if !MONO
-            // .NET Core on Windows returns a core count limited to the current NUMA node
-            //     https://github.com/dotnet/runtime/issues/29686
-            // so always double-check it.
-            if (IsWindows
-#if NETFRAMEWORK
-                // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
-                // So if we get a high core count on full framework, double-check it.
-                && (numberOfCpus >= 32)
-#endif
-            )
-            {
-                var result = GetLogicalCoreCountOnWindows();
-                if (result != -1)
-                {
-                    numberOfCpus = result;
-                }
-            }
-#endif
-
-            return numberOfCpus;
-        }
-
-        /// <summary>
-        /// Get the exact physical core count on Windows
-        /// Useful for getting the exact core count in 32 bits processes,
-        /// as Environment.ProcessorCount has a 32-core limit in that case. 
-        /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
-        /// </summary>
-        private unsafe static int GetLogicalCoreCountOnWindows()
-        {
-            uint len = 0;
-            const int ERROR_INSUFFICIENT_BUFFER = 122;
-
-            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref len) &&
-                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)
-            {
-                // Allocate that much space
-                var buffer = new byte[len];
-                fixed (byte* bufferPtr = buffer)
-                {
-                    // Call GetLogicalProcessorInformationEx with the allocated buffer
-                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, (IntPtr)bufferPtr, ref len))
-                    {
-                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how
-                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.
-                        int processorCount = 0;
-                        byte* ptr = bufferPtr;
-                        byte* endPtr = bufferPtr + len;
-                        while (ptr < endPtr)
-                        {
-                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;
-                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)
-                            {
-                                // Flags is 0 if the core has a single logical proc, LTP_PC_SMT if more than one
-                                // for now, assume "more than 1" == 2, as it has historically been for hyperthreading
-                                processorCount += (current->Processor.Flags == 0) ? 1 : 2;
-                            }
-                            ptr += current->Size;
-                        }
-                        return processorCount;
-                    }
-                }
-            }
-
-            return -1;
-        }
-
-        #endregion
-
-        #region Member data
-
-        internal static bool HasMaxPath => MaxPath == MAX_PATH;
-
-        /// <summary>
-        /// Gets the max path limit of the current OS.
-        /// </summary>
-        internal static int MaxPath
-        {
-            get
-            {
-                if (!IsMaxPathSet)
-                {
-                    SetMaxPath();
-                }
-                return _maxPath;
-            }
-        }
-
-        /// <summary>
-        /// Cached value for MaxPath.
-        /// </summary>
-        private static int _maxPath;
-
-        private static bool IsMaxPathSet { get; set; }
-
-        private static readonly object MaxPathLock = new object();
-
-        private static void SetMaxPath()
-        {
-            lock (MaxPathLock)
-            {
-                if (!IsMaxPathSet)
-                {
-                    bool isMaxPathRestricted = Traits.Instance.EscapeHatches.DisableLongPaths || IsMaxPathLegacyWindows();
-                    _maxPath = isMaxPathRestricted ? MAX_PATH : int.MaxValue;
-                    IsMaxPathSet = true;
-                }
-            }
-        }
-
-        internal static bool IsMaxPathLegacyWindows()
-        {
-            try
-            {
-                return IsWindows && !IsLongPathsEnabledRegistry();
-            }
-            catch
-            {
-                return true;
-            }
-        }
-
-        // CA1416 warns about code that can only run on Windows, but we verified we're running on Windows before this.
-        // This is the most reasonable way to resolve this part because other ways would require ifdef'ing on NET472.
-#pragma warning disable CA1416
-        private static bool IsLongPathsEnabledRegistry()
-        {
-            using (RegistryKey fileSystemKey = Registry.LocalMachine.OpenSubKey(WINDOWS_FILE_SYSTEM_REGISTRY_KEY))
-            {
-                object longPathsEnabledValue = fileSystemKey?.GetValue(WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME, 0);
-                return fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1;
-            }
-        }
-#pragma warning restore CA1416
-
-        /// <summary>
-        /// Cached value for IsUnixLike (this method is called frequently during evaluation).
-        /// </summary>
-        private static readonly bool s_isUnixLike = IsLinux || IsOSX || IsBSD;
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under a Unix-like system (Mac, Linux, etc.)
-        /// </summary>
-        internal static bool IsUnixLike
-        {
-            get { return s_isUnixLike; }
-        }
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under Linux
-        /// </summary>
-        internal static bool IsLinux
-        {
-#if CLR2COMPATIBILITY
-            get { return false; }
-#else
-            get { return RuntimeInformation.IsOSPlatform(OSPlatform.Linux); }
-#endif
-        }
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under flavor of BSD (NetBSD, OpenBSD, FreeBSD)
-        /// </summary>
-        internal static bool IsBSD
-        {
-#if CLR2COMPATIBILITY
-            get { return false; }
-#else
-            get
-            {
-                return RuntimeInformation.IsOSPlatform(OSPlatform.Create("FREEBSD")) ||
-                       RuntimeInformation.IsOSPlatform(OSPlatform.Create("NETBSD")) ||
-                       RuntimeInformation.IsOSPlatform(OSPlatform.Create("OPENBSD"));
-            }
-#endif
-        }
-
-        private static readonly object IsMonoLock = new object();
-
-        private static bool? _isMono;
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under MONO
-        /// </summary>
-        internal static bool IsMono
-        {
-            get
-            {
-                if (_isMono != null) return _isMono.Value;
-
-                lock (IsMonoLock)
-                {
-                    if (_isMono == null)
-                    {
-                        // There could be potentially expensive TypeResolve events, so cache IsMono.
-                        // Also, VS does not host Mono runtimes, so turn IsMono off when msbuild is running under VS
-                        _isMono = !BuildEnvironmentHelper.Instance.RunningInVisualStudio &&
-                                  Type.GetType("Mono.Runtime") != null;
-                    }
-                }
-
-                return _isMono.Value;
-            }
-        }
-
-#if !CLR2COMPATIBILITY
-        private static bool? _isWindows;
-#endif
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under some version of Windows
-        /// </summary>
-        internal static bool IsWindows
-        {
-#if CLR2COMPATIBILITY
-            get { return true; }
-#else
-            get {
-                if (_isWindows == null)
-                {
-                    _isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
-                }
-                return _isWindows.Value;
-            }
-#endif
-        }
-
-#if !CLR2COMPATIBILITY
-        private static bool? _isOSX;
-#endif
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under Mac OSX
-        /// </summary>
-        internal static bool IsOSX
-        {
-#if CLR2COMPATIBILITY
-            get { return false; }
-#else
-            get {
-                if (_isOSX == null)
-                {
-                    _isOSX = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
-                }
-                return _isOSX.Value;
-            }
-#endif
-        }
-
-        /// <summary>
-        /// Gets a string for the current OS. This matches the OS env variable
-        /// for Windows (Windows_NT).
-        /// </summary>
-        internal static string OSName
-        {
-            get { return IsWindows ? "Windows_NT" : "Unix"; }
-        }
-
-        /// <summary>
-        /// OS name that can be used for the msbuildExtensionsPathSearchPaths element
-        /// for a toolset
-        /// </summary>
-        internal static string GetOSNameForExtensionsPath()
-        {
-            return IsOSX ? "osx" : IsUnixLike ? "unix" : "windows";
-        }
-
-        internal static bool OSUsesCaseSensitivePaths
-        {
-            get { return IsLinux; }
-        }
-
-        /// <summary>
-        /// The base directory for all framework paths in Mono
-        /// </summary>
-        private static string s_frameworkBasePath;
-
-        /// <summary>
-        /// The directory of the current framework
-        /// </summary>
-        private static string s_frameworkCurrentPath;
-
-        /// <summary>
-        /// Gets the currently running framework path
-        /// </summary>
-        internal static string FrameworkCurrentPath
-        {
-            get
-            {
-                if (s_frameworkCurrentPath == null)
-                {
-                    var baseTypeLocation = AssemblyUtilities.GetAssemblyLocation(typeof(string).GetTypeInfo().Assembly);
-
-                    s_frameworkCurrentPath =
-                        Path.GetDirectoryName(baseTypeLocation)
-                        ?? string.Empty;
-                }
-
-                return s_frameworkCurrentPath;
-            }
-        }
-
-        /// <summary>
-        /// Gets the base directory of all Mono frameworks
-        /// </summary>
-        internal static string FrameworkBasePath
-        {
-            get
-            {
-                if (s_frameworkBasePath == null)
-                {
-                    var dir = FrameworkCurrentPath;
-                    if (dir != string.Empty)
-                    {
-                        dir = Path.GetDirectoryName(dir);
-                    }
-
-                    s_frameworkBasePath = dir ?? string.Empty;
-                }
-
-                return s_frameworkBasePath;
-            }
-        }
-
-        /// <summary>
-        /// System information, initialized when required.
-        /// </summary>
-        /// <remarks>
-        /// Initially implemented as <see cref="Lazy{SystemInformationData}"/>, but
-        /// that's .NET 4+, and this is used in MSBuildTaskHost.
-        /// </remarks>
-        private static SystemInformationData SystemInformation
-        {
-            get
-            {
-                if (!_systemInformationInitialized)
-                {
-                    lock (SystemInformationLock)
-                    {
-                        if (!_systemInformationInitialized)
-                        {
-                            _systemInformation = new SystemInformationData();
-                            _systemInformationInitialized = true;
-                        }
-                    }
-                }
-                return _systemInformation;
-            }
-        }
-
-        private static SystemInformationData _systemInformation;
-        private static bool _systemInformationInitialized;
-        private static readonly object SystemInformationLock = new object();
-
-        /// <summary>
-        /// Architecture getter
-        /// </summary>
-        internal static ProcessorArchitectures ProcessorArchitecture => SystemInformation.ProcessorArchitectureType;
-
-        /// <summary>
-        /// Native architecture getter
-        /// </summary>
-        internal static ProcessorArchitectures ProcessorArchitectureNative => SystemInformation.ProcessorArchitectureTypeNative;
-
-#endregion
-
-#region Wrapper methods
-
-        /// <summary>
-        /// Really truly non pumping wait.
-        /// Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
-        /// single SafeHandles.
-        /// </summary>
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
-        public static extern Int32 WaitForMultipleObjects(uint handle, IntPtr[] handles, bool waitAll, uint milliseconds);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern void GetSystemInfo(ref SYSTEM_INFO lpSystemInfo);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
-        
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
-
-        /// <summary>
-        /// Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
-        /// if the directory does not exist, then false is returned and fileModifiedTimeUtc is set DateTime.MinValue.
-        /// </summary>
-        /// <param name="fullPath">Full path to the file in the filesystem</param>
-        /// <param name="fileModifiedTimeUtc">The UTC last write time for the directory</param>
-        internal static bool GetLastWriteDirectoryUtcTime(string fullPath, out DateTime fileModifiedTimeUtc)
-        {
-            // This code was copied from the reference manager, if there is a bug fix in that code, see if the same fix should also be made
-            // there
-            if (IsWindows)
-            {
-                fileModifiedTimeUtc = DateTime.MinValue;
-
-                WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                bool success = GetFileAttributesEx(fullPath, 0, ref data);
-                if (success)
-                {
-                    if ((data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
-                    {
-                        long dt = ((long)(data.ftLastWriteTimeHigh) << 32) | ((long)data.ftLastWriteTimeLow);
-                        fileModifiedTimeUtc = DateTime.FromFileTimeUtc(dt);
-                    }
-                    else
-                    {
-                        // Path does not point to a directory
-                        success = false;
-                    }
-                }
-
-                return success;
-            }
-
-            if (Directory.Exists(fullPath))
-            {
-                fileModifiedTimeUtc = Directory.GetLastWriteTimeUtc(fullPath);
-                return true;
-            }
-            else
-            {
-                fileModifiedTimeUtc = DateTime.MinValue;
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Takes the path and returns the short path
-        /// </summary>
-        internal static string GetShortFilePath(string path)
-        {
-            if (!IsWindows)
-            {
-                return path;
-            }
-
-            if (path != null)
-            {
-                int length = GetShortPathName(path, null, 0);
-                int errorCode = Marshal.GetLastWin32Error();
-
-                if (length > 0)
-                {
-                    StringBuilder fullPathBuffer = new StringBuilder(length);
-                    length = GetShortPathName(path, fullPathBuffer, length);
-                    errorCode = Marshal.GetLastWin32Error();
-
-                    if (length > 0)
-                    {
-                        string fullPath = fullPathBuffer.ToString();
-                        path = fullPath;
-                    }
-                }
-
-                if (length == 0 && errorCode != 0)
-                {
-                    ThrowExceptionForErrorCode(errorCode);
-                }
-            }
-
-            return path;
-        }
-
-        /// <summary>
-        /// Takes the path and returns a full path
-        /// </summary>
-        /// <param name="path"></param>
-        /// <returns></returns>
-        internal static string GetLongFilePath(string path)
-        {
-            if (IsUnixLike)
-            {
-                return path;
-            }
-
-            if (path != null)
-            {
-                int length = GetLongPathName(path, null, 0);
-                int errorCode = Marshal.GetLastWin32Error();
-
-                if (length > 0)
-                {
-                    StringBuilder fullPathBuffer = new StringBuilder(length);
-                    length = GetLongPathName(path, fullPathBuffer, length);
-                    errorCode = Marshal.GetLastWin32Error();
-
-                    if (length > 0)
-                    {
-                        string fullPath = fullPathBuffer.ToString();
-                        path = fullPath;
-                    }
-                }
-
-                if (length == 0 && errorCode != 0)
-                {
-                    ThrowExceptionForErrorCode(errorCode);
-                }
-            }
-
-            return path;
-        }
-
-        /// <summary>
-        /// Retrieves the current global memory status.
-        /// </summary>
-        internal static MemoryStatus GetMemoryStatus()
-        {
-            if (NativeMethodsShared.IsWindows)
-            {
-                MemoryStatus status = new MemoryStatus();
-                bool returnValue = NativeMethodsShared.GlobalMemoryStatusEx(status);
-                if (!returnValue)
-                {
-                    return null;
-                }
-
-                return status;
-            }
-
-            return null;
-        }
-
-        /// <summary>
-        /// Get the last write time of the fullpath to the file.
-        /// </summary>
-        /// <param name="fullPath">Full path to the file in the filesystem</param>
-        /// <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
-        /// <remarks>
-        /// This method should be accurate for regular files and symlinks, but can report incorrect data
-        /// if the file's content was modified by writing to it through a different link, unless
-        /// MSBUILDALWAYSCHECKCONTENTTIMESTAMP=1.
-        /// </remarks>
-        internal static DateTime GetLastWriteFileUtcTime(string fullPath)
-        {
-            DateTime fileModifiedTime = DateTime.MinValue;
-
-            if (IsWindows)
-            {
-                if (Traits.Instance.EscapeHatches.AlwaysUseContentTimestamp)
-                {
-                    return GetContentLastWriteFileUtcTime(fullPath);
-                }
-
-                WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
-
-                if (success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) == 0)
-                {
-                    long dt = ((long)(data.ftLastWriteTimeHigh) << 32) | ((long)data.ftLastWriteTimeLow);
-                    fileModifiedTime = DateTime.FromFileTimeUtc(dt);
-
-                    // If file is a symlink _and_ we're not instructed to do the wrong thing, get a more accurate timestamp. 
-                    if ((data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT && !Traits.Instance.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime)
-                    {
-                        fileModifiedTime = GetContentLastWriteFileUtcTime(fullPath);
-                    }
-                }
-
-                return fileModifiedTime;
-            }
-            else
-            {
-                return File.Exists(fullPath)
-                        ? File.GetLastWriteTimeUtc(fullPath)
-                        : DateTime.MinValue;
-            }
-        }
-
-        /// <summary>
-        /// Get the last write time of the content pointed to by a file path.
-        /// </summary>
-        /// <param name="fullPath">Full path to the file in the filesystem</param>
-        /// <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
-        /// <remarks>
-        /// This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
-        /// See https://github.com/Microsoft/msbuild/issues/2052.
-        /// </remarks>
-        private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
-        {
-            DateTime fileModifiedTime = DateTime.MinValue;
-
-            using (SafeFileHandle handle =
-                CreateFile(fullPath,
-                    GENERIC_READ,
-                    FILE_SHARE_READ,
-                    IntPtr.Zero,
-                    OPEN_EXISTING,
-                    FILE_ATTRIBUTE_NORMAL, /* No FILE_FLAG_OPEN_REPARSE_POINT; read through to content */
-                    IntPtr.Zero))
-            {
-                if (!handle.IsInvalid)
-                {
-                    FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime;
-                    if (GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime))
-                    {
-                        long fileTime = ((long)(uint)ftLastWriteTime.dwHighDateTime) << 32 |
-                                        (long)(uint)ftLastWriteTime.dwLowDateTime;
-                        fileModifiedTime =
-                            DateTime.FromFileTimeUtc(fileTime);
-                    }
-                }
-            }
-
-            return fileModifiedTime;
-        }
-
-        /// <summary>
-        /// Did the HRESULT succeed
-        /// </summary>
-        public static bool HResultSucceeded(int hr)
-        {
-            return hr >= 0;
-        }
-
-        /// <summary>
-        /// Did the HRESULT Fail
-        /// </summary>
-        public static bool HResultFailed(int hr)
-        {
-            return hr < 0;
-        }
-
-        /// <summary>
-        /// Given an error code, converts it to an HRESULT and throws the appropriate exception.
-        /// </summary>
-        /// <param name="errorCode"></param>
-        public static void ThrowExceptionForErrorCode(int errorCode)
-        {
-            // See ndp\clr\src\bcl\system\io\__error.cs for this code as it appears in the CLR.
-
-            // Something really bad went wrong with the call
-            // translate the error into an exception
-
-            // Convert the errorcode into an HRESULT (See MakeHRFromErrorCode in Win32Native.cs in
-            // ndp\clr\src\bcl\microsoft\win32)
-            errorCode = unchecked(((int)0x80070000) | errorCode);
-
-            // Throw an exception as best we can
-            Marshal.ThrowExceptionForHR(errorCode);
-        }
-
-        /// <summary>
-        /// Kills the specified process by id and all of its children recursively.
-        /// </summary>
-        internal static void KillTree(int processIdToKill)
-        {
-            // Note that GetProcessById does *NOT* internally hold on to the process handle.
-            // Only when you create the process using the Process object
-            // does the Process object retain the original handle.
-
-            Process thisProcess;
-            try
-            {
-                thisProcess = Process.GetProcessById(processIdToKill);
-            }
-            catch (ArgumentException)
-            {
-                // The process has already died for some reason.  So shrug and assume that any child processes
-                // have all also either died or are in the process of doing so.
-                return;
-            }
-
-            try
-            {
-                DateTime myStartTime = thisProcess.StartTime;
-
-                // Grab the process handle.  We want to keep this open for the duration of the function so that
-                // it cannot be reused while we are running.
-                SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill);
-                if (hProcess.IsInvalid)
-                {
-                    return;
-                }
-
-                try
-                {
-                    try
-                    {
-                        // Kill this process, so that no further children can be created.
-                        thisProcess.Kill();
-                    }
-                    catch (Win32Exception e)
-                    {
-                        // Access denied is potentially expected -- it happens when the process that
-                        // we're attempting to kill is already dead.  So just ignore in that case.
-                        if (e.NativeErrorCode != ERROR_ACCESS_DENIED)
-                        {
-                            throw;
-                        }
-                    }
-
-                    // Now enumerate our children.  Children of this process are any process which has this process id as its parent
-                    // and which also started after this process did.
-                    List<KeyValuePair<int, SafeProcessHandle>> children = GetChildProcessIds(processIdToKill, myStartTime);
-
-                    try
-                    {
-                        foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)
-                        {
-                            KillTree(childProcessInfo.Key);
-                        }
-                    }
-                    finally
-                    {
-                        foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)
-                        {
-                            childProcessInfo.Value.Dispose();
-                        }
-                    }
-                }
-                finally
-                {
-                    // Release the handle.  After this point no more children of this process exist and this process has also exited.
-                    hProcess.Dispose();
-                }
-            }
-            finally
-            {
-                thisProcess.Dispose();
-            }
-        }
-
-        /// <summary>
-        /// Returns the parent process id for the specified process.
-        /// Returns zero if it cannot be gotten for some reason.
-        /// </summary>
-        internal static int GetParentProcessId(int processId)
-        {
-            int ParentID = 0;
-#if !CLR2COMPATIBILITY
-            if (IsUnixLike)
-            {
-                string line = null;
-
-                try
-                {
-                    // /proc/<processID>/stat returns a bunch of space separated fields. Get that string
-                    using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
-                    {
-                        line = r.ReadLine();
-                    }
-                }
-                catch // Ignore errors since the process may have terminated
-                {
-                }
-
-                if (!string.IsNullOrWhiteSpace(line))
-                {
-                    // One of the fields is the process name. It may contain any characters, but since it's
-                    // in parenthesis, we can finds its end by looking for the last parenthesis. After that,
-                    // there comes a space, then the second fields separated by a space is the parent id.
-                    string[] statFields = line.Substring(line.LastIndexOf(')')).Split(MSBuildConstants.SpaceChar, 4);
-                    if (statFields.Length >= 3)
-                    {
-                        ParentID = Int32.Parse(statFields[2]);
-                    }
-                }
-            }
-            else
-#endif
-            {
-                SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);
-
-                if (!hProcess.IsInvalid)
-                {
-                    try
-                    {
-                        // UNDONE: NtQueryInformationProcess will fail if we are not elevated and other process is. Advice is to change to use ToolHelp32 API's
-                        // For now just return zero and worst case we will not kill some children.
-                        PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
-                        int pSize = 0;
-
-                        if (0 == NtQueryInformationProcess(hProcess, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, pbi.Size, ref pSize))
-                        {
-                            ParentID = (int)pbi.InheritedFromUniqueProcessId;
-                        }
-                    }
-                    finally
-                    {
-                        hProcess.Dispose();
-                    }
-                }
-            }
-
-            return ParentID;
-        }
-
-        /// <summary>
-        /// Returns an array of all the immediate child processes by id.
-        /// NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
-        /// </summary>
-        internal static List<KeyValuePair<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime)
-        {
-            List<KeyValuePair<int, SafeProcessHandle>> myChildren = new List<KeyValuePair<int, SafeProcessHandle>>();
-
-            foreach (Process possibleChildProcess in Process.GetProcesses())
-            {
-                using (possibleChildProcess)
-                {
-                    // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.
-                    // This way, any handle we pass back is guaranteed to be one of our actual children.
-                    SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id);
-                    if (childHandle.IsInvalid)
-                    {
-                        continue;
-                    }
-
-                    bool keepHandle = false;
-                    try
-                    {
-                        if (possibleChildProcess.StartTime > parentStartTime)
-                        {
-                            int childParentProcessId = GetParentProcessId(possibleChildProcess.Id);
-                            if (childParentProcessId != 0)
-                            {
-                                if (parentProcessId == childParentProcessId)
-                                {
-                                    // Add this one
-                                    myChildren.Add(new KeyValuePair<int, SafeProcessHandle>(possibleChildProcess.Id, childHandle));
-                                    keepHandle = true;
-                                }
-                            }
-                        }
-                    }
-                    finally
-                    {
-                        if (!keepHandle)
-                        {
-                            childHandle.Dispose();
-                        }
-                    }
-                }
-            }
-
-            return myChildren;
-        }
-
-        /// <summary>
-        /// Internal, optimized GetCurrentDirectory implementation that simply delegates to the native method
-        /// </summary>
-        /// <returns></returns>
-        internal unsafe static string GetCurrentDirectory()
-        {
-#if FEATURE_LEGACY_GETCURRENTDIRECTORY
-            if (IsWindows)
-            {
-                int bufferSize = GetCurrentDirectoryWin32(0, null);
-                char* buffer = stackalloc char[bufferSize];
-                int pathLength = GetCurrentDirectoryWin32(bufferSize, buffer);
-                return new string(buffer, startIndex: 0, length: pathLength);
-            }
-#endif
-            return Directory.GetCurrentDirectory();
-        }
-
-        private unsafe static int GetCurrentDirectoryWin32(int nBufferLength, char* lpBuffer)
-        {
-            int pathLength = GetCurrentDirectory(nBufferLength, lpBuffer);
-            VerifyThrowWin32Result(pathLength);
-            return pathLength;
-        }
-
-        internal unsafe static string GetFullPath(string path)
-        {
-            int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
-            char* buffer = stackalloc char[bufferSize];
-            int fullPathLength = GetFullPathWin32(path, bufferSize, buffer, IntPtr.Zero);
-            // Avoid creating new strings unnecessarily
-            return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
-        }
-
-        private unsafe static int GetFullPathWin32(string target, int bufferLength, char* buffer, IntPtr mustBeZero)
-        {
-            int pathLength = GetFullPathName(target, bufferLength, buffer, mustBeZero);
-            VerifyThrowWin32Result(pathLength);
-            return pathLength;
-        }
-
-        /// <summary>
-        /// Compare an unsafe char buffer with a <see cref="System.String"/> to see if their contents are identical.
-        /// </summary>
-        /// <param name="buffer">The beginning of the char buffer.</param>
-        /// <param name="len">The length of the buffer.</param>
-        /// <param name="s">The string.</param>
-        /// <returns>True only if the contents of <paramref name="s"/> and the first <paramref name="len"/> characters in <paramref name="buffer"/> are identical.</returns>
-        private unsafe static bool AreStringsEqual(char* buffer, int len, string s)
-        {
-            if (len != s.Length)
-            {
-                return false;
-            }
-
-            foreach (char ch in s)
-            {
-                if (ch != *buffer++)
-                {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        internal static void VerifyThrowWin32Result(int result)
-        {
-            bool isError = result == 0;
-            if (isError)
-            {
-                int code = Marshal.GetLastWin32Error();
-                ThrowExceptionForErrorCode(code);
-            }
-        }
-
-#endregion
-
-#region PInvoke
-
-        /// <summary>
-        /// Gets the current OEM code page which is used by console apps
-        /// (as opposed to the Windows/ANSI code page)
-        /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
-        /// that needs to be used for instance when writing to batch files
-        /// </summary>
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport(kernel32Dll)]
-        internal static extern int GetOEMCP();
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
-        private static extern uint SearchPath
-        (
-            string path,
-            string fileName,
-            string extension,
-            int numBufferChars,
-            [Out] StringBuilder buffer,
-            int[] filePart
-        );
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", PreserveSig = true, SetLastError = true)]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static extern bool FreeLibrary([In] IntPtr module);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true, CharSet = CharSet.Ansi, SetLastError = true)]
-        internal static extern IntPtr GetProcAddress(IntPtr module, string procName);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, PreserveSig = true, SetLastError = true)]
-        internal static extern IntPtr LoadLibrary(string fileName);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport(mscoreeDLL, SetLastError = true, CharSet = CharSet.Unicode)]
-        internal static extern uint GetRequestedRuntimeInfo(String pExe,
-                                                String pwszVersion,
-                                                String pConfigurationFile,
-                                                uint startupFlags,
-                                                uint runtimeInfoFlags,
-                                                [Out] StringBuilder pDirectory,
-                                                int dwDirectory,
-                                                out uint dwDirectoryLength,
-                                                [Out] StringBuilder pVersion,
-                                                int cchBuffer,
-                                                out uint dwlength);
-
-        /// <summary>
-        /// Gets the fully qualified filename of the currently executing .exe
-        /// </summary>
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
-        internal static extern int GetModuleFileName(
-#if FEATURE_HANDLEREF
-            HandleRef hModule,
-#else
-            IntPtr hModule,
-#endif
-            [Out] StringBuilder buffer, int length);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll")]
-        internal static extern IntPtr GetStdHandle(int nStdHandle);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll")]
-        internal static extern uint GetFileType(IntPtr hFile);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
-        internal unsafe static extern int GetCurrentDirectory(int nBufferLength, char* lpBuffer);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = "SetCurrentDirectory")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static extern bool SetCurrentDirectoryWindows(string path);
-
-        internal static bool SetCurrentDirectory(string path)
-        {
-            if (IsWindows)
-            {
-                return SetCurrentDirectoryWindows(path);
-            }
-
-            // Make sure this does not throw
-            try
-            {
-                Directory.SetCurrentDirectory(path);
-            }
-            catch
-            {
-            }
-            return true;
-        }
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
-        internal static unsafe extern int GetFullPathName(string target, int bufferLength, char* buffer, IntPtr mustBeZero);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("KERNEL32.DLL")]
-        private static extern SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("NTDLL.DLL")]
-        private static extern int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, ref PROCESS_BASIC_INFORMATION pbi, uint cb, ref int pSize);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
-        private static extern bool GlobalMemoryStatusEx([In, Out] MemoryStatus lpBuffer);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
-        internal static extern int GetShortPathName(string path, [Out] StringBuilder fullpath, [In] int length);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
-        internal static extern int GetLongPathName([In] string path, [Out] StringBuilder fullpath, [In] int length);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
-        internal static extern bool CreatePipe(out SafeFileHandle hReadPipe, out SafeFileHandle hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
-        internal static extern bool ReadFile(SafeFileHandle hFile, byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);
-
-        /// <summary>
-        /// CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
-        /// VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
-        /// build thread which the main thread (blocked on BuildSubmission.Execute) must service.
-        /// </summary>
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("ole32.dll")]
-        public static extern int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, [MarshalAs(UnmanagedType.LPArray)] IntPtr[] pHandles, out int pdwIndex);
-
-        internal const uint GENERIC_READ = 0x80000000;
-        internal const uint FILE_SHARE_READ = 0x1;
-        internal const uint FILE_ATTRIBUTE_NORMAL = 0x80;
-        internal const uint FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000;
-        internal const uint OPEN_EXISTING = 3;
-
-        [DllImport("kernel32.dll", CharSet = AutoOrUnicode, CallingConvention = CallingConvention.StdCall,
-            SetLastError = true)]
-        internal static extern SafeFileHandle CreateFile(
-            string lpFileName,
-            uint dwDesiredAccess,
-            uint dwShareMode,
-            IntPtr lpSecurityAttributes,
-            uint dwCreationDisposition,
-            uint dwFlagsAndAttributes,
-            IntPtr hTemplateFile
-            );
-
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern bool GetFileTime(
-            SafeFileHandle hFile,
-            out FILETIME lpCreationTime,
-            out FILETIME lpLastAccessTime,
-            out FILETIME lpLastWriteTime
-            );
-
-        [DllImport("kernel32.dll", SetLastError = true)]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static extern bool CloseHandle(IntPtr hObject);
-
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
-
-#endregion
-
-#region Extensions
-
-        /// <summary>
-        /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-        /// servicing COM calls from other threads.
-        /// </summary>
-        [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Scope = "member", Target = "Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle,System.Int32)", Justification = "This is necessary and it has been used for a long time. No need to change it now.")]
-        internal static bool MsgWaitOne(this WaitHandle handle)
-        {
-            return handle.MsgWaitOne(Timeout.Infinite);
-        }
-
-        /// <summary>
-        /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-        /// servicing COM calls from other threads.
-        /// </summary>
-        internal static bool MsgWaitOne(this WaitHandle handle, TimeSpan timeout)
-        {
-            return MsgWaitOne(handle, (int)timeout.TotalMilliseconds);
-        }
-
-        /// <summary>
-        /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-        /// servicing COM calls from other threads.
-        /// </summary>
-        [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Justification = "Necessary to avoid pumping")]
-        internal static bool MsgWaitOne(this WaitHandle handle, int timeout)
-        {
-            // CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
-            // VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
-            // build thread which the main thread (blocked on BuildSubmission.Execute) must service.
-            int waitIndex;
-#if FEATURE_HANDLE_SAFEWAITHANDLE
-            IntPtr handlePtr = handle.SafeWaitHandle.DangerousGetHandle();
-#else
-            IntPtr handlePtr = handle.GetSafeWaitHandle().DangerousGetHandle();
-#endif
-            int returnValue = CoWaitForMultipleHandles(COWAIT_FLAGS.COWAIT_NONE, timeout, 1, new IntPtr[] { handlePtr }, out waitIndex);
-            ErrorUtilities.VerifyThrow(returnValue == 0 || ((uint)returnValue == RPC_S_CALLPENDING && timeout != Timeout.Infinite), "Received {0} from CoWaitForMultipleHandles, but expected 0 (S_OK)", returnValue);
-            return returnValue == 0;
-        }
-
-#endregion
-
-#region helper methods
-
-        internal static bool DirectoryExists(string fullPath)
-        {
-            return NativeMethodsShared.IsWindows
-                ? DirectoryExistsWindows(fullPath)
-                : Directory.Exists(fullPath);
-        }
-
-        internal static bool DirectoryExistsWindows(string fullPath)
-        {
-            NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA data = new NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA();
-            bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
-            return success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) != 0;
-        }
-
-        internal static bool FileExists(string fullPath)
-        {
-            return NativeMethodsShared.IsWindows
-                ? FileExistsWindows(fullPath)
-                : File.Exists(fullPath);
-        }
-
-        internal static bool FileExistsWindows(string fullPath)
-        {
-            NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA data = new NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA();
-            bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
-            return success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) == 0;
-        }
-
-        internal static bool FileOrDirectoryExists(string path)
-        {
-            return IsWindows
-                ? FileOrDirectoryExistsWindows(path)
-                : File.Exists(path) || Directory.Exists(path);
-        }
-
-        internal static bool FileOrDirectoryExistsWindows(string path)
-        {
-            WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-            return GetFileAttributesEx(path, 0, ref data);
-        }
-
-#endregion
-    }
-}
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 9902fd49a06..f3f240f8537 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -6,6 +6,7 @@
 using System.Configuration;
 using System.IO;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
diff --git a/src/Shared/UnitTests/ErrorUtilities_Tests.cs b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
index c642db01e3a..6b3556f4a51 100644
--- a/src/Shared/UnitTests/ErrorUtilities_Tests.cs
+++ b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 471e1536b63..f544b884b99 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using System;
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 9922585a325..d3e93024a61 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -17,7 +17,6 @@
 
 using TempPaths = System.Collections.Generic.Dictionary<string, string>;
 using CommonWriterType = System.Action<string, string, System.Collections.Generic.IEnumerable<string>>;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index e932aba587b..e64d7b07d8c 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -14,6 +14,8 @@
 using Xunit;
 using Xunit.Abstractions;
 
+using NativeMethods = Microsoft.Build.Tasks.NativeMethods;
+
 namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
     public class ResolveAssemblyReferenceTestFixture : IDisposable
diff --git a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
index d82ce671a45..414f8d98bff 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
@@ -703,7 +703,7 @@ private void VerifyImplementationArchitecture(string winmdName, string targetPro
             string fullMessage;
             if (implementationFileArch.Equals("Unknown"))
             {
-                fullMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.UnknownProcessorArchitecture", @"C:\WinMDArchVerification\" + winmdName + ".dll", @"C:\WinMDArchVerification\" + winmdName + ".winmd", NativeMethods.IMAGE_FILE_MACHINE_R4000.ToString("X", CultureInfo.InvariantCulture));
+                fullMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.UnknownProcessorArchitecture", @"C:\WinMDArchVerification\" + winmdName + ".dll", @"C:\WinMDArchVerification\" + winmdName + ".winmd", Tasks.NativeMethods.IMAGE_FILE_MACHINE_R4000.ToString("X", CultureInfo.InvariantCulture));
             }
             else
             {
diff --git a/src/Tasks.UnitTests/AssemblyInfo.cs b/src/Tasks.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/Tasks.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 6d48ace8c4b..1d2e517b4ef 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -303,14 +303,14 @@ public void AlwaysRetryCopyEnvironmentOverride()
                     UseSymboliclinksIfPossible = UseSymbolicLinks,
                 };
 
-                // The file is read-only, so the retries will all fail. 
+                // The file is read-only, so the retries will all fail.
                 Assert.False(t.Execute());
 
-                // 3 warnings per retry, except the last one which has only two. 
+                // 3 warnings per retry, except the last one which has only two.
                 ((MockEngine)t.BuildEngine).AssertLogContains("MSB3026");
                 Assert.Equal(((t.Retries + 1) * 3) - 1, ((MockEngine)t.BuildEngine).Warnings);
 
-                // One error for "retrying failed", one error for "copy failed" 
+                // One error for "retrying failed", one error for "copy failed"
                 ((MockEngine)t.BuildEngine).AssertLogContains("MSB3027");
                 ((MockEngine)t.BuildEngine).AssertLogContains("MSB3021");
                 Assert.Equal(2, ((MockEngine)t.BuildEngine).Errors);
@@ -540,7 +540,7 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
 
                 File.WriteAllText(sourceFile, "This is a source temp file.");
 
-                // run copy twice, so we test if we are able to overwrite previously copied (or linked) file 
+                // run copy twice, so we test if we are able to overwrite previously copied (or linked) file
                 for (var i = 0; i < 2; i++)
                 {
                     var engine = new MockEngine(_testOutputHelper);
@@ -2315,7 +2315,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
                 {
                     string destLink = Path.Combine(destFolder, Path.GetFileNameWithoutExtension(sourceFile) + "." + n);
                     string linkError = String.Empty;
-                    NativeMethods.MakeHardLink(destLink, sourceFile, ref linkError);
+                    Tasks.NativeMethods.MakeHardLink(destLink, sourceFile, ref linkError);
                 }
 
                 ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index 5f0cdbf64e0..882be85d3e8 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
diff --git a/src/Tasks/AssemblyInfo.cs b/src/Tasks/AssemblyInfo.cs
index df3964f3cd5..02ca0d38cf8 100644
--- a/src/Tasks/AssemblyInfo.cs
+++ b/src/Tasks/AssemblyInfo.cs
@@ -1,20 +1,22 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System;
 using System.Resources;
 using System.Runtime.InteropServices;
 using System.Runtime.CompilerServices;
 
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
-// this assembly.  We should specify this explicitly, as opposed to letting 
-// tlbexp just pick whatever it wants.  
+// this assembly.  We should specify this explicitly, as opposed to letting
+// tlbexp just pick whatever it wants.
 [assembly: GuidAttribute("E3D4D3B9-944C-407b-A82E-B19719EA7FB3")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: NeutralResourcesLanguage("en")]
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index c58e89aecff..19b5dde493f 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -79,12 +79,6 @@
       <Link>FileDelegates.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\NGen.cs">
       <Link>NGen.cs</Link>
     </Compile>
@@ -149,9 +143,6 @@
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\Tracing.cs" />
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedTraits.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\VersionUtilities.cs">
       <Link>VersionUtilities.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -159,9 +150,6 @@
     <Compile Include="..\Shared\VisualStudioConstants.cs">
       <Link>VisualStudioConstants.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -177,8 +165,6 @@
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-    </Compile>
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 209e21d4d1e..3cb8f7f10e4 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -30,9 +30,6 @@
     <PackageReference Include="Microsoft.Win32.Registry" />
   </ItemGroup>
   <ItemGroup>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <Link>AssemblyUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
@@ -57,24 +54,12 @@
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>FileUtilitiesRegex.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-      <Link>InternalErrorException.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <Link>NativeMethodsShared.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <Link>ResourceUtilities.cs</Link>
     </Compile>
     <Compile Include="..\Shared\StringBuilderCache.cs">
       <Link>StringBuilderCache.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>Traits.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="AssemblyResources.cs" />
     <Compile Include="RunnerUtilities.cs" />
   </ItemGroup>
@@ -88,4 +73,4 @@
     <None Include="project.json" />
   </ItemGroup>
   <Import Project="..\dir.targets" />
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 9dda37aa360..f5984764cce 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -42,7 +42,7 @@ private static void AdjustForShellExecution(ref string pathToExecutable, ref str
                 var comSpec = Environment.GetEnvironmentVariable("ComSpec");
 
                 // /D: Do not load AutoRun configuration from the registry (perf)
-                arguments = $"{(Traits.Instance.EscapeHatches.UseAutoRunWhenLaunchingProcessUnderCmd ? String.Empty : "/D ")}/C \"{pathToExecutable} {arguments}\"";
+                arguments = $"/D /C \"{pathToExecutable} {arguments}\"";
                 pathToExecutable = comSpec;
             }
             else
diff --git a/src/Utilities.UnitTests/AssemblyInfo.cs b/src/Utilities.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/Utilities.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Utilities/AssemblyInfo.cs b/src/Utilities/AssemblyInfo.cs
index 0a6edcd2de0..fb29c8cb944 100644
--- a/src/Utilities/AssemblyInfo.cs
+++ b/src/Utilities/AssemblyInfo.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System;
 using System.Resources;
 #if FEATURE_SECURITY_PERMISSIONS
@@ -17,8 +19,8 @@
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: NeutralResourcesLanguage("en")]
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 30e62d134fe..065b9fc3233 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -101,9 +101,6 @@
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
       <Link>Shared\IConstrainedEqualityComparer.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-      <Link>Shared\InternalErrorException.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\IKeyed.cs">
       <Link>Shared\IKeyed.cs</Link>
     </Compile>
@@ -113,12 +110,6 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Shared\Modifiers.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <Link>Shared\NativeMethodsShared.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <Link>Shared\AssemblyUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>Shared\InprocTrackingNativeMethods.cs</Link>
     </Compile>
@@ -161,12 +152,6 @@
     <Compile Include="..\Shared\ToolsetElement.cs">
       <Link>Shared\ToolsetElement.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>Shared\VisualStudioLocationHelper.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>Shared\Traits.cs</Link>
-    </Compile>
   </ItemGroup>
 
   <ItemGroup>
