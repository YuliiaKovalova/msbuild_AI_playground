diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index fe8274a6e9e..18e3b232be1 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -661,7 +661,7 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentPropertiesIntern
 
             set
             {
-                ErrorUtilities.VerifyThrowInternalNull(value, "EnvironmentPropertiesInternal");
+                ErrorUtilities.VerifyThrowInternalNull(value, nameof(EnvironmentPropertiesInternal));
                 _environmentProperties = value;
             }
         }
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index 4fec533cc16..d9867f35c3c 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
@@ -72,7 +70,7 @@ public BuildRequestConfiguration this[int configId]
         /// <param name="config">The configuration to add.</param>
         public void AddConfiguration(BuildRequestConfiguration config)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(config, "config");
+            ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
             ErrorUtilities.VerifyThrow(config.ConfigurationId != 0, "Invalid configuration ID");
 
             lock (_lockObject)
@@ -106,7 +104,7 @@ public void RemoveConfiguration(int configId)
         /// <returns>A matching configuration if one exists, null otherwise.</returns>
         public BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(config, "config");
+            ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
             return GetMatchingConfiguration(new ConfigurationMetadata(config));
         }
 
@@ -117,7 +115,7 @@ public BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfigurat
         /// <returns>A matching configuration if one exists, null otherwise.</returns>
         public BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(configMetadata, "configMetadata");
+            ErrorUtilities.VerifyThrowArgumentNull(configMetadata, nameof(configMetadata));
             lock (_lockObject)
             {
                 int configId;
@@ -328,7 +326,7 @@ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
         /// <param name="host">The build component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 5bb31403497..3bfaada4903 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
-using System.Diagnostics;
-using System.IO;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
@@ -286,7 +284,7 @@ public void WriteResultsToDisk()
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             _componentHost = host;
         }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 45b9dc30bf0..297324cfe76 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -2,15 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Collections.Concurrent;
-using System.Text;
 using System.Threading;
-using System.Diagnostics;
 using Microsoft.Build.Shared;
 
 using BuildParameters = Microsoft.Build.Execution.BuildParameters;
-using System.Globalization;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -100,7 +96,7 @@ internal class NodeEndpointInProc : INodeEndpoint
         /// <param name="host">The component host.</param>
         private NodeEndpointInProc(EndpointMode commMode, IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
 
             _status = LinkStatus.Inactive;
             _mode = commMode;
@@ -161,7 +157,7 @@ public LinkStatus LinkStatus
         /// <param name="factory">Unused</param>
         public void Listen(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrowInternalNull(factory, "factory");
+            ErrorUtilities.VerifyThrowInternalNull(factory, nameof(factory));
             _packetFactory = factory;
 
             // Initialize our thread in async mode so we are ready when the Node-side endpoint "connects".
@@ -179,7 +175,7 @@ public void Listen(INodePacketFactory factory)
         /// <param name="factory">Unused</param>
         public void Connect(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrowInternalNull(factory, "factory");
+            ErrorUtilities.VerifyThrowInternalNull(factory, nameof(factory));
             _packetFactory = factory;
 
             // Set up asynchronous packet pump, if necessary.
@@ -324,7 +320,7 @@ private void ChangeLinkStatus(LinkStatus newStatus)
         /// <param name="packet">The packet to be transmitted.</param>
         private void EnqueuePacket(INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             ErrorUtilities.VerifyThrow(_mode == EndpointMode.Asynchronous, "EndPoint mode is synchronous, should be asynchronous");
             ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
             ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 4ae2f78cc2f..b7a3c9b04d2 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -1,24 +1,10 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
-using System.IO;
-using System.IO.Pipes;
-using System.Threading;
-using System.Diagnostics;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
 #endif
-using System.Security.Principal;
-
-using BuildParameters = Microsoft.Build.Execution.BuildParameters;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -62,7 +48,7 @@ internal NodeEndpointOutOfProc(
             bool enableReuse)
 #endif
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             _componentHost = host;
             _enableReuse = enableReuse;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 8b0b0efa8fe..c360b6f6ef2 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -2,13 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
 using System.Globalization;
-using System.Text;
 using System.Threading;
-using System.Diagnostics;
-using System.IO;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
@@ -155,8 +150,8 @@ public void ShutdownComponent()
         /// <param name="packet">The data to send.</param>
         public void SendData(int nodeId, INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentOutOfRange(nodeId == _inProcNodeId, "node");
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(nodeId == _inProcNodeId, nameof(nodeId));
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
 
             if (null == _inProcNode)
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 3d857b42622..0d47393b75c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -3,24 +3,15 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
-using System.IO;
-using System.IO.Pipes;
 using System.Diagnostics;
-using System.Threading;
-using System.Runtime.InteropServices;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
 #endif
-using System.Security.Principal;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
 
@@ -103,7 +94,7 @@ internal static long GetClientHandshake()
         /// </summary>
         public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
             if (_nodeContexts.Count == ComponentHost.BuildParameters.MaxNodeCount)
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 77f14ac3ff3..5c1749d19d5 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -10,14 +10,12 @@
 using System.Threading;
 using System.Runtime.InteropServices;
 using System.Security.Principal;
-using System.Security.Permissions;
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
 
 using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
-using System.Threading.Tasks;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd
@@ -75,7 +73,7 @@ protected IBuildComponentHost ComponentHost
         /// <param name="packet">The packet to send.</param>
         protected void SendData(NodeContext context, INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             context.SendData(packet);
         }
 
@@ -448,7 +446,7 @@ private bool WaitForConnectionFromProcess(AnonymousPipeServerStream clientToServ
         private int LaunchNode(string msbuildLocation, string commandLineArgs)
         {
             // Should always have been set already.
-            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, "msbuildLocation");
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
 
             if (!File.Exists(msbuildLocation))
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index d7496282191..187fd870a8e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -3,29 +3,18 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
 using System.IO;
-using System.IO.Pipes;
 using System.Diagnostics;
 using System.Threading;
-using System.Reflection;
-using System.Runtime.InteropServices;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
 #endif
-using System.Security.Principal;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -520,7 +509,7 @@ internal void DisconnectFromHost(TaskHostContext hostContext)
         /// </summary>
         internal bool CreateNode(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
 
             if (AvailableNodes == 0)
diff --git a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
index 3e38bab3cb8..09cc3138399 100644
--- a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
+++ b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -23,7 +19,7 @@ public class ForwardingLoggerRecord
         public ForwardingLoggerRecord(ILogger centralLogger, LoggerDescription forwardingLoggerDescription)
         {
             // The logging service allows a null central logger, so we don't check for it here.
-            ErrorUtilities.VerifyThrowArgumentNull(forwardingLoggerDescription, "forwardingLoggerDescription");
+            ErrorUtilities.VerifyThrowArgumentNull(forwardingLoggerDescription, nameof(forwardingLoggerDescription));
 
             this.CentralLogger = centralLogger;
             this.ForwardingLoggerDescription = forwardingLoggerDescription;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 76ab4ee2278..fa834a8f3e4 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -1,3 +1,6 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Exceptions;
@@ -35,8 +38,8 @@ internal class LoggingContext
         /// <param name="eventContext">The event context</param>
         public LoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingService, "loggingService");
-            ErrorUtilities.VerifyThrowArgumentNull(eventContext, "eventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingService, nameof(loggingService));
+            ErrorUtilities.VerifyThrowArgumentNull(eventContext, nameof(eventContext));
 
             _loggingService = loggingService;
             _eventContext = eventContext;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index d4e89086a53..024e27c4fd5 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -2,15 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 using System.Linq;
 using Microsoft.Build.Shared;
-using System.Diagnostics;
 using System.Threading;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Collections;
 
@@ -93,8 +89,8 @@ internal class Lookup : IPropertyProvider<ProjectPropertyInstance>, IItemProvide
         /// </summary>
         internal Lookup(ItemDictionary<ProjectItemInstance> projectItems, PropertyDictionary<ProjectPropertyInstance> properties)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectItems, "projectItems");
-            ErrorUtilities.VerifyThrowInternalNull(properties, "properties");
+            ErrorUtilities.VerifyThrowInternalNull(projectItems, nameof(projectItems));
+            ErrorUtilities.VerifyThrowInternalNull(properties, nameof(properties));
 
             Lookup.Scope scope = new Lookup.Scope(this, "Lookup()", projectItems, properties);
             _lookupScopes.AddFirst(scope);
@@ -454,7 +450,7 @@ public ProjectPropertyInstance GetProperty(string name, int startIndex, int endI
         /// </summary>
         public ProjectPropertyInstance GetProperty(string name)
         {
-            ErrorUtilities.VerifyThrowInternalLength(name, "name");
+            ErrorUtilities.VerifyThrowInternalLength(name, nameof(name));
 
             return GetProperty(name, 0, name.Length - 1);
         }
@@ -1161,7 +1157,7 @@ public MetadataModification this[string metadataName]
 
                 set
                 {
-                    ErrorUtilities.VerifyThrowInternalNull(value, "value");
+                    ErrorUtilities.VerifyThrowInternalNull(value, nameof(value));
                     _modifications[metadataName] = value;
                 }
             }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index b302375b07d..6b65b11fb19 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -2,36 +2,28 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
-using System.Reflection;
-using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using System.Globalization;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Utilities;
 #if (!STANDALONEBUILD)
 using Microsoft.Internal.Performance;
 #if MSBUILDENABLEVSPROFILING 
 using Microsoft.VisualStudio.Profiler;
 #endif
 #endif
-using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
 using ProjectLoggingContext = Microsoft.Build.BackEnd.Logging.ProjectLoggingContext;
 
@@ -194,8 +186,8 @@ internal bool HasActiveBuildRequest
         /// <param name="entry">The entry to build.</param>
         public void BuildRequest(NodeLoggingContext loggingContext, BuildRequestEntry entry)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "loggingContext");
-            ErrorUtilities.VerifyThrowArgumentNull(entry, "entry");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
             ErrorUtilities.VerifyThrow(null != _componentHost, "Host not set.");
             ErrorUtilities.VerifyThrow(_targetBuilder == null, "targetBuilder not null");
             ErrorUtilities.VerifyThrow(_nodeLoggingContext == null, "nodeLoggingContext not null");
@@ -321,10 +313,10 @@ public void WaitForCancelCompletion()
         public async Task<BuildResult[]> BuildProjects(string[] projectFiles, PropertyDictionary<ProjectPropertyInstance>[] properties, string[] toolsVersions, string[] targets, bool waitForResults, bool skipNonexistentTargets = false)
         {
             VerifyIsNotZombie();
-            ErrorUtilities.VerifyThrowArgumentNull(projectFiles, "projectFiles");
-            ErrorUtilities.VerifyThrowArgumentNull(properties, "properties");
-            ErrorUtilities.VerifyThrowArgumentNull(targets, "targets");
-            ErrorUtilities.VerifyThrowArgumentNull(toolsVersions, "toolsVersions");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFiles, nameof(projectFiles));
+            ErrorUtilities.VerifyThrowArgumentNull(properties, nameof(properties));
+            ErrorUtilities.VerifyThrowArgumentNull(targets, nameof(targets));
+            ErrorUtilities.VerifyThrowArgumentNull(toolsVersions, nameof(toolsVersions));
             ErrorUtilities.VerifyThrow(_componentHost != null, "No host object set");
             ErrorUtilities.VerifyThrow(projectFiles.Length == properties.Length, "Properties and project counts not the same");
             ErrorUtilities.VerifyThrow(projectFiles.Length == toolsVersions.Length, "Tools versions and project counts not the same");
@@ -476,7 +468,7 @@ public void ExitMSBuildCallbackState()
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             ErrorUtilities.VerifyThrow(_componentHost == null, "RequestBuilder already initialized.");
             _componentHost = host;
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index fdab8d6dfd5..a9979bf8cc7 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -4,12 +4,9 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
-using System.Text;
 using System.Threading;
-using System.Xml;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Collections;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -101,11 +98,11 @@ internal class TargetBuilder : ITargetBuilder, ITargetBuilderCallback, IBuildCom
         /// <returns>The target's outputs and result codes</returns>
         public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, string[] targetNames, Lookup baseLookup, CancellationToken cancellationToken)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "projectLoggingContext");
-            ErrorUtilities.VerifyThrowArgumentNull(entry, "entry");
-            ErrorUtilities.VerifyThrowArgumentNull(callback, "requestBuilderCallback");
-            ErrorUtilities.VerifyThrowArgumentNull(targetNames, "targetNames");
-            ErrorUtilities.VerifyThrowArgumentNull(baseLookup, "baseLookup");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
+            ErrorUtilities.VerifyThrowArgumentNull(callback, nameof(callback));
+            ErrorUtilities.VerifyThrowArgumentNull(targetNames, nameof(targetNames));
+            ErrorUtilities.VerifyThrowArgumentNull(baseLookup, nameof(baseLookup));
             ErrorUtilities.VerifyThrow(targetNames.Length > 0, "List of targets must be non-empty");
             ErrorUtilities.VerifyThrow(_componentHost != null, "InitializeComponent must be called before building targets.");
 
@@ -212,7 +209,7 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             _componentHost = host;
         }
 
@@ -538,7 +535,7 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
             if (_buildResult.HasResultsForTarget(currentTargetEntry.Name))
             {
                 TargetResult targetResult = _buildResult[currentTargetEntry.Name] as TargetResult;
-                ErrorUtilities.VerifyThrowInternalNull(targetResult, "targetResult");
+                ErrorUtilities.VerifyThrowInternalNull(targetResult, nameof(targetResult));
 
                 if (targetResult.ResultCode != TargetResultCode.Skipped)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 866128d2613..73204cb1bf2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Threading;
@@ -15,7 +14,6 @@
 using Microsoft.Build.Shared.FileSystem;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-using MessageImportance = Microsoft.Build.Framework.MessageImportance;
 using ProjectLoggingContext = Microsoft.Build.BackEnd.Logging.ProjectLoggingContext;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -168,11 +166,11 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// <param name="stopProcessingOnCompletion">True if the target builder should stop processing the current target stack when this target is complete.</param>
         internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, "requestEntry");
-            ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, "targetBuilderCallback");
-            ErrorUtilities.VerifyThrowArgumentNull(targetSpecification, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(baseLookup, "lookup");
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
+            ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, nameof(targetBuilderCallback));
+            ErrorUtilities.VerifyThrowArgumentNull(targetSpecification, nameof(targetSpecification));
+            ErrorUtilities.VerifyThrowArgumentNull(baseLookup, nameof(baseLookup));
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
 
             _requestEntry = requestEntry;
             _targetBuilderCallback = targetBuilderCallback;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index 3910b7424d7..b5bcac5bb8c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
@@ -26,8 +23,8 @@ internal class TargetSpecification : INodePacketTranslatable
         /// <param name="referenceLocation">The location from which it was referred.</param>
         internal TargetSpecification(string targetName, ElementLocation referenceLocation)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(referenceLocation, "referenceLocation");
+            ErrorUtilities.VerifyThrowArgumentLength(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(referenceLocation, nameof(referenceLocation));
 
             this._targetName = targetName;
             this._referenceLocation = referenceLocation;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index de0357c2a8a..7eb59872157 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -2,15 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.IO;
 using System.Reflection;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -289,7 +286,7 @@ private List<string> CreateListOfParameterValues()
         /// <returns>true, if successful</returns>
         private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(lookup, "lookup");
+            ErrorUtilities.VerifyThrowArgumentNull(lookup, nameof(lookup));
 
             WorkUnitResult taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null);
             TaskHost taskHost = null;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index b616220f277..b745763ef2f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -10,7 +10,6 @@
 using System.Runtime.Remoting;
 #endif
 using System.Threading;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
@@ -113,9 +112,9 @@ internal class TaskHost :
         /// <param name="targetBuilderCallback">An <see cref="ITargetBuilderCallback"/> to use to invoke targets and build projects.</param>
         public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, ElementLocation taskLocation, ITargetBuilderCallback targetBuilderCallback)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
-            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, "requestEntry");
-            ErrorUtilities.VerifyThrowInternalNull(taskLocation, "taskLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
+            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
+            ErrorUtilities.VerifyThrowInternalNull(taskLocation, nameof(taskLocation));
 
             _host = host;
             _requestEntry = requestEntry;
@@ -379,7 +378,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -449,7 +448,7 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -490,7 +489,7 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -531,7 +530,7 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -622,7 +621,7 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(eventName, "eventName");
+                ErrorUtilities.VerifyThrowArgumentNull(eventName, nameof(eventName));
 
                 if (!_activeProxy)
                 {
@@ -653,8 +652,8 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie
         /// </summary>
         public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets = false)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, nameof(projectFileNames));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
             VerifyActiveProxy();
 
             BuildEngineResult result;
@@ -820,8 +819,8 @@ internal bool IsEventSerializable(BuildEventArgs e)
         /// <returns>A Task returning a structure containing the result of the build, success or failure and the list of target outputs per project</returns>
         private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets = false)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, nameof(projectFileNames));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
             VerifyActiveProxy();
 
             List<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = null;
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 3bd3b5969da..1a62a20aa81 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
 
@@ -125,8 +124,8 @@ internal class SchedulableRequest
         /// </summary>
         public SchedulableRequest(SchedulingData collection, BuildRequest request, SchedulableRequest parent)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(collection, "collection");
-            ErrorUtilities.VerifyThrowArgumentNull(request, "request");
+            ErrorUtilities.VerifyThrowArgumentNull(collection, nameof(collection));
+            ErrorUtilities.VerifyThrowArgumentNull(request, nameof(request));
             ErrorUtilities.VerifyThrow((parent == null) || (parent._schedulingData == collection), "Parent request does not belong to the same collection.");
 
             _schedulingData = collection;
@@ -305,7 +304,7 @@ public TimeSpan GetTimeSpentInState(SchedulableRequestState desiredState)
         public void Yield(string[] activeTargets)
         {
             VerifyState(SchedulableRequestState.Executing);
-            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, "activeTargets");
+            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             _activeTargetsWhenBlocked = activeTargets;
             ChangeToState(SchedulableRequestState.Yielding);
         }
@@ -329,8 +328,8 @@ public void Reacquire()
         public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTargets, string blockingTarget = null)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
-            ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, "blockingRequest");
-            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, "activeTargets");
+            ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, nameof(blockingRequest));
+            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             ErrorUtilities.VerifyThrow(BlockingTarget == null, "Cannot block again if we're already blocked on a target");
 
             // Note that the blocking request will typically be our parent UNLESS it is a request we blocked on because it was executing a target we wanted to execute.
@@ -366,7 +365,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
         public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
-            ErrorUtilities.VerifyThrowArgumentNull(result, "result");
+            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
             DisconnectRequestWeAreBlockedBy(key);
@@ -379,7 +378,7 @@ public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         public void UnblockWithResult(BuildResult result)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
-            ErrorUtilities.VerifyThrowArgumentNull(result, "result");
+            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
             DisconnectRequestWeAreBlockedBy(key);
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index e8b9f9769fb..1dc2fa15324 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
@@ -10,7 +9,6 @@
 using System.Linq;
 using System.Text;
 using System.Threading;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -18,7 +16,6 @@
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
-using CommunicationsUtilities = Microsoft.Build.Internal.CommunicationsUtilities;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -1247,8 +1244,8 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
         /// </summary>
         private void AssignUnscheduledRequestToNode(SchedulableRequest request, int nodeId, List<ScheduleResponse> responses)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(request, "request");
-            ErrorUtilities.VerifyThrowArgumentNull(responses, "responses");
+            ErrorUtilities.VerifyThrowArgumentNull(request, nameof(request));
+            ErrorUtilities.VerifyThrowArgumentNull(responses, nameof(responses));
             ErrorUtilities.VerifyThrow(nodeId != InvalidNodeId, "Invalid node id specified.");
 
             // Currently we cannot move certain kinds of traversals (notably solution metaprojects) to other nodes because 
@@ -1486,8 +1483,8 @@ private void MarkRequestAborted(SchedulableRequest request)
         /// </summary>
         private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRequest, BuildRequestBlocker blocker)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(blockedRequest, "blockedRequest");
-            ErrorUtilities.VerifyThrowArgumentNull(blocker, "blocker");
+            ErrorUtilities.VerifyThrowArgumentNull(blockedRequest, nameof(blockedRequest));
+            ErrorUtilities.VerifyThrowArgumentNull(blocker, nameof(blocker));
 
             // We are blocked on an in-progress request building a target whose results we need.
             SchedulableRequest blockingRequest = _schedulingData.GetScheduledRequest(blocker.BlockingRequestId);
@@ -1545,8 +1542,8 @@ private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequ
         /// </summary>
         private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest, BuildRequestBlocker blocker, List<ScheduleResponse> responses)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(blocker, "blocker");
-            ErrorUtilities.VerifyThrowArgumentNull(responses, "responses");
+            ErrorUtilities.VerifyThrowArgumentNull(blocker, nameof(blocker));
+            ErrorUtilities.VerifyThrowArgumentNull(responses, nameof(responses));
 
             // The request is waiting on new requests.
             bool abortRequestBatch = false;
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 2df8149c9de..1b2ce83e8b0 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -115,8 +115,8 @@ public BuildRequest(
             BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
             RequestedProjectState requestedProjectState = null)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
-            ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, "parentBuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, nameof(escapedTargets));
+            ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, nameof(parentBuildEventContext));
 
             _submissionId = submissionId;
             _configurationId = configurationId;
diff --git a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
index 441657b139d..e124747b35e 100644
--- a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
 
@@ -44,7 +41,7 @@ internal BuildRequestUnblocker(INodePacketTranslator translator)
         /// </summary>
         internal BuildRequestUnblocker(int globalRequestIdToResume)
         {
-            ErrorUtilities.VerifyThrowArgumentOutOfRange(globalRequestIdToResume != BuildRequest.InvalidGlobalRequestId, "globalRequestIdToResume");
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(globalRequestIdToResume != BuildRequest.InvalidGlobalRequestId, nameof(globalRequestIdToResume));
             _blockedGlobalRequestId = globalRequestIdToResume;
         }
 
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 29eb418968c..4df79a79596 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -373,7 +373,7 @@ static ItemsStore()
             /// </summary>
             public ItemsStore(TaskItem[] items)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(items, "items");
+                ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
                 _uncompressedItems = items;
                 _itemsCount = items.Length;
             }
diff --git a/src/Build/Collections/ReadOnlyConvertingDictionary.cs b/src/Build/Collections/ReadOnlyConvertingDictionary.cs
index 9b5766c94bd..33bfb114787 100644
--- a/src/Build/Collections/ReadOnlyConvertingDictionary.cs
+++ b/src/Build/Collections/ReadOnlyConvertingDictionary.cs
@@ -32,8 +32,8 @@ internal class ReadOnlyConvertingDictionary<K, V, N> : IDictionary<K, N>
         /// </summary>
         internal ReadOnlyConvertingDictionary(IDictionary<K, V> backing, Func<V, N> converter)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(backing, "backing");
-            ErrorUtilities.VerifyThrowArgumentNull(converter, "converter");
+            ErrorUtilities.VerifyThrowArgumentNull(backing, nameof(backing));
+            ErrorUtilities.VerifyThrowArgumentNull(converter, nameof(converter));
 
             _backing = backing;
             _converter = converter;
diff --git a/src/Build/Construction/ProjectExtensionsElement.cs b/src/Build/Construction/ProjectExtensionsElement.cs
index 06ebff03b64..8e9e264d1f1 100644
--- a/src/Build/Construction/ProjectExtensionsElement.cs
+++ b/src/Build/Construction/ProjectExtensionsElement.cs
@@ -92,8 +92,8 @@ public string this[string name]
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-                ErrorUtilities.VerifyThrowArgumentNull(value, "value");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(value));
 
                 XmlElement idElement = XmlElement[name];
 
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 45e43e6b165..1806200a30b 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -965,8 +965,8 @@ public ProjectItemElement AddItem(string itemType, string include)
         /// </remarks>
         public ProjectItemElement AddItem(string itemType, string include, IEnumerable<KeyValuePair<string, string>> metadata)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
-            ErrorUtilities.VerifyThrowArgumentLength(include, "include");
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowArgumentLength(include, nameof(include));
 
             ProjectItemGroupElement itemGroupToAddTo = null;
 
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index 1c288e9ac64..031d218a08b 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -36,7 +36,7 @@ public class ProjectTaskElement : ProjectElementContainer
         internal ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index a1c192712aa..a903204d1a8 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -448,7 +448,7 @@ public string DefaultToolsVersion
                 ProjectCollectionChangedEventArgs eventArgs = null;
                 using (_locker.EnterWriteLock())
                 {
-                    ErrorUtilities.VerifyThrowArgumentLength(value, "DefaultToolsVersion");
+                    ErrorUtilities.VerifyThrowArgumentLength(value, nameof(DefaultToolsVersion));
 
                     if (!_toolsets.ContainsKey(value))
                     {
@@ -1024,7 +1024,7 @@ public Project LoadProject(string fileName, IDictionary<string, string> globalPr
         {
             using (_locker.EnterWriteLock())
             {
-                ErrorUtilities.VerifyThrowArgumentLength(fileName, "fileName");
+                ErrorUtilities.VerifyThrowArgumentLength(fileName, nameof(fileName));
                 BuildEventContext buildEventContext = new BuildEventContext(0 /* node ID */, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
 
                 if (globalProperties == null)
@@ -1398,7 +1398,7 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
         {
             using (_locker.EnterWriteLock())
             {
-                ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+                ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
 
                 ProjectRootElementCache.DiscardStrongReferences();
 
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 47142aa025d..7e7b6a3a9e4 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -4,11 +4,9 @@
 using System.Diagnostics;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using System;
-using System.Collections;
 using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 
@@ -116,12 +114,12 @@ internal ProjectItem(
                              List<ProjectItemDefinition> inheritedItemDefinitionsCloned
                             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
 
             // Orcas accidentally allowed empty includes if they resulted from expansion: we preserve that bug
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeEscaped, "evaluatedIncludeEscaped");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeBeforeWildcardExpansionEscaped, "evaluatedIncludeBeforeWildcardExpansionEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeEscaped, nameof(evaluatedIncludeEscaped));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeBeforeWildcardExpansionEscaped, nameof(evaluatedIncludeBeforeWildcardExpansionEscaped));
 
             _xml = xml;
             _project = project;
@@ -372,7 +370,7 @@ internal List<ProjectItemDefinition> InheritedItemDefinitions
         /// </summary>
         public ProjectMetadata GetMetadata(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             ProjectMetadata result = null;
 
@@ -433,7 +431,7 @@ public bool HasMetadata(string name)
         /// </summary>
         string IItem.GetMetadataValueEscaped(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             string value = null;
 
@@ -588,7 +586,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
         /// </summary>
         public bool RemoveMetadata(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
             ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
@@ -729,7 +727,7 @@ string IMetadataTable.GetEscapedValueIfPresent(string itemType, string name)
         /// </remarks>
         internal void ChangeItemType(string newItemType)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(newItemType, "ItemType");
+            ErrorUtilities.VerifyThrowArgumentLength(newItemType, nameof(newItemType));
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
             ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
 
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index 87350f18340..00fa7242e6c 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -1,15 +1,14 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
+using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
-using System.Collections.Generic;
-using System;
-using System.Linq;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -53,8 +52,8 @@ public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<Pro
         /// </remarks>
         internal ProjectItemDefinition(Project project, string itemType)
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
 
             _project = project;
             _itemType = itemType;
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index 5bca24c8697..f6bedb43b4d 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
@@ -56,9 +55,9 @@ public class ProjectMetadata : IKeyed, IValued, IEquatable<ProjectMetadata>, IMe
         /// </summary>
         internal ProjectMetadata(IProjectMetadataParent parent, ProjectMetadataElement xml, string evaluatedValueEscaped, ProjectMetadata predecessor)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, "evaluatedValueEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, nameof(evaluatedValueEscaped));
 
             _parent = parent;
             _xml = xml;
@@ -115,7 +114,7 @@ public string UnevaluatedValue
             [DebuggerStepThrough]
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "value");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(value));
                 Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
                 ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null && _xml.Parent.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
 
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 2f2c99a3abc..ac0ba912dc6 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -5,7 +5,6 @@
 using System.Diagnostics;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
@@ -35,8 +34,8 @@ public abstract class ProjectProperty : IKeyed, IValued, IProperty, IEquatable<P
         /// </summary>
         internal ProjectProperty(Project project, string evaluatedValueEscaped)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, "evaluatedValueEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, nameof(evaluatedValueEscaped));
 
             _project = project;
             _evaluatedValueEscaped = evaluatedValueEscaped;
@@ -312,7 +311,7 @@ private class ProjectPropertyXmlBacked : ProjectProperty
             internal ProjectPropertyXmlBacked(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped)
                 : base(project, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+                ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
                 ErrorUtilities.VerifyThrowInvalidOperation(!ProjectHasMatchingGlobalProperty(project, xml.Name), "OM_GlobalProperty", xml.Name);
 
                 _xml = xml;
@@ -457,7 +456,7 @@ private class ProjectPropertyXmlBackedWithPredecessor : ProjectPropertyXmlBacked
             internal ProjectPropertyXmlBackedWithPredecessor(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped, ProjectProperty predecessor)
                 : base(project, xml, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(predecessor, "predecessor");
+                ErrorUtilities.VerifyThrowArgumentNull(predecessor, nameof(predecessor));
 
                 _predecessor = predecessor;
             }
@@ -497,7 +496,7 @@ private class ProjectPropertyNotXmlBacked : ProjectProperty
             internal ProjectPropertyNotXmlBacked(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
                 : base(project, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
                 ErrorUtilities.VerifyThrowInvalidOperation(isGlobalProperty || !ProjectHasMatchingGlobalProperty(project, name), "OM_GlobalProperty", name);
                 ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(name), "OM_ReservedName", name);
                 ErrorUtilities.VerifyThrowArgument(mayBeReserved || !ReservedPropertyNames.IsReservedProperty(name), "OM_ReservedName", name);
diff --git a/src/Build/Definition/ResolvedImport.cs b/src/Build/Definition/ResolvedImport.cs
index 3923d00f84f..92a04ece69a 100644
--- a/src/Build/Definition/ResolvedImport.cs
+++ b/src/Build/Definition/ResolvedImport.cs
@@ -27,7 +27,7 @@ public struct ResolvedImport
         /// </summary>
         internal ResolvedImport(Project project, ProjectImportElement importingElement, ProjectRootElement importedProject, int versionEvaluated, SdkResult sdkResult)
         {
-            ErrorUtilities.VerifyThrowInternalNull(importedProject, "child");
+            ErrorUtilities.VerifyThrowInternalNull(importedProject, nameof(importedProject));
 
             ImportingElement = importingElement;
             ImportedProject = importedProject;
diff --git a/src/Build/Definition/SubToolset.cs b/src/Build/Definition/SubToolset.cs
index 8bfe8ddc9ed..cb9d2e48ae8 100644
--- a/src/Build/Definition/SubToolset.cs
+++ b/src/Build/Definition/SubToolset.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 
@@ -35,7 +34,7 @@ public class SubToolset : INodePacketTranslatable
         /// </summary>
         internal SubToolset(string subToolsetVersion, PropertyDictionary<ProjectPropertyInstance> properties)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, "subToolsetVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, nameof(subToolsetVersion));
 
             _subToolsetVersion = subToolsetVersion;
             _properties = properties;
@@ -94,4 +93,4 @@ internal static SubToolset FactoryForDeserialization(INodePacketTranslator trans
             return subToolset;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 0a8269e5e0a..dfbdc937b8b 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -273,10 +273,10 @@ public Toolset(string toolsVersion, string toolsPath, IDictionary<string, string
         /// <param name="defaultOverrideToolsVersion">ToolsVersion to use as the default ToolsVersion for this version of MSBuild.</param>
         internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, string msbuildOverrideTasksPath, string defaultOverrideToolsVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, "toolsPath");
-            ErrorUtilities.VerifyThrowArgumentNull(environmentProperties, "environmentProperties");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, nameof(toolsPath));
+            ErrorUtilities.VerifyThrowArgumentNull(environmentProperties, nameof(environmentProperties));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
 
             _toolsVersion = toolsVersion;
             this.ToolsPath = toolsPath;
@@ -353,8 +353,8 @@ internal Toolset(
         internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<ProjectPropertyInstance> buildProperties, ProjectCollection projectCollection, DirectoryGetFiles getFiles, LoadXmlFromPath loadXmlFromPath, string msbuildOverrideTasksPath, DirectoryExists directoryExists)
             : this(toolsVersion, toolsPath, buildProperties, projectCollection.EnvironmentProperties, projectCollection.GlobalPropertiesCollection, null, msbuildOverrideTasksPath, null)
         {
-            ErrorUtilities.VerifyThrowInternalNull(getFiles, "getFiles");
-            ErrorUtilities.VerifyThrowInternalNull(loadXmlFromPath, "loadXmlFromPath");
+            ErrorUtilities.VerifyThrowInternalNull(getFiles, nameof(getFiles));
+            ErrorUtilities.VerifyThrowInternalNull(loadXmlFromPath, nameof(loadXmlFromPath));
 
             _directoryExists = directoryExists;
             _getFiles = getFiles;
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 8bc2e15553e..8f523aac2ef 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -61,7 +61,7 @@ internal ToolsetConfigurationReader(PropertyDictionary<ProjectPropertyInstance>
         internal ToolsetConfigurationReader(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, Func<Configuration> readApplicationConfiguration)
             : base(environmentProperties, globalProperties)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(readApplicationConfiguration, "readApplicationConfiguration");
+            ErrorUtilities.VerifyThrowArgumentNull(readApplicationConfiguration, nameof(readApplicationConfiguration));
             _readApplicationConfiguration = readApplicationConfiguration;
             _projectImportSearchPathsCache = new Dictionary<string, Dictionary<string, ProjectImportPathMatch>>(StringComparer.OrdinalIgnoreCase);
         }
@@ -267,4 +267,4 @@ private static Configuration ReadApplicationConfiguration()
             return ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Definition/ToolsetPropertyDefinition.cs b/src/Build/Definition/ToolsetPropertyDefinition.cs
index 5116370d075..2ddc8261465 100644
--- a/src/Build/Definition/ToolsetPropertyDefinition.cs
+++ b/src/Build/Definition/ToolsetPropertyDefinition.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.Diagnostics;
-using System.Text;
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 using Microsoft.Build.Shared;
@@ -40,11 +37,11 @@ internal class ToolsetPropertyDefinition
         /// <param name="source">The property source</param>
         public ToolsetPropertyDefinition(string name, string value, IElementLocation source)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(source, "source");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(source, nameof(source));
 
             // value can be the empty string but not null
-            ErrorUtilities.VerifyThrowArgumentNull(value, "value");
+            ErrorUtilities.VerifyThrowArgumentNull(value, nameof(value));
 
             _name = name;
             _value = value;
@@ -74,7 +71,7 @@ public string Value
 
             set
             {
-                ErrorUtilities.VerifyThrowInternalNull(value, "Value");
+                ErrorUtilities.VerifyThrowInternalNull(value, nameof(Value));
                 _value = value;
             }
         }
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index d546e77d5fb..c5fc7dcd9e2 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -4,7 +4,6 @@
 using System;
 using System.IO;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Linq;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Shared;
@@ -358,7 +357,7 @@ internal string ReadToolsets
             out string defaultOverrideToolsVersion
             )
         {
-            error.VerifyThrowArgumentNull(toolsets, "Toolsets");
+            error.VerifyThrowArgumentNull(toolsets, nameof(toolsets));
 
             ReadEachToolset(toolsets, globalProperties, initialProperties, accumulateProperties);
 
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index d1437e00e62..beef421c6d5 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -3,11 +3,8 @@
 
 #if FEATURE_WIN32_REGISTRY
 
-using Microsoft.Win32;
 using System;
 using System.Collections.Generic;
-using System.IO;
-using System.Security;
 
 using Microsoft.Build.Shared;
 using error = Microsoft.Build.Shared.ErrorUtilities;
@@ -65,7 +62,7 @@ internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> envir
         internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, RegistryKeyWrapper msbuildRegistryWrapper)
             : base(environmentProperties, globalProperties)
         {
-            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, "msbuildRegistryWrapper");
+            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
 
             _msbuildRegistryWrapper = msbuildRegistryWrapper;
         }
@@ -243,7 +240,7 @@ protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion
         /// <returns>An enumeration of property definitions.</returns>
         protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, "subToolsetVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, nameof(subToolsetVersion));
 
             RegistryKeyWrapper toolsVersionWrapper = null;
             RegistryKeyWrapper subToolsetWrapper = null;
@@ -358,4 +355,4 @@ private static string GetValue(RegistryKeyWrapper wrapper, string valueName)
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 22f7a1800ed..d0435b29abb 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using System;
@@ -253,7 +252,7 @@ private class RegularElementLocation : ElementLocation
             /// </summary>
             internal RegularElementLocation(string file, int line, int column)
             {
-                ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(file, "file");
+                ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(file, nameof(file));
                 ErrorUtilities.VerifyThrow(line > -1 && column > -1, "Use zero for unknown");
 
                 this.file = file ?? String.Empty;
@@ -372,4 +371,4 @@ public override int Column
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/ElementLocation/RegistryLocation.cs b/src/Build/ElementLocation/RegistryLocation.cs
index 3c3adfabc5e..b091f8e42d7 100644
--- a/src/Build/ElementLocation/RegistryLocation.cs
+++ b/src/Build/ElementLocation/RegistryLocation.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using System;
 
@@ -29,7 +28,7 @@ internal class RegistryLocation : IElementLocation, INodePacketTranslatable
         /// </summary>
         internal RegistryLocation(string registryPath)
         {
-            ErrorUtilities.VerifyThrowInternalLength(registryPath, "registryPath");
+            ErrorUtilities.VerifyThrowInternalLength(registryPath, nameof(registryPath));
 
             this.registryPath = registryPath;
         }
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 2704ce62392..8d24d3cd5ef 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -2,15 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Xml;
 using System.Runtime.Serialization;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
 
 namespace Microsoft.Build.Exceptions
 {
@@ -186,8 +183,8 @@ internal InvalidProjectFileException
             Exception innerException
         ) : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLength(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLength(message, nameof(message));
 
             // Try to helpfully provide a full path if possible, but do so robustly.
             // This exception might be because the path was invalid!
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 8524dfb9f3a..9f96ee783ff 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -2,13 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
-
-using Microsoft.Build.Shared;
 using System.Runtime.Serialization;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Exceptions
 {
@@ -56,7 +54,7 @@ public InvalidToolsetDefinitionException(string message, Exception innerExceptio
         protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             errorCode = info.GetString("errorCode");
         }
@@ -95,7 +93,7 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             base.GetObjectData(info, context);
 
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 1d9c7b35136..cc43218ff75 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -222,10 +222,10 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             where P : class, IProperty
             where I : class, IItem
         {
-            ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-            ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
-            ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, "evaluationDirectory");
-            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, "buildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
+            ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, nameof(evaluationDirectory));
+            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, nameof(buildEventContext));
 
             // An empty condition is equivalent to a "true" condition.
             if (condition.Length == 0)
@@ -234,7 +234,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             }
 
             // If the condition wasn't empty, there must be a location for it
-            ErrorUtilities.VerifyThrowArgumentNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(elementLocation, nameof(elementLocation));
 
             // Get the expression tree cache for the current parsing options.
             var cachedExpressionTreesForCurrentOptions = s_cachedExpressionTrees.GetOrAdd(
@@ -420,10 +420,10 @@ internal ConditionEvaluationState
                 ProjectRootElementCache projectRootElementCache = null
                 )
             {
-                ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-                ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
-                ErrorUtilities.VerifyThrowArgumentNull(evaluationDirectory, "evaluationDirectory");
-                ErrorUtilities.VerifyThrowArgumentNull(elementLocation, "elementLocation");
+                ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+                ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
+                ErrorUtilities.VerifyThrowArgumentNull(evaluationDirectory, nameof(evaluationDirectory));
+                ErrorUtilities.VerifyThrowArgumentNull(elementLocation, nameof(elementLocation));
 
                 Condition = condition;
                 _expander = expander;
diff --git a/src/Build/Evaluation/Conditionals/Token.cs b/src/Build/Evaluation/Conditionals/Token.cs
index 5887eb2085e..d6fa10f685b 100644
--- a/src/Build/Evaluation/Conditionals/Token.cs
+++ b/src/Build/Evaluation/Conditionals/Token.cs
@@ -81,7 +81,7 @@ internal Token(TokenType type, string tokenString, bool expandable)
                 "Unexpected token type"
                 );
 
-            ErrorUtilities.VerifyThrowInternalNull(tokenString, "tokenString");
+            ErrorUtilities.VerifyThrowInternalNull(tokenString, nameof(tokenString));
 
             _tokenType = type;
             _tokenString = tokenString;
@@ -154,4 +154,4 @@ internal string String
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 01de931c683..4d2001a743e 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -393,7 +393,7 @@ internal static void Evaluate(
         /// </summary>
         internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, "unevaluatedIncludeEscaped");
+            ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, nameof(unevaluatedIncludeEscaped));
 
             List<I> items = new List<I>();
             itemFactory.ItemElement = itemElement;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 91456c8a3c0..2a1a43845fa 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -255,7 +255,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
                 return String.Empty;
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options);
             result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties);
@@ -276,7 +276,7 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
                 return String.Empty;
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string metaExpanded = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options);
             return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _usedUninitializedProperties);
@@ -324,7 +324,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
                 return Array.Empty<T>();
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             expression = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options);
             expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _usedUninitializedProperties);
@@ -398,7 +398,7 @@ internal IList<T> ExpandSingleItemVectorExpressionIntoItems<T>(string expression
                 return Array.Empty<T>();
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             return ItemExpander.ExpandSingleItemVectorExpressionIntoItems(this, expression, _items, itemFactory, options, includeNullItems, out isTransformExpression, elementLocation);
         }
@@ -561,7 +561,7 @@ private static void AddArgument(List<string> arguments, ReuseableStringBuilder a
             // If we don't have something that can be treated as an argument
             // then we should treat it as a null so that passing nulls
             // becomes possible through an empty argument between commas.
-            ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, "argumentBuilder");
+            ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, nameof(argumentBuilder));
 
             // we reached the end of an argument, add the builder's final result
             // to our arguments. 
diff --git a/src/Build/Evaluation/ProjectChangedEventArgs.cs b/src/Build/Evaluation/ProjectChangedEventArgs.cs
index f70ec35ac11..7683617b1bb 100644
--- a/src/Build/Evaluation/ProjectChangedEventArgs.cs
+++ b/src/Build/Evaluation/ProjectChangedEventArgs.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
@@ -20,7 +17,7 @@ public class ProjectChangedEventArgs : EventArgs
         /// <param name="project">The changed project.</param>
         internal ProjectChangedEventArgs(Project project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
 
             Project = project;
         }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 57a5eaa529f..74dbefd4e0d 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -99,8 +99,8 @@ internal class ProjectParser
         /// </summary>
         private ProjectParser(XmlDocumentWithLocation document, ProjectRootElement project)
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowInternalNull(document, "document");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowInternalNull(document, nameof(document));
 
             _document = document;
             _project = project;
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 1c75b279fe0..9c4e8ce0156 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text;
 using System.Xml;
 using Microsoft.Build.Construction;
 
@@ -14,7 +12,6 @@
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 using System.Globalization;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Internal;
 using OutOfProcNode = Microsoft.Build.Execution.OutOfProcNode;
 
@@ -262,7 +259,7 @@ internal ProjectRootElement Get(string projectFile, OpenProjectRootElement openP
                 {
                     projectRootElement = openProjectRootElement(projectFile, this);
 
-                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
+                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, nameof(projectRootElement));
                     ErrorUtilities.VerifyThrow(projectRootElement.FullPath == projectFile, "Got project back with incorrect path");
                     ErrorUtilities.VerifyThrow(_weakCache.Contains(projectFile), "Open should have renamed into cache and boosted");
                 }
@@ -331,7 +328,7 @@ internal void RenameEntry(string oldFullPath, ProjectRootElement projectRootElem
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(oldFullPath, "oldFullPath");
+                ErrorUtilities.VerifyThrowArgumentLength(oldFullPath, nameof(oldFullPath));
                 RenameEntryInternal(oldFullPath, projectRootElement);
             }
         }
@@ -459,7 +456,7 @@ internal void DiscardImplicitReferences()
         /// </remarks>
         internal void DiscardAnyWeakReference(ProjectRootElement projectRootElement)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
 
             // A PRE may be unnamed if it was only used in memory.
             if (projectRootElement.FullPath != null)
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
index 650bfff8442..c49bf2a977b 100644
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ b/src/Build/Evaluation/ProjectStringCache.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using System.Xml;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
@@ -128,7 +127,7 @@ public string Get(string key)
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(key, "key");
+                ErrorUtilities.VerifyThrowArgumentNull(key, nameof(key));
 
                 if (key.Length == 0)
                 {
@@ -155,7 +154,7 @@ public void Clear(XmlDocument document)
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(document, "document");
+                ErrorUtilities.VerifyThrowArgumentNull(document, nameof(document));
 
                 VerifyState();
 
@@ -215,7 +214,7 @@ private void VerifyState()
         /// </remarks>
         private void OnStrongCacheEntryRemoved(object sender, ProjectRootElement projectRootElement)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
             Clear(projectRootElement.XmlDocument);
         }
 
diff --git a/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs b/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
index e16bb5fd0fc..529c07069be 100644
--- a/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
+++ b/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
@@ -32,7 +32,7 @@ public class ProjectXmlChangedEventArgs : EventArgs
         /// <param name="formattingParameter">The formatting parameter to use with <paramref name="unformattedReason"/>.</param>
         internal ProjectXmlChangedEventArgs(ProjectRootElement projectXml, string unformattedReason, string formattingParameter)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectXml, "projectXml");
+            ErrorUtilities.VerifyThrowArgumentNull(projectXml, nameof(projectXml));
 
             this.ProjectXml = projectXml;
             _unformattedReason = unformattedReason;
diff --git a/src/Build/Evaluation/ToolsetProvider.cs b/src/Build/Evaluation/ToolsetProvider.cs
index 1d5f14dc45a..af29f5eb457 100644
--- a/src/Build/Evaluation/ToolsetProvider.cs
+++ b/src/Build/Evaluation/ToolsetProvider.cs
@@ -3,16 +3,12 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd;
 
-using Constants = Microsoft.Build.Internal.Constants;
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -72,7 +68,7 @@ public ICollection<Toolset> Toolsets
         /// </summary>
         public Toolset GetToolset(string toolsVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
 
             Toolset toolset;
             _toolsets.TryGetValue(toolsVersion, out toolset);
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index f131604d876..ed12001a89e 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Framework;
 using System.Collections.Generic;
 using System;
-using System.Collections;
 using System.Diagnostics;
 
 namespace Microsoft.Build.Execution
@@ -59,9 +58,9 @@ public class HostServices
         /// </summary>
         public ITaskHost GetHostObject(string projectFile, string targetName, string taskName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
 
             HostObjects hostObjects;
             if (_hostObjectMap == null || !_hostObjectMap.TryGetValue(projectFile, out hostObjects))
@@ -80,9 +79,9 @@ public ITaskHost GetHostObject(string projectFile, string targetName, string tas
         /// </summary>
         public void RegisterHostObject(string projectFile, string targetName, string taskName, ITaskHost hostObject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
 
             // We can only set the host object to a non-null value if the affinity for the project is not out of proc, or if it is, it is only implicitly 
             // out of proc, in which case it will become in-proc after this call completes.  See GetNodeAffinity.
@@ -319,4 +318,4 @@ public bool Equals(TargetTaskKey other)
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index b737912f8cb..410eb3f3310 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -8,7 +8,6 @@
 using System.Globalization;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
-using Evaluation = Microsoft.Build.Evaluation;
 using ObjectModel = System.Collections.ObjectModel;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
@@ -17,7 +16,6 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Internal;
 
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
 using System.Xml;
@@ -33,6 +31,7 @@
 namespace Microsoft.Build.Execution
 {
     using Utilities = Microsoft.Build.Internal.Utilities;
+
     /// <summary>
     /// Enum for controlling project instance creation
     /// </summary>
@@ -239,8 +238,8 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <returns>A new project instance</returns>
         public ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
 
             // We do not control the current directory at this point, but assume that if we were
             // passed a relative path, the caller assumes we will prepend the current directory.
@@ -374,9 +373,9 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// </summary>
         internal ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, ProjectLoadSettings? projectLoadSettings)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
 
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, false /*Not explicitly loaded*/);
 
@@ -390,9 +389,9 @@ internal ProjectInstance(string projectFile, IDictionary<string, string> globalP
         /// </summary>
         internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
             Initialize(xml, globalProperties, toolsVersion, null, 0 /* no solution version specified */, buildParameters, loggingService, buildEventContext, sdkResolverService, submissionId);
         }
 
@@ -402,9 +401,9 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// </summary>
         internal ProjectInstance(Evaluation.Project.Data data, string directory, string fullPath, HostServices hostServices, PropertyDictionary<ProjectPropertyInstance> environmentVariableProperties, ProjectInstanceSettings settings)
         {
-            ErrorUtilities.VerifyThrowInternalNull(data, "data");
-            ErrorUtilities.VerifyThrowInternalLength(directory, "directory");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(fullPath, "fullPath");
+            ErrorUtilities.VerifyThrowInternalNull(data, nameof(data));
+            ErrorUtilities.VerifyThrowInternalLength(directory, nameof(directory));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(fullPath, nameof(fullPath));
 
             _directory = directory;
             _projectFileLocation = ElementLocation.Create(fullPath);
@@ -1142,7 +1141,7 @@ internal ProjectRootElementCache ProjectRootElementCache
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).EvaluatedIncludeEscaped;
         }
@@ -1152,7 +1151,7 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item)
         /// </summary>
         public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinitionInstance item)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).EvaluatedIncludeEscaped;
         }
@@ -1162,7 +1161,7 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinitionInstanc
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(metadatum, "metadatum");
+            ErrorUtilities.VerifyThrowArgumentNull(metadatum, nameof(metadatum));
 
             return metadatum.EvaluatedValueEscaped;
         }
@@ -1173,7 +1172,7 @@ public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum)
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetMetadataValueEscaped(ProjectItemInstance item, string name)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).GetMetadataValueEscaped(name);
         }
@@ -1183,7 +1182,7 @@ public static string GetMetadataValueEscaped(ProjectItemInstance item, string na
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item, string name)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).GetMetadataValueEscaped(name);
         }
@@ -1194,7 +1193,7 @@ public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item,
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IProperty is an internal interface; this is less confusing to outside customers. ")]
         public static string GetPropertyValueEscaped(ProjectPropertyInstance property)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             return ((IProperty)property).EvaluatedValueEscaped;
         }
@@ -2005,10 +2004,10 @@ private void TranslateItems(INodePacketTranslator translator)
         /// </summary>
         internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, PropertyDictionary<ProjectPropertyInstance> globalPropertiesInstances, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, IReadOnlyCollection<string> targetNames, ISdkResolverService sdkResolverService, int submissionId)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(globalPropertiesInstances, "globalPropertiesInstances");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(globalPropertiesInstances, nameof(globalPropertiesInstances));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
             ErrorUtilities.VerifyThrow(FileUtilities.IsSolutionFilename(projectFile), "Project file {0} is not a solution.", projectFile);
 
             ProjectInstance[] projectInstances = null;
@@ -2247,7 +2246,7 @@ internal ProjectTargetInstance AddTarget(string targetName, string condition, st
         {
             VerifyThrowNotImmutable();
 
-            ErrorUtilities.VerifyThrowInternalLength(targetName, "targetName");
+            ErrorUtilities.VerifyThrowInternalLength(targetName, nameof(targetName));
             ErrorUtilities.VerifyThrow(!_actualTargets.ContainsKey(targetName), "Target {0} already exists.", targetName);
 
             ProjectTargetInstance target = new ProjectTargetInstance
@@ -2490,9 +2489,9 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
         /// </summary>
         private void Initialize(ProjectRootElement xml, IDictionary<string, string> globalProperties, string explicitToolsVersion, string explicitSubToolsetVersion, int visualStudioVersionFromSolution, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService = null, int submissionId = BuildEventContext.InvalidSubmissionId, ProjectLoadSettings? projectLoadSettings = null)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(explicitToolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(explicitToolsVersion, nameof(explicitToolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
 
             _directory = xml.DirectoryPath;
             _projectFileLocation = (xml.ProjectFileLocation != null) ? xml.ProjectFileLocation : ElementLocation.EmptyLocation;
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index d8814626c05..db53364b9db 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using System;
@@ -40,7 +39,7 @@ public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefini
         /// <param name="itemType">The type of item this definition object represents.</param>
         internal ProjectItemDefinitionInstance(ProjectInstance projectInstance, string itemType)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(itemType, "itemType");
+            ErrorUtilities.VerifyThrowArgumentNull(itemType, nameof(itemType));
 
             _itemType = itemType;
         }
diff --git a/src/Build/Instance/ProjectItemGroupTaskInstance.cs b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
index 1295fb3ac9c..d23bc435b1a 100644
--- a/src/Build/Instance/ProjectItemGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
@@ -1,15 +1,12 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
-
 using Microsoft.Build.Construction;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
 {
@@ -53,9 +50,9 @@ internal ProjectItemGroupTaskInstance
             List<ProjectItemGroupTaskItemInstance> items
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(items, "items");
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(items, nameof(items));
 
             _condition = condition;
             _location = location;
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index 1814469a59f..f50d6939559 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -1,15 +1,12 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
-
 using Microsoft.Build.Construction;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
 {
@@ -138,15 +135,15 @@ internal ProjectItemGroupTaskItemInstance
             List<ProjectItemGroupTaskMetadataInstance> metadata
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(itemType, "itemType");
-            ErrorUtilities.VerifyThrowInternalNull(include, "include");
-            ErrorUtilities.VerifyThrowInternalNull(exclude, "exclude");
-            ErrorUtilities.VerifyThrowInternalNull(remove, "remove");
-            ErrorUtilities.VerifyThrowInternalNull(keepMetadata, "keepMetadata");
-            ErrorUtilities.VerifyThrowInternalNull(removeMetadata, "removeMetadata");
-            ErrorUtilities.VerifyThrowInternalNull(keepDuplicates, "keepDuplicates");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowInternalNull(include, nameof(include));
+            ErrorUtilities.VerifyThrowInternalNull(exclude, nameof(exclude));
+            ErrorUtilities.VerifyThrowInternalNull(remove, nameof(remove));
+            ErrorUtilities.VerifyThrowInternalNull(keepMetadata, nameof(keepMetadata));
+            ErrorUtilities.VerifyThrowInternalNull(removeMetadata, nameof(removeMetadata));
+            ErrorUtilities.VerifyThrowInternalNull(keepDuplicates, nameof(keepDuplicates));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _itemType = itemType;
             _include = include;
diff --git a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
index 65a9bbb6532..8931421a1a0 100644
--- a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
@@ -1,15 +1,10 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
-
 using Microsoft.Build.Construction;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
 {
@@ -50,10 +45,10 @@ public class ProjectItemGroupTaskMetadataInstance : INodePacketTranslatable
         /// </summary>
         internal ProjectItemGroupTaskMetadataInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalNull(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(value, "value");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(value, nameof(value));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _name = name;
             _value = value;
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 19e2b03ead2..5142bd5be43 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using System.Linq;
 using System.IO;
 
@@ -184,7 +183,7 @@ public string EvaluatedInclude
             [DebuggerStepThrough]
             set
             {
-                ErrorUtilities.VerifyThrowArgumentLength(value, "EvaluatedInclude");
+                ErrorUtilities.VerifyThrowArgumentLength(value, nameof(EvaluatedInclude));
                 _project.VerifyThrowNotImmutable();
 
                 _taskItem.ItemSpec = value;
@@ -687,8 +686,8 @@ internal ProjectItemElement ToProjectItemElement(ProjectElementContainer parent)
         /// </summary>
         private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUse, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectToUse, "project");
-            ErrorUtilities.VerifyThrowArgumentLength(itemTypeToUse, "itemType");
+            ErrorUtilities.VerifyThrowArgumentNull(projectToUse, nameof(projectToUse));
+            ErrorUtilities.VerifyThrowArgumentLength(itemTypeToUse, nameof(itemTypeToUse));
             XmlUtilities.VerifyThrowArgumentValidElementName(itemTypeToUse);
             ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(itemTypeToUse), "OM_ReservedName", itemTypeToUse);
 
@@ -801,8 +800,8 @@ internal TaskItem(
                               string definingFileEscaped // the actual project file (or import) that defines this item.
                               )
             {
-                ErrorUtilities.VerifyThrowArgumentLength(includeEscaped, "includeEscaped");
-                ErrorUtilities.VerifyThrowArgumentLength(includeBeforeWildcardExpansionEscaped, "includeBeforeWildcardExpansionEscaped");
+                ErrorUtilities.VerifyThrowArgumentLength(includeEscaped, nameof(includeEscaped));
+                ErrorUtilities.VerifyThrowArgumentLength(includeBeforeWildcardExpansionEscaped, nameof(includeBeforeWildcardExpansionEscaped));
 
                 _includeEscaped = FileUtilities.FixFilePath(includeEscaped);
                 _includeBeforeWildcardExpansionEscaped = FileUtilities.FixFilePath(includeBeforeWildcardExpansionEscaped);
@@ -878,7 +877,7 @@ public string ItemSpec
                     ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
                     // Historically empty string was allowed
-                    ErrorUtilities.VerifyThrowArgumentNull(value, "ItemSpec");
+                    ErrorUtilities.VerifyThrowArgumentNull(value, nameof(ItemSpec));
 
                     _includeEscaped = value;
                     _fullPath = null; // Clear cached value
@@ -1022,7 +1021,7 @@ internal string IncludeEscaped
                 {
                     ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
-                    ErrorUtilities.VerifyThrowArgumentLength(value, "IncludeEscaped");
+                    ErrorUtilities.VerifyThrowArgumentLength(value, nameof(IncludeEscaped));
                     _includeEscaped = value;
                     _fullPath = null; // Clear cached value
                 }
@@ -1223,7 +1222,7 @@ public string GetMetadataEscaped(string metadataName)
             {
                 if (metadataName == null || metadataName.Length == 0)
                 {
-                    ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
+                    ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
                 }
 
                 string value = null;
@@ -1322,7 +1321,7 @@ public void CopyMetadataTo(ITaskItem destinationItem)
             /// </param>
             public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
                 string originalItemSpec = null;
                 if (addOriginalItemSpec)
@@ -1783,7 +1782,7 @@ internal ProjectItemInstanceFactory(ProjectInstance project)
                 internal ProjectItemInstanceFactory(ProjectInstance project, string itemType)
                     : this(project)
                 {
-                    ErrorUtilities.VerifyThrowInternalLength(itemType, "itemType");
+                    ErrorUtilities.VerifyThrowInternalLength(itemType, nameof(itemType));
                     this.ItemType = itemType;
                 }
 
@@ -1813,7 +1812,7 @@ public ProjectItemElement ItemElement
                 /// <returns>A new instance item.</returns>
                 public ProjectItemInstance CreateItem(string include, string definingProject)
                 {
-                    ErrorUtilities.VerifyThrowInternalLength(ItemType, "ItemType");
+                    ErrorUtilities.VerifyThrowInternalLength(ItemType, nameof(ItemType));
 
                     ProjectItemInstance item = new ProjectItemInstance(_project, ItemType, include, definingProject);
 
@@ -1846,7 +1845,7 @@ public ProjectItemInstance CreateItem(string includeEscaped, ProjectItemInstance
                 /// </summary>
                 public ProjectItemInstance CreateItem(string evaluatedInclude, string evaluatedIncludeBeforeWildcardExpansion, string definingProject)
                 {
-                    ErrorUtilities.VerifyThrowInternalLength(ItemType, "ItemType");
+                    ErrorUtilities.VerifyThrowInternalLength(ItemType, nameof(ItemType));
 
                     return new ProjectItemInstance(_project, ItemType, evaluatedInclude, evaluatedIncludeBeforeWildcardExpansion, definingProject);
                 }
@@ -1874,8 +1873,8 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
                 /// </summary>
                 private ProjectItemInstance CreateItem(string includeEscaped, string includeBeforeWildcardExpansionEscaped, ProjectItemInstance source, string definingProject)
                 {
-                    ErrorUtilities.VerifyThrowInternalLength(ItemType, "ItemType");
-                    ErrorUtilities.VerifyThrowInternalNull(source, "source");
+                    ErrorUtilities.VerifyThrowInternalLength(ItemType, nameof(ItemType));
+                    ErrorUtilities.VerifyThrowInternalNull(source, nameof(source));
 
                     // The new item inherits any metadata originating in item definitions, which
                     // takes precedence over its own item definition metadata.
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index ee5308dc08d..cb898e10140 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -6,8 +6,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Construction;
 using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.Execution
@@ -61,7 +59,7 @@ internal ProjectMetadataInstance(string name, string escapedValue)
         /// </remarks>
         internal ProjectMetadataInstance(string name, string escapedValue, bool allowItemSpecModifiers)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             if (allowItemSpecModifiers)
             {
diff --git a/src/Build/Instance/ProjectOnErrorInstance.cs b/src/Build/Instance/ProjectOnErrorInstance.cs
index d83062aabfd..d2a738f70cb 100644
--- a/src/Build/Instance/ProjectOnErrorInstance.cs
+++ b/src/Build/Instance/ProjectOnErrorInstance.cs
@@ -56,9 +56,9 @@ internal ProjectOnErrorInstance
             ElementLocation conditionLocation
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(executeTargets, "executeTargets");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalLength(executeTargets, nameof(executeTargets));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _executeTargets = executeTargets;
             _condition = condition;
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
index c0c29d8da14..49ec97edb1e 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
@@ -1,15 +1,12 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
-
 using Microsoft.Build.Construction;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
 {
@@ -53,9 +50,9 @@ internal ProjectPropertyGroupTaskInstance
             List<ProjectPropertyGroupTaskPropertyInstance> properties
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(properties, "properties");
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(properties, nameof(properties));
 
             _condition = condition;
             _location = location;
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index c7a9791566d..4d001740957 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -1,15 +1,10 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
-
 using Microsoft.Build.Construction;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
 {
@@ -50,10 +45,10 @@ public class ProjectPropertyGroupTaskPropertyInstance : INodePacketTranslatable
         /// </summary>
         internal ProjectPropertyGroupTaskPropertyInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalNull(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(value, "value");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(value, nameof(value));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _name = name;
             _value = value;
diff --git a/src/Build/Instance/ProjectTargetInstance.cs b/src/Build/Instance/ProjectTargetInstance.cs
index 8d5142cd846..2b61f585d2f 100644
--- a/src/Build/Instance/ProjectTargetInstance.cs
+++ b/src/Build/Instance/ProjectTargetInstance.cs
@@ -150,15 +150,15 @@ internal ProjectTargetInstance
             bool parentProjectSupportsReturnsAttribute
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(inputs, "inputs");
-            ErrorUtilities.VerifyThrowInternalNull(outputs, "outputs");
-            ErrorUtilities.VerifyThrowInternalNull(keepDuplicateOutputs, "keepDuplicateOutputs");
-            ErrorUtilities.VerifyThrowInternalNull(dependsOnTargets, "dependsOnTargets");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(children, "children");
-            ErrorUtilities.VerifyThrowInternalNull(onErrorChildren, "onErrorChildren");
+            ErrorUtilities.VerifyThrowInternalLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(inputs, nameof(inputs));
+            ErrorUtilities.VerifyThrowInternalNull(outputs, nameof(outputs));
+            ErrorUtilities.VerifyThrowInternalNull(keepDuplicateOutputs, nameof(keepDuplicateOutputs));
+            ErrorUtilities.VerifyThrowInternalNull(dependsOnTargets, nameof(dependsOnTargets));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(children, nameof(children));
+            ErrorUtilities.VerifyThrowInternalNull(onErrorChildren, nameof(onErrorChildren));
 
             _name = name;
             _condition = condition;
@@ -505,7 +505,7 @@ internal ProjectTaskInstance AddTask(string taskName, string condition, string c
         /// <returns>The new task instance.</returns>
         internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture)
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
             ProjectTaskInstance task = new ProjectTaskInstance(taskName, _location, condition ?? String.Empty, continueOnError ?? String.Empty, msbuildRuntime ?? String.Empty, msbuildArchitecture ?? String.Empty);
             this.AddProjectTargetInstanceChild(task);
             return task;
diff --git a/src/Build/Instance/ProjectTaskInstance.cs b/src/Build/Instance/ProjectTaskInstance.cs
index 9ae88579921..55ec975feb5 100644
--- a/src/Build/Instance/ProjectTaskInstance.cs
+++ b/src/Build/Instance/ProjectTaskInstance.cs
@@ -98,8 +98,8 @@ internal ProjectTaskInstance
             IList<ProjectTaskInstanceChild> outputs
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(element, "element");
-            ErrorUtilities.VerifyThrowInternalNull(outputs, "outputs");
+            ErrorUtilities.VerifyThrowInternalNull(element, nameof(element));
+            ErrorUtilities.VerifyThrowInternalNull(outputs, nameof(outputs));
 
             // These are all immutable
             _name = element.Name;
@@ -163,9 +163,9 @@ internal ProjectTaskInstance
             ElementLocation msbuildRuntimeLocation,
             ElementLocation msbuildArchitectureLocation)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-            ErrorUtilities.VerifyThrowArgumentNull(continueOnError, "continueOnError");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowArgumentNull(continueOnError, nameof(continueOnError));
 
             _name = name;
             _condition = condition;
@@ -340,8 +340,8 @@ internal void SetParameter(string parameterName, string unevaluatedValue)
         /// <param name="condition">The condition.</param>
         internal void AddOutputItem(string taskOutputParameterName, string itemName, string condition)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, "taskOutputParameterName");
-            ErrorUtilities.VerifyThrowArgumentLength(itemName, "itemName");
+            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, nameof(taskOutputParameterName));
+            ErrorUtilities.VerifyThrowArgumentLength(itemName, nameof(itemName));
             _outputs.Add(new ProjectTaskOutputItemInstance(itemName, taskOutputParameterName, condition ?? String.Empty, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, condition == null ? null : ElementLocation.EmptyLocation));
         }
 
@@ -353,8 +353,8 @@ internal void AddOutputItem(string taskOutputParameterName, string itemName, str
         /// <param name="condition">The condition.</param>
         internal void AddOutputProperty(string taskOutputParameterName, string propertyName, string condition)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, "taskOutputParameterName");
-            ErrorUtilities.VerifyThrowArgumentLength(propertyName, "propertyName");
+            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, nameof(taskOutputParameterName));
+            ErrorUtilities.VerifyThrowArgumentLength(propertyName, nameof(propertyName));
             _outputs.Add(new ProjectTaskOutputPropertyInstance(propertyName, taskOutputParameterName, condition ?? String.Empty, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, condition == null ? null : ElementLocation.EmptyLocation));
         }
 
diff --git a/src/Build/Instance/ProjectTaskOutputItemInstance.cs b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
index aeae6f06805..ed75ebfac2f 100644
--- a/src/Build/Instance/ProjectTaskOutputItemInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
@@ -1,12 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-
 using Microsoft.Build.Construction;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
 {
@@ -58,11 +55,11 @@ public sealed class ProjectTaskOutputItemInstance : ProjectTaskInstanceChild, IN
         /// </summary>
         internal ProjectTaskOutputItemInstance(string itemType, string taskParameter, string condition, ElementLocation location, ElementLocation itemTypeLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalLength(itemType, "itemType");
-            ErrorUtilities.VerifyThrowInternalLength(taskParameter, "taskParameter");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(itemTypeLocation, "itemTypeLocation");
-            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, "taskParameterLocation");
+            ErrorUtilities.VerifyThrowInternalLength(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowInternalLength(taskParameter, nameof(taskParameter));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(itemTypeLocation, nameof(itemTypeLocation));
+            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, nameof(taskParameterLocation));
 
             _itemType = itemType;
             _taskParameter = taskParameter;
diff --git a/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs b/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
index ee076eea82c..f3dcaac4964 100644
--- a/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
@@ -55,11 +55,11 @@ public sealed class ProjectTaskOutputPropertyInstance : ProjectTaskInstanceChild
         /// </summary>
         internal ProjectTaskOutputPropertyInstance(string propertyName, string taskParameter, string condition, ElementLocation location, ElementLocation propertyNameLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalLength(propertyName, "propertyName");
-            ErrorUtilities.VerifyThrowInternalLength(taskParameter, "taskParameter");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(propertyNameLocation, "propertyNameLocation");
-            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, "taskParameterLocation");
+            ErrorUtilities.VerifyThrowInternalLength(propertyName, nameof(propertyName));
+            ErrorUtilities.VerifyThrowInternalLength(taskParameter, nameof(taskParameter));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(propertyNameLocation, nameof(propertyNameLocation));
+            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, nameof(taskParameterLocation));
 
             _propertyName = propertyName;
             _taskParameter = taskParameter;
diff --git a/src/Build/Instance/ReflectableTaskPropertyInfo.cs b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
index 81c601c1fd5..93e9594b6ed 100644
--- a/src/Build/Instance/ReflectableTaskPropertyInfo.cs
+++ b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -34,7 +32,7 @@ internal class ReflectableTaskPropertyInfo : TaskPropertyInfo
         internal ReflectableTaskPropertyInfo(TaskPropertyInfo taskPropertyInfo, Type taskType)
             : base(taskPropertyInfo.Name, taskPropertyInfo.PropertyType, taskPropertyInfo.Output, taskPropertyInfo.Required)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskType, "taskType");
+            ErrorUtilities.VerifyThrowArgumentNull(taskType, nameof(taskType));
             _taskType = taskType;
         }
 
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index e9960ce22a2..e7be9d672c8 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -205,7 +205,7 @@ public ITask CreateTask(IBuildEngine taskFactoryLoggingHost, IDictionary<string,
         /// </remarks>
         public void CleanupTask(ITask task)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
 #if FEATURE_APPDOMAIN
             AppDomain appDomain;
             if (_tasksAndAppDomains.TryGetValue(task, out appDomain))
@@ -261,7 +261,7 @@ internal LoadedType InitializeFactory
                 string taskProjectFile
             )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+            ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
             VerifyThrowIdentityParametersValid(taskFactoryIdentityParameters, elementLocation, taskName, "Runtime", "Architecture");
 
             if (taskFactoryIdentityParameters != null)
@@ -273,7 +273,7 @@ string taskProjectFile
 
             try
             {
-                ErrorUtilities.VerifyThrowArgumentLength(taskName, "taskName");
+                ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
                 _taskName = taskName;
                 _loadedType = _typeLoader.Load(taskName, loadInfo);
                 ProjectErrorUtilities.VerifyThrowInvalidProject(_loadedType != null, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, String.Empty);
@@ -351,7 +351,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 
             if (useTaskFactory)
             {
-                ErrorUtilities.VerifyThrowInternalNull(buildComponentHost, "buildComponentHost");
+                ErrorUtilities.VerifyThrowInternalNull(buildComponentHost, nameof(buildComponentHost));
 
                 mergedParameters = mergedParameters ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
@@ -417,7 +417,7 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
             LoadedType taskClass = null;
             try
             {
-                ErrorUtilities.VerifyThrowArgumentLength(taskName, "TaskName");
+                ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
                 taskClass = _typeLoader.ReflectionOnlyLoad(taskName, _loadedType.Assembly);
                 if (taskClass != null)
                 {
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index ba03a89a876..5d8f4162a09 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -5,13 +5,10 @@
 using System.Collections.Generic;
 using System.Collections.Concurrent;
 using System.Diagnostics;
-using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Text;
 
 using Microsoft.Build.Exceptions;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -131,7 +128,7 @@ public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggin
 #endif
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(taskType, "taskType");
+            ErrorUtilities.VerifyThrowInternalNull(taskType, nameof(taskType));
 
             _taskLocation = taskLocation;
             _taskLoggingContext = taskLoggingContext;
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 62d541b85d1..bcb45923a8d 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -58,8 +58,8 @@ internal class TaskFactoryLoggingHost :
         /// </summary>
         public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation elementLocation, BuildLoggingContext loggingContext)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "loggingContext");
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             _activeProxy = true;
             _isRunningWithMultipleNodes = isRunningWithMultipleNodes;
@@ -152,7 +152,7 @@ internal BuildLoggingContext LoggingContext
         /// <param name="e">The event args</param>
         public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -173,7 +173,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         /// <param name="e">The event args</param>
         public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -194,7 +194,7 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         /// <param name="e">The event args</param>
         public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -215,7 +215,7 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         /// <param name="e">The event args</param>
         public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index 95973e21d2e..f7e59a6343d 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -62,8 +62,8 @@ internal sealed class TaskFactoryWrapper
         /// </summary>
         internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoadInfo, string taskName, IDictionary<string, string> factoryIdentityParameters)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskFactory, "taskFactory");
-            ErrorUtilities.VerifyThrowArgumentLength(taskName, "taskName");
+            ErrorUtilities.VerifyThrowArgumentNull(taskFactory, nameof(taskFactory));
+            ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
             _taskFactory = taskFactory;
             _taskName = taskName;
             TaskFactoryLoadedType = taskFactoryLoadInfo;
@@ -182,8 +182,8 @@ public TaskPropertyInfo GetProperty(string propertyName)
         /// </summary>
         internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object value)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             IGeneratedTask generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
@@ -202,8 +202,8 @@ internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object val
         /// </summary>
         internal object GetPropertyValue(ITask task, TaskPropertyInfo property)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             IGeneratedTask generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 2f7160c2a29..3955e4aab67 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Diagnostics;
 using System.Collections.Generic;
 using System.IO;
@@ -154,7 +153,7 @@ internal sealed class TaskRegistry : INodePacketTranslatable
         /// </summary>
         internal TaskRegistry(ProjectRootElementCache projectRootElementCache)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, "projectRootElementCache");
+            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
 
             RootElementCache = projectRootElementCache;
         }
@@ -174,8 +173,8 @@ private TaskRegistry()
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         internal TaskRegistry(Toolset toolset, ProjectRootElementCache projectRootElementCache)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, "projectRootElementCache");
-            ErrorUtilities.VerifyThrowInternalNull(toolset, "toolset");
+            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
+            ErrorUtilities.VerifyThrowInternalNull(toolset, nameof(toolset));
 
             RootElementCache = projectRootElementCache;
             _toolset = toolset;
@@ -229,7 +228,7 @@ IFileSystem fileSystem
             where P : class, IProperty
             where I : class, IItem
         {
-            ErrorUtilities.VerifyThrowInternalNull(directoryOfImportingFile, "directoryOfImportingFile");
+            ErrorUtilities.VerifyThrowInternalNull(directoryOfImportingFile, nameof(directoryOfImportingFile));
 
             if (!ConditionEvaluator.EvaluateCondition
                 (
@@ -640,8 +639,8 @@ private Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> GetReleva
         /// </summary>
         private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord)
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
-            ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo, "assemblyLoadInfo");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo, nameof(assemblyLoadInfo));
 
             // Lazily allocate the hashtable
             if (_taskRegistrations == null)
@@ -1079,7 +1078,7 @@ internal class RegisteredTaskRecord : INodePacketTranslatable
             /// </summary>
             internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, ParameterGroupAndTaskElementRecord inlineTask)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(assemblyLoadInfo, "AssemblyLoadInfo");
+                ErrorUtilities.VerifyThrowArgumentNull(assemblyLoadInfo, nameof(assemblyLoadInfo));
                 _registeredName = registeredName;
                 _taskFactoryAssemblyLoadInfo = assemblyLoadInfo;
                 _taskFactoryParameters = taskFactoryParameters;
@@ -1544,8 +1543,8 @@ internal void ExpandUsingTask<P, I>(ProjectUsingTaskElement projectUsingTaskXml,
                     where P : class, IProperty
                     where I : class, IItem
                 {
-                    ErrorUtilities.VerifyThrowArgumentNull(projectUsingTaskXml, "projectUsingTaskXml");
-                    ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
+                    ErrorUtilities.VerifyThrowArgumentNull(projectUsingTaskXml, nameof(projectUsingTaskXml));
+                    ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
 
                     ProjectUsingTaskBodyElement taskElement = projectUsingTaskXml.TaskBody;
                     if (taskElement != null)
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index a9ab1bded67..9eaa919ffe3 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -958,7 +958,7 @@ public virtual void Initialize(IEventSource eventSource)
         /// </summary>
         internal virtual bool ApplyParameter(string parameterName, string parameterValue)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             switch (parameterName.ToUpperInvariant())
             {
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index d19eb478dbd..ae5d2c2ffd7 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Text;
 using System.Collections.Generic;
 
 using Microsoft.Build.Framework;
@@ -131,7 +129,7 @@ private void ParseParameters()
         /// </summary>
         private void ApplyParameter(string parameterName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             if (_forwardingTable.ContainsKey(parameterName))
             {
@@ -160,7 +158,7 @@ private void ApplyParameter(string parameterName)
         /// </summary>
         public virtual void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
 
             ParseParameters();
 
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index ad2e52cad1c..fe0c82bb8a1 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Text;
 using System.IO;
 
 using Microsoft.Build.Framework;
@@ -96,7 +94,7 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
         /// </summary>
         public void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             ParseFileLoggerParameters();
             string fileName = _logFile;
             try
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 2bfa385652d..0bfb9e59218 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -48,7 +48,7 @@ public FileLogger()
         /// <param name="eventSource">Available events.</param>
         public override void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             eventSource.BuildFinished += FileLoggerBuildFinished;
             InitializeFileLogger(eventSource, 1);
         }
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 6bb67875599..2fc0e108553 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -4,11 +4,8 @@
 using System;
 using System.Text;
 using System.Collections;
-using System.Diagnostics;
 using System.Globalization;
-using System.IO;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -488,7 +485,7 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
         /// <param name="e">event arguments</param>
         public override void ProjectStartedHandler(object sender, ProjectStartedEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
             ErrorUtilities.VerifyThrowArgumentNull(e.ParentProjectBuildEventContext, "ParentProjectBuildEventContext");
 
             // Add the project to the BuildManager so we can use the start information later in the build process
@@ -544,10 +541,9 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
         /// <param name="e">event arguments</param>
         public override void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
 
-
-            //Get the project started event so we can use its information to properly display a project finished event
+            // Get the project started event so we can use its information to properly display a project finished event
             ProjectStartedEventMinimumFields startedEvent = _buildEventManager.GetProjectStartedEvent(e.BuildEventContext);
             ErrorUtilities.VerifyThrow(startedEvent != null, "Project finished event for {0} received without matching start event", e.ProjectFile);
 
@@ -740,7 +736,7 @@ internal override void OutputItems(string itemType, ArrayList itemTypeList)
         /// <param name="e">event arguments</param>
         public override void TargetStartedHandler(object sender, TargetStartedEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
 
             // Add the target started information to the buildEventManager so its information can be used
             // later in the build
@@ -762,7 +758,7 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
         /// <param name="e">event arguments</param>
         public override void TargetFinishedHandler(object sender, TargetFinishedEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
 
             if (this.showPerfSummary)
             {
@@ -834,7 +830,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
         /// <param name="e">event arguments</param>
         public override void TaskStartedHandler(object sender, TaskStartedEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
 
             // if verbosity is detailed or diagnostic
 
@@ -875,7 +871,7 @@ public override void TaskStartedHandler(object sender, TaskStartedEventArgs e)
         /// <param name="e">event arguments</param>
         public override void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
             if (this.showPerfSummary)
             {
                 // Stop the task performance counter which was started in the task started event
@@ -909,7 +905,7 @@ public override void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         /// </summary>
         public override void ErrorHandler(object sender, BuildErrorEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
             // Keep track of the number of error events raised 
             errorCount++;
 
@@ -955,7 +951,7 @@ public override void ErrorHandler(object sender, BuildErrorEventArgs e)
         /// </summary>
         public override void WarningHandler(object sender, BuildWarningEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
             // Keep track of the number of warning events raised during the build
             warningCount++;
 
@@ -1005,7 +1001,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
         {
             if (showOnlyErrors || showOnlyWarnings) return;
 
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
             bool print = false;
             bool lightenText = false;
 
@@ -1471,7 +1467,7 @@ public override void CustomEventHandler(object sender, CustomBuildEventArgs e)
         {
             if (showOnlyErrors || showOnlyWarnings) return;
 
-            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, nameof(BuildEventContext));
             if (IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
                 // ignore custom events with null messages -- some other
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index d56b0fa05b5..349f28adc89 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
 using Microsoft.Build.Shared;
@@ -143,7 +142,7 @@ private string[] GetFileList
             IEnumerable<string> excludeSpecsEscaped = null
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, "filespecEscaped");
+            ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
             if (excludeSpecsEscaped == null)
             {
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index d511fc96588..5983221f50e 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -3,10 +3,6 @@
 #if FEATURE_WIN32_REGISTRY
 
 using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Security;
 
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
@@ -67,8 +63,8 @@ internal RegistryKeyWrapper(string registryKeyPath, RegistryHive registryHive, R
         /// </summary>
         internal RegistryKeyWrapper(string registryKeyPath, RegistryKey registryHive)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, "registryKeyPath");
-            ErrorUtilities.VerifyThrowArgumentNull(registryHive, "registryHive");
+            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, nameof(registryKeyPath));
+            ErrorUtilities.VerifyThrowArgumentNull(registryHive, nameof(registryHive));
 
             _registryKeyPath = registryKeyPath;
             _registryHive = registryHive;
@@ -173,7 +169,7 @@ public virtual string[] GetSubKeyNames()
         /// <returns></returns>
         public virtual RegistryKeyWrapper OpenSubKey(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             RegistryKeyWrapper wrapper = this;
             string[] keyNames = name.Split(new char[] { '\\' }, StringSplitOptions.RemoveEmptyEntries);
@@ -271,4 +267,4 @@ private void Dispose(bool disposing)
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index 36004feb9c8..cb96cd77215 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.Runtime.Serialization;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
@@ -58,7 +57,7 @@ StreamingContext context
             base(info, context)
 
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             commandLineArg = info.GetString("commandLineArg");
         }
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index af55f308013..15203a2720f 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
-using System.Globalization;
 using System.Runtime.Serialization;
 
 #if FEATURE_SECURITY_PERMISSIONS
@@ -69,9 +67,8 @@ private InitializationException
             StreamingContext context
         ) :
             base(info, context)
-
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             invalidSwitch = info.GetString("invalidSwitch");
         }
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index 44d941972df..53e28e12b5b 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -37,8 +37,8 @@ internal static void VerifyProjectSchema
             string binPath
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(binPath, "binPath");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(binPath, nameof(binPath));
 
             if ((schemaFile == null) || (schemaFile.Length == 0))
             {
@@ -75,8 +75,8 @@ private void VerifyProjectSchema
             string schemaFile
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(schemaFile, "schemaFile");
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
+            ErrorUtilities.VerifyThrowArgumentNull(schemaFile, nameof(schemaFile));
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
 
             // Options for XmlReader object can be set only in constructor. After the object is created, they
             // become read-only. Because of that we need to create
@@ -302,4 +302,4 @@ private void OnSchemaValidationError(object sender, ValidationEventArgs args)
         #endregion // Event Handlers
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 305acb0a096..e26bdf5c958 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -502,7 +502,7 @@ string [] commandLine
             }
 
 #if FEATURE_GET_COMMANDLINE
-            ErrorUtilities.VerifyThrowArgumentLength(commandLine, "commandLine");
+            ErrorUtilities.VerifyThrowArgumentLength(commandLine, nameof(commandLine));
 #endif
 
             ExitType exitType = ExitType.Success;
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 666fc50449f..9d83997706b 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -4,11 +4,7 @@
 using System;
 using System.IO;
 using System.Reflection;
-using System.Collections;
-using System.Globalization;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
 using System.Threading;
 
 namespace Microsoft.Build.Shared
@@ -224,8 +220,8 @@ private class AssemblyInfoToLoadedTypes
             /// </summary>
             internal AssemblyInfoToLoadedTypes(TypeFilter typeFilter, AssemblyLoadInfo loadInfo)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(typeFilter, "typefilter");
-                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+                ErrorUtilities.VerifyThrowArgumentNull(typeFilter, nameof(typeFilter));
+                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
 
                 _isDesiredType = typeFilter;
                 _assemblyLoadInfo = loadInfo;
@@ -238,7 +234,7 @@ internal AssemblyInfoToLoadedTypes(TypeFilter typeFilter, AssemblyLoadInfo loadI
             /// </summary>
             internal LoadedType GetLoadedTypeByTypeName(string typeName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(typeName, "typeName");
+                ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
                 // Only one thread should be doing operations on this instance of the object at a time.
 
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index ab9e4bf1668..bfac8b3398f 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -54,7 +54,7 @@ internal static TaskScheduler OneSTAThreadPerTaskSchedulerInstance
         /// <returns>The awaiter.</returns>
         internal static TaskAwaiter GetAwaiter(this WaitHandle handle)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(handle, "handle");
+            ErrorUtilities.VerifyThrowArgumentNull(handle, nameof(handle));
             return handle.ToTask().GetAwaiter();
         }
 
@@ -65,7 +65,7 @@ internal static TaskAwaiter GetAwaiter(this WaitHandle handle)
         /// <returns>The awaiter.</returns>
         internal static TaskAwaiter<int> GetAwaiter(this WaitHandle[] handles)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(handles, "handle");
+            ErrorUtilities.VerifyThrowArgumentNull(handles, nameof(handles));
             return handles.ToTask().GetAwaiter();
         }
 
@@ -94,7 +94,7 @@ internal static Task ToTask(this WaitHandle handle, int timeout = Timeout.Infini
         /// </remarks>
         internal static Task<int> ToTask(this WaitHandle[] handles, int timeout = Timeout.Infinite)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(handles, "handle");
+            ErrorUtilities.VerifyThrowArgumentNull(handles, nameof(handles));
 
             var tcs = new TaskCompletionSource<int>();
             int signalledHandle = WaitHandle.WaitAny(handles, 0);
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 37e6727b97d..9d715c7f484 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using System.Diagnostics;
 using System.Globalization;
-using System.Runtime.CompilerServices;
 using System.Threading;
 
 #if BUILDINGAPPXTASKS
diff --git a/src/Shared/LanguageParser/token.cs b/src/Shared/LanguageParser/token.cs
index 5deedb0a4a6..8762cfcf8f5 100644
--- a/src/Shared/LanguageParser/token.cs
+++ b/src/Shared/LanguageParser/token.cs
@@ -2,21 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
-    /*
-     * Class:   Token
-     *
-     * Base class for all token classes.
-     *
-     */
+    /// <summary>
+    /// Base class for all token classes.
+    /// </summary>
     internal abstract class Token
     {
         // The text from the originating source file that caused this token.
@@ -24,22 +15,18 @@ internal abstract class Token
         // The line number that the token fell on.
         private int _line = 0;
 
-        /*
-         * Method:  InnerText
-         * 
-         * Get or set the InnerText for this token
-         */
+        /// <summary>
+        /// Get or set the InnerText for this token
+        /// </summary>
         internal string InnerText
         {
             get { return _innerText; }
             set { _innerText = value; }
         }
 
-        /*
-         * Method:  Line
-         * 
-         * Get or set the Line for this token
-         */
+        /// <summary>
+        /// Get or set the Line for this token
+        /// </summary>
         internal int Line
         {
             get
@@ -52,11 +39,9 @@ internal int Line
             }
         }
 
-        /*
-         * Method:  EqualsIgnoreCase
-         * 
-         * Return true if the given string equals the content of this token
-         */
+        /// <summary>
+        /// Return true if the given string equals the content of this token.
+        /// </summary>
         internal bool EqualsIgnoreCase(string compareTo)
         {
             return (String.Compare(_innerText, compareTo, StringComparison.OrdinalIgnoreCase) == 0);
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 81265e45ced..535da4f69af 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -2,22 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 #if CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Concurrent;
 #else
 using System.Collections.Concurrent;
 #endif
-using System.Globalization;
-using System.Text;
 using System.IO;
 using System.IO.Pipes;
 using System.Threading;
-using System.Diagnostics;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
 using System.Security.AccessControl;
 #endif
@@ -145,7 +139,7 @@ public LinkStatus LinkStatus
         public void Listen(INodePacketFactory factory)
         {
             ErrorUtilities.VerifyThrow(_status == LinkStatus.Inactive, "Link not inactive.  Status is {0}", _status);
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             _packetFactory = factory;
 
             InitializeAsyncPacketThread();
@@ -192,7 +186,7 @@ public void SendData(INodePacket packet)
         /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         internal void InternalConstruct(string pipeName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(pipeName, "pipeName");
+            ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
 
             _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
 
@@ -232,8 +226,8 @@ internal void InternalConstruct(string pipeName)
 #else
         internal void InternalConstruct(string clientToServerPipeHandle, string serverToClientPipeHandle)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(clientToServerPipeHandle, "clientToServerPipeHandle");
-            ErrorUtilities.VerifyThrowArgumentLength(serverToClientPipeHandle, "serverToClientPipeHandle");
+            ErrorUtilities.VerifyThrowArgumentLength(clientToServerPipeHandle, nameof(clientToServerPipeHandle));
+            ErrorUtilities.VerifyThrowArgumentLength(serverToClientPipeHandle, nameof(serverToClientPipeHandle));
 
             _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
 
@@ -313,7 +307,7 @@ private void InternalDisconnect()
         /// <param name="packet">The packet to be transmitted.</param>
         private void EnqueuePacket(INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
             ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
 
diff --git a/src/Shared/OutOfProcTaskHostTaskResult.cs b/src/Shared/OutOfProcTaskHostTaskResult.cs
index 03fcc964d2c..48150a93a7e 100644
--- a/src/Shared/OutOfProcTaskHostTaskResult.cs
+++ b/src/Shared/OutOfProcTaskHostTaskResult.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 
 using Microsoft.Build.BackEnd;
 
@@ -61,7 +60,7 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string
                 result == TaskCompleteType.CrashedDuringExecution ||
                 result == TaskCompleteType.CrashedAfterExecution)
             {
-                ErrorUtilities.VerifyThrowInternalNull(taskException, "taskException");
+                ErrorUtilities.VerifyThrowInternalNull(taskException, nameof(taskException));
             }
 
             if (exceptionMessage != null)
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index bc63745e3cb..6ad19b8b3a6 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Diagnostics;
-
 /******************************************************************************
  * 
  *                              !! WARNING !!
@@ -389,7 +386,7 @@ private static void ThrowInvalidProject
             params object[] args
         )
         {
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 #if DEBUG
             if (errorSubCategoryResourceName != null)
             {
diff --git a/src/Shared/ReadOnlyCollection.cs b/src/Shared/ReadOnlyCollection.cs
index c0a712ab818..4837b457a32 100644
--- a/src/Shared/ReadOnlyCollection.cs
+++ b/src/Shared/ReadOnlyCollection.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using System.Collections;
 using Microsoft.Build.Shared;
 
@@ -128,7 +127,7 @@ public bool Contains(T item)
         /// </summary>
         public void CopyTo(T[] array, int arrayIndex)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(array, "array");
+            ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));
 
             ICollection<T> backingCollection = _backing as ICollection<T>;
             if (backingCollection != null)
@@ -184,7 +183,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// </summary>
         void ICollection.CopyTo(Array array, int index)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(array, "array");
+            ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));
 
             int i = index;
             foreach (T entry in _backing)
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index f64a18c2b30..de5e552fdda 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -6,9 +6,6 @@
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
-using System.Text.RegularExpressions;
-using System.Reflection;
-using System.Text;
 using System.ComponentModel;
 
 #if BUILDINGAPPXTASKS
@@ -38,7 +35,7 @@ internal static class ResourceUtilities
         internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, out string code)
         {
 #if !BUILDINGAPPXTASKS
-            ErrorUtilities.VerifyThrowInternalNull(message, "message");
+            ErrorUtilities.VerifyThrowInternalNull(message, nameof(message));
 #endif
 
             code = null;
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index b819bdcfac5..9ab28cadf6f 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -5,12 +5,8 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
-using System.Linq;
-using System.Threading;
-using System.Text;
 
 using Microsoft.Build.Shared;
-using System.Reflection;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -122,8 +118,8 @@ public TaskHostConfiguration
                 IDictionary<string, object> taskParameters
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
-            ErrorUtilities.VerifyThrowInternalLength(taskLocation, "taskLocation");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowInternalLength(taskLocation, nameof(taskLocation));
 
             _nodeId = nodeId;
             _startupDirectory = startupDirectory;
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index 5eb5f7c9eb9..7b015ff95ce 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -4,10 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using System.Text;
 
-using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
@@ -91,7 +88,7 @@ internal class TaskHostTaskComplete : INodePacket
         /// <param name="buildProcessEnvironment">The build process environment as it was at the end of the task's execution.</param>
         public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<string, string> buildProcessEnvironment)
         {
-            ErrorUtilities.VerifyThrowInternalNull(result, "result");
+            ErrorUtilities.VerifyThrowInternalNull(result, nameof(result));
 
             _taskResult = result.Result;
             _taskException = result.TaskException;
diff --git a/src/Shared/TaskLoggingHelperExtension.cs b/src/Shared/TaskLoggingHelperExtension.cs
index 31fe1c55b39..c151ea7711f 100644
--- a/src/Shared/TaskLoggingHelperExtension.cs
+++ b/src/Shared/TaskLoggingHelperExtension.cs
@@ -97,7 +97,7 @@ public ResourceManager TaskSharedResources
         /// <exception cref="InvalidOperationException">Thrown when the <c>TaskResources</c> property of the owner task is not set.</exception>
         override public string FormatResourceString(string resourceName, params object[] args)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(resourceName, "resourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(resourceName, nameof(resourceName));
             ErrorUtilities.VerifyThrowInvalidOperation(TaskResources != null, "Shared.TaskResourcesNotRegistered", TaskName);
             ErrorUtilities.VerifyThrowInvalidOperation(TaskSharedResources != null, "Shared.TaskResourcesNotRegistered", TaskName);
 
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 3d30933b742..c5f8ae2fcab 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -7,7 +7,6 @@
 using System.Diagnostics;
 using System.Security;
 
-using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Reflection;
@@ -523,7 +522,7 @@ private class TaskParameterTaskItem :
             /// </summary>
             public TaskParameterTaskItem(string escapedItemSpec, string escapedDefiningProject, Dictionary<string, string> escapedMetadata)
             {
-                ErrorUtilities.VerifyThrowInternalNull(escapedItemSpec, "escapedItemSpec");
+                ErrorUtilities.VerifyThrowInternalNull(escapedItemSpec, nameof(escapedItemSpec));
 
                 _escapedItemSpec = escapedItemSpec;
                 _escapedDefiningProject = escapedDefiningProject;
@@ -614,7 +613,7 @@ public string GetMetadata(string metadataName)
             /// <param name="metadataValue">The metadata value.</param>
             public void SetMetadata(string metadataName, string metadataValue)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
 
                 // Non-derivable metadata can only be set at construction time.
                 // That's why this is IsItemSpecModifier and not IsDerivableItemSpecModifier.
@@ -631,7 +630,7 @@ public void SetMetadata(string metadataName, string metadataValue)
             /// <param name="metadataName">The name of the metadata to remove.</param>
             public void RemoveMetadata(string metadataName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
                 ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(metadataName), "Shared.CannotChangeItemSpecModifiers", metadataName);
 
                 if (_customEscapedMetadata == null)
@@ -654,7 +653,7 @@ public void RemoveMetadata(string metadataName)
             /// <param name="destinationItem">The item to copy metadata to.</param>
             public void CopyMetadataTo(ITaskItem destinationItem)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
                 // also copy the original item-spec under a "magic" metadata -- this is useful for tasks that forward metadata
                 // between items, and need to know the source item where the metadata came from
@@ -721,7 +720,7 @@ public override object InitializeLifetimeService()
             /// </summary>
             string ITaskItem2.GetMetadataValueEscaped(string metadataName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
 
                 string metadataValue = null;
 
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 7b697faeab7..8875a59b476 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
@@ -292,8 +291,8 @@ private class AssemblyInfoToLoadedTypes
             /// </summary>
             internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, AssemblyLoadInfo loadInfo)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(typeFilter, "typefilter");
-                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+                ErrorUtilities.VerifyThrowArgumentNull(typeFilter, nameof(typeFilter));
+                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
 
                 _isDesiredType = typeFilter;
                 _assemblyLoadInfo = loadInfo;
@@ -306,7 +305,7 @@ internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, Assembly
             /// </summary>
             internal LoadedType GetLoadedTypeByTypeName(string typeName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(typeName, "typeName");
+                ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
                 // Only one thread should be doing operations on this instance of the object at a time.
 
diff --git a/src/Shared/XamlUtilities.cs b/src/Shared/XamlUtilities.cs
deleted file mode 100644
index b45082802f0..00000000000
--- a/src/Shared/XamlUtilities.cs
+++ /dev/null
@@ -1,435 +0,0 @@
-﻿using System;
-using System.Xml;
-using System.Text.RegularExpressions;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Framework.XamlTypes;
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// This class contains utility methods for Xaml types.
-    /// </summary>
-    static internal class XamlUtilities
-    {
-        /// <summary>
-        /// Gets an identifier for a property based on its name, its containing object's name and/or type. This is intended to
-        /// help the user zero in on the offending line/element in a xaml file, when we don't have access to a parser to
-        /// report line numbers.
-        /// </summary>
-        /// <param name="propertyName"> The name of the property. </param>
-        /// <param name="containingObjectName"> The name of the containing object. </param>
-        /// <param name="containingObject"> The object which contains this property. </param>
-        /// <returns> Returns "(containingObject's type name)containingObjectName.PropertyName". </returns>
-        internal static string GetPropertyId(string propertyName, string containingObjectName, object containingObject)
-        {
-            ErrorUtilities.VerifyThrowArgumentLength(propertyName, "propertyName");
-            ErrorUtilities.VerifyThrowArgumentLength(containingObjectName, "containingObjectName");
-            ErrorUtilities.VerifyThrowArgumentNull(containingObject, "containingObject");
-
-            StringBuilder propertyId = new StringBuilder();
-
-            propertyId.Append("(");
-            propertyId.Append(containingObject.GetType().Name);
-            propertyId.Append(")");
-
-            if (!string.IsNullOrEmpty(containingObjectName))
-            {
-                propertyId.Append(containingObjectName);
-            }
-
-            propertyId.Append(".");
-
-            propertyId.Append(propertyName);
-
-            return propertyId.ToString();
-        }
-
-        /// <summary>
-        /// Returns an identifier for a property based on its name and its containing object's type. Use this
-        /// overload when the containing object's name is not known (which can be the case when the property
-        /// being tested is the Name property itself).
-        /// </summary>
-        /// <param name="propertyName"> The name of the property. </param>
-        /// <param name="containingObject"> The object which contains this property. </param>
-        /// <returns> Returns "(containingObject's type name)unknown.PropertyName". </returns>
-        internal static string GetPropertyId(string propertyName, object containingObject)
-        {
-            string propertyId = GetPropertyId(propertyName, "unknown", containingObject);
-            return propertyId;
-        }
-
-        /// <summary>
-        /// Throws an <see cref="ArgumentNullException"/> if the given property is null.
-        /// </summary>
-        /// <param name="property">The property to test.</param>
-        /// <param name="propertyId">An identifier of the property to check.</param>
-        internal static void VerifyThrowPropertyNotSet(object property, string propertyId)
-        {
-            ErrorUtilities.VerifyThrowArgumentLength(propertyId, "propertyId");
-
-            if (property == null)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(null, propertyId, Strings.PropertyValueMustBeSet);
-            }
-        }
-
-        /// <summary>
-        /// Throws an <see cref="ArgumentNullException"/> if the given property is null.
-        /// </summary>
-        /// <param name="property">The property to test.</param>
-        /// <param name="propertyId">An identifier of the property to check.</param>
-        /// <param name="unformattedMessage"> The text message to display. </param>
-        internal static void VerifyThrowPropertyNotSet(object property, string propertyId, string unformattedMessage)
-        {
-            ErrorUtilities.VerifyThrowArgumentLength(propertyId, "propertyId");
-
-            if (property == null)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(null, propertyId, unformattedMessage);
-            }
-        }
-
-        /// <summary>
-        /// Throws an <see cref="ArgumentException"/> if the given property's value is the empty string.
-        /// </summary>
-        /// <param name="property">The parameter to test.</param>
-        /// <param name="propertyId">An identifier of the property to check.</param>
-        internal static void VerifyThrowPropertyEmptyString(string property, string propertyId)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
-            ErrorUtilities.VerifyThrowArgumentLength(propertyId, "propertyId");
-
-            if (property.Length == 0)
-            {
-                ErrorUtilities.ThrowArgument(Strings.PropertyCannotBeSetToTheEmptyString, propertyId);
-            }
-        }
-
-        /// <summary>
-        /// Throws an <see cref="ArgumentNullException"/> if the given property is null and
-        /// <see cref="ArgumentException"/> if the given property's value is the empty string.
-        /// </summary>
-        /// <param name="property">The parameter to test.</param>
-        /// <param name="propertyId">An identifier of the property to check.</param>
-        internal static void VerifyThrowPropertyNotSetOrEmptyString(string property, string propertyId)
-        {
-            VerifyThrowPropertyNotSet(property, propertyId);
-            VerifyThrowPropertyEmptyString(property, propertyId);
-        }
-
-        /// <summary>
-        /// Throws an <see cref="ArgumentException"/> if the given list property has zero elements.
-        /// </summary>
-        /// <param name="listProperty"> The list parameter to test. </param>
-        /// <param name="propertyId"> An identifier of the property to check. </param>
-        internal static void VerifyThrowListPropertyEmpty(IList listProperty, string propertyId)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(listProperty, "listProperty");
-            ErrorUtilities.VerifyThrowArgumentLength(propertyId, "propertyId");
-
-            if (listProperty.Count == 0)
-            {
-                ErrorUtilities.ThrowArgument(Strings.ListPropertyShouldHaveAtLeastOneElement, propertyId);
-            }
-        }
-
-        #region Extension Methods
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this Argument type)
-        {
-            string propertyId = GetPropertyId("Property", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.Property, propertyId);
-        }
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this BaseProperty type)
-        {
-            string namePropertyId = GetPropertyId("Name", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.Name, namePropertyId);
-
-            string categoryPropertyId = GetPropertyId("Category", type.Name, type);
-            VerifyThrowPropertyEmptyString(typeCategory, categoryPropertyId);
-
-            // Validate children.
-            if (null != type.DataSource)
-            {
-                type.DataSource.Validate();
-            }
-
-            foreach (Argument argument in type.Arguments)
-            {
-                argument.Validate();
-            }
-
-            foreach (ValueEditor editor in type.ValueEditors)
-            {
-                editor.Validate();
-            }
-
-            // Validate any known derivations.
-            BoolProperty boolProp = type as BoolProperty;
-            if (null != boolProp)
-            {
-                return;
-            }
-
-            DynamicEnumProperty dynamicEnumProp = type as DynamicEnumProperty;
-            if (dynamicEnumProp != null)
-            {
-                dynamicEnumProp.Validate();
-                return;
-            }
-
-            EnumProperty enumProp = type as EnumProperty;
-            if (enumProp != null)
-            {
-                enumProp.Validate();
-                return;
-            }
-
-            IntProperty intProp = type as IntProperty;
-            if (intProp != null)
-            {
-                intProp.Validate();
-                return;
-            }
-
-            StringListProperty stringListProp = type as StringListProperty;
-            if (stringListProp != null)
-            {
-                return;
-            }
-
-            StringProperty stringProp = type as StringProperty;
-            if (stringProp != null)
-            {
-                return;
-            }
-
-            // Unknown derivation, but that's ok.
-        }
-
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this Category type)
-        {
-            string namePropertyId = GetPropertyId("Name", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.Name, namePropertyId);
-        }
-
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this DataSource type)
-        {
-            string persistencePropertyId = GetPropertyId("Persistence", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.Persistence, persistencePropertyId);
-        }
-
-        /// <summary>
-        /// Validate the content type data integrity afte deserializing from XAML file
-        /// </summary>
-        internal void Validate(this ContentType type)
-        {
-            // content type must at least declare name, and msbuild ItemType to be workable at minimum level
-            string namePropertyId = GetPropertyId("Name", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.Name, namePropertyId);
-
-            string itemTypePropertyId = GetPropertyId("ItemType", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.ItemType, itemTypePropertyId);
-        }
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this DynamicEnumProperty type)
-        {
-            (type as BaseProperty).Validate();
-            ErrorUtilities.VerifyThrowArgumentLength(type.EnumProvider, "EnumProvider");
-        }
-
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        private void Validate(this EnumProperty type)
-        {
-            (type as BaseProperty).Validate();
-
-            // Validate that the "Default" field is not set on this property.
-            string defaultPropertyId = GetPropertyId("Default", type.Name, type);
-            if (null != Default)
-            {
-                ErrorUtilities.ThrowArgument(Strings.CannotSetDefaultPropertyOnEnumProperty, typeof(EnumProperty).Name, typeof(EnumValue).Name);
-            }
-
-            // Make sure that at least one value was defined in AdmissibleValues.
-            string admissibleValuesId = GetPropertyId("AdmissibleValues", type.Name, type);
-            VerifyThrowListPropertyEmpty(type.AdmissibleValues, admissibleValuesId);
-
-            // Validate that only one of the EnumValues under AdmissibleValues is marked IsDefault.
-            string admissibleValuesPropertyId = GetPropertyId("AdmissibleValues", type.Name, type);
-
-            bool seen = false;
-            foreach (EnumValue enumValue in type.AdmissibleValues)
-            {
-                if (enumValue.IsDefault)
-                {
-                    if (!seen)
-                    {
-                        seen = true;
-                    }
-                    else
-                    {
-                        ErrorUtilities.ThrowArgument(Strings.OnlyOneEnumValueCanBeSetAsDefault, typeof(EnumValue).Name, admissibleValuesPropertyId);
-                    }
-                }
-            }
-        }
-
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this IntProperty type)
-        {
-            (type as BaseProperty).Validate();
-
-            if (null != type.MaxValue && null != type.MinValue)
-            {
-                if (type.MinValue > type.MaxValue)
-                {
-                    string minValuePropertyId = GetPropertyId("MinValue", type.Name, type);
-                    ErrorUtilities.ThrowArgument(Strings.MinValueShouldNotBeGreaterThanMaxValue, minValuePropertyId);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Validate the content type data integrity afte deserializing from XAML file
-        /// </summary>
-        internal void Validate(this ItemType type)
-        {
-            // content type must at least declare name, and msbuild ItemType to be workable at minimum level
-            string namePropertyId = GetPropertyId("Name", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.Name, namePropertyId);
-
-            if (type.DisplayName == null)
-            {
-                type.DisplayName = type.Name;
-            }
-        }
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this Rule type)
-        {
-            // Validate "Name" property.
-            string namePropertyId = GetPropertyId("Name", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.Name, namePropertyId);
-
-            // Make sure that at least one Property was defined in this Rule.
-            string propertiesId = XamlErrorUtilities.GetPropertyId("Properties", Name, this);
-            VerifyThrowListPropertyEmpty(type.Properties, propertiesId);
-
-            // Validate the child objects
-            foreach (BaseProperty property in type.Properties)
-            {
-                property.Validate();
-            }
-
-            foreach (Category category in type.Categories)
-            {
-                category.Validate();
-            }
-
-            // If the DataSource property is not defined on this Rule, check that a DataSource is 
-            // specified locally on every property.
-            if (null == type.DataSource)
-            {
-                foreach (BaseProperty property in type.Properties)
-                {
-                    string dataSourcePropertyId = GetPropertyId("DataSource", property.Name, property);
-                    VerifyThrowPropertyNotSet(property.DataSource, dataSourcePropertyId, Strings.DataSourceMustBeDefinedOnPropertyOrOnRule);
-                }
-            }
-            else
-            {
-                type.DataSource.Validate();
-            }
-
-            // Create a HashSet for O(1) lookup.
-            HashSet<string> propertyNames = new HashSet<string>();
-            foreach (BaseProperty property in type.Properties)
-            {
-                if (!propertyNames.Contains(property.Name))
-                {
-                    propertyNames.Add(property.Name);
-                }
-            }
-
-            // Validate that every argument refers to a valid property.
-            foreach (BaseProperty property in type.Properties)
-            {
-                if (property.Arguments == null || property.Arguments.Count == 0)
-                {
-                    continue;
-                }
-
-                foreach (Argument argument in property.Arguments)
-                {
-                    if (!propertyNames.Contains(argument.Property))
-                    {
-                        ErrorUtilities.ThrowArgument(Strings.PropertyReferredToByArgumentDoesNotExist, argument.Property);
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this RuleBag type)
-        {
-            // Make sure that at least one Rule was defined in this RuleBag.
-            string rulesId = GetPropertyId("Rules", type);
-            VerifyThrowListPropertyEmpty(type.Rules, rulesId);
-
-            foreach (Rule rule in Rules)
-            {
-                rule.Validate();
-            }
-        }
-
-        /// <summary>
-        /// Validates the properties of this object. This method should be called
-        /// after initialization is complete.
-        /// </summary>
-        internal void Validate(this ValueEditor type)
-        {
-            string propertyId = GetPropertyId("EditorType", type);
-            VerifyThrowPropertyNotSetOrEmptyString(type.EditorType, propertyId);
-        }
-
-        #endregion
-
-    }
-}
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index 103570c4d6e..c73d79cf322 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Xml;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Shared
@@ -70,7 +69,7 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
         /// <param name="name">name to validate</param>
         internal static void VerifyThrowArgumentValidElementName(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             int firstInvalidCharLocation = LocateFirstInvalidElementNameCharacter(name);
 
@@ -89,7 +88,7 @@ internal static void VerifyThrowArgumentValidElementName(string name)
         /// </remarks>
         internal static void VerifyThrowProjectValidElementName(string name, IElementLocation location)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
             int firstInvalidCharLocation = LocateFirstInvalidElementNameCharacter(name);
 
             if (-1 != firstInvalidCharLocation)
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 80b7f38c503..dc813d6f02e 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -224,7 +224,7 @@ public string[] TargetFrameworkSubsets
             get { return _targetFrameworkSubsets; }
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "TargetFrameworkSubsets");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(TargetFrameworkSubsets));
                 _targetFrameworkSubsets = value;
             }
         }
@@ -352,7 +352,7 @@ public ITaskItem[] InstalledAssemblySubsetTables
             get { return _installedAssemblySubsetTables; }
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "InstalledAssemblySubsetTables");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(InstalledAssemblySubsetTables));
                 _installedAssemblySubsetTables = value;
             }
         }
@@ -379,7 +379,7 @@ public ITaskItem[] FullFrameworkAssemblyTables
             get { return _fullFrameworkAssemblyTables; }
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "FullFrameworkAssemblyTables");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(FullFrameworkAssemblyTables));
                 _fullFrameworkAssemblyTables = value;
             }
         }
@@ -722,7 +722,7 @@ public string[] FullTargetFrameworkSubsetNames
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "FullTargetFrameworkSubsetNames");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(FullTargetFrameworkSubsetNames));
                 _fullTargetFrameworkSubsetNames = value;
             }
         }
@@ -740,7 +740,7 @@ public string ProfileName
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "profileName");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(ProfileName));
                 _profileName = value;
             }
         }
@@ -759,7 +759,7 @@ public string[] FullFrameworkFolders
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "FullFrameworkFolders");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(FullFrameworkFolders));
                 _fullFrameworkFolders = value;
             }
         }
@@ -1160,7 +1160,7 @@ internal static string ByteArrayToString(byte[] a)
         /// </summary>
         private void LogReferenceDependenciesAndSourceItems(string fusionName, Reference conflictCandidate)
         {
-            ErrorUtilities.VerifyThrowInternalNull(conflictCandidate, "ConflictCandidate");
+            ErrorUtilities.VerifyThrowInternalNull(conflictCandidate, nameof(conflictCandidate));
             Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceString("ResolveAssemblyReference.ReferenceDependsOn", fusionName, conflictCandidate.FullPath));
 
             if (conflictCandidate.IsPrimary)
@@ -1555,7 +1555,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
         /// <param name="importance">The importance of the message.</param>
         private void LogFullName(Reference reference, MessageImportance importance)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(reference, "reference");
+            ErrorUtilities.VerifyThrowArgumentNull(reference, nameof(reference));
 
             if (reference.IsResolved)
             {
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index 85e8cc3e3e2..9e433200cdd 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -134,7 +134,7 @@ internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYP
         /// </summary>
         internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path, ITaskItem originalTaskItem, string targetProcessorArchitecture)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(path, "path");
+            ErrorUtilities.VerifyThrowArgumentNull(path, nameof(path));
 
             this.taskItem = originalTaskItem;
 
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 673b76ebd5e..dccfe14b54c 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -39,7 +39,6 @@
 using System.Runtime.Versioning;
 
 using Microsoft.Build.Utilities;
-using System.Xml.Linq;
 
 namespace Microsoft.Build.Tasks
 {
@@ -597,7 +596,7 @@ private void GenerateResGenCommandLineWithoutResources(CommandLineBuilderExtensi
         {
             // Throw an internal error, since this method should only ever get called by other aspects of this task, not
             // anything that the user touches. 
-            ErrorUtilities.VerifyThrowInternalNull(resGenCommand, "resGenCommand");
+            ErrorUtilities.VerifyThrowInternalNull(resGenCommand, nameof(resGenCommand));
 
             // append the /useSourcePath flag if requested.
             if (UseSourcePath)
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 2012bfee446..7fd79245fd7 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -152,7 +152,7 @@ internal FileState(DateTime lastModified)
             /// </summary>
             internal FileState(SerializationInfo info, StreamingContext context)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
                 lastModified = new DateTime(info.GetInt64("mod"), (DateTimeKind)info.GetInt32("modk"));
                 assemblyName = (AssemblyNameExtension)info.GetValue("an", typeof(AssemblyNameExtension));
@@ -174,7 +174,7 @@ internal FileState(SerializationInfo info, StreamingContext context)
             [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
             public void GetObjectData(SerializationInfo info, StreamingContext context)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
                 info.AddValue("mod", lastModified.Ticks);
                 info.AddValue("modk", (int)lastModified.Kind);
@@ -243,7 +243,7 @@ internal SystemState()
         /// </summary>
         internal SystemState(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             instanceLocalFileStateCache = (Hashtable)info.GetValue("fileState", typeof(Hashtable));
             isDirty = false;
@@ -270,7 +270,7 @@ AssemblyTableInfo[] installedAssemblyTableInfos
         [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
         public void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             info.AddValue("fileState", instanceLocalFileStateCache);
         }
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 56b2d97c712..1f98d0ec590 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -140,7 +140,7 @@ public override bool Execute()
         /// </summary>
         private bool Unregister(string assemblyPath, string typeLibPath)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(typeLibPath, "typeLibPath");
+            ErrorUtilities.VerifyThrowArgumentNull(typeLibPath, nameof(typeLibPath));
 
             Log.LogMessageFromResources(MessageImportance.Low, "UnregisterAssembly.UnregisteringAssembly", assemblyPath);
 
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 40b9343a6d9..5fdd5f44738 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -83,8 +83,8 @@ public Type TaskType
         /// </summary>
         public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> taskParameters, string taskElementContents, IBuildEngine taskFactoryLoggingHost)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskParameters, "taskParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskParameters, nameof(taskParameters));
 
             var log = new TaskLoggingHelper(taskFactoryLoggingHost, taskName)
             {
@@ -211,7 +211,7 @@ public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
         /// </remarks>
         public void CleanupTask(ITask task)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
         }
 
         /// <summary>
diff --git a/src/Tasks/XmlPeek.cs b/src/Tasks/XmlPeek.cs
index 5f273222f3b..dde48902c94 100644
--- a/src/Tasks/XmlPeek.cs
+++ b/src/Tasks/XmlPeek.cs
@@ -46,7 +46,7 @@ public string Query
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_query, "Query");
+                ErrorUtilities.VerifyThrowArgumentNull(_query, nameof(Query));
                 return _query;
             }
 
diff --git a/src/Tasks/XmlPoke.cs b/src/Tasks/XmlPoke.cs
index be8abc7cf67..3d9f64174b2 100644
--- a/src/Tasks/XmlPoke.cs
+++ b/src/Tasks/XmlPoke.cs
@@ -92,9 +92,9 @@ public ITaskItem Value
         /// <returns>true if transformation succeeds.</returns>
         public override bool Execute()
         {
-            ErrorUtilities.VerifyThrowArgumentNull(_query, "Query");
-            ErrorUtilities.VerifyThrowArgumentNull(_value, "Value");
-            ErrorUtilities.VerifyThrowArgumentNull(_xmlInputPath, "XmlInputPath");
+            ErrorUtilities.VerifyThrowArgumentNull(_query, nameof(Query));
+            ErrorUtilities.VerifyThrowArgumentNull(_value, nameof(Value));
+            ErrorUtilities.VerifyThrowArgumentNull(_xmlInputPath, nameof(XmlInputPath));
 
             // Load the XPath Document
             XmlDocument xmlDoc = new XmlDocument();
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 1eef0347d03..04559e754d2 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -63,7 +63,7 @@ public ITaskItem[] OutputPaths
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_outputPaths, "OutputPath");
+                ErrorUtilities.VerifyThrowArgumentNull(_outputPaths, nameof(OutputPaths));
                 return _outputPaths;
             }
 
@@ -90,7 +90,7 @@ public override bool Execute()
         {
             XmlInput xmlinput;
             XsltInput xsltinput;
-            ErrorUtilities.VerifyThrowArgumentNull(_outputPaths, "OutputPath");
+            ErrorUtilities.VerifyThrowArgumentNull(_outputPaths, nameof(OutputPaths));
 
             // Load XmlInput, XsltInput parameters
             try
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 124ef58cb6b..78bde36e496 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -420,7 +420,7 @@ public ITaskItem[] CreatedTaskItems
             /// </summary>
             public void Run(string[] includes, IDictionary<string, string> metadataToAdd)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(includes, "includes");
+                ErrorUtilities.VerifyThrowArgumentNull(includes, nameof(includes));
 
                 CreatedTaskItems = new TaskItem[includes.Length];
 
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 37da4269f8a..5a6f2db074c 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2545,7 +2545,7 @@ internal static void GatherSDKListFromDirectory(List<string> diskroots, Dictiona
         /// </summary>
         internal static void GatherSDKsFromRegistryImpl(Dictionary<TargetPlatformSDK, TargetPlatformSDK> platformMonikers, string registryKeyRoot, RegistryView registryView, RegistryHive registryHive, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey, FileExists fileExists)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(platformMonikers, "PlatformMonikers");
+            ErrorUtilities.VerifyThrowArgumentNull(platformMonikers, nameof(platformMonikers));
             if (string.IsNullOrEmpty(registryKeyRoot))
             {
                 return;
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 8d9a32f698c..32eb5b5b519 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -304,7 +304,7 @@ public static bool FileIsUnderPath(string fileName, string path)
         /// <param name="outputs">ITaskItem array of outputs.</param>
         public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] outputs)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(sources, "sources");
+            ErrorUtilities.VerifyThrowArgumentNull(sources, nameof(sources));
 
             // So we don't have to deal with null checks.
             outputs = outputs ?? Array.Empty<ITaskItem>();
