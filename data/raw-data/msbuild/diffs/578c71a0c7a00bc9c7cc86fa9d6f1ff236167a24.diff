diff --git a/eng/Packages.props b/eng/Packages.props
index 727964ed0b9..eb311e8bb28 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -52,8 +52,9 @@
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
-    <PackageReference Update="StreamJsonRpc" Version="2.4.48" />
+    <PackageReference Update="StreamJsonRpc" Version="2.5.46" />
     <PackageReference Update="Newtonsoft.Json" Version="12.*" PrivateAssets="all" />
+    <PackageReference Update="MessagePack" Version="2.1.165" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index db6aed18321..5bf95c1ac10 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -2546,159 +2546,14 @@ public partial interface IVbcHostObjectFreeThreaded
 }
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ReadOnlyTaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
+    public sealed partial class ReadOnlyTaskItem
     {
         public ReadOnlyTaskItem(string itemSpec) { }
-        [MessagePack.IgnoreMemberAttribute]
-        public string EvaluatedIncludeEscaped { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(0)]
+        public ReadOnlyTaskItem(string itemSpec, System.Collections.IDictionary metadata) { }
         public string ItemSpec { get { throw null; } set { } }
-        [MessagePack.IgnoreMemberAttribute]
-        public int MetadataCount { get { throw null; } set { } }
-        [MessagePack.IgnoreMemberAttribute]
-        public System.Collections.ICollection MetadataNames { get { throw null; } }
-        [MessagePack.KeyAttribute(1)]
         public System.Collections.Generic.Dictionary<string, string> MetadataNameToValue { get { throw null; } set { } }
-        public System.Collections.IDictionary CloneCustomMetadata() { throw null; }
-        public System.Collections.IDictionary CloneCustomMetadataEscaped() { throw null; }
-        public void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }
-        public string GetMetadata(string metadataName) { throw null; }
-        public string GetMetadataValueEscaped(string metadataName) { throw null; }
-        public void RemoveMetadata(string metadataName) { }
-        public void SetMetadata(string metadataName, string metadataValue) { }
-        public void SetMetadataValueLiteral(string metadataName, string metadataValue) { }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceRequest
-    {
-        public ResolveAssemblyReferenceRequest() { }
-        [MessagePack.KeyAttribute(0)]
-        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public string AppConfigFile { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] Assemblies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(4)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] AssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public bool AutoUnify { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public string[] CandidateAssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(7)]
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(8)]
-        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(9)]
-        public bool FindDependencies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(10)]
-        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(11)]
-        public bool FindRelatedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(12)]
-        public bool FindSatellites { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(13)]
-        public bool FindSerializationAssemblies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(14)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(15)]
-        public string[] FullFrameworkFolders { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(16)]
-        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(17)]
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(18)]
-        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(19)]
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(20)]
-        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(21)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(22)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(23)]
-        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(24)]
-        public string ProfileName { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(25)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(26)]
-        public string[] SearchPaths { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(27)]
-        public bool Silent { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(28)]
-        public string StateFile { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(29)]
-        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(30)]
-        public string TargetedRuntimeVersion { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(31)]
-        public string[] TargetFrameworkDirectories { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(32)]
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(33)]
-        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(34)]
-        public string[] TargetFrameworkSubsets { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(35)]
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(36)]
-        public string TargetProcessorArchitecture { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(37)]
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(38)]
-        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(39)]
-        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceResponse
-    {
-        public ResolveAssemblyReferenceResponse() { }
-        [MessagePack.KeyAttribute(0)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] CopyLocalFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public string DependsOnNETStandard { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public string DependsOnSystemRuntime { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FilesWritten { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(4)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] RelatedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedDependencyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(7)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SatelliteFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(8)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ScatterFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(9)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SerializationAssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(10)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SuggestedRedirects { get { throw null; } set { } }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceResult
-    {
-        public ResolveAssemblyReferenceResult() { }
-        [MessagePack.KeyAttribute(4)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildErrorEventArgs> BuildErrorEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildMessageEventArgs> BuildMessageEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildWarningEventArgs> BuildWarningEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.CustomBuildEventArgs> CustomBuildEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public int EventCount { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResponse Response { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(0)]
-        public bool TaskResult { get { throw null; } set { } }
+        public static explicit operator string (Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem taskItemToCast) { throw null; }
+        public override string ToString() { throw null; }
     }
 }
 namespace Microsoft.Build.Tasks.Xaml
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index c8536898736..bc5b80b1ae3 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -2168,159 +2168,14 @@ public partial interface IVbcHostObjectFreeThreaded
 }
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ReadOnlyTaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
+    public sealed partial class ReadOnlyTaskItem
     {
         public ReadOnlyTaskItem(string itemSpec) { }
-        [MessagePack.IgnoreMemberAttribute]
-        public string EvaluatedIncludeEscaped { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(0)]
+        public ReadOnlyTaskItem(string itemSpec, System.Collections.IDictionary metadata) { }
         public string ItemSpec { get { throw null; } set { } }
-        [MessagePack.IgnoreMemberAttribute]
-        public int MetadataCount { get { throw null; } set { } }
-        [MessagePack.IgnoreMemberAttribute]
-        public System.Collections.ICollection MetadataNames { get { throw null; } }
-        [MessagePack.KeyAttribute(1)]
         public System.Collections.Generic.Dictionary<string, string> MetadataNameToValue { get { throw null; } set { } }
-        public System.Collections.IDictionary CloneCustomMetadata() { throw null; }
-        public System.Collections.IDictionary CloneCustomMetadataEscaped() { throw null; }
-        public void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }
-        public string GetMetadata(string metadataName) { throw null; }
-        public string GetMetadataValueEscaped(string metadataName) { throw null; }
-        public void RemoveMetadata(string metadataName) { }
-        public void SetMetadata(string metadataName, string metadataValue) { }
-        public void SetMetadataValueLiteral(string metadataName, string metadataValue) { }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceRequest
-    {
-        public ResolveAssemblyReferenceRequest() { }
-        [MessagePack.KeyAttribute(0)]
-        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public string AppConfigFile { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] Assemblies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(4)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] AssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public bool AutoUnify { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public string[] CandidateAssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(7)]
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(8)]
-        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(9)]
-        public bool FindDependencies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(10)]
-        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(11)]
-        public bool FindRelatedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(12)]
-        public bool FindSatellites { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(13)]
-        public bool FindSerializationAssemblies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(14)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(15)]
-        public string[] FullFrameworkFolders { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(16)]
-        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(17)]
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(18)]
-        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(19)]
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(20)]
-        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(21)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(22)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(23)]
-        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(24)]
-        public string ProfileName { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(25)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(26)]
-        public string[] SearchPaths { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(27)]
-        public bool Silent { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(28)]
-        public string StateFile { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(29)]
-        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(30)]
-        public string TargetedRuntimeVersion { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(31)]
-        public string[] TargetFrameworkDirectories { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(32)]
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(33)]
-        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(34)]
-        public string[] TargetFrameworkSubsets { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(35)]
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(36)]
-        public string TargetProcessorArchitecture { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(37)]
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(38)]
-        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(39)]
-        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceResponse
-    {
-        public ResolveAssemblyReferenceResponse() { }
-        [MessagePack.KeyAttribute(0)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] CopyLocalFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public string DependsOnNETStandard { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public string DependsOnSystemRuntime { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FilesWritten { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(4)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] RelatedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedDependencyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(7)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SatelliteFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(8)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ScatterFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(9)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SerializationAssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(10)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SuggestedRedirects { get { throw null; } set { } }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceResult
-    {
-        public ResolveAssemblyReferenceResult() { }
-        [MessagePack.KeyAttribute(4)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildErrorEventArgs> BuildErrorEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildMessageEventArgs> BuildMessageEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildWarningEventArgs> BuildWarningEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.CustomBuildEventArgs> CustomBuildEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public int EventCount { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResponse Response { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(0)]
-        public bool TaskResult { get { throw null; } set { } }
+        public static explicit operator string (Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem taskItemToCast) { throw null; }
+        public override string ToString() { throw null; }
     }
 }
 namespace System.Deployment.Internal.CodeSigning
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index ae45efb429e..0902a0071dd 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -1,4 +1,5 @@
-﻿using System.Diagnostics.Tracing;
+﻿using System;
+using System.Diagnostics.Tracing;
 
 namespace Microsoft.Build.Eventing
 {
@@ -423,6 +424,18 @@ public void ResolveAssemblyReferenceNodeConnectStop()
         {
             WriteEvent(57);
         }
+
+        [Event(58)]
+        internal void RARaaSStart()
+        {
+            WriteEvent(58);
+        }
+
+        [Event(59)]
+        internal void RARaaSStop()
+        {
+            WriteEvent(59);
+        }
         #endregion
     }
 }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 0d9ca6d8f34..4a782fc8282 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -52,6 +52,10 @@
           <codeBase version="16.8.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
+        <dependentAssembly>
+          <assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
+          <bindingRedirect oldVersion="0.0.0.0-12.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Activities.Build" culture="neutral" publicKeyToken="31bf3856ad364e35" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 07b6a964c1c..8188eab3839 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -41,6 +41,10 @@
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
         </dependentAssembly>
 
+        <dependentAssembly>
+          <assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
+          <bindingRedirect oldVersion="0.0.0.0-12.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Activities.Build" culture="neutral" publicKeyToken="31bf3856ad364e35" />
diff --git a/src/Shared/UnitTests/MockEngine.cs b/src/Shared/UnitTests/MockEngine.cs
index 466e3d639ce..eaccd4c6d16 100644
--- a/src/Shared/UnitTests/MockEngine.cs
+++ b/src/Shared/UnitTests/MockEngine.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.IO;
 using System.Text;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -31,7 +32,7 @@ namespace Microsoft.Build.UnitTests
      * is somewhat of a no-no for task assemblies.
      * 
      **************************************************************************/
-    internal sealed class MockEngine : IBuildEngine7
+    internal sealed class MockEngine : IBuildEngine7, IRarBuildEngine
     {
         private readonly object _lockObj = new object();  // Protects _log, _output
         private readonly ITestOutputHelper _output;
@@ -212,6 +213,7 @@ internal string Log
         }
 
         public bool IsRunningMultipleNodes { get; set; }
+        public Stream ClientStream { get; set; }
 
         public bool BuildProjectFile
             (
@@ -486,5 +488,22 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life
             _objectCache.TryRemove(key, out object obj);
             return obj;
         }
+
+
+
+        bool IRarBuildEngine.CreateRarNode()
+        {
+            throw new NotSupportedException("RAR node should be created before executing test");
+        }
+
+        string IRarBuildEngine.GetRarPipeName()
+        {
+            return "RARNode.Test";
+        }
+
+        Stream IRarBuildEngine.GetRarClientStream(string pipeName, int timeout)
+        {
+            return ClientStream;
+        }
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 7b61135dc16..15d6693b47f 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -221,9 +221,6 @@
     <Compile Include="..\Shared\XMakeAttributes.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\RegisteredTaskObjectCacheBase.cs">
-      <Link>RegisteredTaskObjectCacheBase.cs</Link>
-    </Compile>
     <Compile Include="AppConfig\*.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -369,7 +366,6 @@
     <Compile Include="ResolveAssemblyReferences\Server\RarController.cs" />
     <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceBuildEngine.cs" />
     <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceComparer.cs" />
-    <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceSerializedHandler.cs" />
     <Compile Include="ResolveAssemblyReferences\Server\ServerMutex.cs" />
     <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceHandler.cs" />
     <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemlyReferenceCacheHandler.cs" />
diff --git a/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs b/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
index 4b30bea6940..4d86fe23397 100644
--- a/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.IO.Pipes;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -66,7 +65,6 @@ internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceTaskInpu
             {
                 throw new InternalErrorException("Request failed", e);
             }
-            //return client.ExecuteAsync(request).GetAwaiter().GetResult();
         }
 
         private JsonRpc GetRpcClient()
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
index 72f2ccbfe65..7567d847e5d 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
@@ -1,43 +1,19 @@
-﻿using MessagePack;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
-using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System.Collections;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Windows;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    [MessagePackObject]
-    public sealed class ReadOnlyTaskItem : ITaskItem2
+    public sealed class ReadOnlyTaskItem
     {
-        [IgnoreMember]
-        public ICollection MetadataNames { get; }
-
-        [IgnoreMember]
-        public int MetadataCount { get; set; }
-
-        [Key(0)]
         public string ItemSpec { get; set; }
 
-        [Key(1)]
         public Dictionary<string, string> MetadataNameToValue { get; set; }
 
-
-        [IgnoreMember]
-        public string EvaluatedIncludeEscaped
-        {
-            get => EscapingUtilities.UnescapeAll(ItemSpec);
-
-            set => throw new NotImplementedException();
-        }
-
-
-
         public ReadOnlyTaskItem(string itemSpec)
         {
             ItemSpec = itemSpec;
@@ -50,47 +26,6 @@ public ReadOnlyTaskItem(string itemSpec, IDictionary metadata)
             MetadataNameToValue = new Dictionary<string, string>((IDictionary<string, string>)metadata);
         }
 
-        public string GetMetadata(string metadataName)
-        {
-            throw new NotImplementedException();
-        }
-
-        public void SetMetadata(string metadataName, string metadataValue)
-        {
-            throw new NotImplementedException();
-        }
-
-        public void RemoveMetadata(string metadataName)
-        {
-            throw new NotImplementedException();
-        }
-
-        public void CopyMetadataTo(ITaskItem destinationItem)
-        {
-            throw new NotImplementedException();
-        }
-
-        public IDictionary CloneCustomMetadata()
-        {
-            throw new NotImplementedException();
-        }
-
-        public string GetMetadataValueEscaped(string metadataName)
-        {
-            throw new NotImplementedException();
-
-        }
-
-        public void SetMetadataValueLiteral(string metadataName, string metadataValue)
-        {
-            throw new NotImplementedException();
-        }
-
-        public IDictionary CloneCustomMetadataEscaped()
-        {
-            throw new NotImplementedException();
-        }
-
         internal static ReadOnlyTaskItem[] CreateArray(ITaskItem[] items)
         {
             if (items == null)
@@ -126,23 +61,5 @@ internal static ITaskItem[] ToTaskItem(ReadOnlyTaskItem[] readOnlyTaskItems)
 
             return items;
         }
-
-        /// <summary>
-        /// This allows an explicit typecast from a "TaskItem" to a "string", returning the escaped ItemSpec for this item.
-        /// </summary>
-        /// <param name="taskItemToCast">The item to operate on.</param>
-        /// <returns>The item-spec of the item.</returns>
-        public static explicit operator string(ReadOnlyTaskItem taskItemToCast)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(taskItemToCast, nameof(taskItemToCast));
-            return taskItemToCast.ItemSpec;
-        }
-
-
-        /// <summary>
-        /// Gets the item-spec.
-        /// </summary>
-        /// <returns>The item-spec string.</returns>
-        public override string ToString() => ItemSpec;
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
index 74f2447d710..e82ec64fb9d 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
@@ -1,14 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using MessagePack;
 using System.IO;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    // MessagePack requires transported objects to be public
-    [MessagePackObject]
-    public sealed class ResolveAssemblyReferenceRequest
+    internal sealed class ResolveAssemblyReferenceRequest
     {
         public ResolveAssemblyReferenceRequest() { }
         internal ResolveAssemblyReferenceRequest(ResolveAssemblyReferenceTaskInput input)
@@ -56,127 +53,86 @@ internal ResolveAssemblyReferenceRequest(ResolveAssemblyReferenceTaskInput input
             CurrentPath = input.CurrentPath;
         }
 
-        [Key(0)]
         public string[] AllowedAssemblyExtensions { get; set; }
 
-        [Key(1)]
         public string[] AllowedRelatedFileExtensions { get; set; }
 
-        [Key(2)]
         public string AppConfigFile { get; set; }
 
-        [Key(3)]
         public ReadOnlyTaskItem[] Assemblies { get; set; }
 
-        [Key(4)]
         public ReadOnlyTaskItem[] AssemblyFiles { get; set; }
 
-        [Key(5)]
         public bool AutoUnify { get; set; }
 
-        [Key(6)]
         public string[] CandidateAssemblyFiles { get; set; }
 
-        [Key(7)]
         public bool CopyLocalDependenciesWhenParentReferenceInGac { get; set; }
 
-        [Key(8)]
         public bool DoNotCopyLocalIfInGac { get; set; }
 
-        [Key(9)]
         public bool FindDependencies { get; set; }
 
-        [Key(10)]
         public bool FindDependenciesOfExternallyResolvedReferences { get; set; }
 
-        [Key(11)]
         public bool FindRelatedFiles { get; set; }
 
-        [Key(12)]
         public bool FindSatellites { get; set; }
 
-        [Key(13)]
         public bool FindSerializationAssemblies { get; set; }
 
-        [Key(14)]
         public ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get; set; }
 
-        [Key(15)]
         public string[] FullFrameworkFolders { get; set; }
 
-        [Key(16)]
         public string[] FullTargetFrameworkSubsetNames { get; set; }
 
-        [Key(17)]
         public bool IgnoreDefaultInstalledAssemblySubsetTables { get; set; }
 
-        [Key(18)]
         public bool IgnoreDefaultInstalledAssemblyTables { get; set; }
 
-        [Key(19)]
         public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; set; }
 
-        [Key(20)]
         public bool IgnoreVersionForFrameworkReferences { get; set; }
 
-        [Key(21)]
         public ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get; set; }
 
-        [Key(22)]
         public ReadOnlyTaskItem[] InstalledAssemblyTables { get; set; }
 
-        [Key(23)]
         public string[] LatestTargetFrameworkDirectories { get; set; }
 
-        [Key(24)]
         public string ProfileName { get; set; }
 
-        [Key(25)]
         public ReadOnlyTaskItem[] ResolvedSDKReferences { get; set; }
 
-        [Key(26)]
         public string[] SearchPaths { get; set; }
 
-        [Key(27)]
         public bool Silent { get; set; }
 
-        [Key(28)]
         public string StateFile { get; set; }
 
-        [Key(29)]
         public bool SupportsBindingRedirectGeneration { get; set; }
 
-        [Key(30)]
         public string TargetedRuntimeVersion { get; set; }
 
-        [Key(31)]
         public string[] TargetFrameworkDirectories { get; set; }
 
-        [Key(32)]
         public string TargetFrameworkMoniker { get; set; }
 
-        [Key(33)]
         public string TargetFrameworkMonikerDisplayName { get; set; }
 
-        [Key(34)]
         public string[] TargetFrameworkSubsets { get; set; }
 
-        [Key(35)]
         public string TargetFrameworkVersion { get; set; }
 
-        [Key(36)]
         public string TargetProcessorArchitecture { get; set; }
 
-        [Key(37)]
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; set; }
 
-        [Key(38)]
         public bool UseResolveAssemblyReferenceService { get; set; }
 
-        [Key(39)]
         public string WarnOrErrorOnTargetArchitectureMismatch { get; set; }
 
-        [Key(40)]
         public string CurrentPath { get; set; }
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
index 2a61280d28e..ddf90a648ea 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
@@ -1,12 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using MessagePack;
-
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    [MessagePackObject]
-    public sealed class ResolveAssemblyReferenceResponse
+    internal sealed class ResolveAssemblyReferenceResponse
     {
         public ResolveAssemblyReferenceResponse()
         {
@@ -25,47 +22,28 @@ internal ResolveAssemblyReferenceResponse(ResolveAssemblyReferenceTaskOutput out
             ScatterFiles = ReadOnlyTaskItem.CreateArray(output.ScatterFiles);
             SerializationAssemblyFiles = ReadOnlyTaskItem.CreateArray(output.SerializationAssemblyFiles);
             SuggestedRedirects = ReadOnlyTaskItem.CreateArray(output.SuggestedRedirects);
-            //Assemblies = ReadOnlyTaskItem.CreateArray(output.Assemblies);
-            //AssemblyFiles = ReadOnlyTaskItem.CreateArray(output.AssemblyFiles);
         }
 
-        [Key(0)]
         public ReadOnlyTaskItem[] CopyLocalFiles { get; set; }
 
-        [Key(1)]
         public string DependsOnNETStandard { get; set; }
 
-        [Key(2)]
         public string DependsOnSystemRuntime { get; set; }
 
-        [Key(3)]
         public ReadOnlyTaskItem[] FilesWritten { get; set; }
 
-        [Key(4)]
         public ReadOnlyTaskItem[] RelatedFiles { get; set; }
 
-        [Key(5)]
         public ReadOnlyTaskItem[] ResolvedDependencyFiles { get; set; }
 
-        [Key(6)]
         public ReadOnlyTaskItem[] ResolvedFiles { get; set; }
 
-        [Key(7)]
         public ReadOnlyTaskItem[] SatelliteFiles { get; set; }
 
-        [Key(8)]
         public ReadOnlyTaskItem[] ScatterFiles { get; set; }
 
-        [Key(9)]
         public ReadOnlyTaskItem[] SerializationAssemblyFiles { get; set; }
 
-        [Key(10)]
         public ReadOnlyTaskItem[] SuggestedRedirects { get; set; }
-
-        //[Key(11)]
-        //public ReadOnlyTaskItem[] Assemblies { get; set; }
-
-        //[Key(12)]
-        //public ReadOnlyTaskItem[] AssemblyFiles { get; set; }
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
index 28323b670f8..f4a08eb3358 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
@@ -1,15 +1,13 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
 using MessagePack;
 using Microsoft.Build.Framework;
-using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    // MessagePack requires transported objects to be public
-    [MessagePackObject]
-    public sealed class ResolveAssemblyReferenceResult
+    internal sealed class ResolveAssemblyReferenceResult
     {
         public ResolveAssemblyReferenceResult()
         {
@@ -22,34 +20,24 @@ internal ResolveAssemblyReferenceResult(bool taskResult, ResolveAssemblyReferenc
             Request = new ResolveAssemblyReferenceRequest(input);
         }
 
-        [Key(0)]
         public bool TaskResult { get; set; }
-        [Key(1)]
+
         public ResolveAssemblyReferenceResponse Response { get; set; }
 
-        [Key(2)]
         public int EventCount { get; set; }
 
-        [Key(3)]
         public List<CustomBuildEventArgs> CustomBuildEvents { get; set; }
 
-        [Key(4)]
         public List<BuildErrorEventArgs> BuildErrorEvents { get; set; }
 
-        [Key(5)]
         public List<BuildMessageEventArgs> BuildMessageEvents { get; set; }
 
-        [Key(6)]
         public List<BuildWarningEventArgs> BuildWarningEvents { get; set; }
 
-
-        [Key(7)]
         public ResolveAssemblyReferenceRequest Request { get; set; }
 
-        [IgnoreMember]
         internal ResolveAssemblyReferenceTaskOutput Output => new ResolveAssemblyReferenceTaskOutput(Response);
 
-        [IgnoreMember]
         internal ResolveAssemblyReferenceTaskInput InputOutput => new ResolveAssemblyReferenceTaskInput(Request);
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs
index 873270475d0..95267d464c3 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using MessagePack;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
@@ -25,8 +24,6 @@ public ResolveAssemblyReferenceTaskOutput(ResolveAssemblyReferenceResponse respo
             ScatterFiles = ReadOnlyTaskItem.ToTaskItem(response.ScatterFiles);
             SerializationAssemblyFiles = ReadOnlyTaskItem.ToTaskItem(response.SerializationAssemblyFiles);
             SuggestedRedirects = ReadOnlyTaskItem.ToTaskItem(response.SuggestedRedirects);
-            //Assemblies = ReadOnlyTaskItem.ToTaskItem(response.Assemblies);
-            //AssemblyFiles = ReadOnlyTaskItem.ToTaskItem(response.AssemblyFiles);
         }
 
         public ITaskItem[] CopyLocalFiles { get; set; }
@@ -50,9 +47,5 @@ public ResolveAssemblyReferenceTaskOutput(ResolveAssemblyReferenceResponse respo
         public ITaskItem[] SerializationAssemblyFiles { get; set; }
 
         public ITaskItem[] SuggestedRedirects { get; set; }
-
-        //public ITaskItem[] Assemblies { get; set; }
-
-        //public ITaskItem[] AssemblyFiles { get; set; }
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs
index 0eb4bf41e66..106ebb9f9bf 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs
@@ -17,54 +17,66 @@ internal sealed class BuildEventArgsFormatter
 
         private BuildEventArgsFormatter() { }
 
-        private bool DeserializeBase(ref MessagePackReader reader, out string message, out string helpKeyword, out string senderName)
+        BuildWarningEventArgs IMessagePackFormatter<BuildWarningEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
         {
-            message = null;
-            helpKeyword = null;
-            senderName = null;
-
             if (reader.TryReadNil())
             {
-                return true;
+                return null;
             }
 
-            message = reader.ReadString();
-            helpKeyword = reader.ReadString();
-            senderName = reader.ReadString();
-
-            return false;
-        }
-
-        private bool SerializeBase(ref MessagePackWriter wrtier, BuildEventArgs buildEvent)
-        {
-            if (buildEvent == null)
+            options.Security.DepthStep(ref reader);
+            int length = reader.ReadArrayHeader();
+            string message = null;
+            string helpKeyword = null;
+            string senderName = null;
+            int columnNumber = default;
+            int endColumnNumber = default;
+            int endLineNumber = default;
+            int lineNumber = default;
+            string code = default;
+            string file = default;
+            string subCategory = default;
+
+            for (int key = 0; key < length; key++)
             {
-                wrtier.WriteNil();
-                return true;
+                switch (key)
+                {
+                    case 0:
+                        message = reader.ReadString();
+                        break;
+                    case 1:
+                        helpKeyword = reader.ReadString();
+                        break;
+                    case 2:
+                        senderName = reader.ReadString();
+                        break;
+                    case 3:
+                        columnNumber = reader.ReadInt32();
+                        break;
+                    case 4:
+                        endColumnNumber = reader.ReadInt32();
+                        break;
+                    case 5:
+                        endLineNumber = reader.ReadInt32();
+                        break;
+                    case 6:
+                        lineNumber = reader.ReadInt32();
+                        break;
+                    case 7:
+                        code = reader.ReadString();
+                        break;
+                    case 8:
+                        file = reader.ReadString();
+                        break;
+                    case 9:
+                        subCategory = reader.ReadString();
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
             }
 
-            wrtier.Write(buildEvent.Message);
-            wrtier.Write(buildEvent.HelpKeyword);
-            wrtier.Write(buildEvent.SenderName);
-
-            return false;
-        }
-
-
-        BuildWarningEventArgs IMessagePackFormatter<BuildWarningEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
-        {
-            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
-            {
-                return null;
-            }
-
-            string code = reader.ReadString();
-            int columnNumber = reader.ReadInt32();
-            int endColumnNumber = reader.ReadInt32();
-            int endLineNumber = reader.ReadInt32();
-            string file = reader.ReadString();
-            int lineNumber = reader.ReadInt32();
-            string subCategory = reader.ReadString();
 
             BuildWarningEventArgs buildEvent =
                 new BuildWarningEventArgs(
@@ -79,39 +91,91 @@ BuildWarningEventArgs IMessagePackFormatter<BuildWarningEventArgs>.Deserialize(r
                         helpKeyword,
                         senderName);
 
+            reader.Depth--;
+
             return buildEvent;
         }
 
         void IMessagePackFormatter<BuildWarningEventArgs>.Serialize(ref MessagePackWriter writer, BuildWarningEventArgs value, MessagePackSerializerOptions options)
         {
-            if (SerializeBase(ref writer, value))
+            if (value == null)
             {
+                writer.WriteNil();
                 return;
             }
 
+            writer.WriteArrayHeader(10);
+            writer.Write(value.Message);
+            writer.Write(value.HelpKeyword);
+            writer.Write(value.SenderName);
+            writer.Write(value.ColumnNumber);
+            writer.Write(value.EndColumnNumber);
+            writer.Write(value.EndLineNumber);
+            writer.Write(value.LineNumber);
             writer.Write(value.Code);
-            writer.WriteInt32(value.ColumnNumber);
-            writer.WriteInt32(value.EndColumnNumber);
-            writer.WriteInt32(value.EndLineNumber);
             writer.Write(value.File);
-            writer.WriteInt32(value.LineNumber);
             writer.Write(value.Subcategory);
         }
 
         BuildErrorEventArgs IMessagePackFormatter<BuildErrorEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
         {
-            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            if (reader.TryReadNil())
             {
                 return null;
             }
 
-            string code = reader.ReadString();
-            int columnNumber = reader.ReadInt32();
-            int endColumnNumber = reader.ReadInt32();
-            int endLineNumber = reader.ReadInt32();
-            string file = reader.ReadString();
-            int lineNumber = reader.ReadInt32();
-            string subCategory = reader.ReadString();
+            options.Security.DepthStep(ref reader);
+            int length = reader.ReadArrayHeader();
+            string message = null;
+            string helpKeyword = null;
+            string senderName = null;
+            int columnNumber = default;
+            int endColumnNumber = default;
+            int endLineNumber = default;
+            int lineNumber = default;
+            string code = default;
+            string file = default;
+            string subCategory = default;
+
+            for (int key = 0; key < length; key++)
+            {
+                switch (key)
+                {
+                    case 0:
+                        message = reader.ReadString();
+                        break;
+                    case 1:
+                        helpKeyword = reader.ReadString();
+                        break;
+                    case 2:
+                        senderName = reader.ReadString();
+                        break;
+                    case 3:
+                        columnNumber = reader.ReadInt32();
+                        break;
+                    case 4:
+                        endColumnNumber = reader.ReadInt32();
+                        break;
+                    case 5:
+                        endLineNumber = reader.ReadInt32();
+                        break;
+                    case 6:
+                        lineNumber = reader.ReadInt32();
+                        break;
+                    case 7:
+                        code = reader.ReadString();
+                        break;
+                    case 8:
+                        file = reader.ReadString();
+                        break;
+                    case 9:
+                        subCategory = reader.ReadString();
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
 
             BuildErrorEventArgs buildEvent =
                 new BuildErrorEventArgs(
@@ -125,6 +189,7 @@ BuildErrorEventArgs IMessagePackFormatter<BuildErrorEventArgs>.Deserialize(ref M
                         message,
                         helpKeyword,
                         senderName);
+            reader.Depth--;
 
             return buildEvent;
         }
@@ -132,42 +197,129 @@ BuildErrorEventArgs IMessagePackFormatter<BuildErrorEventArgs>.Deserialize(ref M
 
         void IMessagePackFormatter<BuildErrorEventArgs>.Serialize(ref MessagePackWriter writer, BuildErrorEventArgs value, MessagePackSerializerOptions options)
         {
-            if (SerializeBase(ref writer, value))
+            if (value == null)
             {
+                writer.WriteNil();
                 return;
             }
 
+            writer.WriteArrayHeader(10);
+            writer.Write(value.Message);
+            writer.Write(value.HelpKeyword);
+            writer.Write(value.SenderName);
+            writer.Write(value.ColumnNumber);
+            writer.Write(value.EndColumnNumber);
+            writer.Write(value.EndLineNumber);
+            writer.Write(value.LineNumber);
             writer.Write(value.Code);
-            writer.WriteInt32(value.ColumnNumber);
-            writer.WriteInt32(value.EndColumnNumber);
-            writer.WriteInt32(value.EndLineNumber);
             writer.Write(value.File);
-            writer.WriteInt32(value.LineNumber);
             writer.Write(value.Subcategory);
         }
 
         BuildMessageEventArgs IMessagePackFormatter<BuildMessageEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
         {
-            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            if (reader.TryReadNil())
             {
                 return null;
             }
 
-            int importance = reader.ReadInt32();
+            options.Security.DepthStep(ref reader);
+            int length = reader.ReadArrayHeader();
+            string message = null;
+            string helpKeyword = null;
+            string senderName = null;
+            int columnNumber = default;
+            int endColumnNumber = default;
+            int endLineNumber = default;
+            int lineNumber = default;
+            string code = default;
+            string file = default;
+            string subCategory = default;
+            int importance = default;
+
+            for (int key = 0; key < length; key++)
+            {
+                switch (key)
+                {
+                    case 0:
+                        message = reader.ReadString();
+                        break;
+                    case 1:
+                        helpKeyword = reader.ReadString();
+                        break;
+                    case 2:
+                        senderName = reader.ReadString();
+                        break;
+                    case 3:
+                        columnNumber = reader.ReadInt32();
+                        break;
+                    case 4:
+                        endColumnNumber = reader.ReadInt32();
+                        break;
+                    case 5:
+                        endLineNumber = reader.ReadInt32();
+                        break;
+                    case 6:
+                        lineNumber = reader.ReadInt32();
+                        break;
+                    case 7:
+                        code = reader.ReadString();
+                        break;
+                    case 8:
+                        file = reader.ReadString();
+                        break;
+                    case 9:
+                        subCategory = reader.ReadString();
+                        break;
+                    case 10:
+                        importance = reader.ReadInt32();
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
+
+            BuildMessageEventArgs buildEvent =
+               new BuildMessageEventArgs(
+                       subCategory,
+                       code,
+                       file,
+                       lineNumber,
+                       columnNumber,
+                       endLineNumber,
+                       endColumnNumber,
+                       message,
+                       helpKeyword,
+                       senderName,
+                       (MessageImportance)importance);
+            reader.Depth--;
 
-            return new BuildMessageEventArgs(message, helpKeyword, senderName, (MessageImportance)importance);
+            return buildEvent;
         }
 
         void IMessagePackFormatter<BuildMessageEventArgs>.Serialize(ref MessagePackWriter writer, BuildMessageEventArgs value, MessagePackSerializerOptions options)
         {
-            if (SerializeBase(ref writer, value))
+            if (value == null)
             {
+                writer.WriteNil();
                 return;
             }
 
             int importance = (int)value.Importance;
 
-            writer.WriteInt32(importance);
+            writer.WriteArrayHeader(11);
+            writer.Write(value.Message);
+            writer.Write(value.HelpKeyword);
+            writer.Write(value.SenderName);
+            writer.Write(value.ColumnNumber);
+            writer.Write(value.EndColumnNumber);
+            writer.Write(value.EndLineNumber);
+            writer.Write(value.LineNumber);
+            writer.Write(value.Code);
+            writer.Write(value.File);
+            writer.Write(value.Subcategory);
+            writer.Write(importance);
         }
 
         CustomBuildEventArgs IMessagePackFormatter<CustomBuildEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
@@ -193,7 +345,7 @@ CustomBuildEventArgs IMessagePackFormatter<CustomBuildEventArgs>.Deserialize(ref
 
         void IMessagePackFormatter<CustomBuildEventArgs>.Serialize(ref MessagePackWriter writer, CustomBuildEventArgs value, MessagePackSerializerOptions options)
         {
-            if(value == null)
+            if (value == null)
             {
                 writer.WriteNil();
                 return;
@@ -224,58 +376,136 @@ void IMessagePackFormatter<CustomBuildEventArgs>.Serialize(ref MessagePackWriter
 
         ExternalProjectStartedEventArgs IMessagePackFormatter<ExternalProjectStartedEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
         {
-            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            if (reader.TryReadNil())
             {
                 return null;
             }
 
-            string projectFile = reader.ReadString();
-            string targetNames = reader.ReadString();
+            options.Security.DepthStep(ref reader);
+            int length = reader.ReadArrayHeader();
+            string message = null;
+            string helpKeyword = null;
+            string senderName = null;
+            string projectFile = default;
+            string targetNames = default;
 
-            return new ExternalProjectStartedEventArgs(
-                   message,
-                   helpKeyword,
-                   senderName,
-                   projectFile,
-                   targetNames);
+            for (int key = 0; key < length; key++)
+            {
+                switch (key)
+                {
+                    case 0:
+                        message = reader.ReadString();
+                        break;
+                    case 1:
+                        helpKeyword = reader.ReadString();
+                        break;
+                    case 2:
+                        senderName = reader.ReadString();
+                        break;
+                    case 3:
+                        projectFile = reader.ReadString();
+                        break;
+                    case 4:
+                        targetNames = reader.ReadString();
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
+
+            ExternalProjectStartedEventArgs buildEvent =
+               new ExternalProjectStartedEventArgs(
+                       message,
+                       helpKeyword,
+                       senderName,
+                       projectFile,
+                       targetNames);
+            reader.Depth--;
+
+            return buildEvent;
         }
 
         void IMessagePackFormatter<ExternalProjectStartedEventArgs>.Serialize(ref MessagePackWriter writer, ExternalProjectStartedEventArgs value, MessagePackSerializerOptions options)
         {
-            if (SerializeBase(ref writer, value))
+            if (value == null)
             {
+                writer.WriteNil();
                 return;
             }
 
+            writer.WriteArrayHeader(5);
+            writer.Write(value.Message);
+            writer.Write(value.HelpKeyword);
+            writer.Write(value.SenderName);
             writer.Write(value.ProjectFile);
             writer.Write(value.TargetNames);
         }
 
         ExternalProjectFinishedEventArgs IMessagePackFormatter<ExternalProjectFinishedEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
         {
-            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            if (reader.TryReadNil())
             {
                 return null;
             }
 
-            string projectFile = reader.ReadString();
-            bool succeeded = reader.ReadBoolean();
+            options.Security.DepthStep(ref reader);
+            int length = reader.ReadArrayHeader();
+            string message = null;
+            string helpKeyword = null;
+            string senderName = null;
+            string projectFile = default;
+            bool succeeded = default;
 
-            return new ExternalProjectFinishedEventArgs(
-                    message,
-                    helpKeyword,
-                    senderName,
-                    projectFile,
-                    succeeded);
+            for (int key = 0; key < length; key++)
+            {
+                switch (key)
+                {
+                    case 0:
+                        message = reader.ReadString();
+                        break;
+                    case 1:
+                        helpKeyword = reader.ReadString();
+                        break;
+                    case 2:
+                        senderName = reader.ReadString();
+                        break;
+                    case 3:
+                        projectFile = reader.ReadString();
+                        break;
+                    case 4:
+                        succeeded = reader.ReadBoolean();
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
+
+            ExternalProjectFinishedEventArgs buildEvent =
+               new ExternalProjectFinishedEventArgs(
+                       message,
+                       helpKeyword,
+                       senderName,
+                       projectFile,
+                       succeeded);
+            reader.Depth--;
+
+            return buildEvent;
         }
 
         void IMessagePackFormatter<ExternalProjectFinishedEventArgs>.Serialize(ref MessagePackWriter writer, ExternalProjectFinishedEventArgs value, MessagePackSerializerOptions options)
         {
-            if (SerializeBase(ref writer, value))
+            if (value == null)
             {
+                writer.WriteNil();
                 return;
             }
 
+            writer.WriteArrayHeader(5);
+            writer.Write(value.Message);
+            writer.Write(value.HelpKeyword);
+            writer.Write(value.SenderName);
             writer.Write(value.ProjectFile);
             writer.Write(value.Succeeded);
         }
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
index 2008ab597df..60af623b2dd 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
@@ -1,7 +1,10 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
 using MessagePack;
 using MessagePack.Formatters;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
 {
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs
index 657c7f6b4bf..d2b02825252 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs
@@ -1,5 +1,6 @@
-using System;
-using System.Buffers;
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using MessagePack;
 using MessagePack.Formatters;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs
index f9be26bb7b4..98a0cebd9db 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs
@@ -1,5 +1,6 @@
-using System;
-using System.Buffers;
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using MessagePack;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs
index f9f13e107d8..6c228b71844 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs
@@ -1,5 +1,6 @@
-using System;
-using System.Buffers;
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System.Collections.Generic;
 using MessagePack;
 using MessagePack.Formatters;
diff --git a/src/Tasks/ResolveAssemblyReferences/ResolveAssemlyReferneceResolver.cs b/src/Tasks/ResolveAssemblyReferences/ResolveAssemlyReferneceResolver.cs
index 99f5f3eb77c..617489fbac7 100644
--- a/src/Tasks/ResolveAssemblyReferences/ResolveAssemlyReferneceResolver.cs
+++ b/src/Tasks/ResolveAssemblyReferences/ResolveAssemlyReferneceResolver.cs
@@ -1,3 +1,6 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System;
 using System.Collections.Generic;
 using MessagePack;
diff --git a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
index 49983dd639a..9510cf73e2c 100644
--- a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
@@ -2,14 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics;
 using System.IO;
 using System.IO.Pipes;
 using System.Threading;
 using System.Threading.Tasks;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;
@@ -76,9 +74,9 @@ public RarController(
                   streamFactory,
                   validateHandshakeCallback,
                   timeout: timeout,
-                  resolveAssemblyReferenceTaskHandler: //new ResolveAssemblyReferenceSerializedHandler(
+                  resolveAssemblyReferenceTaskHandler:
                       new ResolveAssemlyReferenceCacheHandler(
-                      new ResolveAssemblyReferenceHandler()))//)
+                      new ResolveAssemblyReferenceHandler()))
         {
         }
 
@@ -167,25 +165,10 @@ internal async Task HandleClientAsync(Stream serverStream, CancellationToken can
             }
         }
 
-        private class ConsoleLogger : TraceListener
-        {
-            public override void Write(string message)
-            {
-                Console.Write(message);
-            }
-
-            public override void WriteLine(string message)
-            {
-                Console.WriteLine(message);
-            }
-        }
-
         private JsonRpc GetRpcServer(Stream stream, IResolveAssemblyReferenceTaskHandler handler)
         {
             IJsonRpcMessageHandler serverHandler = RpcUtils.GetRarMessageHandler(stream);
             JsonRpc rpc = new JsonRpc(serverHandler, handler);
-            rpc.TraceSource = new TraceSource("Server", SourceLevels.Warning);
-            rpc.TraceSource.Listeners.Add(new ConsoleLogger()); 
             return rpc;
         }
 
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs
index d0749177fa0..ef8f739355f 100644
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs
@@ -1,12 +1,10 @@
-﻿using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System;
 using System.Collections;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
 {
@@ -18,8 +16,6 @@ internal sealed class ResolveAssemblyReferenceBuildEngine : IBuildEngine
         internal List<BuildWarningEventArgs> WarningBuildEvent { get; } = new List<BuildWarningEventArgs>();
         internal List<BuildErrorEventArgs> ErrorBuildEvent { get; } = new List<BuildErrorEventArgs>();
 
-        private readonly RegisteredTaskObjectCache _objectCache = new RegisteredTaskObjectCache(); 
-
         public bool AllowFailureWithoutError { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
 
         public bool IsRunningMultipleNodes => throw new NotImplementedException();
@@ -62,9 +58,5 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, IDict
         {
             throw new NotImplementedException();
         }
-
-        private class RegisteredTaskObjectCache : RegisteredTaskObjectCacheBase
-        {
-        }
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
index 81b53333fc7..9ea99c6fe54 100644
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
@@ -1,9 +1,8 @@
-﻿using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
 {
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceHandler.cs
index 8dc55933793..9f71d957728 100644
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceHandler.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceHandler.cs
@@ -1,53 +1,36 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Diagnostics;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
 using System.Threading;
 using System.Threading.Tasks;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
 {
     internal sealed class ResolveAssemblyReferenceHandler : IResolveAssemblyReferenceTaskHandler
     {
-        private ResolveAssemblyReferenceTaskOutput EmptyOutput => new ResolveAssemblyReference().ResolveAssemblyReferenceOutput;
-
-        private readonly ResolveAssemblyReference _task = new ResolveAssemblyReference();
-
-        private ResolveAssemblyReference GetResolveAssemblyReferenceTask(IBuildEngine buildEngine)
-        {
-            _task.BuildEngine = buildEngine;
-            _task.ResolveAssemblyReferenceOutput = EmptyOutput;
-
-            return _task;
-        }
-
         public Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default)
         {
-            return Task.FromResult(Execute(input));
-
+            return Task.Run(() => Execute(input), cancellationToken);
         }
 
         internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceRequest input)
         {
             ResolveAssemblyReferenceTaskInput taskInput = new ResolveAssemblyReferenceTaskInput(input);
             ResolveAssemblyReferenceBuildEngine buildEngine = new ResolveAssemblyReferenceBuildEngine();
-            ResolveAssemblyReference task = GetResolveAssemblyReferenceTask(buildEngine);
-            //ResolveAssemblyReference task = new ResolveAssemblyReference
-            //{
-            //    BuildEngine = buildEngine
-            //};
+            ResolveAssemblyReference task = new ResolveAssemblyReference
+            {
+                BuildEngine = buildEngine
+            };
 
             ResolveAssemblyReferenceResult result = task.Execute(taskInput);
+
             result.CustomBuildEvents = buildEngine.CustomBuildEvent;
             result.BuildMessageEvents = buildEngine.MessageBuildEvent;
             result.BuildWarningEvents = buildEngine.WarningBuildEvent;
             result.BuildErrorEvents = buildEngine.ErrorBuildEvent;
-
             result.EventCount = buildEngine.EventCount;
 
-            //System.Console.WriteLine("RAR task: {0}. Logged {1} events", result.TaskResult ? "Succeded" : "Failed", result.EventCount);
 
             return result;
         }
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceSerializedHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceSerializedHandler.cs
deleted file mode 100644
index 29c4a7c8617..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceSerializedHandler.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System.Threading;
-using System.Threading.Tasks;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-using Microsoft.VisualStudio.Threading;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
-{
-    internal sealed class ResolveAssemblyReferenceSerializedHandler : IResolveAssemblyReferenceTaskHandler
-    {
-        private const int MaxNumberOfConcurentClients = 1;
-
-        private readonly IResolveAssemblyReferenceTaskHandler _taskHandler;
-        private readonly AsyncSemaphore _semaphore;
-
-        public ResolveAssemblyReferenceSerializedHandler(IResolveAssemblyReferenceTaskHandler taskHandler)
-        {
-            _taskHandler = taskHandler;
-            _semaphore = new AsyncSemaphore(MaxNumberOfConcurentClients);
-        }
-
-        public ResolveAssemblyReferenceSerializedHandler() : this(new ResolveAssemblyReferenceHandler())
-        {
-        }
-
-        public async Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default)
-        {
-            using (await _semaphore.EnterAsync(cancellationToken))
-            {
-                NativeMethodsShared.SetCurrentDirectory(input.CurrentPath);
-                ResolveAssemblyReferenceResult result = await _taskHandler.ExecuteAsync(input, cancellationToken);
-                return result;
-            }
-        }
-
-        public void Dispose()
-        {
-            _semaphore?.Dispose();
-        }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemlyReferenceCacheHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemlyReferenceCacheHandler.cs
index feb5b60bfec..ecd471926aa 100644
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemlyReferenceCacheHandler.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemlyReferenceCacheHandler.cs
@@ -1,6 +1,8 @@
-﻿using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
@@ -66,12 +68,6 @@ public async Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyRe
             return result;
         }
 
-        private static void PrintDiagnostic(int requestId, Stopwatch stopwatch, bool cache)
-        {
-            stopwatch.Stop();
-            Console.WriteLine("{0}; Cached used: {1}; Elapsed: {2} ms", requestId, cache, stopwatch.ElapsedMilliseconds);
-        }
-
         public void Dispose()
         {
             _handler.Dispose();
