diff --git a/eng/Common.globalconfig b/eng/Common.globalconfig
index 3dbdf34b74d..cb71d55758c 100644
--- a/eng/Common.globalconfig
+++ b/eng/Common.globalconfig
@@ -714,7 +714,7 @@ dotnet_diagnostic.SA1003.severity = none
 dotnet_diagnostic.SA1004.severity = warning
 
 # Single line comment should begin with a space
-dotnet_diagnostic.SA1005.severity = suggestion
+dotnet_diagnostic.SA1005.severity = warning
 
 # Region should not be preceded by a space
 dotnet_diagnostic.SA1006.severity = warning
@@ -843,7 +843,7 @@ dotnet_diagnostic.SA1132.severity = warning
 dotnet_diagnostic.SA1133.severity = warning
 
 # Each attribute should be placed on its own line of code
-dotnet_diagnostic.SA1134.severity = suggestion
+dotnet_diagnostic.SA1134.severity = warning
 
 # Using directive should be qualified
 dotnet_diagnostic.SA1135.severity = warning
diff --git a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
index f653f343857..6c04b5ee80d 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
@@ -71,7 +71,7 @@ public void ProjectCommentFormatting()
         [Fact]
         public void ProjectWhitespaceFormatting()
         {
-            //  Note that there are two spaces after the <ItemGroup> tag on the second line
+            // Note that there are two spaces after the <ItemGroup> tag on the second line
             string content = ObjectModelHelpers.CleanupFileContents(@"
 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <ItemGroup>  
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index 6b9f84cd55a..bb8e40a0027 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -96,7 +96,7 @@ public void ReadNoChildren(string project)
                     </Project>
                 ")]
         // https://github.com/dotnet/msbuild/issues/900
-        //[InlineData(@"
+        // [InlineData(@"
         //            <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
         //                <Target Name='t'>
         //                    <ItemGroup>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectMetadataElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectMetadataElement_Tests.cs
index 5f728028be7..77402ebc077 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectMetadataElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectMetadataElement_Tests.cs
@@ -641,7 +641,7 @@ public void UpdateMetadataValueAsAttributeOnItemDefinition()
             VerifyAssertLineByLine(expected, actual);
         }
 
-        //  NOTE: When https://github.com/dotnet/msbuild/issues/362 is fixed, then the expected value in XML may be:
+        // NOTE: When https://github.com/dotnet/msbuild/issues/362 is fixed, then the expected value in XML may be:
         //      &lt;&amp;>"
         //  instead of:
         //      &lt;&amp;&gt;&quot;
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index a677b57eebf..13a54b102e4 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -1026,7 +1026,7 @@ public void SolutionCorrupt()
         /// Open lots of projects concurrently to try to trigger problems
         /// </summary>
         [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]  //This test is platform specific for Windows
+        [PlatformSpecific(TestPlatforms.Windows)]  // This test is platform specific for Windows
         public void ConcurrentProjectOpenAndCloseThroughProject()
         {
             int iterations = 500;
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index c32b0e8e748..4d175d5a424 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -781,12 +781,12 @@ private static void TestIncludeExclude(string projectContents, string[] inputFil
         // exclude matches include; file is next to project file
         [InlineData(ItemWithIncludeAndExclude,
             @"a", // include item
-            @"", //path relative from projectFile. Empty string if current directory
+            @"", // path relative from projectFile. Empty string if current directory
 
-            @"a", //exclude item
-            "", //path relative from projectFile. Empty string if current directory
+            @"a", // exclude item
+            "", // path relative from projectFile. Empty string if current directory
 
-            new[] //files relative to this test's root directory. The project is one level deeper than the root.
+            new[] // files relative to this test's root directory. The project is one level deeper than the root.
             {
                 @"project\a",
             },
@@ -2095,7 +2095,7 @@ public void SetDirectMetadataShouldUpdateAlreadyExistingDirectMetadata()
             }
         }
 
-        //  TODO: Should remove tests go in project item tests, project item instance tests, or both?
+        // TODO: Should remove tests go in project item tests, project item instance tests, or both?
         [Fact]
         public void Remove()
         {
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index ff12bb8818a..8bcf74cfe06 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -2054,7 +2054,7 @@ public void BuildDisabled()
 
             result.ShouldBeFalse();
 
-            mockLogger.Errors[0].Code.ShouldBe("MSB4112"); //                 "Security message about disabled targets need to have code MSB4112, because code in the VS Core project system depends on this.  See DesignTimeBuildFeedback.cpp."
+            mockLogger.Errors[0].Code.ShouldBe("MSB4112"); // "Security message about disabled targets need to have code MSB4112, because code in the VS Core project system depends on this.  See DesignTimeBuildFeedback.cpp."
         }
 
         /// <summary>
@@ -2116,9 +2116,9 @@ public void BuildEvaluationUsesCustomLoggers()
 
             result.ShouldBeTrue();
 
-            mockLogger.WarningCount.ShouldBe(0); //                 "Log should not contain MSB4011 because the build logger will not receive evaluation messages."
+            mockLogger.WarningCount.ShouldBe(0); // "Log should not contain MSB4011 because the build logger will not receive evaluation messages."
 
-            collectionLogger.Warnings[0].Code.ShouldBe("MSB4011"); //                 "Log should contain MSB4011 because the project collection logger should have been used for evaluation."
+            collectionLogger.Warnings[0].Code.ShouldBe("MSB4011"); // "Log should contain MSB4011 because the project collection logger should have been used for evaluation."
         }
 
         /// <summary>
@@ -3679,25 +3679,25 @@ public void GetAllGlobsShouldFindAllExcludesAndRemoves()
         }
 
         [Theory]
-//        [InlineData(
+// [InlineData(
 //            @"
-//<A Include=`a;b*;c*;d*;e*;f*` Exclude=`c*;d*`/>
-//<A Remove=`e*;f*`/>
-//",
+// <A Include=`a;b*;c*;d*;e*;f*` Exclude=`c*;d*`/>
+// <A Remove=`e*;f*`/>
+// ",
 //        new[] {"ba"},
 //        new[] {"a", "ca", "da", "ea", "fa"}
 //        )]
 //        [InlineData(
 //            @"
-//<A Include=`a;b*;c*;d*;e*;f*` Exclude=`c*;d*`/>
-//",
+// <A Include=`a;b*;c*;d*;e*;f*` Exclude=`c*;d*`/>
+// ",
 //        new[] {"ba", "ea", "fa"},
 //        new[] {"a", "ca", "da"}
 //        )]
 //        [InlineData(
 //            @"
-//<A Include=`a;b*;c*;d*;e*;f*`/>
-//",
+// <A Include=`a;b*;c*;d*;e*;f*`/>
+// ",
 //        new[] {"ba", "ca", "da", "ea", "fa"},
 //        new[] {"a"}
 //        )]
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
index ad4ef0979e1..62dba852a43 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
@@ -171,8 +171,8 @@ private void CopyFromInternal(ProjectRootElement sourceProject)
             // children are not copied.
             Assert.Empty(newCopyFrom.View.Items);
             // but attributes are (even non standard)
-            //Assert.Equal("2", ProjectElementLink.GetAttributeValue(existingItemGroup, "FunnyAttribute", true));
-            //Assert.Equal("2", ProjectElementLink.GetAttributeValue(newCopyFrom.View, "FunnyAttribute", true));
+            // Assert.Equal("2", ProjectElementLink.GetAttributeValue(existingItemGroup, "FunnyAttribute", true));
+            // Assert.Equal("2", ProjectElementLink.GetAttributeValue(newCopyFrom.View, "FunnyAttribute", true));
             newCopyFrom.VerifyNotSame(ourGroup1);
 
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
index 23839cbbd6a..6b9da4a89be 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectRootElementLink.cs
@@ -36,7 +36,7 @@ public override ProjectElement ImportImpl(ProjectCollectionLinker remote)
         public string DirectoryPath => this.ProjectXml.DirectoryPath;
         public string FullPath { get => this.ProjectXml.FullPath; set => this.ProjectXml.FullPath = value; }
         public ElementLocation ProjectFileLocation => this.ProjectXml.ProjectFileLocation;
-        public Encoding Encoding => this.ProjectXml.Encoding; //!! more complicated in reality when passing cross process.
+        public Encoding Encoding => this.ProjectXml.Encoding; // !! more complicated in reality when passing cross process.
         public string RawXml => this.ProjectXml.RawXml;
         public bool PreserveFormatting => this.ProjectXml.PreserveFormatting;
         public MockProjectChooseElementLinkRemoter CreateChooseElement()
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 63018958d65..98d9ffdd515 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -429,8 +429,8 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTargetFinished.Succeeded, rightTargetFinished.Succeeded);
                     Assert.Equal(leftTargetFinished.TargetFile, rightTargetFinished.TargetFile);
                     Assert.Equal(leftTargetFinished.TargetName, rightTargetFinished.TargetName);
-                    //TODO: target output translation is a special case and is done in TranslateTargetFinishedEvent
-                    //Assert.Equal(leftTargetFinished.TargetOutputs, rightTargetFinished.TargetOutputs);
+                    // TODO: target output translation is a special case and is done in TranslateTargetFinishedEvent
+                    // Assert.Equal(leftTargetFinished.TargetOutputs, rightTargetFinished.TargetOutputs);
                     break;
 
                 case LoggingEventType.TargetStartedEvent:
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 759f74f14e0..55e51e5823b 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -71,8 +71,8 @@ public SdkResultOutOfProc_Tests(ITestOutputHelper output)
             // Need to set this env variable to enable Process.GetCurrentProcess().Id in the project file.
             _env.SetEnvironmentVariable("MSBUILDENABLEALLPROPERTYFUNCTIONS", "1");
 
-            //  Set this if you need to debug the out of process build
-            //_env.SetEnvironmentVariable("MSBUILDDEBUGONSTART", "1");
+            // Set this if you need to debug the out of process build
+            // _env.SetEnvironmentVariable("MSBUILDDEBUGONSTART", "1");
         }
 
         public void Dispose()
@@ -127,7 +127,7 @@ public void RunOutOfProcBuild()
             ValidateResolverResults(result);
         }
 
-        //  Test scenario where using an SdkResolver in a project that hasn't been evaluated
+        // Test scenario where using an SdkResolver in a project that hasn't been evaluated
         //  in the main node (which is where the SdkResolver runs).  This validates that
         //  the SdkResult is correctly transferred between nodes.
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index 03ef9611f6d..fe372c03fda 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -975,7 +975,7 @@ internal string CustomMessage
         /// </summary>
         internal class MyCustomBuildEventArgsNotSerializable : CustomBuildEventArgs
         {
-            //  If binary serialization is not available, then we use a simple serializer which relies on a default constructor.  So to test
+            // If binary serialization is not available, then we use a simple serializer which relies on a default constructor.  So to test
             //  what happens for an event that's not serializable, don't include a default constructor.
             /// <summary>
             /// Default constructor
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index e72b97ed626..e73b77312b4 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -1207,7 +1207,7 @@ public void SingleLineFormatNoop()
 
             string ss = cl.IndentString(s, 0);
 
-            //should be a no-op
+            // should be a no-op
             ss.ShouldBe($"foo{Environment.NewLine}");
         }
 
@@ -1221,7 +1221,7 @@ public void MultilineFormatWindowsLineEndings()
 
             string ss = cl.IndentString(s, 4);
 
-            //should convert lines to system format
+            // should convert lines to system format
             ss.ShouldBe($"    foo{Environment.NewLine}    bar{Environment.NewLine}    baz{Environment.NewLine}    {Environment.NewLine}");
         }
 
@@ -1233,7 +1233,7 @@ public void MultilineFormatUnixLineEndings()
 
             string ss = cl.IndentString(s, 0);
 
-            //should convert lines to system format
+            // should convert lines to system format
             ss.ShouldBe($"foo{Environment.NewLine}bar{Environment.NewLine}baz{Environment.NewLine}{Environment.NewLine}");
         }
 
@@ -1247,7 +1247,7 @@ public void MultilineFormatMixedLineEndings()
 
             string ss = cl.IndentString(s, 0);
 
-            //should convert lines to system format
+            // should convert lines to system format
             ss.ShouldBe($"foo{Environment.NewLine}{Environment.NewLine}bar{Environment.NewLine}baz{Environment.NewLine}{Environment.NewLine}{Environment.NewLine}jazz{Environment.NewLine}razz{Environment.NewLine}{Environment.NewLine}matazz{Environment.NewLine}end{Environment.NewLine}");
         }
 
@@ -1262,7 +1262,7 @@ public void NestedProjectMinimal()
 
             es.Consume(new BuildStartedEventArgs("bs", null));
 
-            //Clear time dependent build started message
+            // Clear time dependent build started message
             sc.Clear();
 
             es.Consume(new ProjectStartedEventArgs("ps1", null, "fname1", "", null, null));
@@ -1303,7 +1303,7 @@ public void NestedProjectNormal()
             es.Consume(new BuildStartedEventArgs("bs", null));
 
 
-            //Clear time dependent build started message
+            // Clear time dependent build started message
             sc.Clear();
 
             es.Consume(new ProjectStartedEventArgs("ps1", null, "fname1", "", null, null));
@@ -1941,7 +1941,7 @@ public void ResetConsoleLoggerStateTestBasic()
         {
             // Create an event source
             EventSourceSink es = new EventSourceSink();
-            //Create a simulated console
+            // Create a simulated console
             SimulatedConsole sc = new SimulatedConsole();
 
             // error and warning string for 1 error and 1 warning
@@ -2031,7 +2031,7 @@ public void ResetConsoleLoggerState_Initialize()
         {
             // Create an event source
             EventSourceSink es = new EventSourceSink();
-            //Create a simulated console
+            // Create a simulated console
             SimulatedConsole sc = new SimulatedConsole();
 
             // error and warning string for 1 error and 1 warning
@@ -2121,7 +2121,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
             for (int i = 1; i <= 2; i++)
             {
                 EventSourceSink es = new EventSourceSink();
-                //Create a simulated console
+                // Create a simulated console
                 SimulatedConsole sc = new SimulatedConsole();
                 // Create a ConsoleLogger with Normal verbosity
                 ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Normal, sc.Write, sc.SetColor, sc.ResetColor);
@@ -2137,7 +2137,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
 
                 // BuildStarted Event
                 es.Consume(new BuildStartedEventArgs("bs", null));
-                //Project Started Event
+                // Project Started Event
                 ProjectStartedEventArgs project1Started = new ProjectStartedEventArgs(1, null, null, "p", "t", null, null, new BuildEventContext(BuildEventContext.InvalidNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId));
                 project1Started.BuildEventContext = new BuildEventContext(1, 1, 1, 1);
                 es.Consume(project1Started);
@@ -2166,7 +2166,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
                 es.Consume(targetFinished1);
 
                 ProjectStartedEventArgs project2Started = new ProjectStartedEventArgs(2, null, null, "p2", "t2", null, null, project1Started.BuildEventContext);
-                //Project Started Event
+                // Project Started Event
                 project2Started.BuildEventContext = new BuildEventContext(2, 2, 2, 2);
                 es.Consume(project2Started);
                 TargetStartedEventArgs targetStarted2 = new TargetStartedEventArgs(null, null, "t2", null, null);
@@ -2246,7 +2246,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
         public void DeferredMessages()
         {
             EventSourceSink es = new EventSourceSink();
-            //Create a simulated console
+            // Create a simulated console
             SimulatedConsole sc = new SimulatedConsole();
             // Create a ConsoleLogger with Detailed verbosity
             ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Detailed, sc.Write, sc.SetColor, sc.ResetColor);
@@ -2298,11 +2298,11 @@ public void VerifyMPLoggerSwitch()
             for (int i = 0; i < 2; i++)
             {
                 EventSourceSink es = new EventSourceSink();
-                //Create a simulated console
+                // Create a simulated console
                 SimulatedConsole sc = new SimulatedConsole();
                 // Create a ConsoleLogger with Normal verbosity
                 ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Normal, sc.Write, sc.SetColor, sc.ResetColor);
-                //Make sure the MPLogger switch will property work on both Initialize methods
+                // Make sure the MPLogger switch will property work on both Initialize methods
                 L.Parameters = "EnableMPLogging";
                 if (i == 0)
                 {
@@ -2337,7 +2337,7 @@ public void VerifyMPLoggerSwitch()
         public void TestPrintTargetNamePerMessage()
         {
             EventSourceSink es = new EventSourceSink();
-            //Create a simulated console
+            // Create a simulated console
             SimulatedConsole sc = new SimulatedConsole();
             // Create a ConsoleLogger with Normal verbosity
             ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Normal, sc.Write, sc.SetColor, sc.ResetColor);
@@ -2391,7 +2391,7 @@ public void TestNewLineAfterProjectFinished()
 
 
                 EventSourceSink es = new EventSourceSink();
-                //Create a simulated console
+                // Create a simulated console
                 SimulatedConsole sc = new SimulatedConsole();
                 ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Normal, sc.Write, sc.SetColor, sc.ResetColor);
 
diff --git a/src/Build.UnitTests/ConsoleOutputAlignerTests.cs b/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
index 9657a96c825..8c5db6c2e03 100644
--- a/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
+++ b/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
@@ -300,67 +300,67 @@ public void TabsMakesItJustOverLimit_IndentAndAlign(string prefix, string input,
         }
 
         [Theory]
-        //+----+----+---+---+---+---+---+---+
-        //| 1  | 2  | 3 | 4 | 5 | 6 | 7 | 8 |
-        //+----+----+---+---+---+---+---+---+
-        //| \t | .  | . | . | . | . | . | . |
-        //+----+----+---+---+---+---+---+---+
-        //| 1  |    |   |   |   |   |   |   |
-        //+----+----+---+---+---+---+---+---+
-        //| a  | \t | . | . | . | . | . | . |
-        //+----+----+---+---+---+---+---+---+
-        //| b  |    |   |   |   |   |   |   |
-        //+----+----+---+---+---+---+---+---+
+        // +----+----+---+---+---+---+---+---+
+        // | 1  | 2  | 3 | 4 | 5 | 6 | 7 | 8 |
+        // +----+----+---+---+---+---+---+---+
+        // | \t | .  | . | . | . | . | . | . |
+        // +----+----+---+---+---+---+---+---+
+        // | 1  |    |   |   |   |   |   |   |
+        // +----+----+---+---+---+---+---+---+
+        // | a  | \t | . | . | . | . | . | . |
+        // +----+----+---+---+---+---+---+---+
+        // | b  |    |   |   |   |   |   |   |
+        // +----+----+---+---+---+---+---+---+
         [InlineData("", "\t1\na\tb", "\t\n1\na\t\nb\n",  8, false)]
-        //+---+---+---+----+---+---+---+---+----+
-        //| 1 | 2 | 3 | 4  | 5 | 6 | 7 | 8 | 9  |
-        //+---+---+---+----+---+---+---+---+----+
-        //| 1 | 2 | 3 | 4  | 5 | 6 | 7 | 8 | \t |
-        //+---+---+---+----+---+---+---+---+----+
-        //| a | b | c |    |   |   |   |   |    |
-        //+---+---+---+----+---+---+---+---+----+
-        //| d | e | f | \t | . | . | . | . | g  |
-        //+---+---+---+----+---+---+---+---+----+
+        // +---+---+---+----+---+---+---+---+----+
+        // | 1 | 2 | 3 | 4  | 5 | 6 | 7 | 8 | 9  |
+        // +---+---+---+----+---+---+---+---+----+
+        // | 1 | 2 | 3 | 4  | 5 | 6 | 7 | 8 | \t |
+        // +---+---+---+----+---+---+---+---+----+
+        // | a | b | c |    |   |   |   |   |    |
+        // +---+---+---+----+---+---+---+---+----+
+        // | d | e | f | \t | . | . | . | . | g  |
+        // +---+---+---+----+---+---+---+---+----+
         [InlineData("", "12345678\tabc\ndef\tg", "12345678\t\nabc\ndef\tg\n", 9, false)]
-        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| 1  | 2 | 3 | 4  | 5 | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
-        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| \t | . | . | .  | . | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | a  |
-        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| b  | c |   |    |   |   |   |   |    |    |    |    |    |    |    |    |    |
-        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| d  | e | f | \t | . | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
-        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| h  | i |   |    |   |   |   |   |    |    |    |    |    |    |    |    |    |
-        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        // +----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | 1  | 2 | 3 | 4  | 5 | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
+        // +----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | \t | . | . | .  | . | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | a  |
+        // +----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | b  | c |   |    |   |   |   |   |    |    |    |    |    |    |    |    |    |
+        // +----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | d  | e | f | \t | . | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
+        // +----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | h  | i |   |    |   |   |   |   |    |    |    |    |    |    |    |    |    |
+        // +----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
         [InlineData("", "\t\tabc\ndef\t\tghi", "\t\ta\nbc\ndef\t\tg\nhi\n", 17, false)]
-        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| 1 | 2 | 3  | 4 | 5  | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
-        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | a | \t | . | .  | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | b  |
-        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | c |    |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
-        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | d | e  | f | \t | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
-        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | h | i  | 5 | 6  | 7 | 8 | 9  | 0 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |
-        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | 9 |    |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
-        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // +---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | 1 | 2 | 3  | 4 | 5  | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
+        // +---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | a | \t | . | .  | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | b  |
+        // +---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | c |    |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
+        // +---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | d | e  | f | \t | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
+        // +---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | h | i  | 5 | 6  | 7 | 8 | 9  | 0 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |
+        // +---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | 9 |    |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
+        // +---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
         [InlineData(" ", "a\t\tbc\ndef\t\tghi567890123456789", " a\t\tb\n c\n def\t\tg\n hi56789012345678\n 9\n", 17, false)]
-        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| 1 | 2  | 3 | 4 | 5  | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
-        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| a | \t | . | . | .  | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | b  |
-        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | c  |   |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
-        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | d  | e | f | \t | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
-        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | h  | i | 5 | 6  | 7 | 8 | 9 | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |
-        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
-        //| _ | 9  |   |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
-        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // +---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | 1 | 2  | 3 | 4 | 5  | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
+        // +---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | a | \t | . | . | .  | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | b  |
+        // +---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | c  |   |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
+        // +---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | d  | e | f | \t | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
+        // +---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | h  | i | 5 | 6  | 7 | 8 | 9 | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |
+        // +---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        // | _ | 9  |   |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
+        // +---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
         [InlineData(" ", "a\t\tbc\ndef\t\tghi567890123456789", "a\t\tb\n c\n def\t\tg\n hi56789012345678\n 9\n", 17, true)]
         public void MultiLinesOverLimit_IndentAndAlign(string prefix, string input, string expected, int bufferWidthWithoutNewLine, bool prefixAlreadyWritten)
         {
diff --git a/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
index dce65c09acb..08b5820f23c 100644
--- a/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -69,7 +69,7 @@ public void ProjectLoadedPreservingCommentsAndWhiteSpaceIsNotReadOnly()
             {
                 // reset all hooks
                 XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
-                env.SetEnvironmentVariable("MSBUILDLOADALLFILESASREADONLY", null); //clear
+                env.SetEnvironmentVariable("MSBUILDLOADALLFILESASREADONLY", null); // clear
                 env.SetEnvironmentVariable("MSBuildLoadMicrosoftTargetsReadOnly", null); // clear
                 env.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", null); // clear
                 var testFiles = env.CreateTestProjectWithFiles(projectContents, Array.Empty<string>());
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 347e2bbab77..d2ab15a93eb 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -175,7 +175,7 @@ public void ParseEtpProject()
                             EndProjectSection
                         EndProject";
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-                //Project should get added to the solution
+                // Project should get added to the solution
                 solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"someproj.etp");
                 solution.ProjectsInOrder[1].RelativePath.ShouldBe(@"ClassLibrary2.csproj");
             }
@@ -365,7 +365,7 @@ public void ParseNestedEtpProjectSingleLevel()
                         EndProject";
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-                //Project should get added to the solution
+                // Project should get added to the solution
                 solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"someproj.etp");
                 solution.ProjectsInOrder[1].RelativePath.ShouldBe(@"someproj2.etp");
                 solution.ProjectsInOrder[2].RelativePath.ShouldBe(@"ClassLibrary1.csproj");
@@ -566,7 +566,7 @@ public void ParseNestedEtpProjectMultipleLevel()
                         </References>
                     </GENERAL>
                 </EFPROJECT>";
-                //Create the directory for the third project
+                // Create the directory for the third project
                 Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), "ETPProjUpgradeTest"));
                 File.WriteAllText(proj3Path, etpProjContent);
 
@@ -580,7 +580,7 @@ public void ParseNestedEtpProjectMultipleLevel()
                         EndProject";
                 SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
-                //Project should get added to the solution
+                // Project should get added to the solution
                 solution.ProjectsInOrder[0].RelativePath.ShouldBe(@"someproj.etp");
                 solution.ProjectsInOrder[1].RelativePath.ShouldBe(@"someproj2.etp");
                 solution.ProjectsInOrder[2].RelativePath.ShouldBe(@"ETPProjUpgradeTest\someproj3.etp");
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index c38448378d0..44a8a18a6a6 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -1721,7 +1721,7 @@ public void SolutionGeneratorCanEmitSolutions()
         {
             string oldValueForMSBuildEmitSolution = Environment.GetEnvironmentVariable("MSBuildEmitSolution");
 
-            //  Clean up projects loaded by other tests
+            // Clean up projects loaded by other tests
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
 
             string solutionFileContents =
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 607e17f234c..3921c17b9d1 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -28,7 +28,7 @@ public class ToolsetState_Tests
         [Fact]
         public void OverrideTasksAreFoundInOverridePath()
         {
-            //Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
+            // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             ProjectCollection e = new ProjectCollection();
             string dir = NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2";
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
@@ -72,7 +72,7 @@ public void OverrideTasksAreFoundInOverridePath()
         [Fact]
         public void OverrideTaskPathIsRelative()
         {
-            //Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
+            // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             ProjectCollection e = new ProjectCollection();
             Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), "msbuildoverridetasks", new DirectoryExists(this.directoryExists));
 
@@ -125,7 +125,7 @@ public void OverrideTaskPathHasTooLongOfAPath()
         [Fact]
         public void OverrideTaskPathIsNotFound()
         {
-            //Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
+            // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             ProjectCollection e = new ProjectCollection();
             Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2", new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), "k:\\Thecatinthehat", new DirectoryExists(this.directoryExists));
 
@@ -143,7 +143,7 @@ public void OverrideTaskPathIsNotFound()
         [Fact]
         public void DefaultTasksAreFoundInToolsPath()
         {
-            //Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
+            // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             Toolset t = new Toolset(
                 "toolsversionname",
                 NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2",
@@ -174,7 +174,7 @@ public void DefaultTasksAreFoundInToolsPath()
         [Fact]
         public void WarningLoggedIfNoDefaultTasksFound()
         {
-            //Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
+            // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             ProjectCollection p = new ProjectCollection();
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
@@ -197,7 +197,7 @@ public void WarningLoggedIfNoDefaultTasksFound()
         [Fact]
         public void InvalidToolPath()
         {
-            //Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
+            // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             ProjectCollection p = new ProjectCollection();
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
@@ -217,7 +217,7 @@ public void InvalidToolPath()
         [Fact]
         public void VerifyTasksFilesAreInSortedOrder()
         {
-            //Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
+            // Note Engine's BinPath is distinct from the ToolsVersion's ToolsPath
             ProjectCollection p = new ProjectCollection();
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
@@ -925,8 +925,8 @@ private string[] getFiles(string path, string pattern)
             string pathWithoutTrailingSlash = path.EndsWith(Path.DirectorySeparatorChar.ToString())
                                                   ? path.Substring(0, path.Length - 1)
                                                   : path;
-            //NOTE: the Replace calls below are a very minimal attempt to convert a basic, cmd.exe-style wildcard
-            //into something Regex.IsMatch will know how to use.
+            // NOTE: the Replace calls below are a very minimal attempt to convert a basic, cmd.exe-style wildcard
+            // into something Regex.IsMatch will know how to use.
             string finalPattern = "^" + pattern.Replace(".", "\\.").Replace("*", "[\\w\\W]*") + "$";
 
             List<string> matches = new List<string>(_defaultTasksFileMap.Keys);
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index e1c99c40e33..7b1f1f6e36b 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -566,7 +566,7 @@ public void GetToolsetDataFromConfiguration_ToolsVersionIsEmptyString()
 
                 Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
-                //this should throw ...
+                // this should throw ...
                 string msbuildOverrideTasksPath = null;
                 string defaultOverrideToolsVersion = null;
                 reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
@@ -629,7 +629,7 @@ public void BlankPropertyNameInConfigFile()
 
                 Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
-                //this should throw ...
+                // this should throw ...
                 string msbuildOverrideTasksPath = null;
                 string defaultOverrideToolsVersion = null;
                 reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
@@ -729,7 +729,7 @@ public void BlankPropertyValueInConfigFile()
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
 
-            //this should not throw ...
+            // this should not throw ...
             string msbuildOverrideTasksPath;
             string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
@@ -823,7 +823,7 @@ public void InvalidPropertyNameInConfigFile()
 
                 Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
-                //this should throw ...
+                // this should throw ...
                 string msbuildOverrideTasksPath = null;
                 string defaultOverrideToolsVersion = null;
                 reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
@@ -1355,7 +1355,7 @@ public void PropertyInConfigurationFileReferencesRegistryLocation()
             key1.SetValue("TaskLocation", @"somePathToTasks");
             key1.SetValue("TargetsLocation", @"D:\somePathToTargets");
             key1.SetValue("SchemaLocation", @"Schemas");
-            key1.SetValue(null, @"D:\somePathToDefault");  //this sets the default value for this key
+            key1.SetValue(null, @"D:\somePathToDefault");  // this sets the default value for this key
 
 #if FEATURE_SYSTEM_CONFIGURATION
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index 38a7a917f76..5b15463db12 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -102,7 +102,7 @@ public void DefaultValuesInRegistryCreatedBySetup()
             {
                 return; // "TODO: under Unix this runs out of stack. Investigate"
             }
-            ToolsetReader reader = new ToolsetRegistryReader(new ProjectCollection().EnvironmentProperties, new PropertyDictionary<ProjectPropertyInstance>());  //we don't use the test registry key because we want to verify the install
+            ToolsetReader reader = new ToolsetRegistryReader(new ProjectCollection().EnvironmentProperties, new PropertyDictionary<ProjectPropertyInstance>());  // we don't use the test registry key because we want to verify the install
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
             string msbuildOverrideTasksPath;
@@ -593,12 +593,12 @@ public void ReadToolsets_NoBinPathOrToolsPath()
 
             string msbuildOverrideTasksPath;
             string defaultOverrideToolsVersion;
-            //should not throw
+            // should not throw
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.True(values.ContainsKey("tv1"));
 
-            //should not contain the second toolset because it does not define a tools/bin path
+            // should not contain the second toolset because it does not define a tools/bin path
             Assert.False(values.ContainsKey("tv2"));
 
             Assert.True(values.ContainsKey("tv3"));
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index e0b7bdc3e43..952ae4b81cf 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -829,8 +829,8 @@ public void SpecialCharactersInMetadataValueEvaluation()
         {
             Project project = new Project();
             ProjectItem item = project.AddItem("None", "MetadataTests", new Dictionary<string, string> {
-                {"EscapedSemicolon", "%3B"}, //Microsoft.Build.Evaluation.ProjectCollection.Escape(";")
-                {"EscapedDollarSign", "%24"}, //Microsoft.Build.Evaluation.ProjectCollection.Escape("$")
+                {"EscapedSemicolon", "%3B"}, // Microsoft.Build.Evaluation.ProjectCollection.Escape(";")
+                {"EscapedDollarSign", "%24"}, // Microsoft.Build.Evaluation.ProjectCollection.Escape("$")
             }).Single();
 
             EscapingInProjectsHelper.SpecialCharactersInMetadataValueTests(item);
@@ -1593,7 +1593,7 @@ public class Class1
             MockLogger log = new MockLogger(_testOutput);
             ObjectModelHelpers.BuildTempProjectFileWithTargetsExpectSuccess(@"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1.sln", new string[] { targetForFirstProject }, null, log);
 
-            Assert.True(File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe"))); //                     @"Did not find expected file Console;!@(foo)'^(Application1.exe"
+            Assert.True(File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe"))); // @"Did not find expected file Console;!@(foo)'^(Application1.exe"
         }
 
         /// <summary>
@@ -1764,7 +1764,7 @@ public class Class1
                 MockLogger log = new MockLogger(_testOutput);
                 ObjectModelHelpers.BuildTempProjectFileWithTargetsExpectSuccess(@"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1.sln", new string[] { targetForFirstProject }, null, log);
 
-                Assert.True(File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe"))); //                         @"Did not find expected file Console;!@(foo)'^(Application1.exe"
+                Assert.True(File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe"))); // @"Did not find expected file Console;!@(foo)'^(Application1.exe"
             }
             finally
             {
diff --git a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
index f241ddefeb8..378c4394b36 100644
--- a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
@@ -492,7 +492,7 @@ public void MultipleInterItemDependenciesOnSameItemOperation()
                 {"m", "i1"}
             };
 
-            //i1 items: i1_1; i1_3; i1_4; i1_6
+            // i1 items: i1_1; i1_3; i1_4; i1_6
             var i1Metadata = new Dictionary<string, string>[]
             {
                 i1BaseMetadata,
@@ -504,7 +504,7 @@ public void MultipleInterItemDependenciesOnSameItemOperation()
             var i1Items = items.Where(i => i.ItemType == "i1").ToList();
             ObjectModelHelpers.AssertItems(new[] { "i1_1", "i1_3", "i1_4", "i1_6" }, i1Items, i1Metadata);
 
-            //i2 items: i1_1; i1_2; i1_3
+            // i2 items: i1_1; i1_2; i1_3
             var i2Metadata = new Dictionary<string, string>[]
             {
                 new Dictionary<string, string>
@@ -518,7 +518,7 @@ public void MultipleInterItemDependenciesOnSameItemOperation()
             var i2Items = items.Where(i => i.ItemType == "i2").ToList();
             ObjectModelHelpers.AssertItems(new[] { "i1_1", "i1_2", "i1_3" }, i2Items, i2Metadata);
 
-            //i3 items: i1_1; i1_2; i1_4
+            // i3 items: i1_1; i1_2; i1_4
             var i3Items = items.Where(i => i.ItemType == "i3").ToList();
             ObjectModelHelpers.AssertItems(new[] { "i1_1", "i1_2", "i1_4" }, i3Items, i1BaseMetadata);
 
@@ -531,8 +531,8 @@ public void LongIncludeChain()
         {
             const int INCLUDE_COUNT = 10000;
 
-            //  This was about the minimum count needed to repro a StackOverflowException
-            //const int INCLUDE_COUNT = 4000;
+            // This was about the minimum count needed to repro a StackOverflowException
+            // const int INCLUDE_COUNT = 4000;
 
             StringBuilder content = new StringBuilder();
             for (int i = 0; i < INCLUDE_COUNT; i++)
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index d3702dc3b68..c8999cb6d79 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -986,7 +986,7 @@ public void SdkResolverItemsAndPropertiesAreInPreprocessedOutput()
 
                 string actual = writer.ToString();
 
-                //  File names for the projects including the properties and items from the SDK resolvers are based on a hash of
+                // File names for the projects including the properties and items from the SDK resolvers are based on a hash of
                 //  the values, so look up the filename here.
                 //  Sample filename: projectPath + ".SdkResolver.-171948414.proj"
                 var virtualImport = project.Imports.First(i => i.ImportedProject.FullPath.StartsWith(projectPath + ".SdkResolver"));
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index ec26ad0381d..7b82202bd2d 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -82,7 +82,7 @@ public void AddEntry()
         /// Tests that a strong reference is held to a single item
         /// </summary>
         [Fact]
-        //  This test fails on .NET Core and Mono: https://github.com/dotnet/msbuild/issues/282
+        // This test fails on .NET Core and Mono: https://github.com/dotnet/msbuild/issues/282
         [Trait("Category", "non-mono-tests")]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/282")]
         public void AddEntryStrongReference()
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
index 815b667a6be..3584cd1a2b2 100644
--- a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -342,7 +342,7 @@ public void SdkResolverCanReturnMultiplePaths(bool includePropertiesAndItems)
             _logger.WarningCount.ShouldBe(0);
         }
 
-        //  When two different SdkResults (ie from the Sdk.props and Sdk.targets imports) return the same combination of items / properties:
+        // When two different SdkResults (ie from the Sdk.props and Sdk.targets imports) return the same combination of items / properties:
         //  - Test that there aren't warnings for duplicate imports
         //  - Test that items from resolver are duplicated in final evaluation result
         [Fact]
@@ -416,7 +416,7 @@ public void SdkResolverCanReturnTheSamePropertiesAndItemsMultipleTimes()
         [Fact]
         public void SdkResolverCanReturnSpecialCharacters()
         {
-            //  %3B - semicolon
+            // %3B - semicolon
             //  %24 - $
             //  %0A - LF
 
diff --git a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
index 6eb89d1cbf5..f1ea97e5b0a 100644
--- a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
+++ b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
@@ -13,7 +13,7 @@ public class FileUtilitiesRegex_Tests
         private string _directoryStart = new string(MSBuildConstants.BackslashChar[0], 2);
         private string _altDirectoryStart = new string(MSBuildConstants.ForwardSlash[0], 2);
 
-        //below are the legacy regex used before explcitly checking these patterns to reduce allocations
+        // below are the legacy regex used before explcitly checking these patterns to reduce allocations
 
         // regular expression used to match file-specs comprising exactly "<drive letter>:" (with no trailing characters)
         internal static readonly Regex DrivePattern = new Regex(@"^[A-Za-z]:$", RegexOptions.Compiled);
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 04c61fc8f2c..592bec82908 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -262,7 +262,7 @@ public static IEnumerable<object[]> SolutionOnlyDependenciesData
             {
                 yield return new object[]
                 {
-                    new Dictionary<int, int[]> //graph nodes and ProjectReference edges
+                    new Dictionary<int, int[]> // graph nodes and ProjectReference edges
                     {
                         {1, null},
                         {2, null}
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 69f44708e46..dbd8b9edae1 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -284,9 +284,9 @@ public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences(string targetN
 
         [Theory]
         [InlineData(false, "BuildUndeclaredReference")]
-//        [InlineData(false, "BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
+// [InlineData(false, "BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
         [InlineData(true, "BuildUndeclaredReference")]
-//        [InlineData(true, "BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
+// [InlineData(true, "BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
         public void UndeclaredReferenceEnforcementShouldFailOnUndeclaredReference(bool addContinueOnError, string targetName)
         {
             AssertBuild(new[] { targetName },
@@ -303,7 +303,7 @@ public void UndeclaredReferenceEnforcementShouldFailOnUndeclaredReference(bool a
 
         [Theory]
         [InlineData("BuildUndeclaredReference")]
-//        [InlineData("BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
+// [InlineData("BuildUndeclaredReferenceViaTask")] https://github.com/dotnet/msbuild/issues/4385
         public void UndeclaredReferenceEnforcementShouldFailOnPreviouslyBuiltButUndeclaredReferences(string targetName)
         {
             AssertBuild(new[] { targetName },
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 934c2ec3da9..9e443496105 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -1924,7 +1924,7 @@ public static IEnumerable<object[]> AllNodesShouldHaveGraphBuildGlobalPropertyDa
             {
                 var globalVariablesArray = new[]
                 {
-                    //todo add null
+                    // todo add null
                     new Dictionary<string, string>(),
                     new Dictionary<string, string>
                     {
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 883bc77d823..eec9427c02a 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -159,7 +159,7 @@ public CacheResult GetExpectedCacheResultForProjectNumber(int projectNumber)
 
             public override string ToString()
             {
-                //return base.ToString();
+                // return base.ToString();
                 return string.Join(
                     ", ",
                     GraphEdges.Select(e => $"{Node(e.Key)}->{FormatChildren(e.Value)}"));
@@ -1495,7 +1495,7 @@ Task<BuildResult> BuildProjectFileAsync(int projectNumber)
         [Theory]
         [InlineData(false, false)]
         // TODO: Reenable when this gets into the main branch.
-        //[InlineData(true, true)]
+        // [InlineData(true, true)]
         public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool disableInprocNode)
         {
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
diff --git a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
index 278d09e7431..a61a639da06 100644
--- a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
+++ b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
@@ -16,7 +16,7 @@
 
 namespace Microsoft.Build.UnitTests
 {
-    //  Although this tests the ProfilerResult API from Microsoft.Build.Framework, it uses the
+    // Although this tests the ProfilerResult API from Microsoft.Build.Framework, it uses the
     //  construction APIs in Microsoft.Build in the test, so this test is in the Microsoft.Build tests
     public class ProjectEvaluationFinishedEventArgs_Tests 
     {
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index 41532eee324..2f7c912bf71 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -448,7 +448,7 @@ public void ComplexTests1()
 
             lexer = new Scanner("'String with an embedded \\' in it'", ParserOptions.AllowAll);
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.String));
-            //          Assert.AreEqual(String.Compare("String with an embedded ' in it", lexer.IsNextString()), 0);
+            // Assert.AreEqual(String.Compare("String with an embedded ' in it", lexer.IsNextString()), 0);
 
             lexer = new Scanner("'String with a $(Property) inside'", ParserOptions.AllowAll);
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.String));
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 5f3faf1a371..6186d6c4dac 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -347,7 +347,7 @@ private void InitializeAsyncPacketThread()
 #if FEATURE_THREAD_CULTURE
                 _packetPump = new Thread(PacketPumpProc);
 #else
-                //  In .NET Core, we need to set the current culture from inside the new thread
+                // In .NET Core, we need to set the current culture from inside the new thread
                 CultureInfo culture = _componentHost.BuildParameters.Culture;
                 CultureInfo uiCulture = _componentHost.BuildParameters.UICulture;
                 _packetPump = new Thread(() =>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index fd8ed6fa54a..711627b304c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -331,7 +331,7 @@ private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessI
         }
 
 #if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-        //  This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
+        // This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
         //  on non-Windows operating systems
         private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream)
         {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 255d2936476..d39ce74cb49 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -371,7 +371,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             ISet<string> removeMetadata
         )
         {
-            //todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
+            // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
 
             ProjectErrorUtilities.VerifyThrowInvalidProject(!(keepMetadata != null && removeMetadata != null), originalItem.KeepMetadataLocation, "KeepAndRemoveMetadataMutuallyExclusive");
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index f91c52fc746..3d35548d260 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -58,7 +58,7 @@ public static IBuildComponent CreateComponent(BuildComponentType type)
             return new MainNodeSdkResolverService();
         }
 
-        //  Test hook
+        // Test hook
         internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
         {
             ((CachingSdkResolverService)_cachedSdkResolver).InitializeForTests(resolverLoader, resolvers);
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index c7ede7db341..e6f1294b28d 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -24,7 +24,7 @@ internal class SdkResolverLoader
 
         private readonly string IncludeDefaultResolver = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
 
-        //  Test hook for loading SDK Resolvers from additional folders.  Support runtime-specific test hook environment variables,
+        // Test hook for loading SDK Resolvers from additional folders.  Support runtime-specific test hook environment variables,
         //  as an SDK resolver built for .NET Framework probably won't work on .NET Core, and vice versa.
         private readonly string AdditionalResolversFolder = Environment.GetEnvironmentVariable(
 #if NETFRAMEWORK
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
index 920e80f4196..9bf0dddb0a6 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
@@ -66,7 +66,7 @@ public SdkResult(SdkReference sdkReference, IEnumerable<string> paths, string ve
 
             Version = version;
 
-            //  Note: these dictionaries should use StringComparison.OrdinalIgnoreCase
+            // Note: these dictionaries should use StringComparison.OrdinalIgnoreCase
             PropertiesToAdd = propertiesToAdd;
             ItemsToAdd = itemsToAdd;
 
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index ffd099e1def..8c3c1834e65 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -423,7 +423,7 @@ private void SetElementAsAttributeValue(ProjectElement child)
         {
             ErrorUtilities.VerifyThrow(Link == null, "External project");
 
-            //  Assumes that child.ExpressedAsAttribute is true
+            // Assumes that child.ExpressedAsAttribute is true
             Debug.Assert(child.ExpressedAsAttribute, nameof(SetElementAsAttributeValue) + " method requires that " +
                 nameof(child.ExpressedAsAttribute) + " property of child is true");
 
@@ -464,7 +464,7 @@ internal void AddToXml(ProjectElement child)
                 // todo children represented as attributes need to be placed in order too
                 //  Assume that the name of the child has already been validated to conform with rules in XmlUtilities.VerifyThrowArgumentValidElementName
 
-                //  Make sure we're not trying to add multiple attributes with the same name
+                // Make sure we're not trying to add multiple attributes with the same name
                 ProjectErrorUtilities.VerifyThrowInvalidProject(!XmlElement.HasAttribute(child.XmlElement.Name),
                     XmlElement.Location, "InvalidChildElementDueToDuplication", child.XmlElement.Name, ElementName);
 
@@ -472,7 +472,7 @@ internal void AddToXml(ProjectElement child)
             }
             else
             {
-                //  We want to add the XmlElement to the same position in the child list as the corresponding ProjectElement.
+                // We want to add the XmlElement to the same position in the child list as the corresponding ProjectElement.
                 //  Depending on whether the child ProjectElement has a PreviousSibling or a NextSibling, we may need to
                 //  use the InsertAfter, InsertBefore, or AppendChild methods to add it in the right place.
                 //
@@ -487,11 +487,11 @@ internal void AddToXml(ProjectElement child)
 
                 if (TrySearchLeftSiblings(child.PreviousSibling, SiblingIsExplicitElement, out ProjectElement referenceSibling))
                 {
-                    //  Add after previous sibling
+                    // Add after previous sibling
                     XmlElement.InsertAfter(child.XmlElement, referenceSibling.XmlElement);
                     if (XmlDocument.PreserveWhitespace)
                     {
-                        //  Try to match the surrounding formatting by checking the whitespace that precedes the node we inserted
+                        // Try to match the surrounding formatting by checking the whitespace that precedes the node we inserted
                         //  after, and inserting the same whitespace between the previous node and the one we added
                         if (referenceSibling.XmlElement.PreviousSibling?.NodeType == XmlNodeType.Whitespace)
                         {
@@ -502,12 +502,12 @@ internal void AddToXml(ProjectElement child)
                 }
                 else if (TrySearchRightSiblings(child.NextSibling, SiblingIsExplicitElement, out referenceSibling))
                 {
-                    //  Add as first child
+                    // Add as first child
                     XmlElement.InsertBefore(child.XmlElement, referenceSibling.XmlElement);
 
                     if (XmlDocument.PreserveWhitespace)
                     {
-                        //  Try to match the surrounding formatting by checking the whitespace that precedes where we inserted
+                        // Try to match the surrounding formatting by checking the whitespace that precedes where we inserted
                         //  the new node, and inserting the same whitespace between the node we added and the one after it.
                         if (child.XmlElement.PreviousSibling?.NodeType == XmlNodeType.Whitespace)
                         {
@@ -518,12 +518,12 @@ internal void AddToXml(ProjectElement child)
                 }
                 else
                 {
-                    //  Add as only child
+                    // Add as only child
                     XmlElement.AppendChild(child.XmlElement);
 
                     if (XmlDocument.PreserveWhitespace)
                     {
-                        //  If the empty parent has whitespace in it, delete it
+                        // If the empty parent has whitespace in it, delete it
                         if (XmlElement.FirstChild.NodeType == XmlNodeType.Whitespace)
                         {
                             XmlElement.RemoveChild(XmlElement.FirstChild);
@@ -577,14 +577,14 @@ internal void RemoveFromXml(ProjectElement child)
 
                 if (XmlDocument.PreserveWhitespace)
                 {
-                    //  If we are trying to preserve formatting of the file, then also remove any whitespace
+                    // If we are trying to preserve formatting of the file, then also remove any whitespace
                     //  that came before the node we removed.
                     if (previousSibling?.NodeType == XmlNodeType.Whitespace)
                     {
                         XmlElement.RemoveChild(previousSibling);
                     }
 
-                    //  If we removed the last non-whitespace child node, set IsEmpty to true so that we get:
+                    // If we removed the last non-whitespace child node, set IsEmpty to true so that we get:
                     //      <ItemName />
                     //  instead of:
                     //      <ItemName>
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index 6027266e540..2acd6b83299 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -51,7 +51,7 @@ public string Name
             set => ChangeName(value);
         }
 
-        //  Add a new property with the same name here because this attribute should be public for ProjectMetadataElement,
+        // Add a new property with the same name here because this attribute should be public for ProjectMetadataElement,
         //  but internal for ProjectElement, because we don't want it to be settable for arbitrary elements.
         /// <summary>
         /// Gets or sets whether this piece of metadata is expressed as an attribute.
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 7ccd2e7dfef..db4be0d5179 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -47,7 +47,7 @@ public enum SolutionProjectType
         /// <summary>
         /// Web Deployment (.wdproj) projects
         /// </summary>
-        WebDeploymentProject, //  MSBuildFormat, but Whidbey-era ones specify ProjectReferences differently
+        WebDeploymentProject, // MSBuildFormat, but Whidbey-era ones specify ProjectReferences differently
         /// <summary>
         /// Project inside an Enterprise Template project
         /// </summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 43ac54836b2..ce67004e11c 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -1229,9 +1229,9 @@ string propertyValue
                 }
                 else if (String.Equals(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase))
                 {
-                    //Website project need to back support 3.5 msbuild parser for the Blend (it is not move to .Net4.0 yet.)
-                    //However, 3.5 version of Solution parser can't handle a equal sign in the value.  
-                    //The "=" in targetframeworkMoniker was escaped to "%3D" for Orcas
+                    // Website project need to back support 3.5 msbuild parser for the Blend (it is not move to .Net4.0 yet.)
+                    // However, 3.5 version of Solution parser can't handle a equal sign in the value.  
+                    // The "=" in targetframeworkMoniker was escaped to "%3D" for Orcas
                     string targetFrameworkMoniker = TrimQuotes(propertyValue);
                     proj.TargetFrameworkMoniker = Shared.EscapingUtilities.UnescapeAll(targetFrameworkMoniker);
                 }
@@ -1421,7 +1421,7 @@ internal void ParseSolutionConfigurations()
 
                 string fullConfigurationName = configurationNames[0].Trim();
 
-                //Fixing bug 555577: Solution file can have description information, in which case we ignore.
+                // Fixing bug 555577: Solution file can have description information, in which case we ignore.
                 if (String.Equals(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
                 {
                     continue;
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 89a68f2756a..8d8f3251768 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -243,7 +243,7 @@ private Dictionary<string, ProjectImportPathMatch> ComputeDistinctListOfSearchPa
                     continue;
                 }
 
-                //FIXME: handle ; in path on Unix
+                // FIXME: handle ; in path on Unix
                 var paths = property.Value
                     .Split(s_separatorForExtensionsPathSearchPaths, StringSplitOptions.RemoveEmptyEntries)
                     .Distinct()
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 213d927c9bb..3f8499f4264 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -428,7 +428,7 @@ bool accumulateProperties
                     // Register toolset paths into list of immutable directories
                     //   example: C:\Windows\Microsoft.NET\Framework\v4.0.30319\
                     FileClassifier.Shared.RegisterImmutableDirectory(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath32")?.EvaluatedValue?.Trim());
-                    //   example:  C:\Windows\Microsoft.NET\Framework64\v4.0.30319\
+                    // example:  C:\Windows\Microsoft.NET\Framework64\v4.0.30319\
                     FileClassifier.Shared.RegisterImmutableDirectory(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath64")?.EvaluatedValue?.Trim());
 
                     if (toolset != null)
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 5f785ca60c4..9156fbf5056 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1879,7 +1879,7 @@ static string EvaluateProperty(string value, IElementLocation location,
                 {
                     projectList ??= new List<ProjectRootElement>();
 
-                    //  Inserting at the beginning will mean that the properties or items from the SdkResult will be evaluated before
+                    // Inserting at the beginning will mean that the properties or items from the SdkResult will be evaluated before
                     //  any projects from paths returned by the SDK Resolver.
                     projectList.Insert(0, CreateProjectForSdkResult(sdkResult));
                 }
@@ -1893,7 +1893,7 @@ static string EvaluateProperty(string value, IElementLocation location,
             }
         }
 
-        //  Creates a project to set the properties and include the items from an SdkResult
+        // Creates a project to set the properties and include the items from an SdkResult
         private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
         {
             int propertiesAndItemsHash;
@@ -1936,7 +1936,7 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
             propertiesAndItemsHash = hash.ToHashCode();
 #endif
 
-            //  Generate a unique filename for the generated project for each unique set of properties and items.
+            // Generate a unique filename for the generated project for each unique set of properties and items.
             string projectPath = _projectRootElement.FullPath + ".SdkResolver." + propertiesAndItemsHash + ".proj";
 
             ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 3c4e72efc3e..cb8f2f24220 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -2210,7 +2210,7 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
                             }
                             catch (ArgumentException)
                             {
-                                //  Prior to porting to .NET Core, this code was passing false as the throwOnBindFailure parameter to Delegate.CreateDelegate.
+                                // Prior to porting to .NET Core, this code was passing false as the throwOnBindFailure parameter to Delegate.CreateDelegate.
                                 //  Since MethodInfo.CreateDelegate doesn't have this option, we catch the ArgumentException to preserve the previous behavior
                                 ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "UnknownItemFunction", functionName);
                             }
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 8f1fb449206..65c1fd8b486 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -172,7 +172,7 @@ public ItemSpec(
 
         private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
         {
-            //  Code corresponds to Evaluator.CreateItemsFromInclude
+            // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
 
             if (string.IsNullOrEmpty(evaluatedItemspecEscaped))
@@ -223,7 +223,7 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                     {
                         // The expression is not of the form "@(X)". Treat as string
 
-                        //  Code corresponds to EngineFileUtilities.GetFileList
+                        // Code corresponds to EngineFileUtilities.GetFileList
                         if (!FileMatcher.HasWildcards(splitEscaped))
                         {
                             // No real wildcards means we just return the original string.  Don't even bother
@@ -261,7 +261,7 @@ private ItemExpressionFragment ProcessItemExpression(
         {
             isItemListExpression = false;
 
-            //  Code corresponds to Expander.ExpandSingleItemVectorExpressionIntoItems
+            // Code corresponds to Expander.ExpandSingleItemVectorExpressionIntoItems
             if (expression.Length == 0)
             {
                 return null;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index ad27682fa2d..f78cc28be71 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -29,7 +29,7 @@ private abstract class LazyItemOperation : IItemOperation
             protected readonly Expander<P, I> _expander;
             protected readonly bool _conditionResult;
 
-            //  This is used only when evaluating an expression, which instantiates
+            // This is used only when evaluating an expression, which instantiates
             //  the items and then removes them
             protected readonly IItemFactory<I, I> _itemFactory;
             internal ItemSpec<P, I> Spec => _itemSpec;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index bcbc373afb8..7f52bb9ae6d 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -343,7 +343,7 @@ private static OrderedItemDataCollection.Builder ComputeItems(LazyItemList lazyI
                         break;
                     }
 
-                    //  If this is a remove operation, then add any globs that will be removed
+                    // If this is a remove operation, then add any globs that will be removed
                     //  to a list of globs to ignore in previous operations
                     if (currentList._memoizedOperation.Operation is RemoveOperation removeOperation)
                     {
@@ -371,7 +371,7 @@ private static OrderedItemDataCollection.Builder ComputeItems(LazyItemList lazyI
                 Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);
                 bool addedToBatch = false;
 
-                //  Walk back down the stack of item lists applying operations
+                // Walk back down the stack of item lists applying operations
                 while (itemListStack.Count > 0)
                 {
                     var currentList = itemListStack.Pop();
@@ -424,7 +424,7 @@ private static OrderedItemDataCollection.Builder ComputeItems(LazyItemList lazyI
                         ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);
                     }
 
-                    //  If this is a remove operation, then it could modify the globs to ignore, so pop the potentially
+                    // If this is a remove operation, then it could modify the globs to ignore, so pop the potentially
                     //  modified entry off the stack of globs to ignore
                     if (currentList._memoizedOperation.Operation is RemoveOperation)
                     {
@@ -560,12 +560,12 @@ private IncludeOperation BuildIncludeOperation(string rootDirectory, ProjectItem
             // Process include
             ProcessItemSpec(rootDirectory, itemElement.Include, itemElement.IncludeLocation, operationBuilder);
 
-            //  Code corresponds to Evaluator.EvaluateItemElement
+            // Code corresponds to Evaluator.EvaluateItemElement
 
             // Process exclude (STEP 4: Evaluate, split, expand and subtract any Exclude)
             if (itemElement.Exclude.Length > 0)
             {
-                //  Expand properties here, because a property may have a value which is an item reference (ie "@(Bar)"), and
+                // Expand properties here, because a property may have a value which is an item reference (ie "@(Bar)"), and
                 //  if so we need to add the right item reference
                 string evaluatedExclude = _expander.ExpandIntoStringLeaveEscaped(itemElement.Exclude, ExpanderOptions.ExpandProperties, itemElement.ExcludeLocation);
 
diff --git a/src/Build/Evaluation/Profiler/EvaluationProfiler.cs b/src/Build/Evaluation/Profiler/EvaluationProfiler.cs
index a55ad7e1906..bc7adaf312e 100644
--- a/src/Build/Evaluation/Profiler/EvaluationProfiler.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationProfiler.cs
@@ -140,7 +140,7 @@ public void Dispose()
                     _evaluationProfiler._evaluationStack.Peek()._exclusiveTime.Start();
                 }
 
-                //  Add elapsed times to evaluation counter dictionaries
+                // Add elapsed times to evaluation counter dictionaries
                 if (!_evaluationProfiler.ProfiledResult.Value.ProfiledLocations.TryGetValue(Location, out var previousTimeSpent))
                 {
                     previousTimeSpent = new ProfiledLocation(TimeSpan.Zero, TimeSpan.Zero, 0);
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 1f84c8f7602..dcd337e14b1 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -284,7 +284,7 @@ private ProjectItemElement ParseProjectItemElement(XmlElementWithLocation elemen
                 exclusiveItemOperation = XMakeAttributes.update;
             }
 
-            //  At most one of the include, remove, or update attributes may be specified
+            // At most one of the include, remove, or update attributes may be specified
             if (exclusiveAttributeCount > 1)
             {
                 XmlAttributeWithLocation errorAttribute = remove.Length > 0 ? (XmlAttributeWithLocation)element.Attributes[XMakeAttributes.remove] : (XmlAttributeWithLocation)element.Attributes[XMakeAttributes.update];
@@ -359,7 +359,7 @@ internal static void CheckMetadataAsAttributeName(string name, out bool isReserv
                 return;
             }
 
-            //  Case insensitive comparison so that mis-capitalizing an attribute like Include or Exclude results in an easy to understand
+            // Case insensitive comparison so that mis-capitalizing an attribute like Include or Exclude results in an easy to understand
             //  error instead of unexpected behavior
             if (KnownAttributesOnItemIgnoreCase.Contains(name))
             {
@@ -368,7 +368,7 @@ internal static void CheckMetadataAsAttributeName(string name, out bool isReserv
                 return;
             }
 
-            //  Reserve attributes starting with underscores in case we need to add more built-in attributes later
+            // Reserve attributes starting with underscores in case we need to add more built-in attributes later
             if (name[0] == '_')
             {
                 isReservedAttributeName = false;
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 3f7324a32b4..bb85186e17c 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -264,7 +264,7 @@ internal override ProjectRootElement Get(string projectFile, OpenProjectRootElem
 
                     if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
                     {
-                        //  Cached project doesn't match preserveFormatting setting, so reload it
+                        // Cached project doesn't match preserveFormatting setting, so reload it
                         projectRootElement.Reload(true, preserveFormatting);
                     }
                 }
diff --git a/src/Build/Globbing/CompositeGlob.cs b/src/Build/Globbing/CompositeGlob.cs
index fb13d021aa5..b1dabb12741 100644
--- a/src/Build/Globbing/CompositeGlob.cs
+++ b/src/Build/Globbing/CompositeGlob.cs
@@ -62,7 +62,7 @@ private CompositeGlob(ImmutableArray<IMSBuildGlob> globs)
         public bool IsMatch(string stringToMatch)
         {
             // Threadpools are a scarce resource in Visual Studio, do not use them.
-            //return Globs.AsParallel().Any(g => g.IsMatch(stringToMatch));
+            // return Globs.AsParallel().Any(g => g.IsMatch(stringToMatch));
 
             return _globs.Any(static (glob, str) => glob.IsMatch(str), stringToMatch);
         }
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 3880fb3e05a..390f8e29f92 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1766,13 +1766,13 @@ public void Translate(ITranslator translator)
             }
         }
 
-        //todo make nested after C# 7
+        // todo make nested after C# 7
         void TranslateTaskRegistrationKey(ITranslator translator, ref RegisteredTaskIdentity taskIdentity)
         {
             translator.Translate(ref taskIdentity);
         }
 
-        //todo make nested after C# 7
+        // todo make nested after C# 7
         void TranslateTaskRegistrationValue(ITranslator translator, ref List<RegisteredTaskRecord> taskRecords)
         {
             translator.Translate(ref taskRecords, RegisteredTaskRecord.FactoryForDeserialization);
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index e3b892f2b6e..04950aca529 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -441,7 +441,7 @@ internal static void ResetColorAnsi()
         /// <param name="background">current background</param>
         internal static ConsoleColor TransformColor(ConsoleColor foreground, ConsoleColor background)
         {
-            ConsoleColor result = foreground; //typically do nothing ...
+            ConsoleColor result = foreground; // typically do nothing ...
 
             if (foreground == background)
             {
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index d794be24780..e9db5412a24 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -923,10 +923,10 @@ private void Write(ITaskItem item, bool writeMetadata = true)
 
             // Don't sort metadata because we want the binary log to be fully roundtrippable
             // and we need to preserve the original order.
-            //if (nameValueListBuffer.Count > 1)
-            //{
+            // if (nameValueListBuffer.Count > 1)
+            // {
             //    nameValueListBuffer.Sort((l, r) => StringComparer.OrdinalIgnoreCase.Compare(l.Key, r.Key));
-            //}
+            // }
 
             WriteNameValueList();
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index e82a335b718..373a0f364f0 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1380,7 +1380,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                         }
                         else
                         {
-                            //there is not enough room just print the message out and let the console do the formatting
+                            // there is not enough room just print the message out and let the console do the formatting
                             WriteBasedOnPrefix(nonNullMessage, prefixAlreadyWritten, adjustedPrefixWidth);
                         }
                     }
@@ -1688,7 +1688,7 @@ internal MPPerformanceCounter(string scopeName)
             /// </summary>
             internal void AddEventStarted(string projectTargetNames, BuildEventContext buildEventContext, DateTime eventTimeStamp, IEqualityComparer<BuildEventContext> comparer)
             {
-                //If the projectTargetNames are set then we should be a project started event
+                // If the projectTargetNames are set then we should be a project started event
                 if (!string.IsNullOrEmpty(projectTargetNames))
                 {
                     // Create a new performance counter for the project entry point to calculate how much time and how many calls
@@ -1781,10 +1781,10 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
         #endregion
 
         #region Per-build Members
-        //Holds messages that were going to be shown before the project started event, buffer them until the project started event is shown
+        // Holds messages that were going to be shown before the project started event, buffer them until the project started event is shown
         private Dictionary<BuildEventContext, List<BuildMessageEventArgs>> _deferredMessages;
         private BuildEventManager _buildEventManager;
-        //  Has the build started
+        // Has the build started
         private bool _hasBuildStarted;
         private bool? _showCommandLine;
         private bool _showTimeStamp;
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 5013b85b0dd..5603b9480f1 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -40,7 +40,7 @@ internal BuildEventManager()
         ///  Adds a new project to the list of project started events which have been fired
         /// </summary>
         internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTimestamp)
-        {   //Parent event can be null if this is the root project
+        {   // Parent event can be null if this is the root project
             ProjectStartedEventMinimumFields parentEvent = GetProjectStartedEvent(e.ParentProjectBuildEventContext);
             lock (_projectStartedEvents)
             {
@@ -102,7 +102,7 @@ internal List<ProjectStartedEventMinimumFields> GetProjectCallStack(BuildEventCo
             // from the engine itself
             if (currentKey != null)
             {
-                //Add the event where the stack should start
+                // Add the event where the stack should start
                 stackTrace.Add(currentKey);
 
                 // Loop through the call tree until the root project started event has been found
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 20522e7e2bb..e677526406b 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -593,7 +593,7 @@ internal void WriteProjectStarted()
         {
             this.VerifyStack(!contextStack.IsEmpty(), "Bad project stack");
 
-            //Pop the current project
+            // Pop the current project
             Frame outerMost = contextStack.Pop();
 
             this.VerifyStack(!outerMost.displayed, "Bad project stack on {0}", outerMost.ID);
@@ -727,9 +727,9 @@ private void ShowDeferredMessages()
 
                 ShowDeferredMessages();
 
-                //push now, so that the stack is in a good state
-                //for WriteProjectStarted() and WriteLinePretty()
-                //because we use the stack to control indenting
+                // push now, so that the stack is in a good state
+                // for WriteProjectStarted() and WriteLinePretty()
+                // because we use the stack to control indenting
                 contextStack.Push(f);
 
                 switch (f.type)
diff --git a/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs b/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
index 482c530d587..d2af49af234 100644
--- a/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
+++ b/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
@@ -27,7 +27,7 @@ string senderName
         )
                 : base(message, helpKeyword, senderName)
             {
-                //Do Nothing
+                // Do Nothing
             }
         }
 
@@ -443,7 +443,7 @@ public void TestBuildWarningEventArgs()
             genericEvent.WriteToStream(_writer);
             long streamWriteEndPosition = _stream.Position;
 
-            //Deserialize and Verify
+            // Deserialize and Verify
             _stream.Position = 0;
             BuildWarningEventArgs newGenericEvent = new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
             newGenericEvent.CreateFromStream(_reader, _eventArgVersion);
@@ -460,7 +460,7 @@ public void TestBuildWarningEventArgs()
             genericEvent.WriteToStream(_writer);
             streamWriteEndPosition = _stream.Position;
 
-            //Deserialize and Verify
+            // Deserialize and Verify
             _stream.Position = 0;
             newGenericEvent = new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
             newGenericEvent.CreateFromStream(_reader, _eventArgVersion);
@@ -473,11 +473,11 @@ public void TestBuildWarningEventArgs()
             genericEvent = new BuildWarningEventArgs(null, null, null, 1, 2, 3, 4, null, null, null);
             genericEvent.BuildEventContext = null;
 
-            //Serialize
+            // Serialize
             genericEvent.WriteToStream(_writer);
             streamWriteEndPosition = _stream.Position;
 
-            //Deserialize and Verify
+            // Deserialize and Verify
             _stream.Position = 0;
             newGenericEvent = new BuildWarningEventArgs("Something", "SomeThing", "SomeThing", -1, -1, -1, -1, "Something", "SomeThing", "Something");
             newGenericEvent.CreateFromStream(_reader, _eventArgVersion);
@@ -734,7 +734,7 @@ public void TestTargetStartedEventArgs()
             VerifyGenericEventArg(genericEvent, newGenericEvent);
             VerifyTargetStarted(genericEvent, newGenericEvent);
 
-            //Test using Empty strings
+            // Test using Empty strings
             _stream.Position = 0;
             // Make sure empty strings are passed correctly
             genericEvent = new TargetStartedEventArgs(string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, TargetBuiltReason.AfterTargets, DateTime.Now);
@@ -757,10 +757,10 @@ public void TestTargetStartedEventArgs()
             // Make sure null string are passed correctly
             genericEvent = new TargetStartedEventArgs(null, null, null, null, null, null, TargetBuiltReason.AfterTargets, DateTime.Now);
             genericEvent.BuildEventContext = null;
-            //Serialize
+            // Serialize
             genericEvent.WriteToStream(_writer);
             streamWriteEndPosition = _stream.Position;
-            //Deserialize and Verify
+            // Deserialize and Verify
             _stream.Position = 0;
             newGenericEvent = new TargetStartedEventArgs("Something", "Something", "Something", "Something", "Something", "Something", TargetBuiltReason.AfterTargets, DateTime.Now);
             newGenericEvent.CreateFromStream(_reader, _eventArgVersion);
@@ -822,10 +822,10 @@ public void TestTargetFinishedEventArgs()
             // Make sure null string are passed correctly
             genericEvent = new TargetFinishedEventArgs(null, null, null, null, null, true);
             genericEvent.BuildEventContext = null;
-            //Serialize
+            // Serialize
             genericEvent.WriteToStream(_writer);
             streamWriteEndPosition = _stream.Position;
-            //Deserialize and Verify
+            // Deserialize and Verify
             _stream.Position = 0;
             newGenericEvent = new TargetFinishedEventArgs("Something", "Something", "Something", "Something", "Something", false);
             newGenericEvent.CreateFromStream(_reader, _eventArgVersion);
@@ -929,7 +929,7 @@ public void TestTaskFinishedEventArgs()
             VerifyGenericEventArg(genericEvent, newGenericEvent);
             VerifyTaskFinished(genericEvent, newGenericEvent);
 
-            //Test using empty strings
+            // Test using empty strings
             _stream.Position = 0;
             // Make sure empty strings are passed correctly
             genericEvent = new TaskFinishedEventArgs(string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, true);
@@ -947,7 +947,7 @@ public void TestTaskFinishedEventArgs()
             VerifyGenericEventArg(genericEvent, newGenericEvent);
             VerifyTaskFinished(genericEvent, newGenericEvent);
 
-            //Test using null strings
+            // Test using null strings
             _stream.Position = 0;
             // Make sure null string are passed correctly
             genericEvent = new TaskFinishedEventArgs(null, null, null, null, null, true);
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index 70e4746bc85..94672522efb 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -217,7 +217,7 @@ public override int GetHashCode()
         {
             var hash = 17;
             // submission ID does not contribute to equality
-            //hash = hash * 31 + _submissionId;
+            // hash = hash * 31 + _submissionId;
             hash = (hash * 31) + _nodeId;
             hash = (hash * 31) + _evaluationId;
             hash = (hash * 31) + _targetId;
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index ffa7b88da4c..e65cf09bb59 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -285,7 +285,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             base.CreateFromStream(reader, version);
             importance = (MessageImportance)reader.ReadInt32();
 
-            //The data in the stream beyond this point are new to 4.0
+            // The data in the stream beyond this point are new to 4.0
             if (version > 20)
             {
                 subcategory = reader.ReadByte() == 0 ? null : reader.ReadString();
diff --git a/src/Framework/Sdk/SdkResult.cs b/src/Framework/Sdk/SdkResult.cs
index 56ad16f651c..52f4157b6fe 100644
--- a/src/Framework/Sdk/SdkResult.cs
+++ b/src/Framework/Sdk/SdkResult.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Framework
     /// </remarks>
     public abstract class SdkResult
     {
-        //  Explicit backing fields so that implementation in Microsoft.Build.dll can use them for translation
+        // Explicit backing fields so that implementation in Microsoft.Build.dll can use them for translation
         private protected bool _success;
         private protected string _path;
         private protected string _version;
diff --git a/src/Framework/TestInfo.cs b/src/Framework/TestInfo.cs
index 48c47b52296..45efb41040b 100644
--- a/src/Framework/TestInfo.cs
+++ b/src/Framework/TestInfo.cs
@@ -2,12 +2,12 @@
 
 namespace Microsoft.Build.Framework
 {
-    //  This is a central place to keep track of whether tests are running or not.  Test startup code
+    // This is a central place to keep track of whether tests are running or not.  Test startup code
     //  will set this to true.  It is consumed in BuildEnvironmentHelper.  However, since that class
     //  is compiled into each project separately, it's not possible for the test startup code to
     //  interact directly with the BuildEnvironmentHelper class - hence this central location.
 
-    //  This class is accessed via reflection, because adding the InternalsVisibleTo attributes which
+    // This class is accessed via reflection, because adding the InternalsVisibleTo attributes which
     //  would be required to access it statically causes errors due to other shared internal classes
     //  which are compiled into multiple projects.
     internal static class TestInfo
diff --git a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
index 4b2255418e0..813ba0128a1 100644
--- a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
+++ b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
@@ -186,7 +186,7 @@ public void VerifyValidProjectSchema
 
                 Assert.Equal(MSBuildApp.ExitType.Success, MSBuildApp.Execute(@"c:\foo\msbuild.exe " + quotedProjectFile + " /validate:\"" + msbuildTempXsdFilenames[0] + "\""));
 
-                //ProjectSchemaValidationHandler.VerifyProjectSchema
+                // ProjectSchemaValidationHandler.VerifyProjectSchema
                 //    (
                 //    projectFilename, 
                 //    msbuildTempXsdFilenames[0],
@@ -239,7 +239,7 @@ public void VerifyInvalidImportNotCaughtBySchema
 
                 Assert.Equal(MSBuildApp.ExitType.Success, MSBuildApp.Execute(@"c:\foo\msbuild.exe " + quotedProjectFile + " /validate:\"" + msbuildTempXsdFilenames[0] + "\""));
 
-                //ProjectSchemaValidationHandler.VerifyProjectSchema
+                // ProjectSchemaValidationHandler.VerifyProjectSchema
                 //    (
                 //    projectFilename,
                 //    msbuildTempXsdFilenames[0],
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 91cca226e9a..f7d6b2d7edd 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -787,7 +787,7 @@ public void TestEnvironment()
                 {
                     sw.WriteLine(projectString);
                 }
-                //Should pass
+                // Should pass
 #if FEATURE_GET_COMMANDLINE
                 MSBuildApp.Execute(@"c:\bin\msbuild.exe " + quotedProjectFileName).ShouldBe(MSBuildApp.ExitType.Success);
 #else
@@ -821,11 +821,11 @@ public void MSBuildEngineLogger()
                     sw.WriteLine(projectString);
                 }
 #if FEATURE_GET_COMMANDLINE
-                //Should pass
+                // Should pass
                 MSBuildApp.Execute(@$"c:\bin\msbuild.exe /logger:FileLogger,""Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"";""LogFile={logFile}"" /verbosity:detailed " + quotedProjectFileName).ShouldBe(MSBuildApp.ExitType.Success);
 
 #else
-                //Should pass
+                // Should pass
                 MSBuildApp.Execute(
                     new[]
                         {
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index c83fc987d12..05e4e08e912 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -3235,7 +3235,7 @@ private static DistributedLoggerRecord CreateForwardingLoggerRecord(ILogger logg
                 effectiveVerbosity = ProcessVerbositySwitch(verbosityValue);
             }
 
-            //Gets the currently loaded assembly in which the specified class is defined
+            // Gets the currently loaded assembly in which the specified class is defined
             Assembly engineAssembly = typeof(ProjectCollection).GetTypeInfo().Assembly;
             string loggerClassName = "Microsoft.Build.Logging.ConfigurableForwardingLogger";
             string loggerAssemblyName = engineAssembly.GetName().FullName;
@@ -3298,7 +3298,7 @@ int cpuCount
                     fileParameters += $"logFile={Path.Combine(Directory.GetCurrentDirectory(), msbuildLogFileName)}";
                 }
 
-                //Gets the currently loaded assembly in which the specified class is defined
+                // Gets the currently loaded assembly in which the specified class is defined
                 Assembly engineAssembly = typeof(ProjectCollection).GetTypeInfo().Assembly;
                 string loggerClassName = "Microsoft.Build.Logging.DistributedFileLogger";
                 string loggerAssemblyName = engineAssembly.GetName().FullName;
diff --git a/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs b/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
index fefb43b48bb..ef6cca48ce1 100644
--- a/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
+++ b/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
@@ -549,12 +549,16 @@ internal struct Slot
             }
         }
     }
+
     /// <summary>Padded head and tail indices, to avoid false sharing between producers and consumers.</summary>
     [DebuggerDisplay("Head = {Head}, Tail = {Tail}")]
     [StructLayout(LayoutKind.Explicit, Size = 192)] // padding before/between/after fields based on typical cache line size of 64
     internal struct PaddedHeadAndTail
     {
-        [FieldOffset(64)] public int Head;
-        [FieldOffset(128)] public int Tail;
+        [FieldOffset(64)]
+        public int Head;
+
+        [FieldOffset(128)]
+        public int Tail;
     }
 }
diff --git a/src/Shared/BufferedReadStream.cs b/src/Shared/BufferedReadStream.cs
index da095e37121..6aaf31e792b 100644
--- a/src/Shared/BufferedReadStream.cs
+++ b/src/Shared/BufferedReadStream.cs
@@ -15,7 +15,7 @@ internal class BufferedReadStream : Stream
         Stream _innerStream;
         byte[] _buffer;
 
-        //  The number of bytes in the buffer that have been read from the underlying stream but not read by consumers of this stream
+        // The number of bytes in the buffer that have been read from the underlying stream but not read by consumers of this stream
         int _currentlyBufferedByteCount;
 
         int _currentIndexInBuffer;
@@ -58,7 +58,7 @@ public override int ReadByte()
             }
             else
             {
-                //  Let the base class handle it, which will end up calling the Read() method
+                // Let the base class handle it, which will end up calling the Read() method
                 return base.ReadByte();
             }
         }
@@ -67,7 +67,7 @@ public override int Read(byte[] buffer, int offset, int count)
         {
             if (count > BUFFER_SIZE)
             {
-                //  Trying to read more data than the buffer can hold
+                // Trying to read more data than the buffer can hold
                 int alreadyCopied = 0;
                 if (_currentlyBufferedByteCount > 0)
                 {
@@ -81,7 +81,7 @@ public override int Read(byte[] buffer, int offset, int count)
             }
             else if (count <= _currentlyBufferedByteCount)
             {
-                //  Enough data buffered to satisfy read request
+                // Enough data buffered to satisfy read request
                 Array.Copy(_buffer, _currentIndexInBuffer, buffer, offset, count);
                 _currentIndexInBuffer += count;
                 _currentlyBufferedByteCount -= count;
@@ -89,7 +89,7 @@ public override int Read(byte[] buffer, int offset, int count)
             }
             else
             {
-                //  Need to read more data
+                // Need to read more data
                 int alreadyCopied = 0;
                 if (_currentlyBufferedByteCount > 0)
                 {
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 8a75d738b65..e4a14d72ef7 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -237,7 +237,7 @@ private static BuildEnvironment TryFromDevConsole()
         {
             if (s_runningTests())
             {
-                //  If running unit tests, then don't try to get the build environment from MSBuild installed on the machine
+                // If running unit tests, then don't try to get the build environment from MSBuild installed on the machine
                 //  (we should be using the locally built MSBuild instead)
                 return null;
             }
@@ -261,7 +261,7 @@ private static BuildEnvironment TryFromSetupApi()
         {
             if (s_runningTests())
             {
-                //  If running unit tests, then don't try to get the build environment from MSBuild installed on the machine
+                // If running unit tests, then don't try to get the build environment from MSBuild installed on the machine
                 //  (we should be using the locally built MSBuild instead)
                 return null;
             }
@@ -355,7 +355,7 @@ private static bool CheckIfRunningTests()
                     return _runningTests.Value;
                 }
 
-                //  Check if running tests via the TestInfo class in Microsoft.Build.Framework.
+                // Check if running tests via the TestInfo class in Microsoft.Build.Framework.
                 //  See the comments on the TestInfo class for an explanation of why it works this way.
                 var frameworkAssembly = typeof(Framework.ITask).Assembly;
                 var testInfoType = frameworkAssembly.GetType("Microsoft.Build.Framework.TestInfo");
@@ -436,7 +436,7 @@ internal static void ResetInstance_ForUnitTestsOnly(Func<string> getProcessFromR
             s_getVisualStudioInstances = getVisualStudioInstances ?? VisualStudioLocationHelper.GetInstances;
             s_getEnvironmentVariable = getEnvironmentVariable ?? GetEnvironmentVariable;
 
-            //  Tests which specifically test the BuildEnvironmentHelper need it to be able to act as if it is not running tests
+            // Tests which specifically test the BuildEnvironmentHelper need it to be able to act as if it is not running tests
             s_runningTests = runningTests ?? CheckIfRunningTests;
 
             BuildEnvironmentHelperSingleton.s_instance = Initialize();
@@ -459,8 +459,8 @@ internal static void ResetInstance_ForUnitTestsOnly(BuildEnvironment buildEnviro
 
         private static class BuildEnvironmentHelperSingleton
         {
-            // Explicit static constructor to tell C# compiler
-            // not to mark type as beforefieldinit
+            // Explicit static constructor to tell C# compiler
+            // not to mark type as beforefieldinit
             static BuildEnvironmentHelperSingleton()
             { }
 
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index b55e905120c..bd5891a0b0a 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -319,7 +319,7 @@ internal static void UnhandledExceptionHandler(object sender, UnhandledException
         /// </summary>
         internal static void DumpExceptionToFile(Exception ex)
         {
-            //  Locking on a type is not recommended.  However, we are doing it here to be extra cautious about compatibility because
+            // Locking on a type is not recommended.  However, we are doing it here to be extra cautious about compatibility because
             //  this method previously had a [MethodImpl(MethodImplOptions.Synchronized)] attribute, which does lock on the type when
             //  applied to a static method.
             lock (typeof(ExceptionHandling))
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 104acce88e1..0cc71e74734 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -749,7 +749,7 @@ string projectDirectory
                     // If the project directory did not end in a slash we need to check to see if the next char in the path is a slash
                     if (!directoryLastCharIsSeparator)
                     {
-                        //If the next char after the project directory is not a slash, skip this path
+                        // If the next char after the project directory is not a slash, skip this path
                         if (path.Length <= projectDirectory.Length || !IsDirectorySeparator(path[projectDirectory.Length]))
                         {
                             yield return path;
@@ -867,7 +867,7 @@ private void GetFilesRecursive(
             ErrorUtilities.VerifyThrow(recursionState.RemainingWildcardDirectory != null, "Expected non-null remaning wildcard directory.");
 
             RecursiveStepResult[] excludeNextSteps = null;
-            //  Determine if any of searchesToExclude is necessarily a superset of the results that will be returned.
+            // Determine if any of searchesToExclude is necessarily a superset of the results that will be returned.
             //  This means all results will be excluded and we should bail out now.
             if (searchesToExclude != null)
             {
@@ -875,25 +875,25 @@ private void GetFilesRecursive(
                 for (int i = 0; i < searchesToExclude.Count; i++)
                 {
                     RecursionState searchToExclude = searchesToExclude[i];
-                    //  The BaseDirectory of all the exclude searches should be the same as the include one
+                    // The BaseDirectory of all the exclude searches should be the same as the include one
                     Debug.Assert(FileUtilities.PathsEqual(searchToExclude.BaseDirectory, recursionState.BaseDirectory), "Expected exclude search base directory to match include search base directory");
 
                     excludeNextSteps[i] = GetFilesRecursiveStep(searchesToExclude[i]);
 
-                    //  We can exclude all results in this folder if:
+                    // We can exclude all results in this folder if:
                     if (
-                        //  We are not looking for a directory matching the pattern given in SearchData.DirectoryPattern
+                        // We are not looking for a directory matching the pattern given in SearchData.DirectoryPattern
                         !searchToExclude.IsLookingForMatchingDirectory &&
-                        //  We are matching files based on a filespec and not a regular expression
+                        // We are matching files based on a filespec and not a regular expression
                         searchToExclude.SearchData.Filespec != null &&
-                        //  The wildcard path portion of the excluded search matches the include search
+                        // The wildcard path portion of the excluded search matches the include search
                         searchToExclude.RemainingWildcardDirectory == recursionState.RemainingWildcardDirectory &&
-                        //  The exclude search will match ALL filenames OR
+                        // The exclude search will match ALL filenames OR
                         (IsAllFilesWildcard(searchToExclude.SearchData.Filespec) ||
-                            //  The exclude search filename pattern matches the include search's pattern
+                            // The exclude search filename pattern matches the include search's pattern
                             searchToExclude.SearchData.Filespec == recursionState.SearchData.Filespec))
                     {
-                        //  We won't get any results from this search that we would end up keeping
+                        // We won't get any results from this search that we would end up keeping
                         return;
                     }
                 }
@@ -938,7 +938,7 @@ private void GetFilesRecursive(
 
             Action<string> processSubdirectory = subdir =>
             {
-                //  RecursionState is a struct so this copies it
+                // RecursionState is a struct so this copies it
                 var newRecursionState = recursionState;
 
                 newRecursionState.BaseDirectory = subdir;
@@ -980,7 +980,7 @@ private void GetFilesRecursive(
 
                     if (searchesToExcludeInSubdirs.TryGetValue(subdir, out searchesForSubdir))
                     {
-                        //  We've found the base directory that these exclusions apply to.  So now add them as normal searches
+                        // We've found the base directory that these exclusions apply to.  So now add them as normal searches
                         if (newSearchesToExclude == null)
                         {
                             newSearchesToExclude = new List<RecursionState>();
@@ -2038,10 +2038,10 @@ private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnes
 
                     // increase the chance of cache hits when multiple relative globs refer to the same base directory
                     // todo https://github.com/dotnet/msbuild/issues/3889
-                    //if (FileUtilities.ContainsRelativePathSegments(filespecUnescaped))
-                    //{
+                    // if (FileUtilities.ContainsRelativePathSegments(filespecUnescaped))
+                    // {
                     //    filespecUnescaped = FileUtilities.GetFullPathNoThrow(filespecUnescaped);
-                    //}
+                    // }
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
@@ -2342,13 +2342,13 @@ private string[] GetFilesImplementation(
             }
             else if (action != SearchAction.RunSearch)
             {
-                //  This means the enum value wasn't valid (or a new one was added without updating code correctly)
+                // This means the enum value wasn't valid (or a new one was added without updating code correctly)
                 throw new NotSupportedException(action.ToString());
             }
 
             List<RecursionState> searchesToExclude = null;
 
-            //  Exclude searches which will become active when the recursive search reaches their BaseDirectory.
+            // Exclude searches which will become active when the recursive search reaches their BaseDirectory.
             //  The BaseDirectory of the exclude search is the key for this dictionary.
             Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs = null;
 
@@ -2358,7 +2358,7 @@ private string[] GetFilesImplementation(
                 searchesToExclude = new List<RecursionState>();
                 foreach (string excludeSpec in excludeSpecsUnescaped)
                 {
-                    //  This is ignored, we always use the include pattern's value for stripProjectDirectory
+                    // This is ignored, we always use the include pattern's value for stripProjectDirectory
                     var excludeAction = GetFileSearchData(projectDirectoryUnescaped, excludeSpec,
                         out _, out RecursionState excludeState);
 
@@ -2374,12 +2374,12 @@ private string[] GetFilesImplementation(
                     }
                     else if (excludeAction == SearchAction.ReturnEmptyList)
                     {
-                        //  Nothing to do
+                        // Nothing to do
                         continue;
                     }
                     else if (excludeAction != SearchAction.RunSearch)
                     {
-                        //  This means the enum value wasn't valid (or a new one was added without updating code correctly)
+                        // This means the enum value wasn't valid (or a new one was added without updating code correctly)
                         throw new NotSupportedException(excludeAction.ToString());
                     }
 
@@ -2388,25 +2388,25 @@ private string[] GetFilesImplementation(
 
                     if (!string.Equals(excludeBaseDirectory, includeBaseDirectory, StringComparison.OrdinalIgnoreCase))
                     {
-                        //  What to do if the BaseDirectory for the exclude search doesn't match the one for inclusion?
+                        // What to do if the BaseDirectory for the exclude search doesn't match the one for inclusion?
                         //  - If paths don't match (one isn't a prefix of the other), then ignore the exclude search.  Examples:
                         //      - c:\Foo\ - c:\Bar\
                         //      - c:\Foo\Bar\ - C:\Foo\Baz\
                         //      - c:\Foo\ - c:\Foo2\
                         if (excludeBaseDirectory.Length == includeBaseDirectory.Length)
                         {
-                            //  Same length, but different paths.  Ignore this exclude search
+                            // Same length, but different paths.  Ignore this exclude search
                             continue;
                         }
                         else if (excludeBaseDirectory.Length > includeBaseDirectory.Length)
                         {
                             if (!IsSubdirectoryOf(excludeBaseDirectory, includeBaseDirectory))
                             {
-                                //  Exclude path is longer, but doesn't start with include path.  So ignore it.
+                                // Exclude path is longer, but doesn't start with include path.  So ignore it.
                                 continue;
                             }
 
-                            //  - The exclude BaseDirectory is somewhere under the include BaseDirectory. So
+                            // - The exclude BaseDirectory is somewhere under the include BaseDirectory. So
                             //    keep the exclude search, but don't do any processing on it while recursing until the baseDirectory
                             //    in the recursion matches the exclude BaseDirectory.  Examples:
                             //      - Include - Exclude
@@ -2428,25 +2428,25 @@ private string[] GetFilesImplementation(
                         }
                         else
                         {
-                            //  Exclude base directory length is less than include base directory length.
+                            // Exclude base directory length is less than include base directory length.
                             if (!IsSubdirectoryOf(state.BaseDirectory, excludeState.BaseDirectory))
                             {
-                                //  Include path is longer, but doesn't start with the exclude path.  So ignore exclude path
+                                // Include path is longer, but doesn't start with the exclude path.  So ignore exclude path
                                 //  (since it won't match anything under the include path)
                                 continue;
                             }
 
-                            //  Now check the wildcard part
+                            // Now check the wildcard part
                             if (excludeState.RemainingWildcardDirectory.Length == 0)
                             {
-                                //  The wildcard part is empty, so ignore the exclude search, as it's looking for files non-recursively
+                                // The wildcard part is empty, so ignore the exclude search, as it's looking for files non-recursively
                                 //  in a folder higher up than the include baseDirectory.
                                 //  Example: include="c:\git\msbuild\src\Framework\**\*.cs" exclude="c:\git\msbuild\*.cs"
                                 continue;
                             }
                             else if (IsRecursiveDirectoryMatch(excludeState.RemainingWildcardDirectory))
                             {
-                                //  The wildcard part is exactly "**\", so the exclude pattern will apply to everything in the include
+                                // The wildcard part is exactly "**\", so the exclude pattern will apply to everything in the include
                                 //  pattern, so simply update the exclude's BaseDirectory to be the same as the include baseDirectory
                                 //  Example: include="c:\git\msbuild\src\Framework\**\*.*" exclude="c:\git\msbuild\**\*.bak"
                                 excludeState.BaseDirectory = state.BaseDirectory;
@@ -2454,7 +2454,7 @@ private string[] GetFilesImplementation(
                             }
                             else
                             {
-                                //  The wildcard part is non-empty and not "**\", so we will need to match it with a Regex.  Fortunately
+                                // The wildcard part is non-empty and not "**\", so we will need to match it with a Regex.  Fortunately
                                 //  these conditions mean that it needs to be matched with a Regex anyway, so here we will update the
                                 //  BaseDirectory to be the same as the exclude BaseDirectory, and change the wildcard part to be "**\"
                                 //  because we don't know where the different parts of the exclude wildcard part would be matched.
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index eebf8a112df..6a6bf071998 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -449,7 +449,7 @@ From Path.cs in the CLR
 
         internal static string FixFilePath(string path)
         {
-            return string.IsNullOrEmpty(path) || Path.DirectorySeparatorChar == '\\' ? path : path.Replace('\\', '/'); //.Replace("//", "/");
+            return string.IsNullOrEmpty(path) || Path.DirectorySeparatorChar == '\\' ? path : path.Replace('\\', '/'); // .Replace("//", "/");
         }
 
 #if !CLR2COMPATIBILITY
@@ -824,7 +824,7 @@ internal static void DeleteDirectoryNoThrow(string path, bool recursive, int ret
         /// </remarks>
         internal static void DeleteWithoutTrailingBackslash(string path, bool recursive = false)
         {
-            //  Some tests (such as FileMatcher and Evaluation tests) were failing with an UnauthorizedAccessException or directory not empty.
+            // Some tests (such as FileMatcher and Evaluation tests) were failing with an UnauthorizedAccessException or directory not empty.
             //  This retry logic works around that issue.
             const int NUM_TRIES = 3;
             for (int i = 0; i < NUM_TRIES; i++)
@@ -833,17 +833,17 @@ internal static void DeleteWithoutTrailingBackslash(string path, bool recursive
                 {
                     Directory.Delete(EnsureNoTrailingSlash(path), recursive);
 
-                    //  If we got here, the directory was successfully deleted
+                    // If we got here, the directory was successfully deleted
                     return;
                 }
                 catch (Exception ex) when (ex is IOException || ex is UnauthorizedAccessException)
                 {
                     if (i == NUM_TRIES - 1)
                     {
-                        //var files = Directory.GetFiles(path, "*.*", SearchOption.AllDirectories);
-                        //string fileString = string.Join(Environment.NewLine, files);
-                        //string message = $"Unable to delete directory '{path}'.  Contents:" + Environment.NewLine + fileString;
-                        //throw new IOException(message, ex);
+                        // var files = Directory.GetFiles(path, "*.*", SearchOption.AllDirectories);
+                        // string fileString = string.Join(Environment.NewLine, files);
+                        // string message = $"Unable to delete directory '{path}'.  Contents:" + Environment.NewLine + fileString;
+                        // throw new IOException(message, ex);
                         throw;
                     }
                 }
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index d7f0e66b9ad..0c94e83cd23 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -79,7 +79,7 @@ internal static bool StartsWithDrivePatternWithSlash(string pattern)
         /// <returns>true if comprises UNC pattern.</returns>
         internal static bool IsUncPattern(string pattern)
         {
-            //Return value == pattern.length means:
+            // Return value == pattern.length means:
             //  meets minimum unc requirements
             //  pattern does not end in a '/' or '\'
             //  if a subfolder were found the value returned would be length up to that subfolder, therefore no subfolder exists
@@ -93,7 +93,7 @@ internal static bool IsUncPattern(string pattern)
         /// <returns>true if starts with UNC pattern.</returns>
         internal static bool StartsWithUncPattern(string pattern)
         {
-            //Any non -1 value returned means there was a match, therefore is begins with the pattern.
+            // Any non -1 value returned means there was a match, therefore is begins with the pattern.
             return StartsWithUncPatternMatchLength(pattern) != -1;
         }
 
@@ -114,14 +114,14 @@ internal static int StartsWithUncPatternMatchLength(string pattern)
 
             for (int i = 2; i < pattern.Length; i++)
             {
-                //Real UNC paths should only contain backslashes. However, the previous
+                // Real UNC paths should only contain backslashes. However, the previous
                 // regex pattern accepted both so functionality will be retained.
                 if (pattern[i] == _backSlash ||
                     pattern[i] == _forwardSlash)
                 {
                     if (prevCharWasSlash)
                     {
-                        //We get here in the case of an extra slash.
+                        // We get here in the case of an extra slash.
                         return -1;
                     }
                     else if(hasShare)
@@ -140,7 +140,7 @@ internal static int StartsWithUncPatternMatchLength(string pattern)
 
             if(!hasShare)
             {
-                //no subfolder means no unc pattern. string is something like "\\abc" in this case
+                // no subfolder means no unc pattern. string is something like "\\abc" in this case
                 return -1;
             }
 
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 5ac573ea245..6afa121168a 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -693,7 +693,7 @@ params object[] messageArgs
             // All of our errors should have an error code, so the user has something
             // to look up in the documentation. To help find errors without error codes,
             // temporarily uncomment this line and run the unit tests.
-            //if (null == errorCode) File.AppendAllText("c:\\errorsWithoutCodes", message + "\n");
+            // if (null == errorCode) File.AppendAllText("c:\\errorsWithoutCodes", message + "\n");
             // We don't have a Debug.Assert for this, because it would be triggered by <Error> and <Warning> tags.
 
             // If the task has missed out all location information, add the location of the task invocation;
@@ -1047,7 +1047,7 @@ params object[] messageArgs
             // All of our warnings should have an error code, so the user has something
             // to look up in the documentation. To help find warnings without error codes,
             // temporarily uncomment this line and run the unit tests.
-            //if (null == warningCode) File.AppendAllText("c:\\warningsWithoutCodes", message + "\n");
+            // if (null == warningCode) File.AppendAllText("c:\\warningsWithoutCodes", message + "\n");
             // We don't have a Debug.Assert for this, because it would be triggered by <Error> and <Warning> tags.
 
             // If the task has missed out all location information, add the location of the task invocation;
diff --git a/src/Shared/TaskLoggingHelperExtension.cs b/src/Shared/TaskLoggingHelperExtension.cs
index 9be33ca4af3..2607884b1db 100644
--- a/src/Shared/TaskLoggingHelperExtension.cs
+++ b/src/Shared/TaskLoggingHelperExtension.cs
@@ -12,7 +12,7 @@
 using Microsoft.Build.Utilities;
 #endif
 
-//This is in the Tasks namespace because that's where it was before and it is public.
+// This is in the Tasks namespace because that's where it was before and it is public.
 
 #nullable disable
 
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index dbd7841d9c4..496525cb47f 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1140,7 +1140,7 @@ public void ParentWithoutSlash()
         [Fact]
         public void Unc()
         {
-            //Check UNC functionality
+            // Check UNC functionality
             ValidateFileMatch
                 (
                 "\\\\server\\c$\\**\\*.cs",
@@ -1424,7 +1424,7 @@ public void RemoveProjectDirectory()
 
         [Theory]
         [InlineData(
-            @"src/**/*.cs", //  Include Pattern
+            @"src/**/*.cs", // Include Pattern
             new string[] //  Matching files
             {
                 @"src/a.cs",
@@ -1432,7 +1432,7 @@ public void RemoveProjectDirectory()
             }
             )]
         [InlineData(
-            @"src/test/**/*.cs", //  Include Pattern
+            @"src/test/**/*.cs", // Include Pattern
             new string[] //  Matching files
             {
                 @"src/test/a.cs",
@@ -1440,7 +1440,7 @@ public void RemoveProjectDirectory()
             }
             )]
         [InlineData(
-            @"src/test/**/a/b/**/*.cs", //  Include Pattern
+            @"src/test/**/a/b/**/*.cs", // Include Pattern
             new string[] //  Matching files
             {
                 @"src/test/dir\a\b\a.cs",
@@ -1454,18 +1454,18 @@ public void IncludePatternShouldNotPreserveUserSlashesInFixedDirPart(string incl
 
         [Theory]
         [InlineData(
-            @"**\*.cs", //  Include Pattern
+            @"**\*.cs", // Include Pattern
             new[] //  Exclude patterns
             {
                 @"bin\**"
             },
-            new string[] //  Matching files
+            new string[] // Matching files
             {
             },
-            new string[] //  Non matching files
+            new string[] // Non matching files
             {
             },
-            new[] //  Non matching files that shouldn't be touched
+            new[] // Non matching files that shouldn't be touched
             {
                 @"bin\foo.cs",
                 @"bin\bar\foo.cs",
@@ -1473,21 +1473,21 @@ public void IncludePatternShouldNotPreserveUserSlashesInFixedDirPart(string incl
             }
             )]
         [InlineData(
-            @"**\*.cs", //  Include Pattern
+            @"**\*.cs", // Include Pattern
             new[] //  Exclude patterns
             {
                 @"bin\**"
             },
-            new[] //  Matching files
+            new[] // Matching files
             {
                 "a.cs",
                 @"b\b.cs",
             },
-            new[] //  Non matching files
+            new[] // Non matching files
             {
                 @"b\b.txt"
             },
-            new[] //  Non matching files that shouldn't be touched
+            new[] // Non matching files that shouldn't be touched
             {
                 @"bin\foo.cs",
                 @"bin\bar\foo.cs",
@@ -1503,24 +1503,24 @@ public void ExcludePattern(string include, string[] exclude, string[] matching,
         public void ExcludeSpecificFiles()
         {
             MatchDriverWithDifferentSlashes(
-                @"**\*.cs",     //  Include Pattern
+                @"**\*.cs",     // Include Pattern
                 new[]    //  Exclude patterns
                 {
                     @"Program_old.cs",
                     @"Properties\AssemblyInfo_old.cs"
                 },
-                new[]    //  Matching files
+                new[]    // Matching files
                 {
                     @"foo.cs",
                     @"Properties\AssemblyInfo.cs",
                     @"Foo\Bar\Baz\Buzz.cs"
                 },
-                new[]    //  Non matching files
+                new[]    // Non matching files
                 {
                     @"Program_old.cs",
                     @"Properties\AssemblyInfo_old.cs"
                 },
-                Array.Empty<string>()    //  Non matching files that shouldn't be touched
+                Array.Empty<string>()    // Non matching files that shouldn't be touched
             );
         }
 
@@ -1528,27 +1528,27 @@ public void ExcludeSpecificFiles()
         public void ExcludePatternAndSpecificFiles()
         {
             MatchDriverWithDifferentSlashes(
-                @"**\*.cs",     //  Include Pattern
+                @"**\*.cs",     // Include Pattern
                 new[]    //  Exclude patterns
                 {
                     @"bin\**",
                     @"Program_old.cs",
                     @"Properties\AssemblyInfo_old.cs"
                 },
-                new[]    //  Matching files
+                new[]    // Matching files
                 {
                     @"foo.cs",
                     @"Properties\AssemblyInfo.cs",
                     @"Foo\Bar\Baz\Buzz.cs"
                 },
-                new[]    //  Non matching files
+                new[]    // Non matching files
                 {
                     @"foo.txt",
                     @"Foo\foo.txt",
                     @"Program_old.cs",
                     @"Properties\AssemblyInfo_old.cs"
                 },
-                new[]    //  Non matching files that shouldn't be touched
+                new[]    // Non matching files that shouldn't be touched
                 {
                     @"bin\foo.cs",
                     @"bin\bar\foo.cs",
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index fb4d85038c9..a2681f795f1 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -333,10 +333,10 @@ public void EnsureTrailingSlash()
             Assert.Equal(FileUtilities.FixFilePath(@"foo/bar\"), FileUtilities.EnsureTrailingSlash(@"foo/bar")); // "test 2"
 
             // Already has a trailing slash to start with.
-            Assert.Equal(FileUtilities.FixFilePath(@"foo/bar/"), FileUtilities.EnsureTrailingSlash(@"foo/bar/")); //test 3"
-            Assert.Equal(FileUtilities.FixFilePath(@"foo\bar\"), FileUtilities.EnsureTrailingSlash(@"foo\bar\")); //test 4"
-            Assert.Equal(FileUtilities.FixFilePath(@"foo/bar\"), FileUtilities.EnsureTrailingSlash(@"foo/bar\")); //test 5"
-            Assert.Equal(FileUtilities.FixFilePath(@"foo\bar/"), FileUtilities.EnsureTrailingSlash(@"foo\bar/")); //"test 5"
+            Assert.Equal(FileUtilities.FixFilePath(@"foo/bar/"), FileUtilities.EnsureTrailingSlash(@"foo/bar/")); // test 3"
+            Assert.Equal(FileUtilities.FixFilePath(@"foo\bar\"), FileUtilities.EnsureTrailingSlash(@"foo\bar\")); // test 4"
+            Assert.Equal(FileUtilities.FixFilePath(@"foo/bar\"), FileUtilities.EnsureTrailingSlash(@"foo/bar\")); // test 5"
+            Assert.Equal(FileUtilities.FixFilePath(@"foo\bar/"), FileUtilities.EnsureTrailingSlash(@"foo\bar/")); // "test 5"
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/ImmutableDictionary_Tests.cs b/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
index f990142f1e7..9ac90118d3a 100644
--- a/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
+++ b/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
@@ -4,7 +4,7 @@
 // We don't automatically run these tests against the BCL implementation of ImmutableDictionary as it would require dual-compiling
 // this file. When making changes to this test, though, it is recommended to run them manually by uncommenting the following line.
 // This helps ensure that the real thing has the same behavior that we expect in our implementation.
-//#define _TEST_BCL_IMMUTABLE_DICTIONARY
+// #define _TEST_BCL_IMMUTABLE_DICTIONARY
 
 extern alias MSBuildTaskHost;
 
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index dd69a5d980c..825ccaeb1d4 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -54,11 +54,11 @@ public void TestGetProcAddress()
                 // Make sure the pointer passed back for the method is not null
                 Assert.NotEqual(processHandle, NativeMethodsShared.NullIntPtr);
 
-                //Actually call the method
+                // Actually call the method
                 GetProcessIdDelegate processIdDelegate = Marshal.GetDelegateForFunctionPointer<GetProcessIdDelegate>(processHandle);
                 uint processId = processIdDelegate();
 
-                //Make sure the return value is the same as retrieved from the .net methods to make sure everything works
+                // Make sure the return value is the same as retrieved from the .net methods to make sure everything works
                 Assert.Equal((uint)Process.GetCurrentProcess().Id, processId); // "Expected the .net processId to match the one from GetCurrentProcessId"
             }
             finally
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index ff765c063a9..72bdbee3979 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -427,7 +427,7 @@ internal static void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
                         Assert.Equal(
                                 expectedMetadataValue,
                                 actualMetadataValue
-                            //string.Format
+                            // string.Format
                             //    (
                             //        "Item '{0}' has metadata {1}={2} instead of expected {1}={3}.",
                             //        actualItem.ItemSpec,
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index 03e8a8f5d14..ef9c42456db 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -11,12 +11,12 @@
 
 [assembly: CollectionBehavior(CollectionBehavior.CollectionPerAssembly)]
 
-//  Register test framework for assembly fixture
+// Register test framework for assembly fixture
 [assembly: TestFramework("Xunit.NetCore.Extensions.XunitTestFrameworkWithAssemblyFixture", "Xunit.NetCore.Extensions")]
 
 [assembly: AssemblyFixture(typeof(MSBuildTestAssemblyFixture))]
 
-//  Wrap a TestEnvironment around each test method and class so if invariants have changed we will know where
+// Wrap a TestEnvironment around each test method and class so if invariants have changed we will know where
 [assembly: AssemblyFixture(typeof(MSBuildTestEnvironmentFixture), LifetimeScope = AssemblyFixtureAttribute.Scope.Class)]
 [assembly: AssemblyFixture(typeof(MSBuildTestEnvironmentFixture), LifetimeScope = AssemblyFixtureAttribute.Scope.Method)]
 
@@ -29,7 +29,7 @@ public class MSBuildTestAssemblyFixture : IDisposable
 
         public MSBuildTestAssemblyFixture()
         {
-            //  Set field to indicate tests are running in the TestInfo class in Microsoft.Build.Framework.
+            // Set field to indicate tests are running in the TestInfo class in Microsoft.Build.Framework.
             //  See the comments on the TestInfo class for an explanation of why it works this way.
             var frameworkAssembly = typeof(Microsoft.Build.Framework.ITask).Assembly;
             var testInfoType = frameworkAssembly.GetType("Microsoft.Build.Framework.TestInfo");
@@ -40,7 +40,7 @@ public MSBuildTestAssemblyFixture()
 
             _testEnvironment.DoNotLaunchDebugger();
 
-            //  Reset the VisualStudioVersion environment variable.  This will be set if tests are run from a VS command prompt.  However,
+            // Reset the VisualStudioVersion environment variable.  This will be set if tests are run from a VS command prompt.  However,
             //  if the environment variable is set, it will interfere with tests which set the SubToolsetVersion
             //  (VerifySubToolsetVersionSetByConstructorOverridable), as the environment variable would take precedence.
             _testEnvironment.SetEnvironmentVariable("VisualStudioVersion", string.Empty);
@@ -51,7 +51,7 @@ public MSBuildTestAssemblyFixture()
 
             SetDotnetHostPath(_testEnvironment);
 
-            //  Use a project-specific temporary path
+            // Use a project-specific temporary path
             //  This is so multiple test projects can be run in parallel without sharing the same temp directory
             var subdirectory = Path.GetRandomFileName();
 
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 22d8b098595..33ed94cc123 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -388,7 +388,7 @@ public override void AssertInvariant(ITestOutputHelper output)
         {
             var currentValue = _accessorFunc();
 
-            //  Something like the following might be preferrable, but the assertion method truncates the values leaving us without
+            // Something like the following might be preferrable, but the assertion method truncates the values leaving us without
             //  useful information.  So use Assert.True instead
             //  Assert.Equal($"{_name}: {_originalValue}", $"{_name}: {_accessorFunc()}");
 
diff --git a/src/Shared/UnitTests/TestProgram.cs b/src/Shared/UnitTests/TestProgram.cs
index 8c7f23da42e..39524b6054b 100644
--- a/src/Shared/UnitTests/TestProgram.cs
+++ b/src/Shared/UnitTests/TestProgram.cs
@@ -12,10 +12,10 @@ public static int Main(string[] args)
 
         int returnCode = Xunit.ConsoleClient.Program.Main(newArgs.ToArray());
 
-        //if (showHelp)
-        //{
+        // if (showHelp)
+        // {
         //    TestCommandLine.ShowHelp();
-        //}
+        // }
 
         return returnCode;
 #else
diff --git a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
index 0ac855564b1..203d24a251f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
@@ -269,7 +269,7 @@ public void ExistsPromotedDependencyInTheBlackList()
         /// In this case,
         /// - A single primary file reference to assembly version 1.0.0.0 was passed in.
         /// - An app.config was passed in that promotes a *different* assembly version name from 
-        //    1.0.0.0 to 2.0.0.0
+        // 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of the file exists.
         /// - Version 2.0.0.0 of the file exists.
         /// Expected:
diff --git a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
index 276cb4ed9f6..df51e79f8f4 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
@@ -307,7 +307,7 @@ public void SystemRuntimeDepends_No_Build()
                 )
             );
 
-            Assert.Equal("false", t.DependsOnSystemRuntime, true); //                 "Expected no System.Runtime dependency found during build."
+            Assert.Equal("false", t.DependsOnSystemRuntime, true); // "Expected no System.Runtime dependency found during build."
             Assert.Equal("false", t.DependsOnNETStandard, true); //                   "Expected no netstandard dependency found during build."
 
             // intelli build mode
@@ -335,7 +335,7 @@ public void SystemRuntimeDepends_No_Build()
                 )
             );
 
-            Assert.Equal("false", t.DependsOnSystemRuntime, true); //                 "Expected no System.Runtime dependency found during intellibuild."
+            Assert.Equal("false", t.DependsOnSystemRuntime, true); // "Expected no System.Runtime dependency found during intellibuild."
             Assert.Equal("false", t.DependsOnNETStandard, true); //                   "Expected no netstandard dependency found during intellibuild."
         }
 
@@ -383,7 +383,7 @@ public void SystemRuntimeDepends_Yes()
                 )
             );
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during build."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during build."
 
             // intelli build mode
             t.FindDependencies = false;
@@ -410,7 +410,7 @@ public void SystemRuntimeDepends_Yes()
                 )
             );
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during intellibuild."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during intellibuild."
         }
 
         // Indirect dependency
@@ -457,7 +457,7 @@ public void SystemRuntimeDepends_Yes_Indirect()
                 )
             );
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during build."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during build."
 
             // intelli build mode
             t.FindDependencies = false;
@@ -484,7 +484,7 @@ public void SystemRuntimeDepends_Yes_Indirect()
                 )
             );
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during intellibuild."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during intellibuild."
         }
 
         [Fact]
@@ -526,7 +526,7 @@ public void SystemRuntimeDepends_Yes_Indirect_ExternallyResolved()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during build."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during build."
 
             // intelli build mode
             t.FindDependencies = false;
@@ -548,7 +548,7 @@ public void SystemRuntimeDepends_Yes_Indirect_ExternallyResolved()
                 checkIfAssemblyIsInGac, isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during intellibuild."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during intellibuild."
         }
 
         [Fact]
@@ -589,7 +589,7 @@ public void NETStandardDepends_Yes()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnNETStandard, true); //                 "Expected System.Runtime dependency found during build."
+            Assert.Equal("true", t.DependsOnNETStandard, true); // "Expected System.Runtime dependency found during build."
 
             // intelli build mode
             t.FindDependencies = false;
@@ -612,7 +612,7 @@ public void NETStandardDepends_Yes()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnNETStandard, true); //                 "Expected System.Runtime dependency found during intellibuild."
+            Assert.Equal("true", t.DependsOnNETStandard, true); // "Expected System.Runtime dependency found during intellibuild."
         }
 
         [Fact]
@@ -653,7 +653,7 @@ public void NETStandardDepends_Yes_Indirect()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnNETStandard, true); //                 "Expected netstandard dependency found during build."
+            Assert.Equal("true", t.DependsOnNETStandard, true); // "Expected netstandard dependency found during build."
 
             // intelli build mode
             t.FindDependencies = false;
@@ -676,7 +676,7 @@ public void NETStandardDepends_Yes_Indirect()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnNETStandard, true); //                 "Expected netstandard dependency found during intellibuild."
+            Assert.Equal("true", t.DependsOnNETStandard, true); // "Expected netstandard dependency found during intellibuild."
         }
 
 
@@ -719,7 +719,7 @@ public void NETStandardDepends_Yes_Indirect_ExternallyResolved()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnNETStandard, true); //                 "Expected netstandard dependency found during build."
+            Assert.Equal("true", t.DependsOnNETStandard, true); // "Expected netstandard dependency found during build."
 
             // intelli build mode
             t.FindDependencies = false;
@@ -742,7 +742,7 @@ public void NETStandardDepends_Yes_Indirect_ExternallyResolved()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnNETStandard, true); //                 "Expected netstandard dependency found during intellibuild."
+            Assert.Equal("true", t.DependsOnNETStandard, true); // "Expected netstandard dependency found during intellibuild."
         }
 
         [Fact]
@@ -785,7 +785,7 @@ public void DependsOn_NETStandard_and_SystemRuntime()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during build."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during build."
             Assert.Equal("true", t.DependsOnNETStandard, true); //                   "Expected netstandard dependency found during build."
 
             // intelli build mode
@@ -809,7 +809,7 @@ public void DependsOn_NETStandard_and_SystemRuntime()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during intellibuild."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during intellibuild."
             Assert.Equal("true", t.DependsOnNETStandard, true); //                   "Expected netstandard dependency found during intellibuild."
         }
 
@@ -855,7 +855,7 @@ public void DependsOn_NETStandard_and_SystemRuntime_ExternallyResolved()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during build."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during build."
             Assert.Equal("true", t.DependsOnNETStandard, true); //                   "Expected netstandard dependency found during build."
 
             // intelli build mode
@@ -879,7 +879,7 @@ public void DependsOn_NETStandard_and_SystemRuntime_ExternallyResolved()
                 isWinMDFile,
                 readMachineTypeFromPEHeader));
 
-            Assert.Equal("true", t.DependsOnSystemRuntime, true); //                 "Expected System.Runtime dependency found during intellibuild."
+            Assert.Equal("true", t.DependsOnSystemRuntime, true); // "Expected System.Runtime dependency found during intellibuild."
             Assert.Equal("true", t.DependsOnNETStandard, true); //                   "Expected netstandard dependency found during intellibuild."
         }
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 841020c30f5..9fe18eaef93 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -931,7 +931,7 @@ public void InputAllowedRelatedFileExtensionsAreUsed()
             t.Assemblies = assemblies;
             t.TargetFrameworkDirectories = new string[] { s_myVersion20Path };
             t.SearchPaths = DefaultPaths;
-            t.AllowedRelatedFileExtensions = new string[] { @".licenses", ".xml" }; //no .pdb or .config
+            t.AllowedRelatedFileExtensions = new string[] { @".licenses", ".xml" }; // no .pdb or .config
             Execute(t);
 
             Assert.Single(t.ResolvedFiles);
@@ -1781,7 +1781,7 @@ public void AssemblyFoldersExTargetFrameworkVersionBogusValue()
             Execute(t);
 
             Assert.Single(t.ResolvedFiles);
-            Assert.Equal("{HintPathFromItem}", t.ResolvedFiles[0].GetMetadata("ResolvedFrom")); //                 "Assembly should have been resolved from HintPathFromItem!"
+            Assert.Equal("{HintPathFromItem}", t.ResolvedFiles[0].GetMetadata("ResolvedFrom")); // "Assembly should have been resolved from HintPathFromItem!"
         }
 
         /// <summary>
@@ -3591,7 +3591,7 @@ public void ConflictBetweenCopyLocalDependenciesRegress444809()
             bool result = Execute(t);
             ResourceManager resources = new ResourceManager("Microsoft.Build.Tasks.Strings", Assembly.GetExecutingAssembly());
 
-            //Unresolved primary reference with itemspec "A, Version=20.0.0.0, Culture=Neutral, PublicKeyToken=null".
+            // Unresolved primary reference with itemspec "A, Version=20.0.0.0, Culture=Neutral, PublicKeyToken=null".
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_ADllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_V2_ADllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_CDllPath);
@@ -4540,13 +4540,13 @@ public void Regress275161_ScatterAssemblies()
 
             Execute(t);
 
-            Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m1.netmodule")); //                 "Expected to find scatter file m1."
+            Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m1.netmodule")); // "Expected to find scatter file m1."
 
-            Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m2.netmodule")); //                 "Expected to find scatter file m2."
+            Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m2.netmodule")); // "Expected to find scatter file m2."
 
-            Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m1.netmodule")); //                 "Expected to find scatter file m1 in CopyLocalFiles."
+            Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m1.netmodule")); // "Expected to find scatter file m1 in CopyLocalFiles."
 
-            Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m2.netmodule")); //                 "Expected to find scatter file m2 in CopyLocalFiles."
+            Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m2.netmodule")); // "Expected to find scatter file m2 in CopyLocalFiles."
         }
 
         /// <summary>
@@ -4600,7 +4600,7 @@ public void Regress317975_LeftoverLowerVersion()
                 Assert.Equal(0, String.Compare(i.GetMetadata("CopyLocal"), "false", StringComparison.OrdinalIgnoreCase));
             }
 
-            Assert.True(ContainsItem(t.ResolvedDependencyFiles, @"C:\Regress317975\B.dll")); //                 "Expected to find lower version listed in dependencies."
+            Assert.True(ContainsItem(t.ResolvedDependencyFiles, @"C:\Regress317975\B.dll")); // "Expected to find lower version listed in dependencies."
         }
 
         /// <summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
index 50da1846c76..fcb3071ded9 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
@@ -87,7 +87,7 @@ public void Exists()
         /// In this case,
         /// - A single primary non-version-strict reference was passed in to assembly version 1.0.0.0
         /// - An app.config was passed in that promotes a *different* assembly version name from 
-        //    1.0.0.0 to 2.0.0.0
+        // 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of the file exists.
         /// - Version 2.0.0.0 of the file exists.
         /// Expected:
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 897f629463e..f7aef1ac162 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -503,11 +503,11 @@ internal void StopIOMonitoring()
             // ==[Related File Extensions Testing]================================================================================================
 
             // ==[Unification Testing]============================================================================================================
-            //@"C:\MyComponents\v0.5\UnifyMe.dll",                                 // For unification testing, a version that doesn't exist.
+            // @"C:\MyComponents\v0.5\UnifyMe.dll",                                 // For unification testing, a version that doesn't exist.
             s_unifyMeDll_V10Path,
             s_unifyMeDll_V20Path,
             s_unifyMeDll_V30Path,
-            //@"C:\MyComponents\v4.0\UnifyMe.dll",
+            // @"C:\MyComponents\v4.0\UnifyMe.dll",
             Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"),
             Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"),
             Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"),
@@ -520,8 +520,8 @@ internal void StopIOMonitoring()
 
             // ==[Test assemblies reference higher versions than the current target framework=====================================================
             Path.Combine(s_myComponentsMiscPath, "DependsOnOnlyv4Assemblies.dll"),  // Only depends on 4.0.0 assemblies
-            Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), //Is in redist list and is a 9.0 assembly
-            Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), //Depends on 9.0 assemblies
+            Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), // Is in redist list and is a 9.0 assembly
+            Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), // Depends on 9.0 assemblies
             Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), // Depends on 9.0 assemblies
             Path.Combine(s_myComponents10Path, "DependsOn9.dll"), // Depends on 9.0 assemblies
             Path.Combine(s_myComponents20Path, "DependsOn9.dll"), // Depends on 9.0 assemblies
@@ -1388,7 +1388,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("DependsOn9, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            //A second assembly which depends on version 9 framework assemblies.
+            // A second assembly which depends on version 9 framework assemblies.
             if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9Also, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
@@ -2290,7 +2290,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            //A second assembly which depends on version 9 framework assemblies.
+            // A second assembly which depends on version 9 framework assemblies.
             if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
@@ -3097,7 +3097,7 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC
                         // OriginalItemSpec attribute on resolved items is to support VS in figuring out which
                         // project file reference caused a particular resolved file.
                         string originalItemSpec = t.ResolvedFiles[i].GetMetadata("OriginalItemSpec");
-                        Assert.True(ContainsItem(t.Assemblies, originalItemSpec) || ContainsItem(t.AssemblyFiles, originalItemSpec)); //                         "Expected to find OriginalItemSpec in Assemblies or AssemblyFiles task parameters"
+                        Assert.True(ContainsItem(t.Assemblies, originalItemSpec) || ContainsItem(t.AssemblyFiles, originalItemSpec)); // "Expected to find OriginalItemSpec in Assemblies or AssemblyFiles task parameters"
                     }
                 }
             }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
index f1005eb2de1..0ff90cdeec1 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
@@ -169,7 +169,7 @@ public void ExistsPromotedDependencyInTheBlackList()
         /// - A single reference to DependsOnUnified was passed in.
         ///   - This assembly depends on version 1.0.0.0 of UnifyMe.
         /// - An app.config was passed in that promotes a *different* assembly version name from
-        //    1.0.0.0 to 2.0.0.0
+        // 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of the file exists.
         /// - Version 2.0.0.0 of the file exists.
         /// Expected:
diff --git a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
index 8c272d7a1be..4ff1910ebc4 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
@@ -156,7 +156,7 @@ public void HigherThanHighestInRedistListForMSBuildAssembly()
             Assert.Equal(1, e.Warnings); // "Expected one warning in this scenario."
 
             // TODO: https://github.com/dotnet/msbuild/issues/2305
-            //e.AssertLogContains("Microsoft.Build.dll");
+            // e.AssertLogContains("Microsoft.Build.dll");
             Assert.Empty(t2.ResolvedFiles);
 
             ResolveAssemblyReference t3 = new ResolveAssemblyReference();
@@ -299,7 +299,7 @@ public void DependenciesHigherThanHighestInRedistListForMSBuildAssembly()
             Assert.Empty(t2.ResolvedFiles);
 
             ResolveAssemblyReference t3 = new ResolveAssemblyReference();
-            //t2.TargetFrameworkVersion is null
+            // t2.TargetFrameworkVersion is null
 
             ExecuteRAROnItemsAndRedist(t3, e, items, redistString, false);
 
diff --git a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
index 0426e95f9d4..56c1a5e53b5 100644
--- a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
+++ b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
@@ -67,13 +67,13 @@ public void KeyContainer()
                 Assert.Equal(badParameterValue, t.KeyContainer); // "New KeyContainer value should be set"
                 CommandLine.ValidateHasParameter(t, @"/keycontainer:" + badParameterValue, false /* no response file */);
                 Utilities.ExecuteTaskAndVerifyLogContainsErrorFromResource(t, "AxTlbBaseTask.StrongNameUtils.NoKeyPairInContainer", t.KeyContainer);
-                //ensure the key does not exist in the CSP
+                // ensure the key does not exist in the CSP
                 StrongNameHelpers.StrongNameKeyDelete(goodParameterValue);
 
                 IntPtr publicKeyBlob = IntPtr.Zero;
                 int publicKeyBlobSize = 0;
 
-                //add key to CSP
+                // add key to CSP
                 if (StrongNameHelpers.StrongNameKeyGen(goodParameterValue, 1 /* leave key registered */, out publicKeyBlob, out publicKeyBlobSize) && publicKeyBlob != IntPtr.Zero)
                 {
                     StrongNameHelpers.StrongNameFreeBuffer(publicKeyBlob);
@@ -90,7 +90,7 @@ public void KeyContainer()
             }
             finally
             {
-                //remove key from CSP
+                // remove key from CSP
                 StrongNameHelpers.StrongNameKeyDelete(goodParameterValue);
 
                 // get rid of the generated temp file
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index d1fee1c666a..a3d57998984 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -513,7 +513,7 @@ public void DoCopyOverDifferentFile()
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile)) // HIGHCHAR: Test reads ASCII (not ANSI).
                     destinationFileContents = sr.ReadToEnd();
 
-                Assert.Equal("This is a source temp file.", destinationFileContents); //                     "Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
                 ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
             }
@@ -1341,7 +1341,7 @@ public void CopyToDestinationFolder()
                     me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
                 }
 
-                Assert.Equal("This is a source temp file.", destinationFileContents); //                     "Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
                 Assert.Single(t.DestinationFiles);
                 Assert.Single(t.CopiedFiles);
@@ -1401,7 +1401,7 @@ public void CopyDoubleEscapableFileToDestinationFolder()
                     destinationFileContents = sr.ReadToEnd();
                 }
 
-                Assert.Equal("This is a source temp file.", destinationFileContents); //                     "Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
                 Assert.Single(t.DestinationFiles);
                 Assert.Single(t.CopiedFiles);
@@ -2169,7 +2169,7 @@ public void CopyToDestinationFolderWithHardLinkCheck()
 
                 // Read the destination file (it should have the same modified content as the source)
                 destinationFileContents = File.ReadAllText(destFile);
-                Assert.Equal("This is another source temp file.", destinationFileContents); //"Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
+                Assert.Equal("This is another source temp file.", destinationFileContents); // "Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
 
                 ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
             }
@@ -2253,9 +2253,9 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
                 me.AssertLogContains("0x80070011");
 
                 string destinationFileContents = File.ReadAllText(destFile1);
-                Assert.Equal("This is source temp file 1.", destinationFileContents); //"Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is source temp file 1.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
                 destinationFileContents = File.ReadAllText(destFile2);
-                Assert.Equal("This is source temp file 2.", destinationFileContents); //"Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is source temp file 2.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
                 Assert.Equal(2, t.DestinationFiles.Length);
                 Assert.Equal(2, t.CopiedFiles.Length);
@@ -2271,7 +2271,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
 
                 // Read the destination file (it should have the same modified content as the source)
                 destinationFileContents = File.ReadAllText(destFile1);
-                Assert.Equal("This is source temp file 1.", destinationFileContents); //"Expected the destination copied file to contain the contents of original source file only."
+                Assert.Equal("This is source temp file 1.", destinationFileContents); // "Expected the destination copied file to contain the contents of original source file only."
 
                 ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
             }
@@ -2348,7 +2348,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
                 me.AssertLogContains("0x80070476");
 
                 string destinationFileContents = File.ReadAllText(destFile);
-                Assert.Equal("This is a source temp file.", destinationFileContents); //"Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
                 Assert.Single(t.DestinationFiles);
                 Assert.Single(t.CopiedFiles);
@@ -2362,7 +2362,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
 
                 // Read the destination file (it should have the same modified content as the source)
                 destinationFileContents = File.ReadAllText(destFile);
-                Assert.Equal("This is a source temp file.", destinationFileContents); //"Expected the destination copied file to contain the contents of original source file only."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination copied file to contain the contents of original source file only."
 
                 ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
             }
@@ -2443,7 +2443,7 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
                     me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.SymbolicLinkComment", sourceFile, destFile);
 
                     string destinationFileContents = File.ReadAllText(destFile);
-                    Assert.Equal("This is a source temp file.", destinationFileContents); //"Expected the destination symbolic linked file to contain the contents of source file."
+                    Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination symbolic linked file to contain the contents of source file."
 
                     Assert.Single(t.DestinationFiles);
                     Assert.Single(t.CopiedFiles);
@@ -2458,7 +2458,7 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
 
                     // Read the destination file (it should have the same modified content as the source)
                     destinationFileContents = File.ReadAllText(destFile);
-                    Assert.Equal("This is another source temp file.", destinationFileContents); //"Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
+                    Assert.Equal("This is another source temp file.", destinationFileContents); // "Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
 
                     ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3891"); // Didn't do retries
                 }
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 54b3cc595e9..72fe8006abd 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -869,31 +869,31 @@ public void SetEnvironmentVariableParameter()
         [Fact]
         public void ConsoleToMSBuild()
         {
-            //Exec with no output
+            // Exec with no output
             Exec exec = PrepareExec("set foo=blah");
-            //Test Set and Get of ConsoleToMSBuild
+            // Test Set and Get of ConsoleToMSBuild
             exec.ConsoleToMSBuild = true;
             Assert.True(exec.ConsoleToMSBuild);
 
             bool result = exec.Execute();
             Assert.True(result);
 
-            //Nothing to run, so the list should be empty
+            // Nothing to run, so the list should be empty
             Assert.Empty(exec.ConsoleOutput);
 
 
-            //first echo prints "Hello stderr" to stderr, second echo prints to stdout
+            // first echo prints "Hello stderr" to stderr, second echo prints to stdout
             string testString = "echo Hello stderr 1>&2\necho Hello stdout";
             exec = PrepareExec(testString);
 
-            //Test Set and Get of ConsoleToMSBuild
+            // Test Set and Get of ConsoleToMSBuild
             exec.ConsoleToMSBuild = true;
             Assert.True(exec.ConsoleToMSBuild);
 
             result = exec.Execute();
             Assert.True(result);
 
-            //Both two lines should had gone to stdout
+            // Both two lines should had gone to stdout
             Assert.Equal(2, exec.ConsoleOutput.Length);
         }
 
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index a253692c77a..40f3e4615d4 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -68,11 +68,11 @@ private static string MakeFakeSDKStructure()
                         new[] { tempPath, "Windows", "2.0", "ExtensionSDKs", "MyAssembly", "3.0", "SDKManifest.xml" }),
                     "Hello");
 
-                //Bad because of v in the sdk version
+                // Bad because of v in the sdk version
                 Directory.CreateDirectory(
                     Path.Combine(new[] { tempPath, "Windows", "v1.0", "ExtensionSDKs", "MyAssembly", "v1.1" }));
 
-                //Bad because no extensionSDKs directory under the platform version
+                // Bad because no extensionSDKs directory under the platform version
                 Directory.CreateDirectory(Path.Combine(tempPath, "Windows", "v3.0") + Path.DirectorySeparatorChar);
 
                 // Bad because the directory under the identifier is not a version
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index c6d8f5337b0..30d4a11db71 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -73,7 +73,7 @@ public void SomeInputsFailToCreate()
             try
             {
                 FileStream fs = File.Create(file);
-                fs.Dispose(); //we're gonna try to delete it
+                fs.Dispose(); // we're gonna try to delete it
 
                 MakeDir t = new MakeDir();
                 MockEngine engine = new MockEngine();
@@ -184,7 +184,7 @@ public void FileAlreadyExists()
             try
             {
                 FileStream fs = File.Create(file);
-                fs.Dispose(); //we're gonna try to delete it
+                fs.Dispose(); // we're gonna try to delete it
 
                 MakeDir t = new MakeDir();
                 MockEngine engine = new MockEngine();
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index ba89346895c..2ac0ecd66f6 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -141,7 +141,7 @@ public void NonexistentSource()
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
                     destinationFileContents = sr.ReadToEnd();
 
-                Assert.Equal("This is a destination temp file.", destinationFileContents); //                     "Expected the destination file to still contain the contents of destination file."
+                Assert.Equal("This is a destination temp file.", destinationFileContents); // "Expected the destination file to still contain the contents of destination file."
             }
             finally
             {
@@ -220,7 +220,7 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
                     destinationFileContents = sr.ReadToEnd();
 
-                Assert.Equal("This is a destination temp file.", destinationFileContents); //                     "Expected the destination file to be unchanged."
+                Assert.Equal("This is a destination temp file.", destinationFileContents); // "Expected the destination file to be unchanged."
 
                 Assert.True(((new FileInfo(destinationFile)).Attributes & FileAttributes.ReadOnly) != 0); // should still be r/o
             }
@@ -266,7 +266,7 @@ public void MoveOverExistingFileDestinationWriteable()
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
                     destinationFileContents = sr.ReadToEnd();
 
-                Assert.Equal("This is a source temp file.", destinationFileContents); //                     "Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
             }
             finally
             {
@@ -316,7 +316,7 @@ public void MoveOverExistingFileOverwriteReadOnly()
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
                     destinationFileContents = sr.ReadToEnd();
 
-                Assert.Equal("This is a source temp file.", destinationFileContents); //                     "Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
                 Assert.True(((new FileInfo(destinationFile)).Attributes & FileAttributes.ReadOnly) == 0); // readonly bit should not be set
             }
@@ -364,7 +364,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
                     destinationFileContents = sr.ReadToEnd();
 
-                Assert.Equal("This is a source temp file.", destinationFileContents); //                     "Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
                 Assert.True(((new FileInfo(destinationFile)).Attributes & FileAttributes.ReadOnly) == 0); // should have cleared r/o bit
             }
@@ -673,7 +673,7 @@ public void MoveToNonexistentDestinationFolder()
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
                     destinationFileContents = sr.ReadToEnd();
 
-                Assert.Equal("This is a source temp file.", destinationFileContents); //                     "Expected the destination file to contain the contents of source file."
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
                 Assert.Single(t.DestinationFiles);
                 Assert.Single(t.MovedFiles);
diff --git a/src/Tasks.UnitTests/PortableTasks_Tests.cs b/src/Tasks.UnitTests/PortableTasks_Tests.cs
index 0a42a0d4fe8..20353efc583 100644
--- a/src/Tasks.UnitTests/PortableTasks_Tests.cs
+++ b/src/Tasks.UnitTests/PortableTasks_Tests.cs
@@ -52,7 +52,7 @@ private void RunMSBuildOnProjectWithPortableTaskAndAssertOutput(bool useDesktopM
                 var folder = env.CreateFolder().Path;
                 var projFile = Path.Combine(folder, ProjectFileName);
 
-                //"Debug", "netstandard1.3"
+                // "Debug", "netstandard1.3"
                 DirectoryInfo ProjectFileFolder =
                     new DirectoryInfo(PortableTaskFolderPath).EnumerateDirectories().First().EnumerateDirectories().First();
 
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 3775b381be0..cb8bb5379f2 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -820,7 +820,7 @@ private void CheckAxReferenceRCWTlbExists(RcwStyle rcwStyle, bool includeVersion
                         includeVersionInInteropName,
                         tlbRefInfo.attr.wMajorVerNum,
                         tlbRefInfo.attr.wMinorVerNum
-                        )); //                     "Expected Ax reference's RCW name to match the new TLB"
+                        )); // "Expected Ax reference's RCW name to match the new TLB"
         }
     }
 }
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 95fe855c9bd..8607667d3c3 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -52,7 +52,7 @@ public void ParseItemSpecGood()
         [Fact]
         public void ParseItemSpecBadNames()
         {
-            //These should all be bad the format must be   <SDKName>, Version=<SDKVersion>.
+            // These should all be bad the format must be   <SDKName>, Version=<SDKVersion>.
             TestBadSDKReferenceIncludes(new TaskItem(""));
             TestBadSDKReferenceIncludes(new TaskItem("Cat, Version=8"));
             TestBadSDKReferenceIncludes(new TaskItem("Cat 8.0"));
@@ -380,7 +380,7 @@ public void VerifyUnResolvedSDKMessage()
             reference5.DependsOnSDK = "reference1, Version=1.0";
             references.Add(reference5);
 
-            ResolveSDKReference.VerifySDKDependsOn(log, references); //, new Version(8, 1), "Windows", null);
+            ResolveSDKReference.VerifySDKDependsOn(log, references); // , new Version(8, 1), "Windows", null);
             Assert.Equal(0, engine.Warnings);
             Assert.Equal(0, engine.Errors);
             Assert.Equal(0, engine.Log.Length);
@@ -407,7 +407,7 @@ public void VerifyUnResolvedSDKMessage()
             reference4.DependsOnSDK = "NotThere, Version=1.0";
             references.Add(reference4);
 
-            ResolveSDKReference.VerifySDKDependsOn(log, references); //, new Version(8, 1), "Windows", null);
+            ResolveSDKReference.VerifySDKDependsOn(log, references); // , new Version(8, 1), "Windows", null);
             Assert.Equal(4, engine.Warnings);
             Assert.Equal(0, engine.Errors);
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index ac9f6c92ce8..dc5742c039b 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -2355,7 +2355,7 @@ public References(ITestOutputHelper output)
         }
 
         [Fact]
-        //FIXME: mono: looks for csc.exe
+        // FIXME: mono: looks for csc.exe
         // https://github.com/dotnet/msbuild/issues/677
         [Trait("Category", "mono-osx-failing")]
         public void DontLockP2PReferenceWhenResolvingSystemTypes()
@@ -2533,7 +2533,7 @@ public class Class1
         /// absolute path).  The fix was to use Assembly.LoadFrom instead.
         /// </summary>
         [Fact]
-        //FIXME: mono: looks for csc.exe
+        // FIXME: mono: looks for csc.exe
         // https://github.com/dotnet/msbuild/issues/677
         [Trait("Category", "mono-osx-failing")]
         public void ReferencedAssemblySpecifiedUsingRelativePath()
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 038639c72ed..64383a4c4b7 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -3263,7 +3263,7 @@ public void MultiTargetingDefaultsSetCorrectly()
             Assert.True(t.ExecuteAsTool); // "ExecuteAsTool should default to true"
         }
 
-        //  Regression test for https://github.com/dotnet/msbuild/issues/2206
+        // Regression test for https://github.com/dotnet/msbuild/issues/2206
         [Theory]
         [InlineData("\n")]
         [InlineData("\r\n")]
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
index 1bd44f2bbd4..b4ac8290ae1 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
@@ -226,11 +226,11 @@ public void References()
             // reference switch adds space + "/r:", (4 characters)
             int referenceSwitchDelta = 4;
 
-            //subtract one because leading space is added to command line arguments
+            // subtract one because leading space is added to command line arguments
             int maxCommandLineLength = 28000 - 1;
             int referencePathLength = 200;
 
-            //min reference argument is " /r:a.dll"
+            // min reference argument is " /r:a.dll"
             int minReferenceArgumentLength = referenceSwitchDelta + "a.dll".Length;
 
             // reference name is of the form aaa...aaa###.dll (repeated a characters followed by 3
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index d73842e0898..17d45366bca 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -356,7 +356,7 @@ public void TestLoadAndParseFromAbsoluteFilePath()
             finally
             {
                 // This throws because the file is still in use!
-                //if (File.Exists(tmpXamlFile))
+                // if (File.Exists(tmpXamlFile))
                 //    File.Delete(tmpXamlFile);
             }
         }
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 8a6d3f7a516..0073d3d5c7e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -477,7 +477,7 @@ private static AssemblyName GetAssemblyName(MetadataReader metadataReader, Assem
 // Enabling this for MONO, because it's required by GetFrameworkName.
 // More details are in the comment for that method
 #if FEATURE_ASSEMBLYLOADCONTEXT || MONO
-        //  This method copied from DNX source: https://github.com/aspnet/dnx/blob/e0726f769aead073af2d8cd9db47b89e1745d574/src/Microsoft.Dnx.Tooling/Utils/LockFileUtils.cs#L385
+        // This method copied from DNX source: https://github.com/aspnet/dnx/blob/e0726f769aead073af2d8cd9db47b89e1745d574/src/Microsoft.Dnx.Tooling/Utils/LockFileUtils.cs#L385
         //  System.Reflection.Metadata 1.1 is expected to have an API that helps with this.
         /// <summary>
         /// Gets the fixed (required) string arguments of a custom attribute.
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 015ff467546..da913266467 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -1123,7 +1123,7 @@ out found
                 return;
             }
 
-            //  It was resolved locally, so copy it.
+            // It was resolved locally, so copy it.
             CopyLocal = CopyLocalState.YesBecauseOfHeuristic;
         }
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index ea98b6b457d..4cb1e0d2a63 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -1434,7 +1434,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                         // we want to know if any primary references have specific version set to true.
                         bool hasSpecificVersionTrue = assemblyReference.CheckForSpecificVersionMetadataOnParentsReference(true);
 
-                        //A dependency is "good" if it is not in the black list or any of its parents have specific version set to true
+                        // A dependency is "good" if it is not in the black list or any of its parents have specific version set to true
                         if (!isMarkedForExclusion || hasSpecificVersionTrue)
                         {
                             // Do not add the reference to the good list if it has been added to the removed references list, possibly because of us processing another reference.
@@ -2289,7 +2289,7 @@ private static bool AreAssembliesEquivalent(
             return false;
         }
 
-        //  Based on coreclr baseassemblyspec.cpp (https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L330)
+        // Based on coreclr baseassemblyspec.cpp (https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L330)
         private static bool RefMatchesDef(AssemblyName @ref, AssemblyName def)
         {
             if (IsStrongNamed(@ref))
@@ -2309,7 +2309,7 @@ private static bool IsStrongNamed(AssemblyName assembly)
             return refPkt != null && refPkt.Length != 0;
         }
 
-        //  Based on https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L241
+        // Based on https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L241
         private static bool CompareRefToDef(AssemblyName @ref, AssemblyName def)
         {
             if (!@ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase))
@@ -2382,7 +2382,7 @@ private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyRef
                 string leftConflictFusionName = assemblyReference0.assemblyName.FullName;
                 string rightConflictFusionName = assemblyReference1.assemblyName.FullName;
 
-                //  If both assemblies being compared are primary references, the caller should pass in a zero-flag 
+                // If both assemblies being compared are primary references, the caller should pass in a zero-flag 
                 // (non-unified) for both. (This conforms to the C# assumption that two direct references are meant to be 
                 // SxS.)
                 bool isNonUnified = leftConflictReference.IsPrimary && rightConflictReference.IsPrimary;
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 636dd5536b5..e6921de70e3 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -372,7 +372,7 @@ protected override void LogPathToTool(string toolName, string pathToTool)
         /// <param name="message"></param>
         protected override void LogToolCommand(string message)
         {
-            //Dont print the command line if Echo is Off.
+            // Dont print the command line if Echo is Off.
             if (!EchoOff)
             {
                 base.LogToolCommand(Command);
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index c344b62e71a..3defe6023da 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -3442,7 +3442,7 @@ private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, Str
             // Generate the STR class
             String[] errors;
             bool generateInternalClass = !_stronglyTypedClassIsPublic;
-            //StronglyTypedResourcesNamespace can be null and this is ok.
+            // StronglyTypedResourcesNamespace can be null and this is ok.
             // If it is null then the default namespace (=stronglyTypedNamespace) is used.
             CodeCompileUnit ccu = StronglyTypedResourceBuilder.Create(
                     reader.resourcesHashTable,
diff --git a/src/Tasks/GetFrameworkSDKPath.cs b/src/Tasks/GetFrameworkSDKPath.cs
index 8a9a26b1701..99555f83897 100644
--- a/src/Tasks/GetFrameworkSDKPath.cs
+++ b/src/Tasks/GetFrameworkSDKPath.cs
@@ -312,7 +312,7 @@ public string FrameworkSdkVersion461Path
         /// <returns>true</returns>
         public override bool Execute()
         {
-            //Does Nothing: getters do all the work
+            // Does Nothing: getters do all the work
 
             return true;
         }
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 498222d091a..116439f37de 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -24,8 +24,8 @@ internal class ComImporter
         // These must be defined in sorted order!
         private static readonly string[] s_knownImplementedCategories =
         {
-            "{02496840-3AC4-11cf-87B9-00AA006C8166}", //CATID_VBFormat
-            "{02496841-3AC4-11cf-87B9-00AA006C8166}", //CATID_VBGetControl
+            "{02496840-3AC4-11cf-87B9-00AA006C8166}", // CATID_VBFormat
+            "{02496841-3AC4-11cf-87B9-00AA006C8166}", // CATID_VBGetControl
             "{40FC6ED5-2438-11CF-A3DB-080036F12502}",
         };
         private static readonly string[] s_knownSubKeys =
@@ -65,7 +65,7 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
                 Guid tlbid = typeLibAttr.guid;
 
                 tlib.GetDocumentation(-1, out _, out string docString, out _, out string helpFile);
-                string helpdir = Util.FilterNonprintableChars(helpFile); //Path.GetDirectoryName(helpFile);
+                string helpdir = Util.FilterNonprintableChars(helpFile); // Path.GetDirectoryName(helpFile);
 
                 TypeLib = new TypeLib(tlbid, new Version(typeLibAttr.wMajorVerNum, typeLibAttr.wMinorVerNum), helpdir, typeLibAttr.lcid, Convert.ToInt32(typeLibAttr.wLibFlags, CultureInfo.InvariantCulture));
 
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index e518fe1ae4d..ddfda42d466 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -267,15 +267,15 @@ private static string PatchCLRVersion(string version)
             }
             catch (ArgumentException)
             {
-                //continue
+                // continue
             }
             catch (FormatException)
             {
-                //continue
+                // continue
             }
             catch (OverflowException)
             {
-                //continue 
+                // continue 
             }
 
             return version;
diff --git a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
index be6b845d311..bcf29162ac8 100644
--- a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
+++ b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
@@ -46,7 +46,7 @@ private bool EnumResNameCallback(IntPtr hModule, IntPtr pType, IntPtr pName, Int
             IntPtr hResInfo = NativeMethods.FindResource(hModule, pName, NativeMethods.RT_MANIFEST);
             if (hResInfo == IntPtr.Zero)
             {
-                return false; //continue looking
+                return false; // continue looking
             }
             IntPtr hResource = NativeMethods.LoadResource(hModule, hResInfo);
             NativeMethods.LockResource(hResource);
@@ -55,7 +55,7 @@ private bool EnumResNameCallback(IntPtr hModule, IntPtr pType, IntPtr pName, Int
 
             Marshal.Copy(hResource, buffer, 0, buffer.Length);
             _manifest = new MemoryStream(buffer, false);
-            return false; //found what we are looking for
+            return false; // found what we are looking for
         }
 
         public static Stream Read(string path)
diff --git a/src/Tasks/ManifestUtil/ManifestFormatter.cs b/src/Tasks/ManifestUtil/ManifestFormatter.cs
index f2bada597f7..5434d2ebbb1 100644
--- a/src/Tasks/ManifestUtil/ManifestFormatter.cs
+++ b/src/Tasks/ManifestUtil/ManifestFormatter.cs
@@ -65,7 +65,7 @@ public static Stream Format(Stream input)
                                 w.WriteAttributeString(r.Prefix, r.LocalName, r.NamespaceURI, r.Value);
                             }
 
-                            r.MoveToElement(); //Moves the reader back to the element node.
+                            r.MoveToElement(); // Moves the reader back to the element node.
                         }
 
                         if (r.IsEmptyElement)
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 70f835b620c..e87d1a84d0b 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -35,7 +35,7 @@ public static string[] GetPathSegments(string path)
             return path.Split(MSBuildConstants.DirectorySeparatorChar);
         }
 
-        //Resolves the path, and if path is a url also canonicalizes it.
+        // Resolves the path, and if path is a url also canonicalizes it.
         public static string Format(string path)
         {
             if (String.IsNullOrEmpty(path)) return path;
@@ -127,8 +127,8 @@ public static bool IsUrl(string path)
             return !u.IsUnc && !String.IsNullOrEmpty(u.Host);
         }
 
-        //If path is a url and starts with "localhost", resolves to machine name.
-        //If path is a relative path, resolves to a full path.
+        // If path is a url and starts with "localhost", resolves to machine name.
+        // If path is a relative path, resolves to a full path.
         public static string Resolve(string path)
         {
             if (String.IsNullOrEmpty(path)) return path;
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index bf36239367a..de1caa01567 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -222,13 +222,13 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioni
                                     }
                                     catch (Exception)
                                     {
-                                        //continue.
+                                        // continue.
                                     }
                                 }
                             }
                             catch (ArgumentException)
                             {
-                                //continue.
+                                // continue.
                             }
                         }
                     }
@@ -469,7 +469,7 @@ public static PermissionSet XmlToPermissionSet(XmlElement element)
             }
             catch (ArgumentException ex)
             {
-                //UNDONE: Need to log exception thrown from PermissionSet.FromXml
+                // UNDONE: Need to log exception thrown from PermissionSet.FromXml
                 Debug.Fail(String.Format(CultureInfo.CurrentCulture, "PermissionSet.FromXml failed: {0}\r\n\r\n{1}", ex.Message, element.OuterXml));
                 return null;
             }
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index 1652655417d..ce5a2b4843e 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -195,7 +195,7 @@ private XmlElement GetInputRequestedPrivilegeElement()
 
         private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequestedPrivilegeElement, XmlDocument document)
         {
-            //  <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
+            // <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
             //      <!--
             //          UAC Manifest Options
             //          If you want to change the Windows User Account Control level replace the 
@@ -553,7 +553,7 @@ public void Write(Stream output)
             var outputDocument = new XmlDocument();
             XmlElement inputPermissionSetElement = GetInputPermissionSetElement();
 
-            //NOTE: XmlDocument.ImportNode munges "xmlns:asmv2" to "xmlns:d1p1" for some reason, use XmlUtil.CloneElementToDocument instead
+            // NOTE: XmlDocument.ImportNode munges "xmlns:asmv2" to "xmlns:d1p1" for some reason, use XmlUtil.CloneElementToDocument instead
             XmlElement outputPermissionSetElement = XmlUtil.CloneElementToDocument(inputPermissionSetElement, outputDocument, XmlNamespaces.asmv2);
             outputDocument.AppendChild(outputPermissionSetElement);
 
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index 744e74775eb..e370c0cad8a 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -30,7 +30,7 @@ public static string GetQName(XmlTextReader r, XmlNamespaceManager nsmgr)
                 return r.LocalName;
         }
 
-        //NOTE: XmlDocument.ImportNode munges "xmlns:asmv2" to "xmlns:d1p1" for some reason, use XmlUtil.CloneElementToDocument instead
+        // NOTE: XmlDocument.ImportNode munges "xmlns:asmv2" to "xmlns:d1p1" for some reason, use XmlUtil.CloneElementToDocument instead
         public static XmlElement CloneElementToDocument(XmlElement element, XmlDocument document, string namespaceURI)
         {
             XmlElement newElement = document.CreateElement(element.Name, namespaceURI);
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 578af1fe268..e2cdca0cc3b 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -562,9 +562,9 @@ internal enum REGKIND
         }
 
         // Set of IMAGE_FILE constants which represent the processor architectures for native assemblies.
-        internal const UInt16 IMAGE_FILE_MACHINE_UNKNOWN = 0x0; //	The contents of this field are assumed to be applicable to any machine type
+        internal const UInt16 IMAGE_FILE_MACHINE_UNKNOWN = 0x0; // The contents of this field are assumed to be applicable to any machine type
         internal const UInt16 IMAGE_FILE_MACHINE_INVALID = UInt16.MaxValue; // Invalid value for the machine type.
-        internal const UInt16 IMAGE_FILE_MACHINE_AMD64 = 0x8664; //	x64
+        internal const UInt16 IMAGE_FILE_MACHINE_AMD64 = 0x8664; // x64
         internal const UInt16 IMAGE_FILE_MACHINE_ARM = 0x1c0; // ARM little endian
         internal const UInt16 IMAGE_FILE_MACHINE_ARMV7 = 0x1c4; // ARMv7 (or higher) Thumb mode only
         internal const UInt16 IMAGE_FILE_MACHINE_I386 = 0x14c; // Intel 386 or later processors and compatible processors
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 62bd9251366..58640172d76 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -868,7 +868,7 @@ public void Add(ITaskItem item)
                 int i = fusionName.IndexOf(',');
                 if (i > 0)
                 {
-                    string simpleName = fusionName.Substring(0, i); //example: "ClassLibrary1, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" -> "ClassLibrary1"
+                    string simpleName = fusionName.Substring(0, i); // example: "ClassLibrary1, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" -> "ClassLibrary1"
                     key = simpleName.ToLowerInvariant();
                     // If there are multiple with same simple name then we'll take the first one and ignore the rest, which is not an unreasonable thing to do
                     if (!_simpleNameDictionary.ContainsKey(key))
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 6bbd44a1e4e..0f2b3752dbe 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -241,7 +241,7 @@ internal bool ExtractFromManifest(
                     {
                         if (assemblyref.IsVirtual)
                         {
-                            //It is a CLR virtual reference, not a real reference.
+                            // It is a CLR virtual reference, not a real reference.
                             continue;
                         }
 
diff --git a/src/Tasks/ResolveProjectBase.cs b/src/Tasks/ResolveProjectBase.cs
index 0a8f2b085d3..3995d2a35f1 100644
--- a/src/Tasks/ResolveProjectBase.cs
+++ b/src/Tasks/ResolveProjectBase.cs
@@ -138,11 +138,11 @@ internal void CacheProjectElementsFromXml(string xmlString)
 
             // Example:
             //
-            //<SolutionConfiguration>
+            // <SolutionConfiguration>
             //  <ProjectConfiguration Project="{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}" AbsolutePath="c:foo\Project1\A.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
             //  <ProjectConfiguration Project="{881C1674-4ECA-451D-85B6-D7C59B7F16FA}" AbsolutePath="c:foo\Project2\B.csproj" BuildProjectInSolution="True">Debug|AnyCPU<ProjectDependency Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" /></ProjectConfiguration>
             //  <ProjectConfiguration Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" AbsolutePath="c:foo\Project3\C.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
-            //</SolutionConfiguration>
+            // </SolutionConfiguration>
             //
             if (doc?.DocumentElement != null)
             {
diff --git a/src/Tasks/SGen.cs b/src/Tasks/SGen.cs
index 2409cd9c0ff..27c58a1c5bb 100644
--- a/src/Tasks/SGen.cs
+++ b/src/Tasks/SGen.cs
@@ -366,7 +366,7 @@ protected override string GenerateCommandLineCommands()
 
                 commandLineBuilder.AppendWhenTrue("/proxytypes", Bag, "UseProxyTypes");
 
-                //add the keep switch
+                // add the keep switch
                 commandLineBuilder.AppendWhenTrue("/keep", Bag, "UseKeep");
 
                 // Append the references, if any.
@@ -382,7 +382,7 @@ protected override string GenerateCommandLineCommands()
                     }
                 }
 
-                //Append the Types to the command line, if any.
+                // Append the Types to the command line, if any.
                 if (Types != null)
                 {
                     foreach (string type in Types)
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 889688864cb..26325de8241 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -146,7 +146,7 @@ private string GenerateCode(out string extension)
 #if FEATURE_SYSTEM_CONFIGURATION
             (e is ConfigurationException || e is SecurityException)
 #else
-            (e.GetType().Name == "ConfigurationErrorsException") //TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456
+            (e.GetType().Name == "ConfigurationErrorsException") // TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456
 #endif
             {
                 Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotCreateProvider", Language, e.Message);
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 400f364cb99..a8e2ace0c3e 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -554,7 +554,7 @@ private static SwitchRelations ObtainAttributes(XmlNode node, SwitchRelations sw
                         switchRelations.Status = attribute.InnerText;
                         break;
                     default:
-                        //LogError("InvalidAttribute", attribute.Name);
+                        // LogError("InvalidAttribute", attribute.Name);
                         break;
                 }
             }
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index def8c175df6..1f79b6ccd1c 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -226,7 +226,7 @@ internal void ValidateOverrides()
         {
             List<string> overriddenSwitches = new List<string>();
 
-            //Collect the overrided switches
+            // Collect the overrided switches
             foreach (KeyValuePair<string, CommandLineToolSwitch> overriddenSwitch in ActiveToolSwitches)
             {
                 foreach (KeyValuePair<string, string> overridePair in overriddenSwitch.Value.Overrides)
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 7fffdebcf51..0facabc1b83 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -203,7 +203,7 @@ private static CodeCompileUnit InternalCreate(Dictionary<String, ResourceData> r
             AddGeneratedCodeAttributeforMember(srClass);
 
             TypeAttributes ta = internalClass ? TypeAttributes.NotPublic : TypeAttributes.Public;
-            //ta |= TypeAttributes.Sealed;
+            // ta |= TypeAttributes.Sealed;
             srClass.TypeAttributes = ta;
             srClass.Comments.Add(new CodeCommentStatement(DocCommentSummaryStart, true));
             srClass.Comments.Add(new CodeCommentStatement(SR.GetString(SR.ClassDocComment), true));
diff --git a/src/Utilities.UnitTests/CanonicalError_Tests.cs b/src/Utilities.UnitTests/CanonicalError_Tests.cs
index 02dd4b68740..755fc101ddd 100644
--- a/src/Utilities.UnitTests/CanonicalError_Tests.cs
+++ b/src/Utilities.UnitTests/CanonicalError_Tests.cs
@@ -192,7 +192,7 @@ public void ValidateErrorMessageWithFileName3()
         [Fact]
         public void ValidateErrorMessageVariableNotUsed()
         {
-            //      (line)
+            // (line)
             ValidateFileNameMultiLineColumnError("Main.cs():Command line warning CS0168: The variable 'foo' is declared but never used",
                 "Main.cs", CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
@@ -203,7 +203,7 @@ public void ValidateErrorMessageVariableNotUsed()
                 "Main.cs", CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, 3, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
 
-            //      (line-line)
+            // (line-line)
             ValidateFileNameMultiLineColumnError("Main.cs(-):Command line warning CS0168: The variable 'foo' is declared but never used",
                 "Main.cs", CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
@@ -216,7 +216,7 @@ public void ValidateErrorMessageVariableNotUsed()
                 "Main.cs", 1, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
 
-            //      (line,col)
+            // (line,col)
             ValidateFileNameMultiLineColumnError("Main.cs(,):Command line warning CS0168: The variable 'foo' is declared but never used",
                 "Main.cs", CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
@@ -239,7 +239,7 @@ public void ValidateErrorMessageVariableNotUsed()
                 "Main.cs", CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
 
-            //      (line,col-col)
+            // (line,col-col)
             ValidateFileNameMultiLineColumnError("Main.cs(,-):Command line warning CS0168: The variable 'foo' is declared but never used",
                 "Main.cs", CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
@@ -260,7 +260,7 @@ public void ValidateErrorMessageVariableNotUsed()
                 "Main.cs", CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
 
-            //      (line,col,line,col)
+            // (line,col,line,col)
             ValidateFileNameMultiLineColumnError("Main.cs(,,,):Command line warning CS0168: The variable 'foo' is declared but never used",
                 "Main.cs", CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified, CanonicalError.Parts.numberNotSpecified,
                 CanonicalError.Parts.Category.Warning, "CS0168", "The variable 'foo' is declared but never used");
diff --git a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
index 25e43977f53..01cfda5a33f 100644
--- a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
+++ b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
@@ -414,7 +414,7 @@ public void AppendSwitchUnQuotedTaskItem()
         public void AppendSwitchWithOddNumberOfLiteralQuotesInParameter()
         {
             CommandLineBuilder c = new CommandLineBuilder();
-            c.AppendSwitchIfNotNull("/D", @"A='""'");     //   /DA='"'
+            c.AppendSwitchIfNotNull("/D", @"A='""'");     // /DA='"'
             c.ShouldBe(@"/D""A='\""'"""); //   /D"A='\"'"
         }
 
diff --git a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
index fc99719c10f..fbafeb6cf97 100644
--- a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
@@ -64,7 +64,7 @@ public void ValidateConvertDotNetFrameworkArchitectureToProcessorArchitecture()
 
                     procArchitecture = ToolLocationHelper.ConvertDotNetFrameworkArchitectureToProcessorArchitecture(Utilities.DotNetFrameworkArchitecture.Bitness64);
 
-                    //We should also allow NULL if the machine is true x86 only.
+                    // We should also allow NULL if the machine is true x86 only.
                     bool isValidResult = procArchitecture?.Equals(ProcessorArchitecture.AMD64) != false || procArchitecture.Equals(ProcessorArchitecture.IA64);
 
                     isValidResult.ShouldBeTrue();
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 9067d780c92..965f5a9e2f8 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -4192,7 +4192,7 @@ public void VerifyFindRootFolderWhereAllFilesExist()
         {
             // create directories and files in them
 
-            //  root1
+            // root1
             //     subdir
             //         file1.txt
             //     file1.txt
@@ -4607,11 +4607,11 @@ private static string MakeFakeSDKStructure()
                 Directory.CreateDirectory(
                     Path.Combine(tempPath, "MyPlatform", "9.0", "Platforms", "Sparkle", "3.3.3.3")); // no platform.xml
 
-                //Bad because of v in the sdk version
+                // Bad because of v in the sdk version
                 Directory.CreateDirectory(
                     Path.Combine(tempPath, "Windows", "v1.0", "ExtensionSDKs", "AnotherAssembly", "v1.1"));
 
-                //Bad because no extensionsdks directory under the platform version
+                // Bad because no extensionsdks directory under the platform version
                 Directory.CreateDirectory(Path.Combine(tempPath, "Windows", "v3.0") + Path.DirectorySeparatorChar);
 
                 // Bad because the directory under the identifier is not a version
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index a7033377e98..67cb313a50e 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -533,7 +533,7 @@ public void ReadTLogWithDuplicateInRoot()
         {
             Console.WriteLine("Test: ReadTLogWithDuplicateInRoot");
 
-            //Prepare files
+            // Prepare files
             DependencyTestHelper.WriteAll("TestFiles\\one.h", "");
             DependencyTestHelper.WriteAll("TestFiles\\foo.cpp", "");
             DependencyTestHelper.WriteAll("TestFiles\\one.obj", "");
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 257be808cd0..2629634f436 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -46,7 +46,7 @@ namespace Microsoft.Build.Utilities
     ///     The event source will be cleaned up.  This may be interesting because the unregister will come from a thread other than what is doing the logging.
     ///     This may create a Synchronization issue, if unregister is called while events are being logged.
     /// </summary>
-    //     
+    // 
     // UNDONE: If we can use ErrorUtilities, replace all InvalidOperation and Argument exceptions with the appropriate calls.
     // 
     public class MuxLogger : INodeLogger
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 52987257bb6..875bb79b0ca 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2213,7 +2213,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
         {
             // Verify the root path is not null throw an ArgumentNullException if the given string parameter is null and ArgumentException if it has zero length.
             ErrorUtilities.VerifyThrowArgumentLength(targetFrameworkRootPath, nameof(targetFrameworkRootPath));
-            //Verify the framework class passed in is not null. Other than being null the class will ensure it is consistent and the internal state is correct
+            // Verify the framework class passed in is not null. Other than being null the class will ensure it is consistent and the internal state is correct
             ErrorUtilities.VerifyThrowArgumentNull(frameworkName, nameof(frameworkName));
 
             string referenceAssemblyCacheKey = GenerateReferenceAssemblyCacheKey(targetFrameworkRootPath, frameworkName);
@@ -2794,7 +2794,7 @@ internal static void GatherSDKsFromRegistryImpl(Dictionary<TargetPlatformSDK, Ta
                                 // Make something like SOFTWARE\MICROSOFT\Windows SDKs\Windows\8.0\ExtensionSDKs\XNA
                                 string sdkNameKey = extensionSDKsKey + @"\" + sdkName;
 
-                                //Get all of the version registry keys under the SDK Name Key.
+                                // Get all of the version registry keys under the SDK Name Key.
                                 IEnumerable<string> sdkVersions = getRegistrySubKeyNames(baseKey, sdkNameKey);
 
                                 ErrorUtilities.DebugTraceMessage("GatherSDKsFromRegistryImpl", "Getting subkeys of '{0}'", sdkNameKey);
@@ -3859,9 +3859,9 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
 
             var frameworkVersions = new List<string>();
 
-            //backward compatibility with orcas
-            //In case of orcas .NETFramework v3.0, v3.5 - the version folders are directly under the frameworkReferenceRoot
-            //first check here
+            // backward compatibility with orcas
+            // In case of orcas .NETFramework v3.0, v3.5 - the version folders are directly under the frameworkReferenceRoot
+            // first check here
             if (string.Equals(frameworkIdentifier, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase))
             {
                 IList<string> versions = GetFx35AndEarlierVersions(frameworkReferenceRoot);
@@ -3871,8 +3871,8 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
                 }
             }
 
-            //then look under the extensible multi-targeting layout - even for .NETFramework because future .NETFramework
-            //versions would be at the right place
+            // then look under the extensible multi-targeting layout - even for .NETFramework because future .NETFramework
+            // versions would be at the right place
             string frameworkIdentifierPath = Path.Combine(frameworkReferenceRoot, frameworkIdentifier);
 
             DirectoryInfo dirInfoFxIdentifierPath = new DirectoryInfo(frameworkIdentifierPath);
@@ -3880,8 +3880,8 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
             {
                 foreach (DirectoryInfo folder in dirInfoFxIdentifierPath.GetDirectories())
                 {
-                    //the expected version folder name is of the format v<MajorVersion>.<MinorVersion> e.g. v3.5
-                    //only add if the version folder name is of the right format
+                    // the expected version folder name is of the format v<MajorVersion>.<MinorVersion> e.g. v3.5
+                    // only add if the version folder name is of the right format
                     if (folder.Name.Length >= 4 && folder.Name.StartsWith("v", StringComparison.OrdinalIgnoreCase))
                     {
                         Version ver;
@@ -3893,8 +3893,8 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
                 }
             }
 
-            //sort in ascending order of the version numbers, this is important as later when we search for assemblies in other methods 
-            //we should be looking in ascending order of the framework version folders on disk
+            // sort in ascending order of the version numbers, this is important as later when we search for assemblies in other methods 
+            // we should be looking in ascending order of the framework version folders on disk
             frameworkVersions.Sort(VersionComparer.Instance);
 
             return frameworkVersions;
