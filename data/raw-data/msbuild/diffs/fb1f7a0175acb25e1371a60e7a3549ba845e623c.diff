diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index 5e2a138e3d5..9dc2f404fa2 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -22,7 +22,7 @@ Importing `Microsoft.Common.targets` includes logic that consumes these items an
 
 ## Who this document is for
 
-This document describes that process, including what is required of a project to be referenceable through a `ProjectReference`. It is intended for for MSBuild SDK maintainers, and those who have created a completely custom project type that needs to interoperate with other projects. It may also be of interest if you'd like to see the implementation details of references. Understanding the details should not be necessary to _use_ `ProjectReferences` in your project.
+This document describes that process, including what is required of a project to be referenceable through a `ProjectReference`. It is intended for MSBuild SDK maintainers, and those who have created a completely custom project type that needs to interoperate with other projects. It may also be of interest if you'd like to see the implementation details of references. Understanding the details should not be necessary to _use_ `ProjectReferences` in your project.
 
 ## Targets related to consuming a reference
 
@@ -51,7 +51,7 @@ These targets should exist in a project to be compatible with the common targets
 
 These targets are all defined in `Microsoft.Common.targets` and are defined in Microsoft SDKs. You should only have to implement them yourself if you require custom behavior or are authoring a project that doesn't import the common targets.
 
-If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworkProperties` is required in the “outer” build. The other targets listed can be “inner” build only.
+If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworks` is required in the “outer” build. The other targets listed can be “inner” build only.
 
 * `GetTargetFrameworks` tells referencing projects what options are available to the build.
   * It returns an item with the following metadata:
@@ -106,7 +106,7 @@ As of MSBuild 16.10, it is possible to gather additional properties from referen
 
 These properties will then be gathered via the `GetTargetFrameworks` call.  They will be available to the referencing project via the `AdditionalPropertiesFromProject` metadata on the `_MSBuildProjectReferenceExistent` item.  The `AdditionalPropertiesFromProject` value will be an XML string which contains the values of the properties for each `TargetFramework` in the referenced project.  For example:
 
-> :warning: This format is being changed. Soon, the schema will replace <net5.0> with <TargetFramework Name="net5.0">. You can opt into that behavior early by setting the _UseAttributeForTargetFrameworkInfoPropertyNames property to true. This property will have no effect after the transition is complete.
+> :warning: This format is being changed. Soon, the schema will replace `<net5.0>` with `<TargetFramework Name="net5.0">`. You can opt into that behavior early by setting the `_UseAttributeForTargetFrameworkInfoPropertyNames` property to true. This property will have no effect after the transition is complete.
 
 ```xml
 <AdditionalProjectProperties>
@@ -176,7 +176,7 @@ Project B: Unmanaged, has `$(Platforms)` constructed from its `Platform` metadat
 Because `AnyCPU` does not map to anything architecture-specific, a custom mapping must be defined. Project A can either:
 1. Define `PlatformLookupTable` in its project or a Directory.Build.props as `AnyCPU=x64` or `AnyCPU=Win32`.
 2. Define `PlatformLookupTable` as metadata on the `ProjectReference` item, which would take priority over a lookup table defined elsewhere.
-     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo` (for unmanaged) or `PlatformTarget=bar` (for managed). This would skip over most negotiation logic.
+     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo`. This would skip over most negotiation logic.
 
 Example of project A defining a lookup table directly on the `ProjectReference`:
 ```xml
diff --git a/documentation/consuming-nuget-package.md b/documentation/consuming-nuget-package.md
index e4e42f5c187..e611e2194d6 100644
--- a/documentation/consuming-nuget-package.md
+++ b/documentation/consuming-nuget-package.md
@@ -30,7 +30,7 @@ The items in this namespace are MSBuild tasks that have been developed by the MS
 [Csc](https://msdn.microsoft.com/en-us/library/microsoft.build.tasks.csc.aspx), and [Exec](https://msdn.microsoft.com/en-us/library/microsoft.build.tasks.exec.aspx).
 
 Most developers do not need to reference this package unless they want to extend a stock MSBuild task with custom functionality.  Alternatively, we recommend that MSBuild task developers reference the 
-`Microsoft.Build.Utilites.Core` package and implement the abstract class [Task](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.task.aspx) or
+`Microsoft.Build.Utilities.Core` package and implement the abstract class [Task](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.task.aspx) or
 [ToolTask](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.tooltask.aspx).
 
 ## Microsoft.Build
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 5b152e7c1a7..6c61626ec7b 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -8,7 +8,7 @@ Opt-out is a better approach for us because we'd likely get limited feedback whe
 The opt-out comes in the form of setting the environment variable `MSBuildDisableFeaturesFromVersion` to the Change Wave (or version) that contains the feature you want **disabled**. This version happens to be the version of MSBuild that the features were developed for. See the mapping of change waves to features below.
 
 ## When do they become permanent?
-A wave of features is set to "rotate out" (i.e. become standard functionality) two bands after its release. For example, wave 16.8 stayed opt-out through wave 16.10, becoming standard functionalty when wave 17.0 is introduced.
+A wave of features is set to "rotate out" (i.e. become standard functionality) two bands after its release. For example, wave 16.8 stayed opt-out through wave 16.10, becoming standard functionality when wave 17.0 is introduced.
 
 ## MSBuildDisableFeaturesFromVersion Values & Outcomes
 | `MSBuildDisableFeaturesFromVersion` Value                         | Result        | Receive Warning? |
diff --git a/eng/Build.props b/eng/Build.props
index 6393db2a363..2fff7c5c2ca 100644
--- a/eng/Build.props
+++ b/eng/Build.props
@@ -2,6 +2,10 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
 
+  <PropertyGroup>
+    <RestoreUseStaticGraphEvaluation>true</RestoreUseStaticGraphEvaluation>
+  </PropertyGroup>
+
   <ItemGroup>
 	<!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
 	Without this, arcade tries to build all three MSBuild solution at once, which leads to
diff --git a/eng/Packages.props b/eng/Packages.props
index eb0144f9b65..042bf70a426 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -13,6 +13,7 @@
     <PackageReference Update="Microsoft.CodeQuality.Analyzers" Version="3.3.0" PrivateAssets="all" />
     <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
+    <PackageReference Update="Microsoft.IO.Redist" Version="4.7.1" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" />
     <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="1.16.30" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index cc3eebb1a18..066d8cbdcc5 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -5,22 +5,22 @@
       <Uri>https://github.com/dotnet/roslyn-analyzers</Uri>
       <Sha />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21460.7">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21515.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>7324320f814152b72295946847ca72413507705a</Sha>
+      <Sha>f389f732d8cdca8ee1e38a534cf10c8c3182ba39</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-preview.4.243">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-rc.262">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>f82431ecc38a28f396d527446834c7de679a6722</Sha>
+      <Sha>e3016693e01536996921d613152648d66eb0ce99</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.0.0-5.21469.2">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.0.0-6.21515.3">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>c1d8c6f043bc80425c6828455eb57f8a404759c6</Sha>
+      <Sha>95b7a0198f8c805b367f17e4639020ec21c16705</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21460.7">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21515.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>7324320f814152b72295946847ca72413507705a</Sha>
+      <Sha>f389f732d8cdca8ee1e38a534cf10c8c3182ba39</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index d01c3c803fc..02f6f026a6b 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -32,11 +32,11 @@
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21460.7</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21515.3</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftCodeAnalysisBannedApiAnalyzersVersion>3.3.2</MicrosoftCodeAnalysisBannedApiAnalyzersVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.0.0-5.21469.2</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.0.0-preview.4.243</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.0.0-6.21515.3</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.0.0-rc.262</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/build.ps1 b/eng/build.ps1
index 9245a71a0f4..2762b71fb9f 100644
--- a/eng/build.ps1
+++ b/eng/build.ps1
@@ -158,9 +158,13 @@ function Check-EditedFiles() {
 
 function Check-RequiredVersionBumps() {
   # Log VSTS errors for missing required version bumps
-  if ($env:SYSTEM_PULLREQUEST_TARGETBRANCH) {
+  $targetBranch = $env:SYSTEM_PULLREQUEST_TARGETBRANCH
+  if ($targetBranch) {
+    # Some PRs specify the bare target branch (most commonly "main"), some prefix it with "refs/heads/".
+    # The following statement normalizes both to a revision spec that git understands.
+    $targetBranch = "refs/remotes/origin/" + ($targetBranch -replace "^refs/heads/", "")
     $versionLineChanged = $false
-    git --no-pager diff --unified --no-color --exit-code -w origin/$env:SYSTEM_PULLREQUEST_TARGETBRANCH HEAD src\Framework\EngineServices.cs `
+    git --no-pager diff --unified --no-color --exit-code -w $targetBranch HEAD src\Framework\EngineServices.cs `
       | Select-String -Pattern "int Version =" | ForEach-Object -process { $versionLineChanged = $true }
     if (($LASTEXITCODE -ne 0) -and (-not $versionLineChanged)) {
       throw "##vso[task.logissue type=error] Detected changes in Framework\EngineServices.cs without a version bump.  " +
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 02347914f5d..44484289943 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -709,14 +709,7 @@ function MSBuild() {
       Write-PipelineSetVariable -Name 'NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS' -Value '20'
     }
 
-    if ($ci) {
-      $env:NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY = 'true'
-      $env:NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT = 6
-      $env:NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS = 1000
-      Write-PipelineSetVariable -Name 'NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY' -Value 'true'
-      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT' -Value '6'
-      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS' -Value '1000'
-    }
+    Enable-Nuget-EnhancedRetry
 
     $toolsetBuildProject = InitializeToolset
     $basePath = Split-Path -parent $toolsetBuildProject
@@ -764,6 +757,8 @@ function MSBuild-Core() {
     }
   }
 
+  Enable-Nuget-EnhancedRetry
+
   $buildTool = InitializeBuildTool
 
   $cmdArgs = "$($buildTool.Command) /m /nologo /clp:Summary /v:$verbosity /nr:$nodeReuse /p:ContinuousIntegrationBuild=$ci"
@@ -904,3 +899,18 @@ function Try-LogClientIpAddress()
         Write-Host "Unable to get this machine's effective IP address for logging: $_"
     }
 }
+
+#
+# If $ci flag is set, turn on (and log that we did) special environment variables for improved Nuget client retry logic.
+#
+function Enable-Nuget-EnhancedRetry() {
+    if ($ci) {
+      Write-Host "Setting NUGET enhanced retry environment variables"
+      $env:NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY = 'true'
+      $env:NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT = 6
+      $env:NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS = 1000
+      Write-PipelineSetVariable -Name 'NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY' -Value 'true'
+      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT' -Value '6'
+      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS' -Value '1000'
+    }
+}
diff --git a/global.json b/global.json
index c0ab9c781c8..6a1d31f66cd 100644
--- a/global.json
+++ b/global.json
@@ -15,6 +15,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21460.7"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21515.3"
   }
 }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 03aaa748076..b7463405425 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -499,6 +499,7 @@ namespace Microsoft.Build.Definition
     public partial class ProjectOptions
     {
         public ProjectOptions() { }
+        public Microsoft.Build.FileSystem.IDirectoryCacheFactory DirectoryCacheFactory { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.Context.EvaluationContext EvaluationContext { get { throw null; } set { } }
         public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.ProjectLoadSettings LoadSettings { get { throw null; } set { } }
@@ -1505,6 +1506,19 @@ public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, strin
 }
 namespace Microsoft.Build.FileSystem
 {
+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);
+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);
+    public partial interface IDirectoryCache
+    {
+        bool DirectoryExists(string path);
+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);
+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);
+        bool FileExists(string path);
+    }
+    public partial interface IDirectoryCacheFactory
+    {
+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);
+    }
     public abstract partial class MSBuildFileSystemBase
     {
         protected MSBuildFileSystemBase() { }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index a2669f62b2a..4df7931e636 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -499,6 +499,7 @@ namespace Microsoft.Build.Definition
     public partial class ProjectOptions
     {
         public ProjectOptions() { }
+        public Microsoft.Build.FileSystem.IDirectoryCacheFactory DirectoryCacheFactory { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.Context.EvaluationContext EvaluationContext { get { throw null; } set { } }
         public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.ProjectLoadSettings LoadSettings { get { throw null; } set { } }
@@ -1499,6 +1500,19 @@ public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, strin
 }
 namespace Microsoft.Build.FileSystem
 {
+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);
+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);
+    public partial interface IDirectoryCache
+    {
+        bool DirectoryExists(string path);
+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);
+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);
+        bool FileExists(string path);
+    }
+    public partial interface IDirectoryCacheFactory
+    {
+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);
+    }
     public abstract partial class MSBuildFileSystemBase
     {
         protected MSBuildFileSystemBase() { }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index f27baefae70..6bb58a189b1 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -93,6 +93,7 @@ if ($runtime -eq "Desktop") {
 
         FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.Data.Entity.targets"
+        FileToCopy "$bootstrapBinDirectory\Microsoft.IO.Redist.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.ServiceModel.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.WinFx.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.WorkflowBuildExtensions.targets"
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 7c478d2a782..c31ba2c3cdb 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -20,6 +20,8 @@
 </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
     <PackageDownload Include="NuGet.CommandLine" Version="[$(NuGetCommandLinePackageVersion)]" />
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 232d22c62dd..49497a0e870 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -129,6 +129,41 @@ public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
             Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
         }
 
+        [Fact]
+        public void EvaluationShouldUseDirectoryCache()
+        {
+            var projectFile = _env.CreateFile("1.proj", @"<Project> <ItemGroup Condition=`Exists('1.file')`> <Compile Include='*.cs'/> </ItemGroup> </Project>".Cleanup()).Path;
+
+            var projectCollection = _env.CreateProjectCollection().Collection;
+            var directoryCacheFactory = new Helpers.LoggingDirectoryCacheFactory();
+
+            var project = Project.FromFile(
+                projectFile,
+                new ProjectOptions
+                {
+                    ProjectCollection = projectCollection,
+                    DirectoryCacheFactory = directoryCacheFactory,
+                }
+            );
+
+            directoryCacheFactory.DirectoryCaches.Count.ShouldBe(1);
+            var directoryCache = directoryCacheFactory.DirectoryCaches[0];
+
+            directoryCache.EvaluationId.ShouldBe(project.LastEvaluationId);
+
+            directoryCache.ExistenceChecks.OrderBy(kvp => kvp.Key).ShouldBe(
+                new Dictionary<string, int>
+                {
+                    { _env.DefaultTestDirectory.Path, 1},
+                    { Path.Combine(_env.DefaultTestDirectory.Path, "1.file"), 2 }
+                }.OrderBy(kvp => kvp.Key));
+            directoryCache.Enumerations.ShouldBe(
+                new Dictionary<string, int>
+                {
+                    { _env.DefaultTestDirectory.Path, 1 }
+                });
+        }
+
         [Theory]
         [InlineData(EvaluationContext.SharingPolicy.Shared)]
         [InlineData(EvaluationContext.SharingPolicy.Isolated)]
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index b58a72d0843..f6f733c34a9 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3979,6 +3979,12 @@ public void PropertyFunctionStringLastIndexOf()
             TestPropertyFunction("$(prop.LastIndexOf('y', 7))", "prop", "x-x-y-y-y-z", "6");
         }
 
+        [Fact]
+        public void PropertyFunctionStringLastIndexOfAny()
+        {
+            TestPropertyFunction("$(prop.LastIndexOfAny('xy'))", "prop", "x-x-y-y-y-z", "8");
+        }
+
         [Fact]
         public void PropertyFunctionStringCopy()
         {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 06560f5c3f4..4e9d8b9b2aa 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -28,8 +28,6 @@ internal class ItemGroupIntrinsicTask : IntrinsicTask
         /// </summary>
         private ProjectItemGroupTaskInstance _taskInstance;
 
-        private EngineFileUtilities _engineFileUtilities;
-
         /// <summary>
         /// Instantiates an ItemGroup task
         /// </summary>
@@ -41,7 +39,6 @@ public ItemGroupIntrinsicTask(ProjectItemGroupTaskInstance taskInstance, TargetL
             : base(loggingContext, projectInstance, logTaskInputs)
         {
             _taskInstance = taskInstance;
-            _engineFileUtilities = EngineFileUtilities.Default;
         }
 
         /// <summary>
@@ -432,7 +429,7 @@ ISet<string> removeMetadata
                     // The expression is not of the form "@(X)". Treat as string
 
                     // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621
-                    string[] includeSplitFiles = _engineFileUtilities.GetFileListEscaped(
+                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(
                         Project.Directory,
                         includeSplit,
                         excludes);
@@ -456,7 +453,7 @@ ISet<string> removeMetadata
 
             foreach (string excludeSplit in excludes)
             {
-                string[] excludeSplitFiles = _engineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
+                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
 
                 foreach (string excludeSplitFile in excludeSplitFiles)
                 {
@@ -541,7 +538,7 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
                 // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
                 // as literals. Everything else is safe to unescape at this point, since we're only matching
                 // against the file system.
-                string[] fileList = _engineFileUtilities.GetFileListEscaped(Project.Directory, piece);
+                string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);
 
                 foreach (string file in fileList)
                 {
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 3f541b05568..e5c4095acb9 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -35,6 +36,8 @@ public override void ClearCaches()
 
         public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
+
             SdkResult result;
 
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
@@ -66,6 +69,8 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
             }
 
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success);
+
             return result;
         }
     }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 6f90dacaeb4..fba2c4925b1 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -11,6 +11,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Reflection;
+using Microsoft.Build.Eventing;
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
@@ -115,7 +116,9 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
 
                 try
                 {
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStart();
                     result = (SdkResult)sdkResolver.Resolve(sdk, context, resultFactory);
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath, projectPath, result?.Path, result?.Success ?? false);
                 }
                 catch (Exception e) when ((e is FileNotFoundException || e is FileLoadException) && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal))
                 {
@@ -232,8 +235,11 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)
                     return;
                 }
 
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
                 _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);
             }
+
         }
 
         private void SetResolverState(int submissionId, SdkResolver resolver, object state)
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 0c83e1ab744..7588b4c3b3d 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -32,6 +32,7 @@
 using EvaluationItemSpec = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>;
 using EvaluationItemExpressionFragment = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>.ItemExpressionFragment;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using Microsoft.Build.FileSystem;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -68,6 +69,11 @@ public class Project : ILinkableObject
         internal ProjectLink Link => implementation;
         object ILinkableObject.Link => IsLinked ? Link : null;
 
+        /// <summary>
+        /// Host-provided factory for <see cref="IDirectoryCache"/> interfaces to be used during evaluation.
+        /// </summary>
+        private readonly IDirectoryCacheFactory _directoryCacheFactory;
+
         /// <summary>
         /// Default project template options (include all features).
         /// </summary>
@@ -250,20 +256,22 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
             ProjectCollection = projectCollection;
-            var defaultImplementation = new ProjectImpl(this, xml, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            var defaultImplementation = new ProjectImpl(this, xml, globalProperties, toolsVersion, subToolsetVersion, loadSettings);
             implementationInternal = (IProjectLinkInternal)defaultImplementation;
             implementation = defaultImplementation;
 
+            _directoryCacheFactory = directoryCacheFactory;
             defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
         }
 
@@ -342,21 +350,23 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
             ProjectCollection = projectCollection;
-            var defailtImplementation = new ProjectImpl(this, xmlReader, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
-            implementationInternal = (IProjectLinkInternal)defailtImplementation;
-            implementation = defailtImplementation;
+            var defaultImplementation = new ProjectImpl(this, xmlReader, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            implementationInternal = (IProjectLinkInternal)defaultImplementation;
+            implementation = defaultImplementation;
 
-            defailtImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            _directoryCacheFactory = directoryCacheFactory;
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
         }
 
         /// <summary>
@@ -436,26 +446,29 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
             ProjectCollection = projectCollection;
-            var defailtImplementation = new ProjectImpl(this, projectFile, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
-            implementationInternal = (IProjectLinkInternal)defailtImplementation;
-            implementation = defailtImplementation;
+            var defaultImplementation = new ProjectImpl(this, projectFile, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            implementationInternal = (IProjectLinkInternal)defaultImplementation;
+            implementation = defaultImplementation;
+
+            _directoryCacheFactory = directoryCacheFactory;
 
             // Note: not sure why only this ctor flavor do TryUnloadProject
             // seems the XmlReader based one should also clean the same way.
             try
             {
-                defailtImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
             }
             catch (Exception ex)
             {
@@ -488,7 +501,8 @@ public static Project FromFile(string file, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -505,7 +519,8 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -522,7 +537,8 @@ public static Project FromXmlReader(XmlReader reader, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -1767,6 +1783,18 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
             ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(Xml, otherXml), "OM_CannotModifyEvaluatedObjectInImportedFile", otherXml.Location.File);
         }
 
+        /// <summary>
+        /// Returns <see cref="IDirectoryCache"/> as provided by the <see cref="IDirectoryCacheFactory"/> passed when creating the
+        /// project, specific for a given evaluation ID.
+        /// </summary>
+        /// <param name="evaluationId">The evaluation ID for which the cache is requested.</param>
+        /// <returns>An <see cref="IDirectoryCache"/> implementation, or null if this project has no <see cref="IDirectoryCacheFactory"/>
+        /// associated with it or it returned null.</returns>
+        internal IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
+        {
+            return _directoryCacheFactory?.GetDirectoryCacheForEvaluation(evaluationId);
+        }
+
         /// <summary>
         /// Internal project evaluation implementation.
         /// </summary>
@@ -1829,8 +1857,7 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
-            public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+            public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
                 ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -3623,6 +3650,7 @@ private void Reevaluate(
 
                 Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.Evaluate(
                     _data,
+                    Owner,
                     Xml,
                     loadSettings,
                     ProjectCollection.MaxNodeCount,
@@ -4164,7 +4192,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Prepares the data object for evaluation.
             /// </summary>
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
             {
                 DefaultTargets = null;
                 Properties = new PropertyDictionary<ProjectProperty>();
@@ -4172,7 +4200,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSyste
                 Items = new ItemDictionary<ProjectItem>();
                 ItemsIgnoringCondition = new ItemDictionary<ProjectItem>();
                 ItemsByEvaluatedIncludeCache = new MultiDictionary<string, ProjectItem>(StringComparer.OrdinalIgnoreCase);
-                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, fileSystem);
+                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext);
                 ItemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinition>(MSBuildNameIgnoreCaseComparer.Default);
                 Targets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
                 ImportClosure = new List<ResolvedImport>();
diff --git a/src/Build/Definition/ProjectOptions.cs b/src/Build/Definition/ProjectOptions.cs
index 44d2ecccfd6..fadfe73a6e3 100644
--- a/src/Build/Definition/ProjectOptions.cs
+++ b/src/Build/Definition/ProjectOptions.cs
@@ -1,6 +1,7 @@
 ﻿using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.FileSystem;
 
 namespace Microsoft.Build.Definition
 {
@@ -38,5 +39,10 @@ public class ProjectOptions
         /// The <see cref="EvaluationContext"/> to use for evaluation.
         /// </summary>
         public EvaluationContext EvaluationContext { get; set; }
+
+        /// <summary>
+        /// Provides <see cref="IDirectoryCache"/> to be used for evaluation.
+        /// </summary>
+        public IDirectoryCacheFactory DirectoryCacheFactory { get; set; }
     }
 }
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 827d9465d75..19510f6d663 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -7,7 +7,6 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.FileSystem;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -43,27 +42,22 @@ public enum SharingPolicy
 
         internal ISdkResolverService SdkResolverService { get; }
         internal IFileSystem FileSystem { get; }
-        internal EngineFileUtilities EngineFileUtilities { get; }
+        internal FileMatcher FileMatcher { get; }
 
         /// <summary>
         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.
         /// </summary>
         private ConcurrentDictionary<string, IReadOnlyList<string>> FileEntryExpansionCache { get; }
 
-        private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
+        private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem, ISdkResolverService sdkResolverService = null,
+            ConcurrentDictionary<string, IReadOnlyList<string>> fileEntryExpansionCache = null)
         {
-            // Unsupported case: isolated context with non null file system.
-            // Isolated means caches aren't reused, but the given file system might cache.
-            ErrorUtilities.VerifyThrowArgument(
-                policy == SharingPolicy.Shared || fileSystem == null,
-                "IsolatedContextDoesNotSupportFileSystem");
-
             Policy = policy;
 
-            SdkResolverService = new CachingSdkResolverService();
-            FileEntryExpansionCache = new ConcurrentDictionary<string, IReadOnlyList<string>>();
+            SdkResolverService = sdkResolverService ?? new CachingSdkResolverService();
+            FileEntryExpansionCache = fileEntryExpansionCache ?? new ConcurrentDictionary<string, IReadOnlyList<string>>();
             FileSystem = fileSystem ?? new CachingFileSystemWrapper(FileSystems.Default);
-            EngineFileUtilities = new EngineFileUtilities(new FileMatcher(FileSystem, FileEntryExpansionCache));
+            FileMatcher = new FileMatcher(FileSystem, FileEntryExpansionCache);
         }
 
         /// <summary>
@@ -89,6 +83,12 @@ public static EvaluationContext Create(SharingPolicy policy)
         /// </param>
         public static EvaluationContext Create(SharingPolicy policy, MSBuildFileSystemBase fileSystem)
         {
+            // Unsupported case: isolated context with non null file system.
+            // Isolated means caches aren't reused, but the given file system might cache.
+            ErrorUtilities.VerifyThrowArgument(
+                policy == SharingPolicy.Shared || fileSystem == null,
+                "IsolatedContextDoesNotSupportFileSystem");
+
             var context = new EvaluationContext(
                 policy,
                 fileSystem);
@@ -124,5 +124,19 @@ internal EvaluationContext ContextForNewProject()
                     return null;
             }
         }
+
+        /// <summary>
+        /// Creates a copy of this <see cref="EvaluationContext"/> with a given <see cref="IFileSystem"/> swapped in.
+        /// </summary>
+        /// <param name="fileSystem">The file system to use by the new evaluation context.</param>
+        /// <returns>The new evaluation context.</returns>
+        internal EvaluationContext ContextWithFileSystem(IFileSystem fileSystem)
+        {
+            var newContext = new EvaluationContext(this.Policy, fileSystem, this.SdkResolverService, this.FileEntryExpansionCache)
+            {
+                _used = 1
+            };
+            return newContext;
+        }
     }
 }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index bd418241b57..5b2937f5425 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
@@ -20,6 +19,7 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Internal;
@@ -144,6 +144,9 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private readonly int _submissionId;
 
+        /// <summary>
+        /// The evaluation context to use.
+        /// </summary>
         private readonly EvaluationContext _evaluationContext;
 
         /// <summary>
@@ -189,6 +192,7 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private Evaluator(
             IEvaluatorData<P, I, M, D> data,
+            Project project,
             ProjectRootElement projectRootElement,
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
@@ -206,6 +210,7 @@ private Evaluator(
         {
             ErrorUtilities.VerifyThrowInternalNull(data, nameof(data));
             ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
+            ErrorUtilities.VerifyThrowInternalNull(evaluationContext, nameof(evaluationContext));
             ErrorUtilities.VerifyThrowInternalNull(loggingService, nameof(loggingService));
             ErrorUtilities.VerifyThrowInternalNull(buildEventContext, nameof(buildEventContext));
 
@@ -220,12 +225,20 @@ private Evaluator(
                 // Wrap the IEvaluatorData<> object passed in.
                 data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
             }
-            _evaluationContext = evaluationContext ?? EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated);
+
+            // If the host wishes to provide a directory cache for this evaluation, create a new EvaluationContext with the right file system.
+            _evaluationContext = evaluationContext;
+            IDirectoryCache directoryCache = project?.GetDirectoryCacheForEvaluation(_evaluationLoggingContext.BuildEventContext.EvaluationId);
+            if (directoryCache is not null)
+            {
+                IFileSystem fileSystem = new DirectoryCacheFileSystemWrapper(evaluationContext.FileSystem, directoryCache);
+                _evaluationContext = evaluationContext.ContextWithFileSystem(fileSystem);
+            }
 
             // Create containers for the evaluation results
-            data.InitializeForEvaluation(toolsetProvider, _evaluationContext.FileSystem);
+            data.InitializeForEvaluation(toolsetProvider, _evaluationContext);
 
-            _expander = new Expander<P, I>(data, data, _evaluationContext.FileSystem);
+            _expander = new Expander<P, I>(data, data, _evaluationContext);
 
             // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
             _expander.WarnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
@@ -284,6 +297,7 @@ private Evaluator(
         /// </remarks>
         internal static void Evaluate(
             IEvaluatorData<P, I, M, D> data,
+            Project project,
             ProjectRootElement root,
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
@@ -295,13 +309,14 @@ internal static void Evaluate(
             BuildEventContext buildEventContext,
             ISdkResolverService sdkResolverService,
             int submissionId,
-            EvaluationContext evaluationContext = null,
+            EvaluationContext evaluationContext,
             bool interactive = false)
         {
             MSBuildEventSource.Log.EvaluateStart(root.ProjectFileLocation.File);
             var profileEvaluation = (loadSettings & ProjectLoadSettings.ProfileEvaluation) != 0 || loggingService.IncludeEvaluationProfile;
             var evaluator = new Evaluator<P, I, M, D>(
                 data,
+                project,
                 root,
                 loadSettings,
                 maxNodeCount,
@@ -357,7 +372,7 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem
                     else
                     {
                         // The expression is not of the form "@(X)". Treat as string
-                        string[] includeSplitFilesEscaped = EngineFileUtilities.Default.GetFileListEscaped(rootDirectory, includeSplitEscaped);
+                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);
 
                         if (includeSplitFilesEscaped.Length > 0)
                         {
@@ -2007,7 +2022,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     }
 
                     // Expand the wildcards and provide an alphabetical order list of import statements.
-                    importFilesEscaped = _evaluationContext.EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true);
+                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);
                 }
                 catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
                 {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 966f6bb0f1a..dd6f840178e 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1,4 +1,4 @@
-// Copyright (c) Microsoft. All rights reserved.
+﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -14,6 +14,7 @@
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -302,6 +303,11 @@ private void FlushFirstValueIfNeeded()
 
         private readonly IFileSystem _fileSystem;
 
+        /// <summary>
+        /// Non-null if the expander was constructed for evaluation.
+        /// </summary>
+        internal EvaluationContext EvaluationContext { get; }
+
         /// <summary>
         /// Creates an expander passing it some properties to use.
         /// Properties may be null.
@@ -313,6 +319,18 @@ internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
             _fileSystem = fileSystem;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties to use and the evaluation context.
+        /// Properties may be null.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext)
+        {
+            _properties = properties;
+            _usedUninitializedProperties = new UsedUninitializedProperties();
+            _fileSystem = evaluationContext.FileSystem;
+            EvaluationContext = evaluationContext;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties and items to use.
         /// Either or both may be null.
@@ -323,6 +341,16 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFile
             _items = items;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties and items to use, and the evaluation context.
+        /// Either or both may be null.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext)
+            : this(properties, evaluationContext)
+        {
+            _items = items;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties, items, and/or metadata to use.
         /// Any or all may be null.
@@ -2218,7 +2246,7 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                         {
                             foreach (
                                 var resultantItem in
-                                EngineFileUtilities.Default.GetFileListEscaped(
+                                EngineFileUtilities.GetFileListEscaped(
                                     item.ProjectDirectory,
                                     item.EvaluatedIncludeEscaped,
                                     forceEvaluate: true))
@@ -3670,6 +3698,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             return true;
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(string.LastIndexOfAny), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (TryGetArg(args, out string arg0))
+                        {
+                            returnVal = text.LastIndexOfAny(arg0.ToCharArray());
+                            return true;
+                        }
+                    }
                     else if (string.Equals(_methodMethodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
                     {
                         if (args.Length == 0)
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index af0265b01d3..7e2c9c5c85c 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -8,7 +8,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Evaluation.Context;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -210,7 +210,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Prepares the data block for a new evaluation pass
         /// </summary>
-        void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem);
+        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
 
         /// <summary>
         /// Indicates to the data block that evaluation has completed,
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 4c88a6d976f..c493969feb5 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -7,8 +7,8 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -285,9 +285,9 @@ public ProjectTargetInstance GetTarget(string targetName)
                 return _wrappedData.GetTarget(targetName);
             }
 
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
             {
-                _wrappedData.InitializeForEvaluation(toolsetProvider, fileSystem);
+                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext);
             }
 
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index da5f61449b6..b50ed189861 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -113,7 +113,8 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                                 includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
                                     _rootDirectory,
                                     glob,
-                                    excludePatternsForGlobs
+                                    excludePatternsForGlobs,
+                                    fileMatcher: FileMatcher
                                 );
                             }
                             if (MSBuildEventSource.Log.IsEnabled())
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 288d11ce9b9..20706932be6 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -44,12 +44,12 @@ protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M,
 
                 _evaluatorData = new EvaluatorData(_lazyEvaluator._outerEvaluatorData, itemType => GetReferencedItems(itemType, ImmutableHashSet<string>.Empty));
                 _itemFactory = new ItemFactoryWrapper(_itemElement, _lazyEvaluator._itemFactory);
-                _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.FileSystem);
+                _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.EvaluationContext);
 
                 _itemSpec.Expander = _expander;
             }
 
-            protected EngineFileUtilities EngineFileUtilities => _lazyEvaluator.EngineFileUtilities;
+            protected FileMatcher FileMatcher => _lazyEvaluator.FileMatcher;
 
             public void Apply(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index a57206cbbc0..553442a42d5 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Eventing;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
@@ -14,6 +13,7 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+using System.Diagnostics;
 using System.Linq;
 using System.Threading;
 
@@ -39,22 +39,22 @@ internal partial class LazyItemEvaluator<P, I, M, D>
             new Dictionary<string, LazyItemList>() :
             new Dictionary<string, LazyItemList>(StringComparer.OrdinalIgnoreCase);
 
-        protected IFileSystem FileSystem { get; }
+        protected EvaluationContext EvaluationContext { get; }
 
-        protected EngineFileUtilities EngineFileUtilities { get; }
+        protected IFileSystem FileSystem => EvaluationContext.FileSystem;
+        protected FileMatcher FileMatcher => EvaluationContext.FileMatcher;
 
         public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> itemFactory, LoggingContext loggingContext, EvaluationProfiler evaluationProfiler, EvaluationContext evaluationContext)
         {
             _outerEvaluatorData = data;
-            _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext.FileSystem);
+            _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext);
             _evaluatorData = new EvaluatorData(_outerEvaluatorData, itemType => GetItems(itemType));
-            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext.FileSystem);
+            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
             _evaluationProfiler = evaluationProfiler;
 
-            FileSystem = evaluationContext.FileSystem;
-            EngineFileUtilities = evaluationContext.EngineFileUtilities;
+            EvaluationContext = evaluationContext;
         }
 
         private ImmutableList<I> GetItems(string itemType)
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 6e3dc3a3ec7..54effc239c5 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -5,10 +5,10 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared.FileSystem;
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
@@ -135,7 +135,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public ItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
-        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem) => _wrapped.InitializeForEvaluation(toolsetProvider, fileSystem);
+        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
         public void FinishEvaluation() => _wrapped.FinishEvaluation();
         public void AddItem(I item) => _wrapped.AddItem(item);
         public void AddItemIgnoringCondition(I item) => _wrapped.AddItemIgnoringCondition(item);
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
new file mode 100644
index 00000000000..84c24fb02cc
--- /dev/null
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -0,0 +1,118 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+
+#if FEATURE_MSIOREDIST
+using Path = Microsoft.IO.Path;
+#endif
+
+namespace Microsoft.Build.FileSystem
+{
+    internal class DirectoryCacheFileSystemWrapper : IFileSystem
+    {
+        /// <summary>
+        /// The base <see cref="IFileSystem"/> to fall back to for functionality not provided by <see cref="_directoryCache"/>.
+        /// </summary>
+        private readonly IFileSystem _fileSystem;
+
+        /// <summary>
+        /// A host-provided cache used for file existence and directory enumeration.
+        /// </summary>
+        private readonly IDirectoryCache _directoryCache;
+
+        public DirectoryCacheFileSystemWrapper(IFileSystem fileSystem, IDirectoryCache directoryCache)
+        {
+            _fileSystem = fileSystem;
+            _directoryCache = directoryCache;
+        }
+
+        #region IFileSystem implementation based on IDirectoryCache
+
+        public bool FileOrDirectoryExists(string path)
+        {
+            return _directoryCache.FileExists(path) || _directoryCache.DirectoryExists(path);
+        }
+
+        public bool DirectoryExists(string path)
+        {
+            return _directoryCache.DirectoryExists(path);
+        }
+
+        public bool FileExists(string path)
+        {
+            return _directoryCache.FileExists(path);
+        }
+
+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: false, includeDirectories: true);
+        }
+
+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: false);
+        }
+
+        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: true);
+        }
+
+        private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string searchPattern, bool includeFiles, bool includeDirectories)
+        {
+            FindPredicate predicate = (ref ReadOnlySpan<char> fileName) =>
+            {
+                return FileMatcher.IsAllFilesWildcard(searchPattern) || FileMatcher.IsMatch(fileName, searchPattern);
+            };
+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);
+
+            IEnumerable<string> directories = includeDirectories
+                ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)
+                : Enumerable.Empty<string>();
+            IEnumerable<string> files = includeFiles
+                ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)
+                : Enumerable.Empty<string>();
+
+            return Enumerable.Concat(directories, files);
+        }
+
+        #endregion
+
+        #region IFileSystem pass-through implementation
+
+        public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);
+
+        public DateTime GetLastWriteTimeUtc(string path) => _fileSystem.GetLastWriteTimeUtc(path);
+
+        public TextReader ReadFile(string path) => _fileSystem.ReadFile(path);
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => _fileSystem.GetFileStream(path, mode, access, share);
+
+        public string ReadFileAllText(string path) => _fileSystem.ReadFileAllText(path);
+
+        public byte[] ReadFileAllBytes(string path) => _fileSystem.ReadFileAllBytes(path);
+
+        #endregion
+    }
+}
diff --git a/src/Build/FileSystem/IDirectoryCache.cs b/src/Build/FileSystem/IDirectoryCache.cs
new file mode 100644
index 00000000000..fb6e62c1b6a
--- /dev/null
+++ b/src/Build/FileSystem/IDirectoryCache.cs
@@ -0,0 +1,89 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.FileSystem
+{
+    /// <summary>
+    /// A provider of <see cref="IDirectoryCache"/> instances. To be implemented by MSBuild hosts that wish to intercept
+    /// file existence checks and file enumerations performed during project evaluation.
+    /// </summary>
+    /// <remarks>
+    /// Unlike <see cref="MSBuildFileSystemBase"/>, file enumeration returns file/directory names, not full paths.
+    /// The host uses <see cref="Definition.ProjectOptions.DirectoryCacheFactory"/> to specify the directory cache
+    /// factory per project.
+    /// </remarks>
+    public interface IDirectoryCacheFactory
+    {
+        /// <summary>
+        /// Returns an <see cref="IDirectoryCache"/> to be used when evaluating the project associated with this <see cref="IDirectoryCacheFactory"/>.
+        /// </summary>
+        /// <param name="evaluationId">The ID of the evaluation for which the interface is requested.</param>
+        IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);
+    }
+
+    /// <summary>
+    /// A predicate taking file name.
+    /// </summary>
+    /// <param name="fileName">The file name to check.</param>
+    public delegate bool FindPredicate(ref ReadOnlySpan<char> fileName);
+
+    /// <summary>
+    /// A function taking file name and returning an arbitrary result.
+    /// </summary>
+    /// <typeparam name="TResult">The type of the result to return</typeparam>
+    /// <param name="fileName">The file name to transform.</param>
+    public delegate TResult FindTransform<TResult>(ref ReadOnlySpan<char> fileName);
+
+    /// <summary>
+    /// Allows the implementor to intercept file existence checks and file enumerations performed during project evaluation.
+    /// </summary>
+    public interface IDirectoryCache
+    {
+        /// <summary>
+        /// Returns <code>true</code> if the given path points to an existing file on disk.
+        /// </summary>
+        /// <param name="path">A full and normalized path.</param>
+        bool FileExists(string path);
+
+        /// <summary>
+        /// Returns <code>true</code> if the given path points to an existing directory on disk.
+        /// </summary>
+        /// <param name="path">A full and normalized path.</param>
+        bool DirectoryExists(string path);
+
+        /// <summary>
+        /// Enumerates files in the given directory only (non-recursively).
+        /// </summary>
+        /// <typeparam name="TResult">The desired return type.</typeparam>
+        /// <param name="path">The directory to enumerate, specified as a full normalized path.</param>
+        /// <param name="pattern">A search pattern supported by the platform which is guaranteed to return a superset of relevant files.</param>
+        /// <param name="predicate">A predicate to test whether a file should be included.</param>
+        /// <param name="transform">A transform from <code>ReadOnlySpan&lt;char&gt;</code> to <typeparamref name="TResult"/>.</param>
+        /// <remarks>
+        /// The <paramref name="pattern"/> parameter may match more files than what the caller is interested in. In other words,
+        /// <paramref name="predicate"/> can return <code>false</code> even if the implementation enumerates only files whose names
+        /// match the pattern. The implementation is free to ignore the pattern and call the predicate for all files on the given
+        /// <paramref name="path"/>.
+        /// </remarks>
+        IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform);
+
+        /// <summary>
+        /// Enumerates subdirectories in the given directory only (non-recursively).
+        /// </summary>
+        /// <typeparam name="TResult">The desired return type.</typeparam>
+        /// <param name="path">The directory to enumerate, specified as a full normalized path.</param>
+        /// <param name="pattern">A search pattern supported by the platform which is guaranteed to return a superset of relevant directories.</param>
+        /// <param name="predicate">A predicate to test whether a directory should be included.</param>
+        /// <param name="transform">A transform from <code>ReadOnlySpan&lt;char&gt;</code> to <typeparamref name="TResult"/>.</param>
+        /// <remarks>
+        /// The <paramref name="pattern"/> parameter may match more direcories than what the caller is interested in. In other words,
+        /// <paramref name="predicate"/> can return <code>false</code> even if the implementation enumerates only directories whose names
+        /// match the pattern. The implementation is free to ignore the pattern and call the predicate for all directories on the given
+        /// <paramref name="path"/>.
+        /// </remarks>
+        IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform);
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index b67aba3de21..35795e9d705 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1347,7 +1347,7 @@ ICollection<ProjectItemInstance> IItemProvider<ProjectItemInstance>.GetItems(str
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.
-            InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
         {
             // All been done in the constructor.  We don't allow re-evaluation of project instances.
         }
@@ -2761,6 +2761,7 @@ out var usingDifferentToolsVersionFromProjectFile
 
             Evaluator<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Evaluate(
                 this,
+                null,
                 xml,
                 projectLoadSettings ?? buildParameters.ProjectLoadSettings, /* Use override ProjectLoadSettings if specified */
                 buildParameters.MaxNodeCount,
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index d08e337c5da..f7540863381 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -36,6 +36,8 @@
     <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
+
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index da8165d3369..242085521c9 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -12,10 +12,8 @@
 
 namespace Microsoft.Build.Internal
 {
-    internal class EngineFileUtilities
+    internal static class EngineFileUtilities
     {
-        private readonly FileMatcher _fileMatcher;
-
         // Regexes for wildcard filespecs that should not get expanded
         // By default all wildcards are expanded.
         private static List<Regex> s_lazyWildCardExpansionRegexes;
@@ -34,13 +32,6 @@ internal static void CaptureLazyWildcardRegexes()
             s_lazyWildCardExpansionRegexes = PopulateRegexFromEnvironment();
         }
 
-        public static EngineFileUtilities Default = new EngineFileUtilities(FileMatcher.Default);
-
-        public EngineFileUtilities(FileMatcher fileMatcher)
-        {
-            _fileMatcher = fileMatcher;
-        }
-
         /// <summary>
         /// Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
         /// ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
@@ -54,14 +45,14 @@ public EngineFileUtilities(FileMatcher fileMatcher)
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <returns>Array of file paths, unescaped.</returns>
-        internal string[] GetFileListUnescaped
+        internal static string[] GetFileListUnescaped
             (
             string directoryEscaped,
             string filespecEscaped
             )
 
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false, excludeSpecsEscaped: null, fileMatcher: FileMatcher.Default);
         }
 
         /// <summary>
@@ -78,16 +69,18 @@ string filespecEscaped
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="excludeSpecsEscaped">Filespecs to exclude, escaped.</param>
         /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
+        /// <param name="fileMatcher"></param>
         /// <returns>Array of file paths, escaped.</returns>
-        internal string[] GetFileListEscaped
+        internal static string[] GetFileListEscaped
             (
             string directoryEscaped,
             string filespecEscaped,
             IEnumerable<string> excludeSpecsEscaped = null,
-            bool forceEvaluate = false
+            bool forceEvaluate = false,
+            FileMatcher fileMatcher = null
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped, fileMatcher ?? FileMatcher.Default);
         }
 
         internal static bool FilespecHasWildcards(string filespecEscaped)
@@ -119,14 +112,16 @@ internal static bool FilespecHasWildcards(string filespecEscaped)
         /// <param name="returnEscaped"><code>true</code> to return escaped specs.</param>
         /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off</param>
         /// <param name="excludeSpecsEscaped">The exclude specification, escaped.</param>
+        /// <param name="fileMatcher"></param>
         /// <returns>Array of file paths.</returns>
-        private string[] GetFileList
+        private static string[] GetFileList
             (
             string directoryEscaped,
             string filespecEscaped,
             bool returnEscaped,
             bool forceEvaluateWildCards,
-            IEnumerable<string> excludeSpecsEscaped = null
+            IEnumerable<string> excludeSpecsEscaped,
+            FileMatcher fileMatcher
             )
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
@@ -156,7 +151,7 @@ private string[] GetFileList
                 // as a relative path, we will get back a bunch of relative paths.
                 // If the filespec started out as an absolute path, we will get
                 // back a bunch of absolute paths.
-                fileList = _fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+                fileList = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
                 ErrorUtilities.VerifyThrow(fileList != null, "We must have a list of files here, even if it's empty.");
 
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 913c97b1281..ce322f9833b 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -142,4 +142,9 @@
     <DocumentationFile Condition=" '$(GenerateDocumentationFile)' == 'true' ">$(IntermediateOutputPath)\$(AssemblyName).xml</DocumentationFile>
   </PropertyGroup>
 
+  <PropertyGroup Condition="'$(MonoBuild)' != 'true' and $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">
+    <DefineConstants>$(DefineConstants);FEATURE_MSIOREDIST</DefineConstants>
+    <FeatureMSIORedist>true</FeatureMSIORedist>
+  </PropertyGroup>
+
 </Project>
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index 2043a496e46..7be18a10802 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -11,6 +11,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 3581225789d..e32cb633fbc 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -429,7 +429,7 @@ public void TargetUpToDateStop(int result)
         {
             WriteEvent(57, result);
         }
-        
+
         [Event(58, Keywords = Keywords.All)]
         public void CopyUpToDateStart(string path)
         {
@@ -454,6 +454,42 @@ public void WriteLinesToFileUpToDateStop(string fileItemSpec, bool wasUpToDate)
             WriteEvent(61, fileItemSpec, wasUpToDate);
         }
 
+        [Event(62, Keywords = Keywords.All)]
+        public void SdkResolverServiceInitializeStart()
+        {
+            WriteEvent(62);
+        }
+
+        [Event(63, Keywords = Keywords.All)]
+        public void SdkResolverServiceInitializeStop(int resolverCount)
+        {
+            WriteEvent(63, resolverCount);
+        }
+
+        [Event(64, Keywords = Keywords.All)]
+        public void SdkResolverResolveSdkStart()
+        {
+            WriteEvent(64);
+        }
+
+        [Event(65, Keywords = Keywords.All)]
+        public void SdkResolverResolveSdkStop(string resolverName, string sdkName, string solutionPath, string projectPath, string sdkPath, bool success)
+        {
+            WriteEvent(65, resolverName, sdkName, solutionPath, projectPath, sdkPath, success);
+        }
+
+        [Event(66, Keywords = Keywords.All)]
+        public void CachedSdkResolverServiceResolveSdkStart(string sdkName, string solutionPath, string projectPath)
+        {
+            WriteEvent(66, sdkName, solutionPath, projectPath);
+        }
+
+        [Event(67, Keywords = Keywords.All)]
+        public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string solutionPath, string projectPath, bool success)
+        {
+            WriteEvent(67, sdkName, solutionPath, projectPath, success);
+        }
+
         #endregion
     }
 }
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 93185ce820a..17594f48d2f 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -229,6 +229,7 @@
     </None>
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 683606d4fa8..3391a53a640 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1331,7 +1331,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild nejde spustit v této verzi operačního systému. Podporuje se jenom v systémech Windows 2000, Windows XP a novějších verzích.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild nejde spustit v této verzi operačního systému. Podporuje se jenom v systémech Windows 7 a novějších verzích.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a6d4afe3c64..63493f136ce 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild kann unter dieser Version des Betriebssystems nicht ausgeführt werden. Nur Windows 2000, Windows XP und Folgeversionen werden unterstützt.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild kann unter dieser Version des Betriebssystems nicht ausgeführt werden. Nur Windows 7 und Folgeversionen werden unterstützt.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index e284447ae5d..956059968ba 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1332,7 +1332,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild no se puede ejecutar en esta versión del sistema operativo. Solo es compatible con Windows 2000, Windows XP y versiones posteriores.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild no se ha podido ejecutar en esta versión del sistema operativo. Solo se admite en Windows 7 y versiones posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 1f465b9f5fa..a0aa66f7a84 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild ne s'exécute pas sur cette version du système d'exploitation. Il est pris en charge uniquement sur Windows 2000, Windows XP et les versions ultérieures.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild ne s'exécute pas sur cette version du système d'exploitation. Il n'est pris en charge que sur Windows 7 et les versions ultérieures.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 17f8ef60d33..200a7a77dae 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1345,7 +1345,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild non può essere eseguito su questa versione del sistema operativo. È supportato solo in Windows 2000, Windows XP e versioni successive.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild non può essere eseguito su questa versione del sistema operativo. È supportato solo in Windows 7 e versioni successive.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 6c17289c3c1..453bbc44766 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild はこのバージョンのオペレーティング システムでは実行できません。Windows 2000、Windows XP およびそれ以降のバージョンでのみサポートされています。</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild はこのバージョンのオペレーティング システムでは実行できません。Windows 7 およびそれ以降のバージョンでのみサポートされています。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index aaa3d3ec15c..e57ed62661a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: 이 운영 체제 버전에서는 MSBuild를 실행할 수 없습니다. MSBuild는 Windows 2000 및 Windows XP 이상 버전에서만 지원됩니다.</target>
+        <target state="translated">MSBUILD : error MSB1015: 이 운영 체제 버전에서는 MSBuild를 실행할 수 없습니다. MSBuild는 Windows 7 이상의 버전에서만 지원됩니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index bf6053ea021..c1e63e21afe 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1337,7 +1337,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: Program MSBuild nie działa w tej wersji systemu operacyjnego. Jest obsługiwany tylko w systemie Windows 2000, Windows XP oraz nowszych wersjach.</target>
+        <target state="translated">MSBUILD : error MSB1015: Program MSBuild nie działa w tej wersji systemu operacyjnego. Jest obsługiwany tylko w systemie Windows 7 i nowszych wersjach.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index ed957260598..e8293005192 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1324,7 +1324,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: O MSBuild não é executado nesta versão de sistema operacional. Há suporte para ele somente nas versões Windows 2000, Windows XP e versões posteriores.</target>
+        <target state="translated">MSBUILD : error MSB1015: O MSBuild não é executado nesta versão do sistema operacional. É suportado apenas no Windows 7 e em versões posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index a16f15e95bc..d5f02251680 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1322,7 +1322,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild не работает в этой версии операционной системы. Он поддерживается только в Windows 2000, Windows XP и более поздних версиях.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild не работает в этой версии операционной системы. Он поддерживается только в Windows 7, Windows XP и более поздних версиях.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 6de7f438111..06ed57c5523 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1327,7 +1327,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild işletim sisteminin bu sürümünde çalışmaz. Yalnızca Windows 2000, Windows XP ve sonraki sürümlerde desteklenir.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild işletim sisteminin bu sürümünde çalışmaz. Yalnızca Windows 7 ve üzeri sürümlerde desteklenir.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index d29ed7c8e4b..3a68a4c3a6b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild 不能在此版本的操作系统上运行。它仅在 Windows 2000、Windows XP 及更高版本的操作系统上受支持。</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild 不在此版本操作系统上运行，而仅在 Windows 7 及更高版本的操作系统上受支持。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 95fe02eeca4..5992ad480da 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild 在此版本的作業系統上不會執行。只有在 Windows 2000、Windows XP 及更新版本才受支援。</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild 不會在此版本的作業系統上執行。只有在 Windows 7 及更新版本才受支援。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 93697e88064..9583cfd1e04 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -127,15 +127,15 @@
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
         <dependentAssembly>
           <assemblyIdentity name="FxCopTask" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\FxCopTask.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\FxCopTask.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
       </assemblyBinding>
     </runtime>
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 047b20fb44c..8fd02af793e 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -119,15 +119,15 @@
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
         <dependentAssembly>
           <assemblyIdentity name="FxCopTask" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\FxCopTask.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\FxCopTask.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
       </assemblyBinding>
     </runtime>
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index 2918e172a5c..04a42dbfce4 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -31,6 +31,7 @@
     <file src="$X86BinPath$/Microsoft.Build.Framework.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Build.Tasks.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.IO.Redist.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin" />
@@ -87,6 +88,7 @@
     <file src="$X86BinPath$/Microsoft.Build.Framework.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Build.Tasks.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.IO.Redist.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin/amd64" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 67e5764974d..fc7164e4899 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -32,6 +32,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.Build.Framework.tlb
   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe vs.file.ngenArchitecture=x86 vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe.config
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe vs.file.ngenArchitecture=x86
@@ -184,6 +185,7 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 9af0619bab7..22a9572fc82 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -132,7 +132,7 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE
                                     directory,
                                     false));
                         IEnumerable<string> filteredEntriesForPath = (pattern != null && !IsAllFilesWildcard(pattern))
-                            ? allEntriesForPath.Where(o => IsMatch(Path.GetFileName(o), pattern))
+                            ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
                             : allEntriesForPath;
                         return stripProjectDirectory
                             ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
@@ -244,7 +244,7 @@ private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem
             {
                 case FileSystemEntity.Files: return GetAccessibleFiles(fileSystem, path, pattern, projectDirectory, stripProjectDirectory);
                 case FileSystemEntity.Directories: return GetAccessibleDirectories(fileSystem, path, pattern);
-                case FileSystemEntity.FilesAndDirectories: return GetAccessibleFilesAndDirectories(fileSystem,path, pattern);
+                case FileSystemEntity.FilesAndDirectories: return GetAccessibleFilesAndDirectories(fileSystem, path, pattern);
                 default:
                     ErrorUtilities.VerifyThrow(false, "Unexpected filesystem entity type.");
                     break;
@@ -268,7 +268,7 @@ private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSyste
                 {
                     return (ShouldEnforceMatching(pattern)
                         ? fileSystem.EnumerateFileSystemEntries(path, pattern)
-                            .Where(o => IsMatch(Path.GetFileName(o), pattern))
+                            .Where(o => IsFileNameMatch(o, pattern))
                         : fileSystem.EnumerateFileSystemEntries(path, pattern)
                         ).ToArray();
                 }
@@ -351,7 +351,7 @@ bool stripProjectDirectory
                     files = fileSystem.EnumerateFiles(dir, filespec);
                     if (ShouldEnforceMatching(filespec))
                     {
-                        files = files.Where(o => IsMatch(Path.GetFileName(o), filespec));
+                        files = files.Where(o => IsFileNameMatch(o, filespec));
                     }
                 }
                 // If the Item is based on a relative path we need to strip
@@ -414,7 +414,7 @@ string pattern
                     directories = fileSystem.EnumerateDirectories((path.Length == 0) ? s_thisDirectory : path, pattern);
                     if (ShouldEnforceMatching(pattern))
                     {
-                        directories = directories.Where(o => IsMatch(Path.GetFileName(o), pattern));
+                        directories = directories.Where(o => IsFileNameMatch(o, pattern));
                     }
                 }
 
@@ -956,7 +956,7 @@ private void GetFilesRecursive(
                     for (int i = 0; i < excludeNextSteps.Length; i++)
                     {
                         if (excludeNextSteps[i].NeedsDirectoryRecursion &&
-                            (excludeNextSteps[i].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[i].DirectoryPattern)))
+                            (excludeNextSteps[i].DirectoryPattern == null || IsFileNameMatch(subdir, excludeNextSteps[i].DirectoryPattern)))
                         {
                             RecursionState thisExcludeStep = searchesToExclude[i];
                             thisExcludeStep.BaseDirectory = subdir;
@@ -1097,7 +1097,7 @@ private static bool MatchFileRecursionStep(RecursionState recursionState, string
             }
             else if (recursionState.SearchData.Filespec != null)
             {
-                return IsMatch(Path.GetFileName(file), recursionState.SearchData.Filespec);
+                return IsFileNameMatch(file, recursionState.SearchData.Filespec);
             }
 
             // if no file-spec provided, match the file to the regular expression
@@ -1664,12 +1664,39 @@ internal Result()
             internal string wildcardDirectoryPart = string.Empty;
         }
 
+        /// <summary>
+        /// A wildcard (* and ?) matching algorithm that tests whether the input path file name matches against the pattern.
+        /// </summary>
+        /// <param name="path">The path whose file name is matched against the pattern.</param>
+        /// <param name="pattern">The pattern.</param>
+        internal static bool IsFileNameMatch(string path, string pattern)
+        {
+            // Use a span-based Path.GetFileName if it is available.
+#if FEATURE_MSIOREDIST
+            return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);
+#elif NETSTANDARD2_0
+            return IsMatch(Path.GetFileName(path), pattern);
+#else
+            return IsMatch(Path.GetFileName(path.AsSpan()), pattern);
+#endif
+        }
+
         /// <summary>
         /// A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
         /// </summary>
         /// <param name="input">String which is matched against the pattern.</param>
         /// <param name="pattern">Pattern against which string is matched.</param>
         internal static bool IsMatch(string input, string pattern)
+        {
+            return IsMatch(input.AsSpan(), pattern);
+        }
+
+        /// <summary>
+        /// A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
+        /// </summary>
+        /// <param name="input">String which is matched against the pattern.</param>
+        /// <param name="pattern">Pattern against which string is matched.</param>
+        internal static bool IsMatch(ReadOnlySpan<char> input, string pattern)
         {
             if (input == null)
             {
@@ -1705,9 +1732,12 @@ internal static bool IsMatch(string input, string pattern)
             // to using the string indexer. The iIndex and pIndex parameters are only used
             // when we have to compare two non ASCII characters. Using just string.Compare for
             // character comparison, would reduce the speed by approx. 5 times.
-            bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
+            bool CompareIgnoreCase(ref ReadOnlySpan<char> input, int iIndex, int pIndex)
 #endif
             {
+                char inputChar = input[iIndex];
+                char patternChar = pattern[pIndex];
+
                 // We will mostly be comparing ASCII characters, check English letters first.
                 char inputCharLower = (char)(inputChar | 0x20);
                 if (inputCharLower >= 'a' && inputCharLower <= 'z')
@@ -1721,7 +1751,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                     // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table
                     return inputChar == patternChar;
                 }
-                return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;
+                return MemoryExtensions.Equals(input.Slice(iIndex, 1), pattern.AsSpan(pIndex, 1), StringComparison.OrdinalIgnoreCase);
             }
 #if MONO
             ; // The end of the CompareIgnoreCase anonymous function
@@ -1761,7 +1791,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                                     break;
                                 }
                                 // If the tail doesn't match, we can safely return e.g. ("aaa", "*b")
-                                if (!CompareIgnoreCase(input[inputTailIndex], pattern[patternTailIndex], patternTailIndex, inputTailIndex) &&
+                                if (!CompareIgnoreCase(ref input, inputTailIndex, patternTailIndex) &&
                                     pattern[patternTailIndex] != '?')
                                 {
                                     return false;
@@ -1781,7 +1811,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                         // The ? wildcard cannot be skipped as we will have a wrong result for e.g. ("aab" "*?b")
                         if (pattern[patternIndex] != '?')
                         {
-                            while (!CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex))
+                            while (!CompareIgnoreCase(ref input, inputIndex, patternIndex))
                             {
                                 // Return if there is no character that match e.g. ("aa", "*b")
                                 if (++inputIndex >= inputLength)
@@ -1796,7 +1826,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                     }
 
                     // If we have a match, step to the next character
-                    if (CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex) ||
+                    if (CompareIgnoreCase(ref input, inputIndex, patternIndex) ||
                         pattern[patternIndex] == '?')
                     {
                         patternIndex++;
@@ -2557,14 +2587,14 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
         private static bool DirectoryEndsWithPattern(string directoryPath, string pattern)
         {
             int index = directoryPath.LastIndexOfAny(FileUtilities.Slashes);
-            return (index != -1 && IsMatch(directoryPath.Substring(index + 1), pattern));
+            return (index != -1 && IsMatch(directoryPath.AsSpan(index + 1), pattern));
         }
 
         /// <summary>
         /// Returns true if <paramref name="pattern"/> is <code>*</code> or <code>*.*</code>.
         /// </summary>
         /// <param name="pattern">The filename pattern to check.</param>
-        private static bool IsAllFilesWildcard(string pattern) => pattern?.Length switch
+        internal static bool IsAllFilesWildcard(string pattern) => pattern?.Length switch
         {
             1 => pattern[0] == '*',
             3 => pattern[0] == '*' && pattern[1] == '.' && pattern[2] == '*',
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 6d8bd32fb4e..d5d80a07e35 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -16,6 +17,20 @@ internal class ManagedFileSystem : IFileSystem
 
         public static ManagedFileSystem Singleton() => ManagedFileSystem.Instance;
 
+        private static bool ShouldUseMicrosoftIO
+        {
+            get
+            {
+#if !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);
+#else
+                // We need to mock usage of ChangeWaves class,
+                // because Microsoft.Build.Engine.OM.UnitTests should not have access to internals of Microsoft.Build.Framework.
+                return true;
+#endif
+            }
+        }
+
         protected ManagedFileSystem() { }
 
         public TextReader ReadFile(string path)
@@ -38,19 +53,78 @@ public byte[] ReadFileAllBytes(string path)
             return File.ReadAllBytes(path);
         }
 
+#if FEATURE_MSIOREDIST
+        private static IEnumerable<string> HandleFileLoadException(
+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,
+            string path,
+            string searchPattern,
+            Microsoft.IO.SearchOption searchOption
+        )
+        {
+            try
+            {
+                return enumerateFunctionDelegate(path, searchPattern, searchOption);
+            }
+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.
+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.
+            // We rethrow it to make it fail with a proper error message and call stack.
+            catch (FileLoadException ex)
+            {
+                throw new InvalidOperationException(ex.Message, ex);
+            }
+            // Sometimes FileNotFoundException is thrown when there is an assembly load failure. In this case it should have FusionLog.
+            catch (FileNotFoundException ex) when (ex.FusionLog != null)
+            {
+                throw new InvalidOperationException(ex.Message, ex);
+            }
+        }
+#endif
+
         public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateFiles(path, searchPattern, searchOption),
+                    path,
+                    searchPattern,
+                    (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateFiles(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateFiles(path, searchPattern, searchOption);
+#endif
         }
 
         public virtual IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateDirectories(path, searchPattern, searchOption),
+                    path,
+                    searchPattern,
+                    (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateDirectories(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateDirectories(path, searchPattern, searchOption);
+#endif
         }
 
         public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption),
+                    path,
+                    searchPattern, (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+#endif
         }
 
         public FileAttributes GetAttributes(string path)
diff --git a/src/Shared/Shared Code.doc b/src/Shared/Shared Code.doc
deleted file mode 100644
index 3bb7c7745d2..00000000000
Binary files a/src/Shared/Shared Code.doc and /dev/null differ
diff --git a/src/Shared/SharedCode.md b/src/Shared/SharedCode.md
new file mode 100644
index 00000000000..955f9af23f8
--- /dev/null
+++ b/src/Shared/SharedCode.md
@@ -0,0 +1,83 @@
+# Shared Code
+
+## **Namespace**
+All shared code _must_ live in `Microsoft.Build.Shared` namespace.
+___
+
+## **Internal Access Only**
+Shared code gets compiled into every assembly as it is referenced by. However this does _not_ mean that the shared types can migrate across the assemblies they are in.
+
+Even if two types in different assemblies have the same name and are in the same namespace, the CLR does _not_ recognize the types to be the same, because their assembly identities are different.
+
+As a result all shared code _must_ have **internal** access only. There should be _no_ public types in shared code.
+___
+
+## **Resources**
+Shared code needs access to assembly resources e.g. for loading error messages for exceptions. Each assembly that shares code, _must_ define a class called `AssemblyResources` in the shared namespace, with an `internal static readonly` member of type `ResourceManager` called `resources`. Each sharing assembly is required to do this because only it knows what the manifest resource name (a.k.a. logical name) of its resources is. Shared code can then statically reference the assembly’s resources. If the `AssemblyResources` class is not defined, it is a compile-time error.
+
+The `AssemblyResources` class at a minimum must look like this:
+
+```cs
+using System.Resources;
+using System.Reflection;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class AssemblyResources
+    {
+        internal static readonly ResourceManager resources =
+            new ResourceManager(
+                "<manifest resource name>",
+                Assembly.GetExecutingAssembly());
+    }
+}
+```
+
+NOTE: the class is explicitly marked `static`, because it only contains static members and methods -- making the class static prevents it from being instantiated, and allows the compiler to flag the (accidental) addition of instance members.
+___
+
+## **Shared Resources**
+Shared code sometimes needs to define its own resources. If this were not allowed, then each sharing assembly would have to redefine the same set of resources on behalf of the shared code. As with code, maintaining multiple copies of the same resources is not desirable.
+
+Shared resources must be placed in the file `Strings.shared.resx` in the shared code directory. All resource names must be prefixed with “`Shared.`” to distinguish the shared resources from an assembly’s primary resources. Each sharing assembly must add an `internal static readonly` member of type `ResourceManager`, called `sharedResources`, to the `AssemblyResources` class. This is necessary because only the sharing assembly can assign the correct manifest resource name to the shared resources. Shared code can then statically reference the shared resources. The absence of either the `AssemblyResources` class, or the `sharedResources` member is a compile-time error.
+
+For assemblies that share resources, the `AssemblyResources` class at a minimum must look like this:
+
+```cs
+using System.Resources;
+using System.Reflection;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class AssemblyResources
+    {
+        internal static readonly ResourceManager resources =
+            new ResourceManager(
+                "<manifest resource name>",
+                Assembly.GetExecutingAssembly());
+
+        internal static readonly ResourceManager sharedResources =
+            new ResourceManager(
+                "<manifest resource name of shared resources>",
+                Assembly.GetExecutingAssembly());
+    }
+}
+```
+
+To simplify the retrieval of resources, the `AssemblyResources` class can optionally define a method called `GetString()` that searches both the assembly’s primary resources as well as its shared resources for a given string. For example:
+
+```cs
+internal static string GetString(string name)
+{
+    string resource = resources.GetString(name, CultureInfo.CurrentUICulture);
+
+    if (resource == null)
+    {
+        resource = sharedResources.GetString(name, CultureInfo.CurrentUICulture);
+    }
+
+    return resource;
+}
+```
+
+NOTE: if the above method is added to the `AssemblyResources` class, it is advisable to make both `resources` and `sharedResources` private (instead of `internal`) to unify access to assembly resources.
\ No newline at end of file
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index d8cf2eeed4c..471e1536b63 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Xunit;
 using Xunit.Abstractions;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -1244,13 +1245,20 @@ public void IllegalPaths()
         [Fact]
         [PlatformSpecific(TestPlatforms.Windows)] // Nothing's too long for Unix
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
-        public void IllegalTooLongPath()
+        public void IllegalTooLongPathOptOutWave17_0()
         {
-            string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-            string[] result = FileMatcher.Default.GetFiles(@"c:\", longString);
+            using (var env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_0.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            Assert.Equal(longString, result[0]); // Does not throw
+                string longString = new string('X', 500) + "*"; // need a wildcard to do anything
+                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString);
 
+                Assert.Equal(longString, result[0]); // Does not throw
+                ChangeWaves.ResetStateForTests();
+            }
             // Not checking that GetFileSpecMatchInfo returns the illegal-path flag,
             // not certain that won't break something; this fix is merely to avoid a crash.
         }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 9261b45785c..e647fd709c0 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -2019,6 +2019,65 @@ public void Dispose()
             }
         }
 
+        internal sealed class LoggingDirectoryCacheFactory : IDirectoryCacheFactory
+        {
+            public List<LoggingDirectoryCache> DirectoryCaches { get; } = new();
+
+            public IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
+            {
+                var directoryCache = new LoggingDirectoryCache(evaluationId);
+                DirectoryCaches.Add(directoryCache);
+                return directoryCache;
+            }
+        }
+
+        internal sealed class LoggingDirectoryCache : IDirectoryCache
+        {
+            internal int EvaluationId { get; }
+
+            public ConcurrentDictionary<string, int> ExistenceChecks { get; } = new();
+            public ConcurrentDictionary<string, int> Enumerations { get; } = new();
+
+            public LoggingDirectoryCache(int evaluationId)
+            {
+                EvaluationId = evaluationId;
+            }
+
+            public bool DirectoryExists(string path)
+            {
+                IncrementExistenceChecks(path);
+                return Directory.Exists(path);
+            }
+
+            public bool FileExists(string path)
+            {
+                IncrementExistenceChecks(path);
+                return File.Exists(path);
+            }
+
+            public IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform)
+            {
+                IncrementEnumerations(path);
+                return Enumerable.Empty<TResult>();
+            }
+
+            public IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform)
+            {
+                IncrementEnumerations(path);
+                return Enumerable.Empty<TResult>();
+            }
+
+            private void IncrementExistenceChecks(string path)
+            {
+                ExistenceChecks.AddOrUpdate(path, p => 1, (p, c) => c + 1);
+            }
+
+            private void IncrementEnumerations(string path)
+            {
+                Enumerations.AddOrUpdate(path, p => 1, (p, c) => c + 1);
+            }
+        }
+
         internal class LoggingFileSystem : MSBuildFileSystemBase
         {
             private int _fileSystemCalls;
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 5fc54d6dfcf..785bab86be5 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -13,6 +13,7 @@
 using System.Text.RegularExpressions;
 using System.Xml.Xsl;
 using System.Xml;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -386,7 +387,7 @@ public void OutputTest()
         /// Setting correct "Parameter" parameters for Xsl.
         /// </summary>
         [Fact]
-        public void XsltParamatersCorrect()
+        public void XsltParametersCorrect()
         {
             string dir;
             TaskItem[] xmlPaths;
@@ -780,6 +781,39 @@ public void OutputFileCannotBeWritten()
             CleanUp(dir);
         }
 
+        /// <summary>
+        /// The files are not kept locked by the task
+        /// </summary>
+        [Fact]
+        public void InputFilesDontLock()
+        {
+            string dir;
+            TaskItem[] xmlPaths;
+            TaskItem xslPath;
+            TaskItem[] outputPaths;
+            MockEngine engine;
+            Prepare(out dir, out xmlPaths, out xslPath, out _, out outputPaths, out _, out _, out engine);
+
+            // Test with files
+            {
+                XslTransformation t = new XslTransformation();
+                t.BuildEngine = engine;
+                t.XmlInputPaths = xmlPaths;
+                t.XslInputPath = xslPath;
+                t.OutputPaths = outputPaths;
+
+                t.Execute().ShouldBeTrue();
+                string xmlInputPath = xmlPaths[0].ItemSpec;
+                File.Delete(xmlInputPath); // this should succeed (file not locked by task)
+                File.Exists(xmlInputPath).ShouldBeFalse();
+                string xslInputPath = xslPath.ItemSpec;
+                File.Delete(xslInputPath); // this should succeed (file not locked by task)
+                File.Exists(xslInputPath).ShouldBeFalse();
+            }
+
+            CleanUp(dir);
+        }
+
         /// <summary>
         /// XslDocument that throws runtime exception.
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 196a70b8747..3b214c55a9f 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -741,13 +741,8 @@ out string redistName
         /// </summary>
         private static void TryConvertToAssemblyName(string itemSpec, string fusionName, ref AssemblyNameExtension assemblyName)
         {
-            // FusionName is used if available.
-            string finalName = fusionName;
-            if (string.IsNullOrEmpty(finalName))
-            {
-                // Otherwise, its itemSpec.
-                finalName = itemSpec;
-            }
+            // FusionName is used if available; otherwise use itemspec.
+            string finalName = string.IsNullOrEmpty(fusionName) ? itemSpec : fusionName;
 
             bool pathRooted = false;
             try
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index d8f81bf9926..485e5d33714 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -989,6 +989,8 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index ab2342d58e4..2847dcd30d7 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1930,13 +1930,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
                                     GetTargetFrameworkProperties
 
-    Overrridden by cross-targeting projects to return the set of
-    properties (in the form "key1=value1;...keyN=valueN") needed
-    to build it with the best target for the referring project's
-    target framework.
-
-    The referring project's $(TargetFrameworkMoniker) is passed
-    in as $(ReferringTargetFramework)
+    OBSOLETE: present only for theoretical backward compatibility.
   -->
   <Target Name="GetTargetFrameworkProperties" />
 
@@ -4832,10 +4826,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          not be considered up to date, so touch this marker file that is considered an
          input to projects that reference this one. -->
     <Touch Files="@(CopyUpToDateMarker)"
-           AlwaysCreate="true"
-           Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'">
-        <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
-    </Touch>
+      AlwaysCreate="true"
+      Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'" />
+
+    <ItemGroup>
+      <FileWrites Include="@(CopyUpToDateMarker)" />
+    </ItemGroup>
 
   </Target>
 
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 2992e07bc73..2c11513b244 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -366,19 +366,14 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             // If the process-wide cache contains an up-to-date FileState, always use it
             if (isProcessFileStateUpToDate)
             {
-                // If a FileState already exists in this instance cache due to deserialization, remove it;
-                // another instance has taken responsibility for serialization, and keeping this would
-                // result in multiple instances serializing the same data to disk
-                if (isCachedInInstance)
+                // For the next build, we may be using a different process. Update the file cache.
+                if (!isInstanceFileStateUpToDate)
                 {
-                    instanceLocalFileStateCache.Remove(path);
+                    instanceLocalFileStateCache[path] = cachedProcessFileState;
                     isDirty = true;
                 }
-
                 return cachedProcessFileState;
             }
-            // If the process-wide FileState is missing or out-of-date, this instance owns serialization;
-            // sync the process-wide cache and signal other instances to avoid data duplication
             if (isInstanceFileStateUpToDate)
             {
                 return s_processWideFileStateCache[path] = cachedInstanceFileState;
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 3b8810be561..0f47a2edfe2 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -334,9 +334,9 @@ public XmlReader CreateReader(int itemPos)
             {
                 if (XmlMode == XmlModes.XmlFile)
                 {
-                    return XmlReader.Create(new StreamReader(_data[itemPos]), null, _data[itemPos]);
+                    return XmlReader.Create(new StreamReader(_data[itemPos]), new XmlReaderSettings { CloseInput = true }, _data[itemPos]);
                 }
-                else // xmlModes.Xml 
+                else // xmlModes.Xml
                 {
                     return XmlReader.Create(new StringReader(_data[itemPos]));
                 }
@@ -459,7 +459,10 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
                             _log.LogMessageFromResources(MessageImportance.Low, "XslTransform.UseTrustedSettings", _data);
                         }
 
-                        xslct.Load(new XPathDocument(XmlReader.Create(new StreamReader(_data), null, _data)), settings, new XmlUrlResolver());
+                        using (XmlReader reader = XmlReader.Create(new StreamReader(_data), new XmlReaderSettings { CloseInput = true }, _data))
+                        {
+                            xslct.Load(new XPathDocument(reader), settings, new XmlUrlResolver());
+                        }
                         break;
                     case XslModes.XsltCompiledDll:
 #if FEATURE_COMPILED_XSL
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index f683c61ca7d..3b5d3eb6085 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -681,19 +681,20 @@ public void FindOnPathSucceeds()
         {
             string[] expectedCmdPath;
             string shellName;
+            string cmdPath;
             if (NativeMethodsShared.IsWindows)
             {
-                expectedCmdPath = new[] { Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe") };
+                expectedCmdPath = new[] { Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe").ToUpperInvariant() };
                 shellName = "cmd.exe";
+                cmdPath = ToolTask.FindOnPath(shellName).ToUpperInvariant();
             }
             else
             {
                 expectedCmdPath = new[] { "/bin/sh", "/usr/bin/sh" };
                 shellName = "sh";
+                cmdPath = ToolTask.FindOnPath(shellName);
             }
 
-            string cmdPath = ToolTask.FindOnPath(shellName);
-
             cmdPath.ShouldBeOneOf(expectedCmdPath);
         }
 
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 09634e72315..da7f065bffe 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -21,6 +21,7 @@
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
