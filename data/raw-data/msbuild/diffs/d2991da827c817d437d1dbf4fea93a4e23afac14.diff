diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 1058ee7f8b1..eaf5e31be4f 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -81,7 +81,7 @@ private ProjectLoggingContext(
             List<string> targets,
             string toolsVersion,
             PropertyDictionary<ProjectPropertyInstance> projectProperties,
-            ItemDictionary<ProjectItemInstance> projectItems,
+            IItemDictionary<ProjectItemInstance> projectItems,
             BuildEventContext parentBuildEventContext,
             int evaluationId,
             int projectContextId)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 9ead103fe08..25b4b6eb512 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -88,7 +88,7 @@ internal class Lookup : IPropertyProvider<ProjectPropertyInstance>, IItemProvide
         /// <summary>
         /// Construct a lookup over specified items and properties.
         /// </summary>
-        internal Lookup(ItemDictionary<ProjectItemInstance> projectItems, PropertyDictionary<ProjectPropertyInstance> properties)
+        internal Lookup(IItemDictionary<ProjectItemInstance> projectItems, PropertyDictionary<ProjectPropertyInstance> properties)
         {
             ErrorUtilities.VerifyThrowInternalNull(projectItems, nameof(projectItems));
             ErrorUtilities.VerifyThrowInternalNull(properties, nameof(properties));
@@ -120,7 +120,7 @@ private Lookup(Lookup that)
         // Convenience private properties
         // "Primary" is the "top" or "innermost" scope
         // "Secondary" is the next from the top.
-        private ItemDictionary<ProjectItemInstance> PrimaryTable
+        private IItemDictionary<ProjectItemInstance> PrimaryTable
         {
             get { return _lookupScopes.First.Value.Items; }
             set { _lookupScopes.First.Value.Items = value; }
@@ -150,7 +150,7 @@ private PropertyDictionary<ProjectPropertyInstance> PrimaryPropertySets
             set { _lookupScopes.First.Value.PropertySets = value; }
         }
 
-        private ItemDictionary<ProjectItemInstance> SecondaryTable
+        private IItemDictionary<ProjectItemInstance> SecondaryTable
         {
             get { return _lookupScopes.First.Next.Value.Items; }
             set { _lookupScopes.First.Next.Value.Items = value; }
@@ -870,7 +870,7 @@ private ProjectItemInstance RetrieveOriginalFromCloneTable(ProjectItemInstance i
         /// Applies a list of modifications to the appropriate <see cref="ItemDictionary{ProjectItemInstance}" /> in a main table.
         /// If any modifications conflict, these modifications win.
         /// </summary>
-        private void ApplyModificationsToTable(ItemDictionary<ProjectItemInstance> table, string itemType, ItemsMetadataUpdateDictionary modify)
+        private void ApplyModificationsToTable(IItemDictionary<ProjectItemInstance> table, string itemType, ItemsMetadataUpdateDictionary modify)
         {
             ICollection<ProjectItemInstance> existing = table[itemType];
             if (existing != null)
@@ -1295,7 +1295,7 @@ internal class Scope
             /// <summary>
             /// Contains all of the original items at this level in the Lookup
             /// </summary>
-            private ItemDictionary<ProjectItemInstance> _items;
+            private IItemDictionary<ProjectItemInstance> _items;
 
             /// <summary>
             /// Contains all of the items which have been added at this level in the Lookup
@@ -1344,7 +1344,7 @@ internal class Scope
             /// </summary>
             private bool _truncateLookupsAtThisScope;
 
-            internal Scope(Lookup lookup, string description, ItemDictionary<ProjectItemInstance> items, PropertyDictionary<ProjectPropertyInstance> properties)
+            internal Scope(Lookup lookup, string description, IItemDictionary<ProjectItemInstance> items, PropertyDictionary<ProjectPropertyInstance> properties)
             {
                 _owningLookup = lookup;
                 _description = description;
@@ -1364,7 +1364,7 @@ internal Scope(Lookup lookup, string description, ItemDictionary<ProjectItemInst
             /// include adds or removes unless it's the table in 
             /// the outermost scope.
             /// </summary>
-            internal ItemDictionary<ProjectItemInstance> Items
+            internal IItemDictionary<ProjectItemInstance> Items
             {
                 get { return _items; }
                 set { _items = value; }
diff --git a/src/Build/Collections/IConstrainableDictionary.cs b/src/Build/Collections/IConstrainableDictionary.cs
new file mode 100644
index 00000000000..2c4b34eef5d
--- /dev/null
+++ b/src/Build/Collections/IConstrainableDictionary.cs
@@ -0,0 +1,31 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Represents an <see cref="IDictionary{String, TValue}"/> that supports use of an
+    /// <see cref="IConstrainedEqualityComparer{T}"/>.
+    /// </summary>
+    /// <typeparam name="TValue">The type of the values in the dictionary. The key is assumed
+    /// to always be <see cref="String"/>.</typeparam>
+    internal interface IConstrainableDictionary<TValue> : IDictionary<string, TValue>
+    {
+        /// <summary>
+        /// Get the value with the specified key or null if it is not present.
+        /// The key used for lookup is the substring of <paramref name="keyString"/>
+        /// starting at <paramref name="startIndex"/> and ending at <paramref name="endIndex"/>
+        /// (e.g. if the key is just the first character in <paramref name="keyString"/>, then
+        /// the value for <paramref name="startIndex"/> should be 0 and the value for
+        /// <paramref name="endIndex"/> should also be 0.)
+        /// </summary>
+        /// <param name="keyString">A string that contains the key of the item to retrieve.</param>
+        /// <param name="startIndex">The start index of the substring of <paramref name="keyString"/> that contains the key.</param>
+        /// <param name="endIndex">The end index of the substring of <paramref name="keyString"/> that contains the key.</param>
+        /// <returns>If it's found, the item whose key matches the calculated substring. Null otherwise.</returns>
+        TValue? Get(string keyString, int startIndex, int endIndex);
+    }
+}
diff --git a/src/Build/Collections/IItemDictionary.cs b/src/Build/Collections/IItemDictionary.cs
new file mode 100644
index 00000000000..481b42dda6c
--- /dev/null
+++ b/src/Build/Collections/IItemDictionary.cs
@@ -0,0 +1,130 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Collections
+{
+    internal interface IItemDictionary<T> : IEnumerable<T>, IItemProvider<T>
+        where T : class, IKeyed, IItem
+    {
+        /// <summary>
+        /// Number of items in total, for debugging purposes.
+        /// </summary>
+        int Count { get; }
+
+        /// <summary>
+        /// Get the item types that have at least one item in this collection.
+        /// </summary>
+        /// <remarks>
+        /// KeyCollection&lt;K&gt; is already a read only collection, so no protection
+        /// is necessary.
+        /// </remarks>
+        ICollection<string> ItemTypes { get; }
+
+        /// <summary>
+        /// Returns the item list for a particular item type,
+        /// creating and adding a new item list if necessary.
+        /// Does not throw if there are no items of this type.
+        /// This is a read-only list.
+        /// If the result is not empty it is a live list.
+        /// Use AddItem or RemoveItem to modify items in this project.
+        /// Using the return value from this in a multithreaded situation is unsafe.
+        /// </summary>
+        ICollection<T> this[string itemType] { get; }
+
+        /// <summary>
+        /// Empty the collection.
+        /// </summary>
+        void Clear();
+
+        /// <summary>
+        /// Returns an enumerable which copies the underlying data on read.
+        /// </summary>
+        IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector);
+
+        /// <summary>
+        /// Enumerates item lists per each item type under the lock.
+        /// </summary>
+        /// <param name="itemTypeCallback">
+        /// A delegate that accepts the item type string and a list of items of that type.
+        /// Will be called for each item type in the list.
+        /// </param>
+        void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback);
+
+        /// <summary>
+        /// Whether the provided item is in this table or not.
+        /// </summary>
+        bool Contains(T projectItem);
+
+        /// <summary>
+        /// Add a new item to the collection, at the
+        /// end of the list of other items with its key.
+        /// </summary>
+        void Add(T projectItem);
+
+        void AddRange(IEnumerable<T> projectItems);
+
+        /// <summary>
+        /// Removes an item, if it is in the collection.
+        /// Returns true if it was found, otherwise false.
+        /// </summary>
+        /// <remarks>
+        /// If a list is emptied, removes the list from the enclosing collection
+        /// so it can be garbage collected.
+        /// </remarks>        
+        bool Remove(T projectItem);
+
+        /// <summary>
+        /// Replaces an existing item with a new item.  This is necessary to preserve the original ordering semantics of Lookup.GetItems
+        /// when items with metadata modifications are being returned.  See Dev10 bug 480737.
+        /// If the item is not found, does nothing.
+        /// </summary>
+        /// <param name="existingItem">The item to be replaced.</param>
+        /// <param name="newItem">The replacement item.</param>
+        void Replace(T existingItem, T newItem);
+
+        /// <summary>
+        /// Add the set of items specified to this dictionary.
+        /// </summary>
+        /// <param name="other">An enumerator over the items to remove.</param>
+        void ImportItems(IEnumerable<T> other);
+
+        /// <summary>
+        /// Add the set of items specified, all sharing an item type, to this dictionary.
+        /// </summary>
+        /// <comment>
+        /// This is a little faster than ImportItems where all the items have the same item type.
+        /// </comment>
+        void ImportItemsOfType(string itemType, IEnumerable<T> items);
+
+        /// <summary>
+        /// Remove the set of items specified from this dictionary
+        /// </summary>
+        /// <param name="other">An enumerator over the items to remove.</param>
+        void RemoveItems(IEnumerable<T> other);
+
+        /// <summary>
+        /// Special method used for batching buckets.
+        /// Adds an explicit marker indicating there are no items for the specified item type.
+        /// In the general case, this is redundant, but batching buckets use this to indicate that they are
+        /// batching over the item type, but their bucket does not contain items of that type.
+        /// See <see cref="HasEmptyMarker">HasEmptyMarker</see>.
+        /// </summary>
+        void AddEmptyMarker(string itemType);
+
+        /// <summary>
+        /// Special method used for batching buckets.
+        /// Lookup can call this to see whether there was an explicit marker placed indicating that
+        /// there are no items of this type. See comment on <see cref="AddEmptyMarker">AddEmptyMarker</see>.
+        /// </summary>
+        bool HasEmptyMarker(string itemType);
+    }
+}
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index d2543da7f5b..1bd66a6e97a 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Item class type to store</typeparam>
     [DebuggerDisplay("#Item types={ItemTypes.Count} #Items={Count}")]
-    internal sealed class ItemDictionary<T> : IEnumerable<T>, IItemProvider<T>
+    internal sealed class ItemDictionary<T> : IItemDictionary<T>
         where T : class, IKeyed, IItem
     {
         /// <summary>
@@ -50,7 +50,7 @@ internal sealed class ItemDictionary<T> : IEnumerable<T>, IItemProvider<T>
         /// <summary>
         /// Constructor for an empty collection.
         /// </summary>
-        internal ItemDictionary()
+        public ItemDictionary()
         {
             // Tracing.Record("new item dictionary");
             _itemLists = new Dictionary<string, LinkedList<T>>(MSBuildNameIgnoreCaseComparer.Default);
@@ -61,7 +61,7 @@ internal ItemDictionary()
         /// Constructor for an empty collection taking an initial capacity
         /// for the number of distinct item types
         /// </summary>
-        internal ItemDictionary(int initialItemTypesCapacity, int initialItemsCapacity = 0)
+        public ItemDictionary(int initialItemTypesCapacity, int initialItemsCapacity = 0)
         {
             // Tracing.Record("new item dictionary");
             _itemLists = new Dictionary<string, LinkedList<T>>(initialItemTypesCapacity, MSBuildNameIgnoreCaseComparer.Default);
@@ -71,7 +71,7 @@ internal ItemDictionary(int initialItemTypesCapacity, int initialItemsCapacity =
         /// <summary>
         /// Constructor for an collection holding items from a specified enumerable.
         /// </summary>
-        internal ItemDictionary(IEnumerable<T> items)
+        public ItemDictionary(IEnumerable<T> items)
         {
             // Tracing.Record("new item dictionary");
             _itemLists = new Dictionary<string, LinkedList<T>>(MSBuildNameIgnoreCaseComparer.Default);
@@ -82,7 +82,7 @@ internal ItemDictionary(IEnumerable<T> items)
         /// <summary>
         /// Number of items in total, for debugging purposes.
         /// </summary>
-        internal int Count => _nodes.Count;
+        public int Count => _nodes.Count;
 
         /// <summary>
         /// Get the item types that have at least one item in this collection
@@ -91,7 +91,7 @@ internal ItemDictionary(IEnumerable<T> items)
         /// KeyCollection&lt;K&gt; is already a read only collection, so no protection
         /// is necessary.
         /// </remarks>
-        internal ICollection<string> ItemTypes
+        public ICollection<string> ItemTypes
         {
             get
             {
@@ -111,7 +111,7 @@ internal ICollection<string> ItemTypes
         /// Use AddItem or RemoveItem to modify items in this project.
         /// Using the return value from this in a multithreaded situation is unsafe.
         /// </summary>
-        internal ICollection<T> this[string itemtype]
+        public ICollection<T> this[string itemtype]
         {
             get
             {
@@ -176,7 +176,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// A delegate that accepts the item type string and a list of items of that type.
         /// Will be called for each item type in the list.
         /// </param>
-        internal void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
+        public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
         {
             lock (_itemLists)
             {
@@ -214,7 +214,7 @@ public ICollection<T> GetItems(string itemType)
         /// <summary>
         /// Whether the provided item is in this table or not.
         /// </summary>
-        internal bool Contains(T projectItem)
+        public bool Contains(T projectItem)
         {
             lock (_itemLists)
             {
@@ -226,7 +226,7 @@ internal bool Contains(T projectItem)
         /// Add a new item to the collection, at the
         /// end of the list of other items with its key.
         /// </summary>
-        internal void Add(T projectItem)
+        public void Add(T projectItem)
         {
             lock (_itemLists)
             {
@@ -241,6 +241,24 @@ internal void Add(T projectItem)
             }
         }
 
+        public void AddRange(IEnumerable<T> projectItems)
+        {
+            lock (_itemLists)
+            {
+                foreach (var projectItem in projectItems)
+                {
+                    if (!_itemLists.TryGetValue(projectItem.Key, out LinkedList<T> list))
+                    {
+                        list = new LinkedList<T>();
+                        _itemLists[projectItem.Key] = list;
+                    }
+
+                    LinkedListNode<T> node = list.AddLast(projectItem);
+                    _nodes.Add(projectItem, node);
+                }
+            }
+        }
+
         /// <summary>
         /// Removes an item, if it is in the collection.
         /// Returns true if it was found, otherwise false.
@@ -248,8 +266,8 @@ internal void Add(T projectItem)
         /// <remarks>
         /// If a list is emptied, removes the list from the enclosing collection
         /// so it can be garbage collected.
-        /// </remarks>        
-        internal bool Remove(T projectItem)
+        /// </remarks>
+        public bool Remove(T projectItem)
         {
             lock (_itemLists)
             {
@@ -279,7 +297,7 @@ internal bool Remove(T projectItem)
         /// </summary>
         /// <param name="existingItem">The item to be replaced.</param>
         /// <param name="newItem">The replacement item.</param>
-        internal void Replace(T existingItem, T newItem)
+        public void Replace(T existingItem, T newItem)
         {
             ErrorUtilities.VerifyThrow(existingItem.Key == newItem.Key, "Cannot replace an item {0} with an item {1} with a different name.", existingItem.Key, newItem.Key);
             lock (_itemLists)
@@ -297,12 +315,9 @@ internal void Replace(T existingItem, T newItem)
         /// Add the set of items specified to this dictionary
         /// </summary>
         /// <param name="other">An enumerator over the items to remove.</param>
-        internal void ImportItems(IEnumerable<T> other)
+        public void ImportItems(IEnumerable<T> other)
         {
-            foreach (T item in other)
-            {
-                Add(item);
-            }
+            AddRange(other);
         }
 
         /// <summary>
@@ -311,7 +326,7 @@ internal void ImportItems(IEnumerable<T> other)
         /// <comment>
         /// This is a little faster than ImportItems where all the items have the same item type.
         /// </comment>
-        internal void ImportItemsOfType(string itemType, IEnumerable<T> items)
+        public void ImportItemsOfType(string itemType, IEnumerable<T> items)
         {
             lock (_itemLists)
             {
@@ -337,7 +352,7 @@ internal void ImportItemsOfType(string itemType, IEnumerable<T> items)
         /// Remove the set of items specified from this dictionary
         /// </summary>
         /// <param name="other">An enumerator over the items to remove.</param>
-        internal void RemoveItems(IEnumerable<T> other)
+        public void RemoveItems(IEnumerable<T> other)
         {
             foreach (T item in other)
             {
@@ -352,7 +367,7 @@ internal void RemoveItems(IEnumerable<T> other)
         /// batching over the item type, but their bucket does not contain items of that type.
         /// See <see cref="HasEmptyMarker">HasEmptyMarker</see>.
         /// </summary>
-        internal void AddEmptyMarker(string itemType)
+        public void AddEmptyMarker(string itemType)
         {
             lock (_itemLists)
             {
@@ -366,7 +381,7 @@ internal void AddEmptyMarker(string itemType)
         /// Lookup can call this to see whether there was an explicit marker placed indicating that
         /// there are no items of this type. See comment on <see cref="AddEmptyMarker">AddEmptyMarker</see>.
         /// </summary>
-        internal bool HasEmptyMarker(string itemType)
+        public bool HasEmptyMarker(string itemType)
         {
             lock (_itemLists)
             {
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 5b20c1f59ba..b15a0c8f8f2 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -35,14 +35,14 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
     [DebuggerDisplay("#Entries={Count}")]
-    internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<PropertyDictionary<T>>, IPropertyProvider<T>, IDictionary<string, T>
+    internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<PropertyDictionary<T>>, IPropertyProvider<T>, IDictionary<string, T>, IConstrainableDictionary<T>
         where T : class, IKeyed, IValued, IEquatable<T>
     {
         /// <summary>
         /// Backing dictionary
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        private readonly RetrievableEntryHashSet<T> _properties;
+        private readonly IRetrievableEntryHashSet<T> _properties;
 
         /// <summary>
         /// Creates empty dictionary
@@ -92,6 +92,15 @@ internal PropertyDictionary(int capacity, IEnumerable<T> elements)
             }
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="PropertyDictionary{T}"/> class.
+        /// </summary>
+        /// <param name="propertiesHashSet">The collection of properties to use.</param>
+        internal PropertyDictionary(IRetrievableEntryHashSet<T> propertiesHashSet)
+        {
+            _properties = propertiesHashSet;
+        }
+
         /// <summary>
         /// Accessor for the list of property names
         /// </summary>
@@ -132,7 +141,7 @@ int ICollection<KeyValuePair<string, T>>.Count
             {
                 lock (_properties)
                 {
-                    return _properties.Count;
+                    return ((ICollection<T>)_properties).Count;
                 }
             }
         }
@@ -152,7 +161,7 @@ internal int Count
             {
                 lock (_properties)
                 {
-                    return _properties.Count;
+                    return ((ICollection<T>)_properties).Count;
                 }
             }
         }
@@ -228,7 +237,7 @@ public void Clear()
         {
             lock (_properties)
             {
-                _properties.Clear();
+                ((ICollection<T>)_properties).Clear();
             }
         }
 
@@ -318,6 +327,12 @@ public T GetProperty(string name, int startIndex, int endIndex)
             }
         }
 
+        /// <inheritdoc />
+        public T Get(string keyString, int startIndex, int endIndex)
+        {
+            return GetProperty(keyString, startIndex, endIndex);
+        }
+
         #region IDictionary<string,T> Members
 
         /// <summary>
@@ -424,13 +439,7 @@ bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> item)
         /// </summary>
         IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator()
         {
-            lock (_properties)
-            {
-                foreach (var entry in _properties)
-                {
-                    yield return new KeyValuePair<string, T>(entry.Key, entry);
-                }
-            }
+            return ((IEnumerable<KeyValuePair<string, T>>)_properties).GetEnumerator();
         }
 
         #endregion
@@ -500,7 +509,7 @@ internal Dictionary<string, string> ToDictionary()
         {
             lock (_properties)
             {
-                var dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);
+                var dictionary = new Dictionary<string, string>(((ICollection<T>)_properties).Count, MSBuildNameIgnoreCaseComparer.Default);
 
                 foreach (T property in this)
                 {
@@ -515,7 +524,7 @@ internal void Enumerate(Action<string, string> keyValueCallback)
         {
             lock (_properties)
             {
-                foreach (var kvp in _properties)
+                foreach (var kvp in (ICollection<T>)_properties)
                 {
                     keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));
                 }
@@ -527,7 +536,7 @@ internal IEnumerable<TResult> Filter<TResult>(Func<T, bool> filter, Func<T, TRes
             List<TResult> result = new();
             lock (_properties)
             {
-                foreach (T property in _properties)
+                foreach (T property in (ICollection<T>)_properties)
                 {
                     if (filter(property))
                     {
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index fb954982e34..2bb4d579818 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -82,9 +82,7 @@ namespace Microsoft.Build.Collections
 #if FEATURE_SECURITY_PERMISSIONS
     [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
-    internal class RetrievableEntryHashSet<T> : ICollection<T>,
-        ISerializable, IDeserializationCallback,
-        IDictionary<string, T>
+    internal class RetrievableEntryHashSet<T> : IRetrievableEntryHashSet<T>
         where T : class, IKeyed
     {
         // store lower 31 bits of hash code
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
new file mode 100644
index 00000000000..edef71ccbc2
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
@@ -0,0 +1,75 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    internal interface IRetrievableEntryHashSet<T> :
+        ICollection<T>,
+        ISerializable,
+        IDeserializationCallback,
+        ICollection<KeyValuePair<string, T>>,
+        IEnumerable<KeyValuePair<string, T>>,
+        IDictionary<string, T>
+        where T : class, IKeyed
+    {
+        /// <summary>
+        /// Gets the item with the given name.
+        /// </summary>
+        /// <param name="key">key to check for containment.</param>
+        /// <returns>The item (if contained).</returns>
+        /// <exception cref="KeyNotFoundException">Thrown if no item with the given name is present in the collection.</exception>
+        T Get(string key);
+
+        /// <summary>
+        /// Gets the item if any with the given name.
+        /// </summary>
+        /// <param name="key">key to check for containment.</param>
+        /// <param name="index">The position of the substring within <paramref name="key"/>.</param>
+        /// <param name="length">The maximum number of characters in the <paramref name="key"/> to lookup.</param>
+        /// <returns>The item (if contained).</returns>
+        /// <exception cref="KeyNotFoundException">Thrown if no item with the given name is present in the collection.</exception>
+        T Get(string key, int index, int length);
+
+        /// <summary>
+        /// Copies the contents of this HashSet into the provided array.
+        /// </summary>
+        /// <param name="array">The array into which the contents of this HashSet will be copied.</param>
+        void CopyTo(T[] array);
+
+        /// <summary>
+        /// Copies the contents of this HashSet into the provided array.
+        /// </summary>
+        /// <param name="array">The array into which the contents of this HashSet will be copied.</param>
+        /// <param name="arrayIndex">The index within <paramref name="array"/> where the first item will be placed.</param>
+        /// <param name="count">The number of items from HashSet to copy into <paramref name="array"/>.</param>
+        void CopyTo(T[] array, int arrayIndex, int count);
+
+        /// <summary>
+        /// Take the union of this HashSet with other. Modifies this set.
+        /// 
+        /// Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
+        /// multiple resizes ended up not being useful in practice; quickly gets to the 
+        /// point where it's a wasteful check.
+        /// </summary>
+        /// <param name="other">enumerable with items to add</param>
+        void UnionWith(IEnumerable<T> other);
+
+        /// <summary>
+        /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
+        /// unless count is 0, in which case we release references.
+        /// 
+        /// This method can be used to minimize a list's memory overhead once it is known that no
+        /// new elements will be added to the list. To completely clear a list and release all 
+        /// memory referenced by the list, execute the following statements:
+        /// 
+        /// list.Clear();
+        /// list.TrimExcess();
+        /// </summary>
+        void TrimExcess();
+    }
+}
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 106b1ca08ee..3302fa6e23c 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -4118,7 +4118,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// Items in this project, ordered within groups of item types.
             /// Protected by an upcast to IEnumerable.
             /// </summary>
-            public ItemDictionary<ProjectItem> Items { get; private set; }
+            public IItemDictionary<ProjectItem> Items { get; private set; }
 
             public List<ProjectItemElement> EvaluatedItemElements { get; private set; }
 
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 729e99b48ab..23b93da8f03 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -190,7 +190,7 @@ IEnumerable<D> ItemDefinitionsEnumerable
         /// covariance problems. (A dictionary of Key, Value cannot be upcast
         /// to a Dictionary of Key, IValue).
         /// </summary>
-        ItemDictionary<I> Items
+        IItemDictionary<I> Items
         {
             get;
         }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 74e43ce6c93..79cd844c167 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -30,7 +30,7 @@ public EvaluatorData(IEvaluatorData<P, I, M, D> wrappedData, IReadOnlyDictionary
                 _itemsByType = itemsByType;
             }
 
-            public ItemDictionary<I> Items
+            public IItemDictionary<I> Items
             {
                 get
                 {
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 7a4d6da9521..51117c2d7c1 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -134,7 +134,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public bool CanEvaluateElementsWithFalseConditions => _wrapped.CanEvaluateElementsWithFalseConditions;
         public PropertyDictionary<P> Properties => _wrapped.Properties;
         public IEnumerable<D> ItemDefinitionsEnumerable => _wrapped.ItemDefinitionsEnumerable;
-        public ItemDictionary<I> Items => _wrapped.Items;
+        public IItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
         public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
diff --git a/src/Build/Instance/IImmutableInstanceProvider.cs b/src/Build/Instance/IImmutableInstanceProvider.cs
new file mode 100644
index 00000000000..a862a12cf13
--- /dev/null
+++ b/src/Build/Instance/IImmutableInstanceProvider.cs
@@ -0,0 +1,14 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Represents an object that is immutable and has an Instance, e.g. a <see cref="ProjectPropertyInstance"/>.
+    /// </summary>
+    /// <typeparam name="T">The Instance type.</typeparam>
+    internal interface IImmutableInstanceProvider<T>
+    {
+        T ImmutableInstance { get; set; }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
new file mode 100644
index 00000000000..fe7503827a9
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
@@ -0,0 +1,278 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Data;
+using System.Runtime.Serialization;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+
+namespace Microsoft.Build.Instance
+{
+    /// <summary>
+    /// A specialized collection used when element data originates in an immutable Project.
+    /// </summary>
+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
+        where T : class, IKeyed
+    {
+        private readonly IDictionary<string, TCached> _projectElements;
+        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+        private readonly ValuesCollection _values;
+
+        public ImmutableElementCollectionConverter(
+            IDictionary<string, TCached> projectElements,
+            IDictionary<(string, int, int), TCached> constrainedProjectElements)
+        {
+            _projectElements = projectElements;
+            _constrainedProjectElements = constrainedProjectElements;
+            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);
+        }
+
+        public T this[string key]
+        {
+            get => Get(key);
+            set => throw new NotSupportedException();
+        }
+
+        public int Count => _values.Count;
+
+        public bool IsReadOnly => true;
+
+        public ICollection<string> Keys => _projectElements.Keys;
+
+        public ICollection<T> Values => _values;
+
+        public void Add(T item) => throw new NotSupportedException();
+
+        public void Add(string key, T value) => throw new NotSupportedException();
+
+        public void Add(KeyValuePair<string, T> item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public bool Contains(T item) => _projectElements.ContainsKey(item.Key);
+
+        public bool Contains(KeyValuePair<string, T> item) => _projectElements.ContainsKey(item.Key);
+
+        public bool ContainsKey(string key) => _projectElements.ContainsKey(key);
+
+        public void CopyTo(T[] array) => _values.CopyTo(array, arrayIndex: 0);
+
+        public void CopyTo(T[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);
+
+        public void CopyTo(T[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);
+
+        public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);
+
+        public T Get(string key) => _values.Get(key);
+
+        public T Get(string key, int index, int length) => _values.Get(key, index, length);
+
+        public IEnumerator<T> GetEnumerator() => _values.GetEnumerator();
+
+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();
+
+        public void OnDeserialization(object sender) => throw new NotSupportedException();
+
+        public bool Remove(T item) => throw new NotSupportedException();
+
+        public bool Remove(string key) => throw new NotSupportedException();
+
+        public bool Remove(KeyValuePair<string, T> item) => throw new NotSupportedException();
+
+        public void TrimExcess()
+        {
+        }
+
+        public bool TryGetValue(string key, out T value) => _values.TryGetValue(key, out value);
+
+        public void UnionWith(IEnumerable<T> other) => throw new NotSupportedException();
+
+        IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator() => _values.GetKvpEnumerator();
+
+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();
+
+        /// <summary>
+        /// Wraps the Project's values.
+        /// </summary>
+        private class ValuesCollection : ICollection<T>
+        {
+            private readonly IDictionary<string, TCached> _projectElements;
+            private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+
+            public ValuesCollection(
+                IDictionary<string, TCached> projectElements,
+                IDictionary<(string, int, int), TCached> constrainedProjectElements)
+            {
+                _projectElements = projectElements;
+                _constrainedProjectElements = constrainedProjectElements;
+            }
+
+            public int Count => _projectElements.Count;
+
+            public bool IsReadOnly => true;
+
+            public void Add(T item) => throw new NotSupportedException();
+
+            public void Clear() => throw new NotSupportedException();
+
+            public bool Contains(T item)
+            {
+                if (item == null)
+                {
+                    throw new ArgumentNullException(nameof(item));
+                }
+
+                return _projectElements.ContainsKey(item.Key);
+            }
+
+            public void CopyTo(T[] array, int arrayIndex)
+            {
+                if (array == null)
+                {
+                    throw new ArgumentNullException(nameof(array));
+                }
+
+                if (arrayIndex < 0)
+                {
+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));
+                }
+
+                int count = Math.Min(Count, array.Length - arrayIndex);
+
+                CopyTo(array, arrayIndex, count);
+            }
+
+            public void CopyTo(T[] array, int arrayIndex, int count)
+            {
+                if (array == null)
+                {
+                    throw new ArgumentNullException(nameof(array));
+                }
+
+                if (arrayIndex < 0)
+                {
+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));
+                }
+
+                if (count < 0)
+                {
+                    throw new ArgumentOutOfRangeException(nameof(count));
+                }
+
+                int index = arrayIndex;
+                int endIndex = arrayIndex + count;
+                foreach (var item in _projectElements.Values)
+                {
+                    array[index] = GetElementInstance(item);
+                    ++index;
+                    if (index >= endIndex)
+                    {
+                        break;
+                    }
+                }
+            }
+
+            public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex)
+            {
+                if (array == null)
+                {
+                    throw new ArgumentNullException(nameof(array));
+                }
+
+                if (arrayIndex < 0)
+                {
+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));
+                }
+
+                int count = Math.Min(_projectElements.Count, array.Length - arrayIndex);
+                int index = arrayIndex;
+                int endIndex = arrayIndex + count;
+                foreach (var item in _projectElements.Values)
+                {
+                    var itemInstance = GetElementInstance(item);
+                    array[index] = new KeyValuePair<string, T>(itemInstance.Key, itemInstance);
+                    ++index;
+                    if (index >= endIndex)
+                    {
+                        break;
+                    }
+                }
+            }
+
+            public IEnumerator<T> GetEnumerator()
+            {
+                foreach (var item in _projectElements.Values)
+                {
+                    yield return GetElementInstance(item);
+                }
+            }
+
+            public IEnumerator<KeyValuePair<string, T>> GetKvpEnumerator()
+            {
+                foreach (var kvp in _projectElements)
+                {
+                    T instance = GetElementInstance(kvp.Value);
+                    yield return new KeyValuePair<string, T>(kvp.Key, instance);
+                }
+            }
+
+            public bool Remove(T item) => throw new NotSupportedException();
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                foreach (var item in _projectElements.Values)
+                {
+                    yield return GetElementInstance(item);
+                }
+            }
+
+            public T Get(string key)
+            {
+                if (_projectElements.TryGetValue(key, out TCached element))
+                {
+                    return GetElementInstance(element);
+                }
+
+                return null;
+            }
+
+            public T Get(string keyString, int startIndex, int length)
+            {
+                if (_constrainedProjectElements.TryGetValue((keyString, startIndex, length), out TCached element))
+                {
+                    return GetElementInstance(element);
+                }
+
+                return null;
+            }
+
+            public bool TryGetValue(string key, out T value)
+            {
+                value = null;
+                if (!_projectElements.TryGetValue(key, out TCached element))
+                {
+                    return false;
+                }
+
+                value = GetElementInstance(element);
+                return value != null;
+            }
+
+            private T GetElementInstance(TCached element)
+            {
+                if (element is IImmutableInstanceProvider<T> instanceProvider)
+                {
+                    return instanceProvider.ImmutableInstance;
+                }
+
+                return null;
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
new file mode 100644
index 00000000000..c76383cce10
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -0,0 +1,232 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+
+namespace Microsoft.Build.Instance
+{
+    /// <summary>
+    /// A specialized collection used when item data originates in an immutable Project.
+    /// </summary>
+    internal class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>
+        where T : class, IKeyed, IItem
+    {
+        private readonly IDictionary<string, ICollection<TCached>> _itemsByType;
+        private readonly ICollection<T> _allItems;
+
+        public ImmutableItemDictionary(IDictionary<string, ICollection<TCached>> itemsByType, ICollection<TCached> allItems)
+        {
+            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
+
+            if (allItems == null)
+            {
+                throw new ArgumentNullException(nameof(allItems));
+            }
+
+            var convertedItems = new HashSet<T>(allItems.Count);
+            foreach (var item in allItems)
+            {
+                T? instance = GetInstance(item);
+                if (instance != null)
+                {
+                    convertedItems.Add(instance);
+                }
+            }
+            _allItems = new ReadOnlyCollection<T>(convertedItems);
+        }
+
+        /// <inheritdoc />
+        public ICollection<T> this[string itemType]
+        {
+            get
+            {
+                if (!_itemsByType.TryGetValue(itemType, out ICollection<TCached>? list))
+                {
+                    return Array.Empty<T>();
+                }
+
+                return new ListConverter(itemType, _allItems, list);
+            }
+        }
+
+        /// <inheritdoc />
+        public int Count => _allItems.Count;
+
+        /// <inheritdoc />
+        public ICollection<string> ItemTypes => _itemsByType.Keys;
+
+        /// <inheritdoc />
+        public void Add(T projectItem) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void AddEmptyMarker(string itemType) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void AddRange(IEnumerable<T> projectItems) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void Clear() => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public bool Contains(T projectItem) => _allItems.Contains(projectItem);
+
+        /// <inheritdoc />
+        public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
+        {
+            foreach (var kvp in _itemsByType)
+            {
+                if (kvp.Value == null || kvp.Value.Count == 0)
+                {
+                    // skip empty markers
+                    continue;
+                }
+
+                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, _allItems, kvp.Value));
+            }
+        }
+
+        /// <inheritdoc />
+        public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)
+        {
+            foreach (var item in _allItems)
+            {
+                yield return selector(item);
+            }
+        }
+
+        /// <inheritdoc />
+        public IEnumerator<T> GetEnumerator() => _allItems.GetEnumerator();
+
+        /// <inheritdoc />
+        IEnumerator IEnumerable.GetEnumerator() => _allItems.GetEnumerator();
+
+        /// <inheritdoc />
+        public ICollection<T> GetItems(string itemType)
+        {
+            if (_itemsByType.TryGetValue(itemType, out ICollection<TCached>? items))
+            {
+                return new ListConverter(itemType, _allItems, items);
+            }
+
+            return Array.Empty<T>();
+        }
+
+        /// <inheritdoc />
+        public bool HasEmptyMarker(string itemType) => _itemsByType.Values.Any(list => list.Count == 0);
+
+        /// <inheritdoc />
+        public void ImportItems(IEnumerable<T> other) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void ImportItemsOfType(string itemType, IEnumerable<T> items) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public bool Remove(T projectItem) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void RemoveItems(IEnumerable<T> other) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void Replace(T existingItem, T newItem) => throw new NotSupportedException();
+
+        private static T? GetInstance(TCached item)
+        {
+            if (item is IImmutableInstanceProvider<T> instanceProvider)
+            {
+                return instanceProvider.ImmutableInstance;
+            }
+
+            return null;
+        }
+
+        private class ListConverter : ICollection<T>
+        {
+            private readonly string _itemType;
+            private readonly ICollection<T> _allItems;
+            private readonly ICollection<TCached> _list;
+
+            public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCached> list)
+            {
+                _itemType = itemType;
+                _allItems = allItems;
+                _list = list;
+            }
+
+            public int Count => _list.Count;
+
+            public bool IsReadOnly => true;
+
+            public void Add(T item) => throw new NotSupportedException();
+
+            public void Clear() => throw new NotSupportedException();
+
+            public bool Remove(T item) => throw new NotSupportedException();
+
+            public bool Contains(T item)
+            {
+                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&
+                       _allItems.Contains(item);
+            }
+
+            public void CopyTo(T[] array, int arrayIndex)
+            {
+                if (array == null)
+                {
+                    throw new ArgumentNullException(nameof(array));
+                }
+
+                if (arrayIndex < 0 || arrayIndex >= array.Length)
+                {
+                    throw new ArgumentOutOfRangeException(nameof(arrayIndex));
+                }
+
+                int currentIndex = arrayIndex;
+                foreach (var item in _list)
+                {
+                    T? instance = GetInstance(item);
+                    if (instance != null)
+                    {
+                        array[currentIndex] = instance;
+                        ++currentIndex;
+                        if (currentIndex == array.Length)
+                        {
+                            break;
+                        }
+                    }
+                }
+            }
+
+            public IEnumerator<T> GetEnumerator()
+            {
+                foreach (var item in _list)
+                {
+                    T? instance = GetInstance(item);
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                foreach (var item in _list)
+                {
+                    T? instance = GetInstance(item);
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index c636ae81b41..e227658af5e 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -21,6 +21,7 @@
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Instance;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -34,6 +35,7 @@
 namespace Microsoft.Build.Execution
 {
     using Utilities = Microsoft.Build.Internal.Utilities;
+
     /// <summary>
     /// Enum for controlling project instance creation
     /// </summary>
@@ -124,7 +126,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// <summary>
         /// Items in the project. This is a dictionary of ordered lists of a single type of items keyed by item type.
         /// </summary>
-        private ItemDictionary<ProjectItemInstance> _items;
+        private IItemDictionary<ProjectItemInstance> _items;
 
         /// <summary>
         /// Items organized by evaluatedInclude value
@@ -151,7 +153,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// <summary>
         /// The item definitions from the parent Project.
         /// </summary>
-        private RetrievableEntryHashSet<ProjectItemDefinitionInstance> _itemDefinitions;
+        private IRetrievableEntryHashSet<ProjectItemDefinitionInstance> _itemDefinitions;
 
         /// <summary>
         /// The HostServices to use during a build.
@@ -388,6 +390,83 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
             _isImmutable = immutable;
         }
 
+        /// <summary>
+        /// Creates a ProjectInstance from an immutable <see cref="Project"/>.
+        /// The resulting <see cref="ProjectInstance"/> object wraps the <see cref="Project"/>
+        /// object. Unlike the ProjectInstance(Project project, ProjectInstanceSettings settings)
+        /// constructor, the properties and items are not cloned.
+        /// </summary>
+        /// <param name="linkedProject">The immutable <see cref="Project"/>.</param>
+        /// <param name="fastItemLookupNeeded">Whether the fast item lookup cache is required.</param>
+        private ProjectInstance(Project linkedProject, bool fastItemLookupNeeded)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(linkedProject, nameof(linkedProject));
+
+            var projectPath = linkedProject.FullPath;
+            _directory = Path.GetDirectoryName(projectPath);
+            _projectFileLocation = ElementLocation.Create(projectPath);
+            _hostServices = linkedProject.ProjectCollection.HostServices;
+            _isImmutable = true;
+
+            EvaluationId = linkedProject.EvaluationCounter;
+
+            // ProjectProperties
+            InitializeImmutableProjectPropertyInstances(linkedProject.Properties);
+            var projectPropertiesConverter = GetImmutableElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(linkedProject.Properties);
+            _properties = new PropertyDictionary<ProjectPropertyInstance>(projectPropertiesConverter);
+
+            // ProjectItemDefinitions
+            InitializeImmutableProjectItemDefinitionInstances(linkedProject.ItemDefinitions);
+            _itemDefinitions = GetImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(linkedProject.ItemDefinitions);
+
+            // ProjectItems
+            InitializeImmutableProjectItemInstances(linkedProject.Items);
+            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
+            var allItems = linkedProject.Items as ICollection<ProjectItem>;
+            _items = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(itemsByType, allItems);
+
+            // ItemsByEvaluatedInclude
+            if (fastItemLookupNeeded)
+            {
+                _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
+                foreach (var item in linkedProject.Items)
+                {
+                    if (item is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
+                    {
+                        _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, immutableInstanceProvider.ImmutableInstance);
+                    }
+                }
+            }
+
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(linkedProject.GlobalPropertiesCount);
+            foreach (var property in linkedProject.GlobalPropertiesEnumerable)
+            {
+                _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
+            }
+
+            CreateEnvironmentVariablePropertiesSnapshot(linkedProject.ProjectCollection.EnvironmentProperties);
+            CreateTargetsSnapshot(linkedProject.Targets, null, null, null, null);
+            CreateImportsSnapshot(linkedProject.Imports, linkedProject.ImportsIncludingDuplicates);
+
+            Toolset = linkedProject.ProjectCollection.GetToolset(linkedProject.ToolsVersion);
+            SubToolsetVersion = linkedProject.SubToolsetVersion;
+            TaskRegistry = new TaskRegistry(Toolset, linkedProject.ProjectCollection.ProjectRootElementCache);
+
+            ProjectRootElementCache = linkedProject.ProjectCollection.ProjectRootElementCache;
+
+            EvaluatedItemElements = new List<ProjectItemElement>(linkedProject.Items.Count);
+            foreach (var item in linkedProject.Items)
+            {
+                EvaluatedItemElements.Add(item.Xml);
+            }
+
+            _usingDifferentToolsVersionFromProjectFile = false;
+            _originalProjectToolsVersion = linkedProject.ToolsVersion;
+            _explicitToolsVersionSpecified = linkedProject.SubToolsetVersion != null;
+
+            _isImmutable = true;
+        }
+
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -785,6 +864,51 @@ public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElem
                 options.Interactive);
         }
 
+        /// <summary>
+        /// Create a ProjectInstance from an immutable project source.
+        /// </summary>
+        /// <param name="project">The immutable <see cref="Project"/> on which the ProjectInstance is based.</param>
+        /// <param name="settings">The <see cref="ProjectInstanceSettings"/> to use.</param>
+        public static ProjectInstance FromImmutableProjectSource(Project project, ProjectInstanceSettings settings)
+        {
+            bool fastItemLookupNeeded = settings.HasFlag(ProjectInstanceSettings.ImmutableWithFastItemLookup);
+            return new ProjectInstance(project, fastItemLookupNeeded);
+        }
+
+        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
+            ICollection<TCached> elementsCollection)
+            where T : class, IKeyed
+        {
+            // The elementsCollection we receive here is implemented in CPS as a special collection
+            // that is both IDictionary<string, TCached> and also IDictionary<(string, int, int), TCached>.
+            // This allows it to represent the fundamental operations of an IRetrievableEntryHashSet.
+            // The IDictionary<(string, int, int), TCached> interface is used to handle the
+            // IRetrievableEntryHashSet's Get(string key, int index, int length) method. Here we take
+            // elementsCollection and put it into an ImmutableElementCollectionConverter, which
+            // represents the elementsCollection as an IRetrievableEntryHashSet<T>.
+            // That IRetrievableEntryHashSet is then used either directly or as a backing source for
+            // another collection wrapper (e.g. PropertyDictionary).
+            if (elementsCollection is not IDictionary<string, TCached> elementsDictionary ||
+                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
+            {
+                throw new ArgumentException(nameof(elementsCollection));
+            }
+
+            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
+        }
+
+        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
+            IDictionary<string, TCached> elementsDictionary)
+            where T : class, IKeyed
+        {
+            if (elementsDictionary is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
+            {
+                throw new ArgumentException(nameof(elementsDictionary));
+            }
+
+            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
+        }
+
         /// <summary>
         /// Global properties this project was evaluated with, if any.
         /// Read only collection.
@@ -1101,7 +1225,7 @@ IEnumerable<ProjectItemDefinitionInstance> IEvaluatorData<ProjectPropertyInstanc
         /// <summary>
         /// Gets the items
         /// </summary>
-        ItemDictionary<ProjectItemInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Items
+        IItemDictionary<ProjectItemInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Items
         {
             [DebuggerStepThrough]
             get
@@ -1283,7 +1407,7 @@ internal PropertyDictionary<ProjectPropertyInstance> PropertiesToBuildWith
         /// Actual collection of items in this project,
         /// for the build to start with.
         /// </summary>
-        internal ItemDictionary<ProjectItemInstance> ItemsToBuildWith
+        internal IItemDictionary<ProjectItemInstance> ItemsToBuildWith
         {
             [DebuggerStepThrough]
             get
@@ -2360,7 +2484,7 @@ internal bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<
 
             if (loggers != null)
             {
-                parameters.Loggers = (loggers is ICollection<ILogger>) ? ((ICollection<ILogger>)loggers) : new List<ILogger>(loggers);
+                parameters.Loggers = (loggers is ICollection<ILogger> loggersCollection) ? loggersCollection : new List<ILogger>(loggers);
 
                 // Enables task parameter logging based on whether any of the loggers attached
                 // to the Project have their verbosity set to Diagnostic. If no logger has
@@ -2693,6 +2817,41 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
             }
         }
 
+        private static void InitializeImmutableProjectItemDefinitionInstances(IDictionary<string, ProjectItemDefinition> projectItemDefinitions)
+        {
+            foreach (var projectItemDefinition in projectItemDefinitions.Values)
+            {
+                if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> immutableInstanceProvider)
+                {
+                    immutableInstanceProvider.ImmutableInstance = new ProjectItemDefinitionInstance(projectItemDefinition);
+                }
+            }
+        }
+
+        private static void InitializeImmutableProjectPropertyInstances(ICollection<ProjectProperty> projectProperties)
+        {
+            foreach (var projectProperty in projectProperties)
+            {
+                if (projectProperty is IImmutableInstanceProvider<ProjectPropertyInstance> immutableInstanceProvider)
+                {
+                    immutableInstanceProvider.ImmutableInstance = InstantiateProjectPropertyInstance(projectProperty, isImmutable: true);
+                }
+            }
+        }
+
+        private static ProjectPropertyInstance InstantiateProjectPropertyInstance(ProjectProperty property, bool isImmutable)
+        {
+            // Allow reserved property names, since this is how they are added to the project instance.
+            // The caller has prevented users setting them themselves.
+            var instance = ProjectPropertyInstance.Create(
+                                property.Name,
+                                ((IProperty)property).EvaluatedValueEscaped,
+                                true /* MAY be reserved name */,
+                                isImmutable,
+                                property.IsEnvironmentProperty);
+            return instance;
+        }
+
         /// <summary>
         /// Common code for the constructors that evaluate directly.
         /// Global properties may be null.
@@ -2934,44 +3093,60 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
 
             foreach (ProjectItem item in items)
             {
-                List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
+                ProjectItemInstance instance = InstantiateProjectItemInstance(item);
+                _items.Add(instance);
+                projectItemToInstanceMap?.Add(item, instance);
+            }
 
-                if (item.InheritedItemDefinitions != null)
-                {
-                    inheritedItemDefinitions = new List<ProjectItemDefinitionInstance>(item.InheritedItemDefinitions.Count);
+            return projectItemToInstanceMap;
+        }
 
-                    foreach (ProjectItemDefinition inheritedItemDefinition in item.InheritedItemDefinitions)
-                    {
-                        // All item definitions in this list should be present in the collection of item definitions
-                        // on the project we are cloning.
-                        inheritedItemDefinitions.Add(_itemDefinitions[inheritedItemDefinition.ItemType]);
-                    }
+        private void InitializeImmutableProjectItemInstances(ICollection<ProjectItem> projectItems)
+        {
+            foreach (var projectItem in projectItems)
+            {
+                if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
+                {
+                    ProjectItemInstance instance = InstantiateProjectItemInstance(projectItem);
+                    immutableInstanceProvider.ImmutableInstance = instance;
                 }
+            }
+        }
 
-                CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
+        private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
+        {
+            List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
 
-                if (item.DirectMetadata != null)
-                {
-                    directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+            if (item.InheritedItemDefinitions != null)
+            {
+                inheritedItemDefinitions = new List<ProjectItemDefinitionInstance>(item.InheritedItemDefinitions.Count);
 
-                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
-                    directMetadata.ImportProperties(projectMetadataInstances);
+                foreach (ProjectItemDefinition inheritedItemDefinition in item.InheritedItemDefinitions)
+                {
+                    // All item definitions in this list should be present in the collection of item definitions
+                    // on the project we are cloning.
+                    inheritedItemDefinitions.Add(_itemDefinitions[inheritedItemDefinition.ItemType]);
                 }
+            }
 
-                // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
-                var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
-                evaluatedIncludeEscaped ??= item.EvaluatedInclude;
-                var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
-                evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
-
-                ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+            CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
 
-                _items.Add(instance);
+            if (item.DirectMetadata != null)
+            {
+                directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
 
-                projectItemToInstanceMap?.Add(item, instance);
+                IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
+                directMetadata.ImportProperties(projectMetadataInstances);
             }
 
-            return projectItemToInstanceMap;
+            // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
+            var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
+            evaluatedIncludeEscaped ??= item.EvaluatedInclude;
+            var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
+            evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
+
+            ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+            return instance;
         }
 
         /// <summary>
@@ -2979,7 +3154,7 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
         /// </summary>
         private void CreateItemDefinitionsSnapshot(IDictionary<string, ProjectItemDefinition> itemDefinitions)
         {
-            _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
+            _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(itemDefinitions.Count, MSBuildNameIgnoreCaseComparer.Default);
 
             foreach (ProjectItemDefinition definition in itemDefinitions.Values)
             {
@@ -2996,9 +3171,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
 
             foreach (ProjectProperty property in properties)
             {
-                // Allow reserved property names, since this is how they are added to the project instance. 
-                // The caller has prevented users setting them themselves.
-                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
+                ProjectPropertyInstance instance = InstantiateProjectPropertyInstance(property, isImmutable);
                 _properties.Set(instance);
             }
         }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 8b6a56d5713..83bc612cb37 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -244,6 +244,7 @@
     <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
     <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
     <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
@@ -362,6 +363,8 @@
     <Compile Include="Collections\CopyOnWritePropertyDictionary.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="Collections\HashTableUtility.cs" />
+    <Compile Include="Collections\IConstrainableDictionary.cs" />
+    <Compile Include="Collections\IItemDictionary.cs" />
     <Compile Include="Collections\ItemDictionary.cs" />
     <Compile Include="Collections\IImmutable.cs" />
     <Compile Include="Collections\MultiDictionary.cs" />
@@ -484,6 +487,9 @@
     <Compile Include="Globbing\IMSBuildGlob.cs" />
     <Compile Include="Globbing\Visitor\ParsedGlobCollector.cs" />
     <!-- #### INSTANCE MODEL ### -->
+    <Compile Include="Instance\IImmutableInstanceProvider.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableElementCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDictionary.cs" />
     <Compile Include="Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="Instance\HostServices.cs" />
     <Compile Include="Instance\ProjectTargetInstanceChild.cs" />
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index 4baaa9ace7d..c0165f577a5 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
 #nullable disable
@@ -236,20 +237,22 @@ public UsingTaskParameterGroupElement Create(UsingTaskParameterGroupElementLink
         // memory storage of original items (with the Link field) while it is small, some of the MSbuild items can be created
         // in millions so it does adds up otherwise.
 
-        private class LinkedProjectItem : ProjectItem, ILinkableObject
+        private class LinkedProjectItem : ProjectItem, ILinkableObject, IImmutableInstanceProvider<ProjectItemInstance>
         {
             internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemLink link)
                 : base(xml, project)
             {
-                this.Link = link;
+                Link = link;
             }
 
+            public ProjectItemInstance ImmutableInstance { get; set; }
+
             internal override ProjectItemLink Link { get; }
 
             object ILinkableObject.Link => Link;
         }
 
-        private class LinkedProjectItemDefinition : ProjectItemDefinition, ILinkableObject
+        private class LinkedProjectItemDefinition : ProjectItemDefinition, ILinkableObject, IImmutableInstanceProvider<ProjectItemDefinitionInstance>
         {
             internal LinkedProjectItemDefinition(ProjectItemDefinitionLink link, Project project, string itemType)
                 : base(project, itemType)
@@ -257,6 +260,8 @@ internal LinkedProjectItemDefinition(ProjectItemDefinitionLink link, Project pro
                 Link = link;
             }
 
+            public ProjectItemDefinitionInstance ImmutableInstance { get; set; }
+
             internal override ProjectItemDefinitionLink Link { get; }
             object ILinkableObject.Link => Link;
         }
@@ -273,7 +278,7 @@ internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
             object ILinkableObject.Link => Link;
         }
 
-        private class LinkedProjectProperty : ProjectProperty, ILinkableObject
+        private class LinkedProjectProperty : ProjectProperty, ILinkableObject, IImmutableInstanceProvider<ProjectPropertyInstance>
         {
             internal ProjectPropertyLink Link { get; }
             object ILinkableObject.Link => Link;
@@ -290,6 +295,8 @@ internal LinkedProjectProperty(Project project, ProjectPropertyLink link)
                 Link = link;
             }
 
+            public ProjectPropertyInstance ImmutableInstance { get; set;  }
+
             public override string Name => Link.Name;
 
             public override string UnevaluatedValue
