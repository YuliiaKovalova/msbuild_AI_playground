diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index 38d140696ad..fbe94d80c8d 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -805,10 +805,10 @@ public partial class RegisterAssembly : Microsoft.Build.Tasks.AppDomainIsolatedT
         public RegisterAssembly() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem AssemblyListFile { get { throw null; } set { } }
-        public bool CreateCodeBase { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem AssemblyListFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool CreateCodeBase { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
         public void ReportEvent(System.Runtime.InteropServices.ExporterEventKind kind, int code, string msg) { }
         public object ResolveRef(System.Reflection.Assembly assemblyToResolve) { throw null; }
@@ -819,7 +819,7 @@ public RemoveDir() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Directories { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] RemovedDirectories { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] RemovedDirectories { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class RemoveDuplicates : Microsoft.Build.Tasks.TaskExtension
@@ -835,17 +835,17 @@ public RemoveDuplicates() { }
     public sealed partial class RequiresFramework35SP1Assembly : Microsoft.Build.Tasks.TaskExtension
     {
         public RequiresFramework35SP1Assembly() { }
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Assemblies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public bool CreateDesktopShortcut { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public string ErrorReportUrl { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ReferencedAssemblies { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string ErrorReportUrl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ReferencedAssemblies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public bool RequiresMinimumFramework35SP1 { get { throw null; } set { } }
-        public bool SigningManifests { get { throw null; } set { } }
-        public string SuiteName { get { throw null; } set { } }
+        public bool RequiresMinimumFramework35SP1 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool SigningManifests { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string SuiteName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -919,77 +919,77 @@ public ResolveAssemblyReference() { }
     public sealed partial class ResolveCodeAnalysisRuleSet : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveCodeAnalysisRuleSet() { }
-        public string CodeAnalysisRuleSet { get { throw null; } set { } }
-        public string[] CodeAnalysisRuleSetDirectories { get { throw null; } set { } }
-        public string MSBuildProjectDirectory { get { throw null; } set { } }
+        public string CodeAnalysisRuleSet { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string[] CodeAnalysisRuleSetDirectories { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string MSBuildProjectDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedCodeAnalysisRuleSet { get { throw null; } }
+        public string ResolvedCodeAnalysisRuleSet { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class ResolveComReference : Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension
     {
         public ResolveComReference() { }
-        public bool DelaySign { get { throw null; } set { } }
+        public bool DelaySign { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string[] EnvironmentVariables { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
-        public bool ExecuteAsTool { get { throw null; } set { } }
-        public bool IncludeVersionInInteropName { get { throw null; } set { } }
-        public string KeyContainer { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        public bool NoClassMembers { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedAssemblyReferences { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedModules { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        public bool Silent { get { throw null; } set { } }
-        public string StateFile { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
+        public bool ExecuteAsTool { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool IncludeVersionInInteropName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string KeyContainer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string KeyFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool NoClassMembers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ResolvedAssemblyReferences { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] ResolvedFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] ResolvedModules { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string SdkToolsPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Silent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string StateFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string TargetFrameworkVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string TargetProcessorArchitecture { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibNames { get { throw null; } set { } }
-        public string WrapperOutputDirectory { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem[] TypeLibNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string WrapperOutputDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class ResolveKeySource : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveKeySource() { }
-        public int AutoClosePasswordPromptShow { get { throw null; } set { } }
-        public int AutoClosePasswordPromptTimeout { get { throw null; } set { } }
-        public string CertificateFile { get { throw null; } set { } }
-        public string CertificateThumbprint { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
+        public int AutoClosePasswordPromptShow { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public int AutoClosePasswordPromptTimeout { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string CertificateFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string CertificateThumbprint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string KeyFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedKeyContainer { get { throw null; } set { } }
+        public string ResolvedKeyContainer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedKeyFile { get { throw null; } set { } }
+        public string ResolvedKeyFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedThumbprint { get { throw null; } set { } }
-        public bool ShowImportDialogDespitePreviousFailures { get { throw null; } set { } }
-        public bool SuppressAutoClosePasswordPrompt { get { throw null; } set { } }
+        public string ResolvedThumbprint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool ShowImportDialogDespitePreviousFailures { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool SuppressAutoClosePasswordPrompt { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveManifestFiles() { }
-        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputAssemblies { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] OutputAssemblies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputDeploymentManifestEntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem OutputDeploymentManifestEntryPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] OutputFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public Microsoft.Build.Framework.ITaskItem[] PublishFiles { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
-        public bool SigningManifests { get { throw null; } set { } }
-        public string TargetCulture { get { throw null; } set { } }
+        public bool SigningManifests { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string TargetCulture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -999,17 +999,17 @@ public ResolveNativeReference() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public string[] AdditionalSearchPaths { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedComComponents { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ContainedComComponents { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedLooseEtcFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ContainedLooseEtcFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedLooseTlbFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ContainedLooseTlbFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedPrerequisiteAssemblies { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ContainedPrerequisiteAssemblies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedTypeLibraries { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ContainedTypeLibraries { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainingReferenceFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ContainingReferenceFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] NativeReferences { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -1017,11 +1017,11 @@ public ResolveNativeReference() { }
     public partial class ResolveNonMSBuildProjectOutput : Microsoft.Build.Tasks.ResolveProjectBase
     {
         public ResolveNonMSBuildProjectOutput() { }
-        public string PreresolvedProjectOutputs { get { throw null; } set { } }
+        public string PreresolvedProjectOutputs { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedOutputPaths { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ResolvedOutputPaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnresolvedProjectReferences { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] UnresolvedProjectReferences { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public abstract partial class ResolveProjectBase : Microsoft.Build.Tasks.TaskExtension
@@ -1039,8 +1039,8 @@ public ResolveSDKReference() { }
         public Microsoft.Build.Framework.ITaskItem[] DisallowedSDKDependencies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] InstalledSDKs { get { throw null; } set { } }
-        public bool LogResolutionErrorsAsWarnings { get { throw null; } set { } }
-        public bool Prefer32Bit { get { throw null; } set { } }
+        public bool LogResolutionErrorsAsWarnings { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool Prefer32Bit { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public string ProjectName { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] References { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
@@ -1055,7 +1055,7 @@ public ResolveSDKReference() { }
         public string TargetPlatformIdentifier { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public string TargetPlatformVersion { get { throw null; } set { } }
-        public bool WarnOnMissingPlatformVersion { get { throw null; } set { } }
+        public bool WarnOnMissingPlatformVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public sealed partial class RoslynCodeTaskFactory : Microsoft.Build.Framework.ITaskFactory
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 8b3eaa3f6dc..cc819d42ff0 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -494,7 +494,7 @@ public RemoveDir() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem[] Directories { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] RemovedDirectories { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] RemovedDirectories { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public partial class RemoveDuplicates : Microsoft.Build.Tasks.TaskExtension
@@ -577,29 +577,29 @@ public ResolveAssemblyReference() { }
     public sealed partial class ResolveCodeAnalysisRuleSet : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveCodeAnalysisRuleSet() { }
-        public string CodeAnalysisRuleSet { get { throw null; } set { } }
-        public string[] CodeAnalysisRuleSetDirectories { get { throw null; } set { } }
-        public string MSBuildProjectDirectory { get { throw null; } set { } }
+        public string CodeAnalysisRuleSet { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string[] CodeAnalysisRuleSetDirectories { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string MSBuildProjectDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedCodeAnalysisRuleSet { get { throw null; } }
+        public string ResolvedCodeAnalysisRuleSet { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public override bool Execute() { throw null; }
     }
     public partial class ResolveKeySource : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveKeySource() { }
-        public int AutoClosePasswordPromptShow { get { throw null; } set { } }
-        public int AutoClosePasswordPromptTimeout { get { throw null; } set { } }
-        public string CertificateFile { get { throw null; } set { } }
-        public string CertificateThumbprint { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
+        public int AutoClosePasswordPromptShow { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public int AutoClosePasswordPromptTimeout { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string CertificateFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string CertificateThumbprint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public string KeyFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedKeyContainer { get { throw null; } set { } }
+        public string ResolvedKeyContainer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedKeyFile { get { throw null; } set { } }
+        public string ResolvedKeyFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedThumbprint { get { throw null; } set { } }
-        public bool ShowImportDialogDespitePreviousFailures { get { throw null; } set { } }
-        public bool SuppressAutoClosePasswordPrompt { get { throw null; } set { } }
+        public string ResolvedThumbprint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool ShowImportDialogDespitePreviousFailures { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
+        public bool SuppressAutoClosePasswordPrompt { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public override bool Execute() { throw null; }
     }
     public abstract partial class ResolveProjectBase : Microsoft.Build.Tasks.TaskExtension
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 38f168a75ab..6b702579d37 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -5,39 +5,27 @@
 
 using System;
 using System.Collections;
-using System.Runtime.InteropServices;
-using System.Runtime.InteropServices.ComTypes;
 using System.Collections.Generic;
 
-
 // TYPELIBATTR clashes with the one in InteropServices.
 using TYPELIBATTR = System.Runtime.InteropServices.ComTypes.TYPELIBATTR;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Shared;
 using Xunit;
 using ItemMetadataNames = Microsoft.Build.Tasks.ItemMetadataNames;
 
 namespace Microsoft.Build.UnitTests
 {
-    /*
-     * Class:   ResolveComReference_Tests
-     *
-     * Test the ResolveComReference task in various ways.
-     *
-     */
     sealed public class ResolveComReference_Tests
     {
-        /*
-         * Method:  SetupTaskItem
-         * 
-         * Creates a valid task item that's modified later
-         */
+        /// <summary>
+        /// Creates a valid task item that's modified later
+        /// </summary>
         private TaskItem SetupTaskItem()
         {
-            TaskItem item = new TaskItem();
+            var item = new TaskItem();
 
             item.SetMetadata(ComReferenceItemMetadataNames.guid, "{5C6D0C4D-D530-4B08-B22F-307CA6BFCB65}");
             item.SetMetadata(ComReferenceItemMetadataNames.versionMajor, "1");
@@ -192,7 +180,7 @@ public void CheckComReferenceMetadataInitializationForFileItems()
         /// </summary>
         private TaskItem CreateComReferenceTaskItem(string itemSpec, string guid, string vMajor, string vMinor, string lcid, string wrapperType, string embedInteropTypes)
         {
-            TaskItem item = new TaskItem(itemSpec);
+            var item = new TaskItem(itemSpec);
 
             item.SetMetadata(ComReferenceItemMetadataNames.guid, guid);
             item.SetMetadata(ComReferenceItemMetadataNames.versionMajor, vMajor);
@@ -236,7 +224,7 @@ public void CheckTaskItemToTypeLibAttr()
         /// </summary>
         private ComReferenceInfo CreateComReferenceInfo(ITaskItem taskItem, string typeLibName, string typeLibPath)
         {
-            ComReferenceInfo referenceInfo = new ComReferenceInfo();
+            var referenceInfo = new ComReferenceInfo();
 
             referenceInfo.taskItem = taskItem;
             referenceInfo.attr = ResolveComReference.TaskItemToTypeLibAttr(taskItem);
@@ -295,7 +283,7 @@ public void CheckIsExistingProjectReference()
             CreateTestReferences(out axRefInfo, out tlbRefInfo, out piaRefInfo,
                 out axAttr, out tlbAttr, out piaAttr, out notInProjectAttr);
 
-            ResolveComReference rcr = new ResolveComReference();
+            var rcr = new ResolveComReference();
 
             // populate the ResolveComReference's list of project references
             rcr.allProjectRefs = new List<ComReferenceInfo>();
@@ -303,10 +291,8 @@ public void CheckIsExistingProjectReference()
             rcr.allProjectRefs.Add(tlbRefInfo);
             rcr.allProjectRefs.Add(piaRefInfo);
 
-            ComReferenceInfo referenceInfo;
-
             // find the Ax ref, matching with any type of reference - should NOT find it
-            bool retValue = rcr.IsExistingProjectReference(axAttr, null, out referenceInfo);
+            bool retValue = rcr.IsExistingProjectReference(axAttr, null, out ComReferenceInfo referenceInfo);
             Assert.True(retValue == false && referenceInfo == null); // "ActiveX ref should NOT be found for any type of ref"
 
             // find the Ax ref, matching with aximp types - should find it
@@ -343,7 +329,6 @@ public void CheckIsExistingProjectReference()
             retValue = rcr.IsExistingProjectReference(piaAttr, ComReferenceTypes.aximp, out referenceInfo);
             Assert.True(retValue == false && referenceInfo == null); // "Pia ref should NOT be found for aximp ref types"
 
-
             // try to find a non existing reference
             retValue = rcr.IsExistingProjectReference(notInProjectAttr, null, out referenceInfo);
             Assert.True(retValue == false && referenceInfo == null); // "not in project ref should not be found"
@@ -361,7 +346,7 @@ public void CheckIsExistingDependencyReference()
             CreateTestReferences(out axRefInfo, out tlbRefInfo, out piaRefInfo,
                 out axAttr, out tlbAttr, out piaAttr, out notInProjectAttr);
 
-            ResolveComReference rcr = new ResolveComReference();
+            var rcr = new ResolveComReference();
 
             // populate the ResolveComReference's list of project references
             rcr.allDependencyRefs = new List<ComReferenceInfo>();
@@ -369,10 +354,8 @@ public void CheckIsExistingDependencyReference()
             rcr.allDependencyRefs.Add(tlbRefInfo);
             rcr.allDependencyRefs.Add(piaRefInfo);
 
-            ComReferenceInfo referenceInfo;
-
             // find the Ax ref - should find it
-            bool retValue = rcr.IsExistingDependencyReference(axAttr, out referenceInfo);
+            bool retValue = rcr.IsExistingDependencyReference(axAttr, out ComReferenceInfo referenceInfo);
             Assert.True(retValue == true && referenceInfo == axRefInfo); // "ActiveX ref should be found"
 
             // find the Tlb ref - should find it
@@ -407,7 +390,7 @@ public void CheckAddMissingTlbReference()
             CreateTestReferences(out axRefInfo, out tlbRefInfo, out piaRefInfo,
                 out axAttr, out tlbAttr, out piaAttr, out notInProjectAttr);
 
-            ResolveComReference rcr = new ResolveComReference();
+            var rcr = new ResolveComReference();
             rcr.BuildEngine = new MockEngine();
 
             // populate the ResolveComReference's list of project references
@@ -436,8 +419,8 @@ public void CheckAddMissingTlbReference()
         [Fact]
         public void BothKeyFileAndKeyContainer()
         {
-            ResolveComReference rcr = new ResolveComReference();
-            MockEngine e = new MockEngine();
+            var rcr = new ResolveComReference();
+            var e = new MockEngine();
             rcr.BuildEngine = e;
 
             rcr.KeyFile = "foo";
@@ -451,8 +434,8 @@ public void BothKeyFileAndKeyContainer()
         [Fact]
         public void DelaySignWithoutEitherKeyFileOrKeyContainer()
         {
-            ResolveComReference rcr = new ResolveComReference();
-            MockEngine e = new MockEngine();
+            var rcr = new ResolveComReference();
+            var e = new MockEngine();
             rcr.BuildEngine = e;
 
             rcr.DelaySign = true;
@@ -486,27 +469,27 @@ public void CheckSetCopyLocalToFalseOnEmbedInteropTypesAssemblies()
             {
                 string fxVersion = fxVersions[i];
 
-                ArrayList taskItems = new ArrayList();
+                var taskItems = new List<ITaskItem>();
 
-                TaskItem nonGacNoPrivate = new TaskItem(@"C:\windows\gar\test1.dll");
+                var nonGacNoPrivate = new TaskItem(@"C:\windows\gar\test1.dll");
                 nonGacNoPrivate.SetMetadata(ItemMetadataNames.embedInteropTypes, "true");
 
-                TaskItem gacNoPrivate = new TaskItem(@"C:\windows\gac\assembly1.dll");
+                var gacNoPrivate = new TaskItem(@"C:\windows\gac\assembly1.dll");
                 gacNoPrivate.SetMetadata(ItemMetadataNames.embedInteropTypes, "true");
 
-                TaskItem nonGacPrivateFalse = new TaskItem(@"C:\windows\gar\test1.dll");
+                var nonGacPrivateFalse = new TaskItem(@"C:\windows\gar\test1.dll");
                 nonGacPrivateFalse.SetMetadata(ItemMetadataNames.privateMetadata, "false");
                 nonGacPrivateFalse.SetMetadata(ItemMetadataNames.embedInteropTypes, "true");
 
-                TaskItem gacPrivateFalse = new TaskItem(@"C:\windows\gac\assembly1.dll");
+                var gacPrivateFalse = new TaskItem(@"C:\windows\gac\assembly1.dll");
                 gacPrivateFalse.SetMetadata(ItemMetadataNames.privateMetadata, "false");
                 gacPrivateFalse.SetMetadata(ItemMetadataNames.embedInteropTypes, "true");
 
-                TaskItem nonGacPrivateTrue = new TaskItem(@"C:\windows\gar\test1.dll");
+                var nonGacPrivateTrue = new TaskItem(@"C:\windows\gar\test1.dll");
                 nonGacPrivateTrue.SetMetadata(ItemMetadataNames.privateMetadata, "true");
                 nonGacPrivateTrue.SetMetadata(ItemMetadataNames.embedInteropTypes, "true");
 
-                TaskItem gacPrivateTrue = new TaskItem(@"C:\windows\gac\assembly1.dll");
+                var gacPrivateTrue = new TaskItem(@"C:\windows\gac\assembly1.dll");
                 gacPrivateTrue.SetMetadata(ItemMetadataNames.privateMetadata, "true");
                 gacPrivateTrue.SetMetadata(ItemMetadataNames.embedInteropTypes, "true");
 
@@ -559,10 +542,10 @@ public void CheckSetCopyLocalToFalseOnGacAssemblies()
         {
             string gacPath = @"C:\windows\gac";
 
-            ResolveComReference rcr = new ResolveComReference();
+            var rcr = new ResolveComReference();
             rcr.BuildEngine = new MockEngine();
 
-            ArrayList taskItems = new ArrayList();
+            var taskItems = new List<ITaskItem>();
             TaskItem nonGacNoPrivate = new TaskItem(@"C:\windows\gar\test1.dll");
             TaskItem gacNoPrivate = new TaskItem(@"C:\windows\gac\assembly1.dll");
 
@@ -614,7 +597,7 @@ public void TestCheckForConflictingReferences()
             CreateTestReferences(out axRefInfo, out tlbRefInfo, out piaRefInfo,
                 out axAttr, out tlbAttr, out piaAttr, out notInProjectAttr);
 
-            ResolveComReference rcr = new ResolveComReference();
+            var rcr = new ResolveComReference();
             rcr.BuildEngine = new MockEngine();
 
             // populate the ResolveComReference's list of project references
@@ -642,13 +625,13 @@ public void TestCheckForConflictingReferences()
 
             // tlb and ax refs with same lib name but different attributes should be considered conflicting
             // We don't care about typelib name conflicts for PIA refs, because we don't have to create wrappers for them
-            ComReferenceInfo conflictTlb = new ComReferenceInfo(tlbRefInfo);
+            var conflictTlb = new ComReferenceInfo(tlbRefInfo);
             conflictTlb.attr = notInProjectAttr;
             rcr.allProjectRefs.Add(conflictTlb);
-            ComReferenceInfo conflictAx = new ComReferenceInfo(axRefInfo);
+            var conflictAx = new ComReferenceInfo(axRefInfo);
             conflictAx.attr = notInProjectAttr;
             rcr.allProjectRefs.Add(conflictAx);
-            ComReferenceInfo piaRef = new ComReferenceInfo(piaRefInfo);
+            var piaRef = new ComReferenceInfo(piaRefInfo);
             piaRef.attr = notInProjectAttr;
             rcr.allProjectRefs.Add(piaRef);
 
@@ -757,10 +740,9 @@ private void CheckAxReferenceRCWTlbExists(RcwStyle rcwStyle, bool includeVersion
             Guid axGuid = Guid.NewGuid();
             ComReferenceInfo tlbRefInfo;
 
-            ResolveComReference rcr = new ResolveComReference();
+            var rcr = new ResolveComReference();
             rcr.BuildEngine = new MockEngine();
             rcr.IncludeVersionInInteropName = includeVersionInInteropName;
-
             rcr.allProjectRefs = new List<ComReferenceInfo>();
 
             TaskItem axTaskItem = CreateComReferenceTaskItem("ref", axGuid.ToString(), "1", "2", "1033", ComReferenceTypes.aximp);
@@ -790,7 +772,7 @@ private void CheckAxReferenceRCWTlbExists(RcwStyle rcwStyle, bool includeVersion
 
             Assert.Equal(2, rcr.allProjectRefs.Count); // "Should be two references"
 
-            tlbRefInfo = (ComReferenceInfo)rcr.allProjectRefs[1];
+            tlbRefInfo = rcr.allProjectRefs[1];
             var embedInteropTypes = tlbRefInfo.taskItem.GetMetadata(ItemMetadataNames.embedInteropTypes);
             Assert.Equal("false", embedInteropTypes); // "The tlb wrapper for the activex control should have EmbedInteropTypes=false not " + embedInteropTypes);
             Assert.True(ComReference.AreTypeLibAttrEqual(tlbRefInfo.attr, axRefInfo.attr)); // "reference information should be the same"
diff --git a/src/Tasks/Dependencies.cs b/src/Tasks/Dependencies.cs
index 9a8bba67432..650458721ff 100644
--- a/src/Tasks/Dependencies.cs
+++ b/src/Tasks/Dependencies.cs
@@ -9,7 +9,8 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// Represents a cache of inputs to a compilation-style task.
     /// </remarks>
-    [Serializable()]
+    /// <remarks>On-disk serialization format, don't change field names or types or use readonly.</remarks>
+    [Serializable]
     internal class Dependencies
     {
         /// <summary>
@@ -32,8 +33,6 @@ internal DependencyFile GetDependencyFile(string filename)
         /// <summary>
         /// Add a new dependency file.
         /// </summary>
-        /// <param name="filename"></param>
-        /// <returns></returns>
         internal void AddDependencyFile(string filename, DependencyFile file)
         {
             dependencies[filename] = file;
@@ -57,4 +56,4 @@ internal void Clear()
             dependencies.Clear();
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/RCWForCurrentContext.cs b/src/Tasks/RCWForCurrentContext.cs
index c1b4ddcb082..185e03f8dd4 100644
--- a/src/Tasks/RCWForCurrentContext.cs
+++ b/src/Tasks/RCWForCurrentContext.cs
@@ -27,7 +27,7 @@ internal class RCWForCurrentContext<T> : IDisposable where T : class
         /// <summary>
         /// Indicates if we created the RCW and therefore need to release it's com reference.
         /// </summary>
-        private bool _shouldReleaseRCW;
+        private readonly bool _shouldReleaseRCW;
 
         /// <summary>
         /// Constructor creates the new RCW in the current context.
@@ -39,7 +39,7 @@ public RCWForCurrentContext(T rcw)
             // the caching behaviour of the marshaled pointer. 
             // See RCW::GetComIPForMethodTableFromCache in ndp\clr\src\VM\RuntimeCallableWrapper.cpp
             IntPtr iunknownPtr = Marshal.GetIUnknownForObject(rcw);
-            Object objInCurrentCtx = null;
+            Object objInCurrentCtx;
 
             try
             {
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 886da937e79..514e79b0432 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -3,24 +3,20 @@
 
 using System;
 using System.Collections;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Text;
 using System.Xml;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Collections.Concurrent;
-using System.Collections.ObjectModel;
-using System.Linq;
 
 namespace Microsoft.Build.Tasks
 {
-    /*
-     * Class:   RedistList
-     *
-     */
     /// <summary>
     /// Defines list of redistributable assemblies for use in dependency analysis.
     /// The input is a set of XML files in a well known format consisting of
@@ -36,7 +32,8 @@ namespace Microsoft.Build.Tasks
     internal sealed class RedistList
     {
         // List of cached RedistList objects, the key is a semi-colon delimited list of data file paths
-        private readonly static Hashtable s_cachedRedistList = new Hashtable(StringComparer.OrdinalIgnoreCase);
+        private static readonly Dictionary<string, RedistList> s_cachedRedistList = new Dictionary<string, RedistList>(StringComparer.OrdinalIgnoreCase);
+
         // Process wide cache of redist lists found on disk under fx directories.
         // K: target framework directory, V: redist lists found on disk underneath K
         private static Dictionary<string, string[]> s_redistListPathCache;
@@ -48,33 +45,32 @@ internal sealed class RedistList
         /// When we check to see if an assembly is in this redist list we want to cache it so that if we ask again we do not
         /// have to re-scan bits of the redist list and do the assemblynameExtension comparisons.
         /// </summary>
-        private ConcurrentDictionary<AssemblyNameExtension, NGen<bool>> _assemblyNameInRedist = new ConcurrentDictionary<AssemblyNameExtension, NGen<bool>>(AssemblyNameComparer.GenericComparer);
+        private readonly ConcurrentDictionary<AssemblyNameExtension, NGen<bool>> _assemblyNameInRedist = new ConcurrentDictionary<AssemblyNameExtension, NGen<bool>>(AssemblyNameComparer.GenericComparer);
 
         /// <summary>
         /// AssemblyName to unified assemblyName. We make this kind of call a lot and also will ask for the same name multiple times.
         /// </summary>
-        private ConcurrentDictionary<string, AssemblyEntry> _assemblyNameToUnifiedAssemblyName = new ConcurrentDictionary<string, AssemblyEntry>(StringComparer.OrdinalIgnoreCase);
+        private readonly ConcurrentDictionary<string, AssemblyEntry> _assemblyNameToUnifiedAssemblyName = new ConcurrentDictionary<string, AssemblyEntry>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// AssemblyName to AssemblyNameExtension object. We make this kind of call a lot and also will ask for the same name multiple times.
         /// </summary>
-        private ConcurrentDictionary<string, AssemblyNameExtension> _assemblyNameToAssemblyNameExtension = new ConcurrentDictionary<string, AssemblyNameExtension>(StringComparer.OrdinalIgnoreCase);
+        private readonly ConcurrentDictionary<string, AssemblyNameExtension> _assemblyNameToAssemblyNameExtension = new ConcurrentDictionary<string, AssemblyNameExtension>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// When we check to see if an assembly is remapped we should cache the result because we may get asked the same question a number of times.
         /// Since the remapping list does not change between builds neither would the results of the remapping for a given fusion name.
         /// </summary>
-        private ConcurrentDictionary<AssemblyNameExtension, AssemblyNameExtension> _remappingCache = new ConcurrentDictionary<AssemblyNameExtension, AssemblyNameExtension>(AssemblyNameComparer.GenericComparerConsiderRetargetable);
+        private readonly ConcurrentDictionary<AssemblyNameExtension, AssemblyNameExtension> _remappingCache = new ConcurrentDictionary<AssemblyNameExtension, AssemblyNameExtension>(AssemblyNameComparer.GenericComparerConsiderRetargetable);
 
         // List of cached BlackList RedistList objects, the key is a semi-colon delimited list of data file paths
-        private ConcurrentDictionary<string, Hashtable> _cachedBlackList = new ConcurrentDictionary<string, Hashtable>(StringComparer.OrdinalIgnoreCase);
-
-
+        private readonly ConcurrentDictionary<string, Hashtable> _cachedBlackList = new ConcurrentDictionary<string, Hashtable>(StringComparer.OrdinalIgnoreCase);
+        
         /***************Fields which are only set in the constructor and should not be modified by the class. **********************/
         // Array of errors encountered while reading files.
-        private ReadOnlyCollection<Exception> _errors;
+        private readonly ReadOnlyCollection<Exception> _errors;
         // Array of files corresponding to the errors above.
-        private ReadOnlyCollection<String> _errorFilenames;
+        private readonly ReadOnlyCollection<String> _errorFilenames;
 
         // List of assembly entries loaded from the XML data files, one entry for each valid File element
         private readonly ReadOnlyCollection<AssemblyEntry> _assemblyList;
@@ -91,12 +87,12 @@ internal sealed class RedistList
 
         private RedistList(AssemblyTableInfo[] assemblyTableInfos)
         {
-            List<Exception> errors = new List<Exception>();
-            List<string> errorFilenames = new List<string>();
-            List<AssemblyEntry> assemblyList = new List<AssemblyEntry>();
-            List<AssemblyRemapping> remappingEntries = new List<AssemblyRemapping>();
+            var errors = new List<Exception>();
+            var errorFilenames = new List<string>();
+            var assemblyList = new List<AssemblyEntry>();
+            var remappingEntries = new List<AssemblyRemapping>();
 
-            if (assemblyTableInfos == null) throw new ArgumentNullException("assemblyTableInfos");
+            if (assemblyTableInfos == null) throw new ArgumentNullException(nameof(assemblyTableInfos));
             foreach (AssemblyTableInfo assemblyTableInfo in assemblyTableInfos)
             {
                 ReadFile(assemblyTableInfo, assemblyList, errors, errorFilenames, remappingEntries);
@@ -110,12 +106,14 @@ private RedistList(AssemblyTableInfo[] assemblyTableInfos)
             assemblyList.Sort(s_sortByVersionDescending);
             _assemblyList = new ReadOnlyCollection<AssemblyEntry>(assemblyList);
 
-            Dictionary<string, int> simpleNameMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
+            var simpleNameMap = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
             for (int i = 0; i < assemblyList.Count; ++i)
             {
                 AssemblyEntry entry = assemblyList[i];
                 if (!simpleNameMap.ContainsKey(entry.SimpleName))
+                {
                     simpleNameMap.Add(entry.SimpleName, i);
+                }
             }
 
             _simpleNameMap = new ReadOnlyDictionary<string, int>(simpleNameMap);
@@ -124,36 +122,17 @@ private RedistList(AssemblyTableInfo[] assemblyTableInfos)
         /// <summary>
         /// Returns any exceptions encountered while reading\parsing the XML.
         /// </summary>
-        internal Exception[] Errors
-        {
-            get
-            {
-                return _errors.ToArray();
-            }
-        }
+        internal Exception[] Errors => _errors.ToArray();
 
         /// <summary>
         /// Returns any exceptions encountered while reading\parsing the XML.
         /// </summary>
-        internal string[] ErrorFileNames
-        {
-            get
-            {
-                return _errorFilenames.ToArray();
-            }
-        }
-
+        internal string[] ErrorFileNames => _errorFilenames.ToArray();
 
         /// <summary>
         /// Returns the number of entries in the redist list
         /// </summary>
-        internal int Count
-        {
-            get
-            {
-                return _assemblyList.Count;
-            }
-        }
+        internal int Count => _assemblyList.Count;
 
         /// <summary>
         /// Determines whether or not the specified assembly is part of the Framework.
@@ -163,17 +142,18 @@ internal int Count
         public bool IsFrameworkAssembly(string assemblyName)
         {
             AssemblyEntry entry = GetUnifiedAssemblyEntry(assemblyName);
-            if (entry != null && !String.IsNullOrEmpty(entry.RedistName)){
+            if (!String.IsNullOrEmpty(entry?.RedistName))
+            {
                 AssemblyNameExtension assembly = GetAssemblyNameExtension(assemblyName);
 
                 // The version of the checking assembly should be lower than the one of the unified assembly
-                if(assembly.Version <= entry.AssemblyNameExtension.Version)
+                if (assembly.Version <= entry.AssemblyNameExtension.Version)
+                {
                     return entry.RedistName.StartsWith("Microsoft-Windows-CLRCoreComp", StringComparison.OrdinalIgnoreCase);
-                else
-                    return false;
-            }
-            else
+                }
                 return false;
+            }
+            return false;
         }
 
         /// <summary>
@@ -184,10 +164,7 @@ public bool IsFrameworkAssembly(string assemblyName)
         public bool IsPrerequisiteAssembly(string assemblyName)
         {
             AssemblyEntry entry = GetUnifiedAssemblyEntry(assemblyName);
-            if (entry != null)
-                return entry.InGAC;
-            else
-                return false;
+            return entry != null && entry.InGAC;
         }
 
         /// <summary>
@@ -196,9 +173,7 @@ public bool IsPrerequisiteAssembly(string assemblyName)
         /// </summary>
         public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRemap)
         {
-            AssemblyNameExtension remappedExtension = null;
-
-            if (!_remappingCache.TryGetValue(extensionToRemap, out remappedExtension))
+            if (!_remappingCache.TryGetValue(extensionToRemap, out AssemblyNameExtension remappedExtension))
             {
                 // We do not expect there to be more than a handfull of entries
                 foreach (AssemblyRemapping remapEntry in _remapEntries)
@@ -213,24 +188,16 @@ public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRema
             }
 
             // Important to clone since we tend to mutate assemblyNameExtensions in RAR
-            return remappedExtension != null ? remappedExtension.Clone() : null;
+            return remappedExtension?.Clone();
         }
 
-
         /// <summary>
         /// Determines whether or not the specified assembly is a redist root.
         /// </summary>
         internal bool? IsRedistRoot(string assemblyName)
         {
             AssemblyEntry entry = GetUnifiedAssemblyEntry(assemblyName);
-            if (entry != null)
-            {
-                return entry.IsRedistRoot;
-            }
-            else
-            {
-                return null;
-            }
+            return entry?.IsRedistRoot;
         }
 
         /// <summary>
@@ -247,8 +214,7 @@ public static RedistList GetFrameworkList20()
                 redistListPaths = RedistList.GetRedistListPathsFromDisk(frameworkVersion20Path);
             }
 
-            AssemblyTableInfo[] assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
-
+            var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
             {
                 assemblyTableInfos[i] = new AssemblyTableInfo(redistListPaths[i], frameworkVersion20Path);
@@ -257,7 +223,6 @@ public static RedistList GetFrameworkList20()
             return GetRedistList(assemblyTableInfos);
         }
 
-
         /// <summary>
         /// Returns an instance of RedistList initialized from the framework folder for v3.0
         /// This function returns a statically cached object, so all calls will return the
@@ -281,14 +246,11 @@ public static RedistList GetFrameworkList35()
         /// <summary>
         /// This is owned by chris mann
         /// </summary>
-        /// <param name="path"></param>
-        /// <returns></returns>
         public static RedistList GetRedistListFromPath(string path)
         {
-            string[] redistListPaths = (path == null) ? Array.Empty<string>(): RedistList.GetRedistListPathsFromDisk(path);
-
-            AssemblyTableInfo[] assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
+            string[] redistListPaths = (path == null) ? Array.Empty<string>(): GetRedistListPathsFromDisk(path);
 
+            var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
             {
                 assemblyTableInfos[i] = new AssemblyTableInfo(redistListPaths[i], path);
@@ -303,10 +265,9 @@ private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotN
 
             // On dogfood build machines, v3.5 is not formally installed, so this returns null.
             // We don't use redist lists in this case.            
-            string[] redistListPaths = (referenceAssembliesPath == null) ? Array.Empty<string>(): RedistList.GetRedistListPathsFromDisk(referenceAssembliesPath);
-
-            AssemblyTableInfo[] assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
+            string[] redistListPaths = (referenceAssembliesPath == null) ? Array.Empty<string>(): GetRedistListPathsFromDisk(referenceAssembliesPath);
 
+            var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
             {
                 assemblyTableInfos[i] = new AssemblyTableInfo(redistListPaths[i], referenceAssembliesPath);
@@ -320,11 +281,10 @@ private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotN
         /// redist list files underneath that path.  A process-wide cache is used to
         /// avoid hitting the disk multiple times for the same framework directory.
         /// </summary>
-        /// <param name="frameworkDirectory"></param>
         /// <returns>Array of paths to redist lists under given framework directory.</returns>
         public static string[] GetRedistListPathsFromDisk(string frameworkDirectory)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(frameworkDirectory, "frameworkDirectory");
+            ErrorUtilities.VerifyThrowArgumentNull(frameworkDirectory, nameof(frameworkDirectory));
 
             lock (s_locker)
             {
@@ -333,21 +293,20 @@ public static string[] GetRedistListPathsFromDisk(string frameworkDirectory)
                     s_redistListPathCache = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
                 }
 
-                if (!s_redistListPathCache.ContainsKey(frameworkDirectory))
+                if (!s_redistListPathCache.TryGetValue(frameworkDirectory, out string[] results))
                 {
                     string redistDirectory = Path.Combine(frameworkDirectory, RedistListFolder);
 
                     if (Directory.Exists(redistDirectory))
                     {
-                        string[] results = Directory.GetFiles(redistDirectory, MatchPattern);
+                        results = Directory.GetFiles(redistDirectory, MatchPattern);
                         s_redistListPathCache.Add(frameworkDirectory, results);
-
-                        return s_redistListPathCache[frameworkDirectory];
+                        return results;
                     }
                 }
                 else
                 {
-                    return s_redistListPathCache[frameworkDirectory];
+                    return results;
                 }
             }
 
@@ -357,19 +316,10 @@ public static string[] GetRedistListPathsFromDisk(string frameworkDirectory)
         /// <summary>
         /// The name of this redist.
         /// </summary>
-        /// <param name="assemblyName"></param>
-        /// <returns></returns>
         internal string RedistName(string assemblyName)
         {
             AssemblyEntry entry = GetUnifiedAssemblyEntry(assemblyName);
-            if (entry != null)
-            {
-                return entry.RedistName;
-            }
-            else
-            {
-                return null;
-            }
+            return entry?.RedistName;
         }
 
         /// <summary>
@@ -379,10 +329,10 @@ internal string RedistName(string assemblyName)
         /// </summary>
         public static RedistList GetRedistList(AssemblyTableInfo[] assemblyTables)
         {
-            if (assemblyTables == null) throw new ArgumentNullException("assemblyTables");
+            if (assemblyTables == null) throw new ArgumentNullException(nameof(assemblyTables));
             Array.Sort(assemblyTables);
 
-            StringBuilder keyBuilder = assemblyTables.Length > 0 ? new StringBuilder(assemblyTables[0].Descriptor) : new StringBuilder();
+            var keyBuilder = assemblyTables.Length > 0 ? new StringBuilder(assemblyTables[0].Descriptor) : new StringBuilder();
             for (int i = 1; i < assemblyTables.Length; ++i)
             {
                 keyBuilder.Append(';');
@@ -392,40 +342,41 @@ public static RedistList GetRedistList(AssemblyTableInfo[] assemblyTables)
             string key = keyBuilder.ToString();
             lock (s_locker)
             {
-                if (s_cachedRedistList.ContainsKey(key))
-                    return (RedistList)s_cachedRedistList[key];
+                if (s_cachedRedistList.TryGetValue(key, out RedistList redistList))
+                {
+                    return redistList;
+                }
 
-                RedistList redistList = new RedistList(assemblyTables);
+                redistList = new RedistList(assemblyTables);
                 s_cachedRedistList.Add(key, redistList);
-
                 return redistList;
             }
         }
 
         private static string GetSimpleName(string assemblyName)
         {
-            if (assemblyName == null) throw new ArgumentNullException("assemblyName");
+            if (assemblyName == null) throw new ArgumentNullException(nameof(assemblyName));
             int i = assemblyName.IndexOf(",", StringComparison.Ordinal);
             return i > 0 ? assemblyName.Substring(0, i) : assemblyName;
         }
 
         private AssemblyEntry GetUnifiedAssemblyEntry(string assemblyName)
         {
-            if (assemblyName == null) throw new ArgumentNullException("assemblyName");
-            AssemblyEntry unifiedEntry = null;
-            if (!_assemblyNameToUnifiedAssemblyName.TryGetValue(assemblyName, out unifiedEntry))
+            if (assemblyName == null) throw new ArgumentNullException(nameof(assemblyName));
+            if (!_assemblyNameToUnifiedAssemblyName.TryGetValue(assemblyName, out AssemblyEntry unifiedEntry))
             {
                 string simpleName = GetSimpleName(assemblyName);
-                if (_simpleNameMap.ContainsKey(simpleName))
+                if (_simpleNameMap.TryGetValue(simpleName, out int index))
                 {
                     // Provides the starting index into assemblyList of the simpleName
-                    int index = (int)_simpleNameMap[simpleName];
-                    AssemblyNameExtension highestVersionInRedist = new AssemblyNameExtension(_assemblyList[index].FullName);
+                    var highestVersionInRedist = new AssemblyNameExtension(_assemblyList[index].FullName);
                     for (int i = index; i < _assemblyList.Count; ++i)
                     {
                         AssemblyEntry entry = _assemblyList[i];
                         if (!string.Equals(simpleName, entry.SimpleName, StringComparison.OrdinalIgnoreCase))
+                        {
                             break;
+                        }
 
                         AssemblyNameExtension firstAssembly = GetAssemblyNameExtension(assemblyName);
                         AssemblyNameExtension secondAssembly = entry.AssemblyNameExtension;
@@ -450,7 +401,7 @@ private AssemblyEntry GetUnifiedAssemblyEntry(string assemblyName)
 
         private AssemblyNameExtension GetAssemblyNameExtension(string assemblyName)
         {
-            return _assemblyNameToAssemblyNameExtension.GetOrAdd(assemblyName, (key) => new AssemblyNameExtension(key));
+            return _assemblyNameToAssemblyNameExtension.GetOrAdd(assemblyName, key => new AssemblyNameExtension(key));
         }
 
         /// <summary>
@@ -458,16 +409,14 @@ private AssemblyNameExtension GetAssemblyNameExtension(string assemblyName)
         /// </summary>
         public bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(assemblyName, "assemblyName");
+            ErrorUtilities.VerifyThrowArgumentNull(assemblyName, nameof(assemblyName));
 
-            NGen<bool> isAssemblyNameInRedist = false;
-            if (!_assemblyNameInRedist.TryGetValue(assemblyName, out isAssemblyNameInRedist))
+            if (!_assemblyNameInRedist.TryGetValue(assemblyName, out NGen<bool> isAssemblyNameInRedist))
             {
                 string simpleName = GetSimpleName(assemblyName.Name);
-                if (_simpleNameMap.ContainsKey(simpleName))
+                if (_simpleNameMap.TryGetValue(simpleName, out int index))
                 {
                     // Provides the starting index into assemblyList of the simpleName
-                    int index = (int)_simpleNameMap[simpleName];
                     for (int i = index; i < _assemblyList.Count; ++i)
                     {
                         AssemblyEntry entry = _assemblyList[i];
@@ -507,10 +456,7 @@ public bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName)
         public string GetUnifiedAssemblyName(string assemblyName)
         {
             AssemblyEntry entry = GetUnifiedAssemblyEntry(assemblyName);
-            if (entry != null)
-                return entry.FullName;
-            else
-                return assemblyName;
+            return entry != null ? entry.FullName : assemblyName;
         }
 
         /// <summary>
@@ -523,11 +469,10 @@ internal AssemblyEntry[] FindAssemblyNameFromSimpleName
             string simpleName
         )
         {
-            List<AssemblyEntry> candidateNames = new List<AssemblyEntry>();
+            var candidateNames = new List<AssemblyEntry>();
 
-            if (_simpleNameMap.ContainsKey(simpleName))
+            if (_simpleNameMap.TryGetValue(simpleName, out int index))
             {
-                int index = (int)_simpleNameMap[simpleName];
                 for (int i = index; i < _assemblyList.Count; ++i)
                 {
                     AssemblyEntry entry = _assemblyList[i];
@@ -572,7 +517,7 @@ internal Hashtable GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableI
             // Sort so that the same set of whiteListAssemblyTableInfo will generate the same key for the cache
             Array.Sort(whiteListAssemblyTableInfo);
 
-            StringBuilder keyBuilder = whiteListAssemblyTableInfo.Length > 0 ? new StringBuilder(whiteListAssemblyTableInfo[0].Descriptor) : new StringBuilder();
+            var keyBuilder = whiteListAssemblyTableInfo.Length > 0 ? new StringBuilder(whiteListAssemblyTableInfo[0].Descriptor) : new StringBuilder();
 
             // Concatenate the paths to the whitelist xml files together to get the key into the blacklist cache.
             for (int i = 1; i < whiteListAssemblyTableInfo.Length; ++i)
@@ -583,19 +528,17 @@ internal Hashtable GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableI
 
             string key = keyBuilder.ToString();
 
-            Hashtable returnTable = null;
-
-            if (!_cachedBlackList.TryGetValue(key, out returnTable))
+            if (!_cachedBlackList.TryGetValue(key, out Hashtable returnTable))
             {
-                List<AssemblyEntry> whiteListAssemblies = new List<AssemblyEntry>();
+                var whiteListAssemblies = new List<AssemblyEntry>();
 
                 // Unique list of redist names in the subset files read in. We use this to make sure we are subtracting from the correct framework list.
-                Hashtable uniqueClientListNames = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                var uniqueClientListNames = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
                 // Get the assembly entries for the white list
                 foreach (AssemblyTableInfo info in whiteListAssemblyTableInfo)
                 {
-                    List<AssemblyEntry> whiteListAssembliesReadIn = new List<AssemblyEntry>();
+                    var whiteListAssembliesReadIn = new List<AssemblyEntry>();
 
                     // Need to know how many errors are in the list before the read file call so that if the redist name is null due to an error
                     // we do not get a "redist name is null or empty" error when in actual fact it was a file not found error.
@@ -604,7 +547,6 @@ internal Hashtable GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableI
                     // Read in the subset list file. 
                     string redistName = ReadFile(info, whiteListAssembliesReadIn, whiteListErrors, whiteListErrorFileNames, null);
 
-
                     // Get the client subset name which has been read in.
                     if (!String.IsNullOrEmpty(redistName))
                     {
@@ -631,7 +573,7 @@ internal Hashtable GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableI
                 }
 
                 // Dont care about the case of the assembly name
-                Hashtable blackList = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                var blackList = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
                 // Do we have any subset names?
                 bool uniqueClientNamesExist = uniqueClientListNames.Count > 0;
@@ -659,15 +601,14 @@ internal Hashtable GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableI
                     }
                 }
 
-
                 // Go through each of the white list assemblies and remove it from the black list. Do this based on the assembly name and the redist name
                 foreach (AssemblyEntry whiteListEntry in whiteListAssemblies)
                 {
                     blackList.Remove(whiteListEntry.FullName + "," + whiteListEntry.RedistName);
                 }
 
-                //The output hashtable needs to be just the full names and not the names + redist name
-                Hashtable blackListOfAssemblyNames = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                // The output hashtable needs to be just the full names and not the names + redist name
+                var blackListOfAssemblyNames = new Hashtable(StringComparer.OrdinalIgnoreCase);
                 foreach (string name in blackList.Values)
                 {
                     blackListOfAssemblyNames[name] = null;
@@ -696,12 +637,11 @@ internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List<Assemb
             // Keep track of what assembly entries we have read in from the redist list, we want to track this because we need to know if there are duplicate entries
             // if there are duplicate entries one with ingac = true and one with InGac=false we want to choose the one with ingac true.
             // The reason we want to take the ingac True over ingac false is that this indicates the assembly IS in the gac.
-            Dictionary<string, AssemblyEntry> assemblyEntries = new Dictionary<string, AssemblyEntry>(StringComparer.OrdinalIgnoreCase);
+            var assemblyEntries = new Dictionary<string, AssemblyEntry>(StringComparer.OrdinalIgnoreCase);
 
             try
             {
-                var readerSettings = new XmlReaderSettings();
-                readerSettings.DtdProcessing = DtdProcessing.Ignore;
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 reader = XmlReader.Create(path, readerSettings);
 
                 while (reader.Read())
@@ -750,10 +690,7 @@ internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List<Assemb
             }
             finally
             {
-                if (reader != null)
-                {
-                    reader.Dispose();
-                }
+                reader?.Dispose();
             }
 
             foreach (AssemblyEntry entry in assemblyEntries.Values)
@@ -796,9 +733,9 @@ private static void ParseRemapSection(AssemblyTableInfo assemblyTableInfo, strin
 
                     if (fromEntry != null && toEntry != null)
                     {
-                        AssemblyRemapping pair = new AssemblyRemapping(fromEntry, toEntry);
+                        var pair = new AssemblyRemapping(fromEntry, toEntry);
 
-                        if (!mapping.Any<AssemblyRemapping>(x => x.From.Equals(pair.From)))
+                        if (!mapping.Any(x => x.From.Equals(pair.From)))
                         {
                             mapping.Add(pair);
                         }
@@ -839,10 +776,9 @@ private static void ParseFileListSection(AssemblyTableInfo assemblyTableInfo, st
                             // We do not need to add the redistName and the framework directory because this will be the same for all entries in the current redist list being read.
                             string hashIndex = String.Format(CultureInfo.InvariantCulture, "{0},{1}", newEntry.FullName, newEntry.IsRedistRoot == null ? "null" : newEntry.IsRedistRoot.ToString());
 
-                            AssemblyEntry dictionaryEntry = null;
-                            assemblyEntries.TryGetValue(hashIndex, out dictionaryEntry);
+                            assemblyEntries.TryGetValue(hashIndex, out AssemblyEntry dictionaryEntry);
                             // If the entry is not in the hashtable or the entry is in the hashtable but the new entry has the ingac flag true, make sure the hashtable contains the entry with the ingac true.
-                            if (dictionaryEntry == null || (dictionaryEntry != null && newEntry.InGAC))
+                            if (dictionaryEntry == null || newEntry.InGAC)
                             {
                                 assemblyEntries[hashIndex] = newEntry;
                             }
@@ -871,7 +807,7 @@ private static void ParseFileListSection(AssemblyTableInfo assemblyTableInfo, st
         /// </summary>
         private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableInfo, string path, string redistName, XmlReader reader, bool fullFusionNameRequired)
         {
-            Dictionary<string, string> attributes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            var attributes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
             reader.MoveToFirstAttribute();
             do
@@ -881,39 +817,23 @@ private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableIn
 
             reader.MoveToElement();
 
-            string name;
-            attributes.TryGetValue("AssemblyName", out name);
-
-            string version;
-            attributes.TryGetValue("Version", out version);
-
-            string publicKeyToken;
-            attributes.TryGetValue("PublicKeyToken", out publicKeyToken);
-
-            string culture;
-            attributes.TryGetValue("Culture", out culture);
-
-            string inGAC;
-            attributes.TryGetValue("InGAC", out inGAC);
-
-            string retargetable;
-            attributes.TryGetValue("Retargetable", out retargetable);
-
-            string isRedistRoot;
-            attributes.TryGetValue("IsRedistRoot", out isRedistRoot);
-
-            bool inGACFlag;
-            if (!bool.TryParse(inGAC, out inGACFlag))
+            attributes.TryGetValue("AssemblyName", out string name);
+            attributes.TryGetValue("Version", out string version);
+            attributes.TryGetValue("PublicKeyToken", out string publicKeyToken);
+            attributes.TryGetValue("Culture", out string culture);
+            attributes.TryGetValue("InGAC", out string inGAC);
+            attributes.TryGetValue("Retargetable", out string retargetable);
+            attributes.TryGetValue("IsRedistRoot", out string isRedistRoot);
+            if (!bool.TryParse(inGAC, out bool inGACFlag))
             {
                 inGACFlag = true;                           // true by default 
             }
-            bool retargetableFlag;
+
             // The retargetable flag is Yes or No for some reason
-            retargetableFlag = "Yes".Equals(retargetable, StringComparison.OrdinalIgnoreCase);
+            bool retargetableFlag = "Yes".Equals(retargetable, StringComparison.OrdinalIgnoreCase);
 
-            bool isRedistRootAsBoolean;
             bool? isRedistRootFlag = null;                  // null by default.
-            if (bool.TryParse(isRedistRoot, out isRedistRootAsBoolean))
+            if (bool.TryParse(isRedistRoot, out bool isRedistRootAsBoolean))
             {
                 isRedistRootFlag = isRedistRootAsBoolean;
             }
@@ -932,7 +852,7 @@ private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableIn
         }
 
         #region Comparers
-        private readonly static IComparer<AssemblyEntry> s_sortByVersionDescending = new SortByVersionDescending();
+        private static readonly IComparer<AssemblyEntry> s_sortByVersionDescending = new SortByVersionDescending();
 
         /// <summary>
         /// The redist list is a collection of AssemblyEntry. We would like to have the redist list sorted on two keys.
@@ -992,41 +912,23 @@ public int Compare(AssemblyEntry firstEntry, AssemblyEntry secondEntry)
     /// </summary>
     internal class AssemblyTableInfo : IComparable
     {
-        private readonly string _path;
-        private readonly string _frameworkDirectory;
         private string _descriptor;
 
         internal AssemblyTableInfo(string path, string frameworkDirectory)
         {
-            _path = path;
-            _frameworkDirectory = frameworkDirectory;
+            Path = path;
+            FrameworkDirectory = frameworkDirectory;
         }
 
-        internal string Path
-        {
-            get { return _path; }
-        }
+        internal string Path { get; }
 
-        internal string FrameworkDirectory
-        {
-            get { return _frameworkDirectory; }
-        }
+        internal string FrameworkDirectory { get; }
 
-        internal string Descriptor
-        {
-            get
-            {
-                if (null == _descriptor)
-                {
-                    _descriptor = _path + _frameworkDirectory;
-                }
-                return _descriptor;
-            }
-        }
+        internal string Descriptor => _descriptor ?? (_descriptor = Path + FrameworkDirectory);
 
         public int CompareTo(object obj)
         {
-            AssemblyTableInfo that = (AssemblyTableInfo)obj;
+            var that = (AssemblyTableInfo)obj;
             return String.Compare(Descriptor, that.Descriptor, StringComparison.OrdinalIgnoreCase);
         }
     }
@@ -1044,7 +946,7 @@ internal class SubsetListFinder
         private static Dictionary<string, string[]> s_subsetListPathCache;
 
         // Locl for subsetListPathCache
-        private static Object s_subsetListPathCacheLock = new Object();
+        private static readonly Object s_subsetListPathCacheLock = new Object();
 
         // Folder to look for the subset lists in under the target framework directories
         private const string subsetListFolder = "SubsetList";
@@ -1052,7 +954,7 @@ internal class SubsetListFinder
         /// <summary>
         /// The subset names to search for.
         /// </summary>
-        private string[] _subsetToSearchFor;
+        private readonly string[] _subsetToSearchFor;
 
         #endregion
 
@@ -1066,7 +968,7 @@ internal class SubsetListFinder
         /// found in the target framework directories. This can happen if the the subsets are instead passed in as InstalledDefaultSubsetTables</param>
         internal SubsetListFinder(string[] subsetToSearchFor)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(subsetToSearchFor, "subsetToSearchFor");
+            ErrorUtilities.VerifyThrowArgumentNull(subsetToSearchFor, nameof(subsetToSearchFor));
             _subsetToSearchFor = subsetToSearchFor;
         }
 
@@ -1076,13 +978,7 @@ internal SubsetListFinder(string[] subsetToSearchFor)
         /// <summary>
         ///  Folder to look for the subset lists under the target framework directories
         /// </summary>
-        public static string SubsetListFolder
-        {
-            get
-            {
-                return subsetListFolder;
-            }
-        }
+        public static string SubsetListFolder => subsetListFolder;
 
         #endregion
 
@@ -1096,7 +992,7 @@ public static string SubsetListFolder
         /// <returns>Array of paths locations to subset lists under the given framework directory.</returns>
         public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(frameworkDirectory, "frameworkDirectory");
+            ErrorUtilities.VerifyThrowArgumentNull(frameworkDirectory, nameof(frameworkDirectory));
 
             // Make sure we have some subset names to search for it is possible that no subsets are asked for
             // so we should return as quickly as possible in that case.
@@ -1111,22 +1007,19 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
                         s_subsetListPathCache = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
                     }
 
-
                     // TargetFrameworkDirectory is not unique enough because a different invocation could ask for a different 
                     // set of subset files from the same TargetFrameworkDirectory
                     string concatenatedSubsetListNames = String.Join(";", _subsetToSearchFor);
 
                     string key = frameworkDirectory + ":" + concatenatedSubsetListNames;
 
-
-                    string[] subsetLists = null;
-                    s_subsetListPathCache.TryGetValue(key, out subsetLists);
+                    s_subsetListPathCache.TryGetValue(key, out string[] subsetLists);
                     if (subsetLists == null)
                     {
                         // Get the path to the subset folder under the target framework directory
                         string subsetDirectory = Path.Combine(frameworkDirectory, subsetListFolder);
 
-                        List<string> subsetFilesForFrameworkDirectory = new List<string>();
+                        var subsetFilesForFrameworkDirectory = new List<string>();
 
                         // Go through each of the subsets and see if it is in the target framework subset directory 
                         foreach (string subsetName in _subsetToSearchFor)
@@ -1161,72 +1054,68 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
     /// </summary>
     internal class AssemblyEntry
     {
-        private readonly string _fullName;
-        private readonly bool _inGAC;
-        private readonly bool? _isRedistRoot;
-        private readonly string _redistName;
-        private readonly string _simpleName;
-        private readonly string _frameworkDirectory;
-        private readonly bool _retargetable;
         private AssemblyNameExtension _assemblyName;
+
         public AssemblyEntry(string name, string version, string publicKeyToken, string culture, bool inGAC, bool? isRedistRoot, string redistName, string frameworkDirectory, bool retargetable)
         {
             Debug.Assert(name != null && frameworkDirectory != null);
-            _simpleName = name;
+            SimpleName = name;
             if (name != null && version != null && publicKeyToken != null && culture != null)
             {
-                _fullName = string.Format(CultureInfo.InvariantCulture, "{0}, Version={1}, Culture={2}, PublicKeyToken={3}", name, version, culture, publicKeyToken);
+                FullName = $"{name}, Version={version}, Culture={culture}, PublicKeyToken={publicKeyToken}";
             }
             else if (name != null && version != null && publicKeyToken != null)
             {
-                _fullName = string.Format(CultureInfo.InvariantCulture, "{0}, Version={1}, PublicKeyToken={2}", name, version, publicKeyToken);
+                FullName = $"{name}, Version={version}, PublicKeyToken={publicKeyToken}";
             }
             else if (name != null && version != null && culture != null)
             {
-                _fullName = string.Format(CultureInfo.InvariantCulture, "{0}, Version={1}, Culture={2}", name, version, culture);
+                FullName = $"{name}, Version={version}, Culture={culture}";
             }
             else if (name != null && version != null)
             {
-                _fullName = string.Format(CultureInfo.InvariantCulture, "{0}, Version={1}", name, version);
+                FullName = $"{name}, Version={version}";
             }
             else if (name != null && publicKeyToken != null)
             {
-                _fullName = string.Format(CultureInfo.InvariantCulture, "{0}, PublicKeyToken={1}", name, version);
+                FullName = $"{name}, PublicKeyToken={version}";
             }
             else if (name != null && culture != null)
             {
-                _fullName = string.Format(CultureInfo.InvariantCulture, "{0}, Culture={1}", name, culture);
+                FullName = $"{name}, Culture={culture}";
             }
             else if (name != null)
             {
-                _fullName = string.Format(CultureInfo.InvariantCulture, "{0}", name);
+                FullName = $"{name}";
             }
 
             if (retargetable)
             {
-                _fullName += ", Retargetable=Yes";
+                FullName += ", Retargetable=Yes";
             }
 
-            _inGAC = inGAC;
-            _isRedistRoot = isRedistRoot;
-            _redistName = redistName;
-            _frameworkDirectory = frameworkDirectory;
-            _retargetable = retargetable;
+            InGAC = inGAC;
+            IsRedistRoot = isRedistRoot;
+            RedistName = redistName;
+            FrameworkDirectory = frameworkDirectory;
+            Retargetable = retargetable;
         }
-        public string FullName { get { return _fullName; } }
-        public bool InGAC { get { return _inGAC; } }
-        public bool? IsRedistRoot { get { return _isRedistRoot; } }
-        public string RedistName { get { return _redistName; } }
-        public string SimpleName { get { return _simpleName; } }
-        public string FrameworkDirectory { get { return _frameworkDirectory; } }
-        public bool Retargetable { get { return _retargetable; } }
+
+        public string FullName { get; }
+        public bool InGAC { get; }
+        public bool? IsRedistRoot { get;  }
+        public string RedistName { get; }
+        public string SimpleName { get; }
+        public string FrameworkDirectory { get; }
+        public bool Retargetable { get; }
+
         public AssemblyNameExtension AssemblyNameExtension
         {
             get
             {
                 if (_assemblyName == null)
                 {
-                    _assemblyName = new AssemblyNameExtension(_fullName, true);
+                    _assemblyName = new AssemblyNameExtension(FullName, true);
                     _assemblyName.MarkImmutable();
                 }
 
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 5301406fbdd..25a24d0dc8a 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -8,8 +8,8 @@
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
-using System.Security;
 using System.Runtime.InteropServices.ComTypes;
+using System.Security;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -23,18 +23,6 @@ namespace Microsoft.Build.Tasks
     /// <comment>ITypeLibExporterNotifySink is necessary for the ITypeLibConverter.ConvertAssemblyToTypeLib call.</comment>
     public class RegisterAssembly : AppDomainIsolatedTaskExtension, ITypeLibExporterNotifySink
     {
-        #region Constructors
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public RegisterAssembly()
-        {
-            // do nothing
-        }
-
-        #endregion
-
         #region Properties
 
         [Required]
@@ -42,41 +30,23 @@ public ITaskItem[] Assemblies
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_assemblies, "assemblies");
+                ErrorUtilities.VerifyThrowArgumentNull(_assemblies, nameof(Assemblies));
                 return _assemblies;
             }
-            set { _assemblies = value; }
+            set => _assemblies = value;
         }
 
-        private ITaskItem[] _assemblies = null;
+        private ITaskItem[] _assemblies;
 
         [Output]
-        public ITaskItem[] TypeLibFiles
-        {
-            get { return _typeLibFiles; }
-            set { _typeLibFiles = value; }
-        }
-
-        private ITaskItem[] _typeLibFiles = null;
-
-        public bool CreateCodeBase
-        {
-            get { return _createCodeBase; }
-            set { _createCodeBase = value; }
-        }
+        public ITaskItem[] TypeLibFiles { get; set; }
 
-        private bool _createCodeBase = false;
+        public bool CreateCodeBase { get; set; }
 
         /// <summary>
         /// The cache file for Register/UnregisterAssembly. Necessary for UnregisterAssembly to do the proper clean up.
         /// </summary>
-        public ITaskItem AssemblyListFile
-        {
-            get { return _assemblyListFile; }
-            set { _assemblyListFile = value; }
-        }
-
-        private ITaskItem _assemblyListFile = null;
+        public ITaskItem AssemblyListFile { get; set; }
 
         #endregion
 
@@ -85,8 +55,7 @@ public ITaskItem AssemblyListFile
         /// <summary>
         /// Task entry point
         /// </summary>
-        /// <returns></returns>
-        override public bool Execute()
+        public override bool Execute()
         {
             // TypeLibFiles isn't [Required], but if it is specified, it must have the same length as Assemblies
             if ((TypeLibFiles != null) && (TypeLibFiles.Length != Assemblies.Length))
@@ -97,19 +66,15 @@ override public bool Execute()
 
             if (TypeLibFiles == null)
             {
-                TypeLibFiles = new TaskItem[Assemblies.Length];
+                TypeLibFiles = new ITaskItem[Assemblies.Length];
             }
 
             AssemblyRegistrationCache cacheFile = null;
 
             if ((AssemblyListFile != null) && (AssemblyListFile.ItemSpec.Length > 0))
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache));
-
-                if (cacheFile == null)
-                {
-                    cacheFile = new AssemblyRegistrationCache();
-                }
+                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache)) ??
+                            new AssemblyRegistrationCache();
             }
 
             bool taskReturnValue = true;
@@ -141,10 +106,7 @@ override public bool Execute()
                         }
                         else
                         {
-                            if (cacheFile != null)
-                            {
-                                cacheFile.AddEntry(Assemblies[i].ItemSpec, tlbPath);
-                            }
+                            cacheFile?.AddEntry(Assemblies[i].ItemSpec, tlbPath);
                         }
                     }
                     catch (ArgumentException ex) // assembly path has invalid chars in it
@@ -165,10 +127,7 @@ override public bool Execute()
             }
             finally
             {
-                if (cacheFile != null)
-                {
-                    cacheFile.SerializeCache(AssemblyListFile.ItemSpec, Log);
-                }
+                cacheFile?.SerializeCache(AssemblyListFile.ItemSpec, Log);
             }
 
             return taskReturnValue;
@@ -178,14 +137,11 @@ override public bool Execute()
 
         #region ITypeLibExporterNotifySink methods
 
-        private bool _typeLibExportFailed = false;
+        private bool _typeLibExportFailed;
 
         /// <summary>
         /// Callback method for reporting type library export events
         /// </summary>
-        /// <param name="kind"></param>
-        /// <param name="code"></param>
-        /// <param name="msg"></param>
         public void ReportEvent(ExporterEventKind kind, int code, string msg)
         {
             // if we get an error, log it and remember we should fail ExportTypeLib
@@ -228,7 +184,7 @@ public void ReportEvent(ExporterEventKind kind, int code, string msg)
         /// </comment>
         public object ResolveRef(Assembly assemblyToResolve)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(assemblyToResolve, "assemblyToResolve");
+            ErrorUtilities.VerifyThrowArgumentNull(assemblyToResolve, nameof(assemblyToResolve));
 
             Log.LogErrorWithCodeFromResources("RegisterAssembly.AssemblyNotRegisteredForComInterop", assemblyToResolve.GetName().FullName);
             _typeLibExportFailed = true;
@@ -242,12 +198,9 @@ public object ResolveRef(Assembly assemblyToResolve)
         /// <summary>
         /// Helper registration method
         /// </summary>
-        /// <param name="assemblyPath"></param>
-        /// <param name="typeLibPath"></param>
-        /// <returns></returns>
         private bool Register(string assemblyPath, string typeLibPath)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(typeLibPath, "typeLibPath");
+            ErrorUtilities.VerifyThrowArgumentNull(typeLibPath, nameof(typeLibPath));
 
             Log.LogMessageFromResources(MessageImportance.Low, "RegisterAssembly.RegisteringAssembly", assemblyPath);
 
@@ -264,10 +217,10 @@ private bool Register(string assemblyPath, string typeLibPath)
                 // Load the specified assembly. 
                 Assembly asm = Assembly.UnsafeLoadFrom(assemblyPath);
 
-                RegistrationServices comRegistrar = new RegistrationServices();
+                var comRegistrar = new RegistrationServices();
 
                 // Register the assembly
-                if (!comRegistrar.RegisterAssembly(asm, (CreateCodeBase) ? AssemblyRegistrationFlags.SetCodeBase : AssemblyRegistrationFlags.None))
+                if (!comRegistrar.RegisterAssembly(asm, CreateCodeBase ? AssemblyRegistrationFlags.SetCodeBase : AssemblyRegistrationFlags.None))
                 {
                     // If the assembly doesn't contain any types that could be registered for COM interop, 
                     // warn the user about it.  
@@ -287,7 +240,9 @@ private bool Register(string assemblyPath, string typeLibPath)
                     {
                         // if export failed the error message is already logged, so just exit
                         if (!ExportTypeLib(asm, typeLibPath))
+                        {
                             return false;
+                        }
                     }
                     catch (COMException ex)
                     {
@@ -296,7 +251,9 @@ private bool Register(string assemblyPath, string typeLibPath)
                     }
                 }
                 else
+                {
                     Log.LogMessageFromResources(MessageImportance.Low, "RegisterAssembly.TypeLibUpToDate", typeLibPath);
+                }
 
                 // Also register the type library
                 try
@@ -378,7 +335,9 @@ private bool ExportTypeLib(Assembly asm, string typeLibFileName)
                 convertedTypeLib = (ITypeLib)tlbConverter.ConvertAssemblyToTypeLib(asm, typeLibFileName, 0, this);
 
                 if (convertedTypeLib == null || _typeLibExportFailed)
+                {
                     return false;
+                }
 
                 // Persist the type library
                 UCOMICreateITypeLib createTypeLib = (UCOMICreateITypeLib)convertedTypeLib;
@@ -388,7 +347,9 @@ private bool ExportTypeLib(Assembly asm, string typeLibFileName)
             finally
             {
                 if (convertedTypeLib != null)
-                    Marshal.ReleaseComObject((ITypeLib)convertedTypeLib);
+                {
+                    Marshal.ReleaseComObject(convertedTypeLib);
+                }
             }
 
             return !_typeLibExportFailed;
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index 5835ee95509..5da0df72abd 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -2,12 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Diagnostics;
+using System.Collections.Generic;
 using System.IO;
-using System.Globalization;
-using System.Reflection;
-using System.Resources;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
@@ -29,23 +25,18 @@ public ITaskItem[] Directories
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_directories, "directories");
+                ErrorUtilities.VerifyThrowArgumentNull(_directories, nameof(Directories));
                 return _directories;
             }
-            set { _directories = value; }
+            set => _directories = value;
         }
 
         //-----------------------------------------------------------------------------------
         // Property:  list of directories that were removed from disk
         //-----------------------------------------------------------------------------------
-        private ITaskItem[] _removedDirectories;
 
         [Output]
-        public ITaskItem[] RemovedDirectories
-        {
-            get { return _removedDirectories; }
-            set { _removedDirectories = value; }
-        }
+        public ITaskItem[] RemovedDirectories { get; set; }
 
         //-----------------------------------------------------------------------------------
         // Execute -- this runs the task
@@ -55,21 +46,18 @@ public override bool Execute()
             // Delete each directory
             bool overallSuccess = true;
             // Our record of the directories that were removed
-            ArrayList removedDirectoriesList = new ArrayList();
+            var removedDirectoriesList = new List<ITaskItem>();
 
             foreach (ITaskItem directory in Directories)
             {
                 if (Directory.Exists(directory.ItemSpec))
                 {
-                    bool unauthorizedAccess = false;
-                    bool currentSuccess;
-
                     // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                     Log.LogMessageFromResources(MessageImportance.Normal, "RemoveDir.Removing", directory.ItemSpec);
 
                     // Try to remove the directory, this will not log unauthorized access errors since
                     // we will attempt to remove read only attributes and try again.
-                    currentSuccess = RemoveDirectory(directory, false, out unauthorizedAccess);
+                    bool currentSuccess = RemoveDirectory(directory, false, out bool unauthorizedAccess);
 
                     // The first attempt failed, to we will remove readonly attributes and try again..
                     if (!currentSuccess && unauthorizedAccess)
@@ -107,7 +95,7 @@ public override bool Execute()
                 }
             }
             // convert the list of deleted files into an array of ITaskItems
-            RemovedDirectories = (ITaskItem[])removedDirectoriesList.ToArray(typeof(ITaskItem));
+            RemovedDirectories = removedDirectoriesList.ToArray();
             return overallSuccess;
         }
 
@@ -121,9 +109,9 @@ private bool RemoveDirectory(ITaskItem directory, bool logUnauthorizedError, out
             try
             {
                 // Try to delete the directory
-                System.IO.Directory.Delete(directory.ItemSpec, true);
+                Directory.Delete(directory.ItemSpec, true);
             }
-            catch (System.UnauthorizedAccessException e)
+            catch (UnauthorizedAccessException e)
             {
                 success = false;
                 // Log the fact that there was a problem only if we have been asked to.
diff --git a/src/Tasks/RequiresFramework35SP1Assembly.cs b/src/Tasks/RequiresFramework35SP1Assembly.cs
index 7629a9358d3..663a4fbbd71 100644
--- a/src/Tasks/RequiresFramework35SP1Assembly.cs
+++ b/src/Tasks/RequiresFramework35SP1Assembly.cs
@@ -13,27 +13,15 @@ namespace Microsoft.Build.Tasks
     public sealed class RequiresFramework35SP1Assembly : TaskExtension
     {
         #region Fields
-        private string _errorReportUrl;
+
         private string _targetFrameworkVersion = Constants.TargetFrameworkVersion20;
         private bool? _createDesktopShortcut;
-        private bool _signingManifests;
-        private bool _outputRequiresMinimumFramework35SP1;
-
-        private ITaskItem[] _referencedAssemblies;
-        private ITaskItem[] _assemblies;
-        private ITaskItem _deploymentManifestEntryPoint;
-        private ITaskItem _entryPoint;
-        private ITaskItem[] _files;
-        private string _suiteName;
+
         #endregion
 
         #region Properties
 
-        public string ErrorReportUrl
-        {
-            get { return _errorReportUrl; }
-            set { _errorReportUrl = value; }
-        }
+        public string ErrorReportUrl { get; set; }
 
         public string TargetFrameworkVersion
         {
@@ -45,7 +33,7 @@ public string TargetFrameworkVersion
                 }
                 return _targetFrameworkVersion;
             }
-            set { _targetFrameworkVersion = value; }
+            set => _targetFrameworkVersion = value;
         }
 
         public bool CreateDesktopShortcut
@@ -62,57 +50,25 @@ public bool CreateDesktopShortcut
                 }
                 return (bool)_createDesktopShortcut;
             }
-            set { _createDesktopShortcut = value; }
+            set => _createDesktopShortcut = value;
         }
 
-        public bool SigningManifests
-        {
-            get { return _signingManifests; }
-            set { _signingManifests = value; }
-        }
+        public bool SigningManifests { get; set; }
 
-        public ITaskItem[] ReferencedAssemblies
-        {
-            get { return _referencedAssemblies; }
-            set { _referencedAssemblies = value; }
-        }
+        public ITaskItem[] ReferencedAssemblies { get; set; }
 
-        public ITaskItem[] Assemblies
-        {
-            get { return _assemblies; }
-            set { _assemblies = value; }
-        }
+        public ITaskItem[] Assemblies { get; set; }
 
-        public ITaskItem DeploymentManifestEntryPoint
-        {
-            get { return _deploymentManifestEntryPoint; }
-            set { _deploymentManifestEntryPoint = value; }
-        }
+        public ITaskItem DeploymentManifestEntryPoint { get; set; }
 
-        public ITaskItem EntryPoint
-        {
-            get { return _entryPoint; }
-            set { _entryPoint = value; }
-        }
+        public ITaskItem EntryPoint { get; set; }
 
-        public ITaskItem[] Files
-        {
-            get { return _files; }
-            set { _files = value; }
-        }
+        public ITaskItem[] Files { get; set; }
 
-        public string SuiteName
-        {
-            get { return _suiteName; }
-            set { _suiteName = value; }
-        }
+        public string SuiteName { get; set; }
 
         [Output]
-        public bool RequiresMinimumFramework35SP1
-        {
-            get { return _outputRequiresMinimumFramework35SP1; }
-            set { _outputRequiresMinimumFramework35SP1 = value; }
-        }
+        public bool RequiresMinimumFramework35SP1 { get; set; }
 
         #endregion
 
@@ -157,11 +113,11 @@ private bool UncheckedSigning()
 
         private bool ExcludeReferenceFromHashing()
         {
-            if (HasExcludedFileOrSP1File(_referencedAssemblies) ||
-                HasExcludedFileOrSP1File(_assemblies) ||
-                HasExcludedFileOrSP1File(_files) ||
-                IsExcludedFileOrSP1File(_deploymentManifestEntryPoint) ||
-                IsExcludedFileOrSP1File(_entryPoint))
+            if (HasExcludedFileOrSP1File(ReferencedAssemblies) ||
+                HasExcludedFileOrSP1File(Assemblies) ||
+                HasExcludedFileOrSP1File(Files) ||
+                IsExcludedFileOrSP1File(DeploymentManifestEntryPoint) ||
+                IsExcludedFileOrSP1File(EntryPoint))
             {
                 return true;
             }
@@ -189,8 +145,6 @@ private static bool HasExcludedFileOrSP1File(ITaskItem[] candidateFiles)
         /// Is this file System.Data.Entity.dll?
         /// Is this file Client Sentinel Assembly? 
         /// </summary>
-        /// <param name="file"></param>
-        /// <returns></returns>
         private static bool IsExcludedFileOrSP1File(ITaskItem candidateFile)
         {
             if (candidateFile != null &&
@@ -211,18 +165,9 @@ private bool HasSuiteName()
 
         #endregion
 
-        public RequiresFramework35SP1Assembly()
-        {
-        }
-
         public override bool Execute()
         {
-            _outputRequiresMinimumFramework35SP1 = false;
-
-            if (HasErrorUrl() || HasCreatedShortcut() || UncheckedSigning() || ExcludeReferenceFromHashing() || HasSuiteName())
-            {
-                _outputRequiresMinimumFramework35SP1 = true;
-            }
+            RequiresMinimumFramework35SP1 = HasErrorUrl() || HasCreatedShortcut() || UncheckedSigning() || ExcludeReferenceFromHashing() || HasSuiteName();
 
             return true;
         }
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 246ea9c7a4a..61e86cf5edf 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -99,8 +99,8 @@ list of symbols.  ResText files can use "#ifdef A" or "#if !B".
             /// </summary>
             public ITaskItem[] InputFiles
             {
-                get { return (ITaskItem[])Bag["InputFiles"]; }
-                set { Bag["InputFiles"] = value; }
+                get => (ITaskItem[])Bag[nameof(InputFiles)];
+                set => Bag[nameof(InputFiles)] = value;
             }
 
             /// <summary>
@@ -111,8 +111,8 @@ public ITaskItem[] InputFiles
             /// </summary>
             public ITaskItem[] OutputFiles
             {
-                get { return (ITaskItem[])Bag["OutputFiles"]; }
-                set { Bag["OutputFiles"] = value; }
+                get => (ITaskItem[])Bag[nameof(OutputFiles)];
+                set => Bag[nameof(OutputFiles)] = value;
             }
 
             /// <summary>
@@ -121,8 +121,8 @@ public ITaskItem[] OutputFiles
             /// </summary>
             public bool PublicClass
             {
-                get { return GetBoolParameterWithDefault("PublicClass", false); }
-                set { Bag["PublicClass"] = value; }
+                get => GetBoolParameterWithDefault(nameof(PublicClass), false);
+                set => Bag[nameof(PublicClass)] = value;
             }
 
             /// <summary>
@@ -130,8 +130,8 @@ public bool PublicClass
             /// </summary>
             public ITaskItem[] References
             {
-                get { return (ITaskItem[])Bag["References"]; }
-                set { Bag["References"] = value; }
+                get => (ITaskItem[])Bag[nameof(References)];
+                set => Bag[nameof(References)] = value;
             }
 
             /// <summary>
@@ -139,8 +139,8 @@ public ITaskItem[] References
             /// </summary>
             public string SdkToolsPath
             {
-                get { return (string)Bag["SdkToolsPath"]; }
-                set { Bag["SdkToolsPath"] = value; }
+                get => (string)Bag[nameof(SdkToolsPath)];
+                set => Bag[nameof(SdkToolsPath)] = value;
             }
 
             /// <summary>
@@ -149,8 +149,8 @@ public string SdkToolsPath
             /// </summary>
             public string StronglyTypedLanguage
             {
-                get { return (string)Bag["StronglyTypedLanguage"]; }
-                set { Bag["StronglyTypedLanguage"] = value; }
+                get => (string)Bag[nameof(StronglyTypedLanguage)];
+                set => Bag[nameof(StronglyTypedLanguage)] = value;
             }
 
             /// <summary>
@@ -159,8 +159,8 @@ public string StronglyTypedLanguage
             /// </summary>
             public string StronglyTypedNamespace
             {
-                get { return (string)Bag["StronglyTypedNamespace"]; }
-                set { Bag["StronglyTypedNamespace"] = value; }
+                get => (string)Bag[nameof(StronglyTypedNamespace)];
+                set => Bag[nameof(StronglyTypedNamespace)] = value;
             }
 
             /// <summary>
@@ -169,8 +169,8 @@ public string StronglyTypedNamespace
             /// </summary>
             public string StronglyTypedClassName
             {
-                get { return (string)Bag["StronglyTypedClassName"]; }
-                set { Bag["StronglyTypedClassName"] = value; }
+                get => (string)Bag[nameof(StronglyTypedClassName)];
+                set => Bag[nameof(StronglyTypedClassName)] = value;
             }
 
             /// <summary>
@@ -179,8 +179,8 @@ public string StronglyTypedClassName
             /// </summary>
             public string StronglyTypedFileName
             {
-                get { return (string)Bag["StronglyTypedFileName"]; }
-                set { Bag["StronglyTypedFileName"] = value; }
+                get => (string)Bag[nameof(StronglyTypedFileName)];
+                set => Bag[nameof(StronglyTypedFileName)] = value;
             }
 
             /// <summary>
@@ -189,8 +189,8 @@ public string StronglyTypedFileName
             /// </summary>
             public bool UseSourcePath
             {
-                get { return GetBoolParameterWithDefault("UseSourcePath", false); }
-                set { Bag["UseSourcePath"] = value; }
+                get => GetBoolParameterWithDefault(nameof(UseSourcePath), false);
+                set => Bag[nameof(UseSourcePath)] = value;
             }
 
             #endregion // Properties
@@ -200,13 +200,7 @@ public bool UseSourcePath
             /// <summary>
             /// Returns the name of the tool to execute
             /// </summary>
-            protected override string ToolName
-            {
-                get
-                {
-                    return "resgen.exe";
-                }
-            }
+            protected override string ToolName => "resgen.exe";
 
             /// <summary>
             /// Tracker.exe wants Unicode response files, and ResGen.exe doesn't care, 
@@ -216,10 +210,7 @@ protected override string ToolName
             /// We no longer use Tracker.exe in ResGen, but given that as ResGen doesn't care, 
             /// there doesn't really seem to be a particular reason to change it back, either...
             /// </comment>
-            protected override Encoding ResponseFileEncoding
-            {
-                get { return Encoding.Unicode; }
-            }
+            protected override Encoding ResponseFileEncoding => Encoding.Unicode;
 
             /// <summary>
             /// Invokes the ToolTask with the given parameters
@@ -228,18 +219,18 @@ protected override Encoding ResponseFileEncoding
             public override bool Execute()
             {
                 // If there aren't any input resources, well, we've already succeeded!
-                if (ResGen.IsNullOrEmpty(InputFiles))
+                if (IsNullOrEmpty(InputFiles))
                 {
                     Log.LogMessageFromResources(MessageImportance.Low, "ResGen.NoInputFiles");
                     return !Log.HasLoggedErrors;
                 }
 
-                if (ResGen.IsNullOrEmpty(OutputFiles))
+                if (IsNullOrEmpty(OutputFiles))
                 {
                     GenerateOutputFileNames();
                 }
 
-                bool success = false;
+                bool success;
 
                 // if command line is too long, fail
                 string commandLineCommands = GenerateCommandLineCommands();
@@ -262,8 +253,8 @@ public override bool Execute()
                     {
                         // One or more of the generated resources was not, in fact generated --
                         // only keep in OutputFiles the ones that actually exist.
-                        ITaskItem[] outputFiles = this.OutputFiles;
-                        List<ITaskItem> successfullyGenerated = new List<ITaskItem>();
+                        ITaskItem[] outputFiles = OutputFiles;
+                        var successfullyGenerated = new List<ITaskItem>();
 
                         for (int i = 0; i < outputFiles.Length; i++)
                         {
@@ -273,7 +264,7 @@ public override bool Execute()
                             }
                         }
 
-                        this.OutputFiles = successfullyGenerated.ToArray();
+                        OutputFiles = successfullyGenerated.ToArray();
                     }
                 }
                 else
@@ -286,7 +277,7 @@ public override bool Execute()
                     {
                         if (!File.Exists(outputFile.ItemSpec))
                         {
-                            this.OutputFiles = Array.Empty<ITaskItem>();
+                            OutputFiles = Array.Empty<ITaskItem>();
                         }
                     }
 
@@ -299,7 +290,7 @@ public override bool Execute()
                     // Default the filename if we need to - regardless of whether the STR was successfully generated
                     if (StronglyTypedFileName == null)
                     {
-                        CodeDomProvider provider = null;
+                        CodeDomProvider provider;
                         try
                         {
                             provider = CodeDomProvider.CreateProvider(StronglyTypedLanguage);
@@ -343,10 +334,11 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
                         ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(
                             "resgen.exe",
                             TargetDotNetFrameworkVersion.Version35),
-                        StringComparison.OrdinalIgnoreCase) && String.IsNullOrEmpty(StronglyTypedLanguage))
+                        StringComparison.OrdinalIgnoreCase)
+                    && String.IsNullOrEmpty(StronglyTypedLanguage))
                 {
                     // 4.0 resgen.exe does support response files, so we can return the resgen arguments here!
-                    CommandLineBuilderExtension resGenArguments = new CommandLineBuilderExtension();
+                    var resGenArguments = new CommandLineBuilderExtension();
                     GenerateResGenCommands(resGenArguments, true /* arguments must be line-delimited */);
 
                     commandLine.AppendTextUnquoted(resGenArguments.ToString());
@@ -369,19 +361,17 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
             /// <param name="commandLine">Gets filled with command line options</param>
             protected internal override void AddCommandLineCommands(CommandLineBuilderExtension commandLine)
             {
-                ErrorUtilities.VerifyThrow(!ResGen.IsNullOrEmpty(InputFiles), "If InputFiles is empty, the task should have returned before reaching this point");
+                ErrorUtilities.VerifyThrow(!IsNullOrEmpty(InputFiles), "If InputFiles is empty, the task should have returned before reaching this point");
 
-                CommandLineBuilderExtension resGenArguments = new CommandLineBuilderExtension();
+                var resGenArguments = new CommandLineBuilderExtension();
                 GenerateResGenCommands(resGenArguments, false /* don't line-delimit arguments; spaces are just fine */);
 
                 string pathToResGen = GenerateResGenFullPath();
 
-                if (
-                        pathToResGen != null &&
-                        NativeMethodsShared.IsWindows &&
-                        !pathToResGen.Equals(NativeMethodsShared.GetLongFilePath(ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", TargetDotNetFrameworkVersion.Version35)), StringComparison.OrdinalIgnoreCase) &&
-                        String.IsNullOrEmpty(StronglyTypedLanguage)
-                   )
+                if (pathToResGen != null &&
+                    NativeMethodsShared.IsWindows &&
+                    !pathToResGen.Equals(NativeMethodsShared.GetLongFilePath(ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", TargetDotNetFrameworkVersion.Version35)), StringComparison.OrdinalIgnoreCase) &&
+                    String.IsNullOrEmpty(StronglyTypedLanguage))
                 {
                     // 4.0 resgen.exe does support response files (at least as long as you're not building an STR), so we can 
                     // make use of them here by returning nothing!
@@ -399,10 +389,8 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
             /// <returns>A string containing the full path of this tool, or null if the tool was not found</returns>
             protected override string GenerateFullPathToTool()
             {
-                string pathToTool = null;
-
                 // Use ToolPath if it exists.
-                pathToTool = GenerateResGenFullPath();
+                string pathToTool = GenerateResGenFullPath();
                 return pathToTool;
             }
 
@@ -412,10 +400,10 @@ protected override string GenerateFullPathToTool()
             /// <returns>True if parameters are valid</returns>
             protected override bool ValidateParameters()
             {
-                ErrorUtilities.VerifyThrow(!ResGen.IsNullOrEmpty(InputFiles), "If InputFiles is empty, the task should have returned before reaching this point");
+                ErrorUtilities.VerifyThrow(!IsNullOrEmpty(InputFiles), "If InputFiles is empty, the task should have returned before reaching this point");
 
                 // make sure that if the output resources were set, they exactly match the number of input sources
-                if (!ResGen.IsNullOrEmpty(OutputFiles) && (OutputFiles.Length != InputFiles.Length))
+                if (!IsNullOrEmpty(OutputFiles) && (OutputFiles.Length != InputFiles.Length))
                 {
                     Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", InputFiles.Length, OutputFiles.Length, "InputFiles", "OutputFiles");
                     return false;
@@ -482,7 +470,7 @@ private static bool IsNullOrEmpty(ITaskItem[] value)
             /// </summary>
             private void GenerateOutputFileNames()
             {
-                ErrorUtilities.VerifyThrow(!ResGen.IsNullOrEmpty(InputFiles), "If InputFiles is empty, the task should have returned before reaching this point");
+                ErrorUtilities.VerifyThrow(!IsNullOrEmpty(InputFiles), "If InputFiles is empty, the task should have returned before reaching this point");
 
                 ITaskItem[] inputFiles = InputFiles;
                 ITaskItem[] outputFiles = new ITaskItem[inputFiles.Length];
@@ -490,9 +478,7 @@ private void GenerateOutputFileNames()
                 // Set the default OutputFiles values
                 for (int i = 0; i < inputFiles.Length; i++)
                 {
-                    ITaskItem2 inputFileAsITaskItem2 = inputFiles[i] as ITaskItem2;
-
-                    if (inputFileAsITaskItem2 != null)
+                    if (inputFiles[i] is ITaskItem2 inputFileAsITaskItem2)
                     {
                         outputFiles[i] = new TaskItem(Path.ChangeExtension(inputFileAsITaskItem2.EvaluatedIncludeEscaped, ".resources"));
                     }
@@ -502,7 +488,7 @@ private void GenerateOutputFileNames()
                     }
                 }
 
-                Bag["OutputFiles"] = outputFiles;
+                Bag[nameof(OutputFiles)] = outputFiles;
             }
 
             /// <summary>
@@ -511,11 +497,8 @@ private void GenerateOutputFileNames()
             /// <returns>The path to ResGen.exe, or null.</returns>
             private string GenerateResGenFullPath()
             {
-                string pathToTool = null;
-
                 // Use ToolPath if it exists.
-                pathToTool = (string)Bag["ToolPathWithFile"];
-
+                var pathToTool = (string)Bag["ToolPathWithFile"];
                 if (pathToTool == null)
                 {
                     // First see if the user has set ToolPath
@@ -560,7 +543,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
             {
                 resGenArguments = resGenArguments ?? new CommandLineBuilderExtension();
 
-                if (ResGen.IsNullOrEmpty(OutputFiles))
+                if (IsNullOrEmpty(OutputFiles))
                 {
                     GenerateOutputFileNames();
                 }
@@ -620,7 +603,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                             {
                                 resGenArguments.AppendFileNamesIfNotNull
                                 (
-                                    new ITaskItem[] { inputFiles[i], outputFiles[i] },
+                                    new[] { inputFiles[i], outputFiles[i] },
                                     ","
                                 );
                             }
@@ -637,7 +620,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                     resGenArguments.AppendSwitchIfNotNull
                     (
                         "/str:",
-                        new string[] { StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName },
+                        new[] { StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName },
                         ","
                     );
                 }
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index aedea58244c..0a964b68c2d 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections;
+using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
 using System.Resources;
@@ -16,8 +17,10 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// This class is a caching mechanism for the resgen task to keep track of linked
     /// files within processed .resx files.
+    /// 
+    /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
-    [Serializable()]
+    [Serializable]
     internal sealed class ResGenDependencies : StateFileBase
     {
         /// <summary>
@@ -35,7 +38,7 @@ internal sealed class ResGenDependencies : StateFileBase
         /// What would be the point in saving the default?
         /// </summary>
         [NonSerialized]
-        private bool isDirty = false;
+        private bool _isDirty;
 
         /// <summary>
         ///  This is the directory that will be used for resolution of files linked within a .resx.
@@ -44,19 +47,9 @@ internal sealed class ResGenDependencies : StateFileBase
         /// </summary>
         private string baseLinkedFileDirectory;
 
-        /// <summary>
-        /// Construct.
-        /// </summary>
-        internal ResGenDependencies()
-        {
-        }
-
         internal string BaseLinkedFileDirectory
         {
-            get
-            {
-                return baseLinkedFileDirectory;
-            }
+            get => baseLinkedFileDirectory;
             set
             {
                 if (value == null && baseLinkedFileDirectory == null)
@@ -64,15 +57,15 @@ internal string BaseLinkedFileDirectory
                     // No change
                     return;
                 }
-                else if ((value == null && baseLinkedFileDirectory != null) ||
-                         (value != null && baseLinkedFileDirectory == null) ||
-                         (String.Compare(baseLinkedFileDirectory, value, StringComparison.OrdinalIgnoreCase) != 0))
+                if ((value == null && baseLinkedFileDirectory != null) ||
+                     (value != null && baseLinkedFileDirectory == null) ||
+                     (String.Compare(baseLinkedFileDirectory, value, StringComparison.OrdinalIgnoreCase) != 0))
                 {
                     // Ok, this is slightly complicated.  Changing the base directory in any manner may
                     // result in changes to how we find .resx files.  Therefore, we must clear our out
                     // cache whenever the base directory changes.  
                     resXFiles.Clear();
-                    isDirty = true;
+                    _isDirty = true;
                     baseLinkedFileDirectory = value;
                 }
             }
@@ -97,9 +90,8 @@ internal bool UseSourcePath
 
         internal ResXFile GetResXFileInfo(string resxFile)
         {
-            // First, try to retrieve the resx information from our hashtable.  
-            ResXFile retVal = (ResXFile)resXFiles.GetDependencyFile(resxFile);
-
+            // First, try to retrieve the resx information from our hashtable.
+            var retVal = (ResXFile)resXFiles.GetDependencyFile(resxFile);
             if (retVal == null)
             {
                 // Ok, the file wasn't there.  Add it to our cache and return it to the caller.  
@@ -112,7 +104,7 @@ internal ResXFile GetResXFileInfo(string resxFile)
                 if (retVal.HasFileChanged())
                 {
                     resXFiles.RemoveDependencyFile(resxFile);
-                    isDirty = true;
+                    _isDirty = true;
                     retVal = AddResxFile(resxFile);
                 }
             }
@@ -125,23 +117,23 @@ private ResXFile AddResxFile(string file)
             // This method adds a .resx file "file" to our .resx cache.  The method causes the file
             // to be cracked for contained files.
 
-            ResXFile resxFile = new ResXFile(file, BaseLinkedFileDirectory);
+            var resxFile = new ResXFile(file, BaseLinkedFileDirectory);
             resXFiles.AddDependencyFile(file, resxFile);
-            isDirty = true;
+            _isDirty = true;
             return resxFile;
         }
 
         internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
         {
             // First, try to retrieve the portable library information from our hashtable.  
-            PortableLibraryFile retVal = (PortableLibraryFile)portableLibraries.GetDependencyFile(libraryPath);
+            var retVal = (PortableLibraryFile)portableLibraries.GetDependencyFile(libraryPath);
 
             // The file is in our cache.  Make sure it's up to date.  If not, discard
             // this entry from the cache and rebuild all the state at a later point.
             if (retVal != null && retVal.HasFileChanged())
             {
                 portableLibraries.RemoveDependencyFile(libraryPath);
-                isDirty = true;
+                _isDirty = true;
                 retVal = null;
             }
 
@@ -150,39 +142,30 @@ internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
 
         internal void UpdatePortableLibrary(PortableLibraryFile library)
         {
-            PortableLibraryFile cached = (PortableLibraryFile)portableLibraries.GetDependencyFile(library.FileName);
+            var cached = (PortableLibraryFile)portableLibraries.GetDependencyFile(library.FileName);
             if (cached == null || !library.Equals(cached))
             {
                 // Add a new entry or replace the existing one.
                 portableLibraries.AddDependencyFile(library.FileName, library);
-                isDirty = true;
+                _isDirty = true;
             }
         }
 
         /// <summary>
         /// Writes the contents of this object out to the specified file.
         /// </summary>
-        /// <param name="stateFile"></param>
-        override internal void SerializeCache(string stateFile, TaskLoggingHelper log)
+        internal override void SerializeCache(string stateFile, TaskLoggingHelper log)
         {
             base.SerializeCache(stateFile, log);
-            isDirty = false;
+            _isDirty = false;
         }
 
         /// <summary>
         /// Reads the .cache file from disk into a ResGenDependencies object.
         /// </summary>
-        /// <param name="stateFile"></param>
-        /// <param name="useSourcePath"></param>
-        /// <returns></returns>
         internal static ResGenDependencies DeserializeCache(string stateFile, bool useSourcePath, TaskLoggingHelper log)
         {
-            ResGenDependencies retVal = (ResGenDependencies)StateFileBase.DeserializeCache(stateFile, log, typeof(ResGenDependencies));
-
-            if (retVal == null)
-            {
-                retVal = new ResGenDependencies();
-            }
+            var retVal = (ResGenDependencies)DeserializeCache(stateFile, log, typeof(ResGenDependencies)) ?? new ResGenDependencies();
 
             // Ensure that the cache is properly initialized with respect to how resgen will 
             // resolve linked files within .resx files.  ResGen has two different
@@ -200,17 +183,16 @@ internal static ResGenDependencies DeserializeCache(string stateFile, bool useSo
 
         /// <remarks>
         /// Represents a single .resx file in the dependency cache.
+        /// 
+        /// This is an on-disk serialization format, don't change field names or types or use readonly.
         /// </remarks>
-        [Serializable()]
+        [Serializable]
         internal sealed class ResXFile : DependencyFile
         {
-            // Files contained within this resx file.  
+            // Files contained within this resx file.
             private string[] linkedFiles;
 
-            internal string[] LinkedFiles
-            {
-                get { return linkedFiles; }
-            }
+            internal string[] LinkedFiles => linkedFiles;
 
             internal ResXFile(string filename, string baseLinkedFileDirectory) : base(filename)
             {
@@ -221,27 +203,24 @@ internal ResXFile(string filename, string baseLinkedFileDirectory) : base(filena
 
                 if (File.Exists(FileName))
                 {
-                    linkedFiles = ResXFile.GetLinkedFiles(filename, baseLinkedFileDirectory);
+                    linkedFiles = GetLinkedFiles(filename, baseLinkedFileDirectory);
                 }
             }
 
             /// <summary>
             /// Given a .RESX file, returns all the linked files that are referenced within that .RESX.
             /// </summary>
-            /// <param name="filename"></param>
-            /// <param name="baseLinkedFileDirectory"></param>
-            /// <returns></returns>
             /// <exception cref="ArgumentException">May be thrown if Resx is invalid. May contain XmlException.</exception>
             /// <exception cref="XmlException">May be thrown if Resx is invalid</exception>
-            internal static string[] GetLinkedFiles(string filename, string baseLinkedFileDirectory)
+            private static string[] GetLinkedFiles(string filename, string baseLinkedFileDirectory)
             {
                 // This method finds all linked .resx files for the .resx file that is passed in.
                 // filename is the filename of the .resx file that is to be examined.
 
                 // Construct the return array
-                ArrayList retVal = new ArrayList();
+                var retVal = new List<string>();
 
-                using (ResXResourceReader resxReader = new ResXResourceReader(filename))
+                using (var resxReader = new ResXResourceReader(filename))
                 {
                     // Tell the reader to return ResXDataNode's instead of the object type
                     // the resource becomes at runtime so we can figure out which files
@@ -262,24 +241,28 @@ internal static string[] GetLinkedFiles(string filename, string baseLinkedFileDi
 
                     foreach (DictionaryEntry dictEntry in resxReader)
                     {
-                        if ((dictEntry.Value != null) && (dictEntry.Value is ResXDataNode))
+                        if (dictEntry.Value is ResXDataNode node)
                         {
-                            ResXFileRef resxFileRef = ((ResXDataNode)dictEntry.Value).FileRef;
+                            ResXFileRef resxFileRef = node.FileRef;
                             if (resxFileRef != null)
+                            {
                                 retVal.Add(FileUtilities.MaybeAdjustFilePath(resxFileRef.FileName));
+                            }
                         }
                     }
                 }
 
-                return (string[])retVal.ToArray(typeof(string));
+                return retVal.ToArray();
             }
         }
 
         /// <remarks>
         /// Represents a single assembly in the dependency cache, which may produce 
         /// 0 to many ResW files.
+        /// 
+        /// This is an on-disk serialization format, don't change field names or types or use readonly.
         /// </remarks>
-        [Serializable()]
+        [Serializable]
         internal sealed class PortableLibraryFile : DependencyFile
         {
             private string[] outputFiles;
@@ -293,20 +276,20 @@ internal PortableLibraryFile(string filename)
 
             internal string[] OutputFiles
             {
-                get { return outputFiles; }
-                set { outputFiles = value; }
+                get => outputFiles;
+                set => outputFiles = value;
             }
 
             internal string NeutralResourceLanguage
             {
-                get { return neutralResourceLanguage; }
-                set { neutralResourceLanguage = value; }
+                get => neutralResourceLanguage;
+                set => neutralResourceLanguage = value;
             }
 
             internal string AssemblySimpleName
             {
-                get { return assemblySimpleName; }
-                set { assemblySimpleName = value; }
+                get => assemblySimpleName;
+                set => assemblySimpleName = value;
             }
 
             internal bool AllOutputFilesAreUpToDate()
@@ -314,8 +297,8 @@ internal bool AllOutputFilesAreUpToDate()
                 Debug.Assert(outputFiles != null, "OutputFiles hasn't been set");
                 foreach (string outputFileName in outputFiles)
                 {
-                    FileInfo outputFile = new FileInfo(FileUtilities.FixFilePath(outputFileName));
-                    if (!outputFile.Exists || outputFile.LastWriteTime < this.LastModified)
+                    var outputFile = new FileInfo(FileUtilities.FixFilePath(outputFileName));
+                    if (!outputFile.Exists || outputFile.LastWriteTime < LastModified)
                     {
                         return false;
                     }
@@ -354,17 +337,10 @@ internal bool Equals(PortableLibraryFile otherLibrary)
                 return true;
             }
         }
-
-
+        
         /// <summary>
         /// Whether this cache is dirty or not.
         /// </summary>
-        internal bool IsDirty
-        {
-            get
-            {
-                return isDirty;
-            }
-        }
+        internal bool IsDirty => _isDirty;
     }
 }
diff --git a/src/Tasks/ResolveCodeAnalysisRuleSet.cs b/src/Tasks/ResolveCodeAnalysisRuleSet.cs
index 54a6d0983d0..ca08ee46e00 100644
--- a/src/Tasks/ResolveCodeAnalysisRuleSet.cs
+++ b/src/Tasks/ResolveCodeAnalysisRuleSet.cs
@@ -16,66 +16,30 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed class ResolveCodeAnalysisRuleSet : TaskExtension
     {
-        /// <summary>
-        /// The desired code analysis rule set file.
-        /// </summary>
-        private string _codeAnalysisRuleSet;
-
-        /// <summary>
-        /// The location of the project currently being built.
-        /// </summary>
-        private string _projectDirectory;
-
-        /// <summary>
-        /// The set of additional directories to search for code analysis rule set files.
-        /// </summary>
-        private string[] _codeAnalysisRuleSetDirectories;
-
-        /// <summary>
-        /// The location of the resolved rule set file. May be null if the file
-        /// does not exist on disk.
-        /// </summary>
-        private string _resolvedCodeAnalysisRuleSet;
-
         #region Properties
 
         /// <summary>
         /// The desired code analysis rule set file. May be a simple name, relative
         /// path, or full path.
         /// </summary>
-        public string CodeAnalysisRuleSet
-        {
-            get { return _codeAnalysisRuleSet; }
-            set { _codeAnalysisRuleSet = value; }
-        }
+        public string CodeAnalysisRuleSet { get; set; }
 
         /// <summary>
         /// The set of additional directories to search for code analysis rule set files.
         /// </summary>
-        public string[] CodeAnalysisRuleSetDirectories
-        {
-            get { return _codeAnalysisRuleSetDirectories; }
-            set { _codeAnalysisRuleSetDirectories = value; }
-        }
+        public string[] CodeAnalysisRuleSetDirectories { get; set; }
 
         /// <summary>
         /// The location of the project currently being built.
         /// </summary>
-        public string MSBuildProjectDirectory
-        {
-            get { return _projectDirectory; }
-            set { _projectDirectory = value; }
-        }
+        public string MSBuildProjectDirectory { get; set; }
 
         /// <summary>
         /// The location of the resolved rule set file. May be null if the file
         /// does not exist on disk.
         /// </summary>
         [Output]
-        public string ResolvedCodeAnalysisRuleSet
-        {
-            get { return _resolvedCodeAnalysisRuleSet; }
-        }
+        public string ResolvedCodeAnalysisRuleSet { get; private set; }
 
         /// <summary>
         /// Runs the task.
@@ -83,7 +47,7 @@ public string ResolvedCodeAnalysisRuleSet
         /// <returns>True if the task succeeds without errors; false otherwise.</returns>
         public override bool Execute()
         {
-            _resolvedCodeAnalysisRuleSet = GetResolvedRuleSetPath();
+            ResolvedCodeAnalysisRuleSet = GetResolvedRuleSetPath();
 
             return !Log.HasLoggedErrors;
         }
@@ -109,30 +73,30 @@ public override bool Execute()
         /// <returns>The full or relative path to the rule set, or null if the file does not exist.</returns>
         private string GetResolvedRuleSetPath()
         {
-            if (string.IsNullOrEmpty(_codeAnalysisRuleSet))
+            if (string.IsNullOrEmpty(CodeAnalysisRuleSet))
             {
                 return null;
             }
 
-            if (_codeAnalysisRuleSet == Path.GetFileName(_codeAnalysisRuleSet))
+            if (CodeAnalysisRuleSet == Path.GetFileName(CodeAnalysisRuleSet))
             {
                 // This is a simple file name.
                 // Check if the file exists in the MSBuild project directory.
-                if (!string.IsNullOrEmpty(_projectDirectory))
+                if (!string.IsNullOrEmpty(MSBuildProjectDirectory))
                 {
-                    string fullName = Path.Combine(_projectDirectory, _codeAnalysisRuleSet);
+                    string fullName = Path.Combine(MSBuildProjectDirectory, CodeAnalysisRuleSet);
                     if (File.Exists(fullName))
                     {
-                        return _codeAnalysisRuleSet;
+                        return CodeAnalysisRuleSet;
                     }
                 }
 
                 // Try the rule set directories if we have some.
-                if (_codeAnalysisRuleSetDirectories != null)
+                if (CodeAnalysisRuleSetDirectories != null)
                 {
-                    foreach (string directory in _codeAnalysisRuleSetDirectories)
+                    foreach (string directory in CodeAnalysisRuleSetDirectories)
                     {
-                        string fullName = Path.Combine(directory, _codeAnalysisRuleSet);
+                        string fullName = Path.Combine(directory, CodeAnalysisRuleSet);
                         if (File.Exists(fullName))
                         {
                             return fullName;
@@ -140,29 +104,29 @@ private string GetResolvedRuleSetPath()
                     }
                 }
             }
-            else if (!Path.IsPathRooted(_codeAnalysisRuleSet))
+            else if (!Path.IsPathRooted(CodeAnalysisRuleSet))
             {
                 // This is a path relative to the project.
-                if (!string.IsNullOrEmpty(_projectDirectory))
+                if (!string.IsNullOrEmpty(MSBuildProjectDirectory))
                 {
-                    string fullName = Path.Combine(_projectDirectory, _codeAnalysisRuleSet);
+                    string fullName = Path.Combine(MSBuildProjectDirectory, CodeAnalysisRuleSet);
                     if (File.Exists(fullName))
                     {
-                        return _codeAnalysisRuleSet;
+                        return CodeAnalysisRuleSet;
                     }
                 }
             }
-            else if (File.Exists(_codeAnalysisRuleSet))
+            else if (File.Exists(CodeAnalysisRuleSet))
             {
                 // This is a full path.
-                return _codeAnalysisRuleSet;
+                return CodeAnalysisRuleSet;
             }
 
             // We can't resolve the rule set to any existing file.
-            Log.LogWarningWithCodeFromResources("Compiler.UnableToFindRuleSet", _codeAnalysisRuleSet);
+            Log.LogWarningWithCodeFromResources("Compiler.UnableToFindRuleSet", CodeAnalysisRuleSet);
             return null;
         }
 
         #endregion
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 3bba8aa85d8..ed267c2f4b9 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -5,13 +5,13 @@
 
 using System;
 using System.Collections;
+using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Reflection;
 using System.Runtime.InteropServices;
-using System.Collections.Generic;
-using System.Linq;
 
 // TYPELIBATTR clashes with the one in InteropServices.
 using TYPELIBATTR = System.Runtime.InteropServices.ComTypes.TYPELIBATTR;
@@ -28,213 +28,75 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public sealed partial class ResolveComReference : AppDomainIsolatedTaskExtension, IComReferenceResolver
     {
-        #region Constructors
-
-        /// <summary>
-        /// public constructor
-        /// </summary>
-        public ResolveComReference()
-        {
-            // do nothing.
-        }
-
-        #endregion
-
         #region Properties
 
         /// <summary>
         /// COM references specified by guid/version/lcid
         /// </summary>
-        public ITaskItem[] TypeLibNames
-        {
-            get
-            {
-                return _typeLibNames;
-            }
-            set
-            {
-                _typeLibNames = value;
-            }
-        }
-
-        private ITaskItem[] _typeLibNames = null;
+        public ITaskItem[] TypeLibNames { get; set; }
 
         /// <summary>
         /// COM references specified by type library file path
         /// </summary>
-        public ITaskItem[] TypeLibFiles
-        {
-            get
-            {
-                return _typeLibFiles;
-            }
-            set
-            {
-                _typeLibFiles = value;
-            }
-        }
+        public ITaskItem[] TypeLibFiles { get; set; }
 
         /// <summary>
         /// Array of equals-separated pairs of environment
         /// variables that should be passed to the spawned tlbimp.exe and aximp.exe,
         /// in addition to (or selectively overriding) the regular environment block.
         /// </summary>
-        public string[] EnvironmentVariables
-        {
-            get;
-            set;
-        }
-
-        private ITaskItem[] _typeLibFiles = null;
+        public string[] EnvironmentVariables { get; set; }
 
         /// <summary>
         /// merged array containing typeLibNames and typeLibFiles (internal for unit testing)
         /// </summary>
-        internal List<ComReferenceInfo> allProjectRefs = null;
+        internal List<ComReferenceInfo> allProjectRefs;
 
         /// <summary>
         /// array containing all dependency references
         /// </summary>
-        internal List<ComReferenceInfo> allDependencyRefs = null;
+        internal List<ComReferenceInfo> allDependencyRefs;
 
         /// <summary>
         /// the directory wrapper files get generated into
         /// </summary>
-        public string WrapperOutputDirectory
-        {
-            get
-            {
-                return _wrapperOutputDirectory;
-            }
-            set
-            {
-                _wrapperOutputDirectory = value;
-            }
-        }
-
-        private string _wrapperOutputDirectory = null;
+        public string WrapperOutputDirectory { get; set; }
 
         /// <summary>
         /// When set to true, the typelib version will be included in the wrapper name.  Default is false.
         /// </summary>
-        public bool IncludeVersionInInteropName
-        {
-            get
-            {
-                return _includeVersionInInteropName;
-            }
-
-            set
-            {
-                _includeVersionInInteropName = value;
-            }
-        }
-
-        private bool _includeVersionInInteropName;
+        public bool IncludeVersionInInteropName { get; set; }
 
         /// <summary>
         /// source of resolved .NET assemblies - we need this for ActiveX wrappers, since we can't resolve .NET assembly
         /// references ourselves
         /// </summary>
-        public ITaskItem[] ResolvedAssemblyReferences
-        {
-            get
-            {
-                return _resolvedAssemblyReferences;
-            }
-            set
-            {
-                _resolvedAssemblyReferences = value;
-            }
-        }
-
-        private ITaskItem[] _resolvedAssemblyReferences = null;
+        public ITaskItem[] ResolvedAssemblyReferences { get; set; }
 
         /// <summary>
         /// container name for public/private keys
         /// </summary>
-        public string KeyContainer
-        {
-            get
-            {
-                return _keyContainer;
-            }
-            set
-            {
-                _keyContainer = value;
-            }
-        }
-
-        private string _keyContainer = null;
+        public string KeyContainer { get; set; } 
 
         /// <summary>
         /// file containing public/private keys
         /// </summary>
-        public string KeyFile
-        {
-            get
-            {
-                return _keyFile;
-            }
-            set
-            {
-                _keyFile = value;
-            }
-        }
-
-        private string _keyFile = null;
+        public string KeyFile { get; set; }
 
         /// <summary>
         /// delay sign wrappers?
         /// </summary>
-        public bool DelaySign
-        {
-            get
-            {
-                return _delaySign;
-            }
-            set
-            {
-                _delaySign = value;
-            }
-        }
-
-        private bool _delaySign = false;
+        public bool DelaySign { get; set; }
 
         /// <summary>
         /// Passes the TypeLibImporterFlags.PreventClassMembers flag to tlb wrapper generation
         /// </summary>
-        public bool NoClassMembers
-        {
-            get
-            {
-                return _noClassMembers;
-            }
-            set
-            {
-                _noClassMembers = value;
-            }
-        }
-
-        private bool _noClassMembers = false;
+        public bool NoClassMembers { get; set; } 
 
         /// <summary>
         /// If true, do not log messages or warnings.  Default is false. 
         /// </summary>
-        public bool Silent
-        {
-            get
-            {
-                return _silent;
-            }
-
-            set
-            {
-                _silent = value;
-            }
-        }
-
-        private bool _silent = false;
+        public bool Silent { get; set; }
 
         /// <summary>
         /// The preferred target processor architecture. Passed to tlbimp.exe /machine flag after translation. 
@@ -242,10 +104,7 @@ public bool Silent
         /// </summary>
         public string TargetProcessorArchitecture
         {
-            get
-            {
-                return _targetProcessorArchitecture;
-            }
+            get => _targetProcessorArchitecture;
 
             set
             {
@@ -276,85 +135,37 @@ public string TargetProcessorArchitecture
             }
         }
 
-        private string _targetProcessorArchitecture = null;
+        private string _targetProcessorArchitecture;
 
         /// <summary>
         /// Property to allow multitargeting of ResolveComReferences:  If true, tlbimp.exe 
         /// from the appropriate target framework will be run out-of-proc to generate
         /// the necessary wrapper assemblies. Aximp is always run out of proc.
         /// </summary>
-        public bool ExecuteAsTool
-        {
-            get
-            {
-                return _executeAsTool;
-            }
-            set
-            {
-                _executeAsTool = value;
-            }
-        }
-
-        private bool _executeAsTool = true;
+        public bool ExecuteAsTool { get; set; } = true;
 
         /// <summary>
         /// paths to found/generated reference wrappers
         /// </summary>
         [Output]
-        public ITaskItem[] ResolvedFiles
-        {
-            get
-            {
-                return _resolvedFiles;
-            }
-            set
-            {
-                _resolvedFiles = value;
-            }
-        }
-
-        private ITaskItem[] _resolvedFiles = null;
+        public ITaskItem[] ResolvedFiles { get; set; }
 
         /// <summary>
         /// paths to found modules (needed for isolation)
         /// </summary>
         [Output]
-        public ITaskItem[] ResolvedModules
-        {
-            get
-            {
-                return _resolvedModules;
-            }
-            set
-            {
-                _resolvedModules = value;
-            }
-        }
-
-        private ITaskItem[] _resolvedModules = null;
+        public ITaskItem[] ResolvedModules { get; set; }
 
         /// <summary>
         /// If ExecuteAsTool is true, this must be set to the SDK 
         /// tools path for the framework version being targeted. 
         /// </summary>
-        public string SdkToolsPath
-        {
-            get { return _sdkToolsPath; }
-            set { _sdkToolsPath = value; }
-        }
-
-        private string _sdkToolsPath;
+        public string SdkToolsPath { get; set; }
 
         /// <summary>
         /// Cache file for COM component timestamps. If not present, every run will regenerate all the wrappers.
         /// </summary>
-        public string StateFile
-        {
-            get { return _stateFile; }
-            set { _stateFile = value; }
-        }
-
-        private string _stateFile = null;
+        public string StateFile { get; set; }
 
         /// <summary>
         /// The project target framework version.
@@ -362,25 +173,22 @@ public string StateFile
         /// Default is empty. which means there will be no filtering for the reference based on their target framework.
         /// </summary>
         /// <value></value>
-        public string TargetFrameworkVersion
-        {
-            get { return _projectTargetFrameworkAsString; }
-            set { _projectTargetFrameworkAsString = value; }
-        }
+        public string TargetFrameworkVersion { get; set; } = String.Empty;
 
-        private string _projectTargetFrameworkAsString = String.Empty;
         private Version _projectTargetFramework;
-
-
+        
         /// <summary>version 4.0</summary>
         private static readonly Version s_targetFrameworkVersion_40 = new Version("4.0");
 
-        private ResolveComReferenceCache _timestampCache = null;
+        private ResolveComReferenceCache _timestampCache;
 
         // Cache hashtables for different wrapper types
-        private Hashtable _cachePia = new Hashtable();
-        private Hashtable _cacheTlb = new Hashtable();
-        private Hashtable _cacheAx = new Hashtable();
+        private readonly Dictionary<string, ComReferenceWrapperInfo> _cachePia =
+            new Dictionary<string, ComReferenceWrapperInfo>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, ComReferenceWrapperInfo> _cacheTlb =
+            new Dictionary<string, ComReferenceWrapperInfo>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, ComReferenceWrapperInfo> _cacheAx =
+            new Dictionary<string, ComReferenceWrapperInfo>(StringComparer.OrdinalIgnoreCase);
 
         // Paths for the out-of-proc tools being used
         private string _aximpPath;
@@ -417,14 +225,14 @@ public override bool Execute()
             {
                 if (!Silent)
                 {
-                    Log.LogMessageFromResources(MessageImportance.Low, "ResolveComReference.NotUsingCacheFile", StateFile == null ? String.Empty : StateFile);
+                    Log.LogMessageFromResources(MessageImportance.Low, "ResolveComReference.NotUsingCacheFile", StateFile ?? String.Empty);
                 }
 
                 _timestampCache = new ResolveComReferenceCache(_tlbimpPath, _aximpPath);
             }
             else if (!Silent)
             {
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveComReference.UsingCacheFile", StateFile == null ? String.Empty : StateFile);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveComReference.UsingCacheFile", StateFile ?? String.Empty);
             }
 
             try
@@ -439,17 +247,17 @@ public override bool Execute()
                 // and continue (first one wins)
                 CheckForConflictingReferences();
 
-                SetFrameworkVersionFromString(_projectTargetFrameworkAsString);
+                SetFrameworkVersionFromString(TargetFrameworkVersion);
 
                 // Process each task item. If one of them fails we still process the rest of them, but
                 // remember that the task should return failure.
                 // DESIGN CHANGE: we no longer fail the task when one or more references fail to resolve. 
                 // Unless we experience a catastrophic failure, we'll log warnings for those refs and proceed
                 // (and return success)
-                ArrayList moduleList = new ArrayList();
-                ArrayList resolvedReferenceList = new ArrayList();
+                var moduleList = new List<ITaskItem>();
+                var resolvedReferenceList = new List<ITaskItem>();
 
-                ComDependencyWalker dependencyWalker = new ComDependencyWalker(Marshal.ReleaseComObject);
+                var dependencyWalker = new ComDependencyWalker(Marshal.ReleaseComObject);
                 bool allReferencesResolvedSuccessfully = true;
                 for (int pass = 0; pass < 4; pass++)
                 {
@@ -465,7 +273,7 @@ public override bool Execute()
                         {
                             try
                             {
-                                if (!this.ResolveReferenceAndAddToList(dependencyWalker, projectRefInfo, resolvedReferenceList, moduleList))
+                                if (!ResolveReferenceAndAddToList(dependencyWalker, projectRefInfo, resolvedReferenceList, moduleList))
                                 {
                                     allReferencesResolvedSuccessfully = false;
                                 }
@@ -519,8 +327,8 @@ public override bool Execute()
 
                 SetCopyLocalToFalseOnGacOrNoPIAAssemblies(resolvedReferenceList, GlobalAssemblyCache.GetGacPath());
 
-                ResolvedModules = (ITaskItem[])moduleList.ToArray(typeof(ITaskItem));
-                ResolvedFiles = (ITaskItem[])resolvedReferenceList.ToArray(typeof(ITaskItem));
+                ResolvedModules = moduleList.ToArray();
+                ResolvedFiles = resolvedReferenceList.ToArray();
 
                 // The Logs from AxImp and TlbImp aren't part of our log, but if the task failed, it will return false from 
                 // GenerateWrapper, which should get passed all the way back up here.  
@@ -561,7 +369,6 @@ internal void SetFrameworkVersionFromString(string version)
             }
 
             _projectTargetFramework = parsedVersion;
-            return;
         }
 
         /// <summary>
@@ -573,7 +380,7 @@ private bool ComputePathToTlbImp()
         {
             _tlbimpPath = null;
 
-            if (String.IsNullOrEmpty(_sdkToolsPath))
+            if (String.IsNullOrEmpty(SdkToolsPath))
             {
                 _tlbimpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("TlbImp.exe", TargetDotNetFrameworkVersion.Version35, VisualStudioVersion.VersionLatest);
 
@@ -586,7 +393,7 @@ private bool ComputePathToTlbImp()
             }
             else
             {
-                _tlbimpPath = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, this.TargetProcessorArchitecture, SdkToolsPath, "TlbImp.exe", Log, ExecuteAsTool);
+                _tlbimpPath = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, TargetProcessorArchitecture, SdkToolsPath, "TlbImp.exe", Log, ExecuteAsTool);
             }
 
             if (null == _tlbimpPath && !ExecuteAsTool)
@@ -614,7 +421,7 @@ private bool ComputePathToAxImp()
             // We always execute AxImp.exe out of proc
             _aximpPath = null;
 
-            if (String.IsNullOrEmpty(_sdkToolsPath))
+            if (String.IsNullOrEmpty(SdkToolsPath))
             {
                 // In certain cases -- such as trying to build a Dev10 project on a machine that only has Dev11 installed --
                 // it's possible to have ExecuteAsTool set to false (e.g. "use the current CLR") but still have SDKToolsPath
@@ -635,7 +442,7 @@ private bool ComputePathToAxImp()
             }
             else
             {
-                _aximpPath = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, this.TargetProcessorArchitecture, SdkToolsPath, "AxImp.exe", Log, true /* log errors */);
+                _aximpPath = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, TargetProcessorArchitecture, SdkToolsPath, "AxImp.exe", Log, true /* log errors */);
             }
 
             if (_aximpPath != null)
@@ -654,7 +461,7 @@ private string GetPathToSDKFileWithCurrentlyTargetedArchitecture(string file, Ta
         {
             string path = null;
 
-            switch (this.TargetProcessorArchitecture)
+            switch (TargetProcessorArchitecture)
             {
                 case UtilitiesProcessorArchitecture.ARM:
                 case UtilitiesProcessorArchitecture.X86:
@@ -710,8 +517,7 @@ private void Cleanup()
          */
         private bool VerifyAndInitializeInputs()
         {
-            if ((KeyContainer != null && KeyContainer.Length != 0)
-                && (KeyFile != null && KeyFile.Length != 0))
+            if (!string.IsNullOrEmpty(KeyContainer) && !string.IsNullOrEmpty(KeyFile))
             {
                 Log.LogErrorWithCodeFromResources("ResolveComReference.CannotSpecifyBothKeyFileAndKeyContainer");
                 return false;
@@ -719,8 +525,7 @@ private bool VerifyAndInitializeInputs()
 
             if (DelaySign)
             {
-                if ((KeyContainer == null || KeyContainer.Length == 0) &&
-                    (KeyFile == null || KeyFile.Length == 0))
+                if (string.IsNullOrEmpty(KeyContainer) && string.IsNullOrEmpty(KeyFile))
                 {
                     Log.LogErrorWithCodeFromResources("ResolveComReference.CannotSpecifyDelaySignWithoutEitherKeyFileOrKeyContainer");
                     return false;
@@ -749,9 +554,8 @@ private bool VerifyAndInitializeInputs()
             for (int i = 0; i < typeLibNamesLength; i++)
             {
                 // verify the COM reference item contains all the required attributes
-                string missingMetadata;
 
-                if (!VerifyReferenceMetadataForNameItem(TypeLibNames[i], out missingMetadata))
+                if (!VerifyReferenceMetadataForNameItem(TypeLibNames[i], out string missingMetadata))
                 {
                     Log.LogErrorWithCodeFromResources(null, TypeLibNames[i].ItemSpec, 0, 0, 0, 0, "ResolveComReference.MissingOrUnknownComReferenceAttribute", missingMetadata, TypeLibNames[i].ItemSpec);
 
@@ -787,11 +591,11 @@ private void ConvertAttrReferencesToComReferenceInfo(List<ComReferenceInfo> proj
 
             for (int i = 0; i < typeLibAttrsLength; i++)
             {
-                ComReferenceInfo projectRefInfo = new ComReferenceInfo();
+                var projectRefInfo = new ComReferenceInfo();
 
                 try
                 {
-                    if (projectRefInfo.InitializeWithTypeLibAttrs(Log, Silent, TaskItemToTypeLibAttr(typeLibAttrs[i]), typeLibAttrs[i], this.TargetProcessorArchitecture))
+                    if (projectRefInfo.InitializeWithTypeLibAttrs(Log, Silent, TaskItemToTypeLibAttr(typeLibAttrs[i]), typeLibAttrs[i], TargetProcessorArchitecture))
                     {
                         projectRefs.Add(projectRefInfo);
                     }
@@ -826,15 +630,16 @@ private void ConvertFileReferencesToComReferenceInfo(List<ComReferenceInfo> proj
             for (int i = 0; i < tlbFilesLength; i++)
             {
                 string refPath = tlbFiles[i].ItemSpec;
-
                 if (!Path.IsPathRooted(refPath))
+                {
                     refPath = Path.Combine(Directory.GetCurrentDirectory(), refPath);
+                }
 
-                ComReferenceInfo projectRefInfo = new ComReferenceInfo();
+                var projectRefInfo = new ComReferenceInfo();
 
                 try
                 {
-                    if (projectRefInfo.InitializeWithPath(Log, Silent, refPath, tlbFiles[i], this.TargetProcessorArchitecture))
+                    if (projectRefInfo.InitializeWithPath(Log, Silent, refPath, tlbFiles[i], TargetProcessorArchitecture))
                     {
                         projectRefs.Add(projectRefInfo);
                     }
@@ -913,7 +718,7 @@ internal void AddMissingTlbReferences()
                             Log.LogMessageFromResources(MessageImportance.Low, "ResolveComReference.AddingMissingTlbReference", axRefInfo.taskItem.ItemSpec);
                         }
 
-                        ComReferenceInfo newTlbRef = new ComReferenceInfo(axRefInfo);
+                        var newTlbRef = new ComReferenceInfo(axRefInfo);
                         newTlbRef.taskItem.SetMetadata(ComReferenceItemMetadataNames.wrapperTool, ComReferenceTypes.primaryortlbimp);
                         newTlbRef.taskItem.SetMetadata(ItemMetadataNames.embedInteropTypes, "false");
                         axRefInfo.primaryOfAxImpRef = newTlbRef;
@@ -933,26 +738,19 @@ internal void AddMissingTlbReferences()
         /// <summary>
         /// Resolves the COM reference, and adds it to the appropriate item list.
         /// </summary>
-        /// <param name="projectRefInfo"></param>
-        /// <param name="resolvedReferenceList"></param>
-        /// <param name="moduleList"></param>
-        /// <returns></returns>
         private bool ResolveReferenceAndAddToList
             (
             ComDependencyWalker dependencyWalker,
             ComReferenceInfo projectRefInfo,
-            ArrayList resolvedReferenceList,
-            ArrayList moduleList
+            List<ITaskItem> resolvedReferenceList,
+            List<ITaskItem> moduleList
             )
         {
-            ITaskItem referencePath;
-
-            if (ResolveReference(dependencyWalker, projectRefInfo, WrapperOutputDirectory, out referencePath))
+            if (ResolveReference(dependencyWalker, projectRefInfo, WrapperOutputDirectory, out ITaskItem referencePath))
             {
                 resolvedReferenceList.Add(referencePath);
 
-                bool metadataFound = false;
-                bool isolated = MetadataConversionUtilities.TryConvertItemMetadataToBool(projectRefInfo.taskItem, "Isolated", out metadataFound);
+                bool isolated = MetadataConversionUtilities.TryConvertItemMetadataToBool(projectRefInfo.taskItem, "Isolated", out bool metadataFound);
 
                 if (metadataFound && isolated)
                 {
@@ -998,11 +796,9 @@ internal bool ResolveReference(ComDependencyWalker dependencyWalker, ComReferenc
                 referencePathItem = new TaskItem();
                 referenceInfo.referencePathItem = referencePathItem;
 
-                ComReferenceWrapperInfo wrapperInfo;
-
                 if (ResolveComClassicReference(referenceInfo, outputDirectory,
                     referenceInfo.taskItem.GetMetadata(ComReferenceItemMetadataNames.wrapperTool),
-                    referenceInfo.taskItem.ItemSpec, true, referenceInfo.dependentWrapperPaths, out wrapperInfo))
+                    referenceInfo.taskItem.ItemSpec, true, referenceInfo.dependentWrapperPaths, out ComReferenceWrapperInfo wrapperInfo))
                 {
                     referencePathItem.ItemSpec = wrapperInfo.path;
                     referenceInfo.taskItem.CopyMetadataTo(referencePathItem);
@@ -1173,10 +969,8 @@ bool IComReferenceResolver.ResolveComClassicReference(TYPELIBATTR typeLibAttr, s
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveComReference.RemappingAdoTypeLib", oldAttr.wMajorVerNum, oldAttr.wMinorVerNum);
             }
 
-            ComReferenceInfo referenceInfo;
-
             // find an existing ref in the project (taking the desired wrapperType into account, if any)
-            if (IsExistingProjectReference(typeLibAttr, wrapperType, out referenceInfo))
+            if (IsExistingProjectReference(typeLibAttr, wrapperType, out ComReferenceInfo referenceInfo))
             {
                 // IsExistingProjectReference should not return null... 
                 Debug.Assert(referenceInfo != null, "IsExistingProjectReference should not return null");
@@ -1209,7 +1003,7 @@ bool IComReferenceResolver.ResolveComClassicReference(TYPELIBATTR typeLibAttr, s
                 {
                     referenceInfo = new ComReferenceInfo();
 
-                    if (referenceInfo.InitializeWithTypeLibAttrs(Log, Silent, typeLibAttr, null, this.TargetProcessorArchitecture))
+                    if (referenceInfo.InitializeWithTypeLibAttrs(Log, Silent, typeLibAttr, null, TargetProcessorArchitecture))
                     {
                         allDependencyRefs.Add(referenceInfo);
                     }
@@ -1286,17 +1080,19 @@ bool IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, out
          */
         bool IComReferenceResolver.ResolveComAssemblyReference(string fullAssemblyName, out string assemblyPath)
         {
-            AssemblyNameExtension fullAssemblyNameEx = new AssemblyNameExtension(fullAssemblyName);
+            var fullAssemblyNameEx = new AssemblyNameExtension(fullAssemblyName);
 
             foreach (ComReferenceWrapperInfo wrapperInfo in _cachePia.Values)
             {
                 // this should not happen, but it would be a non fatal error
                 Debug.Assert(wrapperInfo.path != null);
                 if (wrapperInfo.path == null)
+                {
                     continue;
+                }
 
                 // we have already verified all cached wrappers, so we don't expect this methods to throw anything
-                AssemblyNameExtension wrapperAssemblyNameEx = new AssemblyNameExtension(AssemblyName.GetAssemblyName(wrapperInfo.path));
+                var wrapperAssemblyNameEx = new AssemblyNameExtension(AssemblyName.GetAssemblyName(wrapperInfo.path));
 
                 if (fullAssemblyNameEx.Equals(wrapperAssemblyNameEx))
                 {
@@ -1315,11 +1111,12 @@ bool IComReferenceResolver.ResolveComAssemblyReference(string fullAssemblyName,
             {
                 // temporary wrapper? skip it.
                 if (wrapperInfo.path == null)
+                {
                     continue;
+                }
 
                 // we have already verified all cached wrappers, so we don't expect this methods to throw anything
-                AssemblyNameExtension wrapperAssemblyNameEx = new AssemblyNameExtension(AssemblyName.GetAssemblyName(wrapperInfo.path));
-
+                var wrapperAssemblyNameEx = new AssemblyNameExtension(AssemblyName.GetAssemblyName(wrapperInfo.path));
                 if (fullAssemblyNameEx.Equals(wrapperAssemblyNameEx))
                 {
                     assemblyPath = wrapperInfo.path;
@@ -1332,11 +1129,12 @@ bool IComReferenceResolver.ResolveComAssemblyReference(string fullAssemblyName,
                 // this should not happen, but it would be a non fatal error
                 Debug.Assert(wrapperInfo.path != null);
                 if (wrapperInfo.path == null)
+                {
                     continue;
+                }
 
                 // we have already verified all cached wrappers, so we don't expect this methods to throw anything
-                AssemblyNameExtension wrapperAssemblyNameEx = new AssemblyNameExtension(AssemblyName.GetAssemblyName(wrapperInfo.path));
-
+                var wrapperAssemblyNameEx = new AssemblyNameExtension(AssemblyName.GetAssemblyName(wrapperInfo.path));
                 if (fullAssemblyNameEx.Equals(wrapperAssemblyNameEx))
                 {
                     assemblyPath = wrapperInfo.path;
@@ -1357,20 +1155,18 @@ bool IComReferenceResolver.ResolveComAssemblyReference(string fullAssemblyName,
         /// <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
         internal bool ResolveComReferencePia(ComReferenceInfo referenceInfo, string refName, out ComReferenceWrapperInfo wrapperInfo)
         {
-            wrapperInfo = null;
             string typeLibKey = ComReference.UniqueKeyFromTypeLibAttr(referenceInfo.attr);
 
             // look in the PIA cache first
-            if (_cachePia.ContainsKey(typeLibKey))
+            if (_cachePia.TryGetValue(typeLibKey, out wrapperInfo))
             {
-                wrapperInfo = (ComReferenceWrapperInfo)_cachePia[typeLibKey];
                 return true;
             }
 
             try
             {
                 // if not in the cache, we have no choice but to go looking for the PIA
-                PiaReference reference = new PiaReference(Log, Silent, referenceInfo, refName);
+                var reference = new PiaReference(Log, Silent, referenceInfo, refName);
 
                 // if not found, fail (we do not fall back to tlbimp wrappers if we're looking specifically for a PIA)
                 if (!reference.FindExistingWrapper(out wrapperInfo, _timestampCache[referenceInfo.strippedTypeLibPath]))
@@ -1409,13 +1205,11 @@ internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
         /// <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
         internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outputDirectory, string refName, bool topLevelRef, List<string> dependencyPaths, out ComReferenceWrapperInfo wrapperInfo)
         {
-            wrapperInfo = null;
             string typeLibKey = ComReference.UniqueKeyFromTypeLibAttr(referenceInfo.attr);
 
             // look in the TLB cache first
-            if (_cacheTlb.ContainsKey(typeLibKey))
+            if (_cacheTlb.TryGetValue(typeLibKey, out wrapperInfo))
             {
-                wrapperInfo = (ComReferenceWrapperInfo)_cacheTlb[typeLibKey];
                 return true;
             }
 
@@ -1442,7 +1236,7 @@ internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outp
 
             try
             {
-                List<string> referencePaths = new List<string>(GetResolvedAssemblyReferenceItemSpecs());
+                var referencePaths = new List<string>(GetResolvedAssemblyReferenceItemSpecs());
 
                 if (dependencyPaths != null)
                 {
@@ -1450,16 +1244,18 @@ internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outp
                 }
 
                 // not in the cache? see if anyone was kind enough to generate it for us
-                TlbReference reference = new TlbReference(Log, Silent, this, referencePaths, referenceInfo, refName,
-                    outputDirectory, isTemporary, DelaySign, KeyFile, KeyContainer, this.NoClassMembers,
-                    this.TargetProcessorArchitecture, IncludeVersionInInteropName, ExecuteAsTool, _tlbimpPath,
+                var reference = new TlbReference(Log, Silent, this, referencePaths, referenceInfo, refName,
+                    outputDirectory, isTemporary, DelaySign, KeyFile, KeyContainer, NoClassMembers,
+                    TargetProcessorArchitecture, IncludeVersionInInteropName, ExecuteAsTool, _tlbimpPath,
                     BuildEngine, EnvironmentVariables);
 
                 // wrapper doesn't exist or needs regeneration? generate it then
                 if (!reference.FindExistingWrapper(out wrapperInfo, _timestampCache[referenceInfo.strippedTypeLibPath]))
                 {
                     if (!reference.GenerateWrapper(out wrapperInfo))
+                    {
                         return false;
+                    }
                 }
 
                 // if found or successfully generated, cache it.
@@ -1483,13 +1279,11 @@ internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outp
         /// <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
         internal bool ResolveComReferenceAx(ComReferenceInfo referenceInfo, string outputDirectory, string refName, out ComReferenceWrapperInfo wrapperInfo)
         {
-            wrapperInfo = null;
             string typeLibKey = ComReference.UniqueKeyFromTypeLibAttr(referenceInfo.attr);
 
             // look in the Ax cache first
-            if (_cacheAx.ContainsKey(typeLibKey))
+            if (_cacheAx.TryGetValue(typeLibKey, out wrapperInfo))
             {
-                wrapperInfo = (ComReferenceWrapperInfo)_cacheAx[typeLibKey];
                 return true;
             }
 
@@ -1497,13 +1291,15 @@ internal bool ResolveComReferenceAx(ComReferenceInfo referenceInfo, string outpu
             {
                 // not in the cache? see if anyone was kind enough to generate it for us
 
-                AxReference reference = new AxReference(Log, Silent, this, referenceInfo, refName, outputDirectory, DelaySign, KeyFile, KeyContainer, IncludeVersionInInteropName, _aximpPath, BuildEngine, EnvironmentVariables);
+                var reference = new AxReference(Log, Silent, this, referenceInfo, refName, outputDirectory, DelaySign, KeyFile, KeyContainer, IncludeVersionInInteropName, _aximpPath, BuildEngine, EnvironmentVariables);
 
                 // wrapper doesn't exist or needs regeneration? generate it then
                 if (!reference.FindExistingWrapper(out wrapperInfo, _timestampCache[referenceInfo.strippedTypeLibPath]))
                 {
                     if (!reference.GenerateWrapper(out wrapperInfo))
+                    {
                         return false;
+                    }
                 }
 
                 // if found or successfully generated, cache it.
@@ -1548,8 +1344,7 @@ internal static bool VerifyReferenceMetadataForNameItem(ITaskItem reference, out
             }
 
             // now verify they contain valid data
-            Guid guid;
-            if (!Guid.TryParse(reference.GetMetadata(ComReferenceItemMetadataNames.guid), out guid))
+            if (!Guid.TryParse(reference.GetMetadata(ComReferenceItemMetadataNames.guid), out _))
             {
                 // invalid guid format
                 missingOrInvalidMetadata = ComReferenceItemMetadataNames.guid;
@@ -1612,11 +1407,15 @@ internal static void InitializeDefaultMetadataForNameItem(ITaskItem reference)
         {
             // default value for lcid is 0
             if (reference.GetMetadata(ComReferenceItemMetadataNames.lcid).Length == 0)
+            {
                 reference.SetMetadata(ComReferenceItemMetadataNames.lcid, "0");
+            }
 
             // default value for wrapperTool is tlbimp
             if (reference.GetMetadata(ComReferenceItemMetadataNames.wrapperTool).Length == 0)
+            {
                 reference.SetMetadata(ComReferenceItemMetadataNames.wrapperTool, ComReferenceTypes.tlbimp);
+            }
         }
 
         /*
@@ -1628,7 +1427,9 @@ internal static void InitializeDefaultMetadataForFileItem(ITaskItem reference)
         {
             // default value for wrapperTool is tlbimp
             if (reference.GetMetadata(ComReferenceItemMetadataNames.wrapperTool).Length == 0)
+            {
                 reference.SetMetadata(ComReferenceItemMetadataNames.wrapperTool, ComReferenceTypes.tlbimp);
+            }
         }
 
         /*
@@ -1638,8 +1439,8 @@ internal static void InitializeDefaultMetadataForFileItem(ITaskItem reference)
          */
         internal bool CheckForConflictingReferences()
         {
-            Hashtable namesForReferences = new Hashtable();
-            ArrayList refsToBeRemoved = new ArrayList();
+            var namesForReferences = new Dictionary<string, ComReferenceInfo>(StringComparer.OrdinalIgnoreCase);
+            var refsToBeRemoved = new List<ComReferenceInfo>();
             bool noConflictsFound = true;
 
             for (int pass = 0; pass < 2; pass++)
@@ -1653,12 +1454,10 @@ internal bool CheckForConflictingReferences()
                         (pass == 1 && ComReferenceTypes.IsTlbImp(wrapperType)))
                     {
                         // if we already have a reference with this name, compare attributes
-                        if (namesForReferences.ContainsKey(projectRefInfo.typeLibName))
+                        if (namesForReferences.TryGetValue(projectRefInfo.typeLibName, out ComReferenceInfo conflictingRef))
                         {
                             // if different type lib attributes, we have a conflict, remove the conflicting reference
                             // and continue processing
-                            ComReferenceInfo conflictingRef = (ComReferenceInfo)namesForReferences[projectRefInfo.typeLibName];
-
                             if (!ComReference.AreTypeLibAttrEqual(projectRefInfo.attr, conflictingRef.attr))
                             {
                                 if (!Silent)
@@ -1699,7 +1498,7 @@ internal bool CheckForConflictingReferences()
         /// </summary>
         /// <param name="outputTaskItems">ArrayList of ITaskItems that will be outputted from the task</param>
         /// <param name="gacPath">The GAC root path</param>
-        internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(ArrayList outputTaskItems, string gacPath)
+        internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTaskItems, string gacPath)
         {
             foreach (ITaskItem taskItem in outputTaskItems)
             {
@@ -1773,7 +1572,7 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
 
             dependencyWalker.EncounteredProblems.Clear();
 
-            HashSet<string> dependentPaths = new HashSet<string>();
+            var dependentPaths = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
             TYPELIBATTR[] dependentAttrs = dependencyWalker.GetDependencies();
 
             foreach (TYPELIBATTR dependencyTypeLibAttr in dependentAttrs)
@@ -1781,17 +1580,13 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
                 // We don't need to even try to resolve if the dependency reference is ourselves. 
                 if (!ComReference.AreTypeLibAttrEqual(dependencyTypeLibAttr, reference.attr))
                 {
-                    ComReferenceInfo existingReference;
-
-                    if (IsExistingProjectReference(dependencyTypeLibAttr, null, out existingReference))
+                    if (IsExistingProjectReference(dependencyTypeLibAttr, null, out ComReferenceInfo existingReference))
                     {
-                        ITaskItem resolvedItem;
-
                         // If we're resolving another project reference, empty out the type cache -- if the dependencies are buried,
                         // caching the analyzed types can make it so that we don't recognize our dependencies' dependencies. 
                         dependencyWalker.ClearAnalyzedTypeCache();
 
-                        if (ResolveReference(dependencyWalker, existingReference, WrapperOutputDirectory, out resolvedItem))
+                        if (ResolveReference(dependencyWalker, existingReference, WrapperOutputDirectory, out ITaskItem resolvedItem))
                         {
                             // Add the resolved dependency
                             dependentPaths.Add(resolvedItem.ItemSpec);
@@ -1811,10 +1606,8 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
                                 dependencyTypeLibAttr.guid, dependencyTypeLibAttr.wMajorVerNum, dependencyTypeLibAttr.wMinorVerNum);
                         }
 
-                        ComReferenceWrapperInfo wrapperInfo;
-
                         ((IComReferenceResolver)this).ResolveComClassicReference(dependencyTypeLibAttr, WrapperOutputDirectory,
-                            null /* unknown wrapper type */, null /* unknown name */, out wrapperInfo);
+                            null /* unknown wrapper type */, null /* unknown name */, out ComReferenceWrapperInfo wrapperInfo);
 
                         if (!Silent)
                         {
@@ -1828,7 +1621,7 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
                 }
             }
 
-            return dependentPaths.ToList<string>();
+            return dependentPaths.ToList();
         }
 
         /*
@@ -1839,13 +1632,24 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
          */
         internal static TYPELIBATTR TaskItemToTypeLibAttr(ITaskItem taskItem)
         {
-            TYPELIBATTR attr = new TYPELIBATTR();
-
             // copy metadata from Reference to our TYPELIBATTR
-            attr.guid = new Guid(taskItem.GetMetadata(ComReferenceItemMetadataNames.guid));
-            attr.wMajorVerNum = short.Parse(taskItem.GetMetadata(ComReferenceItemMetadataNames.versionMajor), NumberStyles.Integer, CultureInfo.InvariantCulture);
-            attr.wMinorVerNum = short.Parse(taskItem.GetMetadata(ComReferenceItemMetadataNames.versionMinor), NumberStyles.Integer, CultureInfo.InvariantCulture);
-            attr.lcid = int.Parse(taskItem.GetMetadata(ComReferenceItemMetadataNames.lcid), NumberStyles.Integer, CultureInfo.InvariantCulture);
+            var attr = new TYPELIBATTR
+            {
+                guid = new Guid(taskItem.GetMetadata(ComReferenceItemMetadataNames.guid)),
+                wMajorVerNum = short.Parse(
+                    taskItem.GetMetadata(ComReferenceItemMetadataNames.versionMajor),
+                    NumberStyles.Integer,
+                    CultureInfo.InvariantCulture),
+                wMinorVerNum = short.Parse(
+                    taskItem.GetMetadata(ComReferenceItemMetadataNames.versionMinor),
+                    NumberStyles.Integer,
+                    CultureInfo.InvariantCulture),
+                lcid = int.Parse(
+                    taskItem.GetMetadata(ComReferenceItemMetadataNames.lcid),
+                    NumberStyles.Integer,
+                    CultureInfo.InvariantCulture)
+            };
+
             return attr;
         }
 
diff --git a/src/Tasks/ResolveComReferenceCache.cs b/src/Tasks/ResolveComReferenceCache.cs
index 56e7b3292c1..d0f80dca18f 100644
--- a/src/Tasks/ResolveComReferenceCache.cs
+++ b/src/Tasks/ResolveComReferenceCache.cs
@@ -3,12 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Diagnostics;
-using System.IO;
-using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters.Binary;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
@@ -19,8 +13,10 @@ namespace Microsoft.Build.Tasks
     /// an earlier revision of a COM component, its timestamp can go back in time and we still need to regenerate its
     /// wrapper. So in ResolveComReference we compare the stored timestamp with the current component timestamp, and if 
     /// they are different, we regenerate the wrapper.
+    /// 
+    /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
-    [Serializable()]
+    [Serializable]
     internal sealed class ResolveComReferenceCache : StateFileBase
     {
         /// <summary>
@@ -28,29 +24,25 @@ internal sealed class ResolveComReferenceCache : StateFileBase
         /// Key: Component path on disk
         /// Value: DateTime struct
         /// </summary>
-        private Hashtable componentTimestamps = null;
-        private string tlbImpLocation = null;
-        private string axImpLocation = null;
+        private Hashtable componentTimestamps;
+        private string tlbImpLocation;
+        private string axImpLocation;
 
         /// <summary>
         /// indicates whether the cache contents have changed since it's been created
         /// </summary>
-        internal bool Dirty
-        {
-            get { return dirty; }
-        }
-
-
+        internal bool Dirty => _dirty;
+        
         [NonSerialized]
-        private bool dirty;
+        private bool _dirty;
 
         /// <summary>
         /// Construct.
         /// </summary>
         internal ResolveComReferenceCache(string tlbImpPath, string axImpPath)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(tlbImpPath, "tlbImpPath");
-            ErrorUtilities.VerifyThrowArgumentNull(axImpPath, "axImpPath");
+            ErrorUtilities.VerifyThrowArgumentNull(tlbImpPath, nameof(tlbImpPath));
+            ErrorUtilities.VerifyThrowArgumentNull(axImpPath, nameof(axImpPath));
 
             tlbImpLocation = tlbImpPath;
             axImpLocation = axImpPath;
@@ -64,7 +56,8 @@ internal ResolveComReferenceCache(string tlbImpPath, string axImpPath)
         /// <returns>True if both paths match what is in the cache, false otherwise</returns>
         internal bool ToolPathsMatchCachePaths(string tlbImpPath, string axImpPath)
         {
-            return (String.Equals(tlbImpLocation, tlbImpPath, StringComparison.OrdinalIgnoreCase)) && (String.Equals(axImpLocation, axImpPath, StringComparison.OrdinalIgnoreCase));
+            return String.Equals(tlbImpLocation, tlbImpPath, StringComparison.OrdinalIgnoreCase) &&
+                String.Equals(axImpLocation, axImpPath, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -80,12 +73,10 @@ internal DateTime this[string componentPath]
                 {
                     return (DateTime)componentTimestamps[componentPath];
                 }
-                else
-                {
-                    // If the entry is not present in the cache, return the current time. Since no component should be timestamped
-                    // with the current time, this will effectively always regenerate the wrapper.
-                    return DateTime.Now;
-                }
+
+                // If the entry is not present in the cache, return the current time. Since no component should be timestamped
+                // with the current time, this will effectively always regenerate the wrapper.
+                return DateTime.Now;
             }
             set
             {
@@ -93,7 +84,7 @@ internal DateTime this[string componentPath]
                 if (DateTime.Compare(this[componentPath], value) != 0)
                 {
                     componentTimestamps[componentPath] = value;
-                    dirty = true;
+                    _dirty = true;
                 }
             }
         }
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index 847ffedfa8c..4f2041ecbe3 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Globalization;
 using System.IO;
-using System.Collections;
 using System.Security.Cryptography;
 using System.Security.Cryptography.X509Certificates;
 
@@ -21,89 +20,36 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class ResolveKeySource : TaskExtension
     {
-        private string _keyFile;
-        private string _certificateThumbprint;
-        private string _certificateFile;
-        private string _resolvedKeyContainer = String.Empty;
-        private string _resolvedKeyFile = String.Empty;
-        private string _resolvedThumbprint = String.Empty;
         private const string pfxFileExtension = ".pfx";
         private const string pfxFileContainerPrefix = "VS_KEY_";
-        private bool _suppressAutoClosePasswordPrompt = false;
-        private bool _showImportDialogDespitePreviousFailures = false;
-        private int _autoClosePasswordPromptTimeout = 20;
-        private int _autoClosePasswordPromptShow = 15;
-        static private Hashtable s_pfxKeysToIgnore = new Hashtable(StringComparer.OrdinalIgnoreCase);
-
-
+        
         #region Properties
 
-        public string KeyFile
-        {
-            get { return _keyFile; }
-            set { _keyFile = value; }
-        }
+        public string KeyFile { get; set; }
 
-        public string CertificateThumbprint
-        {
-            get { return _certificateThumbprint; }
-            set { _certificateThumbprint = value; }
-        }
+        public string CertificateThumbprint { get; set; }
 
-        public string CertificateFile
-        {
-            get { return _certificateFile; }
-            set { _certificateFile = value; }
-        }
+        public string CertificateFile { get; set; }
 
-        public bool SuppressAutoClosePasswordPrompt
-        {
-            get { return _suppressAutoClosePasswordPrompt; }
-            set { _suppressAutoClosePasswordPrompt = value; }
-        }
+        public bool SuppressAutoClosePasswordPrompt { get; set; } = false;
 
-        public bool ShowImportDialogDespitePreviousFailures
-        {
-            get { return _showImportDialogDespitePreviousFailures; }
-            set { _showImportDialogDespitePreviousFailures = value; }
-        }
+        public bool ShowImportDialogDespitePreviousFailures { get; set; } = false;
 
-        public int AutoClosePasswordPromptTimeout
-        {
-            get { return _autoClosePasswordPromptTimeout; }
-            set { _autoClosePasswordPromptTimeout = value; }
-        }
+        public int AutoClosePasswordPromptTimeout { get; set; } = 20;
 
-        public int AutoClosePasswordPromptShow
-        {
-            get { return _autoClosePasswordPromptShow; }
-            set { _autoClosePasswordPromptShow = value; }
-        }
+        public int AutoClosePasswordPromptShow { get; set; } = 15;
 
         [Output]
-        public string ResolvedThumbprint
-        {
-            get { return _resolvedThumbprint; }
-            set { _resolvedThumbprint = value; }
-        }
+        public string ResolvedThumbprint { get; set; } = String.Empty;
 
         [Output]
-        public string ResolvedKeyContainer
-        {
-            get { return _resolvedKeyContainer; }
-            set { _resolvedKeyContainer = value; }
-        }
+        public string ResolvedKeyContainer { get; set; } = String.Empty;
 
         [Output]
-        public string ResolvedKeyFile
-        {
-            get { return _resolvedKeyFile; }
-            set { _resolvedKeyFile = value; }
-        }
+        public string ResolvedKeyFile { get; set; } = String.Empty;
 
         #endregion
 
-
         #region ITask Members
 
         public override bool Execute()
@@ -118,7 +64,7 @@ public override bool Execute()
         // hash would give good enough results. This code needs to be kept in sync with the code  in compsvcpkgs
         // to prevent double prompt for newly created keys. The magic numbers here are just random primes
         // in the range 10m/20m.
-        static private UInt64 HashFromBlob(byte[] data)
+        private static UInt64 HashFromBlob(byte[] data)
         {
             UInt32 dw1 = 17339221;
             UInt32 dw2 = 19619429;
@@ -141,7 +87,7 @@ static private UInt64 HashFromBlob(byte[] data)
         private bool ResolveAssemblyKey()
         {
             bool pfxSuccess = true;
-            if (KeyFile != null && KeyFile.Length > 0)
+            if (!string.IsNullOrEmpty(KeyFile))
             {
                 string keyFileExtension = String.Empty;
                 try
@@ -164,10 +110,9 @@ private bool ResolveAssemblyKey()
 #if FEATURE_PFX_SIGNING
                         pfxSuccess = false;
                         // it is .pfx file. It is being imported into key container with name = "VS_KEY_<MD5 check sum of the encrypted file>"
-                        System.IO.FileStream fs = null;
+                        FileStream fs = null;
                         try
                         {
-                            string hashedContainerName = String.Empty;
                             string currentUserName = Environment.UserDomainName + "\\" + Environment.UserName;
                             // we use the curent user name to randomize the associated container name, i.e different user on the same machine will export to different keys
                             // this is because SNAPI by default will create keys in "per-machine" crypto store (visible for all the user) but will set the permission such only
@@ -175,30 +120,24 @@ private bool ResolveAssemblyKey()
                             // Now different users will use different container name. We use ToLower(invariant) because this is what the native equivalent of this function (Create new key, or VC++ import-er).
                             // use as well and we want to keep the hash (and key container name the same) otherwise user could be prompt for a password twice.
                             byte[] userNameBytes = System.Text.Encoding.Unicode.GetBytes(currentUserName.ToLower(CultureInfo.InvariantCulture));
-                            fs = System.IO.File.OpenRead(KeyFile);
+                            fs = File.OpenRead(KeyFile);
                             int fileLength = (int)fs.Length;
-                            byte[] keyBytes = new byte[fileLength];
+                            var keyBytes = new byte[fileLength];
                             fs.Read(keyBytes, 0, fileLength);
 
                             UInt64 hash = HashFromBlob(keyBytes);
                             hash ^= HashFromBlob(userNameBytes); // modify it with the username hash, so each user would get different hash for the same key
 
-                            hashedContainerName = pfxFileContainerPrefix + hash.ToString("X016", CultureInfo.InvariantCulture);
+                            string hashedContainerName = pfxFileContainerPrefix + hash.ToString("X016", CultureInfo.InvariantCulture);
 
-                            IntPtr publicKeyBlob = IntPtr.Zero;
-                            int publicKeyBlobSize = 0;
-                            if (StrongNameHelpers.StrongNameGetPublicKey(hashedContainerName, IntPtr.Zero, 0, out publicKeyBlob, out publicKeyBlobSize) && publicKeyBlob != IntPtr.Zero)
+                            if (StrongNameHelpers.StrongNameGetPublicKey(hashedContainerName, IntPtr.Zero, 0, out IntPtr publicKeyBlob, out _) && publicKeyBlob != IntPtr.Zero)
                             {
                                 StrongNameHelpers.StrongNameFreeBuffer(publicKeyBlob);
                                 pfxSuccess = true;
                             }
                             else
                             {
-                                if (ShowImportDialogDespitePreviousFailures || !s_pfxKeysToIgnore.Contains(hashedContainerName))
-                                {
-                                    Log.LogErrorWithCodeFromResources("ResolveKeySource.KeyFileForSignAssemblyNotImported", KeyFile, hashedContainerName);
-                                }
-
+                                Log.LogErrorWithCodeFromResources("ResolveKeySource.KeyFileForSignAssemblyNotImported", KeyFile, hashedContainerName);
                                 Log.LogErrorWithCodeFromResources("ResolveKeySource.KeyImportError", KeyFile);
                             }
                             if (pfxSuccess)
@@ -212,10 +151,7 @@ private bool ResolveAssemblyKey()
                         }
                         finally
                         {
-                            if (fs != null)
-                            {
-                                fs.Close();
-                            }
+                            fs?.Close();
                         }
 #else
                         Log.LogError("PFX signing not supported on .NET Core");
@@ -235,7 +171,7 @@ private bool ResolveManifestKey()
             if (!string.IsNullOrEmpty(CertificateThumbprint))
             {
                 // look for cert in the cert store
-                X509Store personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
+                var personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
                 try
                 {
                     personalStore.Open(OpenFlags.ReadWrite);
@@ -276,8 +212,8 @@ private bool ResolveManifestKey()
                     {
                         bool imported = false;
                         // first try it with no password
-                        X509Certificate2 cert = new X509Certificate2();
-                        X509Store personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
+                        var cert = new X509Certificate2();
+                        var personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
                         try
                         {
                             personalStore.Open(OpenFlags.ReadWrite);
@@ -306,10 +242,10 @@ private bool ResolveManifestKey()
                     }
                     else
                     {
-                        X509Store personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
+                        var personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
                         try
                         {
-                            X509Certificate2 cert = new X509Certificate2(CertificateFile);
+                            var cert = new X509Certificate2(CertificateFile);
                             personalStore.Open(OpenFlags.ReadWrite);
                             personalStore.Add(cert);
                             ResolvedThumbprint = cert.Thumbprint;
@@ -333,10 +269,11 @@ private bool ResolveManifestKey()
             {
                 // no file and not in store, error out
                 Log.LogErrorWithCodeFromResources("ResolveKeySource.CertificateNotInStore");
-                certSuccess = false;
             }
             else
+            {
                 certSuccess = true;
+            }
 
             return certSuccess;
         }
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 818021d99f3..8ba560eba27 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -9,7 +9,6 @@
 using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -36,22 +35,16 @@ namespace Microsoft.Build.Tasks
     public sealed class ResolveManifestFiles : TaskExtension
     {
         #region Fields
-        private ITaskItem _deploymentManifestEntryPoint = null;
-        private ITaskItem _entryPoint;
+
         private ITaskItem[] _extraFiles;
         private ITaskItem[] _files;
         private ITaskItem[] _managedAssemblies;
         private ITaskItem[] _nativeAssemblies;
-        private ITaskItem[] _outputAssemblies;
-        private ITaskItem _outputDeploymentManifestEntryPoint = null;
-        private ITaskItem _outputEntryPoint = null;
-        private ITaskItem[] _outputFiles;
         private ITaskItem[] _publishFiles;
         private ITaskItem[] _satelliteAssemblies;
-        private string _specifiedTargetCulture;
-        private CultureInfo _targetCulture = null;
-        private bool _includeAllSatellites = false;
-        private bool _signingManifests = false;
+        private CultureInfo _targetCulture;
+        private bool _includeAllSatellites;
+
         private string _targetFrameworkVersion;
         // if signing manifests is on and not all app files are included, then the project can't be published.
         private bool _canPublish;
@@ -59,127 +52,91 @@ public sealed class ResolveManifestFiles : TaskExtension
 
         #region Properties
 
-        public ITaskItem DeploymentManifestEntryPoint
-        {
-            get { return _deploymentManifestEntryPoint; }
-            set { _deploymentManifestEntryPoint = value; }
-        }
+        public ITaskItem DeploymentManifestEntryPoint { get; set; }
 
-        public ITaskItem EntryPoint
-        {
-            get { return _entryPoint; }
-            set { _entryPoint = value; }
-        }
+        public ITaskItem EntryPoint { get; set; }
 
         public ITaskItem[] ExtraFiles
         {
-            get { return _extraFiles; }
-            set { _extraFiles = Util.SortItems(value); }
+            get => _extraFiles;
+            set => _extraFiles = Util.SortItems(value);
         }
 
         public ITaskItem[] Files
         {
-            get { return _files; }
-            set { _files = Util.SortItems(value); }
+            get => _files;
+            set => _files = Util.SortItems(value);
         }
 
         public ITaskItem[] ManagedAssemblies
         {
-            get { return _managedAssemblies; }
-            set { _managedAssemblies = Util.SortItems(value); }
+            get => _managedAssemblies;
+            set => _managedAssemblies = Util.SortItems(value);
         }
 
         public ITaskItem[] NativeAssemblies
         {
-            get { return _nativeAssemblies; }
-            set { _nativeAssemblies = Util.SortItems(value); }
+            get => _nativeAssemblies;
+            set => _nativeAssemblies = Util.SortItems(value);
         }
 
         [Output]
-        public ITaskItem[] OutputAssemblies
-        {
-            get { return _outputAssemblies; }
-            set { _outputAssemblies = value; }
-        }
+        public ITaskItem[] OutputAssemblies { get; set; }
 
         [Output]
-        public ITaskItem OutputDeploymentManifestEntryPoint
-        {
-            get { return _outputDeploymentManifestEntryPoint; }
-            set { _outputDeploymentManifestEntryPoint = value; }
-        }
+        public ITaskItem OutputDeploymentManifestEntryPoint { get; set; }
 
         [Output]
-        public ITaskItem OutputEntryPoint
-        {
-            get { return _outputEntryPoint; }
-            set { _outputEntryPoint = value; }
-        }
+        public ITaskItem OutputEntryPoint { get; set; }
 
         [Output]
-        public ITaskItem[] OutputFiles
-        {
-            get { return _outputFiles; }
-            set { _outputFiles = value; }
-        }
+        public ITaskItem[] OutputFiles { get; set; }
 
         public ITaskItem[] PublishFiles
         {
-            get { return _publishFiles; }
-            set { _publishFiles = Util.SortItems(value); }
+            get => _publishFiles;
+            set => _publishFiles = Util.SortItems(value);
         }
 
         public ITaskItem[] SatelliteAssemblies
         {
-            get { return _satelliteAssemblies; }
-            set { _satelliteAssemblies = Util.SortItems(value); }
+            get => _satelliteAssemblies;
+            set => _satelliteAssemblies = Util.SortItems(value);
         }
 
-        public string TargetCulture
-        {
-            get { return _specifiedTargetCulture; }
-            set { _specifiedTargetCulture = value; }
-        }
+        public string TargetCulture { get; set; }
 
-        public bool SigningManifests
-        {
-            get { return _signingManifests; }
-            set { _signingManifests = value; }
-        }
+        public bool SigningManifests { get; set; }
 
         public string TargetFrameworkVersion
         {
             get
             {
                 if (string.IsNullOrEmpty(_targetFrameworkVersion))
+                {
                     return Constants.TargetFrameworkVersion35;
+                }
                 return _targetFrameworkVersion;
             }
-            set { _targetFrameworkVersion = value; }
+            set => _targetFrameworkVersion = value;
         }
 
         #endregion
 
-        public ResolveManifestFiles()
-        {
-        }
-
         public override bool Execute()
         {
             if (!ValidateInputs())
+            {
                 return false;
+            }
 
             // if signing manifests is on and not all app files are included, then the project can't be published.
             _canPublish = true;
             bool is35Project = (CompareFrameworkVersions(TargetFrameworkVersion, Constants.TargetFrameworkVersion35) >= 0);
 
-            PublishInfo[] assemblyPublishInfoList;
-            PublishInfo[] filePublishInfoList;
-            PublishInfo[] satellitePublishInfoList;
-            PublishInfo[] manifestEntryPointList;
-            GetPublishInfo(out assemblyPublishInfoList, out filePublishInfoList, out satellitePublishInfoList, out manifestEntryPointList);
+            GetPublishInfo(out List<PublishInfo> assemblyPublishInfoList, out List<PublishInfo> filePublishInfoList, out List<PublishInfo> satellitePublishInfoList, out List<PublishInfo> manifestEntryPointList);
 
-            _outputAssemblies = GetOutputAssembliesAndSatellites(assemblyPublishInfoList, satellitePublishInfoList);
+            OutputAssemblies = GetOutputAssembliesAndSatellites(assemblyPublishInfoList, satellitePublishInfoList);
 
             if (!_canPublish && is35Project)
             {
@@ -187,7 +144,7 @@ public override bool Execute()
                 return false;
             }
 
-            _outputFiles = GetOutputFiles(filePublishInfoList);
+            OutputFiles = GetOutputFiles(filePublishInfoList);
 
             if (!_canPublish && is35Project)
             {
@@ -195,7 +152,7 @@ public override bool Execute()
                 return false;
             }
 
-            _outputEntryPoint = GetOutputEntryPoint(_entryPoint, manifestEntryPointList);
+            OutputEntryPoint = GetOutputEntryPoint(EntryPoint, manifestEntryPointList);
 
             if (!_canPublish && is35Project)
             {
@@ -203,7 +160,7 @@ public override bool Execute()
                 return false;
             }
 
-            _outputDeploymentManifestEntryPoint = GetOutputEntryPoint(_deploymentManifestEntryPoint, manifestEntryPointList);
+            OutputDeploymentManifestEntryPoint = GetOutputEntryPoint(DeploymentManifestEntryPoint, manifestEntryPointList);
 
             if (!_canPublish && is35Project)
             {
@@ -214,7 +171,7 @@ public override bool Execute()
             return true;
         }
 
-        private Version ConvertFrameworkVersionToString(string version)
+        private static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
             {
@@ -223,7 +180,7 @@ private Version ConvertFrameworkVersionToString(string version)
             return new Version(version);
         }
 
-        private int CompareFrameworkVersions(string versionA, string versionB)
+        private static int CompareFrameworkVersions(string versionA, string versionB)
         {
             Version version1 = ConvertFrameworkVersionToString(versionA);
             Version version2 = ConvertFrameworkVersionToString(versionB);
@@ -232,17 +189,17 @@ private int CompareFrameworkVersions(string versionA, string versionB)
 
         private bool ValidateInputs()
         {
-            if (!String.IsNullOrEmpty(_specifiedTargetCulture))
+            if (!String.IsNullOrEmpty(TargetCulture))
             {
-                if (String.Equals(_specifiedTargetCulture, "*", StringComparison.Ordinal))
+                if (String.Equals(TargetCulture, "*", StringComparison.Ordinal))
                 {
                     _includeAllSatellites = true;
                 }
-                else if (!String.Equals(_specifiedTargetCulture, "neutral", StringComparison.Ordinal))
+                else if (!String.Equals(TargetCulture, "neutral", StringComparison.Ordinal))
                 {
                     try
                     {
-                        _targetCulture = new CultureInfo(_specifiedTargetCulture);
+                        _targetCulture = new CultureInfo(TargetCulture);
                     }
                     catch (ArgumentException)
                     {
@@ -254,7 +211,6 @@ private bool ValidateInputs()
             return true;
         }
 
-
         #region Helpers
 
         // Creates an output item for a an assembly, with optional Group attribute.
@@ -264,12 +220,19 @@ private static ITaskItem CreateAssemblyItem(ITaskItem item, string group, string
             item.CopyMetadataTo(outputItem);
             outputItem.SetMetadata("DependencyType", "Install");
             if (String.IsNullOrEmpty(targetPath))
+            {
                 targetPath = GetItemTargetPath(outputItem);
+            }
             outputItem.SetMetadata(ItemMetadataNames.targetPath, targetPath);
             if (!String.IsNullOrEmpty(group))
+            {
                 outputItem.SetMetadata("Group", group);
+            }
+
             if (!String.IsNullOrEmpty(includeHash))
+            {
                 outputItem.SetMetadata("IncludeHash", includeHash);
+            }
             return outputItem;
         }
 
@@ -279,12 +242,19 @@ private static ITaskItem CreateFileItem(ITaskItem item, string group, string tar
             ITaskItem outputItem = new TaskItem(item.ItemSpec);
             item.CopyMetadataTo(outputItem);
             if (String.IsNullOrEmpty(targetPath))
+            {
                 targetPath = GetItemTargetPath(outputItem);
+            }
             outputItem.SetMetadata(ItemMetadataNames.targetPath, targetPath);
             if (!String.IsNullOrEmpty(group) && !isDataFile)
+            {
                 outputItem.SetMetadata("Group", group);
+            }
+
             if (!String.IsNullOrEmpty(includeHash))
+            {
                 outputItem.SetMetadata("IncludeHash", includeHash);
+            }
 
             outputItem.SetMetadata("IsDataFile", isDataFile.ToString().ToLowerInvariant());
             return outputItem;
@@ -303,9 +273,10 @@ private static bool GetItemCopyLocal(ITaskItem item)
         {
             string copyLocal = item.GetMetadata(ItemMetadataNames.copyLocal);
             if (!String.IsNullOrEmpty(copyLocal))
+            {
                 return ConvertUtil.ToBoolean(copyLocal);
-            else
-                return true; // always return true if item does not have a CopyLocal attribute
+            }
+            return true; // always return true if item does not have a CopyLocal attribute
         }
 
         // Returns the culture for the specified item, first by looking for an attribute and if not found
@@ -336,41 +307,55 @@ private static string GetItemTargetPath(ITaskItem item)
                 {
                     CultureInfo itemCulture = GetItemCulture(item);
                     if (itemCulture != null)
+                    {
                         targetPath = Path.Combine(itemCulture.ToString(), targetPath);
+                    }
                 }
             }
             return targetPath;
         }
 
-        private void GetOutputAssemblies(PublishInfo[] publishInfos, ref List<ITaskItem> assemblyList)
+        private void GetOutputAssemblies(List<PublishInfo> publishInfos, ref List<ITaskItem> assemblyList)
         {
-            AssemblyMap assemblyMap = new AssemblyMap();
+            var assemblyMap = new AssemblyMap();
 
             // Add all managed assemblies to the AssemblyMap, except assemblies that are part of the .NET Framework...
             if (_managedAssemblies != null)
+            {
                 foreach (ITaskItem item in _managedAssemblies)
+                {
                     if (!IsFiltered(item))
                     {
                         item.SetMetadata("AssemblyType", "Managed");
                         assemblyMap.Add(item);
                     }
+                }
+            }
 
             if (_nativeAssemblies != null)
+            {
                 foreach (ITaskItem item in _nativeAssemblies)
+                {
                     if (!IsFiltered(item))
                     {
                         item.SetMetadata("AssemblyType", "Native");
                         assemblyMap.Add(item);
                     }
+                }
+            }
 
             // Apply PublishInfo state from PublishFile items...
             foreach (PublishInfo publishInfo in publishInfos)
             {
                 MapEntry entry = assemblyMap[publishInfo.key];
                 if (entry != null)
+                {
                     entry.publishInfo = publishInfo;
+                }
                 else
+                {
                     Log.LogWarningWithCodeFromResources("ResolveManifestFiles.PublishFileNotFound", publishInfo.key);
+                }
             }
 
             // Go through the AssemblyMap and determine which items get added to ouput AssemblyList based
@@ -379,7 +364,9 @@ private void GetOutputAssemblies(PublishInfo[] publishInfos, ref List<ITaskItem>
             {
                 // If PublishInfo didn't come from a PublishFile item, then construct PublishInfo from the item
                 if (entry.publishInfo == null)
+                {
                     entry.publishInfo = new PublishInfo();
+                }
 
                 // If state is auto then also need to look on the item to see whether the dependency type
                 // has alread been specified upstream (i.e. from ResolveNativeReference task)...
@@ -387,9 +374,13 @@ private void GetOutputAssemblies(PublishInfo[] publishInfos, ref List<ITaskItem>
                 {
                     string dependencyType = entry.item.GetMetadata("DependencyType");
                     if (String.Equals(dependencyType, "Prerequisite", StringComparison.Ordinal))
+                    {
                         entry.publishInfo.state = PublishState.Prerequisite;
+                    }
                     else if (String.Equals(dependencyType, "Install", StringComparison.Ordinal))
+                    {
                         entry.publishInfo.state = PublishState.Include;
+                    }
                 }
 
                 bool copyLocal = GetItemCopyLocal(entry.item);
@@ -397,47 +388,65 @@ private void GetOutputAssemblies(PublishInfo[] publishInfos, ref List<ITaskItem>
 
                 if (flags.IsPublished &&
                     string.Equals(entry.publishInfo.includeHash, "false", StringComparison.OrdinalIgnoreCase) &&
-                    SigningManifests == true)
+                    SigningManifests)
+                {
                     _canPublish = false;
+                }
 
                 if (flags.IsPublished)
+                {
                     assemblyList.Add(CreateAssemblyItem(entry.item, entry.publishInfo.group, entry.publishInfo.targetPath, entry.publishInfo.includeHash));
+                }
                 else if (flags.IsPrerequisite)
+                {
                     assemblyList.Add(CreatePrerequisiteItem(entry.item));
+                }
             }
         }
 
-        private ITaskItem[] GetOutputAssembliesAndSatellites(PublishInfo[] assemblyPublishInfos, PublishInfo[] satellitePublishInfos)
+        private ITaskItem[] GetOutputAssembliesAndSatellites(List<PublishInfo> assemblyPublishInfos, List<PublishInfo> satellitePublishInfos)
         {
-            List<ITaskItem> assemblyList = new List<ITaskItem>();
+            var assemblyList = new List<ITaskItem>();
             GetOutputAssemblies(assemblyPublishInfos, ref assemblyList);
             GetOutputSatellites(satellitePublishInfos, ref assemblyList);
             return assemblyList.ToArray();
         }
 
-        private ITaskItem[] GetOutputFiles(PublishInfo[] publishInfos)
+        private ITaskItem[] GetOutputFiles(List<PublishInfo> publishInfos)
         {
-            List<ITaskItem> fileList = new List<ITaskItem>();
-            FileMap fileMap = new FileMap();
+            var fileList = new List<ITaskItem>();
+            var fileMap = new FileMap();
 
             // Add all input Files to the FileMap, flagging them to be published by default...
             if (Files != null)
+            {
                 foreach (ITaskItem item in Files)
+                {
                     fileMap.Add(item, true);
+                }
+            }
 
             // Add all input ExtraFiles to the FileMap, flagging them to NOT be published by default...
             if (ExtraFiles != null)
+            {
                 foreach (ITaskItem item in ExtraFiles)
+                {
                     fileMap.Add(item, false);
+                }
+            }
 
             // Apply PublishInfo state from PublishFile items...
             foreach (PublishInfo publishInfo in publishInfos)
             {
                 MapEntry entry = fileMap[publishInfo.key];
                 if (entry != null)
+                {
                     entry.publishInfo = publishInfo;
+                }
                 else
+                {
                     Log.LogWarningWithCodeFromResources("ResolveManifestFiles.PublishFileNotFound", publishInfo.key);
+                }
             }
 
             // Go through the FileMap and determine which items get added to ouput FileList based
@@ -446,33 +455,41 @@ private ITaskItem[] GetOutputFiles(PublishInfo[] publishInfos)
             {
                 // If PublishInfo didn't come from a PublishFile item, then construct PublishInfo from the item
                 if (entry.publishInfo == null)
+                {
                     entry.publishInfo = new PublishInfo();
+                }
 
                 string fileExtension = Path.GetExtension(entry.item.ItemSpec);
                 PublishFlags flags = PublishFlags.GetFileFlags(entry.publishInfo.state, fileExtension, entry.includedByDefault);
 
                 if (flags.IsPublished &&
                     string.Equals(entry.publishInfo.includeHash, "false", StringComparison.OrdinalIgnoreCase) &&
-                    SigningManifests == true)
+                    SigningManifests)
+                {
                     _canPublish = false;
+                }
 
                 if (flags.IsPublished)
+                {
                     fileList.Add(CreateFileItem(entry.item, entry.publishInfo.group, entry.publishInfo.targetPath, entry.publishInfo.includeHash, flags.IsDataFile));
+                }
             }
 
             return fileList.ToArray();
         }
 
-        private void GetOutputSatellites(PublishInfo[] publishInfos, ref List<ITaskItem> assemblyList)
+        private void GetOutputSatellites(List<PublishInfo> publishInfos, ref List<ITaskItem> assemblyList)
         {
-            FileMap satelliteMap = new FileMap();
+            var satelliteMap = new FileMap();
 
             if (_satelliteAssemblies != null)
+            {
                 foreach (ITaskItem item in _satelliteAssemblies)
                 {
                     item.SetMetadata("AssemblyType", "Satellite");
                     satelliteMap.Add(item, true);
                 }
+            }
 
             // Apply PublishInfo state from PublishFile items...
             foreach (PublishInfo publishInfo in publishInfos)
@@ -480,9 +497,13 @@ private void GetOutputSatellites(PublishInfo[] publishInfos, ref List<ITaskItem>
                 string key = publishInfo.key + ".dll";
                 MapEntry entry = satelliteMap[key];
                 if (entry != null)
+                {
                     entry.publishInfo = publishInfo;
+                }
                 else
+                {
                     Log.LogWarningWithCodeFromResources("ResolveManifestFiles.PublishFileNotFound", publishInfo.key);
+                }
             }
 
             // Go through the AssemblyMap and determine which items get added to ouput SatelliteList based
@@ -500,8 +521,10 @@ private void GetOutputSatellites(PublishInfo[] publishInfos, ref List<ITaskItem>
 
                 if (flags.IsPublished &&
                     string.Equals(entry.publishInfo.includeHash, "false", StringComparison.OrdinalIgnoreCase) &&
-                    SigningManifests == true)
+                    SigningManifests)
+                {
                     _canPublish = false;
+                }
 
                 if (flags.IsPublished)
                 {
@@ -514,27 +537,32 @@ private void GetOutputSatellites(PublishInfo[] publishInfos, ref List<ITaskItem>
             }
         }
 
-        private ITaskItem GetOutputEntryPoint(ITaskItem entryPoint, PublishInfo[] manifestEntryPointList)
+        private ITaskItem GetOutputEntryPoint(ITaskItem entryPoint, List<PublishInfo> manifestEntryPointList)
         {
             if (entryPoint == null)
             {
                 return null;
             }
-            TaskItem outputEntryPoint = new TaskItem(entryPoint.ItemSpec);
+            var outputEntryPoint = new TaskItem(entryPoint.ItemSpec);
             entryPoint.CopyMetadataTo(outputEntryPoint);
             string targetPath = entryPoint.GetMetadata("TargetPath");
             if (!string.IsNullOrEmpty(targetPath))
             {
-                for (int i = 0; i < manifestEntryPointList.Length; i++)
+                for (int i = 0; i < manifestEntryPointList.Count; i++)
                 {
                     if (String.Equals(targetPath, manifestEntryPointList[i].key, StringComparison.OrdinalIgnoreCase))
                     {
                         if (!string.IsNullOrEmpty(manifestEntryPointList[i].includeHash))
                         {
                             if (manifestEntryPointList[i].state != PublishState.Exclude &&
-                                string.Equals(manifestEntryPointList[i].includeHash, "false", StringComparison.OrdinalIgnoreCase) &&
-                                SigningManifests == true)
+                                string.Equals(
+                                    manifestEntryPointList[i].includeHash,
+                                    "false",
+                                    StringComparison.OrdinalIgnoreCase) &&
+                                SigningManifests)
+                            {
                                 _canPublish = false;
+                            }
                             outputEntryPoint.SetMetadata("IncludeHash", manifestEntryPointList[i].includeHash);
                         }
                         return outputEntryPoint;
@@ -545,47 +573,44 @@ private ITaskItem GetOutputEntryPoint(ITaskItem entryPoint, PublishInfo[] manife
             return outputEntryPoint;
         }
 
-        // Returns PublishFile items seperated into seperate arrays by FileType attribute.
+        // Returns PublishFile items separated into separate arrays by FileType attribute.
         private void GetPublishInfo(
-            out PublishInfo[] assemblyPublishInfos,
-            out PublishInfo[] filePublishInfos,
-            out PublishInfo[] satellitePublishInfos,
-            out PublishInfo[] manifestEntryPointPublishInfos)
+            out List<PublishInfo> assemblyPublishInfos,
+            out List<PublishInfo> filePublishInfos,
+            out List<PublishInfo> satellitePublishInfos,
+            out List<PublishInfo> manifestEntryPointPublishInfos)
         {
-            List<PublishInfo> assemblyList = new List<PublishInfo>();
-            List<PublishInfo> fileList = new List<PublishInfo>();
-            List<PublishInfo> satelliteList = new List<PublishInfo>();
-            List<PublishInfo> manifestEntryPointList = new List<PublishInfo>();
+            assemblyPublishInfos = new List<PublishInfo>();
+            filePublishInfos = new List<PublishInfo>();
+            satellitePublishInfos = new List<PublishInfo>();
+            manifestEntryPointPublishInfos = new List<PublishInfo>();
 
             if (PublishFiles != null)
+            {
                 foreach (ITaskItem item in PublishFiles)
                 {
-                    PublishInfo publishInfo = new PublishInfo(item);
+                    var publishInfo = new PublishInfo(item);
                     string fileType = item.GetMetadata("FileType");
                     switch (fileType)
                     {
                         case "Assembly":
-                            assemblyList.Add(publishInfo);
+                            assemblyPublishInfos.Add(publishInfo);
                             break;
                         case "File":
-                            fileList.Add(publishInfo);
+                            filePublishInfos.Add(publishInfo);
                             break;
                         case "Satellite":
-                            satelliteList.Add(publishInfo);
+                            satellitePublishInfos.Add(publishInfo);
                             break;
                         case "ManifestEntryPoint":
-                            manifestEntryPointList.Add(publishInfo);
+                            manifestEntryPointPublishInfos.Add(publishInfo);
                             break;
                         default:
                             Log.LogWarningWithCodeFromResources("GenerateManifest.InvalidItemValue", "FileType", item.ItemSpec);
                             continue;
                     }
                 }
-
-            assemblyPublishInfos = assemblyList.ToArray();
-            filePublishInfos = fileList.ToArray();
-            satellitePublishInfos = satelliteList.ToArray();
-            manifestEntryPointPublishInfos = manifestEntryPointList.ToArray();
+            }
         }
 
         private bool IsFiltered(ITaskItem item)
@@ -605,8 +630,7 @@ private bool IsFiltered(ITaskItem item)
             string str = item.GetMetadata("IsRedistRoot");
             if (!String.IsNullOrEmpty(str))
             {
-                bool isRedistRoot;
-                if (Boolean.TryParse(str, out isRedistRoot))
+                if (Boolean.TryParse(str, out bool isRedistRoot))
                 {
                     return !isRedistRoot;
                 }
@@ -619,17 +643,17 @@ private bool IsFiltered(ITaskItem item)
         #region PublishInfo
         private class PublishInfo
         {
-            public readonly string key = null;
-            public readonly string group = null;
-            public readonly string targetPath = null;
-            public readonly string includeHash = null;
+            public readonly string key;
+            public readonly string group;
+            public readonly string targetPath;
+            public readonly string includeHash;
             public PublishState state = PublishState.Auto;
             public PublishInfo()
             {
             }
             public PublishInfo(ITaskItem item)
             {
-                this.key = item.ItemSpec != null ? item.ItemSpec.ToLowerInvariant() : null;
+                this.key = item.ItemSpec?.ToLowerInvariant();
                 this.group = item.GetMetadata("Group");
                 this.state = StringToPublishState(item.GetMetadata("PublishState"));
                 this.includeHash = item.GetMetadata("IncludeHash");
@@ -643,7 +667,7 @@ private class MapEntry
         {
             public readonly ITaskItem item;
             public readonly bool includedByDefault;
-            public PublishInfo publishInfo = null;
+            public PublishInfo publishInfo;
             public MapEntry(ITaskItem item, bool includedByDefault)
             {
                 this.item = item;
@@ -662,27 +686,31 @@ public MapEntry this[string fusionName]
             {
                 get
                 {
-                    MapEntry entry = null;
                     string key = fusionName.ToLowerInvariant();
-                    if (!_dictionary.TryGetValue(key, out entry))
+                    if (!_dictionary.TryGetValue(key, out MapEntry entry))
+                    {
                         _simpleNameDictionary.TryGetValue(key, out entry);
+                    }
                     return entry;
                 }
             }
 
             public void Add(ITaskItem item)
             {
-                MapEntry entry = new MapEntry(item, true);
-                string key;
+                var entry = new MapEntry(item, true);
                 string fusionName = item.GetMetadata(ItemMetadataNames.fusionName);
                 if (String.IsNullOrEmpty(fusionName))
+                {
                     fusionName = Path.GetFileNameWithoutExtension(item.ItemSpec);
+                }
 
                 // Add to map with full name, for SpecificVersion=true case
-                key = fusionName.ToLowerInvariant();
+                string key = fusionName.ToLowerInvariant();
                 Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same key '{0}' detected", key));
                 if (!_dictionary.ContainsKey(key))
+                {
                     _dictionary.Add(key, entry);
+                }
 
                 // Also add to map with simple name, for SpecificVersion=false case
                 int i = fusionName.IndexOf(',');
@@ -692,10 +720,12 @@ public void Add(ITaskItem item)
                     key = simpleName.ToLowerInvariant();
                     // If there are multiple with same simple name then we'll take the first one and ignore the rest, which is not an unreasonable thing to do
                     if (!_simpleNameDictionary.ContainsKey(key))
+                    {
                         _simpleNameDictionary.Add(key, entry);
+                    }
                 }
             }
-
+            
             IEnumerator IEnumerable.GetEnumerator()
             {
                 return _dictionary.Values.GetEnumerator();
@@ -712,9 +742,8 @@ public MapEntry this[string targetPath]
             {
                 get
                 {
-                    MapEntry entry = null;
                     string key = targetPath.ToLowerInvariant();
-                    _dictionary.TryGetValue(key, out entry);
+                    _dictionary.TryGetValue(key, out MapEntry entry);
                     return entry;
                 }
             }
@@ -726,9 +755,11 @@ public void Add(ITaskItem item, bool includedByDefault)
                 if (String.IsNullOrEmpty(targetPath)) return;
                 string key = targetPath.ToLowerInvariant();
                 Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same '{0}' attribute detected", ItemMetadataNames.targetPath));
-                MapEntry entry = new MapEntry(item, includedByDefault);
+                var entry = new MapEntry(item, includedByDefault);
                 if (!_dictionary.ContainsKey(key))
+                {
                     _dictionary.Add(key, entry);
+                }
             }
 
             IEnumerator IEnumerable.GetEnumerator()
@@ -770,20 +801,16 @@ private static PublishState StringToPublishState(string value)
 
         private class PublishFlags
         {
-            private bool _isDataFile = false;
-            private bool _isPrerequisite = false;
-            private bool _isPublished = false;
-
             private PublishFlags(bool isDataFile, bool isPrerequisite, bool isPublished)
             {
-                _isDataFile = isDataFile;
-                _isPrerequisite = isPrerequisite;
-                _isPublished = isPublished;
+                IsDataFile = isDataFile;
+                IsPrerequisite = isPrerequisite;
+                IsPublished = isPublished;
             }
 
             public static PublishFlags GetAssemblyFlags(PublishState state, bool copyLocal)
             {
-                bool isDataFile = false;
+                const bool isDataFile = false;
                 bool isPrerequisite = false;
                 bool isPublished = false;
                 switch (state)
@@ -817,7 +844,7 @@ public static PublishFlags GetAssemblyFlags(PublishState state, bool copyLocal)
             public static PublishFlags GetFileFlags(PublishState state, string fileExtension, bool includedByDefault)
             {
                 bool isDataFile = false;
-                bool isPrerequisite = false;
+                const bool isPrerequisite = false;
                 bool isPublished = false;
                 switch (state)
                 {
@@ -850,7 +877,7 @@ public static PublishFlags GetFileFlags(PublishState state, string fileExtension
             public static PublishFlags GetSatelliteFlags(PublishState state, CultureInfo satelliteCulture, CultureInfo targetCulture, bool includeAllSatellites)
             {
                 bool includedByDefault = IsSatelliteIncludedByDefault(satelliteCulture, targetCulture, includeAllSatellites);
-                bool isDataFile = false;
+                const bool isDataFile = false;
                 bool isPrerequisite = false;
                 bool isPublished = false;
                 switch (state)
@@ -881,36 +908,33 @@ public static PublishFlags GetSatelliteFlags(PublishState state, CultureInfo sat
                 return new PublishFlags(isDataFile, isPrerequisite, isPublished);
             }
 
-            public bool IsDataFile
-            {
-                get { return _isDataFile; }
-            }
+            public bool IsDataFile { get; }
 
-            public bool IsPrerequisite
-            {
-                get { return _isPrerequisite; }
-            }
+            public bool IsPrerequisite { get; }
 
-            public bool IsPublished
-            {
-                get { return _isPublished; }
-            }
+            public bool IsPublished { get; }
 
             private static bool IsSatelliteIncludedByDefault(CultureInfo satelliteCulture, CultureInfo targetCulture, bool includeAllSatellites)
             {
                 // If target culture not specified then satellite is not included by default...
                 if (targetCulture == null)
+                {
                     return includeAllSatellites;
+                }
 
                 // If satellite culture matches target culture then satellite is included by default...
                 if (targetCulture.Equals(satelliteCulture))
+                {
                     return true;
+                }
 
                 // If satellite culture matches target culture's neutral culture then satellite is included by default...
                 // For example, if target culture is "fr-FR" then target culture's neutral culture is "fr",
                 // so if satellite culture is also "fr" then it will be included as well.
                 if (!targetCulture.IsNeutralCulture && targetCulture.Parent.Equals(satelliteCulture))
+                {
                     return true;
+                }
 
                 // Otherwise satellite is not included by default...
                 return includeAllSatellites;
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 772309585a2..f4e9d7e8a43 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -3,14 +3,11 @@
 
 using System;
 using System.IO;
-using System.Diagnostics;
-using System.Resources;
-using System.Reflection;
 using System.Collections;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -36,13 +33,10 @@ public ITaskItem[] NativeReferences
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_nativeReferences, "nativeReferences");
+                ErrorUtilities.VerifyThrowArgumentNull(_nativeReferences, nameof(NativeReferences));
                 return _nativeReferences;
             }
-            set
-            {
-                _nativeReferences = value;
-            }
+            set => _nativeReferences = value;
         }
 
         [Required]
@@ -50,100 +44,31 @@ public string[] AdditionalSearchPaths
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_additionalSearchPaths, "additionalSearchPaths");
+                ErrorUtilities.VerifyThrowArgumentNull(_additionalSearchPaths, nameof(AdditionalSearchPaths));
                 return _additionalSearchPaths;
             }
-            set
-            {
-                _additionalSearchPaths = value;
-            }
+            set => _additionalSearchPaths = value;
         }
 
         [Output]
-        public ITaskItem[] ContainingReferenceFiles
-        {
-            get
-            {
-                return _containingReferenceFiles;
-            }
-            set
-            {
-                _containingReferenceFiles = value;
-            }
-        }
+        public ITaskItem[] ContainingReferenceFiles { get; set; }
 
         [Output]
-        public ITaskItem[] ContainedPrerequisiteAssemblies
-        {
-            get
-            {
-                return _containedPrerequisiteAssemblies;
-            }
-            set
-            {
-                _containedPrerequisiteAssemblies = value;
-            }
-        }
+        public ITaskItem[] ContainedPrerequisiteAssemblies { get; set; }
 
         [Output]
-        public ITaskItem[] ContainedComComponents
-        {
-            get
-            {
-                return _containedComComponents;
-            }
-            set
-            {
-                _containedComComponents = value;
-            }
-        }
+        public ITaskItem[] ContainedComComponents { get; set; }
 
         [Output]
-        public ITaskItem[] ContainedTypeLibraries
-        {
-            get
-            {
-                return _containedTypeLibraries;
-            }
-            set
-            {
-                _containedTypeLibraries = value;
-            }
-        }
+        public ITaskItem[] ContainedTypeLibraries { get; set; }
 
         [Output]
-        public ITaskItem[] ContainedLooseTlbFiles
-        {
-            get
-            {
-                return _containedLooseTlbFiles;
-            }
-            set
-            {
-                _containedLooseTlbFiles = value;
-            }
-        }
+        public ITaskItem[] ContainedLooseTlbFiles { get; set; }
 
         [Output]
-        public ITaskItem[] ContainedLooseEtcFiles
-        {
-            get
-            {
-                return _containedLooseEtcFiles;
-            }
-            set
-            {
-                _containedLooseEtcFiles = value;
-            }
-        }
+        public ITaskItem[] ContainedLooseEtcFiles { get; set; }
 
-        private ITaskItem[] _nativeReferences = null;
-        private ITaskItem[] _containingReferenceFiles = null;
-        private ITaskItem[] _containedPrerequisiteAssemblies = null;
-        private ITaskItem[] _containedComComponents = null;
-        private ITaskItem[] _containedTypeLibraries = null;
-        private ITaskItem[] _containedLooseTlbFiles = null;
-        private ITaskItem[] _containedLooseEtcFiles = null;
+        private ITaskItem[] _nativeReferences;
         private string[] _additionalSearchPaths = Array.Empty<string>();
         #endregion
 
@@ -163,20 +88,19 @@ int IComparer.Compare(Object taskItem1, Object taskItem2)
         /// <summary>
         /// Task entry point.
         /// </summary>
-        /// <returns></returns>
         public override bool Execute()
         {
             // Process each task item. If one of them fails we still process the
             // rest of them, but remember that the task should return failure.
             bool retValue = true;
-            int reference = 0;
+            int reference;
 
-            Hashtable containingReferenceFilesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            Hashtable containedPrerequisiteAssembliesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            Hashtable containedComComponentsTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            Hashtable containedTypeLibrariesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            Hashtable containedLooseTlbFilesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            Hashtable containedLooseEtcFilesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var containingReferenceFilesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var containedPrerequisiteAssembliesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var containedComComponentsTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var containedTypeLibrariesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var containedLooseTlbFilesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var containedLooseEtcFilesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
             for (reference = 0; reference < NativeReferences.GetLength(0); reference++)
             {
@@ -230,29 +154,29 @@ public override bool Execute()
 
             IComparer itemSpecComparer = new ItemSpecComparerClass();
 
-            _containingReferenceFiles = new ITaskItem[containingReferenceFilesTable.Count];
-            containingReferenceFilesTable.Values.CopyTo(_containingReferenceFiles, 0);
-            Array.Sort(_containingReferenceFiles, itemSpecComparer);
+            ContainingReferenceFiles = new ITaskItem[containingReferenceFilesTable.Count];
+            containingReferenceFilesTable.Values.CopyTo(ContainingReferenceFiles, 0);
+            Array.Sort(ContainingReferenceFiles, itemSpecComparer);
 
-            _containedPrerequisiteAssemblies = new ITaskItem[containedPrerequisiteAssembliesTable.Count];
-            containedPrerequisiteAssembliesTable.Values.CopyTo(_containedPrerequisiteAssemblies, 0);
-            Array.Sort(_containedPrerequisiteAssemblies, itemSpecComparer);
+            ContainedPrerequisiteAssemblies = new ITaskItem[containedPrerequisiteAssembliesTable.Count];
+            containedPrerequisiteAssembliesTable.Values.CopyTo(ContainedPrerequisiteAssemblies, 0);
+            Array.Sort(ContainedPrerequisiteAssemblies, itemSpecComparer);
 
-            _containedComComponents = new ITaskItem[containedComComponentsTable.Count];
-            containedComComponentsTable.Values.CopyTo(_containedComComponents, 0);
-            Array.Sort(_containedComComponents, itemSpecComparer);
+            ContainedComComponents = new ITaskItem[containedComComponentsTable.Count];
+            containedComComponentsTable.Values.CopyTo(ContainedComComponents, 0);
+            Array.Sort(ContainedComComponents, itemSpecComparer);
 
-            _containedTypeLibraries = new ITaskItem[containedTypeLibrariesTable.Count];
-            containedTypeLibrariesTable.Values.CopyTo(_containedTypeLibraries, 0);
-            Array.Sort(_containedTypeLibraries, itemSpecComparer);
+            ContainedTypeLibraries = new ITaskItem[containedTypeLibrariesTable.Count];
+            containedTypeLibrariesTable.Values.CopyTo(ContainedTypeLibraries, 0);
+            Array.Sort(ContainedTypeLibraries, itemSpecComparer);
 
-            _containedLooseTlbFiles = new ITaskItem[containedLooseTlbFilesTable.Count];
-            containedLooseTlbFilesTable.Values.CopyTo(_containedLooseTlbFiles, 0);
-            Array.Sort(_containedLooseTlbFiles, itemSpecComparer);
+            ContainedLooseTlbFiles = new ITaskItem[containedLooseTlbFilesTable.Count];
+            containedLooseTlbFilesTable.Values.CopyTo(ContainedLooseTlbFiles, 0);
+            Array.Sort(ContainedLooseTlbFiles, itemSpecComparer);
 
-            _containedLooseEtcFiles = new ITaskItem[containedLooseEtcFilesTable.Count];
-            containedLooseEtcFilesTable.Values.CopyTo(_containedLooseEtcFiles, 0);
-            Array.Sort(_containedLooseEtcFiles, itemSpecComparer);
+            ContainedLooseEtcFiles = new ITaskItem[containedLooseEtcFilesTable.Count];
+            containedLooseEtcFilesTable.Values.CopyTo(ContainedLooseEtcFiles, 0);
+            Array.Sort(ContainedLooseEtcFiles, itemSpecComparer);
 
             return retValue;
         }
@@ -267,7 +191,7 @@ internal bool ExtractFromManifest(ITaskItem taskItem, string path, Hashtable con
         {
             Log.LogMessageFromResources(MessageImportance.Low, "ResolveNativeReference.Comment", path);
 
-            Manifest manifest = null;
+            Manifest manifest;
 
             try
             {
@@ -285,19 +209,21 @@ internal bool ExtractFromManifest(ITaskItem taskItem, string path, Hashtable con
                 manifest.ReadOnly = true; // only reading a manifest, set flag so we get GenerateManifest.ResolveFailedInReadOnlyMode instead of GenerateManifest.ResolveFailedInReadWriteMode messages
                 manifest.ResolveFiles();
                 if (!manifest.OutputMessages.LogTaskMessages(this))
+                {
                     return false;
+                }
 
-                ApplicationManifest applicationManifest = manifest as ApplicationManifest;
-                bool isClickOnceApp = applicationManifest != null && applicationManifest.IsClickOnceManifest;
+                bool isClickOnceApp = manifest is ApplicationManifest applicationManifest && applicationManifest.IsClickOnceManifest;
                 // ClickOnce application manifest should not be added as native reference, but we should open and process it.        
                 if (containingReferenceFilesTable.ContainsKey(path) == false && !isClickOnceApp)
                 {
                     ITaskItem itemNativeReferenceFile = new TaskItem();
                     itemNativeReferenceFile.ItemSpec = path;
                     if (manifest.AssemblyIdentity.Name != null)
+                    {
                         itemNativeReferenceFile.SetMetadata(ItemMetadataNames.fusionName, manifest.AssemblyIdentity.Name);
-                    if (taskItem != null)
-                        taskItem.CopyMetadataTo(itemNativeReferenceFile);
+                    }
+                    taskItem?.CopyMetadataTo(itemNativeReferenceFile);
                     containingReferenceFilesTable.Add(path, itemNativeReferenceFile);
                 }
 
@@ -336,7 +262,9 @@ internal bool ExtractFromManifest(ITaskItem taskItem, string path, Hashtable con
                     foreach (FileReference fileref in manifest.FileReferences)
                     {
                         if (fileref.ResolvedPath == null)
+                        {
                             continue;
+                        }
 
                         // add the loose file to the outputs list, if it's not already there
                         if (containedLooseEtcFilesTable.ContainsKey(fileref.ResolvedPath) == false)
@@ -377,10 +305,7 @@ internal bool ExtractFromManifest(ITaskItem taskItem, string path, Hashtable con
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.wrapperTool, ComReferenceTypes.tlbimp);
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.guid, typelib.TlbId);
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.lcid, "0");
-                                    string delimStr = ".";
-                                    char[] delimiter = delimStr.ToCharArray();
-                                    string[] verMajorAndMinor = null;
-                                    verMajorAndMinor = typelib.Version.Split(delimiter);
+                                    string[] verMajorAndMinor = typelib.Version.Split('.');
                                     // UNDONE: are major and minor version numbers in base 10 or 16?
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.versionMajor, verMajorAndMinor[0]);
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.versionMinor, verMajorAndMinor[1]);
diff --git a/src/Tasks/ResolveNonMSBuildProjectOutput.cs b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
index fdbd9440970..9c527a294b2 100644
--- a/src/Tasks/ResolveNonMSBuildProjectOutput.cs
+++ b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
+using System.Collections.Generic;
 using System.Reflection;
 using System.Xml;
 using Microsoft.Build.Framework;
@@ -40,37 +40,13 @@ public ResolveNonMSBuildProjectOutput()
         /// A special XML string containing resolved project outputs - we need to simply match the projects and
         /// return the appropriate paths
         /// </summary>
-        public string PreresolvedProjectOutputs
-        {
-            get
-            {
-                return _preresolvedProjectOutputs;
-            }
-            set
-            {
-                _preresolvedProjectOutputs = value;
-            }
-        }
-
-        private string _preresolvedProjectOutputs = null;
+        public string PreresolvedProjectOutputs { get; set; }
 
         /// <summary>
         /// The list of resolved reference paths (preserving the original project reference attributes)
         /// </summary>
         [Output]
-        public ITaskItem[] ResolvedOutputPaths
-        {
-            get
-            {
-                return _resolvedOutputPaths;
-            }
-            set
-            {
-                _resolvedOutputPaths = value;
-            }
-        }
-
-        private ITaskItem[] _resolvedOutputPaths = null;
+        public ITaskItem[] ResolvedOutputPaths { get; set; }
 
         /// <summary>
         /// The list of project reference items that could not be resolved using the pre-resolved list of outputs.
@@ -78,19 +54,7 @@ public ITaskItem[] ResolvedOutputPaths
         /// are in the MSBuild format.
         /// </summary>
         [Output]
-        public ITaskItem[] UnresolvedProjectReferences
-        {
-            get
-            {
-                return _unresolvedProjectReferences;
-            }
-            set
-            {
-                _unresolvedProjectReferences = value;
-            }
-        }
-
-        private ITaskItem[] _unresolvedProjectReferences = null;
+        public ITaskItem[] UnresolvedProjectReferences { get; set; }
 
         /// <summary>
         /// A delegate with a signature that matches AssemblyName.GetAssemblyName.
@@ -109,7 +73,6 @@ public ITaskItem[] UnresolvedProjectReferences
         /// <summary>
         /// Main task method
         /// </summary>
-        /// <returns></returns>
         public override bool Execute()
         {
             // Allow unit tests to inject a non-file system dependent version of this.
@@ -121,22 +84,20 @@ public override bool Execute()
             try
             {
                 if (!VerifyProjectReferenceItems(ProjectReferences, false /* treat problems as warnings */))
+                {
                     return false;
+                }
 
-                ArrayList resolvedPaths = new ArrayList(ProjectReferences.GetLength(0));
-                ArrayList unresolvedReferences = new ArrayList(ProjectReferences.GetLength(0));
+                var resolvedPaths = new List<ITaskItem>(ProjectReferences.GetLength(0));
+                var unresolvedReferences = new List<ITaskItem>(ProjectReferences.GetLength(0));
 
                 CacheProjectElementsFromXml(PreresolvedProjectOutputs);
 
                 foreach (ITaskItem projectRef in ProjectReferences)
                 {
-                    bool resolveSuccess = false;
-                    ITaskItem resolvedPath;
-
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveNonMSBuildProjectOutput.ProjectReferenceResolutionStarting", projectRef.ItemSpec);
 
-                    resolveSuccess = ResolveProject(projectRef, out resolvedPath);
-
+                    bool resolveSuccess = ResolveProject(projectRef, out ITaskItem resolvedPath);
                     if (resolveSuccess)
                     {
                         if (resolvedPath.ItemSpec.Length > 0)
@@ -177,8 +138,8 @@ public override bool Execute()
                     }
                 }
 
-                ResolvedOutputPaths = (ITaskItem[])resolvedPaths.ToArray(typeof(ITaskItem));
-                UnresolvedProjectReferences = (ITaskItem[])unresolvedReferences.ToArray(typeof(ITaskItem));
+                ResolvedOutputPaths = resolvedPaths.ToArray();
+                UnresolvedProjectReferences = unresolvedReferences.ToArray();
             }
             catch (XmlException e)
             {
diff --git a/src/Tasks/ResolveProjectBase.cs b/src/Tasks/ResolveProjectBase.cs
index 11d9402c7ab..b3181e1183b 100644
--- a/src/Tasks/ResolveProjectBase.cs
+++ b/src/Tasks/ResolveProjectBase.cs
@@ -5,12 +5,11 @@
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -18,7 +17,7 @@ namespace Microsoft.Build.Tasks
     /// Base class for ResolveNonMSBuildProjectOutput and AssignProjectConfiguration, since they have
     /// similar architecture
     /// </summary>
-    abstract public class ResolveProjectBase : TaskExtension
+    public abstract class ResolveProjectBase : TaskExtension
     {
         #region Properties
 
@@ -30,34 +29,31 @@ public ITaskItem[] ProjectReferences
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentNull(_projectReferences, "projectReferences");
+                ErrorUtilities.VerifyThrowArgumentNull(_projectReferences, nameof(ProjectReferences));
                 return _projectReferences;
             }
-            set
-            {
-                _projectReferences = value;
-            }
+            set => _projectReferences = value;
         }
 
-        private ITaskItem[] _projectReferences = null;
+        private ITaskItem[] _projectReferences;
 
         // This field stores all the distinct project references by project absolute path
-        private HashSet<string> _cachedProjectReferencesByAbsolutePath = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+        private readonly HashSet<string> _cachedProjectReferencesByAbsolutePath = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
         // This field stores pre-cached project elements for project guids for quicker access by project guid
-        private Dictionary<string, XmlElement> _cachedProjectElements = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, XmlElement> _cachedProjectElements = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
 
         // This field stores pre-cached project elements for project guids for quicker access by project absolute path
-        private Dictionary<string, XmlElement> _cachedProjectElementsByAbsolutePath = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, XmlElement> _cachedProjectElementsByAbsolutePath = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
 
         // This field stores the project absolute path for quicker access by project guid
-        private Dictionary<string, string> _cachedProjectAbsolutePathsByGuid = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, string> _cachedProjectAbsolutePathsByGuid = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
         // This field stores the project guid for quicker access by project absolute path
-        private Dictionary<string, string> _cachedProjectGuidsByAbsolutePath = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, string> _cachedProjectGuidsByAbsolutePath = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
         // This field stores the list of dependency project guids by depending project guid
-        private Dictionary<string, List<string>> _cachedDependencyProjectGuidsByDependingProjectGuid = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, List<string>> _cachedDependencyProjectGuidsByDependingProjectGuid = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
 
         private const string attributeProject = "Project";
 
@@ -80,8 +76,7 @@ internal bool VerifyReferenceAttributes(ITaskItem reference, out string missingA
             if (attrValue.Length > 0)
             {
                 // invalid project GUID format?
-                Guid guid;
-                if (!Guid.TryParse(attrValue, out guid))
+                if (!Guid.TryParse(attrValue, out _))
                 {
                     return false;
                 }
@@ -99,13 +94,12 @@ internal bool VerifyReferenceAttributes(ITaskItem reference, out string missingA
         internal bool VerifyProjectReferenceItems(ITaskItem[] references, bool treatAsError)
         {
             bool referencesValid = true;
-            string missingAttribute;
 
             foreach (ITaskItem reference in references)
             {
                 _cachedProjectReferencesByAbsolutePath.Add(reference.GetMetadata("FullPath")); // metadata is cached and used again later
 
-                if (!VerifyReferenceAttributes(reference, out missingAttribute))
+                if (!VerifyReferenceAttributes(reference, out string missingAttribute))
                 {
                     if (treatAsError)
                     {
@@ -125,7 +119,6 @@ internal bool VerifyProjectReferenceItems(ITaskItem[] references, bool treatAsEr
         /// <summary>
         /// Pre-cache individual project elements from the XML string in a hashtable for quicker access.
         /// </summary>
-        /// <param name="doc"></param>
         internal void CacheProjectElementsFromXml(string xmlString)
         {
             XmlDocument doc = null;
@@ -133,9 +126,7 @@ internal void CacheProjectElementsFromXml(string xmlString)
             if (!string.IsNullOrEmpty(xmlString))
             {
                 doc = new XmlDocument();
-                XmlReaderSettings settings = new XmlReaderSettings();
-                settings.DtdProcessing = DtdProcessing.Ignore;
-
+                var settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                 using (XmlReader reader = XmlReader.Create(new StringReader(xmlString), settings))
                 {
                     doc.Load(reader);
@@ -150,7 +141,7 @@ internal void CacheProjectElementsFromXml(string xmlString)
             //  <ProjectConfiguration Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" AbsolutePath="c:foo\Project3\C.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
             //</SolutionConfiguration>
             //
-            if (doc != null && doc.DocumentElement != null)
+            if (doc?.DocumentElement != null)
             {
                 foreach (XmlElement xmlElement in doc.DocumentElement.ChildNodes)
                 {
@@ -195,8 +186,7 @@ internal void CacheProjectElementsFromXml(string xmlString)
                                 continue;
                             }
 
-                            List<string> list;
-                            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out list))
+                            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out List<string> list))
                             {
                                 list = new List<string>();
                                 _cachedDependencyProjectGuidsByDependingProjectGuid.Add(projectGuid, list);
@@ -212,13 +202,10 @@ internal void CacheProjectElementsFromXml(string xmlString)
         /// <summary>
         /// Helper method for retrieving whatever was stored in the XML string for the given project
         /// </summary>
-        /// <param name="projectRef"></param>
-        /// <param name="projectItem"></param>
-        /// <returns></returns>
         protected string GetProjectItem(ITaskItem projectRef)
         {
             XmlElement projectElement = GetProjectElement(projectRef);
-            return projectElement != null ? projectElement.InnerText : null;
+            return projectElement?.InnerText;
         }
 
         /// <summary>
@@ -228,9 +215,8 @@ protected string GetProjectItem(ITaskItem projectRef)
         protected XmlElement GetProjectElement(ITaskItem projectRef)
         {
             string projectGuid = projectRef.GetMetadata(attributeProject);
-            XmlElement projectElement = null;
 
-            if ((_cachedProjectElements.TryGetValue(projectGuid, out projectElement)) && (projectElement != null))
+            if ((_cachedProjectElements.TryGetValue(projectGuid, out XmlElement projectElement)) && (projectElement != null))
             {
                 return projectElement;
             }
@@ -254,16 +240,14 @@ protected XmlElement GetProjectElement(ITaskItem projectRef)
         protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath)
         {
             // Get the guid for this project
-            string projectGuid;
-            if (!_cachedProjectGuidsByAbsolutePath.TryGetValue(currentProjectAbsolutePath, out projectGuid))
+            if (!_cachedProjectGuidsByAbsolutePath.TryGetValue(currentProjectAbsolutePath, out string projectGuid))
             {
                 // We were passed a blob, but we weren't listed in it. Odd. Return.
                 return;
             }
 
             // Use the guid to look up the dependencies for it
-            List<string> guids;
-            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out guids))
+            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out List<string> guids))
             {
                 // We didn't have dependencies listed in the blob
                 return;
@@ -275,8 +259,7 @@ protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath)
             foreach (string guid in guids)
             {
                 // Get the absolute path of the dependency, using the blob
-                string path;
-                if (!_cachedProjectAbsolutePathsByGuid.TryGetValue(guid, out path))
+                if (!_cachedProjectAbsolutePathsByGuid.TryGetValue(guid, out string path))
                 {
                     // We had a dependency listed in the blob that wasn't itself in the blob. Odd. Return.
                     continue;
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index b63fcdb0573..78c0ddef04c 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -7,14 +7,13 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Linq;
-using System.Globalization;
-using System.Diagnostics.CodeAnalysis;
-
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -39,12 +38,12 @@ public class ResolveSDKReference : TaskExtension
         /// <summary>
         /// SimpleName group
         /// </summary>
-        private static readonly string s_SDKsimpleNameGroup = "SDKSIMPLENAME";
+        private const string SDKsimpleNameGroup = "SDKSIMPLENAME";
 
         /// <summary>
         /// Version group
         /// </summary>
-        private static readonly string s_SDKVersionGroup = "SDKVERSION";
+        private const string SDKVersionGroup = "SDKVERSION";
 
         /// <summary>
         /// Delimiter used to delimit the dependent sdk's in the warning message
@@ -54,7 +53,7 @@ public class ResolveSDKReference : TaskExtension
         /// <summary>
         /// Split char for the appx attribute
         /// </summary>
-        private static readonly char[] s_appxSplitChar = new char[] { '-' };
+        private static readonly char[] s_appxSplitChar = { '-' };
 
         /// <summary>
         /// SDKName
@@ -74,7 +73,7 @@ public class ResolveSDKReference : TaskExtension
         /// <summary>
         /// Default target platform version
         /// </summary>
-        private static Version s_defaultTargetPlatformVersion = new Version("7.0");
+        private static readonly Version s_defaultTargetPlatformVersion = new Version("7.0");
 
         /// <summary>
         ///  Set of sdk references to resolve to paths on disk.
@@ -86,41 +85,26 @@ public class ResolveSDKReference : TaskExtension
         /// </summary>
         private ITaskItem[] _installedSDKs = Array.Empty<ITaskItem>();
 
-        /// <summary>
-        /// Should resolution errors be logged as warnings or errors.
-        /// </summary>
-        private bool _logResolutionErrorsAsWarnings = false;
-
-        /// <summary>
-        /// The value of the prefer32bit flag used in the build
-        /// </summary>
-        private bool _prefer32Bit = false;
-
         /// <summary>
         /// stores value of TargetPlatformVersion property
         /// </summary>
-        private Version _targetPlatformVersion = null;
+        private Version _targetPlatformVersion;
 
         /// <summary>
         /// Stores TargetPlatform property
         /// </summary>
-        private string _targetPlatformIdentifier = null;
+        private string _targetPlatformIdentifier;
 
         /// <summary>
         /// Stores ProjectName property
         /// </summary>
-        private string _projectName = null;
+        private string _projectName;
 
         /// <summary>
         /// Stores dictionary with runtime only reference dependencies
         /// </summary>
         private Dictionary<string, string> _runtimeReferenceOnlyDependenciesByName;
 
-        /// <summary>
-        /// Stores flag to enable warning if SDK's max platform version is not specified in the manifest
-        /// </summary>
-        private bool _enableMaxPlatformVersionEmptyWarning = false;
-
         #endregion
 
         #region Properties
@@ -132,14 +116,11 @@ public class ResolveSDKReference : TaskExtension
         [Required]
         public ITaskItem[] SDKReferences
         {
-            get
-            {
-                return _sdkReferences;
-            }
+            get => _sdkReferences;
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "SDKReferences");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(SDKReferences));
                 _sdkReferences = value;
             }
         }
@@ -151,14 +132,11 @@ public ITaskItem[] SDKReferences
         [Required]
         public ITaskItem[] InstalledSDKs
         {
-            get
-            {
-                return _installedSDKs;
-            }
+            get => _installedSDKs;
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "InstalledSDKs");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(InstalledSDKs));
                 _installedSDKs = value;
             }
         }
@@ -175,10 +153,7 @@ public string TargetPlatformIdentifier
                 return _targetPlatformIdentifier;
             }
 
-            set
-            {
-                _targetPlatformIdentifier = value;
-            }
+            set => _targetPlatformIdentifier = value;
         }
 
         /// <summary>
@@ -193,10 +168,7 @@ public string ProjectName
                 return _projectName;
             }
 
-            set
-            {
-                _projectName = value;
-            }
+            set => _projectName = value;
         }
 
         /// <summary>
@@ -205,15 +177,11 @@ public string ProjectName
         [Required]
         public string TargetPlatformVersion
         {
-            get
-            {
-                return TargetPlatformAsVersion.ToString();
-            }
+            get => TargetPlatformAsVersion.ToString();
 
             set
             {
-                Version versionValue;
-                if (Version.TryParse(value, out versionValue))
+                if (Version.TryParse(value, out Version versionValue))
                 {
                     TargetPlatformAsVersion = versionValue;
                 }
@@ -224,113 +192,56 @@ public string TargetPlatformVersion
         /// Reference may be passed in so their SDKNames can be resolved and then sdkroot paths can be tacked onto the reference
         /// so RAR can find the assembly correctly in the sdk location.
         /// </summary>
-        public ITaskItem[] References
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] References { get; set; }
 
         /// <summary>
         /// List of disallowed dependencies passed from the targets file (deprecated)
         /// For instance "VCLibs 11" should be disallowed in projects targeting Win 8.1 or higher.
         /// </summary>
-        public ITaskItem[] DisallowedSDKDependencies
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] DisallowedSDKDependencies { get; set; }
 
         /// <summary>
         /// List of dependencies passed from the targets file that will have the metadata RuntimeReferenceOnly set as true. 
         /// For instance "VCLibs 11" should have such a metadata set to true in projects targeting Win 8.1 or higher.
         /// </summary>
-        public ITaskItem[] RuntimeReferenceOnlySDKDependencies
-        {
-            get;
-            set;
-        }
+        public ITaskItem[] RuntimeReferenceOnlySDKDependencies { get; set; }
 
         /// <summary>
         /// Configuration for SDK's which are resolved
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SDK", Justification = "Shipped this way in Dev11 Beta (go-live)")]
-        public string TargetedSDKConfiguration
-        {
-            get;
-            set;
-        }
+        public string TargetedSDKConfiguration { get; set; }
 
         /// <summary>
         /// Architecture of the SDK's we are targeting
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SDK", Justification = "Shipped this way in Dev11 Beta (go-live)")]
-        public string TargetedSDKArchitecture
-        {
-            get;
-            set;
-        }
+        public string TargetedSDKArchitecture { get; set; }
 
         /// <summary>
         /// Enables warning when MaxPlatformVersion is not present in the manifest and the ESDK platform version (from its path) 
         /// is different than the target platform version (from the project)
         /// </summary>
-        public bool WarnOnMissingPlatformVersion
-        {
-            get
-            {
-                return _enableMaxPlatformVersionEmptyWarning;
-            }
-
-            set
-            {
-                _enableMaxPlatformVersionEmptyWarning = value;
-            }
-        }
+        public bool WarnOnMissingPlatformVersion { get; set; }
 
         /// <summary>
         /// Should problems resolving SDKs be logged as a warning or an error.
         /// If the resolution problem is logged as an error the build will fail.
         /// If the resolution problem is logged as a warning we will warn and continue.
         /// </summary>
-        public bool LogResolutionErrorsAsWarnings
-        {
-            get
-            {
-                return _logResolutionErrorsAsWarnings;
-            }
-
-            set
-            {
-                _logResolutionErrorsAsWarnings = value;
-            }
-        }
+        public bool LogResolutionErrorsAsWarnings { get; set; }
 
         /// <summary>
         /// The prefer32bit flag used during the build
         /// </summary>
-        public bool Prefer32Bit
-        {
-            get
-            {
-                return _prefer32Bit;
-            }
-
-            set
-            {
-                _prefer32Bit = value;
-            }
-        }
+        public bool Prefer32Bit { get; set; }
 
         /// <summary>
         /// Resolved SDK References
         /// </summary>
         [Output]
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SDK", Justification = "Shipped this way in Dev11 Beta (go-live)")]
-        public ITaskItem[] ResolvedSDKReferences
-        {
-            get;
-            private set;
-        }
+        public ITaskItem[] ResolvedSDKReferences { get; private set; }
 
         /// <summary>
         /// Version object containing target platform version
@@ -343,10 +254,7 @@ private Version TargetPlatformAsVersion
                 return _targetPlatformVersion;
             }
 
-            set
-            {
-                _targetPlatformVersion = value;
-            }
+            set => _targetPlatformVersion = value;
         }
 
         #endregion
@@ -356,7 +264,7 @@ private Version TargetPlatformAsVersion
         /// </summary>
         public override bool Execute()
         {
-            ResolvedSDKReferences = Array.Empty<TaskItem>();
+            ResolvedSDKReferences = Array.Empty<ITaskItem>();
 
             if (InstalledSDKs.Length == 0)
             {
@@ -370,10 +278,7 @@ public override bool Execute()
             {
                 foreach (ITaskItem runtimeDependencyOnlyItem in RuntimeReferenceOnlySDKDependencies)
                 {
-                    string dependencyName;
-                    string dependencyVersion;
-
-                    if (ParseSDKReference(runtimeDependencyOnlyItem.ItemSpec, out dependencyName, out dependencyVersion))
+                    if (ParseSDKReference(runtimeDependencyOnlyItem.ItemSpec, out string dependencyName, out string dependencyVersion))
                     {
                         _runtimeReferenceOnlyDependenciesByName[dependencyName] = dependencyVersion;
                     }
@@ -381,30 +286,22 @@ public override bool Execute()
             }
 
             // Convert the list of installed SDK's to a dictionary for faster lookup
-            Dictionary<string, ITaskItem> sdkItems = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
+            var sdkItems = new Dictionary<string, ITaskItem>(InstalledSDKs.Length, StringComparer.OrdinalIgnoreCase);
 
             foreach (ITaskItem installedsdk in InstalledSDKs)
             {
                 string installLocation = installedsdk.ItemSpec;
                 string sdkName = installedsdk.GetMetadata(SDKName);
-                string sdkPlatformVersion = installedsdk.GetMetadata(SDKPlatformVersion);
 
                 if (installLocation.Length > 0 && sdkName.Length > 0)
                 {
-                    if (!sdkItems.ContainsKey(sdkName))
-                    {
-                        sdkItems.Add(sdkName, installedsdk);
-                    }
-                    else
-                    {
-                        sdkItems[sdkName] = installedsdk;
-                    }
+                    sdkItems[sdkName] = installedsdk;
                 }
             }
 
             // We need to check to see if there are any SDKNames on any of the reference items in the project. If there are 
             // then we do not want those SDKs to expand their reference assemblies by default because we are going to use RAR to look inside of them for certain reference assemblies only.
-            HashSet<string> sdkNamesOnReferenceItems = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            var sdkNamesOnReferenceItems = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
             if (References != null)
             {
                 foreach (ITaskItem referenceItem in References)
@@ -418,16 +315,16 @@ public override bool Execute()
             }
 
             // The set of reference items declared in the project file, without duplicate entries.
-            HashSet<SDKReference> sdkReferenceItems = new HashSet<SDKReference>();
+            var sdkReferenceItems = new HashSet<SDKReference>();
 
             // Maps a product family name to a set of SDKs with that product family name
-            Dictionary<string, HashSet<SDKReference>> productFamilyNameToSDK = new Dictionary<string, HashSet<SDKReference>>(StringComparer.OrdinalIgnoreCase);
+            var productFamilyNameToSDK = new Dictionary<string, HashSet<SDKReference>>(StringComparer.OrdinalIgnoreCase);
 
             // Maps a sdk name (no version) to a set of SDKReferences with the same name
-            Dictionary<string, HashSet<SDKReference>> sdkNameToSDK = new Dictionary<string, HashSet<SDKReference>>(StringComparer.OrdinalIgnoreCase);
+            var sdkNameToSDK = new Dictionary<string, HashSet<SDKReference>>(StringComparer.OrdinalIgnoreCase);
 
             // Set of sdks which are not compatible with other sdks of the same product famuily or with the same sdk name
-            HashSet<SDKReference> sdksNotCompatibleWithOtherSDKs = new HashSet<SDKReference>();
+            var sdksNotCompatibleWithOtherSDKs = new HashSet<SDKReference>();
 
             // Go through each reference passed in and determine if it is in the set of installed SDKs. 
             // Also create new output items if the item is in an installed SDK and set the metadata correctly.
@@ -447,13 +344,12 @@ public override bool Execute()
                 if (!sdkReferenceItems.Contains(reference) /* filter out duplicate sdk reference entries*/)
                 {
                     sdkReferenceItems.Add(reference);
-                    reference.Resolve(sdkItems, TargetedSDKConfiguration, TargetedSDKArchitecture, sdkNamesOnReferenceItems, _logResolutionErrorsAsWarnings, _prefer32Bit, TargetPlatformIdentifier, TargetPlatformAsVersion, ProjectName, _enableMaxPlatformVersionEmptyWarning);
+                    reference.Resolve(sdkItems, TargetedSDKConfiguration, TargetedSDKArchitecture, sdkNamesOnReferenceItems, LogResolutionErrorsAsWarnings, Prefer32Bit, TargetPlatformIdentifier, TargetPlatformAsVersion, ProjectName, WarnOnMissingPlatformVersion);
                     if (reference.Resolved)
                     {
                         if (!String.IsNullOrEmpty(reference.ProductFamilyName))
                         {
-                            HashSet<SDKReference> sdksWithProductFamilyName = null;
-                            if (!productFamilyNameToSDK.TryGetValue(reference.ProductFamilyName, out sdksWithProductFamilyName))
+                            if (!productFamilyNameToSDK.TryGetValue(reference.ProductFamilyName, out HashSet<SDKReference> sdksWithProductFamilyName))
                             {
                                 productFamilyNameToSDK.Add(reference.ProductFamilyName, new HashSet<SDKReference> { reference });
                             }
@@ -468,8 +364,7 @@ public override bool Execute()
                             sdksNotCompatibleWithOtherSDKs.Add(reference);
                         }
 
-                        HashSet<SDKReference> sdksWithSimpleName = null;
-                        if (!sdkNameToSDK.TryGetValue(reference.SimpleName, out sdksWithSimpleName))
+                        if (!sdkNameToSDK.TryGetValue(reference.SimpleName, out HashSet<SDKReference> sdksWithSimpleName))
                         {
                             sdkNameToSDK.Add(reference.SimpleName, new HashSet<SDKReference> { reference });
                         }
@@ -494,16 +389,15 @@ public override bool Execute()
                 // If we have already error or warned about an sdk not being compatible with one of the notCompatibleReferences then do not log it again
                 // an sdk could be incompatible because the productfamily is the same but also be incompatible at the same time due to the sdk name
                 // we only want to log one of those cases so we do not get 2 warings or errors for the same sdks.
-                HashSet<SDKReference> sdksAlreadyErrorOrWarnedFor = new HashSet<SDKReference>();
+                var sdksAlreadyErrorOrWarnedFor = new HashSet<SDKReference>();
 
                 // Check to see if a productfamily was set, we want to emit this warning or error first.
                 if (!String.IsNullOrEmpty(notCompatibleReference.ProductFamilyName))
                 {
-                    HashSet<SDKReference> referenceInProductFamily = null;
-                    if (productFamilyNameToSDK.TryGetValue(notCompatibleReference.ProductFamilyName, out referenceInProductFamily))
+                    if (productFamilyNameToSDK.TryGetValue(notCompatibleReference.ProductFamilyName, out HashSet<SDKReference> referenceInProductFamily))
                     {
                         // We want to build a list of incompatible reference names so we can emit them in the error or warnings.
-                        List<string> listOfIncompatibleReferences = new List<string>();
+                        var listOfIncompatibleReferences = new List<string>();
                         foreach (SDKReference incompatibleReference in referenceInProductFamily)
                         {
                             if (!sdksAlreadyErrorOrWarnedFor.Contains(incompatibleReference) && incompatibleReference != notCompatibleReference /*cannot be incompatible with self*/)
@@ -529,11 +423,10 @@ public override bool Execute()
                     }
                 }
 
-                HashSet<SDKReference> referenceWithSameName = null;
-                if (sdkNameToSDK.TryGetValue(notCompatibleReference.SimpleName, out referenceWithSameName))
+                if (sdkNameToSDK.TryGetValue(notCompatibleReference.SimpleName, out HashSet<SDKReference> referenceWithSameName))
                 {
                     // We want to build a list of incompatible reference names so we can emit them in the error or warnings.
-                    List<string> listOfIncompatibleReferences = new List<string>();
+                    var listOfIncompatibleReferences = new List<string>();
                     foreach (SDKReference incompatibleReference in referenceWithSameName)
                     {
                         if (!sdksAlreadyErrorOrWarnedFor.Contains(incompatibleReference) && incompatibleReference != notCompatibleReference /*cannot be incompatible with self*/)
@@ -576,7 +469,7 @@ internal static void AddMetadataToReferences(TaskLoggingHelper log, HashSet<SDKR
         {
             if (referencesToAddMetadata != null)
             {
-                foreach (var referenceItem in sdkReferenceItems)
+                foreach (SDKReference referenceItem in sdkReferenceItems)
                 {
                     string sdkSimpleName = referenceItem.SimpleName;
                     string rawSdkVersion = referenceItem.Version;
@@ -594,7 +487,7 @@ internal static void AddMetadataToReferences(TaskLoggingHelper log, HashSet<SDKR
         /// </summary>
         internal static void VerifySDKDependsOn(TaskLoggingHelper log, HashSet<SDKReference> sdkReferenceItems)
         {
-            foreach (var reference in sdkReferenceItems)
+            foreach (SDKReference reference in sdkReferenceItems)
             {
                 List<string> dependentSDKs = ParseDependsOnSDK(reference.DependsOnSDK);
                 if (dependentSDKs.Count > 0)
@@ -620,9 +513,7 @@ internal static string[] GetUnresolvedDependentSDKs(HashSet<SDKReference> sdkRef
         {
             string[] unresolvedDependencyIdentities = dependentSDKs.Where(x =>
             {
-                string simpleName;
-                string sdkVersion;
-                bool parseSuccessful = ParseSDKReference(x, out simpleName, out sdkVersion);
+                bool parseSuccessful = ParseSDKReference(x, out string simpleName, out string sdkVersion);
                 if (!parseSuccessful)
                 {
                     // If a dependency could not be parsed as an SDK identity then ignore it from the list of unresolved dependencies
@@ -636,13 +527,13 @@ internal static string[] GetUnresolvedDependentSDKs(HashSet<SDKReference> sdkRef
                 return resolvedReference == null;
             })
             .Select(y => String.Format(CultureInfo.CurrentCulture, "\"{0}\"", y))
-            .ToArray<string>();
+            .ToArray();
 
             return unresolvedDependencyIdentities;
         }
 
         /// <summary>
-        ///  Parse out the sdk identities
+        /// Parse out the sdk identities
         /// </summary>
         internal static List<string> ParseDependsOnSDK(string dependsOnSDK)
         {
@@ -659,9 +550,7 @@ internal static List<string> ParseDependsOnSDK(string dependsOnSDK)
         /// </summary>
         internal SDKReference ParseSDKReference(ITaskItem referenceItem)
         {
-            string sdkSimpleName;
-            string rawSdkVersion;
-            bool splitSuccessful = ParseSDKReference(referenceItem.ItemSpec, out sdkSimpleName, out rawSdkVersion);
+            bool splitSuccessful = ParseSDKReference(referenceItem.ItemSpec, out string sdkSimpleName, out string rawSdkVersion);
 
             if (!splitSuccessful)
             {
@@ -669,7 +558,7 @@ internal SDKReference ParseSDKReference(ITaskItem referenceItem)
                 return null;
             }
 
-            SDKReference reference = new SDKReference(referenceItem, sdkSimpleName, rawSdkVersion);
+            var reference = new SDKReference(referenceItem, sdkSimpleName, rawSdkVersion);
             return reference;
         }
 
@@ -686,11 +575,10 @@ private static bool ParseSDKReference(string reference, out string sdkSimpleName
 
             if (match.Success)
             {
-                sdkSimpleName = match.Groups[s_SDKsimpleNameGroup].Value.Trim();
+                sdkSimpleName = match.Groups[SDKsimpleNameGroup].Value.Trim();
 
-                rawSdkVersion = match.Groups[s_SDKVersionGroup].Value.Trim();
-                Version sdkVersion = null;
-                parsedVersion = Version.TryParse(rawSdkVersion, out sdkVersion);
+                rawSdkVersion = match.Groups[SDKVersionGroup].Value.Trim();
+                parsedVersion = Version.TryParse(rawSdkVersion, out _);
             }
 
             return sdkSimpleName.Length > 0 && parsedVersion;
@@ -745,7 +633,7 @@ private void LogResolution(SDKReference reference)
         /// </summary>
         private void LogErrorOrWarning(Tuple<string, object[]> errorOrWarning)
         {
-            if (_logResolutionErrorsAsWarnings)
+            if (LogResolutionErrorsAsWarnings)
             {
                 Log.LogWarningWithCodeFromResources(errorOrWarning.Item1, errorOrWarning.Item2);
             }
@@ -763,7 +651,7 @@ internal class SDKReference : IEquatable<SDKReference>
             /// <summary>
             /// Delimiter for supported architectures
             /// </summary>
-            private static readonly char[] s_supportedArchitecturesSplitChars = new Char[] { ';' };
+            private static readonly char[] s_supportedArchitecturesSplitChars = { ';' };
 
             /// <summary>
             /// Delimiter used to delimit the supported architectures in the error message
@@ -823,7 +711,7 @@ internal class SDKReference : IEquatable<SDKReference>
             /// <summary>
             /// SDKManifest object encapsulating all the information contained in the manifest xml file
             /// </summary>
-            private SDKManifest _sdkManifest = null;
+            private SDKManifest _sdkManifest;
 
             /// <summary>
             /// What should happen if this sdk is resolved with other sdks of the same productfamily or same sdk name.
@@ -833,7 +721,7 @@ internal class SDKReference : IEquatable<SDKReference>
             /// <summary>
             /// Value of the prefer32Bit property from the project.
             /// </summary>
-            private bool _prefer32BitFromProject = false;
+            private bool _prefer32BitFromProject;
 
             #region Constructor
             /// <summary>
@@ -841,9 +729,9 @@ internal class SDKReference : IEquatable<SDKReference>
             /// </summary>
             public SDKReference(ITaskItem taskItem, string sdkName, string sdkVersion)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(taskItem, "taskItem");
-                ErrorUtilities.VerifyThrowArgumentLength(sdkName, "sdkName");
-                ErrorUtilities.VerifyThrowArgumentLength(sdkVersion, "sdkVersion");
+                ErrorUtilities.VerifyThrowArgumentNull(taskItem, nameof(taskItem));
+                ErrorUtilities.VerifyThrowArgumentLength(sdkName, nameof(sdkName));
+                ErrorUtilities.VerifyThrowArgumentLength(sdkVersion, nameof(sdkVersion));
 
                 ReferenceItem = taskItem;
                 SimpleName = sdkName;
@@ -862,281 +750,156 @@ public SDKReference(ITaskItem taskItem, string sdkName, string sdkVersion)
             /// <summary>
             ///  Sdk reference item passed in from the build
             /// </summary>
-            public ITaskItem ReferenceItem
-            {
-                get;
-                private set;
-            }
+            public ITaskItem ReferenceItem { get; }
 
             /// <summary>
             /// Parsed simple name
             /// </summary>
-            public string SimpleName
-            {
-                get;
-                private set;
-            }
+            public string SimpleName { get; }
 
             /// <summary>
             /// Parsed version.
             /// </summary>
-            public string Version
-            {
-                get;
-                private set;
-            }
+            public string Version { get; }
 
             /// <summary>
             /// Resolved full path to the root of the sdk.
             /// </summary>
-            public string ResolvedPath
-            {
-                get;
-                private set;
-            }
+            public string ResolvedPath { get; private set; }
 
             /// <summary>
             /// Has the reference been resolved
             /// </summary>
-            public bool Resolved
-            {
-                get
-                {
-                    return !String.IsNullOrEmpty(ResolvedPath);
-                }
-            }
+            public bool Resolved => !String.IsNullOrEmpty(ResolvedPath);
 
             /// <summary>
             /// Messages which may be warnings or errors depending on the logging setting.
             /// </summary>
-            public List<Tuple<string, object[]>> ResolutionErrors
-            {
-                get;
-                private set;
-            }
+            public List<Tuple<string, object[]>> ResolutionErrors { get; }
 
             /// <summary>
             /// Warning messages only
             /// </summary>
-            public List<Tuple<string, object[]>> ResolutionWarnings
-            {
-                get;
-                private set;
-            }
+            public List<Tuple<string, object[]>> ResolutionWarnings { get; }
 
             /// <summary>
             /// Messages generated during resolution
             /// </summary>
-            public List<Tuple<string, object[]>> StatusMessages
-            {
-                get;
-                private set;
-            }
+            public List<Tuple<string, object[]>> StatusMessages { get; }
 
             /// <summary>
             /// SDKName, this is a formatted name based on the SimpleName and the Version
             /// </summary>
-            public string SDKName
-            {
-                get;
-                private set;
-            }
+            public string SDKName { get; }
 
             /// <summary>
             /// Resolved item which will be output by the task.
             /// </summary>
-            public ITaskItem ResolvedItem
-            {
-                get;
-                set;
-            }
+            public ITaskItem ResolvedItem { get; set; }
 
             /// <summary>
             /// SDKType found in the sdk manifest
             /// </summary>
-            public SDKType SDKType
-            {
-                get;
-                set;
-            }
+            public SDKType SDKType { get; set; }
 
             /// <summary>
             /// The target platform in the sdk manifest
             /// </summary>
-            public string TargetPlatform
-            {
-                get;
-                set;
-            }
+            public string TargetPlatform { get; set; }
 
             /// <summary>
             /// The target platform min version in the sdk manifest
             /// </summary>
-            public string TargetPlatformMinVersion
-            {
-                get;
-                set;
-            }
+            public string TargetPlatformMinVersion { get; set; }
 
             /// <summary>
             /// The target platform max version in the sdk manifest
             /// </summary>
-            public string TargetPlatformVersion
-            {
-                get;
-                set;
-            }
+            public string TargetPlatformVersion { get; set; }
 
             /// <summary>
             /// DisplayName found in the sdk manifest
             /// </summary>
-            public string DisplayName
-            {
-                get;
-                set;
-            }
+            public string DisplayName { get; set; }
 
             /// <summary>
             /// Support Prefer32bit found in the sdk manifest
             /// </summary>
-            public string SupportPrefer32Bit
-            {
-                get;
-                set;
-            }
+            public string SupportPrefer32Bit { get; set; }
 
             /// <summary>
             /// CopyRedistToSubDirectory specifies where the redist files should be copied to relative to the root of the package.
             /// </summary>
-            public string CopyRedistToSubDirectory
-            {
-                get;
-                set;
-            }
+            public string CopyRedistToSubDirectory { get; set; }
 
             /// <summary>
             /// ProductFamilyName specifies the product family for the SDK. This is offered up as metadata on the resolved sdkreference and is used to detect sdk conflicts.
             /// </summary>
-            public string ProductFamilyName
-            {
-                get;
-                set;
-            }
+            public string ProductFamilyName { get; set; }
 
             /// <summary>
             /// SupportsMultipleVersions specifies what should happen if multiple versions of the product family or sdk name are detected
             /// </summary>
             public MultipleVersionSupport SupportsMultipleVersions
             {
-                get
-                {
-                    return _supportsMultipleVersions;
-                }
-
-                set
-                {
-                    _supportsMultipleVersions = value;
-                }
+                get => _supportsMultipleVersions;
+                set => _supportsMultipleVersions = value;
             }
 
             /// <summary>
             /// Supported Architectures is a semicolon delimited list of architectures that the SDK supports.
             /// </summary>
-            public string SupportedArchitectures
-            {
-                get;
-                set;
-            }
+            public string SupportedArchitectures { get; set; }
 
             /// <summary>
             /// DependsOnSDK is a semicolon delimited list of SDK identities that the SDK requires be resolved in order to function.
             /// </summary>
-            public string DependsOnSDK
-            {
-                get;
-                set;
-            }
+            public string DependsOnSDK { get; set; }
 
             /// <summary>
             /// MaxPlatformVersion as in the manifest
             /// </summary>
-            public string MaxPlatformVersion
-            {
-                get;
-                set;
-            }
+            public string MaxPlatformVersion { get; set; }
 
             /// <summary>
             /// MinOSVersion as in the manifest
             /// </summary>
-            public string MinOSVersion
-            {
-                get;
-                set;
-            }
+            public string MinOSVersion { get; set; }
 
             /// <summary>
             /// MaxOSVersionTested as in the manifest
             /// </summary>
-            public string MaxOSVersionTested
-            {
-                get;
-                set;
-            }
+            public string MaxOSVersionTested { get; set; }
 
             /// <summary>
             /// MoreInfo as in the manifest
             /// </summary>
-            public string MoreInfo
-            {
-                get;
-                set;
-            }
+            public string MoreInfo { get; set; }
 
             /// <summary>
             /// What ever framework identities we found in the manifest.
             /// </summary>
-            private Dictionary<string, string> FrameworkIdentitiesFromManifest
-            {
-                get;
-                set;
-            }
+            private Dictionary<string, string> FrameworkIdentitiesFromManifest { get; }
 
             /// <summary>
             /// The frameworkIdentity for the sdk, this may be a single name or a | delimited name
             /// </summary>
-            private string FrameworkIdentity
-            {
-                get;
-                set;
-            }
+            private string FrameworkIdentity { get; set; }
 
             /// <summary>
             /// PlatformIdentity if it exists in the appx manifest for this sdk.
             /// </summary>
-            private string PlatformIdentity
-            {
-                get;
-                set;
-            }
+            private string PlatformIdentity { get; set; }
 
             /// <summary>
             /// Whatever appx locations we found in the manifest
             /// </summary>
-            private Dictionary<string, string> AppxLocationsFromManifest
-            {
-                get;
-                set;
-            }
+            private Dictionary<string, string> AppxLocationsFromManifest { get; }
 
             /// <summary>
             /// The appxlocation for the sdk can be a single name or a | delimited list
             /// </summary>
-            private string AppxLocation
-            {
-                get;
-                set;
-            }
+            private string AppxLocation { get; set; }
 
             #endregion
 
@@ -1154,8 +917,7 @@ public void Resolve(Dictionary<string, ITaskItem> sdks, string targetConfigurati
                     // There must be a trailing slash or else the ExpandSDKReferenceAssemblies will not work.
                     ResolvedPath = FileUtilities.EnsureTrailingSlash(sdks[SDKName].ItemSpec);
 
-                    Version targetPlatformVersionFromItem;
-                    System.Version.TryParse(sdks[SDKName].GetMetadata(SDKPlatformVersion), out targetPlatformVersionFromItem);
+                    System.Version.TryParse(sdks[SDKName].GetMetadata(SDKPlatformVersion), out Version targetPlatformVersionFromItem);
 
                     GetSDKManifestAttributes();
 
@@ -1178,8 +940,7 @@ public void Resolve(Dictionary<string, ITaskItem> sdks, string targetConfigurati
             /// </summary>
             public override bool Equals(object obj)
             {
-                SDKReference reference = obj as SDKReference;
-                if (reference == null)
+                if (!(obj is SDKReference reference))
                 {
                     return false;
                 }
@@ -1210,7 +971,7 @@ public bool Equals(SDKReference other)
                     return true;
                 }
 
-                bool simpleNameMatches = String.Equals(this.SimpleName, other.SimpleName, StringComparison.OrdinalIgnoreCase);
+                bool simpleNameMatches = String.Equals(SimpleName, other.SimpleName, StringComparison.OrdinalIgnoreCase);
                 bool versionMatches = Version.Equals(other.Version, StringComparison.OrdinalIgnoreCase);
 
                 return simpleNameMatches && versionMatches;
@@ -1235,10 +996,10 @@ internal void AddResolutionWarning(string resourceId, params object[] parameters
             /// <summary>
             /// Get a piece of metadata off an item and make sureit is trimmed
             /// </summary>
-            private string GetItemMetadataTrimmed(ITaskItem item, string metadataName)
+            private static string GetItemMetadataTrimmed(ITaskItem item, string metadataName)
             {
                 string metadataValue = item.GetMetadata(metadataName);
-                return metadataValue = metadataValue != null ? metadataValue.Trim() : metadataValue;
+                return metadataValue != null ? metadataValue.Trim() : metadataValue;
             }
 
             /// <summary>
@@ -1361,8 +1122,7 @@ private void GetSDKManifestAttributes()
                 }
                 else
                 {
-                    SDKType sdkType = SDKType.Unspecified;
-                    Enum.TryParse<SDKType>(sdkTypeFromMetadata, out sdkType);
+                    Enum.TryParse<SDKType>(sdkTypeFromMetadata, out SDKType sdkType);
                     SDKType = sdkType;
                 }
 
@@ -1449,7 +1209,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                 AddStatusMessage("ResolveSDKReference.TargetedConfigAndArchitecture", sdkConfiguration, sdkArchitecture);
 
                 string[] supportedArchitectures = null;
-                if (SupportedArchitectures != null && SupportedArchitectures.Length > 0)
+                if (!string.IsNullOrEmpty(SupportedArchitectures))
                 {
                     supportedArchitectures = SupportedArchitectures.Split(s_supportedArchitecturesSplitChars, StringSplitOptions.RemoveEmptyEntries);
                 }
@@ -1490,9 +1250,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                 if (!String.IsNullOrEmpty(MaxPlatformVersion))
                 {
-                    Version maxPlatformVersionAsVersion;
-
-                    if (System.Version.TryParse(MaxPlatformVersion, out maxPlatformVersionAsVersion) && (maxPlatformVersionAsVersion < targetPlatformVersion))
+                    if (System.Version.TryParse(MaxPlatformVersion, out Version maxPlatformVersionAsVersion) && (maxPlatformVersionAsVersion < targetPlatformVersion))
                     {
                         AddResolutionWarning("ResolveSDKReference.MaxPlatformVersionLessThanTargetPlatformVersion", projectName, DisplayName, Version, targetPlatformIdentifier, MaxPlatformVersion, targetPlatformIdentifier, targetPlatformVersion.ToString());
                     }
@@ -1509,9 +1267,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                 if (!String.IsNullOrEmpty(TargetPlatformMinVersion))
                 {
-                    Version targetPlatformMinVersionAsVersion;
-
-                    if (System.Version.TryParse(TargetPlatformMinVersion, out targetPlatformMinVersionAsVersion) && (targetPlatformVersion < targetPlatformMinVersionAsVersion))
+                    if (System.Version.TryParse(TargetPlatformMinVersion, out Version targetPlatformMinVersionAsVersion) && (targetPlatformVersion < targetPlatformMinVersionAsVersion))
                     {
                         AddResolutionErrorOrWarning("ResolveSDKReference.PlatformVersionIsLessThanMinVersion", projectName, DisplayName, Version, targetPlatformVersion.ToString(), targetPlatformMinVersionAsVersion.ToString());
                     }
@@ -1519,8 +1275,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                 if (String.Equals(NeutralArch, sdkArchitecture, StringComparison.OrdinalIgnoreCase) && !String.IsNullOrEmpty(SupportPrefer32Bit) && _prefer32BitFromProject)
                 {
-                    bool supportPrefer32Bit = true;
-                    bool.TryParse(SupportPrefer32Bit, out supportPrefer32Bit);
+                    bool.TryParse(SupportPrefer32Bit, out bool supportPrefer32Bit);
 
                     if (!supportPrefer32Bit)
                     {
@@ -1588,7 +1343,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                         AppxLocation = null;
 
                         // For testing especially it's nice to have a set order of what the generated appxlocation string will be at the end
-                        SortedDictionary<string, string> architectureLocations = new SortedDictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
+                        var architectureLocations = new SortedDictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
                         List<string> appxLocationComponents = new List<string>();
 
                         foreach (var appxLocation in AppxLocationsFromManifest)
@@ -1604,7 +1359,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                                 }
 
                                 string configurationComponent = null;
-                                string architectureComponent = null;
+                                string architectureComponent;
                                 switch (appxComponents.Length)
                                 {
                                     case 1:
@@ -1706,14 +1461,9 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                 if (!hasExpandReferenceAssemblies)
                 {
-                    if (referenceItemHasSDKName)
-                    {
-                        ResolvedItem.SetMetadata(SDKManifest.Attributes.ExpandReferenceAssemblies, "false");
-                    }
-                    else
-                    {
-                        ResolvedItem.SetMetadata(SDKManifest.Attributes.ExpandReferenceAssemblies, "true");
-                    }
+                    ResolvedItem.SetMetadata(
+                        SDKManifest.Attributes.ExpandReferenceAssemblies,
+                        referenceItemHasSDKName ? "false" : "true");
                 }
 
                 if (!hasCopyRedist)
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 6c114b8f62e..53a050fb7bc 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -496,7 +496,7 @@ private static Type FindType(string assemblyPath, string typeName)
                 }
                 else
                 {
-                    List<Type> types = new List<Type>();
+                    var types = new List<Type>();
                     foreach (Type type in loadedAssembly.GetTypes())
                     {
                         if (!type.Name.StartsWith("$", StringComparison.Ordinal))
