diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index defd807a91f..91e1b14d6c1 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -38,14 +38,10 @@ public sealed class MSBuildClient
         private readonly Dictionary<string, string> _serverEnvironmentVariables;
 
         /// <summary>
-        /// Location of executable file to launch the server process. That should be either dotnet.exe or MSBuild.exe location.
+        /// Full path to current MSBuild.exe if executable is MSBuild.exe,
+        /// or to version of MSBuild.dll found to be associated with the current process.
         /// </summary>
-        private readonly string _exeLocation;
-
-        /// <summary>
-        /// Location of dll file to launch the server process if needed. Empty if executable is msbuild.exe and not empty if dotnet.exe.
-        /// </summary>
-        private readonly string _dllLocation;
+        private readonly string _msbuildLocation;
 
         /// <summary>
         /// The MSBuild client execution result.
@@ -91,18 +87,15 @@ public sealed class MSBuildClient
         /// <summary>
         /// Public constructor with parameters.
         /// </summary>
-        /// <param name="exeLocation">Location of executable file to launch the server process.
-        /// That should be either dotnet.exe or MSBuild.exe location.</param>
-        /// <param name="dllLocation">Location of dll file to launch the server process if needed.
-        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>
-        public MSBuildClient(string exeLocation, string dllLocation)
+        /// <param name="msbuildLocation"> Full path to current MSBuild.exe if executable is MSBuild.exe,
+        /// or to version of MSBuild.dll found to be associated with the current process.</param>
+        public MSBuildClient(string msbuildLocation)
         {
             _serverEnvironmentVariables = new();
             _exitResult = new();
 
             // dll & exe locations
-            _exeLocation = exeLocation;
-            _dllLocation = dllLocation;
+            _msbuildLocation = msbuildLocation;
 
             // Client <-> Server communication stream
             _handshake = GetHandshake();
@@ -249,24 +242,17 @@ private bool TryLaunchServer()
 
             // Temporary hack
             string[] msBuildServerOptions = new string[] {
-                // _dllLocation,
                 "/nologo",
                 "/nodemode:8"
             };
 
-            string msbuildLocation;
-            if (string.IsNullOrEmpty(_dllLocation))
-            {
-                msbuildLocation = _exeLocation;
-            }
-            else
-            {
-                msbuildLocation = _dllLocation;
-            }
-
+            string useMSBuildServerEnvVar = Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName);
             try
             {
-                Process msbuildProcess = LaunchNode(msbuildLocation, string.Join(" ", msBuildServerOptions), _serverEnvironmentVariables);
+                // Disable msbuild server in a child process, preventing an infinite recurson.
+                Environment.SetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName, "");
+
+                Process msbuildProcess = NodeLauncher.LaunchNode(_msbuildLocation, string.Join(" ", msBuildServerOptions));
                 CommunicationsUtilities.Trace("Server is launched with PID: {0}", msbuildProcess?.Id);
             }
             catch (Exception ex)
@@ -275,355 +261,12 @@ private bool TryLaunchServer()
                 _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;
                 return false;
             }
-
-            return true;
-        }
-
-        /* 
-
-                private Process? LaunchNode(string exeLocation, string msBuildServerArguments, Dictionary<string, string> serverEnvironmentVariables)
-                {
-                    CommunicationsUtilities.Trace("Launching server node from {0} with arguments {1}", exeLocation, msBuildServerArguments);
-
-                    BackendNativeMethods.STARTUP_INFO startInfo = new();
-                    startInfo.cb = Marshal.SizeOf<BackendNativeMethods.STARTUP_INFO>();
-
-                    // Null out the process handles so that the parent process does not wait for the child process
-                    // to exit before it can exit.
-                    uint creationFlags = 0;
-                    if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-                    {
-                        creationFlags = BackendNativeMethods.NORMALPRIORITYCLASS;
-                    }
-
-                    if (!NativeMethodsShared.IsWindows)
-                    {
-                        ProcessStartInfo processStartInfo = new()
-                        {
-                            FileName = exeLocation,
-                            Arguments = msBuildServerArguments,
-                            UseShellExecute = false
-                        };
-
-                        foreach (var entry in serverEnvironmentVariables)
-                        {
-                            processStartInfo.Environment[entry.Key] = entry.Value;
-                        }
-
-                        // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.
-                        processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = "0";
-
-                        processStartInfo.CreateNoWindow = true;
-                        processStartInfo.UseShellExecute = false;
-
-                        // Redirect the streams of worker nodes so that this MSBuild.exe's
-                        // parent doesn't wait on idle worker nodes to close streams
-                        // after the build is complete.
-                        processStartInfo.RedirectStandardInput = true;
-                        processStartInfo.RedirectStandardOutput = true;
-                        processStartInfo.RedirectStandardError = true;
-
-                        Process? process = null;
-                        try
-                        {
-                            process = Process.Start(processStartInfo);
-                        }
-                        catch (Exception ex)
-                        {
-                            CommunicationsUtilities.Trace
-                               (
-                                   "Failed to launch server node from {0}. CommandLine: {1}" + Environment.NewLine + "{2}",
-                                   exeLocation,
-                                   msBuildServerArguments,
-                                   ex.ToString()
-                               );
-
-                            throw new NodeFailedToLaunchException(ex);
-                        }
-
-                        CommunicationsUtilities.Trace("Successfully launched server node with PID {0}", process?.Id);
-                        return process;
-                    }
-                    else
-                    {
-                        // TODO: IT DOES NOT USE EXTRA ENV VARIABLES!!!
-
-                        BackendNativeMethods.PROCESS_INFORMATION processInfo = new();
-                        BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new();
-                        BackendNativeMethods.SECURITY_ATTRIBUTES threadSecurityAttributes = new();
-                        processSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
-                        threadSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
-
-                        bool result = false;
-                        try
-                        {
-                            Environment.SetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName, "0");
-                            result = BackendNativeMethods.CreateProcess
-                           (
-                               exeLocation,
-                               msBuildServerArguments,
-                               ref processSecurityAttributes,
-                               ref threadSecurityAttributes,
-                               false,
-                               creationFlags,
-                               BackendNativeMethods.NullPtr,
-                               null,
-                               ref startInfo,
-                               out processInfo
-                           );
-                        }
-                        finally
-                        {
-                            Environment.SetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName, "1");
-                        }
-
-
-                        if (!result)
-                        {
-                            // Creating an instance of this exception calls GetLastWin32Error and also converts it to a user-friendly string.
-                            System.ComponentModel.Win32Exception e = new System.ComponentModel.Win32Exception();
-
-                            CommunicationsUtilities.Trace
-                                (
-                                    "Failed to launch node from {0}. System32 Error code {1}. Description {2}. CommandLine: {2}",
-                                    exeLocation,
-                                    e.NativeErrorCode.ToString(CultureInfo.InvariantCulture),
-                                    e.Message,
-                                    msBuildServerArguments
-                                );
-
-                            throw new NodeFailedToLaunchException(e.NativeErrorCode.ToString(CultureInfo.InvariantCulture), e.Message);
-                        }
-
-                        int childProcessId = processInfo.dwProcessId;
-
-                        if (processInfo.hProcess != IntPtr.Zero && processInfo.hProcess != NativeMethods.InvalidHandle)
-                        {
-                            NativeMethodsShared.CloseHandle(processInfo.hProcess);
-                        }
-
-                        if (processInfo.hThread != IntPtr.Zero && processInfo.hThread != NativeMethods.InvalidHandle)
-                        {
-                            NativeMethodsShared.CloseHandle(processInfo.hThread);
-                        }
-
-                        CommunicationsUtilities.Trace("Successfully launched server node with PID {0}", childProcessId);
-                        return Process.GetProcessById(childProcessId);
-                    } 
-                }
-        */
-
-
-#if RUNTIME_TYPE_NETCORE || MONO
-        private static string CurrentHost;
-#endif
-
-        /// <summary>
-        /// Identify the .NET host of the current process.
-        /// </summary>
-        /// <returns>The full path to the executable hosting the current process, or null if running on Full Framework on Windows.</returns>
-        private static string GetCurrentHost()
-        {
-#if RUNTIME_TYPE_NETCORE || MONO
-            if (CurrentHost == null)
-            {
-                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
-                    NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
-                if (File.Exists(dotnetExe))
-                {
-                    CurrentHost = dotnetExe;
-                }
-                else
-                {
-                    using (Process currentProcess = Process.GetCurrentProcess())
-                    {
-                        CurrentHost = currentProcess.MainModule.FileName;
-                    }
-                }
-            }
-
-            return CurrentHost;
-#else
-            return null;
-#endif
-        }
-
-        private Process LaunchNode(string msbuildLocation, string commandLineArgs, Dictionary<string, string> serverEnvironmentVariables)
-        {
-            // Should always have been set already.
-            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
-
-            if (!FileSystems.Default.FileExists(msbuildLocation))
+            finally
             {
-                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
+                Environment.SetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName, useMSBuildServerEnvVar);
             }
 
-            // Repeat the executable name as the first token of the command line because the command line
-            // parser logic expects it and will otherwise skip the first argument
-            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
-
-            BackendNativeMethods.STARTUP_INFO startInfo = new();
-            startInfo.cb = Marshal.SizeOf<BackendNativeMethods.STARTUP_INFO>();
-
-            // Null out the process handles so that the parent process does not wait for the child process
-            // to exit before it can exit.
-            uint creationFlags = 0;
-            if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-            {
-                creationFlags = BackendNativeMethods.NORMALPRIORITYCLASS;
-            }
-
-            if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDNODEWINDOW")))
-            {
-                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-                {
-                    // Redirect the streams of worker nodes so that this MSBuild.exe's
-                    // parent doesn't wait on idle worker nodes to close streams
-                    // after the build is complete.
-                    startInfo.hStdError = BackendNativeMethods.InvalidHandle;
-                    startInfo.hStdInput = BackendNativeMethods.InvalidHandle;
-                    startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;
-                    startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;
-                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;
-                }
-            }
-            else
-            {
-                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;
-            }
-
-            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
-
-            string exeName = msbuildLocation;
-
-#if RUNTIME_TYPE_NETCORE || MONO
-            // Mono automagically uses the current mono, to execute a managed assembly
-            if (!NativeMethodsShared.IsMono)
-            {
-                // Run the child process with the same host as the currently-running process.
-                exeName = GetCurrentHost();
-            }
-#endif
-
-            if (!NativeMethodsShared.IsWindows)
-            {
-                ProcessStartInfo processStartInfo = new ProcessStartInfo();
-                processStartInfo.FileName = exeName;
-                processStartInfo.Arguments = commandLineArgs;
-                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-                {
-                    // Redirect the streams of worker nodes so that this MSBuild.exe's
-                    // parent doesn't wait on idle worker nodes to close streams
-                    // after the build is complete.
-                    processStartInfo.RedirectStandardInput = true;
-                    processStartInfo.RedirectStandardOutput = true;
-                    processStartInfo.RedirectStandardError = true;
-                    processStartInfo.CreateNoWindow = (creationFlags | BackendNativeMethods.CREATENOWINDOW) == BackendNativeMethods.CREATENOWINDOW;
-                }
-                processStartInfo.UseShellExecute = false;
-
-
-                foreach (var entry in serverEnvironmentVariables)
-                {
-                    processStartInfo.Environment[entry.Key] = entry.Value;
-                }
-
-                // We remove env to enable MSBuild Server that might be equal to 1, so we do not get an infinite recursion here.
-                processStartInfo.Environment[Traits.UseMSBuildServerEnvVarName] = "0";
-
-                Process process;
-                try
-                {
-                    process = Process.Start(processStartInfo);
-                }
-                catch (Exception ex)
-                {
-                    CommunicationsUtilities.Trace
-                       (
-                           "Failed to launch node from {0}. CommandLine: {1}" + Environment.NewLine + "{2}",
-                           msbuildLocation,
-                           commandLineArgs,
-                           ex.ToString()
-                       );
-
-                    throw new NodeFailedToLaunchException(ex);
-                }
-
-                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", process.Id, exeName);
-                return process;
-            }
-            else
-            {
-                // TODO: IT DOES NOT USE EXTRA ENV VARIABLES!!!
-
-#if RUNTIME_TYPE_NETCORE
-                // Repeat the executable name in the args to suit CreateProcess
-                commandLineArgs = $"\"{exeName}\" {commandLineArgs}";
-#endif
-
-                BackendNativeMethods.PROCESS_INFORMATION processInfo = new();
-                BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new();
-                BackendNativeMethods.SECURITY_ATTRIBUTES threadSecurityAttributes = new();
-                processSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
-                threadSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
-
-
-                bool result = false;
-                try
-                {
-                    Environment.SetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName, "0");
-                    result = BackendNativeMethods.CreateProcess
-                    (
-                        exeName,
-                        commandLineArgs,
-                        ref processSecurityAttributes,
-                        ref threadSecurityAttributes,
-                        false,
-                        creationFlags,
-                        BackendNativeMethods.NullPtr,
-                        null,
-                        ref startInfo,
-                        out processInfo
-                    );
-                }
-                finally
-                {
-                    Environment.SetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName, "1");
-                }
-
-
-                if (!result)
-                {
-                    // Creating an instance of this exception calls GetLastWin32Error and also converts it to a user-friendly string.
-                    System.ComponentModel.Win32Exception e = new System.ComponentModel.Win32Exception();
-
-                    CommunicationsUtilities.Trace
-                        (
-                            "Failed to launch node from {0}. System32 Error code {1}. Description {2}. CommandLine: {2}",
-                            msbuildLocation,
-                            e.NativeErrorCode.ToString(CultureInfo.InvariantCulture),
-                            e.Message,
-                            commandLineArgs
-                        );
-
-                    throw new NodeFailedToLaunchException(e.NativeErrorCode.ToString(CultureInfo.InvariantCulture), e.Message);
-                }
-
-                int childProcessId = processInfo.dwProcessId;
-
-                if (processInfo.hProcess != IntPtr.Zero && processInfo.hProcess != NativeMethods.InvalidHandle)
-                {
-                    NativeMethodsShared.CloseHandle(processInfo.hProcess);
-                }
-
-                if (processInfo.hThread != IntPtr.Zero && processInfo.hThread != NativeMethods.InvalidHandle)
-                {
-                    NativeMethodsShared.CloseHandle(processInfo.hThread);
-                }
-
-                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", childProcessId, exeName);
-                return Process.GetProcessById(childProcessId);
-            }
+            return true;
         }
 
         private bool TrySendBuildCommand(string commandLine)
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
new file mode 100644
index 00000000000..a3fcb1c2edf
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -0,0 +1,216 @@
+﻿using System;
+using System.Diagnostics;
+using System.Globalization;
+using System.IO;
+using System.Runtime.InteropServices;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+#nullable disable
+
+namespace Microsoft.Build.BackEnd
+{
+    internal static class NodeLauncher
+    {
+
+#if RUNTIME_TYPE_NETCORE || MONO
+        public static string CurrentHost;
+#endif
+
+        /// <summary>
+        /// Identify the .NET host of the current process.
+        /// </summary>
+        /// <returns>The full path to the executable hosting the current process, or null if running on Full Framework on Windows.</returns>
+        public static string GetCurrentHost()
+        {
+#if RUNTIME_TYPE_NETCORE || MONO
+            if (CurrentHost == null)
+            {
+                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
+                    NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
+                if (File.Exists(dotnetExe))
+                {
+                    CurrentHost = dotnetExe;
+                }
+                else
+                {
+                    using (Process currentProcess = Process.GetCurrentProcess())
+                    {
+                        CurrentHost = currentProcess.MainModule.FileName;
+                    }
+                }
+            }
+
+            return CurrentHost;
+#else
+            return null;
+#endif
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process
+        /// </summary>
+        public static Process LaunchNode(string msbuildLocation, string commandLineArgs)
+        {
+            // Should always have been set already.
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
+
+            if (!FileSystems.Default.FileExists(msbuildLocation))
+            {
+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
+            }
+
+            // Repeat the executable name as the first token of the command line because the command line
+            // parser logic expects it and will otherwise skip the first argument
+            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
+
+            BackendNativeMethods.STARTUP_INFO startInfo = new();
+            startInfo.cb = Marshal.SizeOf<BackendNativeMethods.STARTUP_INFO>();
+
+            // Null out the process handles so that the parent process does not wait for the child process
+            // to exit before it can exit.
+            uint creationFlags = 0;
+            if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+            {
+                creationFlags = BackendNativeMethods.NORMALPRIORITYCLASS;
+            }
+
+            if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDNODEWINDOW")))
+            {
+                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+                {
+                    // Redirect the streams of worker nodes so that this MSBuild.exe's
+                    // parent doesn't wait on idle worker nodes to close streams
+                    // after the build is complete.
+                    startInfo.hStdError = BackendNativeMethods.InvalidHandle;
+                    startInfo.hStdInput = BackendNativeMethods.InvalidHandle;
+                    startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;
+                    startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;
+                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;
+                }
+            }
+            else
+            {
+                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;
+            }
+
+            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
+
+            string exeName = msbuildLocation;
+
+#if RUNTIME_TYPE_NETCORE || MONO
+            // Mono automagically uses the current mono, to execute a managed assembly
+            if (!NativeMethodsShared.IsMono)
+            {
+                // Run the child process with the same host as the currently-running process.
+                exeName = GetCurrentHost();
+            }
+#endif
+
+            if (!NativeMethodsShared.IsWindows)
+            {
+                ProcessStartInfo processStartInfo = new ProcessStartInfo();
+                processStartInfo.FileName = exeName;
+                processStartInfo.Arguments = commandLineArgs;
+                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+                {
+                    // Redirect the streams of worker nodes so that this MSBuild.exe's
+                    // parent doesn't wait on idle worker nodes to close streams
+                    // after the build is complete.
+                    processStartInfo.RedirectStandardInput = true;
+                    processStartInfo.RedirectStandardOutput = true;
+                    processStartInfo.RedirectStandardError = true;
+                    processStartInfo.CreateNoWindow = (creationFlags | BackendNativeMethods.CREATENOWINDOW) == BackendNativeMethods.CREATENOWINDOW;
+                }
+                processStartInfo.UseShellExecute = false;
+
+                Process process;
+                try
+                {
+                    process = Process.Start(processStartInfo);
+                }
+                catch (Exception ex)
+                {
+                    CommunicationsUtilities.Trace
+                       (
+                           "Failed to launch node from {0}. CommandLine: {1}" + Environment.NewLine + "{2}",
+                           msbuildLocation,
+                           commandLineArgs,
+                           ex.ToString()
+                       );
+
+                    throw new NodeFailedToLaunchException(ex);
+                }
+
+                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", process.Id, exeName);
+                return process;
+            }
+            else
+            {
+#if RUNTIME_TYPE_NETCORE
+                // Repeat the executable name in the args to suit CreateProcess
+                commandLineArgs = $"\"{exeName}\" {commandLineArgs}";
+#endif
+
+                BackendNativeMethods.PROCESS_INFORMATION processInfo = new();
+                BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new();
+                BackendNativeMethods.SECURITY_ATTRIBUTES threadSecurityAttributes = new();
+                processSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
+                threadSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
+
+                bool result = BackendNativeMethods.CreateProcess
+                    (
+                        exeName,
+                        commandLineArgs,
+                        ref processSecurityAttributes,
+                        ref threadSecurityAttributes,
+                        false,
+                        creationFlags,
+                        BackendNativeMethods.NullPtr,
+                        null,
+                        ref startInfo,
+                        out processInfo
+                    );
+
+                if (!result)
+                {
+                    // Creating an instance of this exception calls GetLastWin32Error and also converts it to a user-friendly string.
+                    System.ComponentModel.Win32Exception e = new System.ComponentModel.Win32Exception();
+
+                    CommunicationsUtilities.Trace
+                        (
+                            "Failed to launch node from {0}. System32 Error code {1}. Description {2}. CommandLine: {2}",
+                            msbuildLocation,
+                            e.NativeErrorCode.ToString(CultureInfo.InvariantCulture),
+                            e.Message,
+                            commandLineArgs
+                        );
+
+                    throw new NodeFailedToLaunchException(e.NativeErrorCode.ToString(CultureInfo.InvariantCulture), e.Message);
+                }
+
+                int childProcessId = processInfo.dwProcessId;
+
+                if (processInfo.hProcess != IntPtr.Zero && processInfo.hProcess != NativeMethods.InvalidHandle)
+                {
+                    NativeMethodsShared.CloseHandle(processInfo.hProcess);
+                }
+
+                if (processInfo.hThread != IntPtr.Zero && processInfo.hThread != NativeMethods.InvalidHandle)
+                {
+                    NativeMethodsShared.CloseHandle(processInfo.hThread);
+                }
+
+                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", childProcessId, exeName);
+                return Process.GetProcessById(childProcessId);
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index b667e7a60f2..d15ac521da7 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -274,7 +274,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
 #endif
 
                 // Create the node process
-                Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);
+                Process msbuildProcess = NodeLauncher.LaunchNode(msbuildLocation, commandLineArgs);
                 _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));
 
                 // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
@@ -332,7 +332,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                 msbuildLocation = "MSBuild.exe";
             }
 
-            var expectedProcessName = Path.GetFileNameWithoutExtension(GetCurrentHost() ?? msbuildLocation);
+            var expectedProcessName = Path.GetFileNameWithoutExtension(NodeLauncher.GetCurrentHost() ?? msbuildLocation);
 
             List<Process> nodeProcesses = new List<Process>(Process.GetProcessesByName(expectedProcessName));
 
@@ -441,199 +441,6 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake han
             return null;
         }
 
-        /// <summary>
-        /// Creates a new MSBuild process
-        /// </summary>
-        private Process LaunchNode(string msbuildLocation, string commandLineArgs)
-        {
-            // Should always have been set already.
-            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
-
-            if (!FileSystems.Default.FileExists(msbuildLocation))
-            {
-                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
-            }
-
-            // Repeat the executable name as the first token of the command line because the command line
-            // parser logic expects it and will otherwise skip the first argument
-            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
-
-            BackendNativeMethods.STARTUP_INFO startInfo = new();
-            startInfo.cb = Marshal.SizeOf<BackendNativeMethods.STARTUP_INFO>();
-
-            // Null out the process handles so that the parent process does not wait for the child process
-            // to exit before it can exit.
-            uint creationFlags = 0;
-            if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-            {
-                creationFlags = BackendNativeMethods.NORMALPRIORITYCLASS;
-            }
-
-            if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDNODEWINDOW")))
-            {
-                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-                {
-                    // Redirect the streams of worker nodes so that this MSBuild.exe's
-                    // parent doesn't wait on idle worker nodes to close streams
-                    // after the build is complete.
-                    startInfo.hStdError = BackendNativeMethods.InvalidHandle;
-                    startInfo.hStdInput = BackendNativeMethods.InvalidHandle;
-                    startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;
-                    startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;
-                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;
-                }
-            }
-            else
-            {
-                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;
-            }
-
-            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
-
-            string exeName = msbuildLocation;
-
-#if RUNTIME_TYPE_NETCORE || MONO
-            // Mono automagically uses the current mono, to execute a managed assembly
-            if (!NativeMethodsShared.IsMono)
-            {
-                // Run the child process with the same host as the currently-running process.
-                exeName = GetCurrentHost();
-            }
-#endif
-
-            if (!NativeMethodsShared.IsWindows)
-            {
-                ProcessStartInfo processStartInfo = new ProcessStartInfo();
-                processStartInfo.FileName = exeName;
-                processStartInfo.Arguments = commandLineArgs;
-                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-                {
-                    // Redirect the streams of worker nodes so that this MSBuild.exe's
-                    // parent doesn't wait on idle worker nodes to close streams
-                    // after the build is complete.
-                    processStartInfo.RedirectStandardInput = true;
-                    processStartInfo.RedirectStandardOutput = true;
-                    processStartInfo.RedirectStandardError = true;
-                    processStartInfo.CreateNoWindow = (creationFlags | BackendNativeMethods.CREATENOWINDOW) == BackendNativeMethods.CREATENOWINDOW;
-                }
-                processStartInfo.UseShellExecute = false;
-
-                Process process;
-                try
-                {
-                    process = Process.Start(processStartInfo);
-                }
-                catch (Exception ex)
-                {
-                    CommunicationsUtilities.Trace
-                       (
-                           "Failed to launch node from {0}. CommandLine: {1}" + Environment.NewLine + "{2}",
-                           msbuildLocation,
-                           commandLineArgs,
-                           ex.ToString()
-                       );
-
-                    throw new NodeFailedToLaunchException(ex);
-                }
-
-                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", process.Id, exeName);
-                return process;
-            }
-            else
-            {
-#if RUNTIME_TYPE_NETCORE
-                // Repeat the executable name in the args to suit CreateProcess
-                commandLineArgs = $"\"{exeName}\" {commandLineArgs}";
-#endif
-
-                BackendNativeMethods.PROCESS_INFORMATION processInfo = new();
-                BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new();
-                BackendNativeMethods.SECURITY_ATTRIBUTES threadSecurityAttributes = new();
-                processSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
-                threadSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
-
-                bool result = BackendNativeMethods.CreateProcess
-                    (
-                        exeName,
-                        commandLineArgs,
-                        ref processSecurityAttributes,
-                        ref threadSecurityAttributes,
-                        false,
-                        creationFlags,
-                        BackendNativeMethods.NullPtr,
-                        null,
-                        ref startInfo,
-                        out processInfo
-                    );
-
-                if (!result)
-                {
-                    // Creating an instance of this exception calls GetLastWin32Error and also converts it to a user-friendly string.
-                    System.ComponentModel.Win32Exception e = new System.ComponentModel.Win32Exception();
-
-                    CommunicationsUtilities.Trace
-                        (
-                            "Failed to launch node from {0}. System32 Error code {1}. Description {2}. CommandLine: {2}",
-                            msbuildLocation,
-                            e.NativeErrorCode.ToString(CultureInfo.InvariantCulture),
-                            e.Message,
-                            commandLineArgs
-                        );
-
-                    throw new NodeFailedToLaunchException(e.NativeErrorCode.ToString(CultureInfo.InvariantCulture), e.Message);
-                }
-
-                int childProcessId = processInfo.dwProcessId;
-
-                if (processInfo.hProcess != IntPtr.Zero && processInfo.hProcess != NativeMethods.InvalidHandle)
-                {
-                    NativeMethodsShared.CloseHandle(processInfo.hProcess);
-                }
-
-                if (processInfo.hThread != IntPtr.Zero && processInfo.hThread != NativeMethods.InvalidHandle)
-                {
-                    NativeMethodsShared.CloseHandle(processInfo.hThread);
-                }
-
-                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", childProcessId, exeName);
-                return Process.GetProcessById(childProcessId);
-            }
-        }
-
-#if RUNTIME_TYPE_NETCORE || MONO
-        private static string CurrentHost;
-#endif
-
-        /// <summary>
-        /// Identify the .NET host of the current process.
-        /// </summary>
-        /// <returns>The full path to the executable hosting the current process, or null if running on Full Framework on Windows.</returns>
-        private static string GetCurrentHost()
-        {
-#if RUNTIME_TYPE_NETCORE || MONO
-            if (CurrentHost == null)
-            {
-                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
-                    NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
-                if (File.Exists(dotnetExe))
-                {
-                    CurrentHost = dotnetExe;
-                }
-                else
-                {
-                    using (Process currentProcess = Process.GetCurrentProcess())
-                    {
-                        CurrentHost = currentProcess.MainModule.FileName;
-                    }
-                }
-            }
-
-            return CurrentHost;
-#else
-            return null;
-#endif
-        }
-
         /// <summary>
         /// Class which wraps up the communications infrastructure for a given node.
         /// </summary>
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 9c4bbac8ee4..aacd09479bf 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -350,6 +350,7 @@
     <Compile Include="BackEnd\Components\Communications\INodeProvider.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeEndpointInProc.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeInfo.cs" />
+    <Compile Include="BackEnd\Components\Communications\NodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderInProc.cs" />
     <Compile Include="BackEnd\Components\IBuildComponent.cs" />
     <Compile Include="BackEnd\Components\IBuildComponentHost.cs" />
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index 349a8e57aac..f0cb78f18fc 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,6 +1,6 @@
 Microsoft.Build.Execution.MSBuildClient
 Microsoft.Build.Execution.MSBuildClient.Execute(string commandLine, System.Threading.CancellationToken cancellationToken) -> Microsoft.Build.Execution.MSBuildClientExitResult
-Microsoft.Build.Execution.MSBuildClient.MSBuildClient(string exeLocation, string dllLocation) -> void
+Microsoft.Build.Execution.MSBuildClient.MSBuildClient(string msbuildLocation) -> void
 Microsoft.Build.Execution.MSBuildClientExitResult
 Microsoft.Build.Execution.MSBuildClientExitResult.MSBuildAppExitTypeString.get -> string
 Microsoft.Build.Execution.MSBuildClientExitResult.MSBuildAppExitTypeString.set -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 39c901f1b5c..6a522fbd526 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,6 +1,6 @@
 Microsoft.Build.Execution.MSBuildClient
 Microsoft.Build.Execution.MSBuildClient.Execute(string commandLine, System.Threading.CancellationToken cancellationToken) -> Microsoft.Build.Execution.MSBuildClientExitResult
-Microsoft.Build.Execution.MSBuildClient.MSBuildClient(string exeLocation, string dllLocation) -> void
+Microsoft.Build.Execution.MSBuildClient.MSBuildClient(string msbuildLocation) -> void
 Microsoft.Build.Execution.MSBuildClientExitResult
 Microsoft.Build.Execution.MSBuildClientExitResult.MSBuildAppExitTypeString.get -> string
 Microsoft.Build.Execution.MSBuildClientExitResult.MSBuildAppExitTypeString.set -> void
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index de83c3a10e3..ef39eb8f1b3 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -42,34 +42,12 @@ public static MSBuildApp.ExitType Execute(
             CancellationToken cancellationToken
             )
         {
-            string? exeLocation;
-            string? dllLocation;
-
-#if RUNTIME_TYPE_NETCORE || MONO
-            // Run the child process with the same host as the currently-running process.
-            // Mono automatically uses the current mono, to execute a managed assembly.
-            if (!NativeMethodsShared.IsMono)
-            {
-                // _exeFileLocation consists the msbuild dll instead.
-                dllLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
-                exeLocation = GetCurrentHost();
-            }
-            else
-            {
-                // _exeFileLocation consists the msbuild dll instead.
-                exeLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
-                dllLocation = String.Empty;
-            }
-#else
-            exeLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
-            dllLocation = String.Empty;
-#endif
+            string msbuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
 
             return Execute(
                 commandLine,
                 cancellationToken,
-                exeLocation,
-                dllLocation
+                msbuildLocation
             );
         }
 
@@ -80,10 +58,8 @@ CancellationToken cancellationToken
         /// on the command line is assumed to be the name/path of the executable, and
         /// is ignored.</param>
         /// <param name="cancellationToken">Cancellation token.</param>
-        /// <param name="exeLocation">Location of executable file to launch the server process.
-        /// That should be either dotnet.exe or MSBuild.exe location.</param>
-        /// <param name="dllLocation">Location of dll file to launch the server process if needed.
-        /// Empty if executable is msbuild.exe and not empty if dotnet.exe.</param>
+        /// <param name="msbuildLocation"> Full path to current MSBuild.exe if executable is MSBuild.exe,
+        /// or to version of MSBuild.dll found to be associated with the current process.</param>
         /// <returns>A value of type <see cref="MSBuildApp.ExitType"/> that indicates whether the build succeeded,
         /// or the manner in which it failed.</returns>
         public static MSBuildApp.ExitType Execute(
@@ -93,8 +69,7 @@ public static MSBuildApp.ExitType Execute(
             string[] commandLine,
 #endif
             CancellationToken cancellationToken,
-            string exeLocation,
-            string dllLocation
+            string msbuildLocation
         )
         {
             // MSBuild client orchestration.
@@ -103,7 +78,7 @@ string dllLocation
 #else
             string commandLineString = commandLine;
 #endif
-            MSBuildClient msbuildClient = new MSBuildClient(exeLocation, dllLocation); 
+            MSBuildClient msbuildClient = new MSBuildClient(msbuildLocation); 
             MSBuildClientExitResult exitResult = msbuildClient.Execute(commandLineString, cancellationToken);
 
             if (exitResult.MSBuildClientExitType == MSBuildClientExitType.ServerBusy ||
