diff --git a/.editorconfig b/.editorconfig
index 90ed95160d4..7b0f1419bb8 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -401,3 +401,11 @@ dotnet_diagnostic.IDE0270.severity = suggestion
 
 # naming rule violation
 dotnet_diagnostic.IDE1006.severity = suggestion
+
+# Use primary constructor
+dotnet_diagnostic.IDE0290.severity = suggestion
+
+# Collection initialization can be simplified
+dotnet_diagnostic.IDE0300.severity = suggestion
+dotnet_diagnostic.IDE0301.severity = suggestion
+dotnet_diagnostic.IDE0305.severity = suggestion
diff --git a/.exp-insertions.yml b/.exp-insertions.yml
new file mode 100644
index 00000000000..2c8a1c06a1a
--- /dev/null
+++ b/.exp-insertions.yml
@@ -0,0 +1,220 @@
+# Pipeline creates experimental msbuild insertions.
+
+trigger: none # Prevents this pipeline from triggering on check-ins
+pr: none # don't run this on PR as well
+
+parameters:
+  # Dotnet installer channel from which to take the latest dotnet bits.
+  - name: DotnetInstallerChannel
+    displayName: Dotnet installer channel
+    type: string
+    default: 'none'
+  # VS version for which to take the latest Retail MSBuild bits.
+  - name: VSVersionName
+    displayName: VS Version
+    type: string
+    default: 'none'
+  # Branch from the MSBuild Build CI pipeline. Default: main
+  # Top run for the branch would be used to create an experimental insertion.
+  - name: MSBuildBranch
+    displayName: MSBuild Branch
+    type: string
+    default: 'refs/heads/main'
+  # BuildID from the MSBuild Build CI pipeline. Overrides the choice of MSBuildBranch parameter
+  - name: MSBuildBuildID
+    displayName: MSBuild CI Run Override
+    type: string
+    default: 'default'
+
+variables:
+  - name: _MsBuildCiPipelineId
+    value: 9434
+  - name: _MSBuildConfigFilePathRequestURL
+    value: 'https://dev.azure.com/cloudbuild/CloudBuild/_apis/git/repositories/CloudBuildConfig/items?versionDescriptor.version=main&path=config/batmon/Q-Prod-Co3/Coordinator/ToolsReleaseConfig-GeneralPublic.json&api-version=5.0'
+  - name: VSVersion
+    value: ${{parameters.VSVersionName}}
+
+pool:
+  vmImage: windows-latest
+
+jobs:
+- job: CreateExpDotnet
+  displayName: Create Experimental Dotnet
+  condition: ne('${{ parameters.DotnetInstallerChannel }}', 'none')
+  steps:
+  - powershell: |
+      mkdir '$(System.ArtifactsDirectory)/installer'
+
+      $dotnetChannel = '${{parameters.DotnetInstallerChannel}}'
+      $sdks = "dotnet-sdk-win-x64.zip", "dotnet-sdk-linux-x64.tar.gz"
+
+      foreach ($sdk in $sdks)
+      {
+        Write-Host "Downloading dotnet $sdk from channel $dotnetChannel"
+        Invoke-WebRequest `
+          -Uri "https://aka.ms/dotnet/$dotnetChannel/daily/$sdk" `
+          -OutFile "$(System.ArtifactsDirectory)/installer/$sdk"
+      }
+      mkdir '$(Pipeline.Workspace)/artifacts'
+    displayName: Download latest dotnet sdks
+
+  - task: DownloadBuildArtifacts@1
+    inputs:
+      buildType: specific
+      project: DevDiv
+      pipeline: $(_MsBuildCiPipelineId)
+      ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
+        buildVersionToDownload: latestFromBranch
+        branchName: '${{parameters.MSBuildBranch}}'
+      ${{ else }}:
+        buildVersionToDownload: specific
+        buildId: ${{parameters.MSBuildBuildID}}
+      artifactName: bin
+      itemPattern: 'MSBuild.Bootstrap/**'
+      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
+    displayName: Download msbuild artifacts
+
+  - powershell: |
+      $sdk = "dotnet-sdk-win-x64"
+
+      Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.zip"
+      Expand-Archive "$(System.ArtifactsDirectory)/installer/$sdk.zip" -DestinationPath "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+
+      $dotnetDirectory = Get-ChildItem -Directory -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk"
+      $dotnetVersion = $dotnetDirectory.Name
+      Write-Host "Detected dotnet version: $dotnetVersion"
+
+      Write-Host "Updating MSBuild dlls."
+      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
+        -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
+        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
+        -configuration Release `
+        -makeBackup $false
+
+      Write-Host "Compressing dotnet sdk files"
+      Get-ChildItem -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/$sdk.zip"
+
+    displayName: Dogfood msbuild dlls to dotnet sdk win-x64
+
+  - powershell: |
+      $sdk = "dotnet-sdk-linux-x64"
+
+      mkdir "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+
+      Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.tar.gz"
+      tar -xzvf "$(System.ArtifactsDirectory)/installer/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+
+      $dotnetDirectory = Get-ChildItem -Directory -Path $(Pipeline.Workspace)/exp-dotnet/$sdk/sdk
+      $dotnetVersion = $dotnetDirectory.Name
+      Write-Host "Detected dotnet version: $dotnetVersion"
+
+      Write-Host "Updating MSBuild dlls."
+      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
+        -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
+        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
+        -configuration Release `
+        -makeBackup $false
+
+      Write-Host "Compressing dotnet sdk files"
+      tar -czvf "$(Pipeline.Workspace)/artifacts/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk" .
+    displayName: Dogfood msbuild dlls to dotnet sdk linux-x64
+
+  - task: PublishPipelineArtifact@1
+    inputs:
+      targetPath: '$(Pipeline.Workspace)/artifacts'
+      artifactName: ExperimentalDotnet
+      parallel: true
+    condition: always()
+    displayName: Publish crank assests artifacts
+
+
+- job: CreateExpMSBuild
+  displayName: "Create Experimental MSBuild"
+  condition: ne('${{ parameters.VSVersionName }}', 'none')
+  steps:
+  - powershell: |
+      $token = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes("PAT:$env:ACCESSTOKEN"))
+      $headers = @{ Authorization = "Basic $token" };
+      $response = Invoke-RestMethod -Uri "$(_MSBuildConfigFilePathRequestURL)" -Headers $headers -Method Get
+      $MSBuildDropPath = $response.Tools.MSBuild.Locations
+      Write-Host "##vso[task.setvariable variable=MSBuildDropPath]$MSBuildDropPath"
+      Write-Host "MSBuild Drop Path directory: $MSBuildDropPath"
+    displayName: Get Retail MSBuild Drop Path
+    env:
+      ACCESSTOKEN: $(cloudbuild-token)
+
+  - task: NuGetToolInstaller@1
+    displayName: 'Install NuGet.exe'
+
+  - task: NuGetCommand@2
+    displayName: Restore internal tools
+    inputs:
+      command: restore
+      feedsToUse: config
+      restoreSolution: '$(Build.SourcesDirectory)\eng\common\internal\Tools.csproj'
+      nugetConfigPath: '$(Build.SourcesDirectory)\NuGet.config'
+      restoreDirectory: '$(Build.SourcesDirectory)\.packages'
+
+  - powershell: |
+      mkdir "$(Pipeline.Workspace)/artifacts"
+
+      $dropAppDirectory = Get-ChildItem -Directory -Path "$(Build.SourcesDirectory)/.packages/drop.app"
+      $dropAppVersion = $dropAppDirectory.Name
+      Write-Host "Detected drop.exe version: $dropAppVersion"
+
+      $dropExePath = "$(Build.SourcesDirectory)/.packages/drop.app/$dropAppVersion/lib/net45/drop.exe"
+      Write-Host "Detected drop.exe path: $dropExePath"
+
+      Write-Host "Downloading VS msbuild"
+      & "$dropExePath" get --patAuthEnvVar 'cloudbuild-token' -u "$(MSBuildDropPath)\$(VSVersion)" -d "$(System.ArtifactsDirectory)/VSMSBuildDrop"
+      Write-Host "Download of VS msbuild finished"
+
+      Write-Host "Copying VS msbuild to $(Pipeline.Workspace)/VSMSBuild"
+      Copy-Item -Path "$(System.ArtifactsDirectory)/VSMSBuildDrop/*" -Destination "$(Pipeline.Workspace)/VSMSBuild" -Recurse
+      Write-Host "Copy of VS msbuild finished"
+    displayName: Download msbuild vs drop
+    env:
+      cloudbuild-token: $(cloudbuild-token)
+
+  - task: DownloadBuildArtifacts@1
+    inputs:
+      buildType: specific
+      project: DevDiv
+      pipeline: $(_MsBuildCiPipelineId)
+      ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
+        buildVersionToDownload: latestFromBranch
+        branchName: '${{parameters.MSBuildBranch}}'
+      ${{ else }}:
+        buildVersionToDownload: specific
+        buildId: ${{parameters.MSBuildBuildID}}
+      artifactName: bin
+      itemPattern: |
+        MSBuild.Bootstrap/*/net472/**
+        Microsoft.Build.Conversion/*/net472/Microsoft.Build.Conversion.Core.dll
+        Microsoft.Build.Engine/*/net472/Microsoft.Build.Engine.dll
+        MSBuildTaskHost/**/MSBuildTaskHost.exe
+        MSBuildTaskHost/**/MSBuildTaskHost.pdb
+        MSBuild/*/*/net472/MSBuild.exe*
+      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
+    displayName: Download msbuild artifacts
+
+  - powershell: |
+      Write-Host "Updating MSBuild dlls."
+      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
+        -destination "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)/MSBuild/Current/Bin" `
+        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
+        -configuration Release `
+        -makeBackup $false
+
+      ls "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)"
+      Write-Host "Compressing msbuild files"
+      Get-ChildItem -Path "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/MSBuild.zip"
+    displayName: Dogfood msbuild dlls
+
+  - task: PublishPipelineArtifact@1
+    inputs:
+      targetPath: '$(Pipeline.Workspace)/artifacts'
+      artifactName: ExperimentalMSBuild
+      parallel: true
+    condition: always()
+    displayName: Publish crank assests artifacts
diff --git a/.git-blame-ignore-revs b/.git-blame-ignore-revs
new file mode 100644
index 00000000000..51f4826e321
--- /dev/null
+++ b/.git-blame-ignore-revs
@@ -0,0 +1,5 @@
+# .git-blame-ignore-revs
+# Removed trailing whitespace from *.cs,*.props,*.targets
+9a0cef6f75bf13ffbbde956b8f7d7ad7d6e0d996
+# Remove trailing whitespace from many *.cs files
+629447b151dc49cf4d9a57719beff12983cf1907
diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
new file mode 100644
index 00000000000..e6e7f272b6d
--- /dev/null
+++ b/.github/CODEOWNERS
@@ -0,0 +1,14 @@
+# Users referenced in this file will automatically be requested as reviewers for PRs that modify the given paths.
+# See https://help.github.com/articles/about-code-owners/
+
+/eng/SourceBuild*       @dotnet/source-build-internal
+/eng/                   @dotnet/kitten
+/.github/               @dotnet/kitten
+/global.json            @dotnet/kitten
+/.exp-insertions.yml    @dotnet/kitten
+/.opt-prof.yml          @dotnet/kitten
+/.vsts-dotnet-ci.yml    @dotnet/kitten
+/.vsts-dotnet.yml       @dotnet/kitten
+/NuGet.config           @dotnet/kitten
+/Directory.Build*       @dotnet/kitten
+/.git*                  @dotnet/kitten
\ No newline at end of file
diff --git a/.vsconfig b/.vsconfig
index a3598fb5a7f..c2d22f4da9f 100644
--- a/.vsconfig
+++ b/.vsconfig
@@ -1,12 +1,7 @@
 {
   "version": "1.0",
   "components": [
-    "Microsoft.Net.Component.4.8.SDK",
-    "Microsoft.Net.Component.4.7.2.SDK",
-    "Microsoft.Net.Component.4.TargetingPack",
-    "Microsoft.Net.Component.4.7.2.TargetingPack",
     "Microsoft.VisualStudio.Workload.ManagedDesktop",
-    "Microsoft.Net.Component.3.5.DeveloperTools",
-    "Microsoft.VisualStudio.Workload.NetCoreTools"
+    "Microsoft.Net.Component.3.5.DeveloperTools"
   ]
 }
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index d538f655a85..922df9717a7 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -35,6 +35,11 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
+  - task: CmdLine@2
+    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
+    condition: failed()
+    inputs:
+      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -49,6 +54,22 @@ jobs:
       ArtifactName: 'FullOnWindows test logs'
     continueOnError: true
     condition: always()
+  - task: CopyFiles@2
+    condition: eq(variables['publishverify'], 'Yes')
+    displayName: 'Copy Verify *.received.* files to Artifact Staging'
+    inputs:
+      contents: '**\*.received.*'
+      targetFolder: '$(Build.ArtifactStagingDirectory)\Verify'
+      cleanTargetFolder: true
+      overWrite: true
+  - task: PublishBuildArtifacts@1
+    displayName: 'Publish Verify *.received.* files as Artifacts'
+    name: 'verifypublish'
+    condition: eq(variables['publishverify'], 'Yes')
+    inputs:
+      PathtoPublish: '$(Build.ArtifactStagingDirectory)\Verify'
+      ArtifactName: 'Windows-on-full Verify $(System.JobAttempt)'
+
 
 - job: BootstrapMSBuildOnCoreWindows
   displayName: "Windows Core"
@@ -185,6 +206,11 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
+  - task: CmdLine@2
+    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
+    condition: failed()
+    inputs:
+      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -199,6 +225,21 @@ jobs:
       ArtifactName: 'CoreOnLinux test logs'
     continueOnError: true
     condition: always()
+  - task: CopyFiles@2
+    condition: eq(variables['publishverify'], 'Yes')
+    displayName: 'Copy Verify *.received.* files to Artifact Staging'
+    inputs:
+      contents: '**/*.received.*'
+      targetFolder: '$(Build.ArtifactStagingDirectory)/Verify'
+      cleanTargetFolder: true
+      overWrite: true
+  - task: PublishBuildArtifacts@1
+    displayName: 'Publish Verify *.received.* files as Artifacts'
+    name: 'verifypublish'
+    condition: eq(variables['publishverify'], 'Yes')
+    inputs:
+      PathtoPublish: '$(Build.ArtifactStagingDirectory)/Verify'
+      ArtifactName: 'Linux Verify $(System.JobAttempt)'
 
 - job: CoreOnMac
   displayName: "macOS Core"
@@ -219,6 +260,11 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
+  - task: CmdLine@2
+    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
+    condition: failed()
+    inputs:
+      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -233,5 +279,20 @@ jobs:
       ArtifactName: 'CoreOnMac test logs'
     continueOnError: true
     condition: always()
+  - task: CopyFiles@2
+    condition: eq(variables['publishverify'], 'Yes')
+    displayName: 'Copy Verify *.received.* files to Artifact Staging'
+    inputs:
+      contents: '**/*.received.*'
+      targetFolder: '$(Build.ArtifactStagingDirectory)/Verify'
+      cleanTargetFolder: true
+      overWrite: true
+  - task: PublishBuildArtifacts@1
+    displayName: 'Publish Verify *.received.* files as Artifacts'
+    name: 'verifypublish'
+    condition: eq(variables['publishverify'], 'Yes')
+    inputs:
+      PathtoPublish: '$(Build.ArtifactStagingDirectory)/Verify'
+      ArtifactName: 'macOS Verify $(System.JobAttempt)'
 
 - template: /eng/common/templates/jobs/source-build.yml
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 343cec26283..661671069c9 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -2,6 +2,7 @@ trigger:
 - main
 - vs*
 - exp/*
+- perf/*
 
 # If defined here, these values are not overrideable
 # Once they exist, we should define these as "runtime parameters"
@@ -40,6 +41,8 @@ variables:
     value: true
   - name: Codeql.Enabled
     value: true
+  - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - group: DotNet-MSBuild-SDLValidation-Params
 
 stages:
 - stage: build
@@ -93,9 +96,8 @@ stages:
       value: Products/$(System.TeamProject)/$(Build.Repository.Name)/$(Build.SourceBranchName)/$(Build.BuildNumber)
 
     steps:
-    - task: NuGetToolInstaller@0
-      inputs:
-        versionSpec: '4.9.2'
+    - task: NuGetToolInstaller@1
+      displayName: 'Install NuGet.exe'
 
     - task: NuGetCommand@2
       displayName: Restore internal tools
@@ -215,6 +217,7 @@ stages:
       inputs:
         DropName: $(VisualStudio.DropName)
         DropFolder: 'artifacts\VSSetup\$(BuildConfiguration)\Insertion'
+        DropRetentionDays: '30' # extended by insertion + VS release
         AccessToken: '$(System.AccessToken)'
         DropServiceUri: 'https://devdiv.artifacts.visualstudio.com'
         VSDropServiceUri: 'https://vsdrop.corp.microsoft.com/file/v1'
@@ -294,3 +297,18 @@ stages:
       enableSymbolValidation: false
       enableSourceLinkValidation: false
       enableNugetValidation: false
+      SDLValidationParameters:
+        enable: true
+        continueOnError: false
+        params: ' -SourceToolsList @("policheck","credscan")
+        -TsaInstanceURL "$(_TsaInstanceURL)"
+        -TsaProjectName "$(_TsaProjectName)"
+        -TsaNotificationEmail "$(_TsaNotificationEmail)"
+        -TsaCodebaseAdmin "$(_TsaCodebaseAdmin)"
+        -TsaBugAreaPath "$(_TsaBugAreaPath)"
+        -TsaIterationPath "$(_TsaIterationPath)"
+        -TsaRepositoryName "dotnet-msbuild"
+        -TsaCodebaseName "dotnet-msbuild"
+        -TsaPublish $True
+        -CrScanAdditionalRunConfigParams @("SuppressionsPath < $(Build.SourcesDirectory)\eng\CredScanSuppressions.json")
+        -PoliCheckAdditionalRunConfigParams @("UserExclusionPath < $(Build.SourcesDirectory)\eng\policheck_exclusions.xml")'
diff --git a/NuGet.config b/NuGet.config
index 4e9907ea835..d7187b4d64a 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -8,6 +8,7 @@
     <add key="dotnet6" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json" />
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
+    <add key="BuildXL" value="https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
 </configuration>
diff --git a/documentation/specs/proposed/interactive-package-references.md b/documentation/specs/proposed/interactive-package-references.md
new file mode 100644
index 00000000000..b01805575d6
--- /dev/null
+++ b/documentation/specs/proposed/interactive-package-references.md
@@ -0,0 +1,217 @@
+# Packages Sourcing
+
+The feature is meant to simplify the process of fixing, testing and contributing changes in projects published as nugets.
+
+It is inspired by the golang modules design - where a standalone dependency (module) has a pointer to it's source location as a first-class citizen within the ecosystem (go.mod) and the relation between the source codes and runtime dependecy is unambigously guaranteed by the compiler.
+
+# North Star / Longer-term vision
+
+We envision the 'packages sourcing' to be a first-class-citizen within nuget client (and hence [`dotnet restore`](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-restore)). Via denoting specific metadata on `PackageReference` it would be possible to perform specific mode of restore operation for the particular package reference - by pointing to a local sources, or letting the command to figure out and fetch apropriate sources:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <ItemGroup>
+    <PackageReference Include="Newtonsoft.Json" ResolveAsSources="true" />
+    <PackageReference Include="Contoso.CommonPackage" ResolveAsSources="true" SourcesLocation="$(MSBuildProjectDirectory)/../CommonPackage/src/CommonPackage.csproj" />
+  </ItemGroup>
+</Project>
+```
+
+```
+dotnet restore MyProj.csproj  
+```
+
+The command would resolve and fetch remote sources of proper revision (unless explicitly pointed to local sources with active changes), build the dependency and add it to `project.assets.json` indicating the sources expansion.
+
+There would need to be special treatment for some aspect of behavior of `PackageReference` that diverges or are not defined for source code references (`ProjectReference`), listed in https://github.com/dotnet/msbuild/issues/8507.
+
+A special metadata (possibly within the nuget package, optionaly within the source repo) might be needed to ensure the proper infering of the build in more involved scenarios (or to disallow package sourcing for particular package).
+
+One of the goals of the initial iteration is to identify the limitations of automatic infering of the build and turining the `PackageReference` to `ProjectReference`. 
+
+# Scope of initial iteration
+
+The initial proof of concept of the feature is envisioned to be facilitated via [`SourceLink`](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink) repository metadata, [`PE headers`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.portableexecutable.peheaders?view=net-7.0) and pdb metadata ([`MetadataReader`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.metadata.metadatareader)), in-memory or persistent switching between `PackageReference` and `ProjectReference` and possibly verification of proper outputs (for `deterministic build` enabled projects).
+
+## In scope
+* Standalone dotnet tool for initiating the `Package Sourcing` of particular nuget(s) via locating and fetching sources, infering the build and flipping `PackageReference` to `ProjectReference`
+
+## Out of scope
+ * **Patching the package/binary dependencies in a deployable way**. The interaction is ment to be used only on developer machine and not survive beyond repository push, external environment deployment etc.
+ * **Survival of patches accross `PackageReference` updates**.
+ * **Supporting nuget packages that are not `SourceLink` enabled**. As a fallback we might use `SourceLink` stamped symbols, but unless the `SourceLink` information is to be found either within the nuget package or published matching symbols, this feature will not be enabled.
+ * **Custom pre-build prerequisities**. First version of the feature will make several assumptions on common ways to build packages from source repository (attempt to build just the project with `dotnet build`, attempt to locate `*.sln` or `build.<cmd|sh|ps1>` script or existence of reproducible build compiler flags)
+
+# User scenarios
+
+## OSS package reference
+* Alice is referencing FooBar nuget in her project and she is using automated PRs (e.g. dependabot) to consume the latest available version
+* A new version of FooBar nuget is published, automated PR into Alice project is created to update the `PackageReference` and the PR is failing
+* Alice is investigating the issue and suspecting problem in FooBar library. If the package was properly SourceLink-ed and symbols published, Alice can debug into the code and diagnose the issue
+* Alice would like to try to fix the issue, test the fix and contribute back to the OSS. She can achieve this with `Packages Sourcing` feature
+
+## Internal corp package flows
+* Bob is working in Contoso co. Contoso co. has dozens of internal repositories and internal package feed used to publish and consume the artifacts of individual repositories
+* Bob is working on component that is consuming another component - BarBaz - as a nuget package.
+* Bob wants to contribute an improvement to component BarBaz, that would be leveraged by his component. He wants to first test the improvement with his component before contributing back to the BarBaz. He can achieve this with `Packages Sourcing` feature
+
+## (Out of scope) Source as package reference
+* Bob from previous scenario needs to work on couple of components that interact with each other and which reference themselves via `PackageReference`s.
+* To simplify his work, Bob wants to include locations with components source code as reference locations for resolving `PackageReference`s, while he'd expect the build to properly interpret the components sources as packages (provided those can be successfuly build and packed)
+* Alteration of this sceanrio is referencing a reference via git repo link and commit hash (analogously to go modules).
+
+# Design proposal
+
+![control flow proposal](packagessourcing-control-flow.jpg)
+
+ ## Subproblems
+
+ * Opting-in mechanism - to request switch to local sources
+ * Preserving the info about swtich to local sources
+ * Opting-out mechanism - to switch back to regular package reference
+ * Local storage of sources - submodule vs standalone checkout
+ * Indication mechanism informing the user about usage of local sources (especially in case where local patch is applied)
+ * Locating and fetching proper source codes
+ * Infering the proper 'build recipe' for the binary and verifying the result (in case of determinictic build)
+ * Verifying that the locally build package is correct - leveraging deterministic build; signature stripping etc.
+ * Converting `PackageReference` to `ProjectReference`
+ * Allowing to quickly consume local code patches (via edit and continue/ hot reload mechanism)
+
+ Some of those problems might be eliminated by simplifying the workflow and e.g. providing a command that prepares a project and edits the original MSBuild file to replace `PackageReference` with `ProjectReference` - the consuming of code patches and indicating the altered reference to user would not be needed.
+ 
+ ## Possible Implementations
+
+ Following sections discuss possible implementations of individual [subproblems outlined above](#subproblems).
+
+ ### Opting-in
+
+ For simplified and isolated rollout of this feature we propose CLI-only interface (no VS or other tooling integration):
+
+```cmd
+> dotnet tool install Microsoft.Build.PackageSourcing
+> dotnet package-to-sources --project MySolution.sln --packages: FooBar.Baz, Newtonsoft.Json
+
+FooBar.Baz:
+Sources located: github.com/FooBar/Baz@0abcb66
+Local checkout: C:\Users\jankrivanek\.nuget\sources\FooBar\6.5.4\
+Build instructions located: FooBar-package-sourcing.proj
+Build reconstructed: OK
+Reference replaced: OK
+
+Newtonsoft.Json:
+...
+
+Sourced packages are ready to use.
+
+>
+```
+
+This as well solves the question of preserving the info about packages sourcing.
+
+### Opting-out
+
+This can be achieved via adding a metadata to mofdified MSBuild files, storing the info about original `PackageReference`s and then reverting those via another CLI command:
+
+```cmd
+> dotnet package-to-sources --revert --project MySolution.sln --packages: FooBar.Baz, Newtonsoft.Json
+
+Successfuly reverted packages sourcing for: FooBar.Baz, Newtonsoft.Json.
+>
+```
+
+### Local storage of sources
+
+To be decided (nuget cache?, Submodules of the current git context?, sibling folder of current project git root?, the `.vs` folder (for vs-centric solution)?, `%temp%`? ...)
+
+We can take inspiration from VS debugger decompilation features:
+
+![vs decompiled sources](https://learn.microsoft.com/en-us/visualstudio/debugger/media/decompilation-solution-explorer.png?view=vs-2022)
+
+![vs nuget source](https://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2021/08/word-image-17.png)
+
+ ### Locating proper sources
+ * Most preferable way is via `SourceLink` metadata within the nuget package itself ([documentation](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink), [reading the metadata](https://learn.microsoft.com/en-us/nuget/reference/nuget-client-sdk#get-package-metadata))
+ * Fallback to `SourceLink` metadata within symbol files ([documentation](https://learn.microsoft.com/en-us/cpp/build/reference/sourcelink?view=msvc-170), [Portable PDB format spec](https://github.com/dotnet/runtime/blob/main/docs/design/specs/PortablePdb-Metadata.md), [reading source locations metadata](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/tests/Metadata/PortablePdb/DocumentNameTests.cs))
+ * We should consider ability to specify/pass-in a custom location of sources - this would facilitate portion of the 'Source as package reference' scenario (possibly something that might be usable for our 'source build' or 'VMR build').
+
+ ### Infering the 'build recipe'
+ This is the most challenging part of the story - as .NET ecosystem currently doesn't enforce custom build pre-requisities standards nor conventions and hence it is not possible to replicate the package build process without possible manual steps. This part will hence be 'best efforts' with sensible communication of issues to user. 
+ 
+ We envision multiple options to achieve this goal (with possibility of fallback/combination of multiple approaches):
+ * Option A: Using Pdb info/ Roslyn to extract information from PE/Pdbs and reconstruct the compilation ([roslyn experimental code](https://github.com/dotnet/roslyn/blob/main/src/Tools/BuildValidator/Program.cs#L268), [NugetPackageExplorer SymbolValidator](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer/blob/main/Core/SymbolValidation/SymbolValidator.cs#L145)). Access to symbol files (whether published as .snupkg on nuget.org or on microsoft or corporate symbols servers) is crucial for this method. As well as usage of particualr compiler toolchain used to generate the inspected package ([sdk 5.0.3 or MSBuild 16.10](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer/commit/a272c8c314257dfa99c6befd2cfeff39b8a6ecbe)). Prototyping task: https://github.com/dotnet/msbuild/issues/8511
+ * Option B: Attempt to run build (`dotnet build`) on `.sln` in repo root or `src` folder, or fallback to discovery of most common build scripts in repo root (`build.<extension>` for few most common script types based on current OS). Prototyping task: https://github.com/dotnet/msbuild/issues/8512
+ * Option C: Sources crawling and finding project by name/assembly name; build; compare results.
+ * Option D: Working backwards from the nuget (finding pack script or msbuild properties indicating nuget creation ...); build; compare results
+ * Option E: Seting up convention for explicit description of build prerequisites and package build. Inspiration for this can be `.proj` files describing external dependencies build recipe in dotnet source build ([sample build descriptions](https://github.com/dotnet/source-build-externals/tree/main/repos)) or [`git dependencies`](https://fsprojects.github.io/Paket/git-dependencies.html) project for Paket
+
+
+**Gotchas:**
+ * The `Option A` above infers the 'compile recipe', but not the 'build recipe' - which means some checked out files would not have their standard expected functionality (they would be completely ignored) - resource files (`.resx`), templates for code generators (`.tt`, `.aspx`, `.xaml`, etc.) and most importantly the project file itself (`.csproj`/`.fsproj`/`.vbproj`/...).
+
+   Possible solutions: 
+    * (short term) Mark such files read-only, add explicit pre-compilation check throwing error if hash of such a file changes 
+    * (long term) For code generators we can extend SourceLink to add info to symbol file what code generator was used and store it on symbols server (or in Executable Image Search Path location)
+    * project files - ??? (though one)
+
+  * The `Option B` might not have acceptable success rate - it is still very appealing option if combined with other approach. 
+
+ * Discrepancies between the `PackageReference` and `ProjectReference` configurability and behavior (different metadata support, different behavior for some of the same metadata, different layout of the the bin outputs yielding some assumptions breaks, nuget support for packaged props/targets, etc.). Probably the biggest problem will be the usage of build features - build.props and build.targets (as those are placed during the project build, but couldn't be identicaly consumed during the same build as for the package reference)
+
+    Possible solutions: 
+      * Those differences needs to be researched/catalogued and categorized first, then we can decide what to consolidate and what will not be explicitly supported. Investigation item: https://github.com/dotnet/msbuild/issues/8507
+      * It might be beneficial to perform analysis of usage prevalence of the individual metadata. Investigation task: https://github.com/dotnet/msbuild/issues/8521
+ 
+ * Running a build script on a local machine is possible security risk - user should be properly warned and informed.
+ * Verifying the binary identity might add unnecesary high cost to the operation at unwanted time - the rebuild is likely needed only after user want to make a change. But the verification might stll be agood idea - especially for cases where we attempt to run a build script (and we might e.g. be running `build.sh` due to being on Unix, while official nuget was published from Windows build).
+ 
+   Possible solution: We might hold on until user makes a change and wants to test run it (we can then compare it with the version that was originaly downloaded - to perform a build verifying the binary identity of the original nuget binary and local reconstructed binary). In the ideal case the experience would be very seamless - user steps into the code during debugging (or via decompilation) and is allowed to perform change - if they perform change they are first asked to confirm that action and to acknowledge this will lead to running the component build on their machine. The current environment might even decide which of the build reconstruction techniques will be fastest based on the change the user made (e.g. single code file vs change to .resx etc.)
+
+ * Building the package on different SDK might lead to slightly different results - this we'll likely need to accept as limitation
+ * Global properties propagate nto the `ProjectReference`, wherease `PackageReference` is already built (example: `Debug` configuration can get propagated into `ProjectReference`, while the consumed `PackageReference` was build in `Release` mode).
+ 
+    Possible solution: Add 'Remove All Global Properties' feature for a project build.
+
+**_Extensive research needed for this subproblem._**
+
+ ### Verifying identity of local package with the feed one
+
+ In case deterministic build was opted-out, this would be very challenging and nearly impossible - so not supported.
+ For signed assemblies we'll need to strip signatures ([`ImageRemoveCertificate`](https://learn.microsoft.com/en-us/windows/win32/api/imagehlp/nf-imagehlp-imageremovecertificate)). Removing signature might nullify checksum bytes in PE header - so binary comparison to the locally built assembly might not match (solution is to temporarily remove the PE header checksum from the local binary as well - to facilitate binary equality).
+
+ ### Converting `PackageReference` to `ProjectReference`
+
+ [To Be Investigated]
+ There might be possible inconsitencies between [`PackageReference`](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) and [`ProjectReference`](https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference) items metadata (and even behavior with same metadata - e.g. https://github.com/dotnet/msbuild/issues/4371).
+ So there needs to be some decision of what's supported and what not and what's the behavior for attempt to translate `PackageReference` using untranslatable metadata.
+
+ ### Allowing to quickly consume local code patches
+
+ To be decided.
+ But likely this will be no-op for the initial version - standard usage scenarios for project references will kick in.
+
+ # Security considerations
+
+ [Under construction]
+ * The build verification mode (out of scope) needs proper design of handling of symbols embedded files and pointers to any sources outside of expected repository root. (otherwise intruder with access to the production build can infect not only the binary, but the symbol file as well)
+ * MIM for the symbol server (offering crafted symbol file with pointers to custom sources that can allow execution of intruder code on the developer machine)
+ * Possible licensing considerations - there can be packages with different redistribution requirements for packages and originating sources, but allowing user to switch from package reference to source references we are technically making it easier for the user to miss and fail license agreement.
+
+ # Cross team dependencies considerations
+
+ * **Nuget - possible dependency** - the proposal doesn't evision changes to the nuget client nor server contracts. However it might be beneficial to consolidate behavior of `ProjectReference` and `PackageReference` items and its metadata - coorfination with nuget team would be helpful here.
+ * **Visual Studio, Project System - No dependency in initial version** - the proposal envision exposing functionality via CLI (and API) only, after the whole concept is constructed and alive, we should start reaching out to those teams to consider exposing the functionality via GUI - e.g.:
+ ![vs context menu proposal](sourcing-vs-context.png)
+ * **SDK - No dependency** - the initial version would be delivered as standalone (optional) dotnet tool
+ * **Roslyn - Consultation and engineering** - ideally packing and exporting the [BuildValidator](https://github.com/dotnet/roslyn/tree/main/src/Tools/BuildValidator) and mainly [Rebuild](https://github.com/dotnet/roslyn/tree/main/src/Compilers/Core/Rebuild). MSBuild team should fund this effort
+ * **MSBuild - Likely no dependency** - There migh need to be some support for allowing storing info about link between original PackageReference and injected ProjectReference - however current MSBuild constructs should suffice here. There might be some work needed to bring `PackageReference` and `ProjectReference` functionaly closer together (as outlined [above](#converting-packagereference-to-projectreference))
+
+ There can be possible leverage of the work by other teams:
+ * Nuget - [NugetPackageExplorrer](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer) - as it currently heavily uses custom code to extract information from PE/Pdb metadata.
+ * Source Build / VMR - to validate buildability of 3rd party components and low touch process of enlisting new 3rd party dependencies into source build
+
+ # Links:
+  * https://github.com/NuGetPackageExplorer/NuGetPackageExplorer
+  * https://devblogs.microsoft.com/visualstudio/debugging-external-sources-with-visual-studio/
+  * https://devblogs.microsoft.com/visualstudio/decompilation-of-c-code-made-easy-with-visual-studio/
+  * https://learn.microsoft.com/en-us/visualstudio/debugger/decompilation?view=vs-2022
+  * https://fsprojects.github.io/Paket/git-dependencies.html
diff --git a/documentation/specs/proposed/packagessourcing-control-flow.jpg b/documentation/specs/proposed/packagessourcing-control-flow.jpg
new file mode 100644
index 00000000000..aff34456469
Binary files /dev/null and b/documentation/specs/proposed/packagessourcing-control-flow.jpg differ
diff --git a/documentation/specs/proposed/sourcing-vs-context.png b/documentation/specs/proposed/sourcing-vs-context.png
new file mode 100644
index 00000000000..20a852205d7
Binary files /dev/null and b/documentation/specs/proposed/sourcing-vs-context.png differ
diff --git a/documentation/specs/test-target.md b/documentation/specs/test-target.md
new file mode 100644
index 00000000000..7726f1f6971
--- /dev/null
+++ b/documentation/specs/test-target.md
@@ -0,0 +1,62 @@
+## MSBuild Test Target and Task 
+See: [MSBuild Test Target](https://github.com/dotnet/msbuild/pull/9193)
+
+### Motivation
+The primary motivation of the MSBuild Test Target is to offer a convienent and standardardized way for executing tests within the msbuild environment. This is inspired by the simplicity of the `dotnet test` command. The proposed command for initiating test within MSBuild would be `msbuild /t:Test`
+
+Another significatnt benefit of integrating this target is to faciliatet the caching of test executions, using MSBuild project caching capabilities. This enhancement will optimize the testing process by reducing test runs which could significantly reduce time spent building and testing, as tests would only execute, (after the initial run) if there are changes to those tests. As an example running with [MSBuildCache](https://github.com/microsoft/MSBuildCache) we can cache both build and test executions. Functionally, this means skipping test executions that have been determined to have not changed.
+Example usage:
+`msbuild /graph /restore:false /m /nr:false /reportfileaccesses /t:"Build;Test"`
+
+### Design Overview
+The 'Microsoft.Common.Test.targets' file contains a stub test target.
+```
+<Project>
+    <Target Name="Test"></Target>
+</Project>
+```
+This target serves a placeholder and entry point for test target implementations.
+
+#### Conditional Import
+* This stub target is conditionally imported, determined by a condition named 
+`$(UseMSBuildTestInfrastructure)`.
+* This condition allows for users to opt-in to this test target, which helps to prevent breaking changes, with respect the the target name, since there are likely 'Test' targets that exist in the wild already.
+
+The 'Microsoft.Common.CurrentVersion.targets' file contains.
+```
+  <PropertyGroup>
+    <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
+  </PropertyGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'"/>
+
+```
+#### Extensibility for Test Runners
+* Test runner implemenations can hook into the provided stub using the `AfterTargets` property.
+* This approach enables different test runners to extend the basic funcionarlity of the test target.
+
+For instance, an implementation for running VSTest would look like:
+```
+<Target Name="RunVSTest" AfterTargets="Test">
+  <!-- Implementation details here -->
+</Target>
+```
+
+#### Usage Scenario
+* Users who wish to utilize this target will set the `$(UseMSBuildTestInfrastructure)` condition in their project file, rsp or via the command line.
+* By executing `msbuild /t:Test`, the MSBuild engine will envoke the `Test` taget, which in turn triggers any test runner targets defined to run after it.
+
+### Default Task Implementation
+See: [MSBuild Test Task](https://github.com/microsoft/MSBuildSdks/pull/473)
+
+#### Nuget package for default implementaion
+* The default implementation will be provided through a nuget package.
+* This package will contain an MSBuild Task deigned to execute `vstest.console.exe`.
+
+#### MSBuild Task Functionality
+* The core of this implemenation is an MSBuild task that interfaces with `vstest.console.exe`.
+* This task will accept arguments as properties and pass them directly into the command line test runner.
+
+#### Using The Default Implementation
+* Users would install the provided Nuget Package to incorporate it into their projects.
+* Add the package to their GlobalPackageReferences or specific projects.
+* Once integrated, executing `msbuild /t:Test` would trigger the MSBuild Task, ultimately executing `vstest.console.exe`.
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index 548a05da664..9edcddc6fd4 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -38,6 +38,10 @@ Note that only `*.csproj`, `*.targets` and other MSBuild project formats are col
 
 If the binary log contains the projects/imports files the MSBuild Structured Log Viewer will display all the files contained in the log, let you search through them and even display preprocessed view for any project where all imported projects are inlined (similar to `msbuild /pp` switch).
 
+# Logging all environment variables
+
+By default, MSBuild logs only the environment variables that are used to influence MSBuild, which is a subset of what is set in the environment. This reduces, but does not eliminate, the likelihood of leaking sensitive information through logs. This behavior can be changed to log the full environment by setting the environment variable `MSBUILDLOGALLENVIRONMENTVARIABLES=1`.
+
 # Replaying a binary log
 
 Instead of passing the project/solution to MSBuild.exe you can now pass a binary log to "build". This will replay all events to all other loggers (just the console by default). Here's an example of replaying a `.binlog` file to the diagnostic verbosity text log:
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 402fe6eb556..f7d92318dc7 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -23,11 +23,21 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ## Current Rotation of Change Waves
 
+### 17.10
+- [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
+- [Warning on serialization custom events by default in .NET framework](https://github.com/dotnet/msbuild/pull/9318)
+- [Cache SDK resolver data process-wide](https://github.com/dotnet/msbuild/pull/9335)
+- [Target parameters will be unquoted](https://github.com/dotnet/msbuild/pull/9452), meaning  the ';' symbol in the parameter target name will always be treated as separator
+- [Change Version switch output to finish with a newline](https://github.com/dotnet/msbuild/pull/9485)
+- [Load Microsoft.DotNet.MSBuildSdkResolver into default load context (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9439)
+- [Load NuGet.Frameworks into secondary AppDomain (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9446)
+
 ### 17.8
 - [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
 - [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
-- [New serialization approach for transferring build exceptions between processes](https://github.com/dotnet/msbuild/pull/8779)
 - [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
+- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
+
 
 ### 17.6
 - [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
@@ -68,4 +78,4 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
 - [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
 - [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
-- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
\ No newline at end of file
+- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
diff --git a/documentation/wiki/Contributing-Code.md b/documentation/wiki/Contributing-Code.md
index c71172b8305..6e6e8b40c62 100644
--- a/documentation/wiki/Contributing-Code.md
+++ b/documentation/wiki/Contributing-Code.md
@@ -8,6 +8,7 @@ Because our focus right now is on maintaining backwards compatibility, the team
 - Pull requests that do not merge easily with the tip of the main branch will be declined. The author will be asked to merge with tip and submit a new pull request.
 - Submissions must meet functional and performance expectations, including scenarios for which the team doesn't yet have open source tests. This means you may be asked to fix and resubmit your pull request against a new open test case if it fails one of these tests.
 - Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
+- For any changed or newly introduced test cases usage of Shouldly assertion framework is preferable.
 
 When you are ready to proceed with making a change, get set up to [build](Home.md "See 'Building Testing and Debugging'") the code and familiarize yourself with our workflow and our coding conventions. These two blogs posts on contributing code to open source projects are good too: [Open Source Contribution Etiquette by Miguel de Icaza](https://tirania.org/blog/archive/2010/Dec-31.html) and [Don’t “Push” Your Pull Requests by Ilya Grigorik](https://www.igvita.com/2011/12/19/dont-push-your-pull-requests/).
 
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
index 3a833348b66..94b9ec2f91b 100644
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ b/documentation/wiki/MSBuild-Tips-&-Tricks.md
@@ -58,11 +58,20 @@ Use this command-line to approximate what the design-time build does:
 /t:CollectResolvedSDKReferencesDesignTime;DebugSymbolsProjectOutputGroup;CollectPackageReferences;ResolveComReferencesDesignTime;ContentFilesProjectOutputGroup;DocumentationProjectOutputGroupDependencies;SGenFilesOutputGroup;ResolveProjectReferencesDesignTime;SourceFilesProjectOutputGroup;DebugSymbolsProjectOutputGroupDependencies;SatelliteDllsProjectOutputGroup;BuiltProjectOutputGroup;SGenFilesOutputGroupDependencies;ResolveAssemblyReferencesDesignTime;CollectAnalyzersDesignTime;CollectSDKReferencesDesignTime;DocumentationProjectOutputGroup;PriFilesOutputGroup;BuiltProjectOutputGroupDependencies;ResolvePackageDependenciesDesignTime;SatelliteDllsProjectOutputGroupDependencies;SDKRedistOutputGroup;CompileDesignTime /p:SkipCompilerExecution=true /p:ProvideCommandLineArgs=true /p:BuildingInsideVisualStudio=true /p:DesignTimeBuild=true
 ```
 
-# Extend all builds (at system-wide level)
-See https://www.simple-talk.com/dotnet/.net-tools/extending-msbuild, "Extending all builds" section. Also read about [MSBuildUserExtensionsPath](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,33), [CustomBeforeMicrosoftCommonProps](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [CustomBeforeMicrosoftCommonTargets](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and CustomAfterMicrosoftCommonProps/CustomAfterMicrosoftCommonTargets.
+# Diagnose WPF temporary assembly compilation issues
+
+Set the property `GenerateTemporaryTargetAssemblyDebuggingInformation` on the `GenerateTemporaryTargetAssembly` task:
+https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/Microsoft/Build/Tasks/Windows/GenerateTemporaryTargetAssembly.cs,4571677f19ba0d24,references
 
-Example:
-Create this file (Custom.props) in `C:\Users\username\AppData\Local\Microsoft\MSBuild\Current\Microsoft.Common.targets\ImportAfter`:
+If the property `$(GenerateTemporaryTargetAssemblyDebuggingInformation)` is set, the temporary project generated during XAML project build will not be deleted and will be available for inspection. This is only available in the recent versions of .NET Framework, so check if your `Microsoft.WinFX.targets` file has it.
+
+Also the name of the project was renamed from `*.tmp_proj` to `*_wpftmp.csproj` so the file extension is now C#: `WpfApp1_jzmidb3d_wpftmp.csproj`
+
+# Extending builds
+
+See the "Extending All Builds" section from [this article](https://www.red-gate.com/simple-talk/development/dotnet-development/extending-msbuild/). Also read about [`CustomBeforeMicrosoftCommonProps`](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [`CustomBeforeMicrosoftCommonTargets`](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and `CustomAfterMicrosoftCommonProps`/`CustomAfterMicrosoftCommonTargets`. And don't miss the explainer below.
+
+Create a file, say `Custom.props`, with the following contents:
 
 ```
 <?xml version="1.0" encoding="utf-8"?>
@@ -73,13 +82,56 @@ Create this file (Custom.props) in `C:\Users\username\AppData\Local\Microsoft\MS
 </Project>
 ```
 
-then build any project. It will have MyCustomProperty set to Value!
+and place it in one of the locations described below, then build any project. It will have `MyCustomProperty` set to `Value!`.
 
-# Diagnose WPF temporary assembly compilation issues
+## User-wide level (`MSBuildUserExtensionsPath`)
 
-Set the property `GenerateTemporaryTargetAssemblyDebuggingInformation` on the `GenerateTemporaryTargetAssembly` task:
-https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/Microsoft/Build/Tasks/Windows/GenerateTemporaryTargetAssembly.cs,4571677f19ba0d24,references
+In one of the following locations (`%LOCALAPPDATA%` evaluating to something like `C:\Users\username\AppData\Local`):
 
-If the property `$(GenerateTemporaryTargetAssemblyDebuggingInformation)` is set, the temporary project generated during XAML project build will not be deleted and will be available for inspection. This is only available in the recent versions of .NET Framework, so check if your `Microsoft.WinFX.targets` file has it.
+* `%LOCALAPPDATA%\Microsoft\MSBuild\Current\Imports\Microsoft.Common.props\ImportBefore`
+  * aka: `$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore`
+* `%LOCALAPPDATA%\Microsoft\MSBuild\Current\Imports\Microsoft.Common.props\ImportAfter`
+  * aka: `$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter`
+* `%LOCALAPPDATA%\Microsoft\MSBuild\Current\Microsoft.Common.targets\ImportBefore`
+  * aka: `$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore`
+* `%LOCALAPPDATA%\Microsoft\MSBuild\Current\Microsoft.Common.targets\ImportAfter`
+  * aka: `$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter`
 
-Also the name of the project was renamed from `*.tmp_proj` to `*_wpftmp.csproj` so the file extension is now C#: `WpfApp1_jzmidb3d_wpftmp.csproj`
+**Note:** the above locations are in the order in which they are imported by `Microsoft.Common.props` and `Microsoft.Common.targets` respectively. Setting your properties later, overwrites previous values. And mind the additional directory level `Imports\` for the files imported by `Microsoft.Common.props`.
+
+**Also note:** [`$(MSBuildUserExtensionsPath)`](https://learn.microsoft.com/visualstudio/msbuild/customize-your-local-build#msbuildextensionspath-and-msbuilduserextensionspath) is equal to `%LOCALAPPDATA%\Microsoft\MSBuild`.
+
+## MSBuild-wide level (`MSBuildExtensionsPath`)
+
+There is another MSBuild-wide location imported by `Microsoft.Common.props` from underneath `$(MSBuildToolsRoot)`, the installation directory of MSBuild, - which, when using it from modern Visual Studio versions, would often equal `$(VsInstallRoot)\MSBuild`. It goes by the name [`MSBuildExtensionsPath`](https://learn.microsoft.com/visualstudio/msbuild/customize-your-local-build#msbuildextensionspath-and-msbuilduserextensionspath).
+
+* `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore`
+* `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter`
+* `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore`
+* `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter`
+
+The principle is the same, drop a valid MSBuild file into one of these locations to extend your build according to whatever you put into the respective MSBuild file.
+
+**Note:** The value of `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props` after evaluation would be something like `C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Imports\Microsoft.Common.Props`.
+
+**Also note:** technically the imports happen from `Microsoft.Common.CurrentVersion.targets` where the above directories say `Microsoft.Common.targets`.
+
+## Explainer: the underlying extension mechanisms and related mechanisms
+
+The above explanations are only half the truth, though.
+
+* The file extension of the file doesn't matter - it's a convention. Any file conforming to the MSBuild XML schema in that location should get picked up and imported.
+* `Microsoft.Common.props` and `Microsoft.Common.targets` conditionally imports from the locations mentioned throughout this section, you can use properties to suppress this extension mechanism, say from the command line:
+  * For user-wide locations set these properties to something else than `true` respectively:
+    * `ImportUserLocationsByWildcardBeforeMicrosoftCommonProps`
+    * `ImportUserLocationsByWildcardAfterMicrosoftCommonProps`
+    * `ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets`
+    * `ImportUserLocationsByWildcardAfterMicrosoftCommonTargets`
+  * For MSBuild-wide locations set these properties to something else than `true` respectively:
+    * `ImportByWildcardBeforeMicrosoftCommonProps`
+    * `ImportByWildcardAfterMicrosoftCommonProps`
+    * `ImportByWildcardBeforeMicrosoftCommonTargets`
+    * `ImportByWildcardAfterMicrosoftCommonTargets`
+* The `Directory.*.props`, `Directory.*.targets` et. al. also offer ways to extend your build. They are fairly well-known and documented:
+  * [`Directory.Build.props` and `Directory.Build.targets`](https://learn.microsoft.com/visualstudio/msbuild/customize-by-directory)
+  * [`Directory.Solution.props` and `Directory.Solution.targets`](https://learn.microsoft.com/visualstudio/msbuild/customize-solution-build) as well as `before.{solutionname}.sln.targets` and `after.{solutionname}.sln.targets` can be used to inject properties, item definitions, items and targets into your build
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index 3fa12a84f6a..37e541136d8 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -2,7 +2,7 @@
 
 MSBuild has the ability to capture a detailed binary log file.  If you are having a build issue and are able to provide a binary log, this can be very helpful for investigating the issue.
 
-However, you should be aware what type of information is captured in the binary log to make sure you are not inadvertently sharing more than you intend.  The binary log captures almost everything your build does, including the contents of your project files and any files (such as .props and .targets) that they import, all tasks that are run during the build as well as the input and output, as well as all environment variables.  It generally doesn't include the contents of the source files that are compiled, but it does capture their full names and paths.
+However, you should be aware what type of information is captured in the binary log to make sure you are not inadvertently sharing more than you intend.  The binary log captures almost everything your build does, including the contents of your project files and any files (such as .props and .targets) that they import, all tasks that are run during the build as well as the input and output, as well as all environment variables used by the build logic.  It generally doesn't include the contents of the source files that are compiled, but it does capture their full names and paths.
 
 ⚠ NOTE: some build environments make secrets available using environment variables. Before sharing a binary log, make sure it does not expose API tokens or other important secrets.
 
diff --git a/eng/AfterSigning.targets b/eng/AfterSigning.targets
index 0bc6b1db9cd..52f5eabf4c7 100644
--- a/eng/AfterSigning.targets
+++ b/eng/AfterSigning.targets
@@ -1,12 +1,12 @@
 <Project>
     <Target Name="CopyAMD64Symbols" Condition="'$(OfficialBuild)' == 'true' AND '$(ArcadeBuildFromSource)' != 'true'" BeforeTargets="Build">
-        <Copy 
+        <Copy
             SourceFiles="$(ArtifactsBinDir)MSBuild\x64\Release\net472\MSBuild.pdb"
             DestinationFolder="$(ArtifactsSymStoreDirectory)\MSBuild\net472\amd64"
             />
-        <Copy 
+        <Copy
             SourceFiles="$(ArtifactsBinDir)MSBuildTaskHost\x64\Release\net35\MSBuildTaskHost.pdb"
             DestinationFolder="$(ArtifactsSymStoreDirectory)\MSBuildTaskHost\net35\amd64"
             />
     </Target>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 02e1e308112..e6fee0282f8 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -229,6 +229,9 @@
     <Copy SourceFiles="@(NuGetSdkResolverManifest)"
           DestinationFolder="$(BootstrapDestination)SdkResolvers\Microsoft.Build.NuGetSdkResolver" />
 
+    <Copy SourceFiles="$(RuntimeIdentifierGraphPath)"
+          DestinationFolder="$(BootstrapDestination)" />
+
     <Copy SourceFiles="@(InstalledSdks)"
           DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)Sdks\%(RecursiveDir)%(Filename)%(Extension)')" />
 
diff --git a/eng/CredScanSuppressions.json b/eng/CredScanSuppressions.json
new file mode 100644
index 00000000000..60c6eb75461
--- /dev/null
+++ b/eng/CredScanSuppressions.json
@@ -0,0 +1,9 @@
+{
+    "tool": "Credential Scanner",
+    "suppressions": [
+      {
+        "file": "\\src\\Tasks.UnitTests\\TestResources\\mycert.pfx",
+        "_justification": "New certificate file with private key used only for testing"
+      }
+    ]
+ }
\ No newline at end of file
diff --git a/eng/Packages.props b/eng/Packages.props
index 489ea061c95..b84d22149d7 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -25,10 +25,10 @@
     <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
     <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
-    <PackageVersion Include="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
+    <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
   </ItemGroup>
diff --git a/eng/Signing.props b/eng/Signing.props
index 66347f3d9d1..3e8e6dbf5cc 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -1,9 +1,11 @@
 <Project>
   <ItemGroup>
     <ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" />
+
+    <FileSignInfo Include="RuntimeContracts.dll" CertificateName="3PartySHA2" />
   </ItemGroup>
-    
+
   <PropertyGroup>
     <UseDotNetCertificate>true</UseDotNetCertificate>
   </PropertyGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 15a527720b7..b341b5e5b5a 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -3,15 +3,17 @@
 
 <UsageData>
   <IgnorePatterns>
-    <UsagePattern IdentityGlob="Microsoft.SourceBuild.Intermediate.*/*" />
-
     <!-- Baseline 7.0 dependencies until msbuild targets net8 and uses a net8 arcade, SBRP, etc.
          These cannot be added to 7.0 SBRP, because they would are produced in the 7.0 build. -->
-    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*7.0.3*" />
+    <UsagePattern IdentityGlob="System.Collections.Immutable/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.Metadata/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Resources.Extensions/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
   </IgnorePatterns>
   <Usages>
   </Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 2758bb113ec..2f5ec2009c7 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,90 +1,93 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ProductDependencies>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23428.2">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23565.1">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>26ce96327dd346534926c4551f8b8d62a6fc724f</Sha>
+      <Sha>95f83e27806330fec09edd96e06bba3acabe3f35</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.CodeDom" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.CodeDom" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
       This allows the package to be retrieved from previously-source-built artifacts and flow in as dependencies
       of the packages produced by msbuild. -->
-    <Dependency Name="System.Collections.Immutable" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Collections.Immutable" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Configuration.ConfigurationManager" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Configuration.ConfigurationManager" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.Metadata" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Reflection.Metadata" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.MetadataLoadContext" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Reflection.MetadataLoadContext" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Resources.Extensions" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Resources.Extensions" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Security.Cryptography.Pkcs" Version="7.0.2">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Security.Cryptography.Pkcs" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Security.Cryptography.Xml" Version="7.0.1">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Security.Cryptography.Xml" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Security.Permissions" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Text.Json" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    </Dependency>
+    <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="7.0.3">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>5b20af47d99620150c53eaf5db8636fdf730b126</Sha>
+    <Dependency Name="System.Threading.Channels" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23425.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23580.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>90c167d5c57de4a8bced566379dbd893556c94e8</Sha>
+      <Sha>efc3da96e5ac110513e92ebd9ef87c73f44d8540</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23423.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
       <Uri>https://github.com/dotnet/xliff-tasks</Uri>
-      <Sha>ed9a83526483c094fb51e7000b6f816ce6cb0325</Sha>
+      <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-preview.1.82">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.9.0-preview.1.64">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>7bb6ca5f6930d23fd93820dfc9c6a4373c8fd691</Sha>
+      <Sha>2a234707a663f731e4de93cba4014ed1a8259def</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-2.23426.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.9.0-3.23615.7">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>34268d1bb9370c7b01c742303a895a99daf10d6a</Sha>
+      <Sha>6a1cfc22d6b40c4e0fe5ac98a77a251c987a7c51</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23425.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23580.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>90c167d5c57de4a8bced566379dbd893556c94e8</Sha>
+      <Sha>efc3da96e5ac110513e92ebd9ef87c73f44d8540</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 58866d8cc69..2d1deca4e31 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.8.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.7.0</PackageValidationBaselineVersion>
+    <VersionPrefix>17.10.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.8.3</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -26,8 +26,8 @@
   </PropertyGroup>
   <!-- Production Dependencies -->
   <PropertyGroup>
-    <SystemCollectionsImmutableVersion>7.0.0</SystemCollectionsImmutableVersion>
-    <SystemConfigurationConfigurationManagerVersion>7.0.0</SystemConfigurationConfigurationManagerVersion>
+    <SystemCollectionsImmutableVersion>8.0.0</SystemCollectionsImmutableVersion>
+    <SystemConfigurationConfigurationManagerVersion>8.0.0</SystemConfigurationConfigurationManagerVersion>
     <!--
         Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
         When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
@@ -35,12 +35,13 @@
     -->
     <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
     <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
-    <SystemReflectionMetadataLoadContextVersion>7.0.0</SystemReflectionMetadataLoadContextVersion>
-    <SystemReflectionMetadataVersion>7.0.0</SystemReflectionMetadataVersion>
-    <SystemResourcesExtensionsPackageVersion>7.0.0</SystemResourcesExtensionsPackageVersion>
-    <SystemSecurityPermissionsVersion>7.0.0</SystemSecurityPermissionsVersion>
+    <SystemReflectionMetadataLoadContextVersion>8.0.0</SystemReflectionMetadataLoadContextVersion>
+    <SystemReflectionMetadataVersion>8.0.0</SystemReflectionMetadataVersion>
+    <SystemResourcesExtensionsPackageVersion>8.0.0</SystemResourcesExtensionsPackageVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
+    <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
+    <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
@@ -48,14 +49,13 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23425.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23580.1</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.8.0-2.23426.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.8.0-preview.1.82</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.9.0-3.23615.7</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.9.0-preview.1.64</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
-    <SystemTextJsonVersion>7.0.3</SystemTextJsonVersion>
-    <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
+    <SystemTextJsonVersion>8.0.0</SystemTextJsonVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index a88d643c8a7..0998e875e5f 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -207,6 +207,7 @@ elseif(ILLUMOS)
     set(CMAKE_CXX_STANDARD_LIBRARIES "${CMAKE_CXX_STANDARD_LIBRARIES} -lssp")
 elseif(HAIKU)
     set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
+    set(CMAKE_PROGRAM_PATH "${CMAKE_PROGRAM_PATH};${CROSS_ROOTFS}/cross-tools-x86_64/bin")
 
     set(TOOLSET_PREFIX ${TOOLCHAIN}-)
     function(locate_toolchain_exec exec var)
@@ -217,7 +218,6 @@ elseif(HAIKU)
         endif()
 
         find_program(EXEC_LOCATION_${exec}
-            PATHS "${CROSS_ROOTFS}/cross-tools-x86_64/bin"
             NAMES
             "${TOOLSET_PREFIX}${exec}${CLR_CMAKE_COMPILER_FILE_NAME_VERSION}"
             "${TOOLSET_PREFIX}${exec}")
diff --git a/eng/common/darc-init.ps1 b/eng/common/darc-init.ps1
index 435e7641341..8fda30bdce2 100644
--- a/eng/common/darc-init.ps1
+++ b/eng/common/darc-init.ps1
@@ -1,6 +1,6 @@
 param (
     $darcVersion = $null,
-    $versionEndpoint = 'https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16',
+    $versionEndpoint = 'https://maestro.dot.net/api/assets/darc-version?api-version=2019-01-16',
     $verbosity = 'minimal',
     $toolpath = $null
 )
diff --git a/eng/common/darc-init.sh b/eng/common/darc-init.sh
index 84c1d0cc2e7..c305ae6bd77 100755
--- a/eng/common/darc-init.sh
+++ b/eng/common/darc-init.sh
@@ -2,7 +2,7 @@
 
 source="${BASH_SOURCE[0]}"
 darcVersion=''
-versionEndpoint='https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16'
+versionEndpoint='https://maestro.dot.net/api/assets/darc-version?api-version=2019-01-16'
 verbosity='minimal'
 
 while [[ $# > 0 ]]; do
diff --git a/eng/common/post-build/add-build-to-channel.ps1 b/eng/common/post-build/add-build-to-channel.ps1
index de2d957922a..49938f0c89f 100644
--- a/eng/common/post-build/add-build-to-channel.ps1
+++ b/eng/common/post-build/add-build-to-channel.ps1
@@ -2,7 +2,7 @@ param(
   [Parameter(Mandatory=$true)][int] $BuildId,
   [Parameter(Mandatory=$true)][int] $ChannelId,
   [Parameter(Mandatory=$true)][string] $MaestroApiAccessToken,
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro.dot.net',
   [Parameter(Mandatory=$false)][string] $MaestroApiVersion = '2019-01-16'
 )
 
diff --git a/eng/common/post-build/publish-using-darc.ps1 b/eng/common/post-build/publish-using-darc.ps1
index 8508397d776..1e779fec4dd 100644
--- a/eng/common/post-build/publish-using-darc.ps1
+++ b/eng/common/post-build/publish-using-darc.ps1
@@ -3,7 +3,7 @@ param(
   [Parameter(Mandatory=$true)][int] $PublishingInfraVersion,
   [Parameter(Mandatory=$true)][string] $AzdoToken,
   [Parameter(Mandatory=$true)][string] $MaestroToken,
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro.dot.net',
   [Parameter(Mandatory=$true)][string] $WaitPublishingFinish,
   [Parameter(Mandatory=$false)][string] $ArtifactsPublishingAdditionalParameters,
   [Parameter(Mandatory=$false)][string] $SymbolPublishingAdditionalParameters
diff --git a/eng/common/post-build/trigger-subscriptions.ps1 b/eng/common/post-build/trigger-subscriptions.ps1
index 55dea518ac5..ac9a95778fc 100644
--- a/eng/common/post-build/trigger-subscriptions.ps1
+++ b/eng/common/post-build/trigger-subscriptions.ps1
@@ -2,7 +2,7 @@ param(
   [Parameter(Mandatory=$true)][string] $SourceRepo,
   [Parameter(Mandatory=$true)][int] $ChannelId,
   [Parameter(Mandatory=$true)][string] $MaestroApiAccessToken,
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro.dot.net',
   [Parameter(Mandatory=$false)][string] $MaestroApiVersion = '2019-01-16'
 )
 
diff --git a/eng/common/sdk-task.ps1 b/eng/common/sdk-task.ps1
index 6c4ac6fec1a..73828dd30d3 100644
--- a/eng/common/sdk-task.ps1
+++ b/eng/common/sdk-task.ps1
@@ -64,7 +64,7 @@ try {
       $GlobalJson.tools | Add-Member -Name "vs" -Value (ConvertFrom-Json "{ `"version`": `"16.5`" }") -MemberType NoteProperty
     }
     if( -not ($GlobalJson.tools.PSObject.Properties.Name -match "xcopy-msbuild" )) {
-      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "17.6.0-2" -MemberType NoteProperty
+      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "17.8.1-2" -MemberType NoteProperty
     }
     if ($GlobalJson.tools."xcopy-msbuild".Trim() -ine "none") {
         $xcopyMSBuildToolsFolder = InitializeXCopyMSBuild $GlobalJson.tools."xcopy-msbuild" -install $true
diff --git a/eng/common/templates/job/publish-build-assets.yml b/eng/common/templates/job/publish-build-assets.yml
index 42017109f37..bb0d9f8b0f1 100644
--- a/eng/common/templates/job/publish-build-assets.yml
+++ b/eng/common/templates/job/publish-build-assets.yml
@@ -81,7 +81,7 @@ jobs:
         arguments: -task PublishBuildAssets -restore -msbuildEngine dotnet
           /p:ManifestsPath='$(Build.StagingDirectory)/Download/AssetManifests'
           /p:BuildAssetRegistryToken=$(MaestroAccessToken)
-          /p:MaestroApiEndpoint=https://maestro-prod.westus2.cloudapp.azure.com
+          /p:MaestroApiEndpoint=https://maestro.dot.net
           /p:PublishUsingPipelines=${{ parameters.publishUsingPipelines }}
           /p:OfficialBuildId=$(Build.BuildNumber)
       condition: ${{ parameters.condition }}
diff --git a/eng/common/templates/post-build/common-variables.yml b/eng/common/templates/post-build/common-variables.yml
index c24193acfc9..173914f2364 100644
--- a/eng/common/templates/post-build/common-variables.yml
+++ b/eng/common/templates/post-build/common-variables.yml
@@ -7,7 +7,7 @@ variables:
 
   # Default Maestro++ API Endpoint and API Version
   - name: MaestroApiEndPoint
-    value: "https://maestro-prod.westus2.cloudapp.azure.com"
+    value: "https://maestro.dot.net"
   - name: MaestroApiAccessToken
     value: $(MaestroAccessToken)
   - name: MaestroApiVersion
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index aa74ab4a81e..fdd0cbb91f8 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -379,13 +379,13 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
   }
 
   # Minimum VS version to require.
-  $vsMinVersionReqdStr = '17.6'
+  $vsMinVersionReqdStr = '17.7'
   $vsMinVersionReqd = [Version]::new($vsMinVersionReqdStr)
 
   # If the version of msbuild is going to be xcopied,
   # use this version. Version matches a package here:
-  # https://dev.azure.com/dnceng/public/_artifacts/feed/dotnet-eng/NuGet/RoslynTools.MSBuild/versions/17.6.0-2
-  $defaultXCopyMSBuildVersion = '17.6.0-2'
+  # https://dev.azure.com/dnceng/public/_artifacts/feed/dotnet-eng/NuGet/RoslynTools.MSBuild/versions/17.8.1-2
+  $defaultXCopyMSBuildVersion = '17.8.1-2'
 
   if (!$vsRequirements) {
     if (Get-Member -InputObject $GlobalJson.tools -Name 'vs') {
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 4a6756eff0a..ef064473a14 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -10,28 +10,31 @@
   these properties to override package versions if necessary. -->
 
   <ItemGroup>
-    <PackageVersion Include="BenchmarkDotNet" Version="0.13.1" />
+    <PackageVersion Include="BenchmarkDotNet" Version="0.13.10" />
     <PackageVersion Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
 
-    <PackageVersion Include="FluentAssertions" Version="6.11.0" />
+    <PackageVersion Include="FluentAssertions" Version="6.12.0" />
     <PackageVersion Update="FluentAssertions" Condition="'$(FluentAssertionsVersion)' != ''" Version="$(FluentAssertionsVersion)" />
 
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
-    <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
-    <PackageVersion Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
+    <PackageVersion Include="Microsoft.BuildXL.Processes" Version="0.1.0-20231128.3" />
+    <PackageVersion Update="Microsoft.BuildXL.Processes" Condition="'$(BuildXLProcessesVersion)' != ''" Version="$(BuildXLProcessesVersion)" />
+
+    <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.8.2112" />
+    <PackageVersion Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" />
 
     <PackageVersion Include="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageVersion Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
 
-    <PackageVersion Include="Newtonsoft.Json" Version="13.0.2" />
+    <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
     <PackageVersion Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
 
     <PackageVersion Include="PdbGit" Version="3.0.41" />
     <PackageVersion Update="PdbGit" Condition="'$(PdbGitVersion)' != ''" Version="$(PdbGitVersion)" />
 
-    <PackageVersion Include="Shouldly" Version="3.0.0" />
+    <PackageVersion Include="Shouldly" Version="4.2.1" />
     <PackageVersion Update="Shouldly" Condition="'$(ShouldlyVersion)' != ''" Version="$(ShouldlyVersion)" />
 
     <PackageVersion Include="System.CodeDom" Version="7.0.0" />
diff --git a/eng/policheck_exclusions.xml b/eng/policheck_exclusions.xml
new file mode 100644
index 00000000000..841de0e4f01
--- /dev/null
+++ b/eng/policheck_exclusions.xml
@@ -0,0 +1,17 @@
+<PoliCheckExclusions>
+  <!-- All strings must be UPPER CASE -->
+  <!--Each of these exclusions is a folder name -if \[name]\exists in the file path, it will be skipped -->
+  <!--<Exclusion Type="FolderPathFull">ABC|XYZ</Exclusion>-->
+  <!--Each of these exclusions is a folder name -if any folder or file starts with "\[name]", it will be skipped -->
+  <!--<Exclusion Type="FolderPathStart">ABC|XYZ</Exclusion>-->
+  <!--Each of these file types will be completely skipped for the entire scan -->
+  <!--<Exclusion Type="FileType">.ABC|.XYZ</Exclusion>-->
+  <!--The specified file names will be skipped during the scan regardless which folder they are in -->
+  <!--<Exclusion Type="FileName">ABC.TXT|XYZ.CS</Exclusion>-->
+
+  <Exclusion Type="FolderPathFull">.DOTNET</Exclusion>
+  <!-- This file contains entity names that were written out by the XML writer in the VS.NET 2002/2003 project system. Leave them unchanged and skip the file -->
+  <Exclusion Type="FileName">OLDVSPROJECTFILEREADER.CS</Exclusion>
+  <!-- Since only support the locale en-us in our repo, skip the translated files currently. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1889125  -->
+  <Exclusion Type="FileType">.XLF</Exclusion>
+</PoliCheckExclusions>
diff --git a/global.json b/global.json
index d9967b3a53d..c4a5905f89c 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "8.0.100-preview.7.23376.3",
+    "dotnet": "8.0.100",
     "vs": {
-      "version": "17.6.0"
+      "version": "17.8.0"
     },
-    "xcopy-msbuild": "17.6.0-2"
+    "xcopy-msbuild": "17.8.1-2"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23425.2"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23580.1"
   }
 }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index 37b65ce9199..95e2726de9f 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -5,7 +5,9 @@ Param(
   [ValidateSet('Debug','Release')]
   [string] $configuration = "Debug",
   [ValidateSet('Core','Desktop', 'Detect', 'Full')]
-  [string] $runtime = "Detect"
+  [string] $runtime = "Detect",
+  [string] $binDirectory = "",
+  [bool] $makeBackup = $true
 )
 
 Set-StrictMode -Version "Latest"
@@ -15,9 +17,9 @@ function Copy-WithBackup ($origin, $destinationSubFolder = "") {
     $directoryPart = [IO.Path]::Combine($destination, $destinationSubFolder, $origin.IntermediaryDirectories)
     $destinationPath = Join-Path -Path $directoryPart (Split-Path $origin.SourceFile -leaf)
 
-    $backupInto = [IO.Path]::Combine($BackupFolder, $destinationSubFolder)
+    if (($makeBackup) -and (Test-Path $destinationPath -PathType Leaf)) {
+        $backupInto = [IO.Path]::Combine($BackupFolder, $destinationSubFolder)
 
-    if (Test-Path $destinationPath -PathType Leaf) {
         # Back up previous copy of the file
         if (!(Test-Path $backupInto)) {
             [system.io.directory]::CreateDirectory($backupInto)
@@ -45,10 +47,15 @@ function FileToCopy([string] $sourceFileRelativeToRepoRoot, [string] $intermedia
 
 # TODO: find most-recently-built MSBuild and make it default $configuration
 
-$BackupFolder = New-Item (Join-Path $destination -ChildPath "Backup-$(Get-Date -Format FileDateTime)") -itemType directory -ErrorAction Stop
-
 Write-Verbose "Copying $configuration MSBuild to $destination"
-Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
+
+if ($makeBackup) {
+    $BackupFolder = New-Item (Join-Path $destination -ChildPath "Backup-$(Get-Date -Format FileDateTime)") -itemType directory -ErrorAction Stop
+    Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
+}
+else {
+    Write-Host "Existing MSBuild assemblies won't be backed up"
+}
 
 if ($runtime -eq "Detect") {
     if ($destination -like "*dotnet*sdk*") {
@@ -72,7 +79,12 @@ if ($runtime -eq "Desktop") {
     $targetFramework = "net8.0"
 }
 
-$bootstrapBinDirectory = "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework"
+# If bootstrap directory is not defined in parameters, use the default location
+if ($binDirectory -eq "") {
+    $binDirectory = "artifacts\bin" 
+}
+
+$bootstrapBinDirectory = "$binDirectory\MSBuild.Bootstrap\$configuration\$targetFramework"
 
 $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.dll"
@@ -104,8 +116,8 @@ $filesToCopyToBin = @(
 
 if ($runtime -eq "Desktop") {
     $runtimeSpecificFiles = @(
-        FileToCopy "artifacts\bin\Microsoft.Build.Conversion\$configuration\$targetFramework\Microsoft.Build.Conversion.Core.dll"
-        FileToCopy "artifacts\bin\Microsoft.Build.Engine\$configuration\$targetFramework\Microsoft.Build.Engine.dll"
+        FileToCopy "$binDirectory\Microsoft.Build.Conversion\$configuration\$targetFramework\Microsoft.Build.Conversion.Core.dll"
+        FileToCopy "$binDirectory\Microsoft.Build.Engine\$configuration\$targetFramework\Microsoft.Build.Engine.dll"
 
         FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.Data.Entity.targets"
@@ -140,14 +152,14 @@ if ($runtime -eq "Desktop") {
     $x86files = @(
         FileToCopy "$bootstrapBinDirectory\MSBuild.exe"
         FileToCopy "$bootstrapBinDirectory\MSBuild.exe.config"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.exe"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.pdb"
+        FileToCopy "$binDirectory\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.exe"
+        FileToCopy "$binDirectory\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.pdb"
     )
     $amd64files = @(
-        FileToCopy "artifacts\bin\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe"
-        FileToCopy "artifacts\bin\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe.config"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.exe"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.pdb"
+        FileToCopy "$binDirectory\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe"
+        FileToCopy "$binDirectory\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe.config"
+        FileToCopy "$binDirectory\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.exe"
+        FileToCopy "$binDirectory\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.pdb"
     )
 }
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
index 57441a1ae20..317fb32847a 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
@@ -77,7 +77,7 @@ public void ProjectWhitespaceFormatting()
             // Note that there are two spaces after the <ItemGroup> tag on the second line
             string content = ObjectModelHelpers.CleanupFileContents(@"
 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
-  <ItemGroup>  
+  <ItemGroup>
     <ProjectReference Include=`..\CLREXE\CLREXE.vcxproj`>
 <Project>{3699f81b-2d03-46c5-abd7-e88a4c946f28}</Project>
     </ProjectReference>
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index a67068c7fe8..7c4ea152dea 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -56,8 +56,8 @@ public void ParseSolution_VC()
             });
         }
         /// <summary>
-        /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid -- 
-        /// we assume that all C++ projects except .vcproj are MSBuild format. 
+        /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid --
+        /// we assume that all C++ projects except .vcproj are MSBuild format.
         /// </summary>
         [Fact]
         public void ParseSolution_VC2()
@@ -238,7 +238,7 @@ public void VersionTooLow()
             });
         }
         /// <summary>
-        /// Test to parse a very basic .sln file to validate that description property in a solution file 
+        /// Test to parse a very basic .sln file to validate that description property in a solution file
         /// is properly handled.
         /// </summary>
         [Fact]
@@ -496,8 +496,8 @@ public void SharedProjects()
         }
 
         /// <summary>
-        /// Tests situation where there's a nonexistent project listed in the solution folders.  We should 
-        /// error with a useful message. 
+        /// Tests situation where there's a nonexistent project listed in the solution folders.  We should
+        /// error with a useful message.
         /// </summary>
         [Fact]
         public void MissingNestedProject()
@@ -840,7 +840,7 @@ public void ParseInvalidSolutionConfigurations3()
             });
         }
         /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly 
+        /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
         /// </summary>
         [Fact]
@@ -938,7 +938,7 @@ public void ParseProjectConfigurationsInSolutionConfigurations1()
         }
 
         /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly 
+        /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a more tricky solution
         /// </summary>
         [Fact]
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
index a3e8c701e6f..37537057d34 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
@@ -456,7 +456,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_UseInBatching()
 
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionMetadataCondition()
@@ -478,7 +478,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionM
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_UnquotedBuiltInProhibitedOnItemDefinitionMetadataCondition()
@@ -500,7 +500,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_UnquotedBuiltInProhibitedOnItemDef
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionCondition()
@@ -522,7 +522,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionC
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionGroupCondition()
@@ -544,7 +544,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_BuiltInProhibitedOnItemDefinitionG
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDefinitionMetadataCondition()
@@ -566,7 +566,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDe
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDefinitionCondition()
@@ -588,7 +588,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDe
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDefinitionGroupCondition()
@@ -610,7 +610,7 @@ public void ExpandBuiltInMetadataAtPointOfUse_QualifiedBuiltInProhibitedOnItemDe
         }
         /// <summary>
         /// Built-in metadata is prohibited in item definition conditions.
-        /// Ideally it would also be late evaluated, but that's too difficult. 
+        /// Ideally it would also be late evaluated, but that's too difficult.
         /// </summary>
         [Fact]
         public void ExpandBuiltInMetadataAtPointOfUse_UnquotedQualifiedBuiltInProhibitedOnItemDefinitionCondition()
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index da4e8adc444..3c17cb2aea3 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -57,7 +57,7 @@ public class ProjectItem_Tests : IDisposable
                 ";
 
         protected readonly TestEnvironment _env;
-        private DummyMappedDrive _mappedDrive = null;
+        private Lazy<DummyMappedDrive> _mappedDrive = DummyMappedDriveUtils.GetLazyDummyMappedDrive();
 
         public ProjectItem_Tests()
         {
@@ -67,7 +67,7 @@ public ProjectItem_Tests()
         public void Dispose()
         {
             _env.Dispose();
-            _mappedDrive?.Dispose();
+            _mappedDrive.Value?.Dispose();
         }
 
         /// <summary>
@@ -804,8 +804,7 @@ public void ProjectGetterResultsInDriveEnumerationException(string unevaluatedIn
         [InlineData(@"%DRIVE%:\**\*.cs")]
         public void ProjectGetterResultsInWindowsDriveEnumerationWarning(string unevaluatedInclude)
         {
-            var mappedDrive = GetDummyMappedDrive();
-            unevaluatedInclude = UpdatePathToMappedDrive(unevaluatedInclude, mappedDrive.MappedDriveLetter);
+            unevaluatedInclude = DummyMappedDriveUtils.UpdatePathToMappedDrive(unevaluatedInclude, _mappedDrive.Value.MappedDriveLetter);
             ProjectGetterResultsInDriveEnumerationWarning(unevaluatedInclude);
         }
 
@@ -898,35 +897,12 @@ public void ThrowExceptionUponProjectInstanceCreationFromDriveEnumeratingContent
             @"%DRIVE%:\$(Microsoft_WindowsAzure_EngSys)**")]
         public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
         {
-            var mappedDrive = GetDummyMappedDrive();
-            placeHolder = UpdatePathToMappedDrive(placeHolder, mappedDrive.MappedDriveLetter);
-            excludePlaceHolder = UpdatePathToMappedDrive(excludePlaceHolder, mappedDrive.MappedDriveLetter);
+            placeHolder = DummyMappedDriveUtils.UpdatePathToMappedDrive(placeHolder, _mappedDrive.Value.MappedDriveLetter);
+            excludePlaceHolder = DummyMappedDriveUtils.UpdatePathToMappedDrive(excludePlaceHolder, _mappedDrive.Value.MappedDriveLetter);
             content = string.Format(content, placeHolder, excludePlaceHolder);
             CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
         }
 
-        private DummyMappedDrive GetDummyMappedDrive()
-        {
-            if (NativeMethods.IsWindows)
-            {
-                // let's create the mapped drive only once it's needed by any test, then let's reuse;
-                _mappedDrive ??= new DummyMappedDrive();
-            }
-
-            return _mappedDrive;
-        }
-
-        private static string UpdatePathToMappedDrive(string path, char driveLetter)
-        {
-            const string drivePlaceholder = "%DRIVE%";
-            // if this seems to be rooted path - replace with the dummy mount
-            if (!string.IsNullOrEmpty(path) && path.StartsWith(drivePlaceholder))
-            {
-                path = driveLetter + path.Substring(drivePlaceholder.Length);
-            }
-            return path;
-        }
-
         [UnixOnlyTheory]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/8373")]
         [InlineData(
@@ -968,7 +944,7 @@ private static void CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(Te
         {
             try
             {
-                // Reset state 
+                // Reset state
                 Helpers.ResetStateForDriveEnumeratingWildcardTests(env, throwException ? "1" : "0");
 
                 if (throwException)
@@ -3782,10 +3758,10 @@ public void FileNameMetadataEvaluationShouldNotDependsFromPlatformSpecificSlashe
 
     public class ProjectItemWithOptimizations_Tests : ProjectItem_Tests
     {
-        public ProjectItemWithOptimizations_Tests()
-        {
-            // Make sure we always use the dictionary-based Remove logic.
-            _env.SetEnvironmentVariable("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", "0");
-        }
+       public ProjectItemWithOptimizations_Tests()
+       {
+           // Make sure we always use the dictionary-based Remove logic.
+           _env.SetEnvironmentVariable("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", "0");
+       }
     }
 }
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index fbdf4b3742f..44a917968a2 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.NetCore.Extensions;
@@ -24,12 +25,19 @@ namespace Microsoft.Build.UnitTests.OM.Instance
     /// <summary>
     /// Tests for ProjectItemInstance public members
     /// </summary>
-    public class ProjectItemInstance_Tests
+    public class ProjectItemInstance_Tests : IDisposable
     {
         /// <summary>
         /// The number of built-in metadata for items.
         /// </summary>
         public const int BuiltInMetadataCount = 15;
+        private Lazy<DummyMappedDrive> _mappedDrive = DummyMappedDriveUtils.GetLazyDummyMappedDrive();
+
+
+        public void Dispose()
+        {
+            _mappedDrive.Value?.Dispose();
+        }
 
         internal const string TargetItemWithInclude = @"
             <Project>
@@ -999,33 +1007,30 @@ public void ThrowExceptionUponBuildingProjectWithDriveEnumeration(string content
         /// <summary>
         /// Log warning for drive enumerating wildcards that exist in projects on Windows platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
         [WindowsOnlyTheory]
         [InlineData(
             TargetItemWithIncludeAndExclude,
-            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"%DRIVE%:$(Microsoft_WindowsAzure_EngSys)\**\*",
             @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
 
-        [InlineData(
-            TargetItemWithIncludeAndExclude,
-            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb",
-            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*")]
-
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)**",
             null,
             "Microsoft_WindowsAzure_EngSys",
-            @"z:\")]
+            @"%DRIVE%:\")]
 
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)\**\*",
             null,
             "Microsoft_WindowsAzure_EngSys",
-            @"z:")]
+            @"%DRIVE%:")]
         public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
         {
+            include = DummyMappedDriveUtils.UpdatePathToMappedDrive(include, _mappedDrive.Value.MappedDriveLetter);
+            exclude = DummyMappedDriveUtils.UpdatePathToMappedDrive(exclude, _mappedDrive.Value.MappedDriveLetter);
+            propertyValue = DummyMappedDriveUtils.UpdatePathToMappedDrive(propertyValue, _mappedDrive.Value.MappedDriveLetter);
             content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
                 string.Format(content, include, exclude) :
                 string.Format(content, property, propertyValue, include);
@@ -1040,7 +1045,7 @@ public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string cont
         /// <summary>
         /// Log warning for drive enumerating wildcards that exist in projects on Unix platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/8373")]
         [UnixOnlyTheory]
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 57cba86c10c..d2515288da0 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -36,21 +36,11 @@
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\MockLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ErrorUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\FileDelegates.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ResourceUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs" />
+    <Compile Include="..\Shared\UnitTests\MockLogger.cs" />
+    <Compile Include="..\Shared\ErrorUtilities.cs" />
+    <Compile Include="..\Shared\FileDelegates.cs" />
+    <Compile Include="..\Shared\ResourceUtilities.cs" />
     <Compile Include="..\Shared\UnitTests\EngineTestEnvironment.cs">
       <Link>EngineTestEnvironment.cs</Link>
     </Compile>
@@ -61,18 +51,10 @@
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs" />
-    <Compile Include="..\Shared\FileUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\EscapingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\FileUtilitiesRegex.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ExceptionHandling.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\FileUtilities.cs" />
+    <Compile Include="..\Shared\EscapingUtilities.cs" />
+    <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
+    <Compile Include="..\Shared\ExceptionHandling.cs" />
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
@@ -81,6 +63,7 @@
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
     <Compile Include="..\UnitTests.Shared\DriveMapping.cs" />
     <Compile Include="..\UnitTests.Shared\DummyMappedDrive.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDriveUtils.cs"/>
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
       <SubType>Designer</SubType>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index e8662ee46ec..690150d1df6 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -120,22 +120,22 @@ public class TestCollectionGroup : IDisposable
                             <When Condition=""'$(Configuration)'=='Foo'"">
                               <PropertyGroup>
                                 <p>vFoo</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                             </When>
                             <When Condition='false'>
                               <PropertyGroup>
                                 <p>vFalse</p>
-                              </PropertyGroup> 
-                            </When>      
+                              </PropertyGroup>
+                            </When>
                             <When Condition='true'>
                               <PropertyGroup>
                                 <p>vTrue</p>
-                              </PropertyGroup> 
-                            </When>      
+                              </PropertyGroup>
+                            </When>
                             <Otherwise>
                               <PropertyGroup>
                                 <p>vOtherwise</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                             </Otherwise>
                         </Choose>
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
index 075a0af11ec..6cd6b26cf96 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     /// <summary>
     /// The C# does not really provide a easy way to efficiently implement inheritance in cases like this
     /// for abstract classes or interface, when there is a hierarchy, it is not way to share the implementation.
-    /// Like if one have IFoo and IBar : IFoo (or as we do abstractFoo, abstractBar:abstractFoo) 
+    /// Like if one have IFoo and IBar : IFoo (or as we do abstractFoo, abstractBar:abstractFoo)
     /// we can provide implementation for IFoo, but we can not use that for implementations for IBar.
     /// Since no multiple inheritance or other suitable mechanism for code share across classes is supported by C#,
     /// Instead IBar implementation should fully implement both IFoo and IBar interfaces.
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index c6378a0ece2..11c0b2b2ff0 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -33,7 +33,7 @@ public override Project CreateLinkedObject(IImportHolder holder)
 
         // all bellow are very inefficient,
         // in reality we do cache these collections  until invalidated and use lazy access for dictionaries.
-        // TODO: Might bring that infrastructure here as well ... 
+        // TODO: Might bring that infrastructure here as well ...
         public IDictionary<string, string> GlobalProperties => this.Source.GlobalProperties;
         public ICollection<string> ItemTypes => this.Source.ItemTypes;
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
index 607e9ba8586..c15ef79fb8f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
@@ -21,12 +21,12 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     For the ExternalProjectsProvider mock infrastructure we'll try to use very similar model as in the actual implementation in VS.
 
     Typical flow for "linked object" of type "Foo"
-    [ ---  Client Collection                                    ]                           [ Server collection (can be different process) ] 
+    [ ---  Client Collection                                    ]                           [ Server collection (can be different process) ]
     (Foo) localView <=> (FooLink) link <=> FooLinkRemoter (Proxy) <=~connection mechanism~=> FooLinkRemoter(stub) <=> (Real object)
-    
+
     FooLinkRemoter would be whatever ExternalProviders see useful to provide FooLink implementation and is compatable with connection mechanism
     it might be completely different interface since some link types would be either inefficient or impossible to serialize for example and pass cross process.
-    
+
     Here we can cheat a little bit, since we run both Client and Server collection in the same process so we can ignore connection mechanism (typically some
     form of serialization/deserialization) and just give the "client" link implementation the same Remoter object we create on the "server"
 
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index 8bf9bf686bb..a2d52c2df63 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -97,7 +97,7 @@ public void GoodTaskNameButNotInInfo()
         }
         /// <summary>
         /// Make sure we get an internal error when we call the initialize factory on the public method.
-        /// This is done because we cannot properly initialize the task factory using the public interface and keep 
+        /// This is done because we cannot properly initialize the task factory using the public interface and keep
         /// backwards compatibility with orcas and whidbey.
         /// </summary>
         [Fact]
@@ -111,7 +111,7 @@ public void CallPublicInitializeFactory()
         }
         /// <summary>
         /// Make sure we get an internal error when we call the ITaskFactory2 version of initialize factory.
-        /// This is done because we cannot properly initialize the task factory using the public interface and keep 
+        /// This is done because we cannot properly initialize the task factory using the public interface and keep
         /// backwards compatibility with orcas and whidbey.
         /// </summary>
         [Fact]
@@ -166,8 +166,8 @@ public void CreatableByTaskFactoryNullTaskName()
             });
         }
         /// <summary>
-        /// Make sure that when an explicitly matching identity is specified (e.g. the identity is non-empty), 
-        /// it still counts as correct.  
+        /// Make sure that when an explicitly matching identity is specified (e.g. the identity is non-empty),
+        /// it still counts as correct.
         /// </summary>
         [Fact]
         public void CreatableByTaskFactoryMatchingIdentity()
@@ -186,7 +186,7 @@ public void CreatableByTaskFactoryMatchingIdentity()
         }
 
         /// <summary>
-        /// Verify that if the task identity parameters don't match the factory identity, TaskNameCreatableByFactory 
+        /// Verify that if the task identity parameters don't match the factory identity, TaskNameCreatableByFactory
         /// returns false.
         /// </summary>
         [Fact]
@@ -263,7 +263,7 @@ public void VerifyGoodTaskInstantiation()
         }
 
         /// <summary>
-        /// Verify a good task that does not use the task host can be created when passed "don't care" 
+        /// Verify a good task that does not use the task host can be created when passed "don't care"
         /// for the task invocation task host parameters.
         /// </summary>
         [Fact]
@@ -294,8 +294,8 @@ public void VerifyMatchingTaskParametersDontLaunchTaskHost1()
         }
 
         /// <summary>
-        /// Verify a good task that does not use the task host can be created when passed task host 
-        /// parameters that explicitly match the current process. 
+        /// Verify a good task that does not use the task host can be created when passed task host
+        /// parameters that explicitly match the current process.
         /// </summary>
         [Fact]
         public void VerifyMatchingTaskParametersDontLaunchTaskHost2()
@@ -325,7 +325,7 @@ public void VerifyMatchingTaskParametersDontLaunchTaskHost2()
         }
 
         /// <summary>
-        /// Verify a good task that does not use the task host can be created when passed "don't care" 
+        /// Verify a good task that does not use the task host can be created when passed "don't care"
         /// for the task invocation task host parameters.
         /// </summary>
         [Fact]
@@ -358,8 +358,8 @@ public void VerifyMatchingUsingTaskParametersDontLaunchTaskHost1()
         }
 
         /// <summary>
-        /// Verify a good task that does not use the task host can be created when passed task host 
-        /// parameters that explicitly match the current process. 
+        /// Verify a good task that does not use the task host can be created when passed task host
+        /// parameters that explicitly match the current process.
         /// </summary>
         [Fact]
         public void VerifyMatchingUsingTaskParametersDontLaunchTaskHost2()
@@ -391,8 +391,8 @@ public void VerifyMatchingUsingTaskParametersDontLaunchTaskHost2()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when passed task host 
-        /// parameters that explicitly do not match the current process. 
+        /// Verify a good task that uses the task host can be created when passed task host
+        /// parameters that explicitly do not match the current process.
         /// </summary>
         [Fact]
         public void VerifyMatchingParametersDontLaunchTaskHost()
@@ -426,8 +426,8 @@ public void VerifyMatchingParametersDontLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when passed task host 
-        /// parameters that explicitly do not match the current process. 
+        /// Verify a good task that uses the task host can be created when passed task host
+        /// parameters that explicitly do not match the current process.
         /// </summary>
         [Fact]
         public void VerifyNonmatchingUsingTaskParametersLaunchTaskHost()
@@ -459,8 +459,8 @@ public void VerifyNonmatchingUsingTaskParametersLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when passed task host 
-        /// parameters that explicitly do not match the current process. 
+        /// Verify a good task that uses the task host can be created when passed task host
+        /// parameters that explicitly do not match the current process.
         /// </summary>
         [Fact]
         public void VerifyNonmatchingTaskParametersLaunchTaskHost()
@@ -490,8 +490,8 @@ public void VerifyNonmatchingTaskParametersLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when passed task host 
-        /// parameters that explicitly do not match the current process. 
+        /// Verify a good task that uses the task host can be created when passed task host
+        /// parameters that explicitly do not match the current process.
         /// </summary>
         [Fact]
         public void VerifyNonmatchingParametersLaunchTaskHost()
@@ -525,8 +525,8 @@ public void VerifyNonmatchingParametersLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when the task factory is 
-        /// explicitly instructed to launch the task host. 
+        /// Verify a good task that uses the task host can be created when the task factory is
+        /// explicitly instructed to launch the task host.
         /// </summary>
         [Fact]
         public void VerifyExplicitlyLaunchTaskHost()
@@ -554,8 +554,8 @@ public void VerifyExplicitlyLaunchTaskHost()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when the task factory is 
-        /// explicitly instructed to launch the task host. 
+        /// Verify a good task that uses the task host can be created when the task factory is
+        /// explicitly instructed to launch the task host.
         /// </summary>
         [Fact]
         public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch1()
@@ -587,8 +587,8 @@ public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch1()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when the task factory is 
-        /// explicitly instructed to launch the task host. 
+        /// Verify a good task that uses the task host can be created when the task factory is
+        /// explicitly instructed to launch the task host.
         /// </summary>
         [Fact]
         public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch2()
@@ -620,8 +620,8 @@ public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch2()
         }
 
         /// <summary>
-        /// Verify a good task that uses the task host can be created when the task factory is 
-        /// explicitly instructed to launch the task host. 
+        /// Verify a good task that uses the task host can be created when the task factory is
+        /// explicitly instructed to launch the task host.
         /// </summary>
         [Fact]
         public void VerifySameFactoryCanGenerateDifferentTaskInstances()
@@ -677,7 +677,7 @@ public void VerifySameFactoryCanGenerateDifferentTaskInstances()
         }
 
         /// <summary>
-        /// Abstract out the creation of the new AssemblyTaskFactory with default task, and 
+        /// Abstract out the creation of the new AssemblyTaskFactory with default task, and
         /// with some basic validation.
         /// </summary>
         private void SetupTaskFactory(IDictionary<string, string> factoryParameters, bool explicitlyLaunchTaskHost)
diff --git a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
index 170ab5deb73..2a2e8822ba1 100644
--- a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
@@ -56,7 +56,7 @@ public void TestConsumeNullBuildEvent()
             });
         }
         /// <summary>
-        /// Verify consume properly packages up the message event into a packet and send it to the 
+        /// Verify consume properly packages up the message event into a packet and send it to the
         /// transport delegate
         /// </summary>
         [Fact]
@@ -145,7 +145,7 @@ public void TestShutDown()
 
         /// <summary>
         /// Create a method which will be a fake method to process a packet.
-        /// This needs to be done because using an anonymous method does not work. 
+        /// This needs to be done because using an anonymous method does not work.
         /// Using an anonymous method does not work because when the delegate is created
         /// it seems that a field is created which creates a strong reference
         /// between the delegate and the class it was created in. This means the delegate is not
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
index f454dc1161d..72f2b212e3f 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -88,7 +88,7 @@ public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWa
         [WindowsFullFrameworkOnlyTheory]
         [InlineData("1", true)]
         [InlineData("0", false)]
-        [InlineData(null, false)]
+        [InlineData(null, true)]
         public void Build_WithCustomBuildArgs_Framework(string envVariableValue, bool isWarningExpected) =>
             TestCustomEventWarning<BuildWarningEventArgs>(envVariableValue, isWarningExpected);
 
@@ -155,9 +155,15 @@ private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningEx
         /// </summary>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index e340aaacdc6..7b1a91dfd04 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -93,9 +93,15 @@ public BuildManager_Tests(ITestOutputHelper output)
         /// </summary>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
 
         /// <summary>
@@ -4108,8 +4114,8 @@ handoff logging completion to the BuildManager.
                     submission1.ExecuteAsync(null, null);
                     submission2.ExecuteAsync(null, null);
 
-                    submission1.WaitHandle.WaitOne(TimeSpan.FromSeconds(10));
-                    submission2.WaitHandle.WaitOne(TimeSpan.FromSeconds(10));
+                    submission1.WaitHandle.WaitOne(TimeSpan.FromSeconds(20));
+                    submission2.WaitHandle.WaitOne(TimeSpan.FromSeconds(20));
 
                     submission1.IsCompleted.ShouldBeTrue();
                     submission2.IsCompleted.ShouldBeTrue();
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index e16bc08dab2..e4c22926ee0 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -340,10 +340,13 @@ public void TestEngineShutdownWhileActive()
             string[] targets = new string[3] { "target1", "target2", "target3" };
             BuildRequest request = CreateNewBuildRequest(1, targets);
 
-            VerifyEngineStatus(BuildRequestEngineStatus.Uninitialized);
+            VerifyEngineStatus(BuildRequestEngineStatus.Uninitialized, true);
             _engine.InitializeForBuild(new NodeLoggingContext(_host.LoggingService, 0, false));
+            // We neeed to get the status changed AutoResetEvent returned to the non-signaled state correctly after each status change for verifying the engine status via waiting for a signal next time.
+            // Make sure it returns back to the non-signaled state.
+            VerifyEngineStatus(BuildRequestEngineStatus.Idle);
+
             _engine.SubmitBuildRequest(request);
-            Thread.Sleep(250);
             VerifyEngineStatus(BuildRequestEngineStatus.Active);
 
             _engine.CleanupForBuild();
@@ -368,10 +371,11 @@ public void TestSimpleBuildScenario()
             string[] targets = new string[3] { "target1", "target2", "target3" };
             BuildRequest request = CreateNewBuildRequest(1, targets);
 
-            VerifyEngineStatus(BuildRequestEngineStatus.Uninitialized);
+            VerifyEngineStatus(BuildRequestEngineStatus.Uninitialized, true);
             _engine.InitializeForBuild(new NodeLoggingContext(_host.LoggingService, 0, false));
+            VerifyEngineStatus(BuildRequestEngineStatus.Idle);
+
             _engine.SubmitBuildRequest(request);
-            Thread.Sleep(250);
             VerifyEngineStatus(BuildRequestEngineStatus.Active);
 
             WaitForEvent(_requestCompleteEvent, "RequestComplete");
@@ -401,10 +405,11 @@ public void TestBuildWithChildren()
             BuildRequest request = CreateNewBuildRequest(1, targets);
 
             // Kick it off
-            VerifyEngineStatus(BuildRequestEngineStatus.Uninitialized);
+            VerifyEngineStatus(BuildRequestEngineStatus.Uninitialized, true);
             _engine.InitializeForBuild(new NodeLoggingContext(_host.LoggingService, 0, false));
+            VerifyEngineStatus(BuildRequestEngineStatus.Idle);
+
             _engine.SubmitBuildRequest(request);
-            Thread.Sleep(250);
             VerifyEngineStatus(BuildRequestEngineStatus.Active);
 
             // Wait for the new requests to be spawned by the builder
@@ -413,9 +418,6 @@ public void TestBuildWithChildren()
             Assert.Single(_newRequest_Request.BuildRequests[0].Targets);
             Assert.Equal("requiredTarget1", _newRequest_Request.BuildRequests[0].Targets[0]);
 
-            // Wait for a moment, because the build request engine thread may not have gotten around
-            // to going to the waiting state.
-            Thread.Sleep(250);
             VerifyEngineStatus(BuildRequestEngineStatus.Waiting);
 
             // Report a result to satisfy the build request
@@ -426,6 +428,8 @@ public void TestBuildWithChildren()
             // Continue the request.
             _engine.UnblockBuildRequest(new BuildRequestUnblocker(request.GlobalRequestId));
 
+            VerifyEngineStatus(BuildRequestEngineStatus.Active);
+
             // Wait for the original request to complete
             WaitForEvent(_requestCompleteEvent, "RequestComplete");
             Assert.Equal(request, _requestComplete_Request);
@@ -456,10 +460,11 @@ public void TestBuildWithNewConfiguration()
             BuildRequest request = CreateNewBuildRequest(1, targets);
 
             // Kick it off
-            VerifyEngineStatus(BuildRequestEngineStatus.Uninitialized);
+            VerifyEngineStatus(BuildRequestEngineStatus.Uninitialized, true);
             _engine.InitializeForBuild(new NodeLoggingContext(_host.LoggingService, 0, false));
+            VerifyEngineStatus(BuildRequestEngineStatus.Idle);
+
             _engine.SubmitBuildRequest(request);
-            Thread.Sleep(250);
             VerifyEngineStatus(BuildRequestEngineStatus.Active);
 
             // Wait for the request to generate the child request with the unresolved configuration
@@ -467,7 +472,6 @@ public void TestBuildWithNewConfiguration()
             Assert.Equal(Path.GetFullPath("OtherFile"), _newConfiguration_Config.ProjectFullPath);
             Assert.Equal("TestToolsVersion", _newConfiguration_Config.ToolsVersion);
             Assert.True(_newConfiguration_Config.WasGeneratedByNode);
-            Thread.Sleep(250);
             VerifyEngineStatus(BuildRequestEngineStatus.Waiting);
 
             // Resolve the configuration
@@ -489,11 +493,12 @@ public void TestBuildWithNewConfiguration()
             // Continue the request
             _engine.UnblockBuildRequest(new BuildRequestUnblocker(request.GlobalRequestId));
 
+            VerifyEngineStatus(BuildRequestEngineStatus.Active);
+
             // Wait for the original request to complete
             WaitForEvent(_requestCompleteEvent, "RequestComplete");
             Assert.Equal(request, _requestComplete_Request);
             Assert.Equal(BuildResultCode.Success, _requestComplete_Result.OverallResult);
-            Thread.Sleep(250);
             VerifyEngineStatus(BuildRequestEngineStatus.Idle);
         }
 
@@ -509,11 +514,11 @@ private BuildRequest CreateNewBuildRequest(int configurationId, string[] targets
             return request;
         }
 
-        private void VerifyEngineStatus(BuildRequestEngineStatus expectedStatus)
+        private void VerifyEngineStatus(BuildRequestEngineStatus expectedStatus, bool isNotKickedOff = false)
         {
             IBuildRequestEngine engine = (IBuildRequestEngine)_host.GetComponent(BuildComponentType.RequestEngine);
 
-            if (engine.Status == expectedStatus)
+            if (isNotKickedOff && engine.Status == expectedStatus)
             {
                 return;
             }
diff --git a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
index 7ac75e98903..da450fb9228 100644
--- a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
@@ -46,7 +46,7 @@ public void GetandSetLoggerParameters()
         }
 
         /// <summary>
-        /// Verify the correct exception is thrown when the logger is initialized with a null 
+        /// Verify the correct exception is thrown when the logger is initialized with a null
         /// event source.
         /// </summary>
         [Fact]
@@ -59,7 +59,7 @@ public void InitializeWithNullEventSourceILogger()
             });
         }
         /// <summary>
-        /// Verify the correct exception is thrown when the logger is initialized with a null 
+        /// Verify the correct exception is thrown when the logger is initialized with a null
         /// event source.
         /// </summary>
         [Fact]
@@ -123,7 +123,7 @@ public void RaiseEventWithNoBuildEventRedirector()
 
         /// <summary>
         /// Create a new forwarding logger, event redirector, and event source.
-        /// The returned event source can then have and event raised on it and it can 
+        /// The returned event source can then have and event raised on it and it can
         /// check to see if the event raised matches the one we were expecting.
         /// </summary>
         /// <param name="buildEventToCheck">A build event we are expecting to be forwarded by the forwarding logger</param>
@@ -139,8 +139,8 @@ private static EventSourceSink AttachForwardingLoggerAndRedirector(BuildEventArg
         }
 
         /// <summary>
-        /// An event redirector which takes in an expected event 
-        /// and when the forwarding logger forwards and event 
+        /// An event redirector which takes in an expected event
+        /// and when the forwarding logger forwards and event
         /// we check to see if the events match. This allows
         /// us to check to see if the forwarding logger is
         /// sending us the events we send in.
@@ -150,8 +150,8 @@ private sealed class TestEventRedirector : IEventRedirector
             #region Data
 
             /// <summary>
-            /// Event we expect to see in the ForwardEvent method. 
-            /// This helps us verify that a logger is correctly forwarding 
+            /// Event we expect to see in the ForwardEvent method.
+            /// This helps us verify that a logger is correctly forwarding
             /// an event.
             /// </summary>
             private BuildEventArgs _expectedEvent;
diff --git a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
index 62f2cef2033..d36c7ee0667 100644
--- a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
@@ -28,7 +28,7 @@ public void TestConstructorNegativeLoggerId()
             });
         }
         /// <summary>
-        /// Verify the correct exception is thrown when the logger is initialized with a null 
+        /// Verify the correct exception is thrown when the logger is initialized with a null
         /// event source.
         /// </summary>
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index 9c1ef800dc6..2d1a262034a 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -31,7 +31,7 @@ public void PropertyGroup()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -179,7 +179,7 @@ public void PropertyGroupWithConditionOnGroup()
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup Condition='false'> 
+                <PropertyGroup Condition='false'>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -194,7 +194,7 @@ public void PropertyGroupWithConditionOnGroup()
             p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup Condition='true'> 
+                <PropertyGroup Condition='true'>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -230,7 +230,7 @@ public void ItemGroup()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -274,7 +274,7 @@ public void ItemKeepDuplicatesEmptySameAsTrue()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i1 Include='a1' KeepDuplicates='' />
                 </ItemGroup>
@@ -294,7 +294,7 @@ public void ItemKeepDuplicatesFalse()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i1 Include='a1' KeepDuplicates='false' />
                 </ItemGroup>
@@ -314,7 +314,7 @@ public void ItemKeepDuplicatesAsCondition()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i1 Include='a1' KeepDuplicates="" '$(Keep)' == 'true' "" />
                 </ItemGroup>
@@ -334,9 +334,9 @@ public void ItemKeepDuplicatesFalseKeepsExistingDuplicates()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
+                    <i1 Include='a1'/>
                     <i1 Include='a1'/>
-                    <i1 Include='a1'/>              
                     <i1 Include='a1' KeepDuplicates='false' />
                 </ItemGroup>
             </Target>
@@ -355,9 +355,9 @@ public void ItemKeepDuplicatesFalseDuringCopyEliminatesDuplicates()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
+                    <i1 Include='a1'/>
                     <i1 Include='a1'/>
-                    <i1 Include='a1'/>              
                     <i2 Include='@(i1)' KeepDuplicates='false' />
                 </ItemGroup>
             </Target>
@@ -379,8 +379,8 @@ public void ItemKeepDuplicatesFalseWithMetadata()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                     </i1>
                     <i1 Include='a2' KeepDuplicates='false' />
@@ -404,8 +404,8 @@ public void ItemKeepMetadataEmptySameAsKeepAll()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                     </i1>
                     <i2 Include='@(i1)' KeepMetadata='' />
@@ -426,8 +426,8 @@ public void ItemKeepMetadata()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -453,8 +453,8 @@ public void ItemKeepMetadataNotExistent()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -479,8 +479,8 @@ public void ItemKeepMetadataList()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -505,8 +505,8 @@ public void ItemKeepMetadataListExpansion()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -534,8 +534,8 @@ public void ItemRemoveMetadataEmptySameAsKeepAll()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                     </i1>
                     <i2 Include='@(i1)' RemoveMetadata='' />
@@ -556,8 +556,8 @@ public void ItemRemoveMetadata()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -582,8 +582,8 @@ public void ItemRemoveMetadataList()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -608,8 +608,8 @@ public void ItemRemoveMetadataListExpansion()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -639,8 +639,8 @@ public void ItemKeepMetadataAndRemoveMetadataMutuallyExclusive()
                 string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
-                    <i1 Include='a1'>              
+                <ItemGroup>
+                    <i1 Include='a1'>
                       <m1>m1</m1>
                       <m2>m2</m2>
                       <m3>m3</m3>
@@ -663,7 +663,7 @@ public void ItemGroupWithPropertyExpandingToNothing()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='$(xxx)'/>
                 </ItemGroup>
             </Target>
@@ -709,7 +709,7 @@ public void ItemGroupTrims()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='  $(p0)  '/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -782,7 +782,7 @@ public void ItemGroupWithTransform()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a.cpp'/>
                     <i2 Include=""@(i1->'%(filename).obj')""/>
                 </ItemGroup>
@@ -804,7 +804,7 @@ public void ItemGroupWithTransformInMetadataValue()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a.cpp'/>
                     <i2 Include='@(i1)'>
                        <m>@(i1->'%(filename).obj')</m>
@@ -827,7 +827,7 @@ public void ItemGroupWithExclude()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i2 Include='a1;@(i1);b1;b2' Exclude='@(i1);b1'/>
                 </ItemGroup>
@@ -849,7 +849,7 @@ public void ItemGroupWithMetadataInExclude()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>a1</m>
                     </i1>
@@ -876,7 +876,7 @@ public void ItemGroupWithConditionOnGroup()
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup Condition='false'> 
+                <ItemGroup Condition='false'>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -891,7 +891,7 @@ public void ItemGroupWithConditionOnGroup()
             p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup Condition='true'> 
+                <ItemGroup Condition='true'>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -932,7 +932,7 @@ public void PropertyGroupWithExternalPropertyReferences()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>$(p0)</p1>
                 </PropertyGroup>
             </Target>
@@ -955,7 +955,7 @@ public void ItemGroupWithPropertyReferences()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='$(p0)'/>
                     <i2 Include='a2'/>
                 </ItemGroup>
@@ -978,7 +978,7 @@ public void ItemGroupWithMetadataReferences()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>m1</m>
                     </i1>
@@ -1011,7 +1011,7 @@ public void ItemGroupWithMetadataReferencesOnMetadataConditions()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>m1</m>
                     </i1>
@@ -1070,7 +1070,7 @@ public void ItemGroupWithExternalMetadataReferences()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='b1'>
                         <m>%(i0.m)</m>
                     </i1>
@@ -1103,7 +1103,7 @@ public void PropertyGroupWithCumulativePropertyReferences()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>v1</p1>
                     <p2>#$(p1)#</p2>
                     <p1>v2</p1>
@@ -1155,7 +1155,7 @@ public void PropertyGroupWithMetadataReferencesOnProperty()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1 Condition=""'%(i0.n)' != n3"">%(i0.n)</p1>
                 </PropertyGroup>
             </Target></Project>");
@@ -1199,7 +1199,7 @@ public void ItemsCanReferencePropertiesInSameTarget()
                     <PropertyGroup>
                         <p0>v0</p0>
                     </PropertyGroup>
-                    <ItemGroup> 
+                    <ItemGroup>
                         <i1 Include='$(p0)'/>
                     </ItemGroup>
                     <Message Text='[@(i1)]'/>
@@ -1306,7 +1306,7 @@ public void PropertiesVisibleToSubsequentTarget()
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                   <Target Name='t2' DependsOnTargets='t'>
-                    <Message Text='[$(p)]'/>                    
+                    <Message Text='[$(p)]'/>
                   </Target>
                   <Target Name='t'>
                     <PropertyGroup>
@@ -1346,7 +1346,7 @@ public void ItemsVisibleToSubsequentTarget()
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                   <Target Name='t2' DependsOnTargets='t'>
-                    <Message Text='[@(i)]'/>                    
+                    <Message Text='[@(i)]'/>
                   </Target>
                   <Target Name='t'>
                     <ItemGroup>
@@ -1369,13 +1369,13 @@ public void ItemsNotVisibleToParallelTargetBatches()
                   <ItemGroup>
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <Message Text='start:[@(i)]'/>
                     <ItemGroup>
                       <j Include='%(i.identity)'/>
                     </ItemGroup>
-                    <Message Text='end:[@(j)]'/>                    
+                    <Message Text='end:[@(j)]'/>
                 </Target>
                 </Project>
             "))));
@@ -1556,7 +1556,7 @@ public void IncludeNoOp()
                 string content = ObjectModelHelpers.CleanupFileContents(
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include=''/>
                 </ItemGroup>
             </Target></Project>");
@@ -1570,7 +1570,7 @@ public void RemoveNoOp()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Remove='a1'/>
                 </ItemGroup>
             </Target></Project>");
@@ -1588,7 +1588,7 @@ public void RemoveItemInTarget()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
+                    <i1 Include='a1'/>
                     <i1 Remove='a1'/>
                 </ItemGroup>
             </Target></Project>");
@@ -1613,7 +1613,7 @@ public void RemoveOfItemAddedInTargetByParallelTargetBatchDoesNothing()
                     <!-- just to cause two target batches -->
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <ItemGroup>
                       <j Include='a' Condition=""'%(i.Identity)'=='1.in'""/>
@@ -1650,7 +1650,7 @@ public void RemoveItemInTargetWithTransform()
             <Target Name='t'>
                 <ItemGroup>
                     <i0 Include='a.cpp;b.cpp'/>
-                    <i1 Include='a.obj;b.obj'/> 
+                    <i1 Include='a.obj;b.obj'/>
                     <i1 Remove=""@(i0->'%(filename).obj')""/>
                 </ItemGroup>
             </Target></Project>");
@@ -1668,8 +1668,8 @@ public void RemoveWithMultipleIncludes()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
-                    <i1 Include='a2'/> 
+                    <i1 Include='a1'/>
+                    <i1 Include='a2'/>
                     <i1 Remove='a1;a2'/>
                 </ItemGroup>
             </Target></Project>");
@@ -1687,8 +1687,8 @@ public void RemoveAllItemsInList()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
-                    <i1 Include='a2'/> 
+                    <i1 Include='a1'/>
+                    <i1 Include='a2'/>
                     <i1 Remove='@(i1)'/>
                 </ItemGroup>
             </Target></Project>");
@@ -2204,7 +2204,7 @@ public void RegressPCHBug()
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                   <!-- squint and pretend i0 is 'CppCompile' and 'm' is 'ObjectFile' -->
                   <Link Include=""A_PCH""/>
                   <Link Include=""@(i0->'%(m).obj')"" Condition=""'%(i0.m)' == 'm1'""/>
@@ -2336,13 +2336,13 @@ public void RemovesOfPersistedItemsAreReversed3()
                   <ItemGroup>
                     <i0 Include='a1'>
                       <m>m1</m>
-                    </i0> 
+                    </i0>
                   </ItemGroup>
                   <Target Name='t'>
                     <ItemGroup>
                       <i0 Include='a1'>
                         <m>m2</m>
-                      </i0> 
+                      </i0>
                       <i0 Remove='a1'/>
                     </ItemGroup>
                     <Message Text='[%(i0.m)]'/>
@@ -2409,13 +2409,13 @@ public void RemovesOfItemsOnlyWithMetadataValue()
                   <ItemGroup>
                     <i0 Include='a1'>
                       <m>m1</m>
-                    </i0> 
+                    </i0>
                   </ItemGroup>
                   <Target Name='t'>
                     <ItemGroup>
                       <i0 Include='a1'>
                         <m>m2</m>
-                      </i0> 
+                      </i0>
                       <i0 Remove='a1' Condition=""'%(i0.m)' == 'm1'""/>
                     </ItemGroup>
                     <Message Text='[%(i0.m)]'/>
@@ -2497,13 +2497,13 @@ public void RemovesNotVisibleToParallelTargetBatches()
                   <ItemGroup>
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <Message Text='start:[@(i)]'/>
                     <ItemGroup>
                       <i Remove='1.in;2.in'/>
                     </ItemGroup>
-                    <Message Text='end:[@(i)]'/>                    
+                    <Message Text='end:[@(i)]'/>
                 </Target>
                 </Project>
             "))));
@@ -2522,13 +2522,13 @@ public void RemovesNotVisibleToParallelTargetBatches2()
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
                     <j Include='j1'/>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <Message Text='start:[@(j)]'/>
                     <ItemGroup>
                       <j Remove='@(j)'/>
                     </ItemGroup>
-                    <Message Text='end:[@(j)]'/>                    
+                    <Message Text='end:[@(j)]'/>
                 </Target>
                 </Project>
             "))));
@@ -2758,7 +2758,7 @@ public void ModifyNoOp()
             string content = ObjectModelHelpers.CleanupFileContents(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1/>
                 </ItemGroup>
             </Target></Project>");
@@ -2776,7 +2776,7 @@ public void ModifyItemInTarget()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
                     <i1>
@@ -2831,7 +2831,7 @@ public void ModifyItemInTargetLastMetadataWins()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
                     <i1>
@@ -2880,10 +2880,10 @@ public void ModifyItemInTargetWithCondition()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1 Condition=""'%(i1.m)'=='m2'"">
@@ -2910,10 +2910,10 @@ public void ModifyItemInTargetWithConditionOnMetadata()
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1>
@@ -2959,10 +2959,10 @@ public void ModifyItemInTargetWithConditionWithoutItemTypeOnMetadataInCondition(
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1 Condition=""'%(m)'=='m2'"">
@@ -2990,10 +2990,10 @@ public void ModifyItemInTargetWithConditionOnMetadataWithoutItemTypeOnMetadataIn
             @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
             <Target Name='t'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1>
@@ -3119,7 +3119,7 @@ public void ModifiesOfPersistedItemsAreReversed1()
                     <ItemGroup>
                       <i0>
                         <m>m1</m>
-                      </i0> 
+                      </i0>
                     </ItemGroup>
                   </Target>
                   <Target Name='t2'>
@@ -3163,7 +3163,7 @@ public void ModifiesOfPersistedItemsAreReversed2()
                       </i1>
                       <i1>
                         <n>n1</n>
-                      </i1> 
+                      </i1>
                     </ItemGroup>
                   </Target>
                   <Target Name='t2'>
@@ -3391,7 +3391,7 @@ public void OutputPropertiesInTargetBatchesCreateItem()
                     <!-- just to cause two target batches -->
                     <i Include='1.in'><output>1.out</output></i>
                     <i Include='2.in'><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name='t' Inputs='%(i.Identity)' Outputs='%(i.output)'>
                     <Message Text='start:[$(p)]'/>
                     <CreateProperty Value='$(p)--%(i.Identity)'>
@@ -3448,7 +3448,7 @@ public void PhoenixBatchingIssue()
                         <ObjectFile>def.obj</ObjectFile>
                     </CppCompile>
                 </ItemGroup>
-                
+
                 <Target Name='t'>
                     <ItemGroup>
                         <CppCompile>
@@ -3524,7 +3524,7 @@ public void ModifyItemPreviouslyModified()
                       </x>
                       <x>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text='[%(x.m1)]'/>
                   </Target>
@@ -3554,7 +3554,7 @@ public void ModifyItemPreviouslyModified2()
                     <ItemGroup>
                       <x>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text='[%(x.m1)]'/>
                   </Target>
diff --git a/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
index 3b7b1987f96..cfbf63deebd 100644
--- a/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
@@ -49,8 +49,7 @@ public void BuildTelemetryConstructedHasNoProperties()
         buildTelemetry.Target.ShouldBeNull();
         buildTelemetry.Version.ShouldBeNull();
 
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
     }
 
     [Fact]
@@ -75,22 +74,23 @@ public void BuildTelemetryCreateProperProperties()
         buildTelemetry.Target = "clean";
         buildTelemetry.Version = new Version(1, 2, 3, 4);
 
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.Count.ShouldBe(11);
+        var properties = buildTelemetry.GetProperties();
 
-        buildTelemetry.Properties["BuildEngineDisplayVersion"].ShouldBe("Some Display Version");
-        buildTelemetry.Properties["BuildEngineFrameworkName"].ShouldBe("new .NET");
-        buildTelemetry.Properties["BuildEngineHost"].ShouldBe("Host description");
-        buildTelemetry.Properties["InitialMSBuildServerState"].ShouldBe("hot");
-        buildTelemetry.Properties["ProjectPath"].ShouldBe(@"C:\\dev\\theProject");
-        buildTelemetry.Properties["ServerFallbackReason"].ShouldBe("busy");
-        buildTelemetry.Properties["BuildSuccess"].ShouldBe("True");
-        buildTelemetry.Properties["BuildTarget"].ShouldBe("clean");
-        buildTelemetry.Properties["BuildEngineVersion"].ShouldBe("1.2.3.4");
+        properties.Count.ShouldBe(11);
+
+        properties["BuildEngineDisplayVersion"].ShouldBe("Some Display Version");
+        properties["BuildEngineFrameworkName"].ShouldBe("new .NET");
+        properties["BuildEngineHost"].ShouldBe("Host description");
+        properties["InitialMSBuildServerState"].ShouldBe("hot");
+        properties["ProjectPath"].ShouldBe(@"C:\\dev\\theProject");
+        properties["ServerFallbackReason"].ShouldBe("busy");
+        properties["BuildSuccess"].ShouldBe("True");
+        properties["BuildTarget"].ShouldBe("clean");
+        properties["BuildEngineVersion"].ShouldBe("1.2.3.4");
 
         // verify computed
-        buildTelemetry.Properties["BuildDurationInMilliseconds"] = (finishedAt - startAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
-        buildTelemetry.Properties["InnerBuildDurationInMilliseconds"] = (finishedAt - innerStartAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+        properties["BuildDurationInMilliseconds"] = (finishedAt - startAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+        properties["InnerBuildDurationInMilliseconds"] = (finishedAt - innerStartAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
     }
 
     [Fact]
@@ -100,22 +100,18 @@ public void BuildTelemetryHandleNullsInRecordedTimes()
 
         buildTelemetry.StartAt = DateTime.MinValue;
         buildTelemetry.FinishedAt = null;
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
 
         buildTelemetry.StartAt = null;
         buildTelemetry.FinishedAt = DateTime.MaxValue;
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
 
         buildTelemetry.InnerStartAt = DateTime.MinValue;
         buildTelemetry.FinishedAt = null;
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
 
         buildTelemetry.InnerStartAt = null;
         buildTelemetry.FinishedAt = DateTime.MaxValue;
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
index 27b30d71997..d6e66cc6ecd 100644
--- a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
@@ -40,8 +40,7 @@ public void BuildTelemetryConstructedHasNoProperties()
         telemetry.BinaryLogger.ShouldBe(false);
         telemetry.BinaryLoggerUsedDefaultName.ShouldBe(false);
 
-        telemetry.UpdateEventProperties();
-        telemetry.Properties.Where(kv => kv.Value != bool.FalseString).ShouldBeEmpty();
+        telemetry.GetProperties().Where(kv => kv.Value != bool.FalseString).ShouldBeEmpty();
     }
 
     [Fact]
@@ -65,21 +64,20 @@ public void BuildTelemetryCreateProperProperties()
             BinaryLoggerUsedDefaultName = true
         };
 
-        telemetry.UpdateEventProperties();
-
-        telemetry.Properties["TerminalLogger"].ShouldBe(bool.TrueString);
-        telemetry.Properties["TerminalLoggerUserIntent"].ShouldBe("on");
-        telemetry.Properties["TerminalLoggerUserIntentSource"].ShouldBe("arg");
-        telemetry.Properties["TerminalLoggerDefault"].ShouldBe("auto");
-        telemetry.Properties["TerminalLoggerDefaultSource"].ShouldBe("sdk");
-        telemetry.Properties["ConsoleLogger"].ShouldBe(bool.TrueString);
-        telemetry.Properties["ConsoleLoggerType"].ShouldBe("serial");
-        telemetry.Properties["ConsoleLoggerVerbosity"].ShouldBe("minimal");
-        telemetry.Properties["FileLogger"].ShouldBe(bool.TrueString);
-        telemetry.Properties["FileLoggerType"].ShouldBe("serial");
-        telemetry.Properties["FileLoggersCount"].ShouldBe("2");
-        telemetry.Properties["FileLoggerVerbosity"].ShouldBe("normal");
-        telemetry.Properties["BinaryLogger"].ShouldBe(bool.TrueString);
-        telemetry.Properties["BinaryLoggerUsedDefaultName"].ShouldBe(bool.TrueString);
+        var properties = telemetry.GetProperties();
+        properties["TerminalLogger"].ShouldBe(bool.TrueString);
+        properties["TerminalLoggerUserIntent"].ShouldBe("on");
+        properties["TerminalLoggerUserIntentSource"].ShouldBe("arg");
+        properties["TerminalLoggerDefault"].ShouldBe("auto");
+        properties["TerminalLoggerDefaultSource"].ShouldBe("sdk");
+        properties["ConsoleLogger"].ShouldBe(bool.TrueString);
+        properties["ConsoleLoggerType"].ShouldBe("serial");
+        properties["ConsoleLoggerVerbosity"].ShouldBe("minimal");
+        properties["FileLogger"].ShouldBe(bool.TrueString);
+        properties["FileLoggerType"].ShouldBe("serial");
+        properties["FileLoggersCount"].ShouldBe("2");
+        properties["FileLoggerVerbosity"].ShouldBe("normal");
+        properties["BinaryLogger"].ShouldBe(bool.TrueString);
+        properties["BinaryLoggerUsedDefaultName"].ShouldBe(bool.TrueString);
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
index becd57ad8dc..9ee0264517d 100644
--- a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
@@ -95,7 +95,7 @@ public void AddsAreCombinedWithPopulates()
             // Start a target
             Lookup.Scope enteredScope = lookup.EnterScope("x");
 
-            // We see the one item 
+            // We see the one item
             Assert.Equal("a1", lookup.GetItems("i1").First().EvaluatedInclude);
             Assert.Single(lookup.GetItems("i1"));
 
@@ -163,7 +163,7 @@ public void AddsWithDuplicateRemovalItemSpecsOnly()
             ProjectItemInstance[] newItems = new ProjectItemInstance[]
             {
                 new ProjectItemInstance(project, "i1", "a1", project.FullPath), // Should not get added
-                new ProjectItemInstance(project, "i1", "a2", project.FullPath), // Should get added               
+                new ProjectItemInstance(project, "i1", "a2", project.FullPath), // Should get added
             };
 
             // Perform the addition
@@ -213,9 +213,9 @@ public void AddsWithDuplicateRemovalWithMetadata()
             ProjectItemInstance[] newItems = new ProjectItemInstance[]
             {
                 new ProjectItemInstance(project, "i1", "a1", project.FullPath), // Should get added
-                new ProjectItemInstance(project, "i1", "a2", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m1") }, project.FullPath), // Should get added               
-                new ProjectItemInstance(project, "i1", "a1", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m1") }, project.FullPath), // Should not get added               
-                new ProjectItemInstance(project, "i1", "a1", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m3") }, project.FullPath), // Should get added               
+                new ProjectItemInstance(project, "i1", "a2", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m1") }, project.FullPath), // Should get added
+                new ProjectItemInstance(project, "i1", "a1", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m1") }, project.FullPath), // Should not get added
+                new ProjectItemInstance(project, "i1", "a1", new KeyValuePair<string, string>[] { new KeyValuePair<string, string>( "m1", "m3") }, project.FullPath), // Should get added
             };
 
             // Perform the addition
@@ -822,7 +822,7 @@ public void ModifyItemModifiedInPreviousScope()
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -863,7 +863,7 @@ public void ModifyItemTwiceInSameScope1()
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -929,7 +929,7 @@ public void ModifyItemTwiceInSameScope2()
             Assert.Equal("n2", foundGroup.First().GetMetadataValue("n"));
             Assert.Equal("o1", foundGroup.First().GetMetadataValue("o"));
 
-            // Make a modification to the item to be n=n3 
+            // Make a modification to the item to be n=n3
             newMetadata = new Lookup.MetadataModifications(keepOnlySpecified: false);
             newMetadata.Add("n", "n3");
             lookup.ModifyItems("i1", group, newMetadata);
@@ -1026,7 +1026,7 @@ public void ModifyItemPreviouslyModifiedAndGottenThroughGetItem()
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -1074,7 +1074,7 @@ public void ModifyItemPreviouslyModifiedAndGottenThroughGetItem()
         public void ModifyItemInProjectPreviouslyModifiedAndGottenThroughGetItem()
         {
             ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
-            // Create some project state with an item with m=m1 and n=n1 
+            // Create some project state with an item with m=m1 and n=n1
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
@@ -1130,7 +1130,7 @@ public void RemoveItemPreviouslyModifiedAndGottenThroughGetItem()
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -1164,7 +1164,7 @@ public void RemoveItemPreviouslyModifiedAndGottenThroughGetItem()
         public void RemoveItemFromProjectPreviouslyModifiedAndGottenThroughGetItem()
         {
             ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
-            // Create some project state with an item with m=m1 and n=n1 
+            // Create some project state with an item with m=m1 and n=n1
             ItemDictionary<ProjectItemInstance> table1 = new ItemDictionary<ProjectItemInstance>();
             ProjectItemInstance item1 = new ProjectItemInstance(project, "i1", "a2", project.FullPath);
             item1.SetMetadata("m", "m1");
@@ -1257,7 +1257,7 @@ public void ModifiedProperty()
 
             Lookup.Scope enteredScope2 = lookup.EnterScope("x");
 
-            // Change the value again in the new scope 
+            // Change the value again in the new scope
             lookup.SetProperty(ProjectPropertyInstance.Create("p1", "v3"));
 
             // Lookup is updated, but not the original item group
@@ -1266,7 +1266,7 @@ public void ModifiedProperty()
 
             Lookup.Scope enteredScope3 = lookup.EnterScope("x");
 
-            // Change the value again in the new scope 
+            // Change the value again in the new scope
             lookup.SetProperty(ProjectPropertyInstance.Create("p1", "v4"));
 
             Assert.Equal("v4", lookup.GetProperty("p1").EvaluatedValue);
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 689e35e5e06..fcf12777aec 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -170,7 +170,7 @@ public void OutputItemsAreTaggedWithProjectFileAndTargetName()
         }
 
         /// <summary>
-        /// Ensures that it is possible to call the MSBuild task with an empty Projects parameter, and it 
+        /// Ensures that it is possible to call the MSBuild task with an empty Projects parameter, and it
         /// shouldn't error, and it shouldn't try to build itself.
         /// </summary>
         [Fact]
@@ -480,7 +480,7 @@ static void Main(string[] args)
             // -------------------------------------------------------
             // TeamBuild.proj
             // -------------------------------------------------------
-            // Attempts to build the above ConsoleApplication1.csproj by calling the MSBuild task, 
+            // Attempts to build the above ConsoleApplication1.csproj by calling the MSBuild task,
             // and overriding the OutDir property.  However, the value being passed into OutDir
             // is coming from another property which is produced by CreateProperty and has
             // some special characters in it.
@@ -489,16 +489,16 @@ static void Main(string[] args)
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <Target Name=`Build`>
-                    
+
                         <CreateProperty Value=`$(MSBuildProjectDirectory)\binaries\`>
                             <Output PropertyName=`MasterOutDir` TaskParameter=`Value`/>
                         </CreateProperty>
-                        
+
                         <MSBuild Projects=`ConsoleApplication1\ConsoleApplication1.csproj`
                                  Properties=`OutDir=$(MasterOutDir)`
                                  Targets=`Rebuild`/>
                     </Target>
-                    
+
                 </Project>
                 ");
 
@@ -520,7 +520,7 @@ public void DifferentGlobalPropertiesWithDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -589,7 +589,7 @@ public void DifferentGlobalPropertiesWithoutDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -664,7 +664,7 @@ public void VariousPropertiesToMSBuildTask()
                           <UndefineProperties>g;h;</UndefineProperties>
                         </PR>
                       </ItemGroup>
-                      <Target Name='a'> 
+                      <Target Name='a'>
                         <MSBuild Projects='@(PR)' Properties='c=c;d=d;' RemoveProperties='i;c;' Targets='b'/>
                       </Target>
                       <Target Name='b'>
@@ -896,7 +896,7 @@ public void DifferentGlobalPropertiesWithBlanks()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -963,7 +963,7 @@ public void DifferentGlobalPropertiesInvalid()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyProp)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyProp)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1018,7 +1018,7 @@ public void DifferentAdditionalPropertiesWithDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='1'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1085,7 +1085,7 @@ public void DifferentAdditionalPropertiesWithGlobalProperties()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='0'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1154,7 +1154,7 @@ public void DifferentAdditionalPropertiesWithoutDefault()
 
                     <Target Name=`TargetA` Outputs=`a1.dll` Condition=`'$(MyPropG)'=='1'`/>
                     <Target Name=`TargetB` Outputs=`b1.dll` Condition=`'$(MyPropA)'=='1'`/>
-                   
+
                 </Project>
                 ");
 
@@ -1231,7 +1231,7 @@ public void TargetsWithSeparationChars()
                     <ItemGroup>
                         <ProjectFile Include=`" + projectFile1 + @"` />
                     </ItemGroup>
-                   
+
                     <Target Name=`Build` Outputs=`$(SomeOutputs)`>
                         <MSBuild Projects=`@(ProjectFile)` Targets=`$(Targets)` TargetAndPropertyListSeparators=`%3B;%3C` />
                     </Target>
@@ -1296,14 +1296,14 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
                     new TaskItem(project1), new TaskItem(project2)
                 };
 
-                // Test the various combinations of BuildInParallel and StopOnFirstFailure when the msbuild task is told there are not multiple nodes 
+                // Test the various combinations of BuildInParallel and StopOnFirstFailure when the msbuild task is told there are not multiple nodes
                 // running in the system
                 for (int i = 0; i < 4; i++)
                 {
                     bool buildInParallel = false;
                     bool stopOnFirstFailure = false;
 
-                    // first set up the project being built. 
+                    // first set up the project being built.
                     switch (i)
                     {
                         case 0:
@@ -1344,7 +1344,7 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
                     switch (i)
                     {
                         case 0:
-                            // Verify setting BuildInParallel and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel and StopOnFirstFailure to
                             // true will cause the msbuild task to set BuildInParallel to false during the execute
                             // Verify build did not build second project which has the message SecondProject
                             logger.AssertLogDoesntContain("SecondProject");
@@ -1354,7 +1354,7 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
                             logger.AssertLogContains(AssemblyResources.GetString("MSBuild.NotBuildingInParallel"));
                             break;
                         case 1:
-                            // Verify setting BuildInParallel to true and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to true and StopOnFirstFailure to
                             // false will cause no change in BuildInParallel
                             // Verify build did  build second project which has the message SecondProject
                             logger.AssertLogContains("SecondProject");
@@ -1373,7 +1373,7 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
                             break;
 
                         case 3:
-                            // Verify setting BuildInParallel to false and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to false and StopOnFirstFailure to
                             // false will cause no change in BuildInParallel
                             // Verify build did build second project which has the message SecondProject
                             logger.AssertLogContains("SecondProject");
@@ -1419,14 +1419,14 @@ public void StopOnFirstFailureandBuildInParallelMultipleNode()
 
             try
             {
-                // Test the various combinations of BuildInParallel and StopOnFirstFailure when the msbuild task is told there are multiple nodes 
+                // Test the various combinations of BuildInParallel and StopOnFirstFailure when the msbuild task is told there are multiple nodes
                 // running in the system
                 for (int i = 0; i < 4; i++)
                 {
                     bool buildInParallel = false;
                     bool stopOnFirstFailure = false;
 
-                    // first set up the project being built. 
+                    // first set up the project being built.
                     switch (i)
                     {
                         case 0:
@@ -1476,7 +1476,7 @@ public void StopOnFirstFailureandBuildInParallelMultipleNode()
                             logger.AssertLogDoesntContain(AssemblyResources.GetString("MSBuild.NotBuildingInParallel"));
                             break;
                         case 1:
-                            // Verify setting BuildInParallel to true and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to true and StopOnFirstFailure to
                             // false will cause no change in BuildInParallel
                             // Verify build did build second project which has the message SecondProject
                             logger.AssertLogContains("SecondProject");
@@ -1486,7 +1486,7 @@ public void StopOnFirstFailureandBuildInParallelMultipleNode()
                             logger.AssertLogDoesntContain(AssemblyResources.GetString("MSBuild.NotBuildingInParallel"));
                             break;
                         case 2:
-                            // Verify setting BuildInParallel to false and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to false and StopOnFirstFailure to
                             // true will cause no change in BuildInParallel
                             // Verify build did not build second project which has the message SecondProject
                             logger.AssertLogDoesntContain("SecondProject");
@@ -1497,7 +1497,7 @@ public void StopOnFirstFailureandBuildInParallelMultipleNode()
                             break;
 
                         case 3:
-                            // Verify setting BuildInParallel to false and StopOnFirstFailure to 
+                            // Verify setting BuildInParallel to false and StopOnFirstFailure to
                             // false will cause no change in BuildInParallel
                             // Verify build did build second project which has the message SecondProject
                             logger.AssertLogContains("SecondProject");
@@ -1771,12 +1771,12 @@ public void PropertiesWithSeparationChars()
                             <AdditionalProperties>C=$(CValues)%3BD=$(DValues)</AdditionalProperties>
                         </ProjectFile>
                     </ItemGroup>
-                   
+
                     <Target Name=`Build` Outputs=`$(SomeOutputs)`>
                         <MSBuild Projects=`@(ProjectFile)` Targets=`Build` Properties=`a=$(AValues)%3Bb=$(BValues)` TargetAndPropertyListSeparators=`%3B`>
                             <Output TaskParameter=`TargetOutputs` PropertyName=`SomeOutputs`/>
                         </MSBuild>
-                    </Target>	
+                    </Target>
                 </Project>
                 ");
 
@@ -1836,13 +1836,13 @@ public void TargetNameIsCaseInsensitive()
                 ");
 
             string projectFile2 = ObjectModelHelpers.CreateTempFileOnDisk(@"
-                <Project DefaultTargets=`t` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>                  
+                <Project DefaultTargets=`t` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <Target Name=`t`>
                         <MSBuild Projects=`" + projectFile1 + @"` Targets=`BUILD`>
                             <Output TaskParameter=`TargetOutputs` ItemName=`out`/>
                         </MSBuild>
                         <Message Text=`[@(out)]`/>
-                    </Target>	
+                    </Target>
                 </Project>
                 ");
 
@@ -1872,13 +1872,13 @@ public void ProjectFileWithoutNamespaceBuilds()
                 ");
 
             string projectFile2 = ObjectModelHelpers.CreateTempFileOnDisk(@"
-                <Project>                  
+                <Project>
                     <Target Name=`t`>
                         <MSBuild Projects=`" + projectFile1 + @"` Targets=`Build`>
                             <Output TaskParameter=`TargetOutputs` ItemName=`out`/>
                         </MSBuild>
                         <Message Text=`[@(out)]`/>
-                    </Target>	
+                    </Target>
                 </Project>
                 ");
 
diff --git a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
new file mode 100644
index 00000000000..aeddc3281eb
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
@@ -0,0 +1,59 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Logging;
+using Microsoft.Build.UnitTests.BackEnd;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Engine.UnitTests.BackEnd
+{
+    public class NodeConfiguration_Tests
+    {
+#if FEATURE_APPDOMAIN
+        /// <summary>
+        /// Test serialization / deserialization of the AppDomainSetup instance.
+        /// </summary>
+        [Theory]
+        [InlineData(new byte[] { 1, 2, 3 })]
+        [InlineData(null)]
+        public void TestTranslationWithAppDomainSetup(byte[] configBytes)
+        {
+            AppDomainSetup setup = new AppDomainSetup();
+
+            NodeConfiguration config = new NodeConfiguration(
+                nodeId: 1,
+                buildParameters: new BuildParameters(),
+                forwardingLoggers: Array.Empty<LoggerDescription>(),
+                appDomainSetup: setup,
+                loggingNodeConfiguration: new LoggingNodeConfiguration());
+
+            setup.SetConfigurationBytes(configBytes);
+
+            ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = NodeConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            packet.ShouldBeOfType<NodeConfiguration>();
+            NodeConfiguration deserializedConfig = (NodeConfiguration)packet;
+
+            deserializedConfig.AppDomainSetup.ShouldNotBeNull();
+
+            if (configBytes is null)
+            {
+                deserializedConfig.AppDomainSetup.GetConfigurationBytes().ShouldBeNull();
+            }
+            else
+            {
+                deserializedConfig.AppDomainSetup.GetConfigurationBytes().SequenceEqual(configBytes).ShouldBeTrue();
+            }
+        }
+#endif
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 2d9699376c1..0649b96b566 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -17,7 +17,7 @@
 namespace Microsoft.Build.UnitTests.BackEnd
 {
     /// <summary>
-    /// Each packet is split up into a region, the region contains the tests for 
+    /// Each packet is split up into a region, the region contains the tests for
     /// a given packet type.
     /// </summary>
     public class NodePackets_Tests
@@ -67,6 +67,7 @@ public void VerifyEventType()
             ExtendedBuildMessageEventArgs extMessage = new("extMsg", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", MessageImportance.Normal);
             ExtendedCustomBuildEventArgs extCustom = new("extCustom", "message", "help", "sender");
             CriticalBuildMessageEventArgs criticalMessage = new("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "Sender", DateTime.Now, "arg1");
+            ExtendedCriticalBuildMessageEventArgs extCriticalMessage = new("extCritMsg", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "Sender", DateTime.Now, "arg1");
             PropertyInitialValueSetEventArgs propInit = new("prop", "val", "propsource", "message", "help", "sender", MessageImportance.Normal);
             MetaprojectGeneratedEventArgs metaProjectGenerated = new("metaName", "path", "message");
             PropertyReassignmentEventArgs propReassign = new("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal);
@@ -98,6 +99,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(extMessage, LoggingEventType.ExtendedBuildMessageEvent);
             VerifyLoggingPacket(extCustom, LoggingEventType.ExtendedCustomEvent);
             VerifyLoggingPacket(criticalMessage, LoggingEventType.CriticalBuildMessage);
+            VerifyLoggingPacket(extCriticalMessage, LoggingEventType.ExtendedCriticalBuildMessageEvent);
             VerifyLoggingPacket(propInit, LoggingEventType.PropertyInitialValueSet);
             VerifyLoggingPacket(metaProjectGenerated, LoggingEventType.MetaprojectGenerated);
             VerifyLoggingPacket(propReassign, LoggingEventType.PropertyReassignment);
@@ -299,6 +301,12 @@ public void TestTranslation()
                         ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
                         BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
                     },
+                    new ExtendedCriticalBuildMessageEventArgs("extCritMsg", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "Sender", DateTime.Now, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
                 };
                 foreach (BuildEventArgs arg in testArgs)
                 {
@@ -318,7 +326,7 @@ public void TestTranslation()
                         .RespectingRuntimeTypes()
                         // Since we use struct DictionaryEntry of class TaskItemData, generated DictionaryEntry.Equals compare TaskItemData by references.
                         // Bellow will instruct equivalency test to not use DictionaryEntry.Equals but its public members for equivalency tests.
-                        .ComparingByMembers<DictionaryEntry>() 
+                        .ComparingByMembers<DictionaryEntry>()
                         .WithTracing(), "Roundtrip deserialization of message type {0} should be equivalent", args.GetType().Name);
                 }
             }
@@ -329,7 +337,7 @@ public void TestTranslation()
         }
 
         /// <summary>
-        /// Verify the LoggingMessagePacket is properly created from a build event. 
+        /// Verify the LoggingMessagePacket is properly created from a build event.
         /// This includes the packet type and the event type depending on which build event arg is passed in.
         /// </summary>
         /// <param name="buildEvent">Build event to put into a packet, and verify after packet creation</param>
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index c82578b6e61..ac1f69f2f60 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -35,7 +35,7 @@ public void Basic()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -89,9 +89,9 @@ public void FailingTaskStillPublishesOutputs()
                     </root>");
 
                 Project project = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
-                    <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                    <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Target Name='Build'>
-                            
+
                             <GenerateResource
                                 ExecuteAsTool='false'
                                 Sources='" + resx + @"'
@@ -99,11 +99,11 @@ public void FailingTaskStillPublishesOutputs()
                                     <Output TaskParameter='FilesWritten' ItemName='FilesWrittenItem'/>
                                     <Output TaskParameter='FilesWritten' PropertyName='FilesWrittenProperty'/>
                             </GenerateResource>
-                                               
+
                             <OnError ExecuteTargets='ErrorTarget'/>
                         </Target>
 
-                        <Target Name='ErrorTarget'>    
+                        <Target Name='ErrorTarget'>
                             <Message Text='[@(fileswrittenitem)]'/>
                             <Message Text='[$(fileswrittenproperty)]'/>
                         </Target>
@@ -144,16 +144,16 @@ public void OnErrorSeesPropertiesAndItemsFromFirstTarget()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
 
                    <Target Name='Build'>
                       <!-- Create a bunch of items and properties -->
                       <CreateItem Include='a1'>
                         <Output ItemName='i1' TaskParameter='Include'/>
-                      </CreateItem> 
+                      </CreateItem>
                       <ItemGroup>
                         <i1 Include='a2'/>
-                      </ItemGroup> 
+                      </ItemGroup>
                       <CreateProperty Value='v1'>
                         <Output PropertyName='p1' TaskParameter='Value'/>
                       </CreateProperty>
@@ -188,7 +188,7 @@ public void TwoExecuteTargets()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -219,7 +219,7 @@ public void TwoOnErrorClauses()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -252,7 +252,7 @@ public void DependentTarget()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp' DependsOnTargets='CleanUp2'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -284,7 +284,7 @@ public void ErrorInChildIsHandledInParent()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -315,7 +315,7 @@ public void NonExistentExecuteTarget()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='Build'>
                       <Error Text='This is an error.'/>
                       <OnError ExecuteTargets='CleanUp'/>
@@ -339,7 +339,7 @@ public void TrueCondition()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -366,7 +366,7 @@ public void FalseCondition()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -394,7 +394,7 @@ public void PropertiesInExecuteTargets()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <PropertyGroup>
                      <Part1>Clean</Part1>
                      <Part2>Up</Part2>
@@ -426,7 +426,7 @@ public void ErrorTargetsContinueAfterErrorsInErrorHandler()
             MockLogger l = new MockLogger();
             Project p = new Project(XmlReader.Create(new StringReader(ObjectModelHelpers.CleanupFileContents(@"
 
-                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'> 
+                <Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                    <Target Name='CleanUp1'>
                       <Message Text='CleanUp1-was-called.'/>
                       <Error Text='Error in CleanUp1.'/>
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index 7bcca24e739..0dfff488ff0 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -166,7 +166,7 @@ public void TestRetrieveSubsetResults()
         }
 
         /// <summary>
-        /// If a result had multiple targets associated with it and we only requested some of their 
+        /// If a result had multiple targets associated with it and we only requested some of their
         /// results, the returned result should only contain the targets we asked for, and the overall
         /// status of the result should reflect the targets we asked for as well.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 52eb10a8b12..298987ef008 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -30,7 +30,6 @@ public class SdkResolverLoader_Tests
     {
         private readonly ITestOutputHelper _output;
         private readonly MockLogger _logger;
-        private readonly LoggingContext _loggingContext;
 
         public SdkResolverLoader_Tests(ITestOutputHelper output)
         {
@@ -38,10 +37,6 @@ public SdkResolverLoader_Tests(ITestOutputHelper output)
             _logger = new MockLogger(output);
             ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             loggingService.RegisterLogger(_logger);
-
-            _loggingContext = new MockLoggingContext(
-                loggingService,
-                new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
         }
 
         [Fact]
@@ -49,7 +44,7 @@ public void AssertDefaultLoaderReturnsDefaultResolvers()
         {
             var loader = new SdkResolverLoader();
 
-            var resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
+            var resolvers = loader.LoadAllResolvers(new MockElementLocation("file"));
 
             resolvers.Select(i => i.GetType().FullName).ShouldBe(new[] { typeof(DefaultSdkResolver).FullName });
 
@@ -131,7 +126,7 @@ public void VerifyThrowsWhenResolverFailsToLoad()
         {
             SdkResolverLoader sdkResolverLoader = new MockSdkResolverLoader
             {
-                LoadResolverAssemblyFunc = (resolverPath, loggingContext, location) => typeof(SdkResolverLoader_Tests).GetTypeInfo().Assembly,
+                LoadResolverAssemblyFunc = (resolverPath) => typeof(SdkResolverLoader_Tests).GetTypeInfo().Assembly,
                 FindPotentialSdkResolversFunc = (rootFolder, loc) => new List<string>
                 {
                     "myresolver.dll"
@@ -141,7 +136,7 @@ public void VerifyThrowsWhenResolverFailsToLoad()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldBe($"The SDK resolver type \"{nameof(MockSdkResolverThatDoesNotLoad)}\" failed to load. A8BB8B3131D3475D881ACD3AF8D75BD6");
@@ -163,7 +158,7 @@ public void VerifyThrowsWhenResolverHasNoPublicConstructor()
         {
             SdkResolverLoader sdkResolverLoader = new MockSdkResolverLoader
             {
-                LoadResolverAssemblyFunc = (resolverPath, loggingContext, location) => typeof(SdkResolverLoader_Tests).GetTypeInfo().Assembly,
+                LoadResolverAssemblyFunc = (resolverPath) => typeof(SdkResolverLoader_Tests).GetTypeInfo().Assembly,
                 FindPotentialSdkResolversFunc = (rootFolder, loc) => new List<string>
                 {
                     "myresolver.dll"
@@ -173,7 +168,7 @@ public void VerifyThrowsWhenResolverHasNoPublicConstructor()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldStartWith($"The SDK resolver type \"{nameof(MockSdkResolverNoPublicConstructor)}\" failed to load.");
@@ -195,7 +190,7 @@ public void VerifyWarningLoggedWhenResolverAssemblyCannotBeLoaded()
 
             SdkResolverLoader sdkResolverLoader = new MockSdkResolverLoader
             {
-                LoadResolverAssemblyFunc = (resolverPath, loggingContext, location) => throw new Exception(expectedMessage),
+                LoadResolverAssemblyFunc = (resolverPath) => throw new Exception(expectedMessage),
                 FindPotentialSdkResolversFunc = (rootFolder, loc) => new List<string>
                 {
                     assemblyPath,
@@ -204,7 +199,7 @@ public void VerifyWarningLoggedWhenResolverAssemblyCannotBeLoaded()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldBe($"The SDK resolver assembly \"{assemblyPath}\" could not be loaded. {expectedMessage}");
@@ -345,12 +340,12 @@ public void SdkResolverLoaderHonorsIncludeDefaultEnvVar()
                     Environment.SetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER", "false");
                     SdkResolverLoader loader = new MockSdkResolverLoader()
                     {
-                        LoadResolversAction = (resolverPath, loggingContext, location, resolvers) =>
+                        LoadResolversAction = (resolverPath, location, resolvers) =>
                         {
                             resolvers.Add(new MockSdkResolverWithAssemblyPath(resolverPath));
                         }
                     };
-                    IList<SdkResolverBase> resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
+                    IReadOnlyList<SdkResolverBase> resolvers = loader.LoadAllResolvers(new MockElementLocation("file"));
 
                     resolvers.Count.ShouldBe(0);
                 }
@@ -390,7 +385,7 @@ public void SdkResolverLoaderHonorsAdditionalResolversFolder()
                     Environment.SetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER", additionalRoot);
 
                     SdkResolverLoader loader = new SdkResolverLoader();
-                    IList<string> resolvers = loader.FindPotentialSdkResolvers(testRoot, new MockElementLocation("file"));
+                    IReadOnlyList<string> resolvers = loader.FindPotentialSdkResolvers(testRoot, new MockElementLocation("file"));
 
                     resolvers.ShouldBeSameIgnoringOrder(new[] { resolver1Path, resolver2Path, resolver3Path });
                 }
@@ -457,22 +452,22 @@ public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverCont
 
         private sealed class MockSdkResolverLoader : SdkResolverLoader
         {
-            public Func<string, LoggingContext, ElementLocation, Assembly> LoadResolverAssemblyFunc { get; set; }
+            public Func<string, Assembly> LoadResolverAssemblyFunc { get; set; }
 
-            public Func<string, ElementLocation, IList<string>> FindPotentialSdkResolversFunc { get; set; }
+            public Func<string, ElementLocation, IReadOnlyList<string>> FindPotentialSdkResolversFunc { get; set; }
 
             public Func<Assembly, IEnumerable<Type>> GetResolverTypesFunc { get; set; }
 
-            public Action<string, LoggingContext, ElementLocation, List<SdkResolver>> LoadResolversAction { get; set; }
+            public Action<string, ElementLocation, List<SdkResolver>> LoadResolversAction { get; set; }
 
-            protected override Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location)
+            protected override Assembly LoadResolverAssembly(string resolverPath)
             {
                 if (LoadResolverAssemblyFunc != null)
                 {
-                    return LoadResolverAssemblyFunc(resolverPath, loggingContext, location);
+                    return LoadResolverAssemblyFunc(resolverPath);
                 }
 
-                return base.LoadResolverAssembly(resolverPath, loggingContext, location);
+                return base.LoadResolverAssembly(resolverPath);
             }
 
             protected override IEnumerable<Type> GetResolverTypes(Assembly assembly)
@@ -485,7 +480,7 @@ protected override IEnumerable<Type> GetResolverTypes(Assembly assembly)
                 return base.GetResolverTypes(assembly);
             }
 
-            internal override IList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
+            internal override IReadOnlyList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
             {
                 if (FindPotentialSdkResolversFunc != null)
                 {
@@ -495,14 +490,14 @@ internal override IList<string> FindPotentialSdkResolvers(string rootFolder, Ele
                 return base.FindPotentialSdkResolvers(rootFolder, location);
             }
 
-            protected override void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
+            protected override void LoadResolvers(string resolverPath, ElementLocation location, List<SdkResolver> resolvers)
             {
                 if (LoadResolversAction != null)
                 {
-                    LoadResolversAction(resolverPath, loggingContext, location, resolvers);
+                    LoadResolversAction(resolverPath, location, resolvers);
                     return;
                 }
-                base.LoadResolvers(resolverPath, loggingContext, location, resolvers);
+                base.LoadResolvers(resolverPath, location, resolvers);
             }
         }
     }
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index dce922f7c2f..bb2cf8e7019 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -131,7 +131,7 @@ public void AssertSecondResolverWithPatternCanResolve()
 
         [Fact]
         // Scenario: MockSdkResolverWithResolvableSdkPattern1 is a specific resolver, it is loaded but did not resolve sdk.
-        // MockSdkResolver1 is a general resolver (i.e. resolver without pattern), it resolves sdk on a fallback. 
+        // MockSdkResolver1 is a general resolver (i.e. resolver without pattern), it resolves sdk on a fallback.
         public void AssertFirstResolverCanResolve()
         {
             SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
@@ -638,13 +638,12 @@ private MockLoaderStrategy()
                 _resolversWithPatterns = new List<(string ResolvableSdkPattern, SdkResolver Resolver)>();
             }
 
-            internal override IList<SdkResolver> LoadAllResolvers(LoggingContext loggingContext, ElementLocation location)
+            internal override IReadOnlyList<SdkResolver> LoadAllResolvers(ElementLocation location)
             {
                 return _resolvers.OrderBy(i => i.Priority).ToList();
             }
 
-            internal override IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,
-            ElementLocation location)
+            internal override IReadOnlyList<SdkResolverManifest> GetResolversManifests(ElementLocation location)
             {
                 var manifests = new List<SdkResolverManifest>();
                 foreach (SdkResolver resolver in _resolvers)
@@ -663,7 +662,7 @@ internal override IList<SdkResolverManifest> GetResolversManifests(LoggingContex
                 return manifests;
             }
 
-            protected internal override IList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)
+            protected internal override IReadOnlyList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, ElementLocation location)
             {
                 var resolvers = new List<SdkResolver>();
                 foreach (var resolver in _resolvers)
@@ -683,7 +682,7 @@ protected internal override IList<SdkResolver> LoadResolversFromManifest(SdkReso
                 return resolvers.OrderBy(t => t.Priority).ToList();
             }
 
-            internal override IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
+            internal override IReadOnlyList<SdkResolver> GetDefaultResolvers()
             {
                 return new List<SdkResolver>();
             }
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 322c61aa579..83d4ae0cf0a 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -77,9 +77,15 @@ public SdkResultOutOfProc_Tests(ITestOutputHelper output)
 
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
             EvaluationContext.TestOnlyHookOnCreate = null;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 065958278e0..cd2a93acc25 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -123,11 +123,11 @@ public void EmptyItemSpecInTargetOutputs()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items);c.cs"
         ///         Outputs="@(Items->'%(Filename).dll')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs], and only b.cs is out of date w/r/t its
         /// correlated output b.dll, then we should only build "b" incrementally.
         /// </summary>
@@ -160,11 +160,11 @@ public void MetaInputAndInputItemThatCorrelatesWithOutputItem()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items)"
         ///         Outputs="@(Items->'%(Filename).dll');@(Items->'%(Filename).xml')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs;c.cs], and only b.cs is out of date w/r/t its
         /// correlated outputs (dll or xml), then we should only build "b" incrementally.
         /// </summary>
@@ -203,11 +203,11 @@ public void InputItemThatCorrelatesWithMultipleTransformOutputItems()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items);@(MoreItems)"
         ///         Outputs="@(Items->'%(Filename).dll');@(MoreItems->'%(Filename).xml')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs;c.cs], and only b.cs is out of date w/r/t its
         /// correlated outputs (dll or xml), then we should only build "b" incrementally.
         /// </summary>
@@ -443,24 +443,24 @@ public void MultiInputItemsThatCorrelatesWithMultipleTransformOutputItems2()
   </Target>
 
   <Target Name='Setup'>
-        <WriteLinesToFile 
+        <WriteLinesToFile
             File='A'
             Lines='A'
             Overwrite='true'/>
-            
-        <WriteLinesToFile 
+
+        <WriteLinesToFile
             File='B.out'
             Lines='B.out'
             Overwrite='true'/>
 
         <Exec Command='sleep.exe 1' />
 
-        <WriteLinesToFile 
+        <WriteLinesToFile
             File='B'
             Lines='B'
             Overwrite='true'/>
-            
-        <WriteLinesToFile 
+
+        <WriteLinesToFile
             File='A.out'
             Lines='A.out'
             Overwrite='true'/>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 1e6b56edd0e..2c662f12a92 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -144,14 +144,24 @@ public void CanceledTasksDoNotLogMSB4181()
                 BuildManager manager = new BuildManager();
                 ProjectCollection collection = new ProjectCollection();
 
+                string sleepCommand = Helpers.GetSleepCommand(TimeSpan.FromSeconds(10));
                 string contents = @"
                     <Project ToolsVersion ='Current'>
                      <Target Name='test'>
-                        <Exec Command='" + Helpers.GetSleepCommand(TimeSpan.FromSeconds(10)) + @"'/>
+                        <Exec Command='" + sleepCommand + @"'/>
                      </Target>
                     </Project>";
 
                 MockLogger logger = new MockLogger(_testOutput);
+                ManualResetEvent waitCommandExecuted = new ManualResetEvent(false);
+                string unescapedSleepCommand = sleepCommand.Replace("&quot;", "\"").Replace("&gt;", ">");
+                logger.AdditionalHandlers.Add((sender, args) =>
+                {
+                    if (unescapedSleepCommand.Equals(args.Message))
+                    {
+                        waitCommandExecuted.Set();
+                    }
+                });
 
                 var project = new Project(XmlReader.Create(new StringReader(contents)), null, MSBuildConstants.CurrentToolsVersion, collection)
                 {
@@ -169,11 +179,14 @@ public void CanceledTasksDoNotLogMSB4181()
                 manager.BeginBuild(_parameters);
                 BuildSubmission asyncResult = manager.PendBuildRequest(data);
                 asyncResult.ExecuteAsync(null, null);
-                Thread.Sleep(500);
+                int timeoutMilliseconds = 2000;
+                bool isCommandExecuted = waitCommandExecuted.WaitOne(timeoutMilliseconds);
                 manager.CancelAllSubmissions();
-                asyncResult.WaitHandle.WaitOne();
+                bool isSubmissionComplated = asyncResult.WaitHandle.WaitOne(timeoutMilliseconds);
                 BuildResult result = asyncResult.BuildResult;
                 manager.EndBuild();
+                isCommandExecuted.ShouldBeTrue($"Waiting for that the sleep command is executed failed in the timeout period {timeoutMilliseconds} ms.");
+                isSubmissionComplated.ShouldBeTrue($"Waiting for that the build submission is completed failed in the timeout period {timeoutMilliseconds} ms.");
 
                 // No errors from cancelling a build.
                 logger.ErrorCount.ShouldBe(0);
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index 0d4a6fc7cba..b956eaa4c6e 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Text;
 using System.Threading;
 
 
@@ -31,7 +32,7 @@ public class TaskHostConfiguration_Tests
         private bool _continueOnErrorDefault = true;
 
         /// <summary>
-        /// Test that an exception is thrown when the task name is null. 
+        /// Test that an exception is thrown when the task name is null.
         /// </summary>
         [Fact]
         public void ConstructorWithNullName()
@@ -66,7 +67,7 @@ public void ConstructorWithNullName()
             });
         }
         /// <summary>
-        /// Test that an exception is thrown when the task name is empty. 
+        /// Test that an exception is thrown when the task name is empty.
         /// </summary>
         [Fact]
         public void ConstructorWithEmptyName()
@@ -175,7 +176,7 @@ public void ConstructorWithEmptyLocation()
 #endif
 
         /// <summary>
-        /// Test the valid constructors.  
+        /// Test the valid constructors.
         /// </summary>
         [Fact]
         public void TestValidConstructors()
@@ -325,7 +326,7 @@ public void TestValidConstructors()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary is null. 
+        /// Test serialization / deserialization when the parameter dictionary is null.
         /// </summary>
         [Fact]
         public void TestTranslationWithNullDictionary()
@@ -376,8 +377,59 @@ public void TestTranslationWithNullDictionary()
             Assert.Equal(expectedGlobalProperties, deserializedConfig.GlobalProperties);
         }
 
+#if FEATURE_APPDOMAIN
+        /// <summary>
+        /// Test serialization / deserialization of the AppDomainSetup instance.
+        /// </summary>
+        [Theory]
+        [InlineData(new byte[] { 1, 2, 3 })]
+        [InlineData(null)]
+        public void TestTranslationWithAppDomainSetup(byte[] configBytes)
+        {
+            AppDomainSetup setup = new AppDomainSetup();
+
+            TaskHostConfiguration config = new TaskHostConfiguration(
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+                appDomainSetup: setup,
+                lineNumberOfTask: 1,
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                isTaskInputLoggingEnabled: false,
+                taskParameters: new Dictionary<string, object>(),
+                globalParameters: new Dictionary<string, string>(),
+                warningsAsErrors: null,
+                warningsNotAsErrors: null,
+                warningsAsMessages: null);
+
+            setup.SetConfigurationBytes(configBytes);
+
+            ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
+
+            deserializedConfig.AppDomainSetup.ShouldNotBeNull();
+
+            if (configBytes is null)
+            {
+                deserializedConfig.AppDomainSetup.GetConfigurationBytes().ShouldBeNull();
+            }
+            else
+            {
+                deserializedConfig.AppDomainSetup.GetConfigurationBytes().SequenceEqual(configBytes).ShouldBeTrue();
+            }
+        }
+#endif
+
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary is empty. 
+        /// Test serialization / deserialization when the parameter dictionary is empty.
         /// </summary>
         [Fact]
         public void TestTranslationWithEmptyDictionary()
@@ -425,7 +477,7 @@ public void TestTranslationWithEmptyDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains just value types. 
+        /// Test serialization / deserialization when the parameter dictionary contains just value types.
         /// </summary>
         [Fact]
         public void TestTranslationWithValueTypesInDictionary()
@@ -475,7 +527,7 @@ public void TestTranslationWithValueTypesInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem.
         /// </summary>
         [Fact]
         public void TestTranslationWithITaskItemInDictionary()
@@ -523,7 +575,7 @@ public void TestTranslationWithITaskItemInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array.
         /// </summary>
         [Fact]
         public void TestTranslationWithITaskItemArrayInDictionary()
@@ -575,7 +627,7 @@ public void TestTranslationWithITaskItemArrayInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array.
         /// </summary>
         [Fact]
         public void TestTranslationWithWarningsAsErrors()
@@ -671,7 +723,7 @@ public void TestTranslationWithWarningsAsMessages()
         }
 
         /// <summary>
-        /// Helper methods for testing the task host-related packets. 
+        /// Helper methods for testing the task host-related packets.
         /// </summary>
         internal static class TaskHostPacketHelpers
         {
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
index c85e00e0f9c..835cb83e7bf 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.UnitTests.BackEnd
     public class TaskHostTaskCancelled_Tests
     {
         /// <summary>
-        /// Basic test of the constructor. 
+        /// Basic test of the constructor.
         /// </summary>
         [Fact]
         public void TestConstructor()
@@ -24,7 +24,7 @@ public void TestConstructor()
         }
 
         /// <summary>
-        /// Basic test of serialization / deserialization. 
+        /// Basic test of serialization / deserialization.
         /// </summary>
         [Fact]
         public void TestTranslation()
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
index 5c6bf006b2c..23cf234576d 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Xunit;
@@ -20,30 +21,76 @@ namespace Microsoft.Build.UnitTests.BackEnd
     public class TaskHostTaskComplete_Tests
     {
         /// <summary>
-        /// Tests various valid ways to construct this packet.  
+        /// Tests various valid ways to construct this packet.
         /// </summary>
         [Fact]
         public void TestConstructors()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success), null);
-            TaskHostTaskComplete complete2 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure), null);
-            TaskHostTaskComplete complete3 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringInitialization, new ArgumentOutOfRangeException()), null);
-            TaskHostTaskComplete complete4 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, new ArgumentNullException()), null);
+#if FEATURE_REPORTFILEACCESSES
+            var fileAccessData = new List<FileAccessData>()
+            {
+                new FileAccessData(
+                    ReportedFileOperation.CreateFile,
+                    RequestedAccess.Read,
+                    0,
+                    0,
+                    DesiredAccess.GENERIC_READ,
+                    FlagsAndAttributes.FILE_ATTRIBUTE_NORMAL,
+                    "foo",
+                    null,
+                    true),
+            };
+#endif
+
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringInitialization,
+                new ArgumentOutOfRangeException()),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, new ArgumentNullException()),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
 
             IDictionary<string, object> parameters = new Dictionary<string, object>();
-            TaskHostTaskComplete complete5 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             IDictionary<string, object> parameters2 = new Dictionary<string, object>();
             parameters2.Add("Text", "Hello!");
             parameters2.Add("MyBoolValue", true);
             parameters2.Add("MyITaskItem", new TaskItem("ABC"));
             parameters2.Add("ItemArray", new ITaskItem[] { new TaskItem("DEF"), new TaskItem("GHI"), new TaskItem("JKL") });
-
-            TaskHostTaskComplete complete6 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters2), null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters2),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
         }
 
         /// <summary>
-        /// Test invalid constructor permutations. 
+        /// Test invalid constructor permutations.
         /// </summary>
         [Fact]
         public void TestInvalidConstructors()
@@ -60,7 +107,12 @@ public void TestInvalidConstructors()
         [Fact]
         public void TestTranslationWithNullDictionary()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -78,7 +130,12 @@ public void TestTranslationWithNullDictionary()
         [Fact]
         public void TestTranslationWithEmptyDictionary()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, new Dictionary<string, object>()), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, new Dictionary<string, object>()),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -99,7 +156,12 @@ public void TestTranslationWithValueTypesInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("Text", "Foo");
             parameters.Add("BoolValue", false);
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -114,14 +176,19 @@ public void TestTranslationWithValueTypesInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem.
         /// </summary>
         [Fact]
         public void TestTranslationWithITaskItemInDictionary()
         {
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemValue", new TaskItem("Foo"));
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -135,14 +202,19 @@ public void TestTranslationWithITaskItemInDictionary()
         }
 
         /// <summary>
-        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array. 
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array.
         /// </summary>
         [Fact]
         public void TestTranslationWithITaskItemArrayInDictionary()
         {
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemArrayValue", new ITaskItem[] { new TaskItem("Foo"), new TaskItem("Baz") });
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -168,7 +240,12 @@ private void AssertInvalidConstructorThrows(Type expectedExceptionType, TaskComp
 
             try
             {
-                TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(taskResult, taskOutputParameters, taskException, taskExceptionMessage, taskExceptionMessageArgs), buildProcessEnvironment);
+                TaskHostTaskComplete complete = new(
+                    new OutOfProcTaskHostTaskResult(taskResult, taskOutputParameters, taskException, taskExceptionMessage, taskExceptionMessageArgs),
+#if FEATURE_REPORTFILEACCESSES
+                    null,
+#endif
+                    buildProcessEnvironment);
             }
             catch (Exception e)
             {
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 57e2bc3fa82..4928a8d29f8 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -188,8 +188,13 @@ public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
             }
         }
 
-        [Fact]
-        public void AssemblyLoadsDuringTaskRunLogged()
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Tests if the AppDomain used to load the task is included in the log text for the event, which is true only on Framework.")]
+        public void AssemblyLoadsDuringTaskRunLoggedWithAppDomain() => AssemblyLoadsDuringTaskRun("AppDomain: [Default]");
+
+        [DotNetOnlyFact(additionalMessage: "Tests if the AssemblyLoadContext used to load the task is included in the log text for the event, which is true only on Core.")]
+        public void AssemblyLoadsDuringTaskRunLoggedWithAssemblyLoadContext() => AssemblyLoadsDuringTaskRun("AssemblyLoadContext: Default");
+
+        private void AssemblyLoadsDuringTaskRun(string additionalEventText)
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
@@ -201,7 +206,7 @@ public void AssemblyLoadsDuringTaskRunLogged()
                         TaskFactory="RoslynCodeTaskFactory"
                         AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
                         <ParameterGroup />
-                        <Task> 
+                        <Task>
                           <Using Namespace="System"/>
                           <Using Namespace="System.IO"/>
                           <Using Namespace="System.Reflection"/>
@@ -235,17 +240,20 @@ public void AssemblyLoadsDuringTaskRunLogged()
                     "Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug";
                 string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
                 text.ShouldContain(assemblyLoadedEventText);
+                text.ShouldContain(additionalEventText);
                 // events should not be in logger with verbosity normal
                 string text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile2.log"));
                 text2.ShouldNotContain(assemblyLoadedEventText);
-
+                text2.ShouldNotContain(additionalEventText);
                 RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
                 success.ShouldBeTrue();
                 text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile3.log"));
                 text.ShouldContain(assemblyLoadedEventText);
+                text.ShouldContain(additionalEventText);
                 // events should not be in logger with verbosity normal
                 text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile4.log"));
                 text2.ShouldNotContain(assemblyLoadedEventText);
+                text2.ShouldNotContain(additionalEventText);
             }
         }
 
@@ -275,7 +283,7 @@ public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"),
-                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+                $"Embedded files: {string.Join(",", zipArchive.Entries)}");
         }
 
         [RequiresSymbolicLinksFact]
@@ -335,13 +343,13 @@ public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"),
-                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+                customMessage: $"Embedded files: {string.Join(",", zipArchive.Entries)}");
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName),
-                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+                customMessage: $"Embedded files: {string.Join(",", zipArchive.Entries)}");
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name),
-                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+                customMessage: $"Embedded files: {string.Join(",", zipArchive.Entries)}");
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName),
-                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+                customMessage: $"Embedded files: {string.Join(",", zipArchive.Entries)}");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 9963b2338b5..faacc88379f 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -263,10 +263,11 @@ public void RoundtripBuildErrorEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
+        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool withOptionalData)
         {
             var args = new ExtendedBuildErrorEventArgs(
                 "extendedDataType",
@@ -281,10 +282,14 @@ public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
                 "Help",
                 "SenderName",
                 DateTime.Parse("9/1/2021 12:02:07 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
 
-            // For now we don't serialize extended data into binary log
-            Roundtrip<BuildErrorEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -294,6 +299,9 @@ public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
                 e => e.Message,
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -332,7 +340,7 @@ public void RoundtripBuildWarningEventArgs(bool useArguments)
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArguments)
+        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool withOptionalData)
         {
             var args = new ExtendedBuildWarningEventArgs(
                 "extendedDataType",
@@ -347,10 +355,14 @@ public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArgume
                 "Help",
                 "SenderName",
                 DateTime.Parse("9/1/2021 12:02:07 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+                {
+                    ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                    ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                    BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+                };
 
-            // For now we don't serialize extended data into binary log
-            Roundtrip<BuildWarningEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -360,6 +372,9 @@ public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArgume
                 e => e.Message,
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -400,14 +415,14 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useArguments)
+        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool withOptionalData)
         {
             var args = new ExtendedBuildMessageEventArgs(
                 "extendedDataType",
                 "Subcategory",
                 "Code",
                 "File",
-                1, 
+                1,
                 2,
                 3,
                 4,
@@ -416,9 +431,14 @@ public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useA
                 "SenderName",
                 MessageImportance.High,
                 DateTime.Parse("12/12/2015 06:11:56 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
 
-            Roundtrip<BuildMessageEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -429,6 +449,9 @@ public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useA
                 e => e.Importance.ToString(),
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -493,19 +516,21 @@ public void ExtendedCustomBuildEventArgs_SerializedAsMessage(bool withOptionalDa
 
             using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
             var deserialized = buildEventArgsReader.Read();
-            BuildMessageEventArgs desArgs = (BuildMessageEventArgs)deserialized;
-
-            desArgs.ShouldBeOfType(typeof(BuildMessageEventArgs));
+            ExtendedBuildMessageEventArgs desArgs = (ExtendedBuildMessageEventArgs)deserialized;
 
+            desArgs.ShouldBeOfType(typeof(ExtendedBuildMessageEventArgs));
             desArgs.Message.ShouldBe(args.Message);
             desArgs.HelpKeyword.ShouldBe(args.HelpKeyword);
             desArgs.SenderName.ShouldBe(args.SenderName);
             desArgs.Importance.ShouldBe(MessageImportance.Normal);
             desArgs.Timestamp.ShouldBe(args.Timestamp);
+            desArgs.ExtendedType.ShouldBe(args.ExtendedType);
 
             if (withOptionalData)
             {
                 desArgs.BuildEventContext.ShouldBe(args.BuildEventContext);
+                desArgs.ExtendedData.ShouldBe(args.ExtendedData);
+                TranslationHelpers.ToString(desArgs.ExtendedMetadata).ShouldBe(TranslationHelpers.ToString(args.ExtendedMetadata));
             }
             else
             {
@@ -549,6 +574,48 @@ public void RoundtripCriticalBuildMessageEventArgs()
                 e => e.Subcategory);
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedCriticalBuildMessageEventArgs(bool withOptionalData)
+        {
+            var args = new ExtendedCriticalBuildMessageEventArgs(
+                "extCrit",
+                "Subcategory",
+                "Code",
+                "File",
+                1,
+                2,
+                3,
+                4,
+                "Message",
+                "Help",
+                "SenderName",
+                DateTime.Parse("12/12/2015 06:11:56 PM"),
+                withOptionalData ? new object[] { "argument0" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
+
+
+            Roundtrip(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
         [Fact]
         public void RoundtripTaskCommandLineEventArgs()
         {
diff --git a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
index f204e2b163f..882753a8a50 100644
--- a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
@@ -198,7 +198,7 @@ private static CopyOnWritePropertyDictionary<MockValue> CreateInstance(params st
             return dic;
         }
 
-        private sealed class MockValue : IKeyed, IValued, IEquatable<MockValue>, IImmutable
+        private sealed class MockValue : IKeyed, IValued, IEquatable<MockValue>, IEquatable<object>, IImmutable
         {
             public MockValue(string s) => Key = s;
 
@@ -210,6 +210,15 @@ public bool Equals(MockValue? other)
             {
                 return other != null && Key == other.Key;
             }
+
+            public new bool Equals(object? other)
+            {
+                if (other is MockValue mv)
+                {
+                    return Equals(mv);
+                }
+                return false;
+            }
         }
     }
 }
diff --git a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
index 1f167556b98..be97777e5e3 100644
--- a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
+++ b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
@@ -57,7 +57,7 @@ public void MatchProperty()
         }
 
         /// <summary>
-        /// Null 
+        /// Null
         /// </summary>
         [Fact]
         public void Null1()
@@ -66,7 +66,7 @@ public void Null1()
         }
 
         /// <summary>
-        /// Null 
+        /// Null
         /// </summary>
         [Fact]
         public void Null2()
@@ -75,7 +75,7 @@ public void Null2()
         }
 
         /// <summary>
-        /// Invalid start 
+        /// Invalid start
         /// </summary>
         [Fact]
         public void InvalidValue2()
@@ -86,7 +86,7 @@ public void InvalidValue2()
             });
         }
         /// <summary>
-        /// Invalid small end 
+        /// Invalid small end
         /// </summary>
         [Fact]
         public void InvalidValue4()
@@ -97,7 +97,7 @@ public void InvalidValue4()
             });
         }
         /// <summary>
-        /// Invalid large end 
+        /// Invalid large end
         /// </summary>
         [Fact]
         public void InvalidValue5()
@@ -160,7 +160,7 @@ public void DefaultGetHashcode()
         {
             Assert.True(0 == MSBuildNameIgnoreCaseComparer.Default.GetHashCode((string)null));
 
-            MSBuildNameIgnoreCaseComparer.Default.GetHashCode(""); // doesn't throw            
+            MSBuildNameIgnoreCaseComparer.Default.GetHashCode(""); // doesn't throw
             Assert.Equal(MSBuildNameIgnoreCaseComparer.Default.GetHashCode("aBc"), MSBuildNameIgnoreCaseComparer.Default.GetHashCode("AbC"));
         }
 
diff --git a/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
index f1c67899aea..7b98b820a4f 100644
--- a/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -60,7 +60,7 @@ public void ProjectLoadedPreservingCommentsAndWhiteSpaceIsNotReadOnly()
             var projectContents =
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                   <!--Initial Comment-->
-                       
+
                   <!--Ending Comment-->
                 </Project>
                 ";
@@ -91,7 +91,7 @@ public void ProjectLoadedStrippingCommentsAndWhiteSpaceIsReadOnly()
             var projectContents =
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                   <!--Initial Comment-->
-                       
+
                   <!--Ending Comment-->
                 </Project>
                 ";
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 278c11f36ed..79bb93a4703 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -421,7 +421,7 @@ public void TestVSAndSolutionVersionParsing()
             string solutionFileContentsDev12Corrupted2 =
                @"
                     Microsoft Visual Studio Solution File, Format Version 11.00
-                        VisualStudioVersion = 
+                        VisualStudioVersion =
                         MinimumVisualStudioVersion = 10.0.40219.1
                         Project('{FE3BBBB6-72D5-11D2-9ACE-00C04F79A2A4}') = 'someproj', 'someproj.etp', '{AD0F3D02-9925-4D57-9DAF-E0A9D936ABDB}'
                             ProjectSection(ProjectDependencies) = postProject
@@ -1050,20 +1050,20 @@ public void ParseSolutionConfigurationWithEmptyLines()
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
 
                         Debug|Any CPU = Debug|Any CPU
-                        
+
                         Release|Any CPU = Release|Any CPU
- 
-    
+
+
                     EndGlobalSection
                     GlobalSection(ProjectConfigurationPlatforms) = postSolution
 
                         {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
                         {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        
+
                         {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.ActiveCfg = Release|Any CPU
                         {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.Build.0 = Release|Any CPU
- 
-  
+
+
                         {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
                         {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.Build.0 = Debug|Any CPU
                         {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.ActiveCfg = Release|Any CPU
@@ -1072,17 +1072,17 @@ public void ParseSolutionConfigurationWithEmptyLines()
                         {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
                         {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
                         {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.Build.0 = Release|Any CPU
-    
+
                     EndGlobalSection
                     GlobalSection(SolutionProperties) = preSolution
                         HideSolutionNode = FALSE
                     EndGlobalSection
                     GlobalSection(NestedProjects) = preSolution
-                        
+
                         {A5EE8128-B08E-4533-86C5-E46714981680} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
                         {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
                         {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4} = {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}
-                        
+
 
                     EndGlobalSection
                 EndGlobal
diff --git a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
index fa09e0d0cd5..7e81e9ec729 100644
--- a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
@@ -62,7 +62,7 @@ private static IList<ProjectItem> GetItemsFromFragment(string fragment)
 
         /// <summary>
         /// Get the item of type "i" using the item Xml fragment provided.
-        /// If there is more than one, fail. 
+        /// If there is more than one, fail.
         /// </summary>
         private static ProjectItem GetOneItemFromFragment(string fragment)
         {
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index 4b1c8457c93..57afc8fd889 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -115,7 +115,7 @@ public void MSBuildToolsetsTest_Basic2()
         }
 
         /// <summary>
-        ///  Tests if ToolsetConfigurationReaderTests is successfully initialized from the config file and that msbuildOVerrideTasksPath 
+        ///  Tests if ToolsetConfigurationReaderTests is successfully initialized from the config file and that msbuildOVerrideTasksPath
         ///  is correctly read in when the value is empty.
         /// </summary>
         [Fact]
@@ -194,7 +194,7 @@ public void MSBuildToolsetsTest_BasicWithOtherConfigEntries()
         #region "Invalid cases (exception is expected to be thrown)"
 
         /// <summary>
-        /// name attribute is missing from toolset element 
+        /// name attribute is missing from toolset element
         /// </summary>
         [Fact]
         public void ToolsVersionTest_NameNotSpecified()
@@ -250,7 +250,7 @@ public void ToolsVersionTest_MultipleElementsWithSameName()
             });
         }
         /// <summary>
-        /// empty toolset element 
+        /// empty toolset element
         /// </summary>
         [Fact]
         public void ToolsVersionTest_EmptyElement()
diff --git a/src/Build.UnitTests/Definition/Toolset_Tests.cs b/src/Build.UnitTests/Definition/Toolset_Tests.cs
index 2bf6e660b37..cb63a9d574b 100644
--- a/src/Build.UnitTests/Definition/Toolset_Tests.cs
+++ b/src/Build.UnitTests/Definition/Toolset_Tests.cs
@@ -188,8 +188,8 @@ public void TestDefaultSubToolsetFor40()
                 }
                 else
                 {
-                    // Otherwise, it's the highest one numerically.  Since by definition if Dev10 isn't 
-                    // installed and subtoolsets exists we must be at least Dev11, it should be "11.0" 
+                    // Otherwise, it's the highest one numerically.  Since by definition if Dev10 isn't
+                    // installed and subtoolsets exists we must be at least Dev11, it should be "11.0"
                     Assert.Equal("11.0", t.DefaultSubToolsetVersion);
                 }
             }
@@ -438,8 +438,8 @@ public void TestGenerateSubToolsetVersion_SolutionVersionOverrides()
                 Assert.Equal("12.0", t.GenerateSubToolsetVersion(null, 13));
                 Assert.Equal("v13.0", t.GenerateSubToolsetVersion(null, 14));
 
-                // however, if there is no matching solution version, we just fall back to the 
-                // default sub-toolset. 
+                // however, if there is no matching solution version, we just fall back to the
+                // default sub-toolset.
                 Assert.Equal(t.DefaultSubToolsetVersion, t.GenerateSubToolsetVersion(null, 55));
             }
             finally
@@ -488,27 +488,27 @@ public void TestGetPropertyFromSubToolset()
         }
 
         /// <summary>
-        /// Creates a standard ProjectCollection and adds a fake toolset with the following contents to it:  
-        /// 
+        /// Creates a standard ProjectCollection and adds a fake toolset with the following contents to it:
+        ///
         /// ToolsVersion = Fake
-        /// Base Properties: 
+        /// Base Properties:
         /// a = a1
         /// b = b1
-        /// 
-        /// SubToolset "12.0": 
+        ///
+        /// SubToolset "12.0":
         /// d = d4
         /// e = e5
-        /// 
-        /// SubToolset "v11.0": 
+        ///
+        /// SubToolset "v11.0":
         /// b = b2
         /// c = c2
-        /// 
+        ///
         /// SubToolset "FakeSubToolset":
         /// a = a3
         /// c = c3
-        /// 
+        ///
         /// SubToolset "v13.0":
-        /// f = f6 
+        /// f = f6
         /// g = g7
         /// </summary>
         private Toolset GetFakeToolset(IDictionary<string, string> globalPropertiesForProjectCollection)
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 221ea0026e2..44a21a2321f 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -2651,18 +2651,18 @@ public void MSBuildVersion()
             Version.TryParse(msbuildVersionProperty, out Version msbuildVersionAsVersion).ShouldBeTrue();
 
             msbuildVersionAsVersion.Minor.ShouldBeInRange(0, 20,
-                () => $"minor version {msbuildVersionProperty} looks fishy. If we're really in x.20.0, go ahead and change the constant. This is to guard against being nonsensical like 16.200.19");
+                customMessage: $"minor version {msbuildVersionProperty} looks fishy. If we're really in x.20.0, go ahead and change the constant. This is to guard against being nonsensical like 16.200.19");
 
             // Version parses missing elements into -1, and this property should be Major.Minor.Patch only
             msbuildVersionAsVersion.Revision.ShouldBe(-1);
 
             msbuildFileVersionProperty.ShouldBe(ProjectCollection.Version.ToString());
             ProjectCollection.Version.ToString().ShouldStartWith(msbuildVersionProperty,
-                "ProjectCollection.Version should match the property MSBuildVersion, but can contain another version part");
+                customMessage: "ProjectCollection.Version should match the property MSBuildVersion, but can contain another version part");
 
             msbuildSemanticVersionProperty.ShouldBe(ProjectCollection.DisplayVersion);
             ProjectCollection.DisplayVersion.ShouldStartWith(msbuildVersionProperty,
-                "DisplayVersion is semver2 while MSBuildVersion is Major.Minor.Build but should be a prefix match");
+                customMessage: "DisplayVersion is semver2 while MSBuildVersion is Major.Minor.Build but should be a prefix match");
         }
 
 
@@ -4597,7 +4597,7 @@ public void VerifyMSBuildLogsAMessageWhenLocalPropertyCannotOverrideValueOfGloba
         public void VerifyPropertyTrackingLoggingDefault()
         {
             // Having just environment variables defined should default to nothing being logged except one environment variable read.
-            this.VerifyPropertyTrackingLoggingScenario(
+            VerifyPropertyTrackingLoggingScenario(
                 null,
                 logger =>
                 {
@@ -4616,7 +4616,8 @@ public void VerifyPropertyTrackingLoggingDefault()
                     logger
                         .AllBuildEvents
                         .OfType<PropertyReassignmentEventArgs>()
-                        .ShouldBeEmpty();
+                        .Count()
+                        .ShouldBe(2);
 
                     logger
                         .AllBuildEvents
@@ -4628,7 +4629,7 @@ public void VerifyPropertyTrackingLoggingDefault()
         [Fact]
         public void VerifyPropertyTrackingLoggingPropertyReassignment()
         {
-            this.VerifyPropertyTrackingLoggingScenario(
+            VerifyPropertyTrackingLoggingScenario(
                 "1",
                 logger =>
                 {
@@ -4677,13 +4678,14 @@ public void VerifyPropertyTrackingLoggingNone()
 
                     logger
                         .AllBuildEvents
-                        .OfType<PropertyReassignmentEventArgs>()
+                        .OfType<PropertyInitialValueSetEventArgs>()
                         .ShouldBeEmpty();
 
                     logger
-                        .AllBuildEvents
-                        .OfType<PropertyInitialValueSetEventArgs>()
-                        .ShouldBeEmpty();
+                       .AllBuildEvents
+                       .OfType<PropertyReassignmentEventArgs>()
+                       .Count()
+                       .ShouldBe(2);
                 });
         }
 
@@ -4919,6 +4921,55 @@ private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<Mo
             }
         }
 
+        /// <summary>
+        /// Log when a property is being assigned a new value.
+        /// </summary>
+        [Fact]
+        public void VerifyLogPropertyReassignment()
+        {
+            string propertyName = "Prop";
+            string propertyOldValue = "OldValue";
+            string propertyNewValue = "NewValue";
+            string testtargets = ObjectModelHelpers.CleanupFileContents(@$"
+                                <Project xmlns='msbuildnamespace'>
+                                     <PropertyGroup>
+                                         <{propertyName}>{propertyOldValue}</{propertyName}>
+                                         <{propertyName}>{propertyNewValue}</{propertyName}>
+                                     </PropertyGroup>
+                                  <Target Name=""Test""/>
+                                </Project>");
+
+            string tempPath = Path.GetTempPath();
+            string targetDirectory = Path.Combine(tempPath, "LogPropertyAssignments");
+            string testTargetPath = Path.Combine(targetDirectory, "test.proj");
+
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.CreateFolder(targetDirectory);
+                env.CreateFile(testTargetPath, testtargets);
+
+                MockLogger logger = new()
+                {
+                    Verbosity = LoggerVerbosity.Diagnostic,
+                };
+                ProjectCollection pc = new();
+                pc.RegisterLogger(logger);
+                Project project = pc.LoadProject(testTargetPath);
+
+                bool result = project.Build();
+                result.ShouldBeTrue();
+                logger.BuildMessageEvents
+                      .OfType<PropertyReassignmentEventArgs>()
+                      .ShouldContain(r => r.PropertyName == propertyName
+                      && r.PreviousValue == propertyOldValue
+                      && r.NewValue == propertyNewValue
+                      && r.Message.StartsWith($"{
+                          ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                              "PropertyReassignment", propertyName, propertyNewValue, propertyOldValue, string.Empty)}"));
+                logger.BuildMessageEvents.ShouldBeOfTypes(new[] { typeof(PropertyReassignmentEventArgs) });
+            }
+        }
+
 #if FEATURE_HTTP_LISTENER
         /// <summary>
         /// HTTP server code running on a separate thread that expects a connection request
diff --git a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
index 1d768794e9f..5e451ce45c5 100644
--- a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
@@ -1134,14 +1134,14 @@ private static HashSet<string> GetConsumedItemReferences_OriginalImplementation(
         /// <summary>
         /// Looks through the parameters of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Returns a Hashtable containing a bunch of MetadataReference
-        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <returns>Hashtable containing the metadata references.</returns>
         private static Dictionary<string, MetadataReference> GetConsumedMetadataReferences_OriginalImplementation(string expression)
         {
             // The keys in the hash table are the qualified metadata names (e.g. "EmbeddedResource.Culture"
-            // or just "Culture").  The values are MetadataReference structs, which simply split out the item 
+            // or just "Culture").  The values are MetadataReference structs, which simply split out the item
             // name (possibly null) and the actual metadata name.
             Dictionary<string, MetadataReference> consumedMetadataReferences = new Dictionary<string, MetadataReference>(StringComparer.OrdinalIgnoreCase);
 
@@ -1153,7 +1153,7 @@ private static Dictionary<string, MetadataReference> GetConsumedMetadataReferenc
         /// <summary>
         /// Looks through a single parameter of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Populates a Hashtable containing a bunch of MetadataReference
-        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <param name="batchableObjectParameter"></param>
@@ -1241,7 +1241,7 @@ private static void FindEmbeddedMetadataReferences_OriginalImplementation(
         /// <summary>
         /// Looks through a single parameter of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Populates a MatchCollection object with any regex matches
-        /// found in the input.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// found in the input.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <param name="batchableObjectParameter"></param>
diff --git a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
index 4d4e33ff79d..e21015b4c68 100644
--- a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -842,6 +843,43 @@ public void FallbackImportWithFileNotFoundWhenPropertyNotDefined()
                 FileUtilities.DeleteDirectoryNoThrow(extnDir1, true);
             }
         }
+        /// <summary>
+        /// Fall-back search path on a property that is not valid. https://github.com/dotnet/msbuild/issues/8762
+        /// </summary>
+        /// <param name="projectValue">imported project value expression</param>
+        [Theory]
+        [InlineData("")]
+        [InlineData("|")]
+        public void FallbackImportWithInvalidProjectValue(string projectValue)
+        {
+            string mainTargetsFileContent = $"""
+                <Project>
+                    <PropertyGroup>
+                    <VSToolsPath>{projectValue}</VSToolsPath>
+                </PropertyGroup>
+                <Import Project="$(VSToolsPath)"/>
+                </Project>
+                """;
+
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            string mainProjectPath = testEnvironment.CreateTestProjectWithFiles("main.proj", mainTargetsFileContent).ProjectFile;
+            var projectCollection = GetProjectCollection();
+            projectCollection.ResetToolsetsForTests(WriteConfigFileAndGetReader("VSToolsPath", "temp"));
+            var logger = new MockLogger();
+            projectCollection.RegisterLogger(logger);
+            Assert.Throws<InvalidProjectFileException>(() => projectCollection.LoadProject(mainProjectPath));
+
+            if (string.IsNullOrEmpty(projectValue))
+            {
+                logger.AssertLogContains("MSB4102");
+            }
+            else
+            {
+#if NETFRAMEWORK
+                logger.AssertLogContains("MSB4102");
+#endif
+            }
+        }
 
         private void CreateAndBuildProjectForImportFromExtensionsPath(string extnPathPropertyName, Action<Project, MockLogger> action)
         {
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index 3f17110a7d0..84656861b31 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -1211,7 +1211,7 @@ This import was added implicitly because the Project element's Sdk attribute spe
 
 
         /// <summary>
-        /// Verifies that the Preprocessor works when the import graph contains unevaluated duplicates.  This can occur if two projects in 
+        /// Verifies that the Preprocessor works when the import graph contains unevaluated duplicates.  This can occur if two projects in
         /// two different folders both import "..\dir.props" or "$(Property)".  Those values will evaluate to different paths at run time
         /// but the preprocessor builds a map of the imports.
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
index 6268fee61ea..2f0b81f8ddd 100644
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
@@ -273,7 +273,7 @@ public void AddReturnsSameInstanceForSameDocument()
 
                 string return2 = cache.Add(builder.ToString(), document);
 
-                // Content of string should be the same.            
+                // Content of string should be the same.
                 Assert.Equal(builder.ToString(), return2);
 
                 // Returned references should be the same
@@ -285,7 +285,7 @@ public void AddReturnsSameInstanceForSameDocument()
         }
 
         /// <summary>
-        /// Adding a string equivalent to an existing instance but under a different document 
+        /// Adding a string equivalent to an existing instance but under a different document
         /// should return the existing instance.
         /// </summary>
         [Fact]
@@ -334,7 +334,7 @@ public void AddReturnsSameInstanceForDifferentDocument()
         /// WHITEBOX ASSUMPTION:
         /// The following method assumes knowledge of the ProjectStringCache internal implementation
         /// details, and may become invalid if those details change.
-        /// </remarks>        
+        /// </remarks>
         [Fact]
         public void RemoveLastInstanceDeallocatesEntry()
         {
@@ -370,7 +370,7 @@ public void RemoveLastInstanceDeallocatesEntry()
         }
 
         /// <summary>
-        /// Removing one document containing a string which already existed in the collection 
+        /// Removing one document containing a string which already existed in the collection
         /// should still leave a reference in the collection, so that a subsequent add will
         /// return the existing reference.
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
index 30f95c0e0bb..4266e36105b 100644
--- a/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
@@ -49,7 +49,7 @@ IDictionary<string, string> toolsetProperties
         }
 
         [Fact]
-        // With ToolsetDefintionLocations set to ConfigurationFile (Which would only happen in net5.0 if the user decides to set it). 
+        // With ToolsetDefintionLocations set to ConfigurationFile (Which would only happen in net5.0 if the user decides to set it).
         // Most toolsets are available and the MsBuildTools and SDK paths are all in the net5.0 runtime.
         public void ToolsetDefinitionLocationsIsConfiguration()
         {
diff --git a/src/Build.UnitTests/EvaluationProfiler_Tests.cs b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
index 27438bec72e..078dc9e3520 100644
--- a/src/Build.UnitTests/EvaluationProfiler_Tests.cs
+++ b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
@@ -67,8 +67,14 @@ public EvaluationProfiler_Tests(ITestOutputHelper output)
         /// <nodoc/>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 72abe497317..d3f01d757fb 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -58,7 +58,7 @@ public class IsolateProjectsTests : IDisposable
                     </Target>
 
                     <Target Name='CallTarget'>
-                        <CallTarget Targets='SelfTarget'/>  
+                        <CallTarget Targets='SelfTarget'/>
                     </Target>
 
                     <Target Name='SelfTarget'>
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 932c3c8e439..f2bc8fd22a8 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -678,11 +678,19 @@ public void ConstructGraphWithDifferentEntryPointsAndGraphRoots()
         [Fact]
         public void ConstructGraphWithSolution()
         {
-            // This test exercises two key features of solution-based builds from AssignProjectConfiguration:
-            // 1. Adding synthetic project references
-            // 2. Resolving project configuration based on the sln
-            // 3. Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=true
-            // 4. Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=false
+            /*
+             * This test exercises various key features of solution-based builds:
+             *      From AssignProjectConfiguration:
+             *          Adding synthetic project references (defined both before and after the depending project)
+             *          Resolving project configuration based on the sln
+             *          Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=true
+             *          Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=false
+             *      Project types other than "well-known" MSBuild project types:
+             *          Buildable project (wapproj)
+             *          Solution folder
+             *      Project not included in build (also has solution dependencies as a regression test)
+             * 
+             */
             using (var env = TestEnvironment.Create())
             {
                 const string SolutionFileContents = """
@@ -690,15 +698,30 @@ public void ConstructGraphWithSolution()
                     # Visual Studio Version 17
                     VisualStudioVersion = 17.0.31903.59
                     MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project8", "Project8.csproj", "{2022C11A-1405-4983-BEC2-3A8B0233108F}"
+                    EndProject
                     Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "Project1.csproj", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
                         ProjectSection(ProjectDependencies) = postProject
                             {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98} = {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F} = {2022C11A-1405-4983-BEC2-3A8B0233108F}
                         EndProjectSection
                     EndProject
                     Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Project2", "Project2.vcxproj", "{D638A8EF-3A48-45F2-913C-88B29FED03CB}"
                     EndProject
                     Project("{13B669BE-BB05-4DDF-9536-439F39A36129}") = "Project3", "Project3.vcxproj", "{52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}"
                     EndProject
+                    Project("{C7167F0D-BC9F-4E6E-AFE1-012C56B48DB5}") = "Project6", "Project6.wapproj", "{CA5CAD1A-224A-4171-B13A-F16E576FDD12}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project7", "Project7.csproj", "{28C7025E-2AB6-4962-A001-1E5B2271837C}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98} = {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}
+                        EndProjectSection
+                    EndProject
+                    Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{0392E290-973E-4086-A58E-F927AAA65B9A}"
+                        ProjectSection(SolutionItems) = preProject
+                            SomeSolutionItemsFile = SomeSolutionItemsFile
+                        EndProjectSection
+                    EndProject
                     Global
                         GlobalSection(SolutionConfigurationPlatforms) = preSolution
                             Debug|Win32 = Debug|Win32
@@ -709,6 +732,18 @@ public void ConstructGraphWithSolution()
                             Release|x86 = Release|x86
                         EndGlobalSection
                         GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|Win32.ActiveCfg = Debug|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|Win32.Build.0 = Debug|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.ActiveCfg = Debug|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.Build.0 = Debug|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x86.ActiveCfg = Debug|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x86.Build.0 = Debug|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|Win32.ActiveCfg = Release|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|Win32.Build.0 = Release|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.ActiveCfg = Release|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.Build.0 = Release|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x86.ActiveCfg = Release|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x86.Build.0 = Release|x86
                             {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.ActiveCfg = Debug|x86
                             {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.Build.0 = Debug|x86
                             {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
@@ -753,6 +788,24 @@ public void ConstructGraphWithSolution()
                             {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.Build.0 = Release|x64
                             {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.ActiveCfg = Release|Win32
                             {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.Build.0 = Release|Win32
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|Win32.ActiveCfg = Debug|x86
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|Win32.Build.0 = Debug|x86
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|Win32.Deploy.0 = Debug|x86
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|x64.ActiveCfg = Debug|x64
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|x64.Build.0 = Debug|x64
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|x64.Deploy.0 = Debug|x64
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|x86.ActiveCfg = Debug|x86
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|x86.Build.0 = Debug|x86
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|x86.Deploy.0 = Debug|x86
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|Win32.ActiveCfg = Release|x86
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|x64.ActiveCfg = Release|x64
+                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|x86.ActiveCfg = Release|x86
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Debug|Win32.ActiveCfg = Debug|x86
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Debug|x64.ActiveCfg = Debug|x64
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Debug|x86.ActiveCfg = Debug|x86
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Release|Win32.ActiveCfg = Release|x86
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Release|x64.ActiveCfg = Release|x64
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Release|x86.ActiveCfg = Release|x86
                         EndGlobalSection
                         GlobalSection(SolutionProperties) = preSolution
                             HideSolutionNode = FALSE
@@ -764,7 +817,7 @@ public void ConstructGraphWithSolution()
 
                 ProjectRootElement project1Xml = ProjectRootElement.Create();
 
-                // Project 1 depends on Project 2 using ProjectReference but there is a sln-based dependency defined on Project 3 as well.
+                // Project 1 depends on Project 2 using ProjectReference but there is a sln-based dependency defined on Project 3 and 8 as well.
                 project1Xml.AddItem("ProjectReference", "Project2.vcxproj");
 
                 ProjectRootElement project2Xml = ProjectRootElement.Create();
@@ -781,39 +834,52 @@ public void ConstructGraphWithSolution()
 
                 ProjectRootElement project4Xml = ProjectRootElement.Create();
                 ProjectRootElement project5Xml = ProjectRootElement.Create();
+                ProjectRootElement project6Xml = ProjectRootElement.Create();
+                ProjectRootElement project7Xml = ProjectRootElement.Create();
+                ProjectRootElement project8Xml = ProjectRootElement.Create();
 
                 string project1Path = Path.Combine(env.DefaultTestDirectory.Path, "Project1.csproj");
                 string project2Path = Path.Combine(env.DefaultTestDirectory.Path, "Project2.vcxproj");
                 string project3Path = Path.Combine(env.DefaultTestDirectory.Path, "Project3.vcxproj");
                 string project4Path = Path.Combine(env.DefaultTestDirectory.Path, "Project4.vcxproj");
                 string project5Path = Path.Combine(env.DefaultTestDirectory.Path, "Project5.vcxproj");
+                string project6Path = Path.Combine(env.DefaultTestDirectory.Path, "Project6.wapproj");
+                string project7Path = Path.Combine(env.DefaultTestDirectory.Path, "Project7.csproj");
+                string project8Path = Path.Combine(env.DefaultTestDirectory.Path, "Project8.csproj");
 
                 project1Xml.Save(project1Path);
                 project2Xml.Save(project2Path);
                 project3Xml.Save(project3Path);
                 project4Xml.Save(project4Path);
                 project5Xml.Save(project5Path);
+                project6Xml.Save(project6Path);
+                project7Xml.Save(project7Path);
+                project8Xml.Save(project8Path);
 
                 var projectGraph = new ProjectGraph(slnFile.Path);
-                projectGraph.EntryPointNodes.Count.ShouldBe(3);
-                projectGraph.GraphRoots.Count.ShouldBe(1);
-                projectGraph.GraphRoots.First().ProjectInstance.FullPath.ShouldBe(project1Path);
-                projectGraph.ProjectNodes.Count.ShouldBe(5);
+                projectGraph.EntryPointNodes.Count.ShouldBe(5);
+                projectGraph.EntryPointNodes.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project1Path, project2Path, project3Path, project6Path, project8Path }, ignoreOrder: true);
+                projectGraph.GraphRoots.Count.ShouldBe(2);
+                projectGraph.GraphRoots.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project1Path, project6Path }, ignoreOrder: true);
+                projectGraph.ProjectNodes.Count.ShouldBe(7);
 
                 ProjectGraphNode project1Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project1Path);
                 project1Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project1Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
-                project1Node.ProjectReferences.Count.ShouldBe(2);
+                project1Node.ProjectReferences.Count.ShouldBe(3);
+                project1Node.ProjectReferences.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project2Path, project3Path, project8Path }, ignoreOrder: true);
 
                 ProjectGraphNode project2Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project2Path);
                 project2Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project2Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
                 project2Node.ProjectReferences.Count.ShouldBe(1);
+                project2Node.ProjectReferences.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project4Path }, ignoreOrder: true);
 
                 ProjectGraphNode project3Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project3Path);
                 project3Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project3Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
                 project3Node.ProjectReferences.Count.ShouldBe(1);
+                project3Node.ProjectReferences.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project5Path }, ignoreOrder: true);
 
                 // Configuration and Platform get unset
                 ProjectGraphNode project4Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project4Path);
@@ -826,6 +892,20 @@ public void ConstructGraphWithSolution()
                 project5Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project5Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
                 project5Node.ProjectReferences.Count.ShouldBe(0);
+
+                // Project type other than "well-known" MSBuild project types.
+                ProjectGraphNode project6Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project6Path);
+                project6Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project6Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                project6Node.ProjectReferences.Count.ShouldBe(0);
+
+                // Project not included in the build
+                Assert.DoesNotContain(projectGraph.ProjectNodes, node => node.ProjectInstance.FullPath == project7Path);
+
+                ProjectGraphNode project8Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project8Path);
+                project8Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project8Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                project8Node.ProjectReferences.Count.ShouldBe(0);
             }
         }
 
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index 65ab4706791..c2f62879a4e 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -408,7 +408,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
         /// This method runs in two modes.
         /// When <param name="generateCacheFiles"></param> is true, the method will fill in the empty <param name="outputCaches"/> and <param name="expectedNodeBuildOutput"/>, simulating a build from scratch.
         /// When it is false, it uses the filled in <param name="outputCaches"/> and <param name="expectedNodeBuildOutput"/> to simulate a fully cached build.
-        /// 
+        ///
         /// </summary>
         /// <param name="env">The test environment under which to run.</param>
         /// <param name="topoSortedNodes"></param>
@@ -533,7 +533,7 @@ internal static TransientTestFile CreateProjectFileWithBuildTargetAndItems(
                                 ? $"Targets='{explicitTargets}'"
                                 : string.Empty)}
                             >
-                            <Output TaskParameter='TargetOutputs' ItemName='i' />  
+                            <Output TaskParameter='TargetOutputs' ItemName='i' />
                         </MSBuild>
                     </Target>");
 
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index c20134ea1dc..2c81f94f2cc 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -143,8 +143,8 @@ public void TestSpecificAffinityRegistration()
         }
 
         /// <summary>
-        /// Make sure we get the default affinity when the affinity map exists, but the specific 
-        /// project we're requesting is not set. 
+        /// Make sure we get the default affinity when the affinity map exists, but the specific
+        /// project we're requesting is not set.
         /// </summary>
         [Fact]
         public void TestDefaultAffinityWhenProjectNotRegistered()
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index da4fd47acd2..7c9a8b14f6c 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -235,7 +235,7 @@ static TaskItem BuildItem(
         }
 
         /// <summary>
-        /// Flushing an item through a task should not mess up special characters on the metadata. 
+        /// Flushing an item through a task should not mess up special characters on the metadata.
         /// </summary>
         [Fact]
         public void Escaping1()
@@ -287,7 +287,7 @@ public void Escaping1()
         }
 
         /// <summary>
-        /// Flushing an item through a task run in the task host also should not mess up special characters on the metadata. 
+        /// Flushing an item through a task run in the task host also should not mess up special characters on the metadata.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE || MONO
         [Fact(Skip = "FEATURE: TASKHOST")]
@@ -344,7 +344,7 @@ public void Escaping2()
         }
 
         /// <summary>
-        /// Flushing an item through a task run in the task host also should not mess up the escaping of the itemspec either. 
+        /// Flushing an item through a task run in the task host also should not mess up the escaping of the itemspec either.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE || MONO
         [Fact(Skip = "FEATURE: TASKHOST")]
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 92fc5c72239..dda2456a9f9 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -7,7 +7,7 @@
     <AssemblyName>Microsoft.Build.Engine.UnitTests</AssemblyName>
 
     <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_UNITTESTS</DefineConstants>
-    
+
     <!-- Define a constant so we can skip tests that require MSBuildTaskHost -->
     <DefineConstants Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(MonoBuild)' == 'true'">$(DefineConstants);NO_MSBUILDTASKHOST</DefineConstants>
 
@@ -21,16 +21,14 @@
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
-    <PackageReference Include="NuGet.Frameworks" >
+    <PackageReference Include="NuGet.Frameworks">
       <PrivateAssets>all</PrivateAssets>
     </PackageReference>
 
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
-    <ProjectReference Include="..\MSBuildTaskHost\MSBuildTaskHost.csproj"
-                      Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' != 'true'"
-                      Aliases="MSBuildTaskHost" />
+    <ProjectReference Include="..\MSBuildTaskHost\MSBuildTaskHost.csproj" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' != 'true'" Aliases="MSBuildTaskHost" />
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
@@ -48,67 +46,38 @@
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
     </ProjectReference>
 
-    <Reference Include="System.IO.Compression"
-               Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' " />
+    <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' " />
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\UnitTests\BuildEventArgsExtension.cs">
-      <!-- Extension methods -->
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\EscapingUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\ErrorUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\PrintLineDebugger_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\FileUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\FileMatcher_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\MockEngine.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\MockLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\ResourceUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\UnitTests\BuildEventArgsExtension.cs" />
+    <Compile Include="..\Shared\UnitTests\EscapingUtilities_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\ErrorUtilities_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\PrintLineDebugger_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\FileUtilities_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\FileMatcher_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\MockEngine.cs" />
+    <Compile Include="..\Shared\UnitTests\MockLogger.cs" />
+    <Compile Include="..\Shared\UnitTests\ResourceUtilities_Tests.cs" />
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
-    <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\StreamHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
+    <Compile Include="..\UnitTests.Shared\DriveMapping.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDrive.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDriveUtils.cs" />
+    <Compile Include="..\Shared\UnitTests\StreamHelpers.cs" />
     <Compile Include="..\Shared\UnitTests\EngineTestEnvironment.cs">
       <Link>EngineTestEnvironment.cs</Link>
     </Compile>
     <Compile Include="..\Shared\UnitTests\TestEnvironment.cs">
       <Link>TestEnvironment.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\UnitTests\TypeLoader_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\TypeLoader_Dependencies_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\UnitTests\TypeLoader_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\TypeLoader_Dependencies_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\XmakeAttributes_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
       <Link>XmakeAttributes_Tests.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\UnitTests\XmlUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\UnitTests\XmlUtilities_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\AssemblyNameEx_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
       <Link>AssemblyNameEx_Tests.cs</Link>
     </Compile>
     <Compile Include="..\Shared\UnitTests\TaskParameter_Tests.cs">
@@ -144,14 +113,14 @@
     <!-- In TypeLoader, the following logic is used for loading assemblies on .NET Core:
             - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded, indifferent of the user specified path
             - otherwise, the assembly from the user specified path is loaded, if it exists.
-            
+
           So the custom tasks we are testing can't be in test output folder, because on .NET Core that would affect the loading behavior.  So this
-          target puts them in subfolders of the test output folder instead.    
+          target puts them in subfolders of the test output folder instead.
     -->
 
     <Error Condition="'@(PortableTaskResolvedProjectReferencePath)' == ''" Text="Couldn't find PortableTaskResolvedProjectReferencePath item for PortableTask" />
     <Error Condition="'@(TaskWithDependencyResolvedProjectReferencePath)' == ''" Text="Couldn't find TaskWithDependencyResolvedProjectReferencePath item for TaskWithDependency" />
-    
+
     <PropertyGroup>
       <PortableTaskOutputPath>@(PortableTaskResolvedProjectReferencePath->'%(RootDir)%(Directory)')</PortableTaskOutputPath>
       <TaskWithDependencyOutputPath>@(TaskWithDependencyResolvedProjectReferencePath->'%(RootDir)%(Directory)')</TaskWithDependencyOutputPath>
@@ -163,7 +132,7 @@
       <TaskWithDependencyContentContent Include="$(TaskWithDependencyOutputPath)*.*" />
       <Content Include="@(TaskWithDependencyContentContent)" Link="TaskWithDependency\%(TaskWithDependencyContentContent.Filename)%(TaskWithDependencyContentContent.Extension)" CopyToOutputDirectory="PreserveNewest" />
     </ItemGroup>
-    
+
   </Target>
 
   <ItemDefinitionGroup>
@@ -171,7 +140,7 @@
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
   </ItemDefinitionGroup>
-  
+
   <ItemGroup>
     <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
   </ItemGroup>
diff --git a/src/Build.UnitTests/Parser_Tests.cs b/src/Build.UnitTests/Parser_Tests.cs
index 60dd1139123..81d505f3c2d 100644
--- a/src/Build.UnitTests/Parser_Tests.cs
+++ b/src/Build.UnitTests/Parser_Tests.cs
@@ -582,7 +582,7 @@ public void SupportItemDefinationGroupInWhenOtherwise(bool context)
             var metadatam = projectItem.GetMetadata("m");
             if (context)
             {
-                // Go to when 
+                // Go to when
                 Assert.Equal("m1", metadatam.EvaluatedValue);
             }
             else
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 6debe82528e..c994283bdbe 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -557,6 +557,7 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
@@ -674,6 +675,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
@@ -1440,6 +1442,7 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
@@ -1547,7 +1550,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
         // This test ensures that scheduling proxy builds on the inproc node works nicely within the Scheduler
         // if the BuildRequestConfigurations for those proxy builds have built before (or are still building) on
         // the out of proc node.
-        // More details: https://github.com/dotnet/msbuild/pull/6635 
+        // More details: https://github.com/dotnet/msbuild/pull/6635
         public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
         {
             var cacheNotApplicableTarget = "NATarget";
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 73774529835..aafe08827d9 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -2,9 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 // --------------------------------------------------------------------
-// 
+//
 // Copyright (c) Microsoft Corporation.  All rights reserved.
-// 
+//
 // --------------------------------------------------------------------
 
 using System;
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 36094ff2bec..55716f80a51 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -69,8 +69,8 @@ public void TargetARM()
         #region 32bit preferred
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), library type assemblies do not 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), library type assemblies do not
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPULibraryProjectIsNot32BitPreferred()
@@ -118,8 +118,8 @@ public void AnyCPULibraryProjectIsNot32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an explicit platform of anycpu, library type assemblies do not 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platform of anycpu, library type assemblies do not
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPULibraryProjectIsNot32BitPreferred()
@@ -168,8 +168,8 @@ public void ExplicitAnyCPULibraryProjectIsNot32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), winmdobj type assemblies do not 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), winmdobj type assemblies do not
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPUWinMDObjProjectIsNot32BitPreferred()
@@ -223,8 +223,8 @@ we need to be .NET 4.5 or greater -->
         }
 
         /// <summary>
-        /// Check that with an explicit platformtarget of anycpu, winmdobj type assemblies do not 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platformtarget of anycpu, winmdobj type assemblies do not
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
@@ -279,8 +279,8 @@ we need to be .NET 4.5 or greater -->
         }
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), exe type assemblies 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), exe type assemblies
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPUExeProjectIs32BitPreferred()
@@ -328,8 +328,8 @@ public void AnyCPUExeProjectIs32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an explicit platformtarget of anycpu, exe type assemblies 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platformtarget of anycpu, exe type assemblies
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPUExeProjectIs32BitPreferred()
@@ -378,8 +378,8 @@ public void ExplicitAnyCPUExeProjectIs32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), exe type assemblies 
-        /// that are targeting .NET 4.0 do not get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), exe type assemblies
+        /// that are targeting .NET 4.0 do not get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPU40ExeProjectIsNot32BitPreferred()
@@ -427,8 +427,8 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an explicit platformtarget of anycpu, exe type assemblies that are 
-        /// targeting .NET 4.0+ do not get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platformtarget of anycpu, exe type assemblies that are
+        /// targeting .NET 4.0+ do not get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPUExeProjectIsNot32BitPreferred()
@@ -477,8 +477,8 @@ public void ExplicitAnyCPUExeProjectIsNot32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an empty platformtarget (equivalent to anycpu), appcontainerexe type assemblies 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an empty platformtarget (equivalent to anycpu), appcontainerexe type assemblies
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void AnyCPUAppContainerExeProjectIs32BitPreferred()
@@ -532,8 +532,8 @@ public void AnyCPUAppContainerExeProjectIs32BitPreferred()
         }
 
         /// <summary>
-        /// Check that with an explicit platformtarget of anycpu, appcontainerexe type assemblies 
-        /// get forced to anycpu32bitpreferred by default. 
+        /// Check that with an explicit platformtarget of anycpu, appcontainerexe type assemblies
+        /// get forced to anycpu32bitpreferred by default.
         /// </summary>
         [Fact]
         public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
@@ -588,8 +588,8 @@ we need to be .NET 4.5 or greater -->
         }
 
         /// <summary>
-        /// Although AnyCPU library projects should not default to AnyCPU32BitPreferred, because that platform is 
-        /// not supported for library projects, if Prefer32Bit is explicitly set, we should still respect that. 
+        /// Although AnyCPU library projects should not default to AnyCPU32BitPreferred, because that platform is
+        /// not supported for library projects, if Prefer32Bit is explicitly set, we should still respect that.
         /// </summary>
         [Fact]
         public void AnyCPULibraryProjectIs32BitPreferredIfPrefer32BitSet()
@@ -639,8 +639,8 @@ public void AnyCPULibraryProjectIs32BitPreferredIfPrefer32BitSet()
         }
 
         /// <summary>
-        /// A project with no explicit OutputType will end up defaulting its OutputType to exe, 
-        /// so it should also default to Prefer32Bit = true. 
+        /// A project with no explicit OutputType will end up defaulting its OutputType to exe,
+        /// so it should also default to Prefer32Bit = true.
         /// </summary>
         [Fact]
         public void AnyCPUProjectWithNoExplicitOutputTypeIs32BitPreferred()
@@ -688,8 +688,8 @@ public void AnyCPUProjectWithNoExplicitOutputTypeIs32BitPreferred()
         }
 
         /// <summary>
-        /// A project with no explicit OutputType will end up defaulting its OutputType to exe, 
-        /// so it should also default to Prefer32Bit = true. 
+        /// A project with no explicit OutputType will end up defaulting its OutputType to exe,
+        /// so it should also default to Prefer32Bit = true.
         /// </summary>
         [Fact]
         public void AnyCPUJupiterProjectWithNoExplicitOutputTypeIs32BitPreferred()
@@ -740,7 +740,7 @@ public void AnyCPUJupiterProjectWithNoExplicitOutputTypeIs32BitPreferred()
         #endregion 32bit preferred
 
         /// <summary>
-        /// Validate that the GetFrameworkPaths target 
+        /// Validate that the GetFrameworkPaths target
         /// </summary>
         [Fact]
         public void TestGetFrameworkPaths()
@@ -774,7 +774,7 @@ public void TestGetFrameworkPaths()
         }
 
         /// <summary>
-        /// Validate that the GetFrameworkPaths target 
+        /// Validate that the GetFrameworkPaths target
         /// </summary>
         [Fact]
         public void TestTargetFrameworkPaths()
@@ -837,7 +837,7 @@ public void TestTargetFrameworkPaths()
         #region AssignLinkMetadata targets tests
 
         /// <summary>
-        /// Doesn't synthesize Link metadata if the items are defined in the project  
+        /// Doesn't synthesize Link metadata if the items are defined in the project
         /// </summary>
         [Fact]
         public void NoLinkMetadataSynthesisWhenDefinedInProject()
@@ -1057,8 +1057,8 @@ public void DontSynthesizeLinkMetadataIfPropertyNotSet()
 #if _NOT_YET_FULLY_CONVERTED_
         /// <summary>
         /// Tests that exercise the SplitResourcesByCulture Target in Microsoft.Common.targets.
-        /// This target's job is to separate the items that need to run through resgen from 
-        /// those that need to go directly into CSC. Also, Culture and non-Culture resources 
+        /// This target's job is to separate the items that need to run through resgen from
+        /// those that need to go directly into CSC. Also, Culture and non-Culture resources
         /// are split.
         /// </summary>
         [Test]
@@ -1080,11 +1080,11 @@ public void SplitResourcesByCultureTarget()
                       </ItemGroup>
                       <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                     </Project>
-                "); 
+                ");
 
             p.Build(new string [] {"SplitResourcesByCulture"}, null);
 
-            ProjectItem[] items = p.GetItems("EmbeddedResource").ToArray();                        
+            ProjectItem[] items = p.GetItems("EmbeddedResource").ToArray();
 
             Assert.AreEqual("Resource2.resx", items[0].EvaluatedInclude);
             Assert.AreEqual("false", items[0].GetMetadataValue("WithCulture"));
@@ -1202,10 +1202,10 @@ static int Main(string[] args)
                             try
                             {
 			                    ResourceManager rm;
-                    			
+
 			                    rm = new ResourceManager(`ConsoleApplication37.Strings1`, Assembly.GetExecutingAssembly());
 			                    Console.WriteLine(rm.GetString(`Usage`));
-                    			
+
 			                    rm = new ResourceManager(`MyStrings2`, Assembly.GetExecutingAssembly());
 			                    Console.WriteLine(String.Format(rm.GetString(`InvalidChildElement`), `Foo`));
 
@@ -1228,32 +1228,32 @@ static int Main(string[] args)
             // ----------------------------------------------------------------------------
             // Strings1.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings1.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings1.restext",
                 @"Usage=Hello world!  Isn't it a beautiful day?");
 
             // ----------------------------------------------------------------------------
             // Strings2.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings2.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings2.restext",
                 @"InvalidChildElement=The element {0} is not allowed here.");
 
             // ----------------------------------------------------------------------------
             // Subfolder\Strings3.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Subfolder\Strings3.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Subfolder\Strings3.restext",
                 @"CopyrightMessage=Copyright (C) 2005, The MSBuild Team");
 
             MockLogger logger = ObjectModelHelpers.BuildTempProjectFileExpectSuccess(@"ConsoleApplication37.csproj");
 
             string stdout = ObjectModelHelpers.RunTempProjectBuiltApplication(@"bin\debug\ConsoleApplication37.exe");
 
-            Assert.IsTrue(@"ConsoleApplication37.exe did not emit Usage string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication37.exe did not emit Usage string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("Hello world!  Isn't it a beautiful day?"));
 
-            Assert.IsTrue(@"ConsoleApplication37.exe did not emit InvalidChildElement string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication37.exe did not emit InvalidChildElement string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("The element Foo is not allowed here."));
 
-            Assert.IsTrue(@"ConsoleApplication37.exe did not emit CopyrightMessage string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication37.exe did not emit CopyrightMessage string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("Copyright (C) 2005, The MSBuild Team"));
         }
 
@@ -1362,32 +1362,32 @@ End Module
             // ----------------------------------------------------------------------------
             // Strings1.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings1.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings1.restext",
                 @"Usage=Hello world!  Isn't it a beautiful day?");
 
             // ----------------------------------------------------------------------------
             // Strings2.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings2.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Strings2.restext",
                 @"InvalidChildElement=The element {0} is not allowed here.");
 
             // ----------------------------------------------------------------------------
             // Subfolder\Strings3.restext
             // ----------------------------------------------------------------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Subfolder\Strings3.restext", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Subfolder\Strings3.restext",
                 @"CopyrightMessage=Copyright (C) 2005, The MSBuild Team");
 
             MockLogger logger = ObjectModelHelpers.BuildTempProjectFileExpectSuccess(@"ConsoleApplication38.vbproj");
 
             string stdout = ObjectModelHelpers.RunTempProjectBuiltApplication(@"bin\debug\ConsoleApplication38.exe");
 
-            Assert.IsTrue(@"ConsoleApplication38.exe did not emit Usage string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication38.exe did not emit Usage string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("Hello world!  Isn't it a beautiful day?"));
 
-            Assert.IsTrue(@"ConsoleApplication38.exe did not emit InvalidChildElement string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication38.exe did not emit InvalidChildElement string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("The element Foo is not allowed here."));
 
-            Assert.IsTrue(@"ConsoleApplication38.exe did not emit CopyrightMessage string.  See test output (Attachments in Azure Pipelines) for details.", 
+            Assert.IsTrue(@"ConsoleApplication38.exe did not emit CopyrightMessage string.  See test output (Attachments in Azure Pipelines) for details.",
                 stdout.Contains("Copyright (C) 2005, The MSBuild Team"));
         }
     }
@@ -1411,16 +1411,16 @@ public void Regress381480()
             try
             {
                 Project p0 = ObjectModelHelpers.CreateInMemoryProject(@"
-    
-                        <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+
+                        <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                             <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                         </Project>
 
                     ");
 
                 Project p1 = ObjectModelHelpers.CreateInMemoryProject(@"
-    
-                        <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+
+                        <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                            <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                         </Project>
 
@@ -1451,7 +1451,7 @@ public void Regress381480()
     /// building) returning the name of the EXE or DLL that would be built.
     /// </summary>
     [TestFixture]
-    sealed public class GetTargetPath        
+    sealed public class GetTargetPath
     {
         /// <summary>
         /// Try a basic workings.
@@ -1461,7 +1461,7 @@ public void Basic()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>bin\Debug\</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -1473,23 +1473,23 @@ public void Basic()
                       </ItemGroup>
                       <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                    </Project>
-                ");            
-            
+                ");
+
             Hashtable h = new Hashtable();
             p.Build(new string[] {"GetTargetPath" }, h);
             ObjectModelHelpers.AssertSingleItemInDictionary(h, "<|proj|>bin\\Debug\\MyAssembly.exe");
         }
-    }    
+    }
 
     /// <summary>
-    /// Tests that exercise the PrepareResourceNames Target in 
+    /// Tests that exercise the PrepareResourceNames Target in
     /// Microsoft.VisualBasic.targets.
-    /// 
+    ///
     /// This target's job is to create manifest resource names for each of
     /// the resource files.
     /// </summary>
     [TestFixture]
-    sealed public class PrepareResourceNamesTarget        
+    sealed public class PrepareResourceNamesTarget
     {
         /// <summary>
         /// Basic test.
@@ -1499,7 +1499,7 @@ public void BasicVbResourceNames()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>bin\Debug\</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -1516,11 +1516,11 @@ public void BasicVbResourceNames()
                       </ItemGroup>
                       <Import Project=`$(MSBuildBinPath)\Microsoft.VisualBasic.targets` />
                     </Project>
-                ");            
+                ");
 
             p.Build(new string [] {"PrepareResourceNames"}, null);
 
-            ProjectItem[] items = p.GetItems("EmbeddedResource").ToArray();            
+            ProjectItem[] items = p.GetItems("EmbeddedResource").ToArray();
 
             Assert.AreEqual("Resource2.resx", items[0].EvaluatedInclude);
             Assert.AreEqual("false", items[0].GetMetadataValue("WithCulture"));
@@ -1530,7 +1530,7 @@ public void BasicVbResourceNames()
             Assert.AreEqual("Resource2.fr.resx", items[1].EvaluatedInclude);
             Assert.AreEqual("true", items[1].GetMetadataValue("WithCulture"));
             Assert.AreEqual("Resx", items[1].GetMetadataValue("Type"));
-            Assert.AreEqual("MyNamespace.Resource2.fr", items[1].GetMetadataValue("ManifestResourceName"));            
+            Assert.AreEqual("MyNamespace.Resource2.fr", items[1].GetMetadataValue("ManifestResourceName"));
 
             Assert.AreEqual("Resource1.txt", items[2].EvaluatedInclude);
             Assert.AreEqual("false", items[2].GetMetadataValue("WithCulture"));
@@ -1597,7 +1597,7 @@ public void CopyAppConfigFileEvenForDllProjects()
                     <Folder Include=`Properties\` />
                 </ItemGroup>
                 <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
-                <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                     Other similar extension points exist, see Microsoft.Common.targets.
                 <Target Name=`BeforeBuild`>
                 </Target>
@@ -1606,7 +1606,7 @@ public void CopyAppConfigFileEvenForDllProjects()
                 -->
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -1618,7 +1618,7 @@ public void CopyAppConfigFileEvenForDllProjects()
                 using System.Runtime.CompilerServices;
                 using System.Runtime.InteropServices;
 
-                // General Information about an assembly is controlled through the following 
+                // General Information about an assembly is controlled through the following
                 // set of attributes. Change these attribute values to modify the information
                 // associated with an assembly.
                 [assembly: AssemblyTitle(`ClassLibrary16`)]
@@ -1630,8 +1630,8 @@ public void CopyAppConfigFileEvenForDllProjects()
                 [assembly: AssemblyTrademark(``)]
                 [assembly: AssemblyCulture(``)]
 
-                // Setting ComVisible to false makes the types in this assembly not visible 
-                // to COM components.  If you need to access a type in this assembly from 
+                // Setting ComVisible to false makes the types in this assembly not visible
+                // to COM components.  If you need to access a type in this assembly from
                 // COM, set the ComVisible attribute to true on that type.
                 [assembly: ComVisible(false)]
 
@@ -1641,11 +1641,11 @@ public void CopyAppConfigFileEvenForDllProjects()
                 // Version information for an assembly consists of the following four values:
                 //
                 //      Major Version
-                //      Minor Version 
+                //      Minor Version
                 //      Build Number
                 //      Revision
                 //
-                // You can specify all the values or you can default the Revision and Build Numbers 
+                // You can specify all the values or you can default the Revision and Build Numbers
                 // by using the '*' as shown below:
                 [assembly: AssemblyVersion(`1.0.0.0`)]
                 [assembly: AssemblyFileVersion(`1.0.0.0`)]
@@ -1695,7 +1695,7 @@ public void AppConfigLocation()
             e.SetGlobalProperty("case", "0"); // Make project loadable
             Project p = ObjectModelHelpers.CreateInMemoryProject(e, @"
 
-                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputType>Library</OutputType>
                         <AssemblyName>foo</AssemblyName>
@@ -1728,7 +1728,7 @@ public void AppConfigLocation()
             p.Build(new string[] { "PrepareForBuild" });
             item = ObjectModelHelpers.AssertSingleItem(p, "AppConfigWithTargetPath", "app.config");
             Assert.AreEqual("foo.dll.config", item.GetMetadataValue("TargetPath"));
-            
+
             ///    (4) Choose @(None) App.Config in any subfolder in the project.
             p.SetGlobalProperty("case", "4");
             p.Build(new string[] { "PrepareForBuild" });
@@ -1758,7 +1758,7 @@ public void AppConfigLocationRelativeDir()
             ProjectCollection e = new ProjectCollection();
             Project p = ObjectModelHelpers.CreateInMemoryProject(e, @"
 
-                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputType>Library</OutputType>
                         <AssemblyName>foo</AssemblyName>
@@ -1786,7 +1786,7 @@ public void AppConfigLocationNoneWinsOverContent()
             ProjectCollection e = new ProjectCollection();
             Project p = ObjectModelHelpers.CreateInMemoryProject(e, @"
 
-                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`> 
+                   <Project ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputType>Library</OutputType>
                         <AssemblyName>foo</AssemblyName>
@@ -1853,7 +1853,7 @@ public void ConfigurationsReferencedInCSharpProject()
                     </ItemGroup>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-                ");            
+                ");
 
             string[] configurations = p.GetConditionedProperties("Configuration");
 
@@ -1944,7 +1944,7 @@ public void ConfigurationsReferencedInVBProject()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.VisualBasic.targets` />
                 </Project>
 
-                ");            
+                ");
 
             string[] configurations = p.GetConditionedProperties("Configuration");
 
@@ -1954,10 +1954,10 @@ public void ConfigurationsReferencedInVBProject()
         }
 
         /// <summary>
-        /// This is the infamous path-too-long problem.  All absolute paths in question are within 
-        /// the 260 character limit that the filesystem imposes.  However, when paths are accessed 
+        /// This is the infamous path-too-long problem.  All absolute paths in question are within
+        /// the 260 character limit that the filesystem imposes.  However, when paths are accessed
         /// using relative paths, sometimes the simple concatenation of the current directory with the
-        /// relative path can exceed 260 characters.  MSBuild should solve this scenario by doing 
+        /// relative path can exceed 260 characters.  MSBuild should solve this scenario by doing
         /// smarter path manipulation.
         /// </summary>
         [Test]
@@ -1972,7 +1972,7 @@ public void ProjectToProjectReferenceWithLongRelativePath()
             // minus 55 to leave room for ConsoleApp\obj\debug\ResolveAssemblyReference.cache
             // div 4 because that's how much each subdir costs.
             int MAX_PATH = 260;
-            int numberOfSubDirectoriesToCreate = (MAX_PATH - tempProjectRoot.Length - 55) / 4;  
+            int numberOfSubDirectoriesToCreate = (MAX_PATH - tempProjectRoot.Length - 55) / 4;
             StringBuilder deepRelativePath = new StringBuilder();
             for (int i = 0 ; i < numberOfSubDirectoriesToCreate ; i++)
             {
@@ -2087,7 +2087,7 @@ static void Main(string[] args)
                     </ItemGroup>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                     <!-- The old OM, which is what this solution is being built under, doesn't understand
-                         BeforeTargets, so this test was failing, because _AssignManagedMetadata was set 
+                         BeforeTargets, so this test was failing, because _AssignManagedMetadata was set
                          up as a BeforeTarget for Build.  Copied here so that build will return the correct
                          information again. -->
                     <Target Name=`BeforeBuild`>
@@ -2133,7 +2133,7 @@ public void SolutionConfigurationWithDifferentProjectConfigurations()
             // ==================================================================
             // SOLUTION1.SLN
             // ==================================================================
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("Solution1.sln", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("Solution1.sln",
                 @"Microsoft Visual Studio Solution File, Format Version 9.00
                  Visual Studio 2005
                 Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `CSharpClassLib`, `CSharpClassLib\CSharpClassLib.csproj`, `{9FB32A10-FA44-4DD3-ABA8-5215CF599BD6}`
@@ -2228,7 +2228,7 @@ Visual Studio 2005
                     <Folder Include=`Properties\` />
                   </ItemGroup>
                   <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=`BeforeBuild`>
                   </Target>
@@ -2296,7 +2296,7 @@ public class Class1
                     <Folder Include=`Properties\` />
                   </ItemGroup>
                   <Import Project=`$(MSBuildBinPath)\Microsoft.VisualJSharp.targets` />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=`BeforeBuild`>
                   </Target>
@@ -2417,7 +2417,7 @@ public void SkipProducingPdbCsharp()
             l = ObjectModelHelpers.BuildTempProjectFileWithTargetsExpectSuccess(@"ConsoleApplication\ConsoleApplication.csproj", null, additionalProperties, true);
             l.AssertLogContains("/debug+");
             l.AssertLogContains("/debug:pdbonly");
-            ObjectModelHelpers.AssertFileExistsInTempProjectDirectory(@"ConsoleApplication\bin\release\ConsoleApplication.pdb");        
+            ObjectModelHelpers.AssertFileExistsInTempProjectDirectory(@"ConsoleApplication\bin\release\ConsoleApplication.pdb");
         }
 
         /// <summary>
@@ -2670,7 +2670,7 @@ internal static void CreateTempVBProject()
                     <Compile Include=""Module1.vb"" />
                   </ItemGroup>
                   <Import Project=""$(MSBuildBinPath)\Microsoft.VisualBasic.targets"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
index 84e458f6a54..6266cb6e4c7 100644
--- a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -23,12 +23,10 @@ public class TerminalLoggerConfiguration_Tests : IDisposable
     private readonly TestEnvironment _env;
 
     private readonly string _cmd;
-    private readonly ITestOutputHelper _output;
 
     public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)
     {
         _env = TestEnvironment.Create(output);
-        _output = output;
 
         // Ignore environment variables that may have been set by the environment where the tests are running.
         _env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
@@ -72,8 +70,7 @@ public void TerminalLoggerOn(string tlValue)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -103,8 +100,7 @@ public void TerminalLoggerWithTlAutoIsOff(string tlValue)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -113,7 +109,6 @@ public void TerminalLoggerWithTlAutoIsOff(string tlValue)
         ShouldNotBeTerminalLog(output);
     }
 
-
     [Fact]
     public void TerminalLoggerDefaultByEnv()
     {
@@ -132,8 +127,7 @@ public void TerminalLoggerDefaultByEnv()
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -162,8 +156,7 @@ public void TerminalLoggerOnByEnv(string envVarSource)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -191,8 +184,7 @@ public void TerminalLoggerDefaultOn(string defaultValue)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -218,12 +210,11 @@ public void TerminalLoggerDefaultOff(string defaultValue)
             TerminalLoggerUserIntentSource = null,
             ConsoleLogger = true,
             ConsoleLoggerVerbosity = "minimal",
-            ConsoleLoggerType = "parallel", 
+            ConsoleLoggerType = "parallel",
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -232,6 +223,23 @@ public void TerminalLoggerDefaultOff(string defaultValue)
         ShouldNotBeTerminalLog(output);
     }
 
+    [Theory]
+    [InlineData("1")]
+    [InlineData("0")]
+    public void TerminalLoggerOnInvalidProjectBuild(string msbuildinprocnodeState)
+    {
+        _ = _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", msbuildinprocnodeState);
+
+        string output = RunnerUtilities.ExecMSBuild(
+            $"{_cmd} -tl:true",
+            out bool success);
+
+        success.ShouldBeTrue();
+        ShouldBeTerminalLog(output);
+        output.ShouldContain("Build succeeded.");
+    }
+
     private static void ShouldBeTerminalLog(string output) => output.ShouldContain("\x1b[?25l");
+
     private static void ShouldNotBeTerminalLog(string output) => output.ShouldNotContain("\x1b[?25l");
 }
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index d6ded939073..491ad832358 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -101,7 +101,7 @@ public void CommentsInPreprocessing()
             bool foundDoNotModify = false;
             foreach (string line in File.ReadLines(outputFile.Path))
             {
-                line.ShouldNotContain("<!---->", "This is what it will look like if we're loading read/only");
+                line.ShouldNotContain("<!---->", customMessage: "This is what it will look like if we're loading read/only");
 
                 if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
                 {
@@ -170,7 +170,7 @@ public void RepeatedProjectExtensions()
             Assert.Throws<InvalidProjectFileException>(() =>
             {
                 ObjectModelHelpers.CreateInMemoryProject(@"
-                <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                     <ProjectExtensions/>
                     <Import Project=`$(MSBuildBinPath)\\Microsoft.CSharp.Targets` />
                     <ProjectExtensions/>
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index dc353692197..db2d9eab3ad 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -358,7 +358,7 @@ public void TaskLogsWarningAsError_BatchedBuild()
                 logger.WarningCount.ShouldBe(2);
                 logger.ErrorCount.ShouldBe(1);
 
-                // The build should STOP when a task logs an error, make sure ReturnFailureWithoutLoggingErrorTask doesn't run. 
+                // The build should STOP when a task logs an error, make sure ReturnFailureWithoutLoggingErrorTask doesn't run.
                 logger.AssertLogDoesntContain("MSB1237");
             }
         }
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 40a6964c0e5..86a5a8073d2 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -32,3 +32,6 @@
 
 [assembly: ComVisible(false)]
 [assembly: CLSCompliant(true)]
+
+[assembly: Dependency("BuildXL.Utilities.Core", LoadHint.Sometimes)]
+[assembly: Dependency("BuildXL.Processes", LoadHint.Sometimes)]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 4c8bda783c3..b2aae4fb743 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -13,6 +13,7 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using System.Runtime.ExceptionServices;
 using System.Threading;
 using System.Threading.Tasks;
@@ -25,6 +26,7 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Graph;
@@ -116,7 +118,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// Set of active nodes in the system.
         /// </summary>
-        private readonly HashSet<NGen<int>> _activeNodes;
+        private readonly HashSet<int> _activeNodes;
 
         /// <summary>
         /// Event signalled when all nodes have shutdown.
@@ -126,7 +128,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// Mapping of nodes to the configurations they know about.
         /// </summary>
-        private readonly Dictionary<NGen<int>, HashSet<NGen<int>>> _nodeIdToKnownConfigurations;
+        private readonly Dictionary<int, HashSet<int>> _nodeIdToKnownConfigurations;
 
         /// <summary>
         /// Flag indicating if we are currently shutting down.  When set, we stop processing packets other than NodeShutdown.
@@ -299,9 +301,9 @@ public BuildManager(string hostName)
             _buildSubmissions = new Dictionary<int, BuildSubmission>();
             _graphBuildSubmissions = new Dictionary<int, GraphBuildSubmission>();
             _noActiveSubmissionsEvent = new AutoResetEvent(true);
-            _activeNodes = new HashSet<NGen<int>>();
+            _activeNodes = new HashSet<int>();
             _noNodesActiveEvent = new AutoResetEvent(true);
-            _nodeIdToKnownConfigurations = new Dictionary<NGen<int>, HashSet<NGen<int>>>();
+            _nodeIdToKnownConfigurations = new Dictionary<int, HashSet<int>>();
             _unnamedProjectInstanceToNames = new Dictionary<ProjectInstance, string>();
             _nextUnnamedProjectId = 1;
             _componentFactories = new BuildComponentFactoryCollection(this);
@@ -558,6 +560,13 @@ public void BeginBuild(BuildParameters parameters)
                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath("msbuild-cache");
                 }
 
+#if FEATURE_REPORTFILEACCESSES
+                if (_buildParameters.ReportFileAccesses)
+                {
+                    EnableDetouredNodeLauncher();
+                }
+#endif
+
                 // Initialize components.
                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
 
@@ -567,14 +576,21 @@ public void BeginBuild(BuildParameters parameters)
                 LogDeferredMessages(loggingService, _deferredBuildMessages);
 
                 // Log known deferred telemetry
-                KnownTelemetry.LoggingConfigurationTelemetry.UpdateEventProperties();
-                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.Properties);
+                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.GetProperties());
 
                 InitializeCaches();
 
+#if FEATURE_REPORTFILEACCESSES
+                var fileAccessManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager) as IFileAccessManager;
+#endif
+
                 _projectCacheService = new ProjectCacheService(
                     this,
                     loggingService,
+#if FEATURE_REPORTFILEACCESSES
+                    fileAccessManager,
+#endif
+                    _configCache,
                     _buildParameters.ProjectCacheDescriptor);
 
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
@@ -584,7 +600,9 @@ public void BeginBuild(BuildParameters parameters)
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfiguration, BuildRequestConfiguration.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse, BuildRequestConfigurationResponse.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildResult, BuildResult.FactoryForDeserialization, this);
+                _nodeManager.RegisterPacketHandler(NodePacketType.FileAccessReport, FileAccessReport.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.NodeShutdown, NodeShutdown.FactoryForDeserialization, this);
+                _nodeManager.RegisterPacketHandler(NodePacketType.ProcessReport, ProcessReport.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResolveSdkRequest, SdkResolverRequest.FactoryForDeserialization, SdkResolverService as INodePacketHandler);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResourceRequest, ResourceRequest.FactoryForDeserialization, this);
 
@@ -699,6 +717,29 @@ void InitializeCaches()
             }
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Configure the build to use I/O tracking for nodes.
+        /// </summary>
+        /// <remarks>
+        /// Must be a separate non-inlinable method to avoid loading the BuildXL assembly when not opted in.
+        /// </remarks>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        private void EnableDetouredNodeLauncher()
+        {
+            // Currently BuildXL only supports x64. Once this feature moves out of the experimental phase, this will need to be addressed.
+            ErrorUtilities.VerifyThrowInvalidOperation(NativeMethodsShared.ProcessorArchitecture == NativeMethodsShared.ProcessorArchitectures.X64, "ReportFileAccessesX64Only");
+
+            // To properly report file access, we need to disable the in-proc node which won't be detoured.
+            _buildParameters.DisableInProcNode = true;
+
+            // Node reuse must be disabled as future builds will not be able to listen to events raised by detours.
+            _buildParameters.EnableNodeReuse = false;
+
+            _componentFactories.ReplaceFactory(BuildComponentType.NodeLauncher, DetouredNodeLauncher.CreateComponent);
+        }
+#endif
+
         private static void AttachDebugger()
         {
             if (Debugger.IsAttached)
@@ -1048,8 +1089,7 @@ public void EndBuild()
                             }
                             _buildTelemetry.Host = host;
 
-                            _buildTelemetry.UpdateEventProperties();
-                            loggingService.LogTelemetry(buildEventContext: null, _buildTelemetry.EventName, _buildTelemetry.Properties);
+                            loggingService.LogTelemetry(buildEventContext: null, _buildTelemetry.EventName, _buildTelemetry.GetProperties());
                             // Clean telemetry to make it ready for next build submission.
                             _buildTelemetry = null;
                         }
@@ -1411,13 +1451,20 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
             }
 
             ErrorUtilities.VerifyThrow(FileUtilities.IsSolutionFilename(config.ProjectFullPath), "{0} is not a solution", config.ProjectFullPath);
+
+            var buildEventContext = request.BuildEventContext;
+            if (buildEventContext == BuildEventContext.Invalid)
+            {
+                buildEventContext = new BuildEventContext(request.SubmissionId, 0, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            }
+
             var instances = ProjectInstance.LoadSolutionForBuild(
                 config.ProjectFullPath,
                 config.GlobalProperties,
                 config.ExplicitToolsVersionSpecified ? config.ToolsVersion : null,
                 _buildParameters,
                 ((IBuildComponentHost)this).LoggingService,
-                request.BuildEventContext,
+                buildEventContext,
                 false /* loaded by solution parser*/,
                 config.RequestedTargets,
                 SdkResolverService,
@@ -1564,6 +1611,16 @@ private void ProcessPacket(int node, INodePacket packet)
                         HandleNodeShutdown(node, shutdownPacket);
                         break;
 
+                    case NodePacketType.FileAccessReport:
+                        FileAccessReport fileAccessReport = ExpectPacketType<FileAccessReport>(packet, NodePacketType.FileAccessReport);
+                        HandleFileAccessReport(node, fileAccessReport);
+                        break;
+
+                    case NodePacketType.ProcessReport:
+                        ProcessReport processReport = ExpectPacketType<ProcessReport>(packet, NodePacketType.ProcessReport);
+                        HandleProcessReport(node, processReport);
+                        break;
+
                     default:
                         ErrorUtilities.ThrowInternalError("Unexpected packet received by BuildManager: {0}", packet.Type);
                         break;
@@ -2342,9 +2399,9 @@ private void HandleConfigurationRequest(int node, BuildRequestConfiguration unre
 
             var response = new BuildRequestConfigurationResponse(unresolvedConfiguration.ConfigurationId, resolvedConfiguration.ConfigurationId, resolvedConfiguration.ResultsNodeId);
 
-            if (!_nodeIdToKnownConfigurations.TryGetValue(node, out HashSet<NGen<int>> configurationsOnNode))
+            if (!_nodeIdToKnownConfigurations.TryGetValue(node, out HashSet<int> configurationsOnNode))
             {
-                configurationsOnNode = new HashSet<NGen<int>>();
+                configurationsOnNode = new HashSet<int>();
                 _nodeIdToKnownConfigurations[node] = configurationsOnNode;
             }
 
@@ -2371,6 +2428,39 @@ private void HandleResult(int node, BuildResult result)
                 configuration.ProjectTargets ??= result.ProjectTargets;
             }
 
+            // Only report results to the project cache services if it's the result for a build submission.
+            // Note that graph builds create a submission for each node in the graph, so each node in the graph will be
+            // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to
+            // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that
+            // would require moving the cache service interactions to the Scheduler.
+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))
+            {
+                // The result may be associated with the build submission due to it being the submission which
+                // caused the build, but not the actual request which was originally used with the build submission.
+                // ie. it may be a dependency of the "root-level" project which is associated with this submission, which
+                // isn't what we're looking for. Ensure only the actual submission's request is considered.
+                if (buildSubmission.BuildRequest != null
+                    && buildSubmission.BuildRequest.ConfigurationId == configuration.ConfigurationId
+                    && _projectCacheService.ShouldUseCache(configuration))
+                {
+                    BuildEventContext buildEventContext = _projectStartedEvents.TryGetValue(result.SubmissionId, out BuildEventArgs buildEventArgs)
+                        ? buildEventArgs.BuildEventContext
+                        : new BuildEventContext(result.SubmissionId, node, configuration.Project?.EvaluationId ?? BuildEventContext.InvalidEvaluationId, configuration.ConfigurationId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                    try
+                    {
+                        _projectCacheService.HandleBuildResultAsync(configuration, result, buildEventContext, _executionCancellationTokenSource.Token).Wait();
+                    }
+                    catch (AggregateException ex) when (ex.InnerExceptions.All(inner => inner is OperationCanceledException))
+                    {
+                        // The build is being cancelled. Swallow any exceptions related specifically to cancellation.
+                    }
+                    catch (OperationCanceledException)
+                    {
+                        // The build is being cancelled. Swallow any exceptions related specifically to cancellation.
+                    }
+                }
+            }
+
             IEnumerable<ScheduleResponse> response = _scheduler.ReportResult(node, result);
             PerformSchedulingActions(response);
         }
@@ -2437,6 +2527,36 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             CheckForActiveNodesAndCleanUpSubmissions();
         }
 
+        /// <summary>
+        /// Report the received <paramref name="fileAccessReport"/> to the file access manager.
+        /// </summary>
+        /// <param name="nodeId">The id of the node from which the <paramref name="fileAccessReport"/> was received.</param>
+        /// <param name="fileAccessReport">The file access report.</param>
+        private void HandleFileAccessReport(int nodeId, FileAccessReport fileAccessReport)
+        {
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessReport.FileAccessData, nodeId);
+            }
+#endif
+        }
+
+        /// <summary>
+        /// Report the received <paramref name="processReport"/> to the file access manager.
+        /// </summary>
+        /// <param name="nodeId">The id of the node from which the <paramref name="processReport"/> was received.</param>
+        /// <param name="processReport">The process data report.</param>
+        private void HandleProcessReport(int nodeId, ProcessReport processReport)
+        {
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportProcess(processReport.ProcessData, nodeId);
+            }
+#endif
+        }
+
         /// <summary>
         /// If there are no more active nodes, cleans up any remaining submissions.
         /// </summary>
@@ -2549,7 +2669,7 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                             // of which nodes have had configurations specifically assigned to them for building.  However, a node may
                             // have created a configuration based on a build request it needs to wait on.  In this
                             // case we need not send the configuration since it will already have been mapped earlier.
-                            if (!_nodeIdToKnownConfigurations.TryGetValue(response.NodeId, out HashSet<NGen<int>> configurationsOnNode) ||
+                            if (!_nodeIdToKnownConfigurations.TryGetValue(response.NodeId, out HashSet<int> configurationsOnNode) ||
                                !configurationsOnNode.Contains(response.BuildRequest.ConfigurationId))
                             {
                                 IConfigCache configCache = _componentFactories.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 8d7a8268648..582532e5795 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -220,6 +220,8 @@ public class BuildParameters : ITranslatable
 
         private string _outputResultsCacheFile;
 
+        private bool _reportFileAccesses;
+
         /// <summary>
         /// Constructor for those who intend to set all properties themselves.
         /// </summary>
@@ -303,6 +305,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _projectIsolationMode = other.ProjectIsolationMode;
             _inputResultsCacheFiles = other._inputResultsCacheFiles;
             _outputResultsCacheFile = other._outputResultsCacheFile;
+            _reportFileAccesses = other._reportFileAccesses;
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
             Question = other.Question;
@@ -801,6 +804,17 @@ public string OutputResultsCacheFile
             set => _outputResultsCacheFile = value;
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.
+        /// </summary>
+        public bool ReportFileAccesses
+        {
+            get => _reportFileAccesses;
+            set => _reportFileAccesses = value;
+        }
+#endif
+
         /// <summary>
         /// Determines whether MSBuild will save the results of builds after EndBuild to speed up future builds.
         /// </summary>
@@ -885,6 +899,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _interactive);
             translator.Translate(ref _question);
             translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
+            translator.Translate(ref _reportFileAccesses);
 
             // ProjectRootElementCache is not transmitted.
             // ResetCaches is not transmitted.
diff --git a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
index cb4464c8460..5670a61e3f1 100644
--- a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
+++ b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
@@ -19,10 +19,10 @@ internal class LegacyThreadingData
     {
         #region Fields
         /// <summary>
-        /// Store the pair of start/end events used by a particular submission to track their ownership 
-        /// of the legacy thread. 
-        /// Item1: Start event, tracks when the submission has permission to start building. 
-        /// Item2: End event, signalled when that submission is no longer using the legacy thread. 
+        /// Store the pair of start/end events used by a particular submission to track their ownership
+        /// of the legacy thread.
+        /// Item1: Start event, tracks when the submission has permission to start building.
+        /// Item2: End event, signalled when that submission is no longer using the legacy thread.
         /// </summary>
         private readonly IDictionary<int, Tuple<AutoResetEvent, ManualResetEvent>> _legacyThreadingEventsById = new Dictionary<int, Tuple<AutoResetEvent, ManualResetEvent>>();
 
@@ -37,8 +37,8 @@ internal class LegacyThreadingData
         private RequestBuilder _instanceForMainThread;
 
         /// <summary>
-        /// Lock object for startNewRequestBuilderMainThreadEventsById, since it's possible for multiple submissions to be 
-        /// submitted at the same time. 
+        /// Lock object for startNewRequestBuilderMainThreadEventsById, since it's possible for multiple submissions to be
+        /// submitted at the same time.
         /// </summary>
         private readonly Object _legacyThreadingEventsLock = new Object();
         #endregion
@@ -79,7 +79,7 @@ internal int MainThreadSubmissionId
         #endregion
 
         /// <summary>
-        /// Given a submission ID, assign it "start" and "finish" events to track its use of 
+        /// Given a submission ID, assign it "start" and "finish" events to track its use of
         /// the legacy thread.
         /// </summary>
         internal void RegisterSubmissionForLegacyThread(int submissionId)
@@ -95,8 +95,8 @@ internal void RegisterSubmissionForLegacyThread(int submissionId)
         }
 
         /// <summary>
-        /// This submission is completely done with the legacy thread, so unregister it 
-        /// from the dictionary so that we don't leave random events lying around. 
+        /// This submission is completely done with the legacy thread, so unregister it
+        /// from the dictionary so that we don't leave random events lying around.
         /// </summary>
         internal void UnregisterSubmissionForLegacyThread(int submissionId)
         {
@@ -109,8 +109,8 @@ internal void UnregisterSubmissionForLegacyThread(int submissionId)
         }
 
         /// <summary>
-        /// Given a submission ID, return the event being used to track when that submission is ready 
-        /// to be executed on the legacy thread. 
+        /// Given a submission ID, return the event being used to track when that submission is ready
+        /// to be executed on the legacy thread.
         /// </summary>
         internal WaitHandle GetStartRequestBuilderMainThreadEventForSubmission(int submissionId)
         {
@@ -127,8 +127,8 @@ internal WaitHandle GetStartRequestBuilderMainThreadEventForSubmission(int submi
         }
 
         /// <summary>
-        /// Given a submission ID, return the event being used to track when that submission is ready 
-        /// to be executed on the legacy thread. 
+        /// Given a submission ID, return the event being used to track when that submission is ready
+        /// to be executed on the legacy thread.
         /// </summary>
         internal Task GetLegacyThreadInactiveTask(int submissionId)
         {
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 693912475d0..642f1b1b024 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -225,7 +225,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
 
                 ReadPacketsLoop(cancellationToken);
 
-                MSBuildEventSource.Log.MSBuildServerBuildStop(descriptiveCommandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);
+                MSBuildEventSource.Log.MSBuildServerBuildStop(descriptiveCommandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString ?? string.Empty);
                 CommunicationsUtilities.Trace("Build finished.");
             }
 
@@ -437,7 +437,7 @@ private bool TrySendPacket(Func<INodePacket> packetResolver)
         }
 
         /// <summary>
-        /// Launches MSBuild server. 
+        /// Launches MSBuild server.
         /// </summary>
         /// <returns> Whether MSBuild server was started successfully.</returns>
         private bool TryLaunchServer()
@@ -473,7 +473,7 @@ private bool TryLaunchServer()
                 };
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
-                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions));
+                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
                 CommunicationsUtilities.Trace("Server started with PID: {0}", msbuildProcess?.Id);
             }
             catch (Exception ex)
@@ -511,7 +511,7 @@ private ServerNodeBuildCommand GetServerNodeBuildCommand()
                 envVars[pair.Key] = pair.Value;
             }
 
-            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. 
+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here.
             envVars.Remove(Traits.UseMSBuildServerEnvVarName);
 
             Debug.Assert(KnownTelemetry.PartialBuildTelemetry == null || KnownTelemetry.PartialBuildTelemetry.StartAt.HasValue, "BuildTelemetry.StartAt was not initialized!");
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 784116cf854..4c2be1f5a97 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -201,7 +201,7 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                 bool continueReading = true;
                 do
                 {
-                    // Ordering of the wait handles is important. The first signalled wait handle in the array 
+                    // Ordering of the wait handles is important. The first signalled wait handle in the array
                     // will be returned by WaitAny if multiple wait handles are signalled. We prefer to have the
                     // terminate event triggered so that we cannot get into a situation where packets are being
                     // spammed to the client and it never gets an opportunity to shutdown.
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 5ea3ee2bde1..70a4bf0aeef 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -61,6 +62,7 @@ public void RegisterDefaultFactories()
             _componentEntriesByType[BuildComponentType.NodeManager] = new BuildComponentEntry(BuildComponentType.NodeManager, NodeManager.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.TaskHostNodeManager] = new BuildComponentEntry(BuildComponentType.TaskHostNodeManager, TaskHostNodeManager.CreateComponent, CreationPattern.Singleton);
 
+            _componentEntriesByType[BuildComponentType.NodeLauncher] = new BuildComponentEntry(BuildComponentType.NodeLauncher, NodeLauncher.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.InProcNodeProvider] = new BuildComponentEntry(BuildComponentType.InProcNodeProvider, NodeProviderInProc.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.OutOfProcNodeProvider] = new BuildComponentEntry(BuildComponentType.OutOfProcNodeProvider, NodeProviderOutOfProc.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.OutOfProcTaskHostNodeProvider] = new BuildComponentEntry(BuildComponentType.OutOfProcTaskHostNodeProvider, NodeProviderOutOfProcTaskHost.CreateComponent, CreationPattern.Singleton);
@@ -80,10 +82,14 @@ public void RegisterDefaultFactories()
 
             // SDK resolution
             _componentEntriesByType[BuildComponentType.SdkResolverService] = new BuildComponentEntry(BuildComponentType.SdkResolverService, MainNodeSdkResolverService.CreateComponent, CreationPattern.Singleton);
+
+#if FEATURE_REPORTFILEACCESSES
+            _componentEntriesByType[BuildComponentType.FileAccessManager] = new BuildComponentEntry(BuildComponentType.FileAccessManager, FileAccessManager.CreateComponent, CreationPattern.Singleton);
+#endif
         }
 
         /// <summary>
-        /// Shuts down all factories registered to this component factory collection. 
+        /// Shuts down all factories registered to this component factory collection.
         /// </summary>
         public void ShutdownComponents()
         {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index ef42f9fe895..297ac265e0e 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -1122,7 +1122,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
             lock (issuingEntry.GlobalLock)
             {
                 var existingResultsToReport = new List<BuildResult>();
-                var unresolvedConfigurationsAdded = new HashSet<NGen<int>>();
+                var unresolvedConfigurationsAdded = new HashSet<int>();
 
                 foreach (FullyQualifiedBuildRequest request in newRequests)
                 {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 1ded6e6fc8a..e7eb3675469 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -31,8 +31,8 @@ internal enum BuildRequestEntryState
         /// being actively built by the engine - i.e. it has a running task thread.  All other requests
         /// must be in one of the other states.  When in this state, the outstandingRequest and
         /// receivedResult members must be null.
-        /// 
-        /// Transitions: 
+        ///
+        /// Transitions:
         ///     Waiting:  When an msbuild callback is made the active build request needs to wait
         ///               for the results in order to continue to process.
         ///     Complete: The build request has generated all of the required results.
@@ -41,21 +41,21 @@ internal enum BuildRequestEntryState
 
         /// <summary>
         /// This state means the node has received all of the results needed to continue processing this
-        /// request.  When this state is set, the receivedResult member of this entry must be non-null.  
+        /// request.  When this state is set, the receivedResult member of this entry must be non-null.
         /// The request engine can continue it at some later point when it is no longer busy.
         /// Any number of entries may be in this state.
-        /// 
+        ///
         /// Transitions:
         ///         Active: The build request engine picks this ready request to process.
         /// </summary>
         Ready,
 
         /// <summary>
-        /// This state means the node is waiting for results from outstanding build requests.  When this 
-        /// state is set, the outstandingRequest or outstandingConfiguration members of the entry 
+        /// This state means the node is waiting for results from outstanding build requests.  When this
+        /// state is set, the outstandingRequest or outstandingConfiguration members of the entry
         /// must be non-null.
-        /// 
-        /// Transitions: 
+        ///
+        /// Transitions:
         ///           Ready: All of the results which caused the build request to wait have been received
         /// </summary>
         Waiting,
@@ -63,7 +63,7 @@ internal enum BuildRequestEntryState
         /// <summary>
         /// This state means the request has completed and results are available.  The engine will remove
         /// the request from the list and the results will be returned to the node for processing.
-        /// 
+        ///
         /// Transitions: None, this is the final state of the build request
         /// </summary>
         Complete
@@ -342,7 +342,7 @@ public void ReportResult(BuildResult result)
                 {
                     _outstandingRequests.Remove(result.NodeRequestId);
 
-                    // If we wish to implement behavior where we stop building after the first failing request, then check for 
+                    // If we wish to implement behavior where we stop building after the first failing request, then check for
                     // overall results being failure rather than just circular dependency. Sync with BasicScheduler.ReportResult and
                     // BasicScheduler.ReportRequestBlocked.
                     if (result.CircularDependency || (_outstandingRequests.Count == 0 && (_unresolvedConfigurations == null || _unresolvedConfigurations.Count == 0)))
@@ -475,7 +475,7 @@ public void Complete(BuildResult result)
                 ErrorUtilities.VerifyThrow(Result == null, "Entry already Completed.");
 
                 // If this request is determined to be a success, then all outstanding items must have been taken care of
-                // and it must be in the correct state.  It can complete unsuccessfully for a variety of reasons in a variety 
+                // and it must be in the correct state.  It can complete unsuccessfully for a variety of reasons in a variety
                 // of states.
                 if (result.OverallResult == BuildResultCode.Success)
                 {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
index fe0362d6fba..fac725d8149 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
@@ -139,7 +139,7 @@ internal interface IBuildRequestEngine
 
         #region Methods
         /// <summary>
-        /// Prepares the engine for a new build and spins up the engine thread.  
+        /// Prepares the engine for a new build and spins up the engine thread.
         /// The engine must be in the Idle state, and not already be initialized.
         /// </summary>
         /// <param name="loggingContext">The logging context for the node.</param>
@@ -154,7 +154,7 @@ internal interface IBuildRequestEngine
         void CleanupForBuild();
 
         /// <summary>
-        /// Submits the specified request to the build queue. 
+        /// Submits the specified request to the build queue.
         /// </summary>
         /// <param name="request">The request to build.</param>
         /// <remarks>It is only valid to call this method when the engine is in the Idle or
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index 15d06a15c93..7bc41b77750 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -148,7 +148,7 @@ public BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata
                 else if (loadProject)
                 {
                     // We already had a configuration, load the project
-                    // If it exists but it cached, retrieve it 
+                    // If it exists but it cached, retrieve it
                     if (configuration.IsCached)
                     {
                         configuration.RetrieveFromCache();
diff --git a/src/Build/BackEnd/Components/Caching/IConfigCache.cs b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
index c0bfc8b5461..83b13f615fe 100644
--- a/src/Build/BackEnd/Components/Caching/IConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
@@ -77,7 +77,7 @@ BuildRequestConfiguration this[int configId]
         void ClearConfigurations();
 
         /// <summary>
-        /// Clear non explicltly loaded configurations. 
+        /// Clear non explicltly loaded configurations.
         /// </summary>
         /// <returns>The configuration ids which have been cleared.</returns>
         List<int> ClearNonExplicitlyLoadedConfigurations();
diff --git a/src/Build/BackEnd/Components/Caching/IResultsCache.cs b/src/Build/BackEnd/Components/Caching/IResultsCache.cs
index c1786e8dbb2..b1d70409322 100644
--- a/src/Build/BackEnd/Components/Caching/IResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IResultsCache.cs
@@ -49,9 +49,9 @@ internal interface IResultsCache : IBuildComponent, ITranslatable, IEnumerable<B
         /// <param name="request">The request whose results we should return</param>
         /// <param name="configInitialTargets">The initial targets for the request's configuration.</param>
         /// <param name="configDefaultTargets">The default targets for the request's configuration.</param>
-        /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".  
-        /// If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method 
-        /// will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no 
+        /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".
+        /// If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method
+        /// will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no
         /// chance of re-execution (which is the usual response to missing / skipped targets), and the caller just needs the data.</param>
         /// <returns>A response indicating the results, if any, and the targets needing to be built, if any.</returns>
         ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> configInitialTargets, List<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss);
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 41013a9701e..d8167fe45b0 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -148,9 +148,9 @@ public BuildResult GetResultsForConfiguration(int configurationId)
         /// <param name="request">The request whose results we should return</param>
         /// <param name="configInitialTargets">The initial targets for the request's configuration.</param>
         /// <param name="configDefaultTargets">The default targets for the request's configuration.</param>
-        /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".  
-        /// If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method 
-        /// will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no 
+        /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".
+        /// If true, then as long as there is a result in the cache (regardless of whether it was skipped or not), this method
+        /// will return "Satisfied". In most cases this should be false, but it may be set to true in a situation where there is no
         /// chance of re-execution (which is the usual response to missing / skipped targets), and the caller just needs the data.</param>
         /// <returns>A response indicating the results, if any, and the targets needing to be built, if any.</returns>
         public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> configInitialTargets, List<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss)
@@ -298,7 +298,7 @@ internal static IBuildComponent CreateComponent(BuildComponentType componentType
         /// <param name="result">The result to examine</param>
         /// <param name="targets">The targets to search for</param>
         /// <param name="targetsMissingResults">An optional list to be populated with missing targets</param>
-        /// <param name="skippedResultsAreOK">If true, a status of "skipped" counts as having valid results 
+        /// <param name="skippedResultsAreOK">If true, a status of "skipped" counts as having valid results
         /// for that target.  Otherwise, a skipped target is treated as equivalent to a missing target.</param>
         /// <returns>False if there were missing results, true otherwise.</returns>
         private static bool CheckResults(BuildResult result, List<string> targets, HashSet<string> targetsMissingResults, bool skippedResultsAreOK)
@@ -320,7 +320,7 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
                 }
                 else
                 {
-                    // If the result was a failure and we have not seen any skipped targets up to this point, then we conclude we do 
+                    // If the result was a failure and we have not seen any skipped targets up to this point, then we conclude we do
                     // have results for this request, and they indicate failure.
                     if (result[target].ResultCode == TargetResultCode.Failure && (targetsMissingResults == null || targetsMissingResults.Count == 0))
                     {
diff --git a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
new file mode 100644
index 00000000000..a10c7b4eb8b
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
@@ -0,0 +1,200 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using BuildXL.Processes;
+using BuildXL.Utilities.Core;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.FileAccesses;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using static BuildXL.Processes.FileAccessManifest;
+
+#nullable disable
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent
+    {
+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();
+
+        private readonly BuildParameters.IBuildParameters _environmentVariables = CreateEnvironmentVariables();
+
+        private IFileAccessManager _fileAccessManager;
+
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));
+            return new DetouredNodeLauncher();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);
+        }
+
+        public void ShutdownComponent()
+        {
+            _fileAccessManager = null;
+
+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)
+            {
+                sandboxedProcess.Dispose();
+            }
+
+            _sandboxedProcesses.Clear();
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process
+        /// </summary>
+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
+        {
+            // Should always have been set already.
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
+
+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));
+
+            if (!FileSystems.Default.FileExists(msbuildLocation))
+            {
+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
+            }
+
+            // Repeat the executable name as the first token of the command line because the command line
+            // parser logic expects it and will otherwise skip the first argument
+            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
+
+            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
+
+            string exeName = msbuildLocation;
+
+#if RUNTIME_TYPE_NETCORE
+            // Run the child process with the same host as the currently-running process.
+            exeName = CurrentHost.GetCurrentHost();
+#endif
+
+            var eventListener = new DetoursEventListener(_fileAccessManager, nodeId);
+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);
+
+            var info = new SandboxedProcessInfo(
+                fileStorage: null, // Don't write stdout/stderr to files
+                fileName: exeName,
+                disableConHostSharing: false,
+                detoursEventListener: eventListener,
+                createJobObjectForCurrentProcess: false)
+            {
+                SandboxKind = SandboxKind.Default,
+                PipDescription = "MSBuild",
+                PipSemiStableHash = 0,
+                Arguments = commandLineArgs,
+                EnvironmentVariables = _environmentVariables,
+                MaxLengthInMemory = 0, // Don't buffer any output
+            };
+
+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed
+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.
+            // this code allows all types of accesses for all files
+            info.FileAccessManifest.AddScope(
+                AbsolutePath.Invalid,
+                FileAccessPolicy.MaskNothing,
+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);
+
+            // Support shared compilation
+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new BreakawayChildProcess[]
+            {
+#if RUNTIME_TYPE_NETCORE
+                new BreakawayChildProcess(NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet", "vbcscompiler.dll", CommandLineArgsSubstringContainmentIgnoreCase: true)
+#else
+                new BreakawayChildProcess(NativeMethodsShared.IsWindows ? "VBCSCompiler.exe" : "VBCSCompiler")
+#endif
+            };
+            info.FileAccessManifest.MonitorChildProcesses = true;
+            info.FileAccessManifest.IgnoreReparsePoints = true;
+            info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;
+            info.FileAccessManifest.UseLargeNtClosePreallocatedList = true;
+            info.FileAccessManifest.LogProcessData = true;
+
+            // needed for logging process arguments when a new process is invoked; see DetoursEventListener.cs
+            info.FileAccessManifest.ReportProcessArgs = true;
+
+            // By default, BuildXL sets the timestamp of all input files to January 1, 1970
+            // This breaks some tools like Robocopy which will not copy a file to the destination if the file exists at the destination and has a timestamp that is more recent than the source file
+            info.FileAccessManifest.NormalizeReadTimestamps = false;
+
+            // If a process exits but its child processes survive, Tracker waits 30 seconds by default to wait for this process to exit.
+            // This slows down C++ builds in which mspdbsrv.exe doesn't exit when it's parent exits. Set this time to 0.
+            info.NestedProcessTerminationTimeout = TimeSpan.Zero;
+
+            ISandboxedProcess sp = SandboxedProcessFactory.StartAsync(info, forceSandboxing: false).GetAwaiter().GetResult();
+            lock (_sandboxedProcesses)
+            {
+                _sandboxedProcesses.Add(sp);
+            }
+
+            CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", sp.ProcessId, exeName);
+            return Process.GetProcessById(sp.ProcessId);
+        }
+
+        private static BuildParameters.IBuildParameters CreateEnvironmentVariables()
+        {
+            var envVars = new Dictionary<string, string>();
+            foreach (DictionaryEntry baseVar in Environment.GetEnvironmentVariables())
+            {
+                envVars.Add((string)baseVar.Key, (string)baseVar.Value);
+            }
+
+            return BuildParameters.GetFactory().PopulateFromDictionary(envVars);
+        }
+
+        private sealed class DetoursEventListener : IDetoursEventListener
+        {
+            private readonly IFileAccessManager _fileAccessManager;
+            private readonly int _nodeId;
+
+            public DetoursEventListener(IFileAccessManager fileAccessManager, int nodeId)
+            {
+                _fileAccessManager = fileAccessManager;
+                _nodeId = nodeId;
+            }
+
+            public override void HandleDebugMessage(DebugData debugData)
+            {
+            }
+
+            public override void HandleFileAccess(FileAccessData fileAccessData) => _fileAccessManager.ReportFileAccess(
+                new Experimental.FileAccess.FileAccessData(
+                    (Experimental.FileAccess.ReportedFileOperation)fileAccessData.Operation,
+                    (Experimental.FileAccess.RequestedAccess)fileAccessData.RequestedAccess,
+                    fileAccessData.ProcessId,
+                    fileAccessData.Error,
+                    (Experimental.FileAccess.DesiredAccess)fileAccessData.DesiredAccess,
+                    (Experimental.FileAccess.FlagsAndAttributes)fileAccessData.FlagsAndAttributes,
+                    fileAccessData.Path,
+                    fileAccessData.ProcessArgs,
+                    fileAccessData.IsAnAugmentedFileAccess),
+                _nodeId);
+
+            public override void HandleProcessData(ProcessData processData) => _fileAccessManager.ReportProcess(
+                new Experimental.FileAccess.ProcessData(
+                    processData.ProcessName,
+                    processData.ProcessId,
+                    processData.ParentProcessId,
+                    processData.CreationDateTime,
+                    processData.ExitDateTime,
+                    processData.ExitCode),
+                _nodeId);
+
+            public override void HandleProcessDetouringStatus(ProcessDetouringStatusData data)
+            {
+            }
+        }
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/Communications/INodeLauncher.cs b/src/Build/BackEnd/Components/Communications/INodeLauncher.cs
new file mode 100644
index 00000000000..c409c856c0b
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/INodeLauncher.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal interface INodeLauncher
+    {
+        Process Start(string msbuildLocation, string commandLineArgs, int nodeId);
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index 2cb875e0764..0deb352e9e5 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -30,7 +30,7 @@ internal enum NodeProviderType
     }
 
     /// <summary>
-    /// This interface represents a collection of nodes in the system.  It provides methods to 
+    /// This interface represents a collection of nodes in the system.  It provides methods to
     /// enumerate active nodes as well as send data and receive events from those nodes.
     /// </summary>
     internal interface INodeProvider : IBuildComponent
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 4c7c7fbd385..68843247305 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -65,7 +65,7 @@ internal class NodeEndpointInProc : INodeEndpoint
 
         /// <summary>
         /// Set when a packet is available in the packet queue
-        /// </summary>      
+        /// </summary>
         private AutoResetEvent _packetAvailable;
 
         /// <summary>
@@ -84,7 +84,7 @@ internal class NodeEndpointInProc : INodeEndpoint
         private bool _peerConnected;
 
         /// <summary>
-        /// The asynchronous packet queue.  
+        /// The asynchronous packet queue.
         /// </summary>
         /// <remarks>
         /// Operations on this queue must be synchronized since it is accessible by multiple threads.
@@ -175,7 +175,7 @@ public void Listen(INodePacketFactory factory)
         }
 
         /// <summary>
-        /// Causes this node to connect to the matched endpoint.  
+        /// Causes this node to connect to the matched endpoint.
         /// </summary>
         /// <param name="factory">Unused</param>
         public void Connect(INodePacketFactory factory)
@@ -266,7 +266,7 @@ private void RaiseLinkStatusChanged(LinkStatus newStatus)
             }
         }
 
-        #endregion 
+        #endregion
 
         #region Private Methods
 
@@ -416,7 +416,7 @@ private void PacketPumpProc()
         {
             try
             {
-                // Ordering of the wait handles is important.  The first signalled wait handle in the array 
+                // Ordering of the wait handles is important.  The first signalled wait handle in the array
                 // will be returned by WaitAny if multiple wait handles are signalled.  We prefer to have the
                 // terminate event triggered so that we cannot get into a situation where packets are being
                 // spammed to the endpoint and it never gets an opportunity to shutdown.
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index 611c4ca68c9..ddec6d79279 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -16,12 +16,26 @@
 
 namespace Microsoft.Build.BackEnd
 {
-    internal class NodeLauncher
+    internal sealed class NodeLauncher : INodeLauncher, IBuildComponent
     {
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));
+            return new NodeLauncher();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+        }
+
+        public void ShutdownComponent()
+        {
+        }
+
         /// <summary>
         /// Creates a new MSBuild process
         /// </summary>
-        public Process Start(string msbuildLocation, string commandLineArgs)
+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
         {
             // Disable MSBuild server for a child process.
             // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.
@@ -181,7 +195,7 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)
             }
         }
 
-        private Process DisableMSBuildServer(Func<Process> func)
+        private static Process DisableMSBuildServer(Func<Process> func)
         {
             string useMSBuildServerEnvVarValue = Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName);
             try
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index f05aa33f9f6..b0031746031 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -11,7 +11,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the 
+    /// The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the
     /// creation of new nodes on request.
     /// </summary>
     internal class NodeManager : INodeManager
@@ -23,7 +23,7 @@ internal class NodeManager : INodeManager
 
         /// <summary>
         /// The node provider for out-of-proc nodes.
-        /// </summary> 
+        /// </summary>
         private INodeProvider? _outOfProcNodeProvider;
 
         /// <summary>
@@ -56,9 +56,9 @@ internal class NodeManager : INodeManager
         /// BUGBUG: This is a fix which corrects an RI blocking BVT failure.  The real fix must be determined before RTM.
         /// This must be investigated and resolved before RTM.  The apparent issue is that a design-time build has already called EndBuild
         /// through the BuildManagerAccessor, and the nodes are shut down.  Shortly thereafter, the solution build manager comes through and calls EndBuild, which throws
-        /// another Shutdown packet in the queue, and causes the following build to stop prematurely.  This is all timing related - not every sequence of builds seems to 
+        /// another Shutdown packet in the queue, and causes the following build to stop prematurely.  This is all timing related - not every sequence of builds seems to
         /// cause the problem, probably due to the order in which the packet queue gets serviced relative to other threads.
-        /// 
+        ///
         /// It appears that the problem is that the BuildRequestEngine is being invoked in a way that causes a shutdown packet to appear to overlap with a build request packet.
         /// Interactions between the in-proc node communication thread and the shutdown mechanism must be investigated to determine how BuildManager.EndBuild is allowing itself
         /// to return before the node has indicated it is actually finished.
@@ -66,7 +66,7 @@ internal class NodeManager : INodeManager
         private bool _nodesShutdown = true;
 
         /// <summary>
-        /// Tracks whether ShutdownComponent has been called.  
+        /// Tracks whether ShutdownComponent has been called.
         /// </summary>
         private bool _componentShutdown;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 58105527c16..273e6990f13 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -332,8 +332,8 @@ bool StartNewNode(int nodeId)
                     }
 #endif
                     // Create the node process
-                    NodeLauncher nodeLauncher = new NodeLauncher();
-                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs);
+                    INodeLauncher nodeLauncher = (INodeLauncher)_componentHost.GetComponent(BuildComponentType.NodeLauncher);
+                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId);
                     _processesToIgnore.TryAdd(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id), default);
 
                     // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index ad7730289d5..e7e66d6b886 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -12,13 +12,13 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the 
+    /// The NodeManager class is responsible for marshalling data to/from the NodeProviders and organizing the
     /// creation of new nodes on request.
     /// </summary>
     internal class TaskHostNodeManager : INodeManager
     {
         /// <summary>
-        /// The node provider for task hosts. 
+        /// The node provider for task hosts.
         /// </summary>
         private INodeProvider _outOfProcTaskHostNodeProvider;
 
@@ -28,7 +28,7 @@ internal class TaskHostNodeManager : INodeManager
         private IBuildComponentHost _componentHost;
 
         /// <summary>
-        /// Tracks whether ShutdownComponent has been called.  
+        /// Tracks whether ShutdownComponent has been called.
         /// </summary>
         private bool _componentShutdown;
 
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 0abf972541a..912c37ee0ca 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -14,9 +14,9 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// This class is responsible for serializing and deserializing anything that is not 
-    /// officially supported by ITranslator, but that we still want to do 
-    /// custom translation of.  
+    /// This class is responsible for serializing and deserializing anything that is not
+    /// officially supported by ITranslator, but that we still want to do
+    /// custom translation of.
     /// </summary>
     internal static class TranslatorExtensions
     {
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
new file mode 100644
index 00000000000..6943ff208e0
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
@@ -0,0 +1,188 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Collections.Concurrent;
+using System.IO;
+using System.Runtime.Versioning;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent
+    {
+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);
+
+        // In order to synchronize between the node communication and the file access reporting, a special file access
+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen
+        // and the build result is reported can plugins be notified about project completion.
+        // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.
+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @":\{MSBuildFileAccessCompletion}\";
+
+        private IScheduler? _scheduler;
+        private IConfigCache? _configCache;
+
+        private object _handlersWriteLock = new object();
+        private Handlers[] _handlers = Array.Empty<Handlers>();
+        private string? _tempDirectory;
+
+        // Keyed on global request id
+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();
+
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));
+            return new FileAccessManager();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;
+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);
+        }
+
+        public void ShutdownComponent()
+        {
+            _scheduler = null;
+            _configCache = null;
+            _tempDirectory = null;
+            _fileAccessCompletionWaitHandles.Clear();
+        }
+
+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)
+        {
+            string fileAccessPath = fileAccessData.Path;
+
+            // Intercept and avoid forwarding the file access completion
+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))
+            {
+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.
+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));
+
+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());
+                handle.Set();
+            }
+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))
+            {
+                // Ignore MSBuild's temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,
+                // so should not be exposed to handlers. Note that this is not %TEMP% but instead a subdir under %TEMP% which is only expected to be used by MSBuild.
+                return;
+            }
+            else
+            {
+                // Forward the file access to handlers.
+                BuildRequest? buildRequest = GetBuildRequest(nodeId);
+                if (buildRequest != null)
+                {
+                    Handlers[] localHandlers = _handlers;
+                    foreach (Handlers handlers in localHandlers)
+                    {
+                        handlers.FileAccessHander.Invoke(buildRequest, fileAccessData);
+                    }
+                }
+            }
+        }
+
+        public void ReportProcess(ProcessData processData, int nodeId)
+        {
+            BuildRequest? buildRequest = GetBuildRequest(nodeId);
+            if (buildRequest != null)
+            {
+                Handlers[] localHandlers = _handlers;
+                foreach (Handlers handlers in localHandlers)
+                {
+                    handlers.ProcessHandler.Invoke(buildRequest, processData);
+                }
+            }
+        }
+
+        public HandlerRegistration RegisterHandlers(Action<BuildRequest, FileAccessData> fileAccessHandler, Action<BuildRequest, ProcessData> processHandler)
+        {
+            lock (_handlersWriteLock)
+            {
+                Handlers[] newHandlers = new Handlers[_handlers.Length + 1];
+                _handlers.CopyTo(newHandlers, 0);
+
+                Handlers addedHandlers = new(fileAccessHandler, processHandler);
+                newHandlers[_handlers.Length] = addedHandlers;
+
+                _handlers = newHandlers;
+
+                return new HandlerRegistration(() => UnregisterHandlers(addedHandlers));
+            }
+        }
+
+        private void UnregisterHandlers(Handlers handlersToRemove)
+        {
+            lock (_handlersWriteLock)
+            {
+                Handlers[] newHandlers = new Handlers[_handlers.Length - 1];
+                int newHandlersIdx = 0;
+                for (int handlersIdx = 0; handlersIdx < _handlers.Length; handlersIdx++)
+                {
+                    if (_handlers[handlersIdx] != handlersToRemove)
+                    {
+                        newHandlers[newHandlersIdx] = _handlers[handlersIdx];
+                        newHandlersIdx++;
+                    }
+                }
+
+                _handlers = newHandlers;
+            }
+        }
+
+        // The [SupportedOSPlatform] attribute is a safeguard to ensure that the comment on FileAccessCompletionPrefix regarding being Windows-only gets addressed.
+        // [SupportedOSPlatform] doesn't apply to fields, so using it here as a reasonable proxy.
+        [SupportedOSPlatform("windows")]
+        public static void NotifyFileAccessCompletion(int globalRequestId)
+        {
+            // Make a dummy file access to use as a notification that the file accesses should be completed for a project.
+            string filePath = FileAccessCompletionPrefix + globalRequestId.ToString();
+            _ = File.Exists(filePath);
+        }
+
+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken)
+        {
+            ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());
+            if (!handle.IsSet)
+            {
+                handle.Wait(cancellationToken);
+            }
+
+            // Try to keep the collection clean. A request should not need to be completed twice.
+            _fileAccessCompletionWaitHandles.TryRemove(globalRequestId, out _);
+        }
+
+        private BuildRequest? GetBuildRequest(int nodeId)
+        {
+            ErrorUtilities.VerifyThrow(
+                _scheduler != null && _configCache != null,
+                "Component has not been initialized");
+
+            // Note: If the node isn't executing anything it may be accessing binaries required to run, eg. the MSBuild binaries
+            return _scheduler!.GetExecutingRequestByNode(nodeId);
+        }
+
+        internal readonly struct HandlerRegistration : IDisposable
+        {
+            private readonly Action _unregisterAction;
+
+            public HandlerRegistration(Action unregisterAction)
+            {
+                _unregisterAction = unregisterAction;
+            }
+
+            public void Dispose()
+            {
+                _unregisterAction();
+            }
+        }
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs
new file mode 100644
index 00000000000..72ce0107921
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class FileAccessReport : INodePacket
+    {
+        private FileAccessData _fileAccessData;
+
+        internal FileAccessReport(FileAccessData fileAccessData) => _fileAccessData = fileAccessData;
+
+        private FileAccessReport(ITranslator translator) => Translate(translator);
+
+        /// <inheritdoc/>
+        public NodePacketType Type => NodePacketType.FileAccessReport;
+
+        /// <inheritdoc/>
+        public void Translate(ITranslator translator) => translator.Translate(ref _fileAccessData);
+
+        internal FileAccessData FileAccessData => _fileAccessData;
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator) => new FileAccessReport(translator);
+    }
+}
diff --git a/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
new file mode 100644
index 00000000000..dd3b7685053
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal interface IFileAccessManager
+    {
+        void ReportFileAccess(FileAccessData fileAccessData, int nodeId);
+
+        void ReportProcess(ProcessData processData, int nodeId);
+
+        // Note: The return type of FileAccessManager.HandlerRegistration is exposed directly instead of IDisposable to avoid boxing.
+        FileAccessManager.HandlerRegistration RegisterHandlers(
+            Action<BuildRequest, FileAccessData> fileAccessHandler,
+            Action<BuildRequest, ProcessData> processHandler);
+
+        void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken);
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
new file mode 100644
index 00000000000..e211f674789
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
@@ -0,0 +1,63 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.FileAccesses
+{
+    /// <summary>
+    /// Reports file accesses and process data to the in-proc node.
+    /// </summary>
+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent
+    {
+        /// <summary>
+        /// The <see cref="Action"/> to report file accesses and process
+        /// data to the in-proc node.
+        /// </summary>
+        private readonly Action<INodePacket> _sendPacket;
+
+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;
+
+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));
+            return new OutOfProcNodeFileAccessManager(sendPacket);
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+        }
+
+        public void ShutdownComponent()
+        {
+        }
+
+        /// <summary>
+        /// Reports a file access to the in-proc node.
+        /// </summary>
+        /// <param name="fileAccessData">The file access to report to the in-proc node.</param>
+        /// <param name="nodeId">The id of the reporting out-of-proc node.</param>
+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));
+
+        /// <summary>
+        /// Reports process data to the in-proc node.
+        /// </summary>
+        /// <param name="processData">The process data to report to the in-proc node.</param>
+        /// <param name="nodeId">The id of the reporting out-of-proc node.</param>
+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));
+
+        public FileAccessManager.HandlerRegistration RegisterHandlers(
+            Action<BuildRequest, FileAccessData> fileAccessHandler,
+            Action<BuildRequest, ProcessData> processHandler) =>
+            throw new NotImplementedException("This method should not be called in OOP nodes.");
+
+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken) =>
+            throw new NotImplementedException("This method should not be called in OOP nodes.");
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs b/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs
new file mode 100644
index 00000000000..f8d891fe532
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class ProcessReport : INodePacket
+    {
+        private ProcessData _processData;
+
+        internal ProcessReport(ProcessData processData) => _processData = processData;
+
+        private ProcessReport(ITranslator translator) => Translate(translator);
+
+        /// <inheritdoc/>
+        public NodePacketType Type => NodePacketType.ProcessReport;
+
+        internal ProcessData ProcessData => _processData;
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator) => new ProcessReport(translator);
+
+        /// <inheritdoc/>
+        public void Translate(ITranslator translator) => translator.Translate(ref _processData);
+    }
+}
diff --git a/src/Build/BackEnd/Components/IBuildComponent.cs b/src/Build/BackEnd/Components/IBuildComponent.cs
index e79f6a24444..411350f4278 100644
--- a/src/Build/BackEnd/Components/IBuildComponent.cs
+++ b/src/Build/BackEnd/Components/IBuildComponent.cs
@@ -6,7 +6,7 @@ namespace Microsoft.Build.BackEnd
     /// <summary>
     /// Each component in the build system which is registered with the Build Manager or a Node must
     /// implement this interface.
-    /// 
+    ///
     /// REFACTOR: Maybe these could all implement IDisposable.
     /// </summary>
     internal interface IBuildComponent
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index bcbc7eac430..5ae9d947906 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -130,6 +130,18 @@ internal enum BuildComponentType
         /// The SDK resolution service.
         /// </summary>
         SdkResolverService,
+
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// The component which is the sink for file access reports and forwards reports to other components.
+        /// </summary>
+        FileAccessManager,
+#endif
+
+        /// <summary>
+        /// The component which launches new MSBuild nodes.
+        /// </summary>
+        NodeLauncher,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
index ccaf8c46ea1..893d8796e7d 100644
--- a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
@@ -47,7 +47,7 @@ internal BuildEventArgTransportSink(SendDataDelegate sendData)
 
         #region Properties
         /// <summary>
-        /// Provide a friendly name for the sink to make it easier to differentiate during 
+        /// Provide a friendly name for the sink to make it easier to differentiate during
         /// debugging and display
         /// </summary>
         public string Name
diff --git a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
index eb2fe9a8cee..17d2e672250 100644
--- a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
+++ b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
@@ -16,7 +16,7 @@ internal class CentralForwardingLogger : IForwardingLogger
         #region Properties
 
         /// <summary>
-        /// An IEventRedirector which will redirect any events forwarded from the logger. The eventRedirector determines where the events will 
+        /// An IEventRedirector which will redirect any events forwarded from the logger. The eventRedirector determines where the events will
         /// be redirected.
         /// </summary>
         public IEventRedirector BuildEventRedirector
@@ -59,7 +59,7 @@ public string Parameters
         #region Public
 
         /// <summary>
-        /// Initialize the logger with an eventSource and a node count. 
+        /// Initialize the logger with an eventSource and a node count.
         /// The logger will register and listen to anyEvents on the eventSource.
         /// The node count is for informational purposes. The logger may want to take different
         /// actions depending on how many nodes there are in the system.
@@ -102,7 +102,7 @@ public void Shutdown()
         #region Private
 
         /// <summary>
-        /// Forwards any event raised to the BuildEventRedirector, this redirector will send the event on a path which will 
+        /// Forwards any event raised to the BuildEventRedirector, this redirector will send the event on a path which will
         /// take it to a logger.
         /// </summary>
         /// <param name="sender">Who sent the message, this is not used</param>
@@ -110,7 +110,7 @@ public void Shutdown()
         private void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent)
         {
             // If no central logger was registered with the system
-            // there will not be a build event redirector as there is 
+            // there will not be a build event redirector as there is
             // nowhere to forward the events to.
             BuildEventRedirector?.ForwardEvent(buildEvent);
         }
diff --git a/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs b/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
index edf9d9d2f3e..de3a78aea4a 100644
--- a/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
@@ -28,7 +28,7 @@ internal class EventRedirectorToSink : IEventRedirector
         #region Constructors
         /// <summary>
         /// Initalize this class with a central logger id identifying the central logger to which
-        /// these events should consumed by. The redirector will send the messages to the registered sink to 
+        /// these events should consumed by. The redirector will send the messages to the registered sink to
         /// be consumed
         /// </summary>
         /// <param name="loggerId">Id which will be attached to the build event arguments to indicate which logger the events came from</param>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index e76797ee3cc..5e5e883ff08 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -83,8 +83,8 @@ internal sealed class EventSourceSink :
         public event CustomBuildEventHandler CustomEventRaised;
 
         /// <summary>
-        /// this event is raised to log build status events, such as 
-        /// build/project/target/task started/stopped 
+        /// this event is raised to log build status events, such as
+        /// build/project/target/task started/stopped
         /// </summary>
         public event BuildStatusEventHandler StatusEventRaised;
 
@@ -102,7 +102,7 @@ internal sealed class EventSourceSink :
 
         #region Properties
         /// <summary>
-        /// Provide a friendly name for the sink to make it easier to differentiate during 
+        /// Provide a friendly name for the sink to make it easier to differentiate during
         /// debugging and display
         /// </summary>
         public string Name
@@ -313,7 +313,7 @@ internal void UnregisterAllEventHandlers()
         /// <param name="buildEvent">BuildMessageEventArgs</param>
         /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
         /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception> 
+        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
         private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent)
         {
             if (MessageRaised != null)
@@ -875,9 +875,9 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     // if a fellow logger is throwing in an event handler.
                     this.UnregisterAllEventHandlers();
 
-                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a 
-                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could 
-                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :) 
+                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a
+                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
+                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
                     ExceptionHandling.DumpExceptionToFile(exception);
 
                     throw;
@@ -888,9 +888,9 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     // if a fellow logger is throwing in an event handler.
                     this.UnregisterAllEventHandlers();
 
-                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a 
-                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could 
-                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :) 
+                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a
+                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
+                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
                     ExceptionHandling.DumpExceptionToFile(exception);
 
                     if (ExceptionHandling.IsCriticalException(exception))
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index a3b78640194..6d4973bc223 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -100,7 +100,7 @@ ICollection<ILogger> Loggers
 
         /// <summary>
         /// The list of descriptions which describe how to create forwarding loggers on a node.
-        /// This is used by the node provider to get a list of registered descriptions so that 
+        /// This is used by the node provider to get a list of registered descriptions so that
         /// they can be transmitted to child nodes.
         /// </summary>
         ICollection<LoggerDescription> LoggerDescriptions
@@ -616,13 +616,13 @@ BuildEventContext LogProjectStarted(
     }
 
     /// <summary>
-    /// Acts as an endpoint for a buildEventArg. The objects which implement this interface are intended to consume the BuildEventArg. 
+    /// Acts as an endpoint for a buildEventArg. The objects which implement this interface are intended to consume the BuildEventArg.
     /// </summary>
     internal interface IBuildEventSink
     {
         #region Properties
         /// <summary>
-        /// Provide a the sink a friendly name which can be used to distinguish sinks in memory 
+        /// Provide a the sink a friendly name which can be used to distinguish sinks in memory
         /// and for display
         /// </summary>
         string Name
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 1efec57dc44..15b6000a7aa 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -77,7 +77,7 @@ public ILoggingService LoggingService
         /// <summary>
         /// Retrieves the build event context
         /// UNDONE: (Refactor) We eventually want to remove this because all logging should go
-        /// through a context object.  This exists only so we can make certain 
+        /// through a context object.  This exists only so we can make certain
         /// logging calls in code which has not yet been fully refactored.
         /// </summary>
         public BuildEventContext BuildEventContext
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2f95ae3f180..885647baba0 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -462,6 +462,11 @@ public int MaxCPUCount
             set => _maxCPUCount = value;
         }
 
+        /// <summary>
+        /// Gets or sets a value that will error when the build process fails an up-to-date check.
+        /// </summary>
+        public bool Question { get; set; }
+
         /// <summary>
         /// The list of descriptions which describe how to create forwarding loggers on a node.
         /// This is used by the node provider to get a list of registered descriptions so that
@@ -797,6 +802,8 @@ public void InitializeComponent(IBuildComponentHost buildComponentHost)
                 // this information default to 1
                 _maxCPUCount = buildComponentHost.BuildParameters.MaxNodeCount;
 
+                Question = buildComponentHost.BuildParameters.Question;
+
                 // Ask the component host if onlyLogCriticalEvents is true or false. If the host does
                 // not have this information default to false.
                 _onlyLogCriticalEvents = buildComponentHost.BuildParameters.OnlyLogCriticalEvents;
@@ -998,13 +1005,13 @@ public bool RegisterLogger(ILogger logger)
 
                     // Get the Id of the eventSourceSink which was created for the first logger.
                     // We keep a reference to this Id so that all other central loggers registered on this logging service (from registerLogger)
-                    // will be attached to that eventSource sink so that they get all of the events forwarded by 
+                    // will be attached to that eventSource sink so that they get all of the events forwarded by
                     // forwarded by the CentralForwardingLogger
                     _centralForwardingLoggerSinkId = centralForwardingLoggerDescription.LoggerId;
                 }
                 else
                 {
-                    // We have already create a forwarding logger and have a single eventSink which 
+                    // We have already create a forwarding logger and have a single eventSink which
                     // a logger can listen to inorder to get all events in the system
                     EventSourceSink eventSource = (EventSourceSink)_eventSinkDictionary[_centralForwardingLoggerSinkId];
 
@@ -1035,7 +1042,7 @@ public void UnregisterAllLoggers()
                 }
             }
 
-            // UNDONE: (Logging) This should re-initialize this logging service. 
+            // UNDONE: (Logging) This should re-initialize this logging service.
         }
 
         /// <summary>
@@ -1641,10 +1648,10 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
                 // them.
                 _filterEventSource.Consume(eventArg);
 
-                // Now that the forwarding loggers have been given the chance to log the build started and finished events we need to check the 
+                // Now that the forwarding loggers have been given the chance to log the build started and finished events we need to check the
                 // central logger sinks to see if they have received the events or not. If the sink has not received the event we need to send it to the
                 // logger for backwards compatibility with orcas.
-                // In addition we need to make sure we manually forward the events because in orcas the forwarding loggers were not allowed to 
+                // In addition we need to make sure we manually forward the events because in orcas the forwarding loggers were not allowed to
                 // forward build started or build finished events. In the new OM we allow the loggers to forward the events. However since orcas did not forward them
                 // we need to support loggers which cannot forward the events.
                 if (eventArg is BuildStartedEventArgs)
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 33c747f9eb0..9ef9a58f17b 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -26,7 +26,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// Logs a comment (BuildMessageEventArgs) with a certain MessageImportance level
         /// </summary>
         /// <param name="buildEventContext">Event context information which describes who is logging the event</param>
-        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
+        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on.
         /// The higher the importance the lower the verbosity needs to be for the message to be seen</param>
         /// <param name="messageResourceName">String which identifies the message in the string resx</param>
         /// <param name="messageArgs">Arguments for the format string indexed by messageResourceName</param>
@@ -45,7 +45,7 @@ public void LogComment(BuildEventContext buildEventContext, MessageImportance im
         /// Log a comment
         /// </summary>
         /// <param name="buildEventContext">Event context information which describes who is logging the event</param>
-        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
+        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on.
         /// The higher the importance the lower the verbosity needs to be for the message to be seen</param>
         /// <param name="message">Message to log</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
@@ -59,7 +59,7 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor
         /// Log a comment
         /// </summary>
         /// <param name="buildEventContext">Event context information which describes who is logging the event</param>
-        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on. 
+        /// <param name="importance">How important is the message, this will determine which verbosities the message will show up on.
         /// The higher the importance the lower the verbosity needs to be for the message to be seen</param>
         /// <param name="message">Message to log</param>
         /// <param name="messageArgs">Message formatting arguments</param>
@@ -368,7 +368,7 @@ public void LogWarningFromText(BuildEventContext buildEventContext, string subca
         #region Log status
 
         /// <summary>
-        /// Logs that the build has started 
+        /// Logs that the build has started
         /// </summary>
         public void LogBuildStarted()
         {
@@ -402,7 +402,14 @@ public void LogBuildFinished(bool success)
             string message = String.Empty;
             if (!OnlyLogCriticalEvents)
             {
-                message = ResourceUtilities.GetResourceString(success ? "BuildFinishedSuccess" : "BuildFinishedFailure");
+                if (Question)
+                {
+                    message = ResourceUtilities.GetResourceString(success ? "BuildFinishedQuestionSuccess" : "BuildFinishedQuestionFailure");
+                }
+                else
+                {
+                    message = ResourceUtilities.GetResourceString(success ? "BuildFinishedSuccess" : "BuildFinishedFailure");
+                }
             }
 
             BuildFinishedEventArgs buildEvent = new BuildFinishedEventArgs(message, null /* no help keyword */, success);
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 7bff292f0e1..3d9a25df6cc 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -121,7 +121,7 @@ internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectT
         /// </summary>
         /// <remarks>
         /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when 
+        /// The expense of copying items is only incurred if and when
         /// a logger chooses to enumerate over it.
         /// </remarks>
         internal class TargetOutputItemsInstanceEnumeratorProxy : IEnumerable<TaskItem>
diff --git a/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs b/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs
new file mode 100644
index 00000000000..5ff62cfb514
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public readonly struct FileAccessContext
+    {
+        public FileAccessContext(
+            string projectFullPath,
+            IReadOnlyDictionary<string, string> globalProperties,
+            IReadOnlyList<string> targets)
+        {
+            ProjectFullPath = projectFullPath;
+            GlobalProperties = globalProperties;
+            Targets = targets;
+        }
+
+        public string ProjectFullPath { get; }
+
+        public IReadOnlyDictionary<string, string> GlobalProperties { get; }
+
+        public IReadOnlyList<string> Targets { get; }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
index 2bf479c6055..6c999cfcf53 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
@@ -1,9 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.FileAccess;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
@@ -39,5 +41,32 @@ public abstract Task<CacheResult> GetCacheResultAsync(
         ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
         /// </summary>
         public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);
+
+        /// <summary>
+        ///     Called for each file access from an MSBuild node or one of its children.
+        /// </summary>
+        [CLSCompliant(false)]
+        public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData)
+        {
+        }
+
+        /// <summary>
+        ///     Called for each new child process created by an MSBuild node or one of its children.
+        /// </summary>
+        [CLSCompliant(false)]
+        public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData)
+        {
+        }
+
+        /// <summary>
+        ///     Called when a build request finishes execution. This provides an opportunity for the plugin to take action on the
+        ///     aggregated file access reports from <see cref="HandleFileAccess(FileAccessContext, FileAccessData)"/>.
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public virtual Task HandleProjectFinishedAsync(
+            FileAccessContext fileAccessContext,
+            BuildResult buildResult,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken) => Task.CompletedTask;
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index e34e70cca44..4d695e99076 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
@@ -33,17 +34,31 @@ internal sealed class ProjectCacheService : IAsyncDisposable
         private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
         private readonly BuildManager _buildManager;
+        private readonly IBuildComponentHost _componentHost;
         private readonly ILoggingService _loggingService;
+#if FEATURE_REPORTFILEACCESSES
+        private readonly IFileAccessManager _fileAccessManager;
+#endif
+        private readonly IConfigCache _configCache;
 
         private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;
 
         private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);
 
+        // Helps to avoid excessive allocation since BuildRequestConfiguration doesn't expose global properties in a way the plugins can consume (PropertyDictionary<ProjectPropertyInstance> vs IReadOnlyDictionary<string, string>).
+        private readonly ConcurrentDictionary<BuildRequestConfiguration, IReadOnlyDictionary<string, string>> _globalPropertiesPerConfiguration = new();
+
         private bool _isVsScenario;
 
         private bool _isDisposed;
 
-        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);
+        private record struct ProjectCachePlugin(
+            string Name,
+            ProjectCachePluginBase? Instance,
+#if FEATURE_REPORTFILEACCESSES
+            FileAccessManager.HandlerRegistration? HandlerRegistration,
+#endif
+            ExceptionDispatchInfo? InitializationException = null);
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
@@ -61,10 +76,19 @@ private DefaultMSBuildFileSystem()
         public ProjectCacheService(
             BuildManager buildManager,
             ILoggingService loggingService,
+#if FEATURE_REPORTFILEACCESSES
+            IFileAccessManager fileAccessManager,
+#endif
+            IConfigCache configCache,
             ProjectCacheDescriptor? globalProjectCacheDescriptor)
         {
             _buildManager = buildManager;
+            _componentHost = buildManager;
             _loggingService = loggingService;
+#if FEATURE_REPORTFILEACCESSES
+            _fileAccessManager = fileAccessManager;
+#endif
+            _configCache = configCache;
             _globalProjectCacheDescriptor = globalProjectCacheDescriptor;
         }
 
@@ -75,18 +99,24 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
         {
             EnsureNotDisposed();
 
-            Parallel.ForEach(
-                projectGraph.ProjectNodes,
-                s_parallelOptions,
-                node =>
+            // Performing this in a Task.Run to break away from the main thread and prevent hangs
+            Task.Run(
+                () =>
                 {
-                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
-                    {
-                        // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
-                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
-                    }
-                });
+                    Parallel.ForEach(
+                        projectGraph.ProjectNodes,
+                        s_parallelOptions,
+                        node =>
+                        {
+                            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                            {
+                                // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
+                                    .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                            }
+                        });
+                },
+                cancellationToken);
         }
 
         public void InitializePluginsForVsScenario(
@@ -104,15 +134,21 @@ public void InitializePluginsForVsScenario(
                 return;
             }
 
-            Parallel.ForEach(
-                projectCacheDescriptors,
-                s_parallelOptions,
-                projectCacheDescriptor =>
+            // Performing this in a Task.Run to break away from the main thread and prevent hangs
+            Task.Run(
+                () =>
                 {
-                    // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
-                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
-                });
+                    Parallel.ForEach(
+                        projectCacheDescriptors,
+                        s_parallelOptions,
+                        projectCacheDescriptor =>
+                        {
+                            // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
+                                .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                        });
+                },
+                cancellationToken);
         }
 
         private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
@@ -187,7 +223,13 @@ private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
                 }
                 catch (Exception e)
                 {
-                    return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                    return new ProjectCachePlugin(
+                        pluginTypeName,
+                        Instance: null,
+#if FEATURE_REPORTFILEACCESSES
+                        HandlerRegistration: null,
+#endif
+                        ExceptionDispatchInfo.Capture(e));
                 }
                 finally
                 {
@@ -218,11 +260,43 @@ await pluginInstance.BeginBuildAsync(
                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
                 }
 
-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);
+#if FEATURE_REPORTFILEACCESSES
+            FileAccessManager.HandlerRegistration? handlerRegistration = null;
+            if (_componentHost.BuildParameters.ReportFileAccesses)
+            {
+                handlerRegistration = _fileAccessManager.RegisterHandlers(
+                    (buildRequest, fileAccessData) =>
+                    {
+                        // TODO: Filter out projects which do not configure this plugin
+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);
+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);
+                    },
+                    (buildRequest, processData) =>
+                    {
+                        // TODO: Filter out projects which do not configure this plugin
+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);
+                        pluginInstance.HandleProcess(fileAccessContext, processData);
+                    });
+            }
+#endif
+
+                return new ProjectCachePlugin(
+                    pluginTypeName,
+                    pluginInstance,
+#if FEATURE_REPORTFILEACCESSES
+                    handlerRegistration,
+#endif
+                    InitializationException: null);
             }
             catch (Exception e)
             {
-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                return new ProjectCachePlugin(
+                    pluginTypeName,
+                    Instance: null,
+#if FEATURE_REPORTFILEACCESSES
+                    HandlerRegistration: null,
+#endif
+                    ExceptionDispatchInfo.Capture(e));
             }
             finally
             {
@@ -230,6 +304,27 @@ await pluginInstance.BeginBuildAsync(
             }
         }
 
+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)
+        {
+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];
+            IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(configuration);
+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);
+        }
+
+        private IReadOnlyDictionary<string, string> GetGlobalProperties(BuildRequestConfiguration configuration)
+            => _globalPropertiesPerConfiguration.GetOrAdd(
+                    configuration,
+                    static configuration =>
+                    {
+                        Dictionary<string, string> globalProperties = new(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);
+                        foreach (ProjectPropertyInstance property in configuration.GlobalProperties)
+                        {
+                            globalProperties.Add(property.Name, property.EvaluatedValue);
+                        }
+
+                        return globalProperties;
+                    });
+
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
         {
             try
@@ -306,6 +401,12 @@ public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration)
                 return false;
             }
 
+            // We need to retrieve the configuration if it's already loaded in order to access the Project property below.
+            if (buildRequestConfiguration.IsCached)
+            {
+                buildRequestConfiguration.RetrieveFromCache();
+            }
+
             // Check if there are any project cache items defined in the project
             return GetProjectCacheDescriptors(buildRequestConfiguration.Project).Any();
         }
@@ -424,7 +525,7 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
 
                     ErrorUtilities.VerifyThrow(plugin.Instance != null, "Plugin '{0}' instance is null", plugin.Name);
 
-                    MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(plugin.Name, buildRequest.ProjectFullPath, targetNames);
+                    MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(plugin.Name, buildRequest.ProjectFullPath, targetNames ?? MSBuildConstants.DefaultTargetsMarker);
                     cacheResult = await plugin.Instance!.GetCacheResultAsync(buildRequest, pluginLogger, cancellationToken);
 
                     if (pluginLogger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
@@ -447,7 +548,7 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
                     if (MSBuildEventSource.Log.IsEnabled())
                     {
                         string cacheResultType = cacheResult?.ResultType.ToString() ?? nameof(CacheResultType.None);
-                        MSBuildEventSource.Log.ProjectCacheGetCacheResultStop(plugin.Name, buildRequest.ProjectFullPath, targetNames, cacheResultType);
+                        MSBuildEventSource.Log.ProjectCacheGetCacheResultStop(plugin.Name, buildRequest.ProjectFullPath, targetNames ?? "<default>", cacheResultType);
                     }
                 }
             }
@@ -587,6 +688,98 @@ static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromS
             }
         }
 
+        public async Task HandleBuildResultAsync(
+            BuildRequestConfiguration requestConfiguration,
+            BuildResult buildResult,
+            BuildEventContext buildEventContext,
+            CancellationToken cancellationToken)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(requestConfiguration.Project, nameof(requestConfiguration.Project));
+
+            if (_projectCachePlugins.IsEmpty)
+            {
+                return;
+            }
+
+            // We need to retrieve the configuration if it's already loaded in order to access the Project property below.
+            if (requestConfiguration.IsCached)
+            {
+                requestConfiguration.RetrieveFromCache();
+            }
+
+            // Filter to plugins which apply to the project, if any
+            List<ProjectCacheDescriptor> projectCacheDescriptors = GetProjectCacheDescriptors(requestConfiguration.Project).ToList();
+            if (projectCacheDescriptors.Count == 0)
+            {
+                return;
+            }
+
+#if FEATURE_REPORTFILEACCESSES
+            if (_componentHost.BuildParameters.ReportFileAccesses)
+            {
+                _fileAccessManager.WaitForFileAccessReportCompletion(buildResult.GlobalRequestId, cancellationToken);
+            }
+#endif
+
+            IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(requestConfiguration);
+
+            List<string> targets = buildResult.ResultsByTarget.Keys.ToList();
+            string? targetNames = string.Join(", ", targets);
+
+            FileAccessContext fileAccessContext = new(requestConfiguration.ProjectFullPath, globalProperties, targets);
+
+            var buildEventFileInfo = new BuildEventFileInfo(requestConfiguration.ProjectFullPath);
+            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                buildEventContext,
+                buildEventFileInfo);
+
+            Task[] tasks = new Task[projectCacheDescriptors.Count];
+            int idx = 0;
+            foreach (ProjectCacheDescriptor projectCacheDescriptor in projectCacheDescriptors)
+            {
+                tasks[idx++] = Task.Run(
+                    async () =>
+                    {
+                        if (!_projectCachePlugins.TryGetValue(projectCacheDescriptor, out Lazy<Task<ProjectCachePlugin>>? pluginLazyTask))
+                        {
+                            // The plugin might not be in the collection if it was never initialized, which can happen if there are multiple plugins
+                            // and the first one(s) always handles the cache request so the subsequent one(s) never get lazy initialized.
+                            return;
+                        }
+
+                        ProjectCachePlugin plugin = await pluginLazyTask.Value;
+
+                        // Rethrow any initialization exception.
+                        plugin.InitializationException?.Throw();
+
+                        ErrorUtilities.VerifyThrow(plugin.Instance != null, "Plugin '{0}' instance is null", plugin.Name);
+
+                        MSBuildEventSource.Log.ProjectCacheHandleBuildResultStart(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);
+                        try
+                        {
+                            await plugin.Instance!.HandleProjectFinishedAsync(fileAccessContext, buildResult, pluginLogger, cancellationToken);
+                        }
+                        catch (Exception e) when (e is not ProjectCacheException)
+                        {
+                            HandlePluginException(e, nameof(ProjectCachePluginBase.HandleProjectFinishedAsync));
+                        }
+                        finally
+                        {
+                            MSBuildEventSource.Log.ProjectCacheHandleBuildResultStop(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);
+                        }
+                    },
+                    cancellationToken);
+            }
+
+            await Task.WhenAll(tasks).ConfigureAwait(false);
+
+            if (pluginLogger.HasLoggedErrors)
+            {
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheHandleBuildResultFailed", fileAccessContext.ProjectFullPath);
+            }
+        }
+
         public async ValueTask DisposeAsync()
         {
             if (_isDisposed)
@@ -624,6 +817,13 @@ public async ValueTask DisposeAsync()
                         return;
                     }
 
+#if FEATURE_REPORTFILEACCESSES
+                    if (plugin.HandlerRegistration.HasValue)
+                    {
+                        plugin.HandlerRegistration.Value.Dispose();
+                    }
+#endif
+
                     MSBuildEventSource.Log.ProjectCacheEndBuildStart(plugin.Name);
                     try
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 7e03b6cfd3e..14150696614 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -7,6 +7,9 @@
 using System.Linq;
 #endif
 using System.Reflection;
+#if FEATURE_ASSEMBLYLOADCONTEXT
+using System.Runtime.Loader;
+#endif
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 
@@ -152,10 +155,15 @@ private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs a
             string? assemblyName = args.LoadedAssembly.FullName;
             string assemblyPath = args.LoadedAssembly.IsDynamic ? string.Empty : args.LoadedAssembly.Location;
             Guid mvid = args.LoadedAssembly.ManifestModule.ModuleVersionId;
+#if FEATURE_ASSEMBLYLOADCONTEXT
+            // AssemblyLoadContext.GetLoadContext returns null when the assembly isn't a RuntimeAssembly, which should not be the case here.
+            // Name would only be null if the AssemblyLoadContext didn't supply a name, but MSBuildLoadContext does.
+            string appDomainDescriptor = AssemblyLoadContext.GetLoadContext(args.LoadedAssembly)?.Name ?? "Unknown";
+#else
             string? appDomainDescriptor = _appDomain.IsDefaultAppDomain()
                 ? null
                 : $"{_appDomain.Id}|{_appDomain.FriendlyName}";
-
+#endif
 
             AssemblyLoadBuildEventArgs buildArgs = new(_context, _initiator, assemblyName, assemblyPath, mvid, appDomainDescriptor);
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index c5852c97d30..646381478b9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -19,26 +19,26 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     /// <remarks>
     /// What batching does
-    /// 
-    /// Batching partitions the items consumed by the batchable object into buckets, where each bucket 
-    /// contains a set of items that have the same value set on all item metadata consumed by the object. 
-    /// Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it 
+    ///
+    /// Batching partitions the items consumed by the batchable object into buckets, where each bucket
+    /// contains a set of items that have the same value set on all item metadata consumed by the object.
+    /// Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it
     /// refers, for example %(a.m).
-    /// 
-    /// If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the 
-    /// same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type ‘b’ 
-    /// are considered to always have a blank value for %(a.m). This means items of type ‘b’ will only be 
+    ///
+    /// If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the
+    /// same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type ‘b’
+    /// are considered to always have a blank value for %(a.m). This means items of type ‘b’ will only be
     /// placed in buckets where %(a.m) is blank. However %(a.m) is equivalent to %(m) on items of type ‘a’.
-    /// 
-    /// There is an extra ambiguity rule: every items consumed by the object must have an explicit value for 
-    /// every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item 
-    /// of type ‘a’ must have a value for the metadata ‘m’ but need not all necessarily have a value for the 
-    /// metadata ‘n’. This rule eliminates ambiguity about whether items that do not define values for an 
-    /// unqualified metadata should go in all buckets, or just into buckets with a blank value for 
+    ///
+    /// There is an extra ambiguity rule: every items consumed by the object must have an explicit value for
+    /// every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item
+    /// of type ‘a’ must have a value for the metadata ‘m’ but need not all necessarily have a value for the
+    /// metadata ‘n’. This rule eliminates ambiguity about whether items that do not define values for an
+    /// unqualified metadata should go in all buckets, or just into buckets with a blank value for
     /// that metadata.
-    /// 
-    /// For example 
-    /// 
+    ///
+    /// For example
+    ///
     /// <ItemGroup>
     /// <a Include='a1;a2'>
     ///   <n>m0</n>
@@ -54,19 +54,19 @@ namespace Microsoft.Build.BackEnd
     /// </b>
     /// <b Include='b4'/>
     /// </ItemGroup>
-    /// 
+    ///
     /// <Target Name="t" >
     ///   <Message Text="a={@(a).%(a.n)} b={@(b).%(b.n)}" />
     /// </Target>
-    /// 
-    /// Will produce 5 buckets: 
-    /// 
+    ///
+    /// Will produce 5 buckets:
+    ///
     /// a={a1;a2.m0} b={.}
     /// a={a3.m1} b={.}
     /// a={.} b={b1.n0}
     /// a={.} b={b2;b3.n1}
     /// a={.} b={b4.}
-    /// 
+    ///
     /// </remarks>
     internal static class BatchingEngine
     {
@@ -113,14 +113,14 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
 
             ItemsAndMetadataPair pair = ExpressionShredder.GetReferencedItemNamesAndMetadata(batchableObjectParameters);
 
-            // All the @(itemname) item list references in the tag, including transforms, etc.        
+            // All the @(itemname) item list references in the tag, including transforms, etc.
             HashSet<string> consumedItemReferences = pair.Items;
 
-            // All the %(itemname.metadataname) references in the tag (not counting those embedded 
+            // All the %(itemname.metadataname) references in the tag (not counting those embedded
             // inside item transforms), and note that the itemname portion is optional.
             // The keys in the returned hash table are the qualified metadata names (e.g. "EmbeddedResource.Culture"
-            // or just "Culture").  The values are MetadataReference structs, which simply split out the item 
-            // name (possibly null) and the actual metadata name.            
+            // or just "Culture").  The values are MetadataReference structs, which simply split out the item
+            // name (possibly null) and the actual metadata name.
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             List<ItemBucket> buckets = null;
@@ -136,14 +136,14 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
                 // This method goes through all the item list references and figures out which ones
                 // will be participating in batching, and which ones won't.  We get back a hashtable
                 // where the key is the item name that will be participating in batching.  The values
-                // are all String.Empty (not used).  This method may return additional item names 
+                // are all String.Empty (not used).  This method may return additional item names
                 // that weren't represented in "consumedItemReferences"... this would happen if there
-                // were qualified metadata references in the consumedMetadataReferences table, such as 
+                // were qualified metadata references in the consumedMetadataReferences table, such as
                 // %(EmbeddedResource.Culture).
                 Dictionary<string, ICollection<ProjectItemInstance>> itemListsToBeBatched = GetItemListsToBeBatched(consumedMetadataReferences, consumedItemReferences, lookup, elementLocation);
 
-                // At this point, if there were any metadata references in the tag, but no item 
-                // references to batch on, we've got a problem because we can't figure out which 
+                // At this point, if there were any metadata references in the tag, but no item
+                // references to batch on, we've got a problem because we can't figure out which
                 // item lists the user wants us to batch.
                 if (itemListsToBeBatched.Count == 0)
                 {
@@ -178,16 +178,16 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
 
         /// <summary>
         /// Of all the item lists that are referenced in this batchable object, which ones should we
-        /// batch on, and which ones should we just pass in wholesale to every invocation of the 
+        /// batch on, and which ones should we just pass in wholesale to every invocation of the
         /// target/task?
-        /// 
+        ///
         /// Rule #1.  If the user has referenced any *qualified* item metadata such as %(EmbeddedResource.Culture),
         /// then that item list "EmbeddedResource" will definitely get batched.
-        /// 
-        /// Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that 
+        ///
+        /// Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that
         /// every single item in every single item list being passed into the task contains a value
         /// for that metadata.  If not, it's an error.  If so, we batch all of those item lists.
-        /// 
+        ///
         /// All other item lists will not be batched, and instead will be passed in wholesale to all buckets.
         /// </summary>
         /// <returns>Dictionary containing the item names that should be batched.  If the items match unqualified metadata,
@@ -212,11 +212,11 @@ private static Dictionary<string, ICollection<ProjectItemInstance>> GetItemLists
                 if (consumedMetadataReference.ItemName != null)
                 {
                     // Rule #1.  Qualified metadata reference.
-                    // For metadata references that are qualified with an item name 
-                    // (e.g., %(EmbeddedResource.Culture) ), we add that item name to the list of 
+                    // For metadata references that are qualified with an item name
+                    // (e.g., %(EmbeddedResource.Culture) ), we add that item name to the list of
                     // consumed item names, even if the item name wasn't otherwise referenced via
                     // @(...) syntax, and even if every item in the list doesn't necessary contain
-                    // a value for this metadata.  This is the special power that you get by qualifying 
+                    // a value for this metadata.  This is the special power that you get by qualifying
                     // the metadata reference with an item name.
                     itemListsToBeBatched[consumedMetadataReference.ItemName] = null;
 
@@ -224,7 +224,7 @@ private static Dictionary<string, ICollection<ProjectItemInstance>> GetItemLists
                     // %(EmbeddedResource.Culture) effectively means that @(EmbeddedResource) is
                     // being consumed, even though we may not see literally "@(EmbeddedResource)"
                     // in the tag anywhere.  Adding it to this list allows us (down below in this
-                    // method) to check that every item in this list has a value for each 
+                    // method) to check that every item in this list has a value for each
                     // unqualified metadata reference.
                     consumedItemReferenceNames ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                     consumedItemReferenceNames.Add(consumedMetadataReference.ItemName);
@@ -364,7 +364,7 @@ private static List<ItemBucket> BucketConsumedItems(
         /// <summary>
         /// Gets the values of the specified metadata for the given item.
         /// The keys in the dictionary returned may be qualified and/or unqualified, exactly
-        /// as they are found in the metadata reference. 
+        /// as they are found in the metadata reference.
         /// For example if %(x) is found, the key is "x", if %(z.x) is found, the key is "z.x".
         /// This dictionary in each bucket is used by Expander to expand exactly the same metadata references, so
         /// %(x) is expanded using the key "x", and %(z.x) is expanded using the key "z.x".
@@ -393,7 +393,7 @@ private static Dictionary<string, string> GetItemMetadataValues(
                 {
                     try
                     {
-                        // This returns String.Empty for both metadata that is undefined and metadata that has 
+                        // This returns String.Empty for both metadata that is undefined and metadata that has
                         // an empty value; they are treated the same.
                         itemMetadataValues[metadataQualifiedName] = ((IItem)item).GetMetadataValueEscaped(metadataName);
                     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
index 51fe0d9196d..7f0b5c187e6 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
@@ -15,14 +15,14 @@ namespace Microsoft.Build.BackEnd
     internal interface ITargetBuilderCallback : IRequestBuilderCallback
     {
         /// <summary>
-        /// Invokes the specified targets using Dev9 behavior.  
+        /// Invokes the specified targets using Dev9 behavior.
         /// </summary>
         /// <param name="targets">The targets to build.</param>
         /// <param name="continueOnError">True to continue building the remaining targets if one fails.</param>
         /// <param name="referenceLocation">The <see cref="ElementLocation"/> of the reference.</param>
         /// <returns>The results for each target.</returns>
         /// <remarks>
-        /// The target is run using the data context of the Project, rather than the data context 
+        /// The target is run using the data context of the Project, rather than the data context
         /// of the current target.  This has the following effects:
         /// 1. Data visible to the CALLING target at the time it was first invoked is the only
         ///    data which the CALLED target can see.  No changes made between the time the CALLING
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ITaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/ITaskBuilder.cs
index b274bd8b11c..5daea9c8d78 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ITaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ITaskBuilder.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.BackEnd
     internal enum TaskExecutionMode
     {
         /// <summary>
-        /// This entry is necessary to use the enum with binary math. It is never used outside 
+        /// This entry is necessary to use the enum with binary math. It is never used outside
         /// intermediate calculations.
         /// </summary>
         Invalid = 0,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
index 74d4f09524a..94c1ee183ac 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
@@ -83,7 +83,7 @@ internal static IntrinsicTask InstantiateTask(ProjectTargetInstanceChild taskIns
         }
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <param name="lookup">The lookup used for expansion and to receive created items and properties.</param>
         internal abstract void ExecuteTask(Lookup lookup);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
index 6e6c793ecc2..7d5eb31fc38 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/CallTarget.cs
@@ -32,7 +32,7 @@ internal class CallTarget : ITask
         private readonly List<ITaskItem> _targetOutputs = new List<ITaskItem>();
 
         /// <summary>
-        /// A list of targets to build.  This is a required parameter.  If you want to build the 
+        /// A list of targets to build.  This is a required parameter.  If you want to build the
         /// default targets, use the <see cref="MSBuild"/> task and pass in Projects=$(MSBuildProjectFile).
         /// </summary>
         /// <value>Array of target names.</value>
@@ -92,8 +92,8 @@ public Task<bool> ExecuteInternal()
             }
 
             // This is a list of string[].  That is, each element in the list is a string[].  Each
-            // string[] represents a set of target names to build.  Depending on the value 
-            // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
+            // string[] represents a set of target names to build.  Depending on the value
+            // of the RunEachTargetSeparately parameter, we each just call the engine to run all
             // the targets together, or we call the engine separately for each target.
             List<string[]> targetLists = MSBuild.CreateTargetLists(Targets, RunEachTargetSeparately);
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 72d42315df5..08cc3e9f5e0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -167,7 +167,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
             // Second, expand the item include and exclude, and filter existing metadata as appropriate.
             List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata, loggingContext);
 
-            // Third, expand the metadata.           
+            // Third, expand the metadata.
             foreach (ProjectItemGroupTaskMetadataInstance metadataInstance in child.Metadata)
             {
                 bool condition = ConditionEvaluator.EvaluateCondition(
@@ -196,7 +196,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
 
                     string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
 
-                    // This both stores the metadata so we can add it to all the items we just created later, and 
+                    // This both stores the metadata so we can add it to all the items we just created later, and
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
                     metadataTable.SetValue(metadataInstance.Name, evaluatedValue);
                 }
@@ -236,7 +236,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
         }
 
         /// <summary>
-        /// Remove items from the world. Removes to items that are part of the project manifest are backed up, so 
+        /// Remove items from the world. Removes to items that are part of the project manifest are backed up, so
         /// they can be reverted when the project is reset after the end of the build.
         /// </summary>
         /// <param name="child">The item specification to evaluate and remove.</param>
@@ -280,7 +280,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
         }
 
         /// <summary>
-        /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so 
+        /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so
         /// they can be reverted when the project is reset after the end of the build.
         /// </summary>
         /// <param name="child">The item specification to evaluate and modify.</param>
@@ -681,7 +681,7 @@ internal Dictionary<string, string> AddedMetadata
             #region IMetadataTable Members
             // NOTE:  Leaving these methods public so as to avoid having to explicitly define them
             // through the IMetadataTable interface and then cast everywhere they're used.  This class
-            // is private, so it ultimately doesn't matter. 
+            // is private, so it ultimately doesn't matter.
 
             /// <summary>
             /// Gets the specified metadata value.  Returns an empty string if none is set.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index ccb65841cbb..df32111f095 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -83,7 +83,7 @@ internal static string GetParameterText(string prefix, string parameterName, ILi
                 // If the parameterName is not specified, no need to have an extra indent.
                 // Without parameterName:
                 //
-                // Input files: 
+                // Input files:
                 //     a.txt
                 //     b.txt
                 //
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 0c250da8f00..21650e6448f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -38,10 +38,10 @@ internal sealed class ItemBucket : IComparable
         private Lookup _lookup;
 
         /// <summary>
-        /// When buckets are being created for batching purposes, this indicates which order the 
+        /// When buckets are being created for batching purposes, this indicates which order the
         /// buckets were created in, so that the target/task being batched gets called with the items
         /// in the same order as they were declared in the project file.  For example, the first
-        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets 
+        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
         private int _bucketSequenceNumber;
@@ -153,10 +153,10 @@ internal Expander<ProjectPropertyInstance, ProjectItemInstance> Expander
 
 
         /// <summary>
-        /// When buckets are being created for batching purposes, this indicates which order the 
+        /// When buckets are being created for batching purposes, this indicates which order the
         /// buckets were created in, so that the target/task being batched gets called with the items
         /// in the same order as they were declared in the project file.  For example, the first
-        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets 
+        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
         internal int BucketSequenceNumber
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 9ead103fe08..b5bcf7ca165 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -24,33 +24,33 @@ namespace Microsoft.Build.BackEnd
     ///     - quick lookups
     ///     - scoping down of item subsets in nested scopes (useful for batches)
     ///     - isolation of adds, removes, modifies, and property sets inside nested scopes
-    ///     
+    ///
     /// When retrieving the item group for an item type, each table is consulted in turn,
     /// starting with the primary table (the "top" or "innermost" table), until a table is found that has an entry for that type.
     /// When an entry is found, it is returned without looking deeper.
     /// This makes it possible to let callers see only a subset of items without affecting or cloning the original item groups,
     /// by populating a scope with item groups that are empty or contain subsets of items in lower scopes.
-    /// 
+    ///
     /// Instances of this class can be cloned with Clone() to share between batches.
-    /// 
+    ///
     /// When EnterScope() is called, a fresh primary table is inserted, and all adds and removes will be invisible to
     /// any clones made before the scope was entered and anyone who has access to item groups in lower tables.
-    /// 
+    ///
     /// When LeaveScope() is called, the primary tables are merged into the secondary tables, and the primary tables are discarded.
     /// This makes the adds and removes in the primary tables visible to clones made during the previous scope.
-    /// 
+    ///
     /// Scopes can be populated (before Adds, Removes, and Lookups) using PopulateWithItem(). This reduces the set of items of a particular
     /// type that are visible in a scope, because lookups of items of this type will stop at this level and see the subset, rather than the
     /// larger set in a scope below.
-    /// 
+    ///
     /// Items can be added or removed by calling AddNewItem() and RemoveItem(). Only the primary level is modified.
     /// When items are added or removed they enter into a primary table exclusively for adds or removes, instead of the main primary table.
     /// This allows the adds and removes to be applied to the scope below on LeaveScope(). Even when LeaveScope() is called, the adds and removes
     /// stay in their separate add and remove tables: if they were applied to a main table, they could truncate the downward traversal performed by lookups
     /// and hide items in a lower main table. Only on the final call of LeaveScope() can all adds and removes be applied to the outermost table, i.e., the project.
-    /// 
+    ///
     /// Much the same applies to properties.
-    /// 
+    ///
     /// For sensible semantics, only the current primary scope can be modified at any point.
     /// </summary>
     internal class Lookup : IPropertyProvider<ProjectPropertyInstance>, IItemProvider<ProjectItemInstance>
@@ -221,7 +221,7 @@ internal List<string> GetPropertyOverrideMessages(Dictionary<string, string> loo
                     }
 
                     // Set the value of the hash to the new property value
-                    // PERF: we store the EvaluatedValueEscaped here to avoid unnecessary unescaping (the value is stored 
+                    // PERF: we store the EvaluatedValueEscaped here to avoid unnecessary unescaping (the value is stored
                     // escaped in the property)
                     lookupHash[propertyName] = ((IProperty)property).EvaluatedValueEscaped;
                 }
@@ -262,8 +262,8 @@ private void LeaveScope(Lookup.Scope scopeToLeave)
             ErrorUtilities.VerifyThrow(_lookupScopes.Count >= 2, "Too many calls to Leave().");
             ErrorUtilities.VerifyThrow(Object.ReferenceEquals(scopeToLeave, _lookupScopes.First.Value), "Attempting to leave with scope '{0}' but scope '{1}' is on top of the stack.", scopeToLeave.Description, _lookupScopes.First.Value.Description);
 
-            // Our lookup works by stopping the first time it finds an item group of the appropriate type. 
-            // So we can't apply an add directly into the table below because that could create a new group 
+            // Our lookup works by stopping the first time it finds an item group of the appropriate type.
+            // So we can't apply an add directly into the table below because that could create a new group
             // of that type, which would cause the next lookup to stop there and miss any existing items in a table below.
             // Instead we keep adds stored separately until we're leaving the very last scope. Until then
             // we only move adds down into the next add table below, and when we lookup we consider both tables.
@@ -279,7 +279,7 @@ private void LeaveScope(Lookup.Scope scopeToLeave)
 
             // Let go of our pointer into the clone table; we assume we won't need it after leaving scope and want to save memory.
             // This is an assumption on IntrinsicTask, that it won't ask to remove or modify a clone in a higher scope than it was handed out in.
-            // We mustn't call cloneTable.Clear() because other clones of this lookup may still be using it. When the last lookup clone leaves scope, 
+            // We mustn't call cloneTable.Clear() because other clones of this lookup may still be using it. When the last lookup clone leaves scope,
             // the table will be collected.
             _cloneTable = null;
 
@@ -413,7 +413,7 @@ private void MergeScopeIntoLastScope()
         /// </summary>
         public ProjectPropertyInstance GetProperty(string name, int startIndex, int endIndex)
         {
-            // Walk down the tables and stop when the first 
+            // Walk down the tables and stop when the first
             // property with this name is found
             foreach (Scope scope in _lookupScopes)
             {
@@ -716,8 +716,8 @@ internal void RemoveItem(ProjectItemInstance item)
             PrimaryRemoveTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryRemoveTable.Add(item);
 
-            // No need to remove this item from the primary add table if it's 
-            // already there -- we always apply removes after adds, so that add 
+            // No need to remove this item from the primary add table if it's
+            // already there -- we always apply removes after adds, so that add
             // will be reversed anyway.
         }
 
@@ -731,7 +731,7 @@ internal void ModifyItems(string itemType, ICollection<ProjectItemInstance> grou
             MustNotBeOuterScope();
 
 #if DEBUG
-            // This item should not already be in any remove table; there is no way a project can 
+            // This item should not already be in any remove table; there is no way a project can
             // modify items that were already removed
             // Obviously, do this only in debug, as it's a slow check for bugs.
             LinkedListNode<Scope> node = _lookupScopes.First;
@@ -912,7 +912,7 @@ private void MergeModificationsIntoModificationTable(Dictionary<ProjectItemInsta
                     foreach (var metadataChange in modify.Value.ExplicitModifications)
                     {
                         // If the existing metadata change list has an entry for this metadata, ignore this change.
-                        // We continue to allow changes made when KeepOnlySpecified is set because it is assumed that explicit metadata changes 
+                        // We continue to allow changes made when KeepOnlySpecified is set because it is assumed that explicit metadata changes
                         // always trump implicit ones.
                         if (!existingMetadataChanges.ContainsExplicitModification(metadataChange.Key))
                         {
@@ -960,7 +960,7 @@ private void MustNotBeInTable(ItemTypeToItemsMetadataUpdateDictionary table, Pro
 
         /// <summary>
         /// Verify item is not in any table in any scope
-        /// </summary>        
+        /// </summary>
         private void MustNotBeInAnyTables(ProjectItemInstance item)
         {
             // This item should not already be in any table; there is no way a project can
@@ -1360,8 +1360,8 @@ internal Scope(Lookup lookup, string description, ItemDictionary<ProjectItemInst
 
             /// <summary>
             /// The main table, populated with items that
-            /// are initially visible in this scope. Does not 
-            /// include adds or removes unless it's the table in 
+            /// are initially visible in this scope. Does not
+            /// include adds or removes unless it's the table in
             /// the outermost scope.
             /// </summary>
             internal ItemDictionary<ProjectItemInstance> Items
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index b4b97933ac7..e2c2e7cc772 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -292,7 +292,7 @@ public void WaitForCancelCompletion()
                 }
                 catch (AggregateException e) when (InnerExceptionsAreAllCancelledExceptions(e))
                 {
-                    // ignore -- just indicates that the task finished cancelling before we got a chance to wait on it.  
+                    // ignore -- just indicates that the task finished cancelling before we got a chance to wait on it.
                     taskCleanedUp = true;
                 }
 
@@ -608,7 +608,7 @@ internal static int WaitWithBuilderThreadStart(WaitHandle[] handles, bool recurs
                 }
                 finally
                 {
-                    // If this was the top level submission doing the waiting, we are done with this submission and it's 
+                    // If this was the top level submission doing the waiting, we are done with this submission and it's
                     // main thread building context
                     if (!recursive)
                     {
@@ -638,10 +638,10 @@ private void StartBuilderThread()
             _cancellationTokenSource = new CancellationTokenSource();
 
             // IMPLEMENTATION NOTE: It may look strange that we are creating new tasks here which immediately turn around and create
-            // more tasks that look async.  The reason for this is that while these methods are technically async, they really only 
+            // more tasks that look async.  The reason for this is that while these methods are technically async, they really only
             // unwind at very specific times according to the needs of MSBuild, in particular when we are waiting for results from
             // another project or when we are Yielding the Build Engine while running certain tasks.  Essentially, the Request Builder
-            // and related components form a giant state machine and the tasks are used to implement one very deep co-routine.  
+            // and related components form a giant state machine and the tasks are used to implement one very deep co-routine.
             if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
             {
                 // Create a task which completes when the legacy threading task thread is finished.
@@ -650,13 +650,13 @@ private void StartBuilderThread()
                 _requestTask = Task.Factory.StartNew(
                     () =>
                     {
-                        // If this is a very quick-running request, it is possible that the request will have built and completed in 
+                        // If this is a very quick-running request, it is possible that the request will have built and completed in
                         // the time between when StartBuilderThread is called, and when the threadpool gets around to actually servicing
-                        // this request.  If that's the case, it's also possible that ShutdownComponent() could have already been called, 
-                        // in which case the componentHost will be null.  
+                        // this request.  If that's the case, it's also possible that ShutdownComponent() could have already been called,
+                        // in which case the componentHost will be null.
 
-                        // In that circumstance, by definition we don't have anyone who will want to wait on the LegacyThreadInactiveEvent 
-                        // task, so we can safely just return. Take a snapshot so that we don't fall victim to componentHost being set 
+                        // In that circumstance, by definition we don't have anyone who will want to wait on the LegacyThreadInactiveEvent
+                        // task, so we can safely just return. Take a snapshot so that we don't fall victim to componentHost being set
                         // to null between the null check and asking the LegacyThreadingData for the Task.
                         IBuildComponentHost componentHostSnapshot = _componentHost;
 
@@ -678,9 +678,9 @@ private void StartBuilderThread()
                 ErrorUtilities.VerifyThrow(_componentHost.LegacyThreadingData.MainThreadSubmissionId != _requestEntry.Request.SubmissionId, "Can't start builder thread when we are using legacy threading semantics for this request.");
 
                 // We do not run in STA by default.  Most code does not
-                // require the STA apartment and the .Net default is to 
+                // require the STA apartment and the .Net default is to
                 // create threads with MTA semantics.  We provide this
-                // switch so that those few tasks which may require it 
+                // switch so that those few tasks which may require it
                 // can be made to work.
                 if (Environment.GetEnvironmentVariable("MSBUILDFORCESTA") == "1")
                 {
@@ -804,7 +804,7 @@ private async Task BuildAndReport()
             BuildResult result = null;
             VerifyEntryInActiveState();
 
-            // Start the build request            
+            // Start the build request
             try
             {
                 result = await BuildProject();
@@ -896,7 +896,7 @@ private void ReportResultAndCleanUp(BuildResult result)
                 }
             }
 
-            // Clear out our state now in case any of these callbacks cause the engine to try and immediately 
+            // Clear out our state now in case any of these callbacks cause the engine to try and immediately
             // reuse this builder.
             BuildRequestEntry entryToComplete = _requestEntry;
             _nodeLoggingContext = null;
@@ -946,13 +946,13 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
                 SaveOperatingEnvironment();
             }
 
-            // Issue the requests to the engine            
+            // Issue the requests to the engine
             RaiseOnNewBuildRequests(requests);
 
             // TODO: OPTIMIZATION: By returning null here, we commit to having to unwind the stack all the
             // way back to RequestThreadProc and then shutting down the thread before we can receive the
             // results and continue with them.  It is not always the case that this will be desirable, however,
-            // particularly if the results we need are immediately available.  In those cases, it would be 
+            // particularly if the results we need are immediately available.  In those cases, it would be
             // useful to wait here for a short period in case those results become available - one second
             // might be enough.  This means we may occasionally get more than one builder thread lying around
             // waiting for something to happen, but that would be short lived.  At the same time it would
@@ -1111,8 +1111,8 @@ private async Task<BuildResult> BuildProject()
         {
             ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
 
-            // Make sure it is null before loading the configuration into the request, because if there is a problem 
-            // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be 
+            // Make sure it is null before loading the configuration into the request, because if there is a problem
+            // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be
             // logged with the node logging context
             _projectLoggingContext = null;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 537660af9bf..bb3f3c87d9e 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -419,8 +419,8 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                         "TargetDoesNotExist",
                         currentTargetEntry.Name);
 
-                        // If we already have results for this target which were not skipped, we can ignore it.  In 
-                        // addition, we can also ignore its before and after targets -- if this target has already run, 
+                        // If we already have results for this target which were not skipped, we can ignore it.  In
+                        // addition, we can also ignore its before and after targets -- if this target has already run,
                         // then so have they.
                         if (!CheckSkipTarget(ref stopProcessingStack, currentTargetEntry))
                         {
@@ -446,7 +446,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                             IList<TargetSpecification> dependencies = currentTargetEntry.GetDependencies(_projectLoggingContext);
 
                             // Push our before targets now, unconditionally.  If we have marked that we should stop processing the stack here, which can only
-                            // happen if our current target was supposed to stop processing AND we had no after targets, then our last before target should 
+                            // happen if our current target was supposed to stop processing AND we had no after targets, then our last before target should
                             // inherit the stop processing flag and we will reset it.
                             // Our parent is the target before which we run, just like a depends-on target.
                             IList<TargetSpecification> beforeTargets = _requestEntry.RequestConfiguration.Project.GetTargetsWhichRunBefore(currentTargetEntry.Name);
@@ -584,11 +584,11 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
                     {
                         TargetEntry topEntry = _targetsToBuild.Pop();
 
-                        // If this is a skip because of target failure, we should behave in the same way as we 
-                        // would if this target actually failed -- remove all its dependencies from the stack as 
-                        // well.  Otherwise, we could encounter a situation where a failure target happens in the 
+                        // If this is a skip because of target failure, we should behave in the same way as we
+                        // would if this target actually failed -- remove all its dependencies from the stack as
+                        // well.  Otherwise, we could encounter a situation where a failure target happens in the
                         // middle of execution once, then exits, then a request comes through to build the same
-                        // targets, reaches that target, skips-already-failed, and then continues building. 
+                        // targets, reaches that target, skips-already-failed, and then continues building.
                         PopDependencyTargetsOnTargetFailure(topEntry, targetResult, ref stopProcessingStack);
                     }
 
@@ -663,7 +663,7 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
 
                 if (buildReason == TargetBuiltReason.BeforeTargets || buildReason == TargetBuiltReason.AfterTargets)
                 {
-                    // Don't build any Before or After targets for which we already have results.  Unlike other targets, 
+                    // Don't build any Before or After targets for which we already have results.  Unlike other targets,
                     // we don't explicitly log a skipped-with-results message because it is not interesting.
                     if (_buildResult.HasResultsForTarget(targetSpecification.TargetName))
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index cef0fb834f9..e742933082c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -19,7 +19,7 @@
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
-#if MSBUILDENABLEVSPROFILING 
+#if MSBUILDENABLEVSPROFILING
 using Microsoft.VisualStudio.Profiler;
 #endif
 #nullable disable
@@ -507,7 +507,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                 // We either have some work to do or at least we need to infer outputs from inputs.
                                 bucketResult = await ProcessBucket(taskBuilder, targetLoggingContext, GetTaskExecutionMode(dependencyResult), lookupForInference, lookupForExecution);
 
-                                // Now aggregate the result with the existing known results.  There are four rules, assuming the target was not 
+                                // Now aggregate the result with the existing known results.  There are four rules, assuming the target was not
                                 // skipped due to being up-to-date:
                                 // 1. If this bucket failed or was cancelled, the aggregate result is failure.
                                 // 2. If this bucket Succeeded and we have not previously failed, the aggregate result is a success.
@@ -525,7 +525,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                     }
                                 }
 
-                                // Pop the lookup scopes, causing them to collapse their values back down into the 
+                                // Pop the lookup scopes, causing them to collapse their values back down into the
                                 // bucket's lookup.
                                 // NOTE: this order is important because when we infer outputs, we are trying
                                 // to produce the same results as would be produced from a full build; as such
@@ -557,7 +557,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                     }
                     finally
                     {
-                        // Don't log the last target finished event until we can process the target outputs as we want to attach them to the 
+                        // Don't log the last target finished event until we can process the target outputs as we want to attach them to the
                         // last target batch.
                         if (targetLoggingContext != null && i < numberOfBuckets - 1)
                         {
@@ -585,13 +585,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                     string targetReturns = _target.Returns;
                     ElementLocation targetReturnsLocation = _target.ReturnsLocation;
 
-                    // If there are no targets in the project file that use the "Returns" attribute, that means that we 
+                    // If there are no targets in the project file that use the "Returns" attribute, that means that we
                     // revert to the legacy behavior in the case where Returns is not specified (null, rather
-                    // than the empty string, which indicates no returns).  Legacy behavior is for all 
-                    // of the target's Outputs to be returned. 
-                    // On the other hand, if there is at least one target in the file that uses the Returns attribute, 
+                    // than the empty string, which indicates no returns).  Legacy behavior is for all
+                    // of the target's Outputs to be returned.
+                    // On the other hand, if there is at least one target in the file that uses the Returns attribute,
                     // then all targets in the file are run according to the new behaviour (return nothing unless otherwise
-                    // specified by the Returns attribute). 
+                    // specified by the Returns attribute).
                     if (targetReturns == null)
                     {
                         if (!_target.ParentProjectSupportsReturnsAttribute)
@@ -616,7 +616,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
 
                         // NOTE: we need to gather the outputs in batches, because the output specification may reference item metadata
                         // Also, we are using the baseLookup, which has possibly had changes made to it since the project started.  Because of this, the
-                        // set of outputs calculated here may differ from those which would have been calculated at the beginning of the target.  It is 
+                        // set of outputs calculated here may differ from those which would have been calculated at the beginning of the target.  It is
                         // assumed the user intended this.
                         List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
 
@@ -648,7 +648,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 }
                 finally
                 {
-                    // log the last target finished since we now have the target outputs. 
+                    // log the last target finished since we now have the target outputs.
                     targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
                 }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index 8409e8135ca..a3297139fa8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -37,7 +37,7 @@ private TargetSpecification()
         }
 
         /// <summary>
-        /// Gets or sets the target name            
+        /// Gets or sets the target name
         /// </summary>
         public string TargetName => _targetName;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index dcf16e16545..4b40715d67b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -22,12 +22,12 @@ namespace Microsoft.Build.BackEnd
     using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
     using ItemVectorPartition = System.Collections.Generic.Dictionary<string, System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectItemInstance>>;
     // ItemVectorPartitionCollection is designed to contains a set of project items which have possibly undergone transforms.
-    // The outer dictionary it usually keyed by item type, so if items originally came from 
+    // The outer dictionary it usually keyed by item type, so if items originally came from
     // an expression like @(Foo), the outer dictionary would have a key of "Foo" in it.
     // Under that is a dictionary of expressions to items resulting from the expression.
     // For instance, if items were generated from an expression @(Foo->'%(Filename).obj'), then
-    // the inner dictionary would have a key of "@(Foo->'%(Filename).obj')", in which would be 
-    // contained a list of the items which were created/transformed using that pattern.    
+    // the inner dictionary would have a key of "@(Foo->'%(Filename).obj')", in which would be
+    // contained a list of the items which were created/transformed using that pattern.
     using ItemVectorPartitionCollection = System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectItemInstance>>>;
 
     /// <summary>
@@ -192,14 +192,14 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
                          * At this point, we know the following:
                          * 1) the target has outputs
                          * 2) the target has NO discrete outputs
-                         * 
+                         *
                          * This implies:
                          * 1) the target only references vectors (incl. transforms) in its outputs
                          * 2) all vectors referenced in the outputs are also referenced in the inputs
                          * 3) the referenced vectors are not empty
-                         * 
+                         *
                          * We can thus conclude: the target MUST have (non-discrete) inputs
-                         * 
+                         *
                          */
                         ErrorUtilities.VerifyThrow(itemVectorsReferencedInBothTargetInputsAndOutputs.Count > 0, "The target must have inputs.");
                         ErrorUtilities.VerifyThrow(!IsItemVectorEmpty(itemVectorsInTargetInputs), "The target must have inputs.");
@@ -970,7 +970,7 @@ internal static bool IsAnyOutOfDate<T>(out DependencyAnalysisLogDetail dependenc
             // Algorithm: walk through all the outputs to find the oldest output
             //            walk through the inputs as far as we need to until we find one that's newer (if any)
 
-            // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely): 
+            // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely):
             //         possibly the outputs list isn't actually the shortest list. However it always is the shortest
             //         in the cases I've seen, and adding this optimization would make the code hard to read.
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index f8768988732..ee09e5be50f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -347,7 +347,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
 
                 taskHost?.MarkAsInactive();
 
-                // Now all task batches are done, apply all item adds to the outer 
+                // Now all task batches are done, apply all item adds to the outer
                 // target batch; we do this even if the task wasn't found (in that case,
                 // no items or properties will have been added to the scope)
                 if (buckets != null)
@@ -414,14 +414,14 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 {
                     // Change to the project root directory.
                     // If that directory does not exist, do nothing. (Do not check first as it is almost always there and it is slow)
-                    // This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project. 
+                    // This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project.
                     // No errors are masked by doing this: errors loading the project from disk are reported at load time, if necessary.
                     NativeMethodsShared.SetCurrentDirectory(_buildRequestEntry.ProjectRootDirectory);
                 }
 
                 if (howToExecuteTask == TaskExecutionMode.ExecuteTaskAndGatherOutputs)
                 {
-                    // We need to find the task before logging the task started event so that the using task statement comes before the task started event 
+                    // We need to find the task before logging the task started event so that the using task statement comes before the task started event
                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);
                     TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);
                     if (requirements != null)
@@ -519,15 +519,15 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
         /// </summary>
         private IDictionary<string, string> GatherTaskIdentityParameters(Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
-            ErrorUtilities.VerifyThrowInternalNull(_taskNode, "taskNode"); // taskNode should never be null when we're calling this method. 
+            ErrorUtilities.VerifyThrowInternalNull(_taskNode, "taskNode"); // taskNode should never be null when we're calling this method.
 
             string msbuildArchitecture = expander.ExpandIntoStringAndUnescape(_taskNode.MSBuildArchitecture ?? String.Empty, ExpanderOptions.ExpandAll, _taskNode.MSBuildArchitectureLocation ?? ElementLocation.EmptyLocation);
             string msbuildRuntime = expander.ExpandIntoStringAndUnescape(_taskNode.MSBuildRuntime ?? String.Empty, ExpanderOptions.ExpandAll, _taskNode.MSBuildRuntimeLocation ?? ElementLocation.EmptyLocation);
 
             IDictionary<string, string> taskIdentityParameters = null;
 
-            // only bother to create a task identity parameter set if we're putting anything in there -- otherwise, 
-            // a null set will be treated as equivalent to all parameters being "don't care". 
+            // only bother to create a task identity parameter set if we're putting anything in there -- otherwise,
+            // a null set will be treated as equivalent to all parameters being "don't care".
             if (msbuildRuntime != String.Empty || msbuildArchitecture != String.Empty)
             {
                 taskIdentityParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
@@ -825,7 +825,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
 
                     // Set the property "MSBuildLastTaskResult" to reflect whether the task succeeded or not.
                     // The main use of this is if ContinueOnError is true -- so that the next task can consult the result.
-                    // So we want it to be "false" even if ContinueOnError is true. 
+                    // So we want it to be "false" even if ContinueOnError is true.
                     // The constants "true" and "false" should NOT be localized. They become property values.
                     bucket.Lookup.SetProperty(ProjectPropertyInstance.Create(ReservedPropertyNames.lastTaskResult, taskResult ? "true" : "false", true/* may be reserved */, _buildRequestEntry.RequestConfiguration.Project.IsImmutable));
                 }
@@ -894,7 +894,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     }
                     else if (type == typeof(Exception) || type.GetTypeInfo().IsSubclassOf(typeof(Exception)))
                     {
-                        // Occasionally, when debugging a very uncommon task exception, it is useful to loop the build with 
+                        // Occasionally, when debugging a very uncommon task exception, it is useful to loop the build with
                         // a debugger attached to break on 2nd chance exceptions.
                         // That requires that there needs to be a way to not catch here, by setting an environment variable.
                         if (ExceptionHandling.IsCriticalException(taskException) || (Environment.GetEnvironmentVariable("MSBUILDDONOTCATCHTASKEXCEPTIONS") == "1"))
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 939370ab515..e9e1bf575a2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -6,22 +6,24 @@
 using System.Collections.Generic;
 using System.Globalization;
 #if FEATURE_APPDOMAIN
-using System.Runtime.Remoting.Lifetime;
 using System.Runtime.Remoting;
+using System.Runtime.Remoting.Lifetime;
 #endif
+using System.Diagnostics;
+using System.Reflection;
 using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Components.Caching;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Eventing;
+using Microsoft.Build.Execution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Execution;
-using System.Diagnostics;
-using Microsoft.Build.Collections;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Components.Caching;
-using System.Reflection;
-using Microsoft.Build.Eventing;
 
 #nullable disable
 
@@ -343,6 +345,14 @@ public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames,
         /// </summary>
         public void Yield()
         {
+#if FEATURE_REPORTFILEACCESSES
+            // If file accesses are being reported we should not yield as file access will be attributed to the wrong project.
+            if (_host.BuildParameters.ReportFileAccesses)
+            {
+                return;
+            }
+#endif
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -364,6 +374,14 @@ public void Reacquire()
             // to release explicitly granted cores when reacquiring the node may lead to deadlocks.
             ReleaseAllCores();
 
+#if FEATURE_REPORTFILEACCESSES
+            // If file accesses are being reported yielding is a no-op so reacquire should be too.
+            if (_host.BuildParameters.ReportFileAccesses)
+            {
+                return;
+            }
+#endif
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -377,7 +395,7 @@ public void Reacquire()
             }
         }
 
-        #endregion
+#endregion
 
         #region IBuildEngine Members
 
@@ -409,8 +427,8 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -419,7 +437,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
 
                 if (_convertErrorsToWarnings)
                 {
-                    // Convert the error into a warning.  We do this because the whole point of 
+                    // Convert the error into a warning.  We do this because the whole point of
                     // ContinueOnError is that a project author expects that the task might fail,
                     // but wants to ignore the failures.  This implies that we shouldn't be logging
                     // errors either, because you should never have a successful build with errors.
@@ -479,8 +497,8 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -520,8 +538,8 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -561,8 +579,8 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
                     return;
                 }
 
-                // If we are in building across process we need the events to be serializable. This method will 
-                // check to see if we are building with multiple process and if the event is serializable. It will 
+                // If we are in building across process we need the events to be serializable. This method will
+                // check to see if we are building with multiple process and if the event is serializable. It will
                 // also log a warning if the event is not serializable and drop the logging message.
                 if (IsRunningMultipleNodes && !IsEventSerializable(e))
                 {
@@ -920,11 +938,26 @@ public override bool LogsMessagesOfImportance(MessageImportance importance)
 
             /// <inheritdoc/>
             public override bool IsTaskInputLoggingEnabled => _taskHost._host.BuildParameters.LogTaskInputs;
+
+#if FEATURE_REPORTFILEACCESSES
+            /// <summary>
+            /// Reports a file access from a task.
+            /// </summary>
+            /// <param name="fileAccessData">The file access to report.</param>
+            public void ReportFileAccess(FileAccessData fileAccessData)
+            {
+                IBuildComponentHost buildComponentHost = _taskHost._host;
+                if (buildComponentHost.BuildParameters.ReportFileAccesses)
+                {
+                    ((IFileAccessManager)buildComponentHost.GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessData, buildComponentHost.BuildParameters.NodeId);
+                }
+            }
+#endif
         }
 
         public EngineServices EngineServices { get; }
 
-        #endregion
+#endregion
 
         /// <summary>
         /// Called by the internal MSBuild task.
@@ -990,7 +1023,7 @@ public override object InitializeLifetimeService()
                 ILease lease = (ILease)base.InitializeLifetimeService();
 
                 // Set how long a lease should be initially. Once a lease expires
-                // the remote object will be disconnected and it will be marked as being availiable 
+                // the remote object will be disconnected and it will be marked as being availiable
                 // for garbage collection
                 int initialLeaseTime = 1;
 
@@ -1012,7 +1045,7 @@ public override object InitializeLifetimeService()
                 // increase the lease time allowing the object to stay in memory
                 _sponsor = new ClientSponsor();
 
-                // When a new lease is requested lets make it last 1 minutes longer. 
+                // When a new lease is requested lets make it last 1 minutes longer.
                 int leaseExtensionTime = 1;
 
                 string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDENGINEPROXYLEASEEXTENSIONTIME");
@@ -1049,7 +1082,7 @@ internal void MarkAsInactive()
                 ReleaseAllCores();
 
                 // Since the task has a pointer to this class it may store it in a static field. Null out
-                // internal data so the leak of this object doesn't lead to a major memory leak.            
+                // internal data so the leak of this object doesn't lead to a major memory leak.
                 _host = null;
                 _requestEntry = null;
 
@@ -1141,7 +1174,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                 }
                 else
                 {
-                    // UNDONE: (Refactor) Investigate making this a ReadOnly collection of some sort.  
+                    // UNDONE: (Refactor) Investigate making this a ReadOnly collection of some sort.
                     PropertyDictionary<ProjectPropertyInstance>[] propertyDictionaries = new PropertyDictionary<ProjectPropertyInstance>[projectFileNames.Length];
 
                     for (int i = 0; i < projectFileNames.Length; i++)
diff --git a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
index d66e50d62c1..84e22a9c67c 100644
--- a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
@@ -33,6 +33,11 @@ internal interface IScheduler : IBuildComponent
         /// <returns>A positive configuration id if one exists in the plan, 0 otherwise.</returns>
         int GetConfigurationIdFromPlan(string configurationPath);
 
+        /// <summary>
+        /// Retrieves the request executing on a node.
+        /// </summary>
+        BuildRequest GetExecutingRequestByNode(int nodeId);
+
         /// <summary>
         /// Reports to the scheduler that a request is blocked.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 33d0de2f88c..4d7abb22231 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -40,7 +40,7 @@ internal enum SchedulableRequestState
         Blocked,
 
         /// <summary>
-        /// This request has yielded control of the node while it is running a long-running out-of-process program.  Any number of tasks on a 
+        /// This request has yielded control of the node while it is running a long-running out-of-process program.  Any number of tasks on a
         /// node may be in the yielding state.
         /// </summary>
         Yielding,
@@ -506,15 +506,15 @@ private void DetectCircularDependency(SchedulableRequest blockingRequest)
         /// of it having been previously scheduled in a multiproc scenario, but before this request was able to execute.
         /// </summary>
         /// <remarks>
-        /// Let A be 'this' project and B be 'blockingRequest' (the request which is going to block A.)  
-        /// An indirect circular dependency exists if there is a dependency path from B to A.  If there is no 
-        /// existing blocked request B' with the same global request id as B, then there can be no path from B to A because B is a brand new 
-        /// request with no other dependencies.  If there is an existing blocked request B' with the same global request ID as B, then we 
+        /// Let A be 'this' project and B be 'blockingRequest' (the request which is going to block A.)
+        /// An indirect circular dependency exists if there is a dependency path from B to A.  If there is no
+        /// existing blocked request B' with the same global request id as B, then there can be no path from B to A because B is a brand new
+        /// request with no other dependencies.  If there is an existing blocked request B' with the same global request ID as B, then we
         /// walk the set of dependencies recursively searching for A.  If A is found, we have a circular dependency.
         /// </remarks>
         private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest)
         {
-            // If there is already a blocked request which has the same configuration id as the blocking request and that blocked request is (recursively) 
+            // If there is already a blocked request which has the same configuration id as the blocking request and that blocked request is (recursively)
             // waiting on this request, then that is an indirect circular dependency.
             SchedulableRequest alternateRequest = _schedulingData.GetBlockedRequestIfAny(blockingRequest.BuildRequest.GlobalRequestId);
             if (alternateRequest == null)
@@ -539,7 +539,7 @@ private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest
                 evaluatedRequests.Add(requestToEvaluate);
 
                 // If the request is not scheduled, it's possible that is because it's been scheduled elsewhere and is blocked.
-                // Follow that path if it exists.                        
+                // Follow that path if it exists.
                 if (requestToEvaluate.State == SchedulableRequestState.Unscheduled)
                 {
                     requestToEvaluate = _schedulingData.GetBlockedRequestIfAny(requestToEvaluate.BuildRequest.GlobalRequestId);
@@ -567,7 +567,7 @@ private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest
         /// </summary>
         private void ThrowIndirectCircularDependency(SchedulableRequest blockingRequest, SchedulableRequest requestToEvaluate)
         {
-            // We found a request which has the same global request ID as us in a chain which leads from the (already blocked) request 
+            // We found a request which has the same global request ID as us in a chain which leads from the (already blocked) request
             // which is trying to block us.  Calculate its list of ancestors by walking up the parent list.
             List<SchedulableRequest> ancestors = new List<SchedulableRequest>(16);
             while (requestToEvaluate.Parent != null)
@@ -585,7 +585,7 @@ private void ThrowIndirectCircularDependency(SchedulableRequest blockingRequest,
         /// </summary>
         private void DetectDirectCircularDependency(SchedulableRequest blockingRequest)
         {
-            // A circular dependency occurs when this project (or any of its ancestors) has the same global request id as the 
+            // A circular dependency occurs when this project (or any of its ancestors) has the same global request id as the
             // blocking request.
             List<SchedulableRequest> ancestors = new List<SchedulableRequest>(16);
             SchedulableRequest currentRequest = this;
@@ -644,7 +644,7 @@ internal void DisconnectRequestWeAreBlockedBy(BlockingRequestKey blockingRequest
             _requestsWeAreBlockedBy.Remove(blockingRequestKey);
             unblockingRequest._requestsWeAreBlocking.Remove(this);
 
-            // If the request we are blocked by also happens to be unscheduled, remove it as well so we don't try to run it later.  This is 
+            // If the request we are blocked by also happens to be unscheduled, remove it as well so we don't try to run it later.  This is
             // because circular dependency errors cause us to fail all outstanding requests on the current request.  See BuildRequsetEntry.ReportResult.
             if (unblockingRequest.State == SchedulableRequestState.Unscheduled)
             {
diff --git a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
index bae176a6540..bc5e8f86256 100644
--- a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
+++ b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
@@ -25,7 +25,7 @@ internal enum ScheduleActionType
         Schedule,
 
         /// <summary>
-        /// The response indicates that the request should be send to the specified node, 
+        /// The response indicates that the request should be send to the specified node,
         /// along with the configuration for the request.
         /// </summary>
         ScheduleWithConfiguration,
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 53bf46ec2f3..2bae4049ae1 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -283,6 +283,20 @@ public int GetConfigurationIdFromPlan(string configPath)
             return _schedulingPlan.GetConfigIdForPath(configPath);
         }
 
+        /// <summary>
+        /// Retrieves the request executing on a node.
+        /// </summary>
+        public BuildRequest GetExecutingRequestByNode(int nodeId)
+        {
+            if (!_schedulingData.IsNodeWorking(nodeId))
+            {
+                return null;
+            }
+
+            SchedulableRequest request = _schedulingData.GetExecutingRequestByNode(nodeId);
+            return request.BuildRequest;
+        }
+
         /// <summary>
         /// Reports that the specified request has become blocked and cannot proceed.
         /// </summary>
@@ -318,7 +332,7 @@ public IEnumerable<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildReque
                 else if ((blocker.BlockingRequestId == blocker.BlockedRequestId) && blocker.BlockingRequestId != BuildRequest.InvalidGlobalRequestId)
                 {
                     ErrorUtilities.VerifyThrow(string.IsNullOrEmpty(blocker.BlockingTarget), "Blocking target should be null because this is not a request blocking on a target");
-                    // We are blocked waiting for a transfer of results.                    
+                    // We are blocked waiting for a transfer of results.
                     HandleRequestBlockedOnResultsTransfer(parentRequest, responses);
                 }
                 else if (blocker.BlockingRequestId != BuildRequest.InvalidGlobalRequestId)
@@ -349,7 +363,7 @@ public IEnumerable<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildReque
                 responses.Add(ScheduleResponse.CreateCircularDependencyResponse(nodeId, parentRequest.BuildRequest, ex.Request));
             }
 
-            // Now see if we can schedule requests somewhere since we 
+            // Now see if we can schedule requests somewhere since we
             // a) have a new request; and
             // b) have a node which is now waiting and not doing anything.
             ScheduleUnassignedRequests(responses);
@@ -368,7 +382,7 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
 
             if (result.NodeRequestId == BuildRequest.ResultsTransferNodeRequestId)
             {
-                // We are transferring results.  The node to which they should be sent has already been recorded by the 
+                // We are transferring results.  The node to which they should be sent has already been recorded by the
                 // HandleRequestBlockedOnResultsTransfer method in the configuration.
                 BuildRequestConfiguration config = _configCache[result.ConfigurationId];
                 ScheduleResponse response = ScheduleResponse.CreateReportResultResponse(config.ResultsNodeId, result);
@@ -380,7 +394,7 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
                 SchedulableRequest request = _schedulingData.GetExecutingRequest(result.GlobalRequestId);
                 request.Complete(result);
 
-                // Report results to our parent, or report submission complete as necessary.            
+                // Report results to our parent, or report submission complete as necessary.
                 if (request.Parent != null)
                 {
                     // responses.Add(new ScheduleResponse(request.Parent.AssignedNode, new BuildRequestUnblocker(request.Parent.BuildRequest.GlobalRequestId, result)));
@@ -388,10 +402,10 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
 
                     // When adding the result to the cache we merge the result with what ever is already in the cache this may cause
                     // the result to have more target outputs in it than was was requested.  To fix this we can ask the cache itself for the result we just added.
-                    // When results are returned from the cache we filter them based on the targets we requested. This causes our result to only 
+                    // When results are returned from the cache we filter them based on the targets we requested. This causes our result to only
                     // include the targets we requested rather than the merged result.
 
-                    // Note: In this case we do not need to log that we got the results from the cache because we are only using the cache 
+                    // Note: In this case we do not need to log that we got the results from the cache because we are only using the cache
                     // for filtering the targets for the result instead rather than using the cache as the location where this result came from.
                     ScheduleResponse response = TrySatisfyRequestFromCache(request.Parent.AssignedNode, request.BuildRequest, skippedResultsDoNotCauseCacheMiss: _componentHost.BuildParameters.SkippedResultsDoNotCauseCacheMiss());
 
@@ -429,13 +443,13 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
                         int parentNode = (unscheduledRequest.Parent == null) ? InvalidNodeId : unscheduledRequest.Parent.AssignedNode;
 
                         // There are other requests which we can satisfy based on this result, lets pull the result out of the cache
-                        // and satisfy those requests.  Normally a skipped result would lead to the cache refusing to satisfy the 
-                        // request, because the correct response in that case would be to attempt to rebuild the target in case there 
+                        // and satisfy those requests.  Normally a skipped result would lead to the cache refusing to satisfy the
+                        // request, because the correct response in that case would be to attempt to rebuild the target in case there
                         // are state changes that would cause it to now excute.  At this point, however, we already know that the parent
-                        // request has completed, and we already know that this request has the same global request ID, which means that 
-                        // its configuration and set of targets are identical -- from MSBuild's perspective, it's the same.  So since 
-                        // we're not going to attempt to re-execute it, if there are skipped targets in the result, that's fine. We just 
-                        // need to know what the target results are so that we can log them. 
+                        // request has completed, and we already know that this request has the same global request ID, which means that
+                        // its configuration and set of targets are identical -- from MSBuild's perspective, it's the same.  So since
+                        // we're not going to attempt to re-execute it, if there are skipped targets in the result, that's fine. We just
+                        // need to know what the target results are so that we can log them.
                         ScheduleResponse response = TrySatisfyRequestFromCache(parentNode, unscheduledRequest.BuildRequest, skippedResultsDoNotCauseCacheMiss: true);
 
                         // If we have a response we need to tell the loggers that we satisified that request from the cache.
@@ -445,8 +459,8 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
                         }
                         else
                         {
-                            // Response may be null if the result was never added to the cache. This can happen if the result has 
-                            // an exception in it. If that is the case, we should report the result directly so that the 
+                            // Response may be null if the result was never added to the cache. This can happen if the result has
+                            // an exception in it. If that is the case, we should report the result directly so that the
                             // build manager knows that it needs to shut down logging manually.
                             response = GetResponseForResult(parentNode, unscheduledRequest.BuildRequest, newResult.Clone());
                         }
@@ -507,7 +521,7 @@ public void ReportBuildAborted(int nodeId)
         {
             _schedulingData.EventTime = DateTime.UtcNow;
 
-            // Get the list of build requests currently assigned to the node and report aborted results for them.            
+            // Get the list of build requests currently assigned to the node and report aborted results for them.
             TraceScheduler("Build aborted by node {0}", nodeId);
 
             foreach (SchedulableRequest request in _schedulingData.GetScheduledRequestsByNode(nodeId))
@@ -727,15 +741,15 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
                 }
                 else if (_schedulingData.BlockedRequestsCount != 0)
                 {
-                    // It is legitimate to have blocked requests with none executing if none of the requests can 
-                    // be serviced by any currently existing node, or if they are blocked by requests, none of 
-                    // which can be serviced by any currently existing node.  However, in that case, we had better 
-                    // be requesting the creation of a node that can service them.  
+                    // It is legitimate to have blocked requests with none executing if none of the requests can
+                    // be serviced by any currently existing node, or if they are blocked by requests, none of
+                    // which can be serviced by any currently existing node.  However, in that case, we had better
+                    // be requesting the creation of a node that can service them.
                     //
-                    // Note: This is O(# nodes * closure of requests blocking current set of blocked requests), 
-                    // but all three numbers should usually be fairly small and, more importantly, this situation 
-                    // should occur at most once per build, since it requires a situation where all blocked requests 
-                    // are blocked on the creation of a node that can service them. 
+                    // Note: This is O(# nodes * closure of requests blocking current set of blocked requests),
+                    // but all three numbers should usually be fairly small and, more importantly, this situation
+                    // should occur at most once per build, since it requires a situation where all blocked requests
+                    // are blocked on the creation of a node that can service them.
                     foreach (SchedulableRequest request in _schedulingData.BlockedRequests)
                     {
                         if (RequestOrAnyItIsBlockedByCanBeServiced(request))
@@ -843,7 +857,7 @@ private bool GetSchedulingPlanAndAlgorithm()
 
                 if (!String.IsNullOrEmpty(customScheduler))
                 {
-                    // Assign to the delegate 
+                    // Assign to the delegate
                     if (customScheduler.Equals("WithPlanByMostImmediateReferences", StringComparison.OrdinalIgnoreCase) && _schedulingPlan.IsPlanValid)
                     {
                         _customRequestSchedulingAlgorithm = AssignUnscheduledRequestsWithPlanByMostImmediateReferences;
@@ -1142,7 +1156,7 @@ private void AssignUnscheduledRequestsWithMaxWaitingRequests(List<ScheduleRespon
                     BuildRequest currentRequest = currentSchedulableRequest.BuildRequest;
                     int requiredNodeId = _schedulingData.GetAssignedNodeForRequestConfiguration(currentRequest.ConfigurationId);
 
-                    // This performs the depth-first traversal, assuming that the unassigned build requests has been populated such that the 
+                    // This performs the depth-first traversal, assuming that the unassigned build requests has been populated such that the
                     // top-most requests are the ones most recently issued.  We schedule the first request which can be scheduled to this node.
                     if (requiredNodeId == InvalidNodeId || requiredNodeId == nodeId)
                     {
@@ -1276,7 +1290,7 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
 
             Dictionary<int, int> configurationCountsByNode = new Dictionary<int, int>(_availableNodes.Count);
 
-            // The configuration count limit will be the average configuration count * X (to allow for some wiggle room) where 
+            // The configuration count limit will be the average configuration count * X (to allow for some wiggle room) where
             // the default value of X is 1.1 (+ 10%)
             int configurationCountLimit = 0;
 
@@ -1315,8 +1329,8 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
                     {
                         int requiredNodeId = _schedulingData.GetAssignedNodeForRequestConfiguration(request.BuildRequest.ConfigurationId);
 
-                        // Only schedule an entirely new configuration (one not already tied to this node) to this node if we're 
-                        // not already over the limit needed to keep a reasonable balance. 
+                        // Only schedule an entirely new configuration (one not already tied to this node) to this node if we're
+                        // not already over the limit needed to keep a reasonable balance.
                         if (request.AssignedNode == nodeId || requiredNodeId == nodeId || configurationCountsByNode[nodeId] <= configurationCountLimit)
                         {
                             AssignUnscheduledRequestToNode(request, nodeId, responses);
@@ -1331,8 +1345,8 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
                 }
             }
 
-            // at this point, we may still have work left unassigned, but that's OK -- we're deliberately choosing to delay assigning all available 
-            // requests in order to avoid overloading certain nodes with excess numbers of requests.  
+            // at this point, we may still have work left unassigned, but that's OK -- we're deliberately choosing to delay assigning all available
+            // requests in order to avoid overloading certain nodes with excess numbers of requests.
         }
 
         /// <summary>
@@ -1409,7 +1423,7 @@ private bool AtSchedulingLimit()
                 return false;
             }
 
-            // We're at our limit of schedulable requests if: 
+            // We're at our limit of schedulable requests if:
             // (1) MaxNodeCount requests are currently executing
             if (_schedulingData.ExecutingRequestsCount >= _componentHost.BuildParameters.MaxNodeCount)
             {
@@ -1471,9 +1485,9 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
             {
                 int assignedNodeForConfiguration = _schedulingData.GetAssignedNodeForRequestConfiguration(request.BuildRequest.ConfigurationId);
 
-                // Although this request has not been scheduled, this configuration may previously have been 
-                // scheduled to an existing node.  If so, we shouldn't count it in our checks for new node 
-                // creation, because it'll only eventually get assigned to its existing node anyway.  
+                // Although this request has not been scheduled, this configuration may previously have been
+                // scheduled to an existing node.  If so, we shouldn't count it in our checks for new node
+                // creation, because it'll only eventually get assigned to its existing node anyway.
                 if (assignedNodeForConfiguration != Scheduler.InvalidNodeId)
                 {
                     continue;
@@ -1486,9 +1500,9 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                     case NodeAffinity.InProc:
                         inProcNodesToCreate++;
 
-                        // If we've previously seen "Any"-affinitized requests, now that there are some 
-                        // genuine inproc requests, they get to play with the inproc node first, so 
-                        // push the "Any" requests to the out-of-proc nodes.  
+                        // If we've previously seen "Any"-affinitized requests, now that there are some
+                        // genuine inproc requests, they get to play with the inproc node first, so
+                        // push the "Any" requests to the out-of-proc nodes.
                         if (requestsWithAnyAffinityOnInProcNodes > 0)
                         {
                             requestsWithAnyAffinityOnInProcNodes--;
@@ -1525,7 +1539,7 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                         break;
                 }
 
-                // We've already hit the limit of the number of nodes we'll be allowed to create, so just quit counting now. 
+                // We've already hit the limit of the number of nodes we'll be allowed to create, so just quit counting now.
                 if (inProcNodesToCreate >= availableNodesWithInProcAffinity && outOfProcNodesToCreate >= availableNodesWithOutOfProcAffinity)
                 {
                     break;
@@ -1535,7 +1549,7 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
             // If we think we want to create inproc nodes
             if (inProcNodesToCreate > 0)
             {
-                // In-proc node determination is simple: we want as many as are available.  
+                // In-proc node determination is simple: we want as many as are available.
                 inProcNodesToCreate = Math.Min(availableNodesWithInProcAffinity, inProcNodesToCreate);
 
                 // If we still want to create one, go ahead
@@ -1545,8 +1559,8 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                     TraceScheduler("Requesting creation of new node satisfying affinity {0}", NodeAffinity.InProc);
                     responses.Add(ScheduleResponse.CreateNewNodeResponse(NodeAffinity.InProc, 1));
 
-                    // We only want to submit one node creation request at a time -- as part of node creation we recursively re-request the scheduler 
-                    // to do more scheduling, so the other request will be dealt with soon enough.  
+                    // We only want to submit one node creation request at a time -- as part of node creation we recursively re-request the scheduler
+                    // to do more scheduling, so the other request will be dealt with soon enough.
                     return true;
                 }
             }
@@ -1554,17 +1568,17 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
             // If we think we want to create out-of-proc nodes
             if (outOfProcNodesToCreate > 0)
             {
-                // Out-of-proc node determination is a bit more complicated.  If we have N out-of-proc requests, we want to 
-                // fill up to N out-of-proc nodes.  However, if we have N "any" requests, we must assume that at least some of them 
-                // will be fulfilled by the inproc node, in which case we only want to launch up to N-1 out-of-proc nodes, for a 
-                // total of N nodes overall -- the scheduler will only schedule to N nodes at a time, so launching any more than that 
-                // is ultimately pointless. 
+                // Out-of-proc node determination is a bit more complicated.  If we have N out-of-proc requests, we want to
+                // fill up to N out-of-proc nodes.  However, if we have N "any" requests, we must assume that at least some of them
+                // will be fulfilled by the inproc node, in which case we only want to launch up to N-1 out-of-proc nodes, for a
+                // total of N nodes overall -- the scheduler will only schedule to N nodes at a time, so launching any more than that
+                // is ultimately pointless.
                 int maxCreatableOutOfProcNodes = availableNodesWithOutOfProcAffinity;
 
                 if (requestsWithOutOfProcAffinity < availableNodesWithOutOfProcAffinity)
                 {
-                    // We don't have enough explicitly out-of-proc requests to justify creating every technically allowed 
-                    // out-of-proc node, so our max is actually one less than the absolute max for the reasons explained above. 
+                    // We don't have enough explicitly out-of-proc requests to justify creating every technically allowed
+                    // out-of-proc node, so our max is actually one less than the absolute max for the reasons explained above.
                     maxCreatableOutOfProcNodes--;
                 }
 
@@ -1577,12 +1591,12 @@ private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerab
                     responses.Add(ScheduleResponse.CreateNewNodeResponse(NodeAffinity.OutOfProc, outOfProcNodesToCreate));
                 }
 
-                // We only want to submit one node creation request at a time -- as part of node creation we recursively re-request the scheduler 
-                // to do more scheduling, so the other request will be dealt with soon enough.  
+                // We only want to submit one node creation request at a time -- as part of node creation we recursively re-request the scheduler
+                // to do more scheduling, so the other request will be dealt with soon enough.
                 return true;
             }
 
-            // If we haven't returned before now, we haven't asked that any new nodes be created.  
+            // If we haven't returned before now, we haven't asked that any new nodes be created.
             return false;
         }
 
@@ -1647,14 +1661,14 @@ private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequ
             // we will update the storage location in the configuration.  This is doing a bit of a run around the scheduler - we don't
             // create a new formal request, so we treat the blocked request as if it is still executing - this prevents any other requests
             // from getting onto that node and also means we don't have to do additional work to get the scheduler to understand the bizarre
-            // case of sending a request for results from a project's own configuration (which it believes reside on the very node which 
+            // case of sending a request for results from a project's own configuration (which it believes reside on the very node which
             // is actually requesting the results in the first place.)
             BuildRequestConfiguration configuration = _configCache[parentRequest.BuildRequest.ConfigurationId];
             responses.Add(ScheduleResponse.CreateScheduleResponse(configuration.ResultsNodeId, newRequest, false));
 
             TraceScheduler("Created request {0} (node request {1}) for transfer of configuration {2}'s results from node {3} to node {4}", newRequest.GlobalRequestId, newRequest.NodeRequestId, configuration.ConfigurationId, configuration.ResultsNodeId, parentRequest.AssignedNode);
 
-            // The configuration's results will now be homed at the new location (once they have come back from the 
+            // The configuration's results will now be homed at the new location (once they have come back from the
             // original node.)
             configuration.ResultsNodeId = parentRequest.AssignedNode;
         }
@@ -1856,7 +1870,7 @@ private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest reque
                         responses.Add(response);
                     }
 
-                    // Is the node we are reporting to idle? If so, does reporting this result allow it to proceed with work? 
+                    // Is the node we are reporting to idle? If so, does reporting this result allow it to proceed with work?
                     if (!_schedulingData.IsNodeWorking(response.NodeId))
                     {
                         ResumeReadyRequestIfAny(response.NodeId, responses);
@@ -2090,7 +2104,7 @@ internal void RecordResultToCurrentCacheIfConfigNotInOverrideCache(BuildResult r
         /// </summary>
         private ScheduleResponse GetResponseForResult(int parentRequestNode, BuildRequest requestWhichGeneratedResult, BuildResult result)
         {
-            // We have results, return them to the originating node, or if it is a root request, mark the submission complete.      
+            // We have results, return them to the originating node, or if it is a root request, mark the submission complete.
             if (requestWhichGeneratedResult.IsRootRequest)
             {
                 // return new ScheduleResponse(result);
@@ -2209,9 +2223,9 @@ private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
                     }
                 }
 
-                // if none of the requests we are blocked by can be serviced, it doesn't matter 
-                // whether we can be serviced or not -- the reason we're blocked is because none 
-                // of the requests we are blocked by can be serviced. 
+                // if none of the requests we are blocked by can be serviced, it doesn't matter
+                // whether we can be serviced or not -- the reason we're blocked is because none
+                // of the requests we are blocked by can be serviced.
                 return false;
             }
             else
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index e28c86db050..18ba022d5a6 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -605,7 +605,7 @@ public IEnumerable<SchedulableRequest> GetReadyRequestsByNode(int nodeId)
         }
 
         /// <summary>
-        /// Retrieves a set of build requests which have the specified parent.  If root is null, this will retrieve all of the 
+        /// Retrieves a set of build requests which have the specified parent.  If root is null, this will retrieve all of the
         /// top-level requests.
         /// </summary>
         public IEnumerable<SchedulableRequest> GetRequestsByHierarchy(SchedulableRequest root)
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 19f75d8da72..c15b5a25063 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -462,7 +462,7 @@ private void RecursiveAccumulateConfigurationTimes(SchedulableRequest request, D
         {
             double accumulatedTime;
 
-            // NOTE: Do we want to count it each time the config appears in the hierarchy?  This will inflate the 
+            // NOTE: Do we want to count it each time the config appears in the hierarchy?  This will inflate the
             // cost of frequently referenced configurations.
             accumulatedTimeByConfiguration.TryGetValue(request.BuildRequest.ConfigurationId, out accumulatedTime);
             accumulatedTimeByConfiguration[request.BuildRequest.ConfigurationId] = accumulatedTime + request.GetTimeSpentInState(SchedulableRequestState.Executing).TotalMilliseconds;
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverLoader.cs
new file mode 100644
index 00000000000..4c765982f88
--- /dev/null
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverLoader.cs
@@ -0,0 +1,91 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BackEnd.SdkResolution
+{
+    /// <summary>
+    /// A subclass of <see cref="SdkResolverLoader"/> which creates resolver manifests and SDK resolvers only once and
+    /// then returns cached results.
+    /// </summary>
+    internal sealed class CachingSdkResolverLoader : SdkResolverLoader
+    {
+        /// <summary>
+        /// Cached list of default resolvers. Set eagerly.
+        /// </summary>
+        private readonly IReadOnlyList<SdkResolver> _defaultResolvers;
+
+        /// <summary>
+        /// Cached manifest -> resolver dictionary. Populated lazily.
+        /// </summary>
+        private readonly ConcurrentDictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>> _resolversByManifest = new();
+
+        /// <summary>
+        /// Cached list of all resolvers. Set lazily.
+        /// </summary>
+        private IReadOnlyList<SdkResolver>? _allResolvers;
+
+        /// <summary>
+        /// Cached list of all resolver manifests. Set lazily.
+        /// </summary>
+        private IReadOnlyList<SdkResolverManifest>? _resolversManifests;
+
+        /// <summary>
+        /// A lock object protecting <see cref="_allResolvers"/> and <see cref="_resolversManifests"/>.
+        /// </summary>
+        private readonly object _lock = new();
+
+        /// <summary>
+        /// A static instance of <see cref="CachingSdkResolverLoader"/>.
+        /// </summary>
+        /// <remarks>
+        /// The set of available SDK resolvers is expected to be fixed for the given MSBuild installation so it should be safe to use
+        /// a static instance as opposed to creating <see cref="CachingSdkResolverLoader"/> or <see cref="SdkResolverLoader"/> for each
+        /// <see cref="SdkResolverService" /> instance.
+        /// </remarks>
+        public static CachingSdkResolverLoader Instance = new CachingSdkResolverLoader();
+
+        /// <summary>
+        /// Initializes a new instance by setting <see cref="_defaultResolvers"/>.
+        /// </summary>
+        public CachingSdkResolverLoader()
+        {
+            _defaultResolvers = base.GetDefaultResolvers();
+        }
+
+        #region SdkResolverLoader overrides
+
+        /// <inheritdoc />
+        internal override IReadOnlyList<SdkResolver> GetDefaultResolvers() => _defaultResolvers;
+
+        /// <inheritdoc />
+        internal override IReadOnlyList<SdkResolver> LoadAllResolvers(ElementLocation location)
+        {
+            lock (_lock)
+            {
+                return _allResolvers ??= base.LoadAllResolvers(location);
+            }
+        }
+
+        /// <inheritdoc />
+        internal override IReadOnlyList<SdkResolverManifest> GetResolversManifests(ElementLocation location)
+        {
+            lock (_lock)
+            {
+                return _resolversManifests ??= base.GetResolversManifests(location);
+            }
+        }
+
+        /// <inheritdoc />
+        protected internal override IReadOnlyList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, ElementLocation location)
+        {
+            return _resolversByManifest.GetOrAdd(manifest, (manifest) => base.LoadResolversFromManifest(manifest, location));
+        }
+
+        #endregion
+    }
+}
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 2e198bf29f6..0f79c18d598 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -41,7 +41,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
 
             bool wasResultCached = true;
 
-            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath ?? string.Empty, projectPath ?? string.Empty);
 
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
             {
@@ -79,7 +79,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
             }
 
-            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success, wasResultCached);
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath ?? string.Empty, projectPath ?? string.Empty, result.Success, wasResultCached);
 
             return result;
         }
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 8b937f7c5e6..b4ddbd55220 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -39,7 +39,7 @@ public static IBuildComponent CreateComponent(BuildComponentType type)
         }
 
         // Test hook
-        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
+        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IReadOnlyList<SdkResolver> resolvers = null)
         {
             ((CachingSdkResolverService)_cachedSdkResolver).InitializeForTests(resolverLoader, resolvers);
         }
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 40dc8ffdf2b..5241e228c2f 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// sends requests to the main node that SDK resolution is handled in a central location.  This instance is registered in <see cref="Microsoft.Build.Execution.OutOfProcNode"/>
     /// using a factory so that parameters can be passed to the constructor.  This service caches responses for a given build so that it can avoid sending
     /// a packet where possible.  The cache is always in effect here because the out-of-proc node is only used for builds.
-    /// 
+    ///
     /// Since this object is a registered <see cref="IBuildComponent"/>, it is a singleton for the main process.  To get an instance of it, you
     /// must have access to an <see cref="IBuildComponentHost"/> and call <see cref="IBuildComponentHost.GetComponent"/> and pass <see cref="BuildComponentType.SdkResolverService"/>.
     /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverServiceFactory.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverServiceFactory.cs
index 6c739e55493..4c0415bce26 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverServiceFactory.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverServiceFactory.cs
@@ -8,7 +8,7 @@
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
     /// <summary>
-    /// A factory used when creating a <see cref="OutOfProcNodeSdkResolverService"/> which can pass parameters to its constructor.  Our 
+    /// A factory used when creating a <see cref="OutOfProcNodeSdkResolverService"/> which can pass parameters to its constructor.  Our
     /// dependency inject cannot pass parameters to constructors so this factory is used as a middle man.
     /// </summary>
     internal sealed class OutOfProcNodeSdkResolverServiceFactory
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 4bb7ed9bfb1..25039ccd712 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -34,19 +34,18 @@ internal class SdkResolverLoader
 #endif
             ?? Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
 
-        internal virtual IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
+        internal virtual IReadOnlyList<SdkResolver> GetDefaultResolvers()
         {
-            var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
+            var resolvers = !string.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
                 new List<SdkResolver> { new DefaultSdkResolver() }
                 : new List<SdkResolver>();
 
             return resolvers;
         }
 
-        internal virtual IList<SdkResolver> LoadAllResolvers(LoggingContext loggingContext,
-            ElementLocation location)
+        internal virtual IReadOnlyList<SdkResolver> LoadAllResolvers(ElementLocation location)
         {
-            var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
+            var resolvers = !string.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
                 new List<SdkResolver> { new DefaultSdkResolver() }
                 : new List<SdkResolver>();
 
@@ -60,14 +59,13 @@ internal virtual IList<SdkResolver> LoadAllResolvers(LoggingContext loggingConte
 
             foreach (var potentialResolver in potentialResolvers)
             {
-                LoadResolvers(potentialResolver, loggingContext, location, resolvers);
+                LoadResolvers(potentialResolver, location, resolvers);
             }
 
             return resolvers.OrderBy(t => t.Priority).ToList();
         }
 
-        internal virtual IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,
-            ElementLocation location)
+        internal virtual IReadOnlyList<SdkResolverManifest> GetResolversManifests(ElementLocation location)
         {
             return FindPotentialSdkResolversManifests(
                 Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot, "SdkResolvers"), location);
@@ -80,14 +78,14 @@ internal virtual IList<SdkResolverManifest> GetResolversManifests(LoggingContext
         /// <param name="rootFolder"></param>
         /// <param name="location"></param>
         /// <returns></returns>
-        internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
+        internal virtual IReadOnlyList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
         {
             var manifestsList = FindPotentialSdkResolversManifests(rootFolder, location);
 
             return manifestsList.Select(manifest => manifest.Path).ToList();
         }
 
-        internal virtual IList<SdkResolverManifest> FindPotentialSdkResolversManifests(string rootFolder, ElementLocation location)
+        internal virtual IReadOnlyList<SdkResolverManifest> FindPotentialSdkResolversManifests(string rootFolder, ElementLocation location)
         {
             List<SdkResolverManifest> manifestsList = new List<SdkResolverManifest>();
 
@@ -183,14 +181,12 @@ private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifes
                 //   <Path>...</Path>
                 //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>
                 // </SdkResolver>
-                manifest = SdkResolverManifest.Load(pathToManifest);
+                manifest = SdkResolverManifest.Load(pathToManifest, manifestFolder);
 
                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))
                 {
                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, string.Empty);
                 }
-
-                manifest.Path = FileUtilities.FixFilePath(manifest.Path);
             }
             catch (XmlException e)
             {
@@ -198,12 +194,6 @@ private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifes
                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, "SdkResolverManifestInvalid", pathToManifest, e.Message);
             }
 
-            if (!Path.IsPathRooted(manifest.Path))
-            {
-                manifest.Path = Path.Combine(manifestFolder, manifest.Path);
-                manifest.Path = Path.GetFullPath(manifest.Path);
-            }
-
             if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))
             {
                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, manifest.Path);
@@ -233,28 +223,42 @@ protected virtual IEnumerable<Type> GetResolverTypes(Assembly assembly)
                 .Select(t => t.type);
         }
 
-        protected virtual Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location)
+        protected virtual Assembly LoadResolverAssembly(string resolverPath)
         {
 #if !FEATURE_ASSEMBLYLOADCONTEXT
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
+            {
+                string resolverFileName = Path.GetFileNameWithoutExtension(resolverPath);
+                if (resolverFileName.Equals("Microsoft.DotNet.MSBuildSdkResolver", StringComparison.OrdinalIgnoreCase))
+                {
+                    // This will load the resolver assembly into the default load context if possible, and fall back to LoadFrom context.
+                    // We very much prefer the default load context because it allows native images to be used by the CLR, improving startup perf.
+                    AssemblyName assemblyName = new AssemblyName(resolverFileName)
+                    {
+                        CodeBase = resolverPath,
+                    };
+                    return Assembly.Load(assemblyName);
+                }
+            }
             return Assembly.LoadFrom(resolverPath);
 #else
             return s_loader.LoadFromPath(resolverPath);
 #endif
         }
 
-        protected internal virtual IList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)
+        protected internal virtual IReadOnlyList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, ElementLocation location)
         {
             var resolvers = new List<SdkResolver>();
-            LoadResolvers(manifest.Path, loggingContext, location, resolvers);
+            LoadResolvers(manifest.Path, location, resolvers);
             return resolvers;
         }
 
-        protected virtual void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
+        protected virtual void LoadResolvers(string resolverPath, ElementLocation location, List<SdkResolver> resolvers)
         {
             Assembly assembly;
             try
             {
-                assembly = LoadResolverAssembly(resolverPath, loggingContext, location);
+                assembly = LoadResolverAssembly(resolverPath);
             }
             catch (Exception e)
             {
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 85943ff9442..3e319d90adf 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// <summary>
     /// Serialization contract for an SDK Resolver manifest
     /// </summary>
-    internal class SdkResolverManifest
+    internal sealed class SdkResolverManifest
     {
         private SdkResolverManifest()
         {
@@ -33,17 +33,17 @@ public SdkResolverManifest(string DisplayName, string Path, Regex ResolvableSdkR
         /// <remarks>
         /// This field should be used only for logging purposes. Do not use for any actual processing, unless that are tests.
         /// </remarks>
-        public string DisplayName { get; set; }
+        public string DisplayName { get; private set; }
 
         /// <summary>
         /// Path for resolvers dll location.
         /// </summary>
-        public string Path { get; set; }
+        public string Path { get; private set; }
 
         /// <summary>
-        /// Regex which matches all the sdk names that could be resolved by the resolvers associated with given manifest.  
+        /// Regex which matches all the sdk names that could be resolved by the resolvers associated with given manifest.
         /// </summary>
-        public Regex ResolvableSdkRegex { get; set; }
+        public Regex ResolvableSdkRegex { get; private set; }
 
         /// <summary>
         /// The time-out interval for the name pattern regex in milliseconds.
@@ -58,8 +58,9 @@ public SdkResolverManifest(string DisplayName, string Path, Regex ResolvableSdkR
         /// Deserialize the file into an SdkResolverManifest.
         /// </summary>
         /// <param name="filePath">Path to the manifest xml file.</param>
+        /// <param name="manifestFolder">Path to the directory containing the manifest.</param>
         /// <returns>New deserialized collection instance.</returns>
-        internal static SdkResolverManifest Load(string filePath)
+        internal static SdkResolverManifest Load(string filePath, string manifestFolder)
         {
             XmlReaderSettings readerSettings = new XmlReaderSettings()
             {
@@ -76,7 +77,16 @@ internal static SdkResolverManifest Load(string filePath)
                 {
                     if (reader.NodeType == XmlNodeType.Element && reader.Name == "SdkResolver")
                     {
-                        return ParseSdkResolverElement(reader, filePath);
+                        SdkResolverManifest manifest = ParseSdkResolverElement(reader, filePath);
+
+                        manifest.Path = FileUtilities.FixFilePath(manifest.Path);
+                        if (!System.IO.Path.IsPathRooted(manifest.Path))
+                        {
+                            manifest.Path = System.IO.Path.Combine(manifestFolder, manifest.Path);
+                            manifest.Path = System.IO.Path.GetFullPath(manifest.Path);
+                        }
+
+                        return manifest;
                     }
                     else
                     {
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index a684c59618a..a9e03193f11 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -46,12 +46,12 @@ internal class SdkResolverService : ISdkResolverService
         /// <remarks>
         /// Need it for supporting the ChangeWave less than <see cref="ChangeWaves.Wave17_4"/>. Remove when move out Wave17_4.
         /// </remarks>
-        private IList<SdkResolver> _resolversList;
+        private IReadOnlyList<SdkResolver> _resolversList;
 
         /// <summary>
         /// Stores the loaded SDK resolvers, mapped to the manifest from which they came.
         /// </summary>
-        private Dictionary<SdkResolverManifest, IList<SdkResolver>> _manifestToResolvers;
+        private Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>> _manifestToResolvers;
 
         /// <summary>
         /// Stores the list of manifests of specific SDK resolvers which could be loaded.
@@ -66,7 +66,13 @@ internal class SdkResolverService : ISdkResolverService
         /// <summary>
         /// Stores an <see cref="SdkResolverLoader"/> which can load registered SDK resolvers.
         /// </summary>
-        private SdkResolverLoader _sdkResolverLoader = new SdkResolverLoader();
+        /// <remarks>
+        /// Unless the 17.10 changewave is disabled, we use a singleton instance because the set of SDK resolvers
+        /// is not expected to change during the lifetime of the process.
+        /// </remarks>
+        private SdkResolverLoader _sdkResolverLoader = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)
+            ? CachingSdkResolverLoader.Instance
+            : new SdkResolverLoader();
 
         public SdkResolverService()
         {
@@ -145,7 +151,7 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
         {
             if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)
             {
-                RegisterResolversManifests(loggingContext, sdkReferenceLocation);
+                RegisterResolversManifests(sdkReferenceLocation);
             }
 
             // Pick up the matching specific resolvers from the list of resolvers.
@@ -195,7 +201,7 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
                 warnings.AddRange(firstWarnings);
             }
 
-            // Second pass: fallback to general resolvers. 
+            // Second pass: fallback to general resolvers.
             resolvers = GetResolvers(
                 _generalResolversManifestsRegistry,
                 loggingContext,
@@ -238,7 +244,7 @@ private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManif
             List<SdkResolver> resolvers = new List<SdkResolver>();
             foreach (var resolverManifest in resolversManifests)
             {
-                if (!_manifestToResolvers.TryGetValue(resolverManifest, out IList<SdkResolver> newResolvers))
+                if (!_manifestToResolvers.TryGetValue(resolverManifest, out IReadOnlyList<SdkResolver> newResolvers))
                 {
                     lock (_lockObject)
                     {
@@ -246,9 +252,9 @@ private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManif
                         {
                             // Loading of the needed resolvers.
                             MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();
-                            newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, loggingContext, sdkReferenceLocation);
+                            newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, sdkReferenceLocation);
                             _manifestToResolvers[resolverManifest] = newResolvers;
-                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(resolverManifest.DisplayName, newResolvers.Count);
+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(resolverManifest.DisplayName ?? string.Empty, newResolvers.Count);
                         }
                     }
                 }
@@ -265,7 +271,7 @@ private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk
             // Lazy initialize all SDK resolvers
             if (_resolversList == null)
             {
-                Initialize(loggingContext, sdkReferenceLocation);
+                Initialize(sdkReferenceLocation);
             }
 
             TryResolveSdkUsingSpecifiedResolvers(
@@ -286,7 +292,7 @@ private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk
         }
 
         private bool TryResolveSdkUsingSpecifiedResolvers(
-            IList<SdkResolver> resolvers,
+            IReadOnlyList<SdkResolver> resolvers,
             int submissionId,
             SdkReference sdk,
             LoggingContext loggingContext,
@@ -340,7 +346,7 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
                 }
                 finally
                 {
-                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath, projectPath, result?.Path, result?.Success ?? false);
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath ?? string.Empty, projectPath ?? string.Empty, result?.Path ?? string.Empty, result?.Success ?? false);
                 }
 
                 SetResolverState(submissionId, sdkResolver, context.State);
@@ -379,7 +385,7 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
         /// </summary>
         /// <param name="resolverLoader">An <see cref="SdkResolverLoader"/> to use for loading SDK resolvers.</param>
         /// <param name="resolvers">Explicit set of SdkResolvers to use for all SDK resolution.</param>
-        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
+        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IReadOnlyList<SdkResolver> resolvers = null)
         {
             if (resolverLoader != null)
             {
@@ -397,7 +403,7 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<
                 {
                     _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
                     _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
-                    _manifestToResolvers = new Dictionary<SdkResolverManifest, IList<SdkResolver>>();
+                    _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
 
                     SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
                     _generalResolversManifestsRegistry.Add(sdkResolverManifest);
@@ -444,7 +450,7 @@ private object GetResolverState(int submissionId, SdkResolver resolver)
             return null;
         }
 
-        private void Initialize(LoggingContext loggingContext, ElementLocation location)
+        private void Initialize(ElementLocation location)
         {
             lock (_lockObject)
             {
@@ -454,12 +460,12 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)
                 }
 
                 MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
-                _resolversList = _sdkResolverLoader.LoadAllResolvers(loggingContext, location);
+                _resolversList = _sdkResolverLoader.LoadAllResolvers(location);
                 MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolversList.Count);
             }
         }
 
-        private void RegisterResolversManifests(LoggingContext loggingContext, ElementLocation location)
+        private void RegisterResolversManifests(ElementLocation location)
         {
             lock (_lockObject)
             {
@@ -469,19 +475,19 @@ private void RegisterResolversManifests(LoggingContext loggingContext, ElementLo
                 }
 
                 MSBuildEventSource.Log.SdkResolverServiceFindResolversManifestsStart();
-                var allResolversManifests = _sdkResolverLoader.GetResolversManifests(loggingContext, location);
+                var allResolversManifests = _sdkResolverLoader.GetResolversManifests(location);
 
-                _manifestToResolvers = new Dictionary<SdkResolverManifest, IList<SdkResolver>>();
+                _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
 
                 // Load and add the manifest for the default resolvers, located directly in this dll.
-                IList<SdkResolver> defaultResolvers = _sdkResolverLoader.GetDefaultResolvers(loggingContext, location);
+                IReadOnlyList<SdkResolver> defaultResolvers = _sdkResolverLoader.GetDefaultResolvers();
+                SdkResolverManifest sdkDefaultResolversManifest = null;
                 if (defaultResolvers.Count > 0)
                 {
                     MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();
-                    SdkResolverManifest sdkDefaultResolversManifest = new SdkResolverManifest(DisplayName: "DefaultResolversManifest", Path: null, ResolvableSdkRegex: null);
-                    allResolversManifests.Add(sdkDefaultResolversManifest);
+                    sdkDefaultResolversManifest = new SdkResolverManifest(DisplayName: "DefaultResolversManifest", Path: null, ResolvableSdkRegex: null);
                     _manifestToResolvers[sdkDefaultResolversManifest] = defaultResolvers;
-                    MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(sdkDefaultResolversManifest.DisplayName, defaultResolvers.Count);
+                    MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(sdkDefaultResolversManifest.DisplayName ?? string.Empty, defaultResolvers.Count);
                 }
 
                 MSBuildEventSource.Log.SdkResolverServiceFindResolversManifestsStop(allResolversManifests.Count);
@@ -500,6 +506,10 @@ private void RegisterResolversManifests(LoggingContext loggingContext, ElementLo
                         _specificResolversManifestsRegistry.Add(manifest);
                     }
                 }
+                if (sdkDefaultResolversManifest != null)
+                {
+                    _generalResolversManifestsRegistry.Add(sdkDefaultResolversManifest);
+                }
             }
         }
 
diff --git a/src/Build/BackEnd/Node/NativeMethods.cs b/src/Build/BackEnd/Node/NativeMethods.cs
index b986a5bce03..c1540aae0c2 100644
--- a/src/Build/BackEnd/Node/NativeMethods.cs
+++ b/src/Build/BackEnd/Node/NativeMethods.cs
@@ -86,8 +86,8 @@ internal struct STARTUP_INFO
             internal string lpDesktop;
 
             /// <summary>
-            /// For console processes, this is the title displayed in the title bar if a new console window is created. 
-            /// If NULL, the name of the executable file is used as the window title instead. 
+            /// For console processes, this is the title displayed in the title bar if a new console window is created.
+            /// If NULL, the name of the executable file is used as the window title instead.
             /// This parameter must be NULL for GUI or console processes that do not create a new console window
             /// </summary>
             internal string lpTitle;
@@ -103,7 +103,7 @@ internal struct STARTUP_INFO
             internal Int32 dwY;
 
             /// <summary>
-            /// If dwFlags specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored. 
+            /// If dwFlags specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored.
             /// </summary>
             internal Int32 dwXSize;
 
@@ -118,12 +118,12 @@ internal struct STARTUP_INFO
             internal Int32 dwXCountChars;
 
             /// <summary>
-            /// If dwFlags specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.dwFillAttribute 
+            /// If dwFlags specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.dwFillAttribute
             /// </summary>
             internal Int32 dwYCountChars;
 
             /// <summary>
-            /// If dwFlags specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored. 
+            /// If dwFlags specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored.
             /// </summary>
             internal Int32 dwFillAttribute;
 
@@ -177,12 +177,12 @@ internal struct SECURITY_ATTRIBUTES
 
             /// <summary>
             /// A pointer to a security descriptor for the object that controls the sharing of it.
-            /// If NULL is specified for this member, the object is assigned the default security descriptor of the calling process. 
-            /// This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). 
+            /// If NULL is specified for this member, the object is assigned the default security descriptor of the calling process.
+            /// This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL).
             /// The default security descriptor is based on the default DACL of the access token belonging to the calling process.
-            /// By default, the default DACL in the access token of a process allows access only to the user represented by the access token. 
-            /// If other users must access the object, you can either create a security descriptor with the appropriate access, 
-            /// or add ACEs to the DACL that grants access to a group of users. 
+            /// By default, the default DACL in the access token of a process allows access only to the user represented by the access token.
+            /// If other users must access the object, you can either create a security descriptor with the appropriate access,
+            /// or add ACEs to the DACL that grants access to a group of users.
             /// </summary>
             public IntPtr lpSecurityDescriptor;
 
@@ -212,7 +212,7 @@ internal struct PROCESS_INFORMATION
 
             /// <summary>
             /// A value that can be used to identify a process.
-            /// The value is valid from the time the process is created until all handles to the process are closed and 
+            /// The value is valid from the time the process is created until all handles to the process are closed and
             /// the process object is freed; at this point, the identifier may be reused.
             /// </summary>
             public int dwProcessId;
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 0b678346842..2caec69b11d 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -7,6 +7,7 @@
 using System.Diagnostics;
 
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
 #nullable disable
 
@@ -161,7 +162,28 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _buildParameters, BuildParameters.FactoryForDeserialization);
             translator.TranslateArray(ref _forwardingLoggers, LoggerDescription.FactoryForTranslation);
 #if FEATURE_APPDOMAIN
-            translator.TranslateDotNet(ref _appDomainSetup);
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
+            {
+                byte[] appDomainConfigBytes = null;
+
+                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+                if (translator.Mode == TranslationDirection.WriteToStream)
+                {
+                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+                }
+
+                translator.Translate(ref appDomainConfigBytes);
+
+                if (translator.Mode == TranslationDirection.ReadFromStream)
+                {
+                    _appDomainSetup = new AppDomainSetup();
+                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
+                }
+            }
+            else
+            {
+                translator.TranslateDotNet(ref _appDomainSetup);
+            }
 #endif
             translator.Translate(ref _loggingNodeConfiguration);
         }
@@ -173,6 +195,7 @@ internal static INodePacket FactoryForDeserialization(ITranslator translator)
         {
             NodeConfiguration configuration = new NodeConfiguration();
             configuration.Translate(translator);
+
             return configuration;
         }
         #endregion
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 619c476a1f6..afa0d2aec65 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -153,11 +154,15 @@ public OutOfProcNode()
 
             // Create a factory for the out-of-proc SDK resolver service which can pass our SendPacket delegate to be used for sending packets to the main node
             OutOfProcNodeSdkResolverServiceFactory sdkResolverServiceFactory = new OutOfProcNodeSdkResolverServiceFactory(SendPacket);
-
             ((IBuildComponentHost)this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
-
             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
 
+#if FEATURE_REPORTFILEACCESSES
+            ((IBuildComponentHost)this).RegisterFactory(
+                BuildComponentType.FileAccessManager,
+                (componentType) => OutOfProcNodeFileAccessManager.CreateComponent(componentType, SendPacket));
+#endif
+
             if (s_projectRootElementCacheBase == null)
             {
                 s_projectRootElementCacheBase = new ProjectRootElementCache(true /* automatically reload any changes from disk */);
@@ -369,6 +374,13 @@ private void OnRequestComplete(BuildRequest request, BuildResult result)
             {
                 _nodeEndpoint.SendData(result);
             }
+
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                FileAccessManager.NotifyFileAccessCompletion(result.GlobalRequestId);
+            }
+#endif
         }
 
         /// <summary>
@@ -574,8 +586,9 @@ private void SendPacket(INodePacket packet)
             {
 #if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
-                    && logMessage.EventType == LoggingEventType.CustomEvent 
-                    && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) 
+                    && logMessage.EventType == LoggingEventType.CustomEvent
+                    &&
+                    (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
                     && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
                 {
                     BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
@@ -716,7 +729,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             }
 
             // We want to make sure the global project collection has the toolsets which were defined on the parent
-            // so that any custom toolsets defined can be picked up by tasks who may use the global project collection but are 
+            // so that any custom toolsets defined can be picked up by tasks who may use the global project collection but are
             // executed on the child node.
             ICollection<Toolset> parentToolSets = _buildParameters.ToolsetProvider.Toolsets;
             if (parentToolSets != null)
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index f419172153b..aa28f7213e0 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Experimental
 {
     /// <summary>
-    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server 
+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server
     /// </summary>
     public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler
     {
@@ -69,7 +69,7 @@ public delegate (int exitCode, string exitType) BuildCallback(
 
         /// <summary>
         /// Indicate that cancel has been requested and initiated.
-        /// </summary>        
+        /// </summary>
         private bool _cancelRequested = false;
         private string _serverBusyMutexName = default!;
 
@@ -92,7 +92,7 @@ public OutOfProcServerNode(BuildCallback buildFunction)
         /// <summary>
         /// Starts up the server node and processes all build requests until the server is requested to shut down.
         /// </summary>
-        /// <param name="shutdownException">The exception which caused shutdown, if any.</param> 
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
         /// <returns>The reason for shutting down.</returns>
         public NodeEngineShutdownReason Run(out Exception? shutdownException)
         {
diff --git a/src/Build/BackEnd/Shared/BuildAbortedException.cs b/src/Build/BackEnd/Shared/BuildAbortedException.cs
index d62a1504c70..8588ba771dd 100644
--- a/src/Build/BackEnd/Shared/BuildAbortedException.cs
+++ b/src/Build/BackEnd/Shared/BuildAbortedException.cs
@@ -88,7 +88,7 @@ protected override void InitializeCustomState(IDictionary<string, string> state)
         }
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
 #if NET8_0_OR_GREATER
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 838210573f6..eda42874f86 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -306,7 +306,7 @@ public bool IsTraversal
                     }
                     else if (FileUtilities.IsMetaprojectFilename(ProjectFullPath))
                     {
-                        // Metaprojects generated by the SolutionProjectGenerator are traversals.  They have no 
+                        // Metaprojects generated by the SolutionProjectGenerator are traversals.  They have no
                         // on-disk representation - they are ProjectInstances which exist only in memory.
                         _isTraversalProject = true;
                     }
diff --git a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
index 6617ff8b911..6f5ab6e48d6 100644
--- a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.BackEnd
     /// There are two cases:
     /// 1. The request was blocked waiting on a target in the same project.  In this case this class will contain
     ///    no information other than the request id.
-    /// 2. The request was blocked on some set of build requests.  This class will then contain the build results 
+    /// 2. The request was blocked on some set of build requests.  This class will then contain the build results
     ///    needed to satisfy those requests.
     /// </summary>
     internal class BuildRequestUnblocker : ITranslatable, INodePacket
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 149ec426518..68aa197381f 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -311,7 +311,7 @@ public int NodeRequestId
         }
 
         /// <summary>
-        /// Returns the exception generated while this result was run, if any. 
+        /// Returns the exception generated while this result was run, if any.
         /// </summary>
         public Exception Exception
         {
@@ -657,8 +657,8 @@ private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDict
         }
 
         /// <summary>
-        /// Creates the target result dictionary and populates it with however many target results are 
-        /// available given the list of targets passed. 
+        /// Creates the target result dictionary and populates it with however many target results are
+        /// available given the list of targets passed.
         /// </summary>
         private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDictionaryWithContents(BuildResult existingResults, string[] targetNames)
         {
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 2840148876c..d435d1c3606 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -185,7 +185,7 @@ void ITranslatable.Translate(ITranslator translator)
             {
                 lock (_result)
                 {
-                    // Should we have cached these items but now want to send them to another node, we need to 
+                    // Should we have cached these items but now want to send them to another node, we need to
                     // ensure they are loaded before doing so.
                     RetrieveItemsFromCache();
                     InternalTranslate(translator);
@@ -305,7 +305,7 @@ private void TranslateItems(ITranslator translator)
                 // When creating the interner, we use the number of items as the initial size of the collections since the
                 // number of strings will be of the order of the number of items in the collection.  This assumes basically
                 // one unique string per item (frequently a path related to the item) with most of the rest of the metadata
-                // being the same (and thus interning.)  This is a hueristic meant to get us in the ballpark to avoid 
+                // being the same (and thus interning.)  This is a hueristic meant to get us in the ballpark to avoid
                 // too many reallocations when growing the collections.
                 var interner = new LookasideStringInterner(StringComparer.Ordinal, _items.Length);
                 foreach (TaskItem t in _items)
diff --git a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
index 6d25f2f4688..60dfee13d2c 100644
--- a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
@@ -41,7 +41,7 @@ internal enum TaskRequirements
     /// are pass-throughs to just set some member variables and call methods directly on the task and associated objects.
     /// In the out-of-proc/AppDomain-isolated case, the object implementing these methods may break apart the information
     /// in the parameters to be consumed by the IContract representing the remote object through MAF.
-    /// 
+    ///
     /// REFACTOR - Eliminate this interface.
     /// </summary>
     internal interface ITaskExecutionHost
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 83b46097d82..76e975fe3c3 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -15,11 +15,11 @@ namespace Microsoft.Build.Collections
 {
     /// <summary>
     /// A dictionary of unordered property or metadata name/value pairs, with copy-on-write semantics.
-    /// 
+    ///
     /// The copy-on-write semantics are only possible if the contained type is immutable, which currently
     /// means it can only be used for ProjectMetadataInstance's.
     /// USE THIS DICTIONARY ONLY FOR IMMUTABLE TYPES. OTHERWISE USE PROPERTYDICTIONARY.
-    /// 
+    ///
     /// </summary>
     /// <remarks>
     /// The value that this adds over IDictionary&lt;string, T&gt; is:
@@ -27,9 +27,9 @@ namespace Microsoft.Build.Collections
     ///     - enforces that key = T.Name
     ///     - default enumerator is over values
     ///     - (marginal) enforces the correct key comparer
-    /// 
+    ///
     /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
-    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
     /// either not expose this collection or expose it through a readonly wrapper.
     ///
     /// This collection is safe for concurrent readers and a single writer.
@@ -149,7 +149,7 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
                 return false;
             }
 
-            // Copy both backing collections to locals 
+            // Copy both backing collections to locals
             ImmutableDictionary<string, T> thisBacking = _backing;
             ImmutableDictionary<string, T> thatBacking = other._backing;
 
@@ -299,7 +299,7 @@ IEnumerable<KeyValuePair<string, T>> Items()
         }
 
         /// <summary>
-        /// Clone. As we're copy on write, this 
+        /// Clone. As we're copy on write, this
         /// should be cheap.
         /// </summary>
         internal CopyOnWritePropertyDictionary<T> DeepClone()
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index d2543da7f5b..ee57e45788c 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -13,17 +13,17 @@
 namespace Microsoft.Build.Collections
 {
     /// <summary>
-    /// Collection of items that allows a list of all items of a specified type to be 
-    /// retrieved in O(1), and specific items to be added, removed, or checked for in O(1). 
+    /// Collection of items that allows a list of all items of a specified type to be
+    /// retrieved in O(1), and specific items to be added, removed, or checked for in O(1).
     /// All items of a particular type can also be removed in O(1).
     /// Items are ordered with respect to all other items of their type.
     /// </summary>
     /// <remarks>
     /// Really a Dictionary&lt;string, ICollection&lt;T&gt;&gt; where the key (the item type) is obtained from IKeyed.Key
-    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
     /// either not expose this collection or expose it through a readonly wrapper.
     /// At various places in this class locks are taken on the backing collection.  The reason for this is to allow
-    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will 
+    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will
     /// lock the backing collection when it does its deep cloning.  This prevents asynchronous access from corrupting
     /// the state of the enumeration until the collection has been fully copied.
     /// </remarks>
@@ -248,7 +248,7 @@ internal void Add(T projectItem)
         /// <remarks>
         /// If a list is emptied, removes the list from the enclosing collection
         /// so it can be garbage collected.
-        /// </remarks>        
+        /// </remarks>
         internal bool Remove(T projectItem)
         {
             lock (_itemLists)
diff --git a/src/Build/Collections/MultiDictionary.cs b/src/Build/Collections/MultiDictionary.cs
index 4c1243c7010..b2fc7427261 100644
--- a/src/Build/Collections/MultiDictionary.cs
+++ b/src/Build/Collections/MultiDictionary.cs
@@ -26,12 +26,12 @@ internal class MultiDictionary<K, V>
         where K : class
         where V : class
     {
-        // The simplest implementation of MultiDictionary would use a Dictionary<K, List<V>>. 
+        // The simplest implementation of MultiDictionary would use a Dictionary<K, List<V>>.
         // However, a List<T> with one element is 44 bytes (empty, 24 bytes)
         // even though a single Object takes up only 12 bytes.
         // If most values are only one element, we can save space by storing Object
         // and using its implicit type field to discriminate.
-        // 
+        //
         // Experiments, using a large number of keys:
         //
         // Dictionary<string,List<object>>, each key with one item, 127 bytes/key
@@ -47,7 +47,7 @@ internal class MultiDictionary<K, V>
         // MultiDictionary<string, object>, each key with 2 items, 139 bytes/key
         //
         // Savings for 10,000 objects with 1.01 per entry is 420Kb out of 1.2Mb
-        // If keys and values are already allocated (e.g., strings in use elsewhere) then this is 
+        // If keys and values are already allocated (e.g., strings in use elsewhere) then this is
         // the complete cost of the collection.
 
         /// <summary>
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 5b20c1f59ba..7672333cd2b 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -21,16 +21,16 @@ namespace Microsoft.Build.Collections
     ///     - default enumerator is over values
     ///     - (marginal) enforces the correct key comparer
     ///     - potentially makes copy on write possible
-    /// 
+    ///
     /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
-    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and 
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
     /// either not expose this collection or expose it through a readonly wrapper.
     /// At various places in this class locks are taken on the backing collection.  The reason for this is to allow
-    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will 
+    /// this class to be asynchronously enumerated.  This is accomplished by the CopyOnReadEnumerable which will
     /// lock the backing collection when it does its deep cloning.  This prevents asynchronous access from corrupting
     /// the state of the enumeration until the collection has been fully copied.
-    /// 
-    /// Since we use the mutable ignore case comparer we need to make sure that we lock our self before we call the comparer since the comparer can call back 
+    ///
+    /// Since we use the mutable ignore case comparer we need to make sure that we lock our self before we call the comparer since the comparer can call back
     /// into this dictionary which could cause a deadlock if another thread is also accessing another method in the dictionary.
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs b/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
index 89412677013..2158d913c6a 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
@@ -9,12 +9,12 @@ namespace Microsoft.Build.Collections
 {
     /// <summary>
     /// ABOUT:
-    /// Helps with operations that rely on bit marking to indicate whether an item in the 
-    /// collection should be added, removed, visited already, etc. 
-    /// 
-    /// BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the 
-    /// stack or heap. ToIntArrayLength() tells you the int array size you must allocate. 
-    /// 
+    /// Helps with operations that rely on bit marking to indicate whether an item in the
+    /// collection should be added, removed, visited already, etc.
+    ///
+    /// BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the
+    /// stack or heap. ToIntArrayLength() tells you the int array size you must allocate.
+    ///
     /// USAGE:
     /// Suppose you need to represent a bit array of length (i.e. logical bit array length)
     /// BIT_ARRAY_LENGTH. Then this is the suggested way to instantiate BitHelper:
@@ -28,20 +28,20 @@ namespace Microsoft.Build.Collections
     ///     int[] m_arrayPtr = new int[intArrayLength];
     ///     bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
     /// ***************************************************************************
-    /// 
+    ///
     /// IMPORTANT:
     /// The second ctor args, length, should be specified as the length of the int array, not
     /// the logical bit array. Because length is used for bounds checking into the int array,
-    /// it's especially important to get this correct for the stackalloc version. See the code 
-    /// samples above; this is the value gotten from ToIntArrayLength(). 
-    /// 
-    /// The length ctor argument is the only exception; for other methods -- MarkBit and 
+    /// it's especially important to get this correct for the stackalloc version. See the code
+    /// samples above; this is the value gotten from ToIntArrayLength().
+    ///
+    /// The length ctor argument is the only exception; for other methods -- MarkBit and
     /// IsMarked -- pass in values as indices into the logical bit array, and it will be mapped
     /// to the position within the array of ints.
-    /// 
+    ///
     /// FUTURE OPTIMIZATIONS:
-    /// A method such as FindFirstMarked/Unmarked Bit would be useful for callers that operate 
-    /// on a bit array and then need to loop over it. In particular, if it avoided visiting 
+    /// A method such as FindFirstMarked/Unmarked Bit would be useful for callers that operate
+    /// on a bit array and then need to loop over it. In particular, if it avoided visiting
     /// every bit, it would allow good perf improvements when the bit array is sparse.
     /// </summary>
     internal unsafe class BitHelper
@@ -59,7 +59,7 @@ internal unsafe class BitHelper
         // array of ints
         private readonly int[] _array;
 
-        // whether to operate on stack alloc'd or heap alloc'd array 
+        // whether to operate on stack alloc'd or heap alloc'd array
         private readonly bool _useStackAlloc;
 
         /// <summary>
@@ -136,7 +136,7 @@ internal bool IsMarked(int bitPosition)
         }
 
         /// <summary>
-        /// How many ints must be allocated to represent n bits. Returns (n+31)/32, but 
+        /// How many ints must be allocated to represent n bits. Returns (n+31)/32, but
         /// avoids overflow
         /// </summary>
         /// <param name="n"></param>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
index 49baf191c18..0e3499b0248 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
@@ -18,9 +18,9 @@ namespace Microsoft.Build.Collections
     /// </summary>
     internal static class HashHelpers
     {
-        // Table of prime numbers to use as hash table sizes. 
+        // Table of prime numbers to use as hash table sizes.
         // The entry used for capacity is the smallest prime number in this array
-        // that is larger than twice the previous capacity. 
+        // that is larger than twice the previous capacity.
 
         internal static readonly int[] primes = {
             3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,
@@ -69,7 +69,7 @@ internal static int GetPrime(int min)
                 }
             }
 
-            // Outside of our predefined table. Compute the hard way. 
+            // Outside of our predefined table. Compute the hard way.
             for (int i = (min | 1); i < Int32.MaxValue; i += 2)
             {
                 if (IsPrime(i))
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 8380f9cd3b9..8824d26e051 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -21,7 +21,7 @@
     * require T implements IKeyed, and accept IKeyed directly where necessary
     * all constructors require a comparer -- an IEqualityComparer<IKeyed> -- to avoid mistakes
     * change Contains to give you back the found entry, rather than a boolean
-    * change Add so that it always adds, even if there's an entry already present with the same name. 
+    * change Add so that it always adds, even if there's an entry already present with the same name.
            We want "replacement" semantics, like a dictionary keyed on name.
     * constructor that allows the collection to be read-only
     * implement IDictionary<string, T>
@@ -32,42 +32,47 @@
 
 #nullable disable
 
+// The BuildXL package causes an indirect dependency on the RuntimeContracts package, which adds an analyzer which forbids the use of System.Diagnostics.Contract.
+// So effectively if your dependencies use RuntimeContracts, it attempts to force itself on your as well.
+// See: https://github.com/SergeyTeplyakov/RuntimeContracts/issues/12
+#pragma warning disable RA001 // Do not use System.Diagnostics.Contract class.
+
 namespace Microsoft.Build.Collections
 {
     /// <summary>
     /// Implementation notes:
     /// This uses an array-based implementation similar to <see cref="Dictionary{TKey, TValue}" />, using a buckets array
     /// to map hash values to the Slots array. Items in the Slots array that hash to the same value
-    /// are chained together through the "next" indices. 
-    /// 
+    /// are chained together through the "next" indices.
+    ///
     /// The capacity is always prime; so during resizing, the capacity is chosen as the next prime
-    /// greater than double the last capacity. 
-    /// 
-    /// The underlying data structures are lazily initialized. Because of the observation that, 
+    /// greater than double the last capacity.
+    ///
+    /// The underlying data structures are lazily initialized. Because of the observation that,
     /// in practice, hashtables tend to contain only a few elements, the initial capacity is
     /// set very small (3 elements) unless the ctor with a collection is used.
-    /// 
-    /// The +/- 1 modifications in methods that add, check for containment, etc allow us to 
-    /// distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to 
+    ///
+    /// The +/- 1 modifications in methods that add, check for containment, etc allow us to
+    /// distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to
     /// reset each bucket to -1 when resizing. See Contains, for example.
-    /// 
+    ///
     /// Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify
     /// this set.
-    /// 
+    ///
     /// Some operations can perform faster if we can assume "other" contains unique elements
     /// according to this equality comparer. The only times this is efficient to check is if
     /// other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we
-    /// also have to check that the hashset is using the same equality comparer. If other 
+    /// also have to check that the hashset is using the same equality comparer. If other
     /// has a different equality comparer, it will have unique elements according to its own
-    /// equality comparer, but not necessarily according to ours. Therefore, to go these 
+    /// equality comparer, but not necessarily according to ours. Therefore, to go these
     /// optimized routes we check that other is a hashset using the same equality comparer.
-    /// 
-    /// A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for 
+    ///
+    /// A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for
     /// special empty set checks.)
-    /// 
-    /// A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). 
+    ///
+    /// A couple of methods have a special case if other is this (e.g. SymmetricExceptWith).
     /// If we didn't have these checks, we could be iterating over the set and modifying at
-    /// the same time. 
+    /// the same time.
     /// </summary>
     /// <typeparam name="T"></typeparam>
     [DebuggerTypeProxy(typeof(Microsoft.Build.Collections.HashSetDebugView<>))]
@@ -85,7 +90,7 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
         // store lower 31 bits of hash code
         private const int Lower31BitMask = 0x7FFFFFFF;
 
-        // when constructing a hashset from an existing collection, it may contain duplicates, 
+        // when constructing a hashset from an existing collection, it may contain duplicates,
         // so this is used as the max acceptable excess ratio of capacity to count. Note that
         // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
         // a lot of adds followed by removes. Users must explicitly shrink by calling TrimExcess.
@@ -142,8 +147,8 @@ public RetrievableEntryHashSet(IEnumerable<KeyValuePair<string, T>> collection,
 
         /// <summary>
         /// Implementation Notes:
-        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize 
-        /// the need to resize by setting the initial capacity based on size of collection. 
+        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize
+        /// the need to resize by setting the initial capacity based on size of collection.
         /// </summary>
         public RetrievableEntryHashSet(int suggestedCapacity, IEqualityComparer<string> comparer)
             : this(comparer)
@@ -153,8 +158,8 @@ public RetrievableEntryHashSet(int suggestedCapacity, IEqualityComparer<string>
 
         /// <summary>
         /// Implementation Notes:
-        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize 
-        /// the need to resize by setting the initial capacity based on size of collection. 
+        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize
+        /// the need to resize by setting the initial capacity based on size of collection.
         /// </summary>
         public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<string> comparer)
             : this(comparer)
@@ -187,9 +192,9 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
 
         protected RetrievableEntryHashSet(SerializationInfo info, StreamingContext context)
         {
-            // We can't do anything with the keys and values until the entire graph has been 
-            // deserialized and we have a reasonable estimate that GetHashCode is not going to 
-            // fail.  For the time being, we'll just cache this.  The graph is not valid until 
+            // We can't do anything with the keys and values until the entire graph has been
+            // deserialized and we have a reasonable estimate that GetHashCode is not going to
+            // fail.  For the time being, we'll just cache this.  The graph is not valid until
             // OnDeserialization has been called.
             _siInfo = info;
         }
@@ -248,7 +253,7 @@ void ICollection<T>.Add(T item)
         }
 
         /// <summary>
-        /// Remove all items from this set. This clears the elements but not the underlying 
+        /// Remove all items from this set. This clears the elements but not the underlying
         /// buckets and slots array. Follow this call by TrimExcess to release these.
         /// </summary>
         public void Clear()
@@ -263,7 +268,7 @@ public void Clear()
                 Debug.Assert(_buckets != null, "m_buckets was null but m_lastIndex > 0");
 
                 // clear the elements so that the gc can reclaim the references.
-                // clear only up to m_lastIndex for m_slots 
+                // clear only up to m_lastIndex for m_slots
                 Array.Clear(_slots, 0, _lastIndex);
                 Array.Clear(_buckets, 0, _buckets.Length);
                 _lastIndex = 0;
@@ -387,7 +392,7 @@ public void CopyTo(T[] array, int arrayIndex)
 
         /// <summary>
         /// Remove entry that compares equal to T
-        /// </summary>        
+        /// </summary>
         public bool Remove(T item)
         {
             return Remove(item.Key);
@@ -537,9 +542,9 @@ public virtual void OnDeserialization(Object sender)
         {
             if (_siInfo == null)
             {
-                // It might be necessary to call OnDeserialization from a container if the 
-                // container object also implements OnDeserialization. However, remoting will 
-                // call OnDeserialization again. We can return immediately if this function is 
+                // It might be necessary to call OnDeserialization from a container if the
+                // container object also implements OnDeserialization. However, remoting will
+                // call OnDeserialization again. We can return immediately if this function is
                 // called twice. Note we set m_siInfo to null at the end of this method.
                 return;
             }
@@ -581,7 +586,7 @@ public virtual void OnDeserialization(Object sender)
         #region HashSet methods
 
         /// <summary>
-        /// Add item to this HashSet. 
+        /// Add item to this HashSet.
         /// *** MSBUILD NOTE: Always added - overwrite semantics
         /// </summary>
         public void Add(T item)
@@ -608,9 +613,9 @@ void ICollection<KeyValuePair<string, T>>.Add(KeyValuePair<string, T> entry)
 
         /// <summary>
         /// Take the union of this HashSet with other. Modifies this set.
-        /// 
-        /// Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
-        /// multiple resizes ended up not being useful in practice; quickly gets to the 
+        ///
+        /// Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding
+        /// multiple resizes ended up not being useful in practice; quickly gets to the
         /// point where it's a wasteful check.
         /// </summary>
         /// <param name="other">enumerable with items to add</param>
@@ -690,13 +695,13 @@ public void CopyTo(T[] array, int arrayIndex, int count)
         /// <summary>
         /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
         /// unless count is 0, in which case we release references.
-        /// 
+        ///
         /// This method can be used to minimize a list's memory overhead once it is known that no
-        /// new elements will be added to the list. To completely clear a list and release all 
+        /// new elements will be added to the list. To completely clear a list and release all
         /// memory referenced by the list, execute the following statements:
-        /// 
+        ///
         /// list.Clear();
-        /// list.TrimExcess(); 
+        /// list.TrimExcess();
         /// </summary>
         public void TrimExcess()
         {
@@ -719,7 +724,7 @@ public void TrimExcess()
                 Slot[] newSlots = new Slot[newSize];
                 int[] newBuckets = new int[newSize];
 
-                // move down slots and rehash at the same time. newIndex keeps track of current 
+                // move down slots and rehash at the same time. newIndex keeps track of current
                 // position in newSlots array
                 int newIndex = 0;
                 for (int i = 0; i < _lastIndex; i++)
@@ -766,9 +771,9 @@ private void Initialize(int capacity)
         }
 
         /// <summary>
-        /// Expand to new capacity. New capacity is next prime greater than or equal to suggested 
-        /// size. This is called when the underlying array is filled. This performs no 
-        /// defragmentation, allowing faster execution; note that this is reasonable since 
+        /// Expand to new capacity. New capacity is next prime greater than or equal to suggested
+        /// size. This is called when the underlying array is filled. This performs no
+        /// defragmentation, allowing faster execution; note that this is reasonable since
         /// AddEvenIfPresent attempts to insert new elements in re-opened spots.
         /// </summary>
         private void IncreaseCapacity()
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index 34d1267a234..b09f78484ff 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -119,7 +119,7 @@ public V this[K key]
                 {
                     Scavenge();
 
-                    // If that didn't do anything, raise the capacity at which 
+                    // If that didn't do anything, raise the capacity at which
                     // we next scavenge. Note that we never shrink, but neither
                     // does the underlying dictionary.
                     if (_dictionary.Count == _capacity)
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
deleted file mode 100644
index e979313ca70..00000000000
--- a/src/Build/CompatibilitySuppressions.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
-<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
-</Suppressions>
diff --git a/src/Build/Construction/ProjectChooseElement.cs b/src/Build/Construction/ProjectChooseElement.cs
index 4ecc4131aca..0ef3acca430 100644
--- a/src/Build/Construction/ProjectChooseElement.cs
+++ b/src/Build/Construction/ProjectChooseElement.cs
@@ -44,7 +44,7 @@ private ProjectChooseElement(XmlElement xmlElement, ProjectRootElement containin
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index aab13ff3128..a8619b746fc 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -15,7 +15,7 @@
 namespace Microsoft.Build.Construction
 {
     /// <summary>
-    /// Abstract base class for MSBuild construction object model elements. 
+    /// Abstract base class for MSBuild construction object model elements.
     /// </summary>
     public abstract class ProjectElement : IProjectElement, ILinkableObject
     {
@@ -73,7 +73,7 @@ internal ProjectElement(XmlElement xmlElement, ProjectElementContainer parent, P
         /// </summary>
         /// <remarks>
         /// If this is true, then the <see cref="XmlElement"/> will still be used to hold the data for this (pseudo) ProjectElement, but
-        /// it will not be added to the Xml tree.  
+        /// it will not be added to the Xml tree.
         /// </remarks>
         internal virtual bool ExpressedAsAttribute
         {
@@ -95,8 +95,8 @@ internal virtual bool ExpressedAsAttribute
         }
 
         /// <summary>
-        /// Gets or sets the Condition value. 
-        /// It will return empty string IFF a condition attribute is legal but it’s not present or has no value. 
+        /// Gets or sets the Condition value.
+        /// It will return empty string IFF a condition attribute is legal but it’s not present or has no value.
         /// It will return null IFF a Condition attribute is illegal on that element.
         /// Removes the attribute if the value to set is empty.
         /// It is possible for derived classes to throw an <see cref="InvalidOperationException"/> if setting the condition is
@@ -120,7 +120,7 @@ public virtual string Condition
         }
 
         /// <summary>
-        /// Gets or sets the Label value. 
+        /// Gets or sets the Label value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -286,7 +286,7 @@ internal set
 
         /// <summary>
         /// Location of the corresponding Xml element.
-        /// May not be correct if file is not saved, or 
+        /// May not be correct if file is not saved, or
         /// file has been edited since it was last saved.
         /// In the case of an unsaved edit, the location only
         /// contains the path to the file that the element originates from.
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index c138612fced..d2386dc8028 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -42,7 +42,7 @@ internal ProjectElementContainer(ProjectElementContainerLink link)
         /// </summary>
         /// <comment>
         /// Should ideally be protected+internal.
-        /// </comment> 
+        /// </comment>
         internal ProjectElementContainer()
         {
         }
@@ -379,7 +379,7 @@ public virtual void DeepCopyFrom(ProjectElementContainer element)
         /// Appends the provided child.
         /// Does not dirty the project, does not add an element, does not set the child's parent,
         /// and does not check the parent's future siblings and parent are acceptable.
-        /// Called during project load, when the child can be expected to 
+        /// Called during project load, when the child can be expected to
         /// already have a parent and its element is already connected to the
         /// parent's element.
         /// All that remains is to set FirstChild/LastChild and fix up the linked list.
diff --git a/src/Build/Construction/ProjectExtensionsElement.cs b/src/Build/Construction/ProjectExtensionsElement.cs
index 83d6520abd8..7674069b671 100644
--- a/src/Build/Construction/ProjectExtensionsElement.cs
+++ b/src/Build/Construction/ProjectExtensionsElement.cs
@@ -47,7 +47,7 @@ private ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement proje
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
@@ -94,7 +94,7 @@ public override ElementLocation ConditionLocation
         }
 
         /// <summary>
-        /// Get or set the content of the first sub-element 
+        /// Get or set the content of the first sub-element
         /// with the provided name.
         /// </summary>
         public string this[string name]
diff --git a/src/Build/Construction/ProjectImportElement.cs b/src/Build/Construction/ProjectImportElement.cs
index a38385ca9b8..89c9202364a 100644
--- a/src/Build/Construction/ProjectImportElement.cs
+++ b/src/Build/Construction/ProjectImportElement.cs
@@ -48,7 +48,7 @@ internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectRootElem
         }
 
         /// <summary>
-        /// Gets or sets the Project value. 
+        /// Gets or sets the Project value.
         /// </summary>
         public string Project
         {
diff --git a/src/Build/Construction/ProjectItemDefinitionElement.cs b/src/Build/Construction/ProjectItemDefinitionElement.cs
index 85edb365e8a..d659c62c186 100644
--- a/src/Build/Construction/ProjectItemDefinitionElement.cs
+++ b/src/Build/Construction/ProjectItemDefinitionElement.cs
@@ -99,7 +99,7 @@ internal static ProjectItemDefinitionElement CreateDisconnected(string itemType,
 
             // Orcas inadvertently did not check for reserved item types (like "Choose") in item definitions,
             // as we do for item types in item groups. So we do not have a check here.
-            // Although we could perhaps add one, as such item definitions couldn't be used 
+            // Although we could perhaps add one, as such item definitions couldn't be used
             // since no items can have the reserved itemType.
             XmlElementWithLocation element = containingProject.CreateElement(itemType);
 
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index fb98d908339..27856edbeaa 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -54,7 +54,7 @@ internal ProjectItemElement(ProjectItemElementLink link)
         private string _update;
 
         /// <summary>
-        /// Whether the include value has wildcards, 
+        /// Whether the include value has wildcards,
         /// cached for performance.
         /// </summary>
         private bool? _includeHasWildcards;
@@ -87,7 +87,7 @@ public string ItemType
         }
 
         /// <summary>
-        /// Gets or sets the Include value. 
+        /// Gets or sets the Include value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty or null.
         /// </summary>
@@ -109,7 +109,7 @@ public string Include
         }
 
         /// <summary>
-        /// Gets or sets the Exclude value. 
+        /// Gets or sets the Exclude value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty or null.
         /// </summary>
@@ -331,7 +331,7 @@ public string KeepDuplicates
         public ElementLocation KeepDuplicatesLocation => GetAttributeLocation(XMakeAttributes.keepDuplicates);
 
         /// <summary>
-        /// Whether the include value has wildcards, 
+        /// Whether the include value has wildcards,
         /// cached for performance.
         /// </summary>
         internal bool IncludeHasWildcards
diff --git a/src/Build/Construction/ProjectItemGroupElement.cs b/src/Build/Construction/ProjectItemGroupElement.cs
index 03dc40eb8eb..bf74c24a299 100644
--- a/src/Build/Construction/ProjectItemGroupElement.cs
+++ b/src/Build/Construction/ProjectItemGroupElement.cs
@@ -102,13 +102,13 @@ public ProjectItemElement AddItem(string itemType, string include, IEnumerable<K
             ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
             ErrorUtilities.VerifyThrowArgumentLength(include, nameof(include));
 
-            // If there are no items, or it turns out that there are only items with 
+            // If there are no items, or it turns out that there are only items with
             // item types that sort earlier, then we should go after the last child
             ProjectElement reference = LastChild;
 
             foreach (ProjectItemElement item in Items)
             {
-                // If it's the same item type, and 
+                // If it's the same item type, and
                 if (MSBuildNameIgnoreCaseComparer.Default.Equals(itemType, item.ItemType))
                 {
                     // the include sorts after us,
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index 473f39c0476..0d6b355e117 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -74,7 +74,7 @@ public string Name
         }
 
         /// <summary>
-        /// Gets or sets the unevaluated value. 
+        /// Gets or sets the unevaluated value.
         /// Returns empty string if it is not present.
         /// </summary>
         public string Value
diff --git a/src/Build/Construction/ProjectOtherwiseElement.cs b/src/Build/Construction/ProjectOtherwiseElement.cs
index 81adce4ec70..2a0ddfb4d0a 100644
--- a/src/Build/Construction/ProjectOtherwiseElement.cs
+++ b/src/Build/Construction/ProjectOtherwiseElement.cs
@@ -42,7 +42,7 @@ private ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectRootEl
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
diff --git a/src/Build/Construction/ProjectOutputElement.cs b/src/Build/Construction/ProjectOutputElement.cs
index 43814d3f9a0..71b9baa98e2 100644
--- a/src/Build/Construction/ProjectOutputElement.cs
+++ b/src/Build/Construction/ProjectOutputElement.cs
@@ -43,7 +43,7 @@ private ProjectOutputElement(XmlElement xmlElement, ProjectRootElement containin
         }
 
         /// <summary>
-        /// Gets or sets the TaskParameter value. 
+        /// Gets or sets the TaskParameter value.
         /// Returns empty string if it is not present.
         /// </summary>
         public string TaskParameter
@@ -73,7 +73,7 @@ public string TaskParameter
         public bool IsOutputProperty => PropertyName.Length > 0;
 
         /// <summary>
-        /// Gets or sets the ItemType value. 
+        /// Gets or sets the ItemType value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -96,7 +96,7 @@ public string ItemType
         }
 
         /// <summary>
-        /// Gets or sets the PropertyName value. 
+        /// Gets or sets the PropertyName value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
diff --git a/src/Build/Construction/ProjectPropertyElement.cs b/src/Build/Construction/ProjectPropertyElement.cs
index eca5645ab18..c9020db30ba 100644
--- a/src/Build/Construction/ProjectPropertyElement.cs
+++ b/src/Build/Construction/ProjectPropertyElement.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Construction
     /// ProjectPropertyElement class represents the Property element in the MSBuild project.
     /// </summary>
     /// <remarks>
-    /// We do not need to use or set the PropertyType enumeration in the CM. 
+    /// We do not need to use or set the PropertyType enumeration in the CM.
     /// The CM does not know about Environment or Global properties, and does not create Output properties.
     /// We can just verify that we haven't read a PropertyType.Reserved property ourselves.
     /// So the CM only represents Normal properties.
@@ -59,7 +59,7 @@ public string Name
         }
 
         /// <summary>
-        /// Gets or sets the unevaluated value. 
+        /// Gets or sets the unevaluated value.
         /// Returns empty string if it is not present.
         /// </summary>
         public string Value
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 1db13d96a4c..86c6a442d44 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -38,7 +38,7 @@ namespace Microsoft.Build.Construction
     /// project file schema.
     /// This class and its related classes allow a complete MSBuild project or targets file to be read and written.
     /// Comments and whitespace cannot be edited through this model at present.
-    /// 
+    ///
     /// Each project root element is associated with exactly one ProjectCollection. This allows the owner of that project collection
     /// to control its lifetime and not be surprised by edits via another project collection.
     /// </summary>
@@ -113,9 +113,9 @@ public class ProjectRootElement : ProjectElementContainer
         private string _escapedFullPath;
 
         /// <summary>
-        /// The directory that the project is in. 
+        /// The directory that the project is in.
         /// Essential for evaluating relative paths.
-        /// If the project is not loaded from disk, returns the current-directory from 
+        /// If the project is not loaded from disk, returns the current-directory from
         /// the time the project was loaded - this is the same behavior as Whidbey/Orcas.
         /// </summary>
         private string _directory;
@@ -271,7 +271,7 @@ private ProjectRootElement(XmlDocumentWithLocation document)
         internal event EventHandler<ProjectXmlChangedEventArgs> OnProjectXmlChanged;
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
@@ -366,10 +366,10 @@ public override string Condition
         #endregion
 
         /// <summary>
-        /// The directory that the project is in. 
+        /// The directory that the project is in.
         /// Essential for evaluating relative paths.
         /// Is never null, even if the FullPath does not contain directory information.
-        /// If the project has not been loaded from disk and has not been given a path, returns the current-directory from 
+        /// If the project has not been loaded from disk and has not been given a path, returns the current-directory from
         /// the time the project was loaded - this is the same behavior as Whidbey/Orcas.
         /// If the project has not been loaded from disk but has been given a path, this path may not exist.
         /// </summary>
@@ -582,20 +582,20 @@ public string RawXml
         /// Version number of this object.
         /// A host can compare this to a stored version number to determine whether
         /// a project's XML has changed, even if it has also been saved since.
-        /// 
+        ///
         /// The actual value is meaningless: an edit may increment it more than once,
         /// so it should only be compared to a stored value.
         /// </summary>
         /// <remarks>
-        /// Used by the Project class to figure whether changes have occurred that 
+        /// Used by the Project class to figure whether changes have occurred that
         /// it might want to pick up by reevaluation.
-        /// 
+        ///
         /// Used by the ProjectRootElement class to determine whether it needs to save.
-        /// 
+        ///
         /// This number is unique to the appdomain. That means that it is possible
         /// to know when a ProjectRootElement has been unloaded (perhaps after modification) and
         /// reloaded -- the version won't reset to '0'.
-        /// 
+        ///
         /// We're assuming we don't have over 2 billion edits.
         /// </remarks>
         public int Version
@@ -687,11 +687,11 @@ public override ElementLocation ConditionLocation
         internal bool IsMemberOfProjectCollection => _projectFileLocation != null;
 
         /// <summary>
-        /// Indicates whether there are any targets in this project 
+        /// Indicates whether there are any targets in this project
         /// that use the "Returns" attribute.  If so, then this project file
         /// is automatically assumed to be "Returns-enabled", and the default behavior
-        /// for targets without Returns attributes changes from using the Outputs to 
-        /// returning nothing by default. 
+        /// for targets without Returns attributes changes from using the Outputs to
+        /// returning nothing by default.
         /// </summary>
         internal bool ContainsTargetsWithReturnsAttribute { get; set; }
 
@@ -1305,7 +1305,7 @@ public ProjectItemGroupElement CreateItemGroupElement()
         }
 
         /// <summary>
-        /// Creates an import group. 
+        /// Creates an import group.
         /// Caller must add it to the location of choice in the project.
         /// </summary>
         public ProjectImportGroupElement CreateImportGroupElement()
@@ -1436,7 +1436,7 @@ public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string as
         /// Creates a using task.
         /// Caller must add it to the location of choice in the project.
         /// Exactly one of assembly file and assembly name must be provided.
-        /// Also allows providing optional runtime and architecture specifiers.  Null is OK. 
+        /// Also allows providing optional runtime and architecture specifiers.  Null is OK.
         /// </summary>
         public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture)
         {
@@ -1537,8 +1537,8 @@ public void Save(Encoding saveEncoding)
                 FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(_projectFileLocation.File);
 
                 // If the file was deleted by a race with someone else immediately after it was written above
-                // then we obviously can't read the write time. In this obscure case, we'll retain the 
-                // older last write time, which at worst would cause the next load to unnecessarily 
+                // then we obviously can't read the write time. In this obscure case, we'll retain the
+                // older last write time, which at worst would cause the next load to unnecessarily
                 // come from disk.
                 if (fileInfo != null)
                 {
@@ -1616,7 +1616,7 @@ public ProjectRootElement DeepClone()
         /// <summary>
         /// Reload the existing project root element from its file.
         /// An <see cref="InvalidOperationException"/> is thrown if the project root element is not associated with any file on disk.
-        /// 
+        ///
         /// See <see cref="ProjectRootElement.ReloadFrom(XmlReader, bool, bool?)"/>
         /// </summary>
         public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null)
@@ -1629,7 +1629,7 @@ public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting =
         /// <summary>
         /// Reload the existing project root element from the given path
         /// An <see cref="InvalidOperationException"/> is thrown if the path does not exist.
-        /// 
+        ///
         /// See <see cref="ProjectRootElement.ReloadFrom(XmlReader, bool, bool?)"/>
         /// </summary>
         public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null)
@@ -1648,14 +1648,14 @@ public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? pre
 
         /// <summary>
         /// Reload the existing project root element from the given <paramref name="reader"/>
-        /// A reload operation completely replaces the state of this <see cref="ProjectRootElement"/> object. This operation marks the 
-        /// object as dirty (see <see cref="ProjectRootElement.MarkDirty"/> for side effects). 
-        /// 
+        /// A reload operation completely replaces the state of this <see cref="ProjectRootElement"/> object. This operation marks the
+        /// object as dirty (see <see cref="ProjectRootElement.MarkDirty"/> for side effects).
+        ///
         /// If the new state has invalid XML or MSBuild syntax, then this method throws an <see cref="InvalidProjectFileException"/>.
         /// When this happens, the state of this object does not change.
-        /// 
+        ///
         /// Reloading from an XMLReader will retain the previous root element location (<see cref="FullPath"/>, <see cref="DirectoryPath"/>, <see cref="ProjectFileLocation"/>).
-        /// 
+        ///
         /// </summary>
         /// <param name="reader">Reader to read from</param>
         /// <param name="throwIfUnsavedChanges">
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index e9893009031..f594efaf072 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -171,7 +171,7 @@ public string KeepDuplicateOutputs
                 if (String.IsNullOrEmpty(value) && !BuildParameters.KeepDuplicateOutputs)
                 {
                     // In 4.0, by default we do NOT keep duplicate outputs unless they user has either set the attribute
-                    // explicitly or overridden it globally with MSBUILDKEEPDUPLICATEOUTPUTS set to a non-empty value.                    
+                    // explicitly or overridden it globally with MSBUILDKEEPDUPLICATEOUTPUTS set to a non-empty value.
                     value = "False";
                 }
 
@@ -273,11 +273,11 @@ public string Returns
                         value,
                         true); /* only remove the element if the value is null -- setting to empty string is OK */
 
-                // if this target's Returns attribute is non-null, then there is at least one target in the 
-                // parent project that has the returns attribute.  
-                // NOTE: As things are currently, if a project is created that has targets with Returns, but then 
-                // all of those targets are set to not have Returns anymore, the PRE will still claim that it 
-                // contains targets with the Returns attribute.  Do we care? 
+                // if this target's Returns attribute is non-null, then there is at least one target in the
+                // parent project that has the returns attribute.
+                // NOTE: As things are currently, if a project is created that has targets with Returns, but then
+                // all of those targets are set to not have Returns anymore, the PRE will still claim that it
+                // contains targets with the Returns attribute.  Do we care?
                 if (returnsAttribute != null)
                 {
                     ((ProjectRootElement)Parent).ContainsTargetsWithReturnsAttribute = true;
@@ -313,7 +313,7 @@ public ElementLocation KeepDuplicateOutputsLocation
                 if ((location == null) && !BuildParameters.KeepDuplicateOutputs)
                 {
                     // In 4.0, by default we do NOT keep duplicate outputs unless they user has either set the attribute
-                    // explicitly or overridden it globally with MSBUILDKEEPDUPLICATEOUTPUTS set to a non-empty value.                    
+                    // explicitly or overridden it globally with MSBUILDKEEPDUPLICATEOUTPUTS set to a non-empty value.
                     location = NameLocation;
                 }
 
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index 94031b4994c..984ffe33b31 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -449,7 +449,7 @@ private void EnsureParametersInitialized()
                     {
                         // By pulling off and caching the Location early here, it becomes frozen for the life of this object.
                         // That means that if the name of the file is changed after first load (possibly from null) it will
-                        // remain the old value here. Correctly, this should cache the attribute not the location. Fixing 
+                        // remain the old value here. Correctly, this should cache the attribute not the location. Fixing
                         // that will need profiling, though, as this cache was added for performance.
                         _parameters[attribute.Name] = (attribute.Value, attribute.Location);
                     }
diff --git a/src/Build/Construction/ProjectUsingTaskBodyElement.cs b/src/Build/Construction/ProjectUsingTaskBodyElement.cs
index 9ef2a82faf0..ad1f97ce4a7 100644
--- a/src/Build/Construction/ProjectUsingTaskBodyElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskBodyElement.cs
@@ -46,7 +46,7 @@ private ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectRo
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
@@ -56,7 +56,7 @@ public override string Condition
         }
 
         /// <summary>
-        /// Gets or sets the unevaluated value of the contents of the task xml 
+        /// Gets or sets the unevaluated value of the contents of the task xml
         /// Returns empty string if it is not present.
         /// </summary>
         public string TaskBody
@@ -159,7 +159,7 @@ private static void VerifyCorrectParent(ProjectElementContainer parent)
             var parentUsingTask = parent as ProjectUsingTaskElement;
             ErrorUtilities.VerifyThrowInvalidOperation(parentUsingTask != null, "OM_CannotAcceptParent");
 
-            // Since there is not going to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and 
+            // Since there is not going to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and
             // that it is not empty
             if (parentUsingTask.TaskFactory.Length == 0)
             {
diff --git a/src/Build/Construction/ProjectUsingTaskParameterElement.cs b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
index e7da47595bc..636fb171028 100644
--- a/src/Build/Construction/ProjectUsingTaskParameterElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
@@ -43,7 +43,7 @@ private ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, Proj
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
diff --git a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
index 4056ee44afd..073739d11a6 100644
--- a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
@@ -47,7 +47,7 @@ internal ProjectConfigurationInSolution(string configurationName, string platfor
         /// This is a hacky method to remove the space in the "Any CPU" platform in project configurations.
         /// The problem is that this platform is stored as "AnyCPU" in project files, but the project system
         /// reports it as "Any CPU" to the solution configuration manager. Because of that all solution configurations
-        /// contain the version with a space in it, and when we try and give that name to actual projects, 
+        /// contain the version with a space in it, and when we try and give that name to actual projects,
         /// they have no clue what we're talking about. We need to remove the space in project platforms so that
         /// the platform name matches the one used in projects.
         /// </summary>
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index b13b09f50a1..3880a57f618 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -107,7 +107,7 @@ public sealed class ProjectInSolution
         /// <summary>
         /// The project configuration in given solution configuration
         /// K: full solution configuration name (cfg + platform)
-        /// V: project configuration 
+        /// V: project configuration
         /// </summary>
         private readonly Dictionary<string, ProjectConfigurationInSolution> _projectConfigurations;
         private IReadOnlyDictionary<string, ProjectConfigurationInSolution> _projectConfigurationsReadOnly;
@@ -208,14 +208,14 @@ public string AbsolutePath
         public string ProjectGuid { get; internal set; }
 
         /// <summary>
-        /// The guid, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, of this project's 
-        /// parent project, if any. 
+        /// The guid, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, of this project's
+        /// parent project, if any.
         /// </summary>
         public string ParentProjectGuid { get; internal set; }
 
         /// <summary>
-        /// List of guids, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, mapping to projects 
-        /// that this project has a build order dependency on, as defined in the solution file. 
+        /// List of guids, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, mapping to projects
+        /// that this project has a build order dependency on, as defined in the solution file.
         /// </summary>
         public IReadOnlyList<string> Dependencies => _dependenciesAsReadonly ?? (_dependenciesAsReadonly = _dependencies.AsReadOnly());
 
@@ -239,9 +239,9 @@ public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfig
         public SolutionProjectType ProjectType { get; set; }
 
         /// <summary>
-        /// Only applies to websites -- for other project types, references are 
+        /// Only applies to websites -- for other project types, references are
         /// either specified as Dependencies above, or as ProjectReferences in the
-        /// project file, which the solution doesn't have insight into. 
+        /// project file, which the solution doesn't have insight into.
         /// </summary>
         internal List<string> ProjectReferences { get; } = new List<string>();
 
@@ -270,7 +270,7 @@ internal void AddDependency(string referencedProjectGuid)
         }
 
         /// <summary>
-        /// Set the requested project configuration. 
+        /// Set the requested project configuration.
         /// </summary>
         internal void SetProjectConfiguration(string configurationName, ProjectConfigurationInSolution configuration)
         {
@@ -305,7 +305,7 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                 FileStream fs = File.OpenRead(AbsolutePath);
                 using (XmlReader xmlReader = XmlReader.Create(fs, xrSettings))
                 {
-                    // Load the project file and get the first node    
+                    // Load the project file and get the first node
                     projectDocument.Load(xmlReader);
                 }
 
@@ -502,7 +502,7 @@ private static string CleanseProjectName(string projectName)
             // This is where we're going to work on the final string to return to the caller.
             var cleanProjectName = new StringBuilder(projectName);
 
-            // Replace each unclean character with a clean one            
+            // Replace each unclean character with a clean one
             foreach (char uncleanChar in s_charsToCleanse)
             {
                 cleanProjectName.Replace(uncleanChar, cleanCharacter);
diff --git a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
index 57d868d3a03..ca74704b73e 100644
--- a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
@@ -44,7 +44,7 @@ internal SolutionConfigurationInSolution(string configurationName, string platfo
         public string FullName { get; }
 
         /// <summary>
-        /// Given a configuration name and a platform name, compute the full name 
+        /// Given a configuration name and a platform name, compute the full name
         /// of this configuration
         /// </summary>
         internal static string ComputeFullName(string configurationName, string platformName)
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index a59fdb60e4d..7c8a7dcc867 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -51,7 +51,7 @@ public sealed class SolutionFile
         // An example of a property line looks like this:
         //      AspNetCompiler.VirtualPath = "/webprecompile"
         // Because website projects now include the target framework moniker as
-        // one of their properties, <PROPERTYVALUE> may now have '=' in it. 
+        // one of their properties, <PROPERTYVALUE> may now have '=' in it.
 
         private static readonly Lazy<Regex> s_crackPropertyLine = new Lazy<Regex>(
             () => new Regex(
@@ -142,7 +142,7 @@ internal SolutionFile()
         internal List<string> SolutionParserComments { get; } = new List<string>();
 
         /// <summary>
-        /// This property returns the list of error codes for warnings/errors that were generated during solution parsing. 
+        /// This property returns the list of error codes for warnings/errors that were generated during solution parsing.
         /// </summary>
         internal List<string> SolutionParserErrorCodes { get; } = new List<string>();
 
@@ -176,7 +176,7 @@ internal int VisualStudioVersion
 
         /// <summary>
         /// Returns true if the solution contains any .wdproj projects.  Used to determine
-        /// whether we need to load up any projects to examine dependencies. 
+        /// whether we need to load up any projects to examine dependencies.
         /// </summary>
         internal bool ContainsWebDeploymentProjects { get; private set; }
 
@@ -186,7 +186,7 @@ internal int VisualStudioVersion
         public IReadOnlyList<ProjectInSolution> ProjectsInOrder => _projectsInOrder.AsReadOnly();
 
         /// <summary>
-        /// The collection of projects in this solution, accessible by their guids as a 
+        /// The collection of projects in this solution, accessible by their guids as a
         /// string in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
         /// </summary>
         public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
@@ -263,8 +263,8 @@ public static SolutionFile Parse(string solutionFile)
         }
 
         /// <summary>
-        /// Returns "true" if it's a project that's expected to be buildable, or false if it's 
-        /// not (e.g. a solution folder) 
+        /// Returns "true" if it's a project that's expected to be buildable, or false if it's
+        /// not (e.g. a solution folder)
         /// </summary>
         /// <param name="project">The project in the solution</param>
         /// <returns>Whether the project is expected to be buildable</returns>
@@ -275,9 +275,9 @@ internal static bool IsBuildableProject(ProjectInSolution project)
 
         /// <summary>
         /// Given a solution file, parses the header and returns the major version numbers of the solution file
-        /// and the visual studio. 
-        /// Throws InvalidProjectFileException if the solution header is invalid, or if the version is less than 
-        /// our minimum version. 
+        /// and the visual studio.
+        /// Throws InvalidProjectFileException if the solution header is invalid, or if the version is less than
+        /// our minimum version.
         /// </summary>
         internal static void GetSolutionFileAndVisualStudioMajorVersions(string solutionFile, out int solutionVersion, out int visualStudioMajorVersion)
         {
@@ -299,7 +299,7 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
                 fileStream = File.OpenRead(solutionFile);
                 reader = new StreamReader(fileStream, Encoding.GetEncoding(0)); // HIGHCHAR: If solution files have no byte-order marks, then assume ANSI rather than ASCII.
 
-                // Read first 4 lines of the solution file. 
+                // Read first 4 lines of the solution file.
                 // The header is expected to be in line 1 or 2
                 // VisualStudioVersion is expected to be in line 3 or 4.
                 for (int i = 0; i < 4; i++)
@@ -452,7 +452,7 @@ private string ReadLine()
         /// <summary>
         /// This method takes a path to a solution file, parses the projects and project dependencies
         /// in the solution file, and creates internal data structures representing the projects within
-        /// the SLN.  Used for conversion, which means it allows situations that we refuse to actually build. 
+        /// the SLN.  Used for conversion, which means it allows situations that we refuse to actually build.
         /// </summary>
         internal void ParseSolutionFileForConversion()
         {
@@ -630,7 +630,7 @@ internal void ParseSolution()
 
                 bool uniqueNameExists = projectsByUniqueName.ContainsKey(uniqueName);
 
-                // Add the unique name (if it does not exist) to the hash table 
+                // Add the unique name (if it does not exist) to the hash table
                 if (!uniqueNameExists)
                 {
                     projectsByUniqueName.Add(uniqueName, proj);
@@ -650,11 +650,11 @@ internal void ParseSolution()
         /// <summary>
         /// This method searches the first two lines of the solution file opened by the specified
         /// StreamReader for the solution file header.  An exception is thrown if it is not found.
-        /// 
+        ///
         /// The solution file header looks like this:
-        /// 
+        ///
         ///     Microsoft Visual Studio Solution File, Format Version 9.00
-        /// 
+        ///
         /// </summary>
         private void ParseFileHeader()
         {
@@ -688,9 +688,9 @@ private void ParseFileHeader()
         /// <summary>
         /// This method parses the Visual Studio version in Dev 12 solution files
         /// The version line looks like this:
-        /// 
+        ///
         /// VisualStudioVersion = 12.0.20311.0 VSPRO_PLATFORM
-        /// 
+        ///
         /// If such a line is found, the version is stored in this.currentVisualStudioVersion
         /// </summary>
         private static Version ParseVisualStudioVersion(string str)
@@ -714,11 +714,11 @@ private static Version ParseVisualStudioVersion(string str)
         /// This method extracts the whole part of the version number from the specified line
         /// containing the solution file format header, and throws an exception if the version number
         /// is outside of the valid range.
-        /// 
+        ///
         /// The solution file header looks like this:
-        /// 
+        ///
         ///     Microsoft Visual Studio Solution File, Format Version 9.00
-        /// 
+        ///
         /// </summary>
         /// <param name="versionString"></param>
         private void ValidateSolutionFileVersion(string versionString)
@@ -750,7 +750,7 @@ private void ValidateSolutionFileVersion(string versionString)
         }
 
         /// <summary>
-        /// 
+        ///
         /// This method processes a "Project" section in the solution file opened by the specified
         /// StreamReader, and returns a populated ProjectInSolution instance, if successful.
         /// An exception is thrown if the solution file is invalid.
@@ -763,7 +763,7 @@ private void ValidateSolutionFileVersion(string versionString)
         ///          ...
         ///      EndProjectSection
         ///  EndProject
-        /// 
+        ///
         /// </summary>
         private void ParseProject(string firstLine)
         {
@@ -808,7 +808,7 @@ private void ParseProject(string firstLine)
                 else if (line.StartsWith("ProjectSection(WebsiteProperties)", StringComparison.Ordinal))
                 {
                     // We have a WebsiteProperties section.  This section is present only in Venus
-                    // projects, and contains properties that we'll need in order to call the 
+                    // projects, and contains properties that we'll need in order to call the
                     // AspNetCompiler task.
                     line = ReadLine();
                     while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
@@ -845,7 +845,7 @@ private void ParseProject(string firstLine)
 
             // Add the project to the collection
             AddProjectToSolution(proj);
-            // If the project is an etp project then parse the etp project file 
+            // If the project is an etp project then parse the etp project file
             // to get the projects contained in it.
             if (IsEtpProjectFile(proj.RelativePath))
             {
@@ -854,7 +854,7 @@ private void ParseProject(string firstLine)
         } // ParseProject()
 
         /// <summary>
-        /// This method will parse a .etp project recursively and 
+        /// This method will parse a .etp project recursively and
         /// add all the projects found to projects and projectsInOrder
         /// </summary>
         /// <param name="etpProj">ETP Project</param>
@@ -899,8 +899,8 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
 
                 // We need to parse the .etp project file to get the names of projects contained
                 // in the .etp Project. The projects are listed under /EFPROJECT/GENERAL/References/Reference node in the .etp project file.
-                // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain 
-                // all the projects in the .etp project. Therefore, we need to look at 
+                // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain
+                // all the projects in the .etp project. Therefore, we need to look at
                 // /EFPROJECT/GENERAL/References/Reference.
                 // Find the /EFPROJECT/GENERAL/References/Reference node
                 // Note that this is case sensitive
@@ -926,10 +926,10 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                         XmlNode projGuidNode = referenceNode.SelectSingleNode("GUIDPROJECTID");
 
                         // It is ok for a project to not have a guid inside an etp project.
-                        // If a solution file contains a project without a guid it fails to 
-                        // load in Everett. But if an etp project contains a project without 
+                        // If a solution file contains a project without a guid it fails to
+                        // load in Everett. But if an etp project contains a project without
                         // a guid it loads well in Everett and p2p references to/from this project
-                        // are preserved. So we should make sure that we don’t error in this 
+                        // are preserved. So we should make sure that we don’t error in this
                         // situation while upgrading.
                         proj.ProjectGuid = projGuidNode?.InnerText ?? String.Empty;
 
@@ -948,7 +948,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle security errors
             catch (SecurityException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
@@ -957,7 +957,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in path resolution
             catch (NotSupportedException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
@@ -966,7 +966,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in loading project file
             catch (IOException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
@@ -975,16 +975,16 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in loading project file
             catch (UnauthorizedAccessException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
                 SolutionParserErrorCodes.Add(errorCode);
             }
-            // handle XML parsing errors 
+            // handle XML parsing errors
             catch (XmlException e)
             {
-                // Log a warning 
+                // Log a warning
                 string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "Shared.InvalidProjectFile",
                    etpProj.RelativePath, e.Message);
                 SolutionParserWarnings.Add(warning);
@@ -1052,7 +1052,7 @@ private static void ParseAspNetCompilerProperty(
             // Project("{E24C65DC-7377-472B-9ABA-BC803B73C61A}") = "c:\...\myfirstwebsite\", "..\..\..\..\..\..\rajeev\temp\websites\myfirstwebsite", "{956CC04E-FD59-49A9-9099-96888CB6F366}"
             //     ProjectSection(WebsiteProperties) = preProject
             //       TargetFrameworkMoniker = ".NETFramework,Version%3Dv4.0"
-            //       ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
+            //       ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
             //       Debug.AspNetCompiler.VirtualPath = "/publishfirst"
             //       Debug.AspNetCompiler.PhysicalPath = "..\..\..\..\..\..\rajeev\temp\websites\myfirstwebsite\"
             //       Debug.AspNetCompiler.TargetPath = "..\..\..\..\..\..\rajeev\temp\publishfirst\"
@@ -1176,7 +1176,7 @@ private static void ParseAspNetCompilerProperty(
             }
             else
             {
-                // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
+                // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
                 if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
@@ -1185,7 +1185,7 @@ private static void ParseAspNetCompilerProperty(
                     {
                         int indexOfBar = projectReferenceEntry.IndexOf('|');
 
-                        // indexOfBar could be -1 if we had semicolons in the file names, so skip entries that 
+                        // indexOfBar could be -1 if we had semicolons in the file names, so skip entries that
                         // don't contain a guid. File names may not contain the '|' character
                         if (indexOfBar != -1)
                         {
@@ -1208,7 +1208,7 @@ private static void ParseAspNetCompilerProperty(
                 else if (String.Equals(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase))
                 {
                     // Website project need to back support 3.5 msbuild parser for the Blend (it is not move to .Net4.0 yet.)
-                    // However, 3.5 version of Solution parser can't handle a equal sign in the value.  
+                    // However, 3.5 version of Solution parser can't handle a equal sign in the value.
                     // The "=" in targetframeworkMoniker was escaped to "%3D" for Orcas
                     string targetFrameworkMoniker = TrimQuotes(propertyValue);
                     proj.TargetFrameworkMoniker = Shared.EscapingUtilities.UnescapeAll(targetFrameworkMoniker);
@@ -1237,7 +1237,7 @@ private static string TrimQuotes(
         /// Parse the first line of a Project section of a solution file. This line should look like:
         ///
         ///  Project("{Project type GUID}") = "Project name", "Relative path to project file", "{Project GUID}"
-        /// 
+        ///
         /// </summary>
         /// <param name="firstLine"></param>
         /// <param name="proj"></param>
@@ -1254,8 +1254,8 @@ internal void ParseFirstProjectLine(
             proj.RelativePath = match.Groups["RELATIVEPATH"].Value.Trim();
             proj.ProjectGuid = match.Groups["PROJECTGUID"].Value.Trim();
 
-            // If the project name is empty (as in some bad solutions) set it to some generated generic value.  
-            // This allows us to at least generate reasonable target names etc. instead of crashing. 
+            // If the project name is empty (as in some bad solutions) set it to some generated generic value.
+            // This allows us to at least generate reasonable target names etc. instead of crashing.
             if (String.IsNullOrEmpty(proj.ProjectName))
             {
                 proj.ProjectName = "EmptyProjectName." + Guid.NewGuid();
@@ -1296,7 +1296,7 @@ internal void ParseFirstProjectLine(
                     {
                         ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(FullPath), "ProjectUpgradeNeededToVcxProj", proj.RelativePath);
                     }
-                    // otherwise, we're parsing this solution file because we want the P2P information during 
+                    // otherwise, we're parsing this solution file because we want the P2P information during
                     // conversion, and it's perfectly valid for an unconverted solution file to still contain .vcprojs
                 }
                 else
@@ -1358,11 +1358,11 @@ internal void ParseNestedProjects()
         }
 
         /// <summary>
-        /// Read solution configuration section. 
+        /// Read solution configuration section.
         /// </summary>
         /// <remarks>
         /// A sample section:
-        /// 
+        ///
         /// GlobalSection(SolutionConfigurationPlatforms) = preSolution
         ///     Debug|Any CPU = Debug|Any CPU
         ///     Release|Any CPU = Release|Any CPU
@@ -1389,7 +1389,7 @@ internal void ParseSolutionConfigurations()
 
                 string[] configurationNames = str.Split(nameValueSeparators);
 
-                // There should be exactly one '=' character, separating two names. 
+                // There should be exactly one '=' character, separating two names.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(configurationNames.Length == 2, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseInvalidSolutionConfigurationEntry", str);
 
@@ -1430,7 +1430,7 @@ internal static (string Configuration, string Platform) ParseConfigurationName(s
         /// </summary>
         /// <remarks>
         /// A sample (incomplete) section:
-        /// 
+        ///
         /// GlobalSection(ProjectConfigurationPlatforms) = postSolution
         /// 	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
         /// 	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
@@ -1466,7 +1466,7 @@ internal Dictionary<string, string> ParseProjectConfigurations()
 
                 string[] nameValue = str.Split('=');
 
-                // There should be exactly one '=' character, separating the name and value. 
+                // There should be exactly one '=' character, separating the name and value.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(nameValue.Length == 2, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseInvalidProjectSolutionConfigurationEntry", str);
 
@@ -1477,17 +1477,17 @@ internal Dictionary<string, string> ParseProjectConfigurations()
         }
 
         /// <summary>
-        /// Read the project configuration information for every project in the solution, using pre-cached 
-        /// solution section data. 
+        /// Read the project configuration information for every project in the solution, using pre-cached
+        /// solution section data.
         /// </summary>
         /// <param name="rawProjectConfigurationsEntries">Cached data from the project configuration section</param>
         internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawProjectConfigurationsEntries)
         {
-            // Instead of parsing the data line by line, we parse it project by project, constructing the 
-            // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its 
+            // Instead of parsing the data line by line, we parse it project by project, constructing the
+            // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its
             // value from the raw data. The reason for this is that the IDE does it this way, and as the result
             // the '.' character is allowed in configuration names although it technically separates different
-            // parts of the entry name string. This could lead to ambiguous results if we tried to parse 
+            // parts of the entry name string. This could lead to ambiguous results if we tried to parse
             // the entry name instead of constructing it and looking it up. Although it's pretty unlikely that
             // this would ever be a problem, it's safer to do it the same way VS IDE does it.
             foreach (ProjectInSolution project in _projectsInOrder)
@@ -1503,9 +1503,9 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
                             project.ProjectGuid, solutionConfiguration.FullName);
 
                         // The "Build.0" entry tells us whether to build the project configuration in the given solution configuration.
-                        // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial, 
-                        // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used). 
-                        // The configuration name is not used, and the whole entry means "build the project configuration" 
+                        // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial,
+                        // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used).
+                        // The configuration name is not used, and the whole entry means "build the project configuration"
                         // if it's present in the solution file, and "don't build" if it's not.
                         string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0",
                             project.ProjectGuid, solutionConfiguration.FullName);
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 7b3d3c05b43..33e382771f6 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -287,9 +287,9 @@ internal static string GetSolutionConfiguration(SolutionFile solutionFile, Solut
                                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(dependencyProject != null, "SubCategoryForSolutionParsingErrors", new BuildEventFileInfo(solutionFile.FullPath), "SolutionParseProjectDepNotFoundError", project.ProjectGuid, dependencyProjectGuid);
                             }
 
-                            // Add it to the list of dependencies, but only if it should build in this solution configuration 
+                            // Add it to the list of dependencies, but only if it should build in this solution configuration
                             // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
-                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise 
+                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise
                             if (dependencyProject.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat)
                             {
                                 if (dependencyProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out ProjectConfigurationInSolution dependencyProjectConfiguration) &&
@@ -420,10 +420,10 @@ private static void AddTasksToCopyAllDependenciesIntoBinDir(
             string fullFrameworkRefAssyPathName = GenerateSafePropertyName(project, "_FullFrameworkReferenceAssemblyPaths");
             string destinationFolder = String.Format(CultureInfo.InvariantCulture, @"$({0})\Bin\", GenerateSafePropertyName(project, "AspNetPhysicalPath"));
 
-            // This is a bit of a hack.  We're actually calling the "Copy" task on all of 
-            // the *non-existent* files.  Why?  Because we want to emit a warning in the 
+            // This is a bit of a hack.  We're actually calling the "Copy" task on all of
+            // the *non-existent* files.  Why?  Because we want to emit a warning in the
             // log for each non-existent file, and the Copy task does that nicely for us.
-            // I would have used the <Warning> task except for the fact that we are in 
+            // I would have used the <Warning> task except for the fact that we are in
             // string-resource lockdown.
             ProjectTaskInstance copyNonExistentReferencesTask = target.AddTask("Copy", String.Format(CultureInfo.InvariantCulture, "!Exists('%({0}.Identity)')", referenceItemName), "true");
             copyNonExistentReferencesTask.SetParameter("SourceFiles", "@(" + referenceItemName + "->'%(FullPath)')");
@@ -437,7 +437,7 @@ private static void AddTasksToCopyAllDependenciesIntoBinDir(
             getRefAssembliesTask.AddOutputProperty("ReferenceAssemblyPaths", targetFrameworkDirectoriesName, null);
             getRefAssembliesTask.AddOutputProperty("FullFrameworkReferenceAssemblyPaths", fullFrameworkRefAssyPathName, null);
 
-            // Call ResolveAssemblyReference on each of the .DLL files that were found on 
+            // Call ResolveAssemblyReference on each of the .DLL files that were found on
             // disk from the .REFRESH files as well as the P2P references.  RAR will crack
             // the dependencies, find PDBs, satellite assemblies, etc., and determine which
             // files need to be copy-localed.
@@ -648,7 +648,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile so
         /// <summary>
         /// Returns true if the specified project will build in the currently selected solution configuration.
         /// </summary>
-        private static bool WouldProjectBuild(SolutionFile solutionFile, string selectedSolutionConfiguration, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration)
+        internal static bool WouldProjectBuild(SolutionFile solutionFile, string selectedSolutionConfiguration, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration)
         {
             // If the solution filter does not contain this project, do not build it.
             if (!solutionFile.ProjectShouldBuild(project.RelativePath))
@@ -698,11 +698,11 @@ private ProjectInstance[] Generate()
                 new BuildEventFileInfo(_solutionFile.FullPath),
                 "SolutionParseUpgradeNeeded");
 
-            // This is needed in order to make decisions about tools versions such as whether to put a 
-            // ToolsVersion parameter on <MSBuild> task tags and what MSBuildToolsPath to use when 
+            // This is needed in order to make decisions about tools versions such as whether to put a
+            // ToolsVersion parameter on <MSBuild> task tags and what MSBuildToolsPath to use when
             // scanning child projects for dependency information.
-            // The knowledge of whether it was explicitly specified is required because otherwise we 
-            // don't know whether we need to pass the ToolsVersion on to the child projects or not.  
+            // The knowledge of whether it was explicitly specified is required because otherwise we
+            // don't know whether we need to pass the ToolsVersion on to the child projects or not.
             string wrapperProjectToolsVersion = DetermineWrapperProjectToolsVersion(_toolsVersionOverride, out bool explicitToolsVersionSpecified);
 
             return CreateSolutionProject(wrapperProjectToolsVersion, explicitToolsVersionSpecified);
@@ -719,9 +719,9 @@ private ProjectInstance[] CreateSolutionProject(string wrapperProjectToolsVersio
             if (_solutionFile.ContainsWebDeploymentProjects)
             {
                 // If there are Web Deployment projects, we need to scan those project files
-                // and specify the references explicitly.  
-                // Other references are either ProjectReferences (taken care of by MSBuild) or 
-                // explicit manual references in the solution file -- which get parsed out by 
+                // and specify the references explicitly.
+                // Other references are either ProjectReferences (taken care of by MSBuild) or
+                // explicit manual references in the solution file -- which get parsed out by
                 // the SolutionParser.
                 string childProjectToolsVersion = DetermineChildProjectToolsVersion(wrapperProjectToolsVersion);
                 string fullSolutionConfigurationName = PredictActiveSolutionConfigurationName();
@@ -797,7 +797,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
 
                 bool canBuildDirectly = CanBuildDirectly(traversalInstance, project, projectConfiguration);
 
-                // Add an entry to @(ProjectReference) for the project.  This will be either a reference directly to the project, or to the 
+                // Add an entry to @(ProjectReference) for the project.  This will be either a reference directly to the project, or to the
                 // metaproject, as appropriate.
                 AddProjectReference(traversalInstance, traversalInstance, project, projectConfiguration, canBuildDirectly);
 
@@ -875,8 +875,8 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             }
 
             // Add our global extensibility points to the project representing the solution:
-            // Imported at the top:  $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportBefore\* 
-            // Imported at the bottom:  $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter\*             
+            // Imported at the top:  $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportBefore\*
+            // Imported at the bottom:  $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter\*
             ProjectImportElement importBefore = traversalProject.CreateImportElement(@"$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportBefore\*");
             importBefore.Condition = @"'$(ImportByWildcardBeforeSolution)' != 'false' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportBefore')"; // Avoids wildcard perf problem
 
@@ -972,7 +972,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             directorySolutionPropsPropertyGroup.AppendChild(directorySolutionPropsBasePathProperty);
             directorySolutionPropsPropertyGroup.AppendChild(directorySolutionPropsPathProperty);
 
-            // These are just dummies necessary to make the evaluation into a project instance succeed when 
+            // These are just dummies necessary to make the evaluation into a project instance succeed when
             // any custom imported targets have declarations like BeforeTargets="Build"
             // They'll be replaced momentarily with the real ones.
             string[] dummyTargetsForEvaluationTime = _defaultTargetNames.Union(_targetNames).ToArray();
@@ -1104,7 +1104,7 @@ private static string GetPropertiesMetadataForProjectReference(ProjectInstance t
 
             if (traversalProject.SubToolsetVersion != null)
             {
-                // Note: it is enough below to compare traversalProject.SubToolsetVersion with 4.0 as a means to verify if 
+                // Note: it is enough below to compare traversalProject.SubToolsetVersion with 4.0 as a means to verify if
                 // traversalProject.SubToolsetVersion < 12.0 since this path isn't followed for traversalProject.SubToolsetVersion values of 2.0 and 3.5
                 if (traversalProject.SubToolsetVersion.Equals("4.0", StringComparison.OrdinalIgnoreCase))
                 {
@@ -1414,15 +1414,15 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
 
             if (targetName == "Clean")
             {
-                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of 
-                // a "Clean" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of
+                // a "Clean" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageInstance(newTarget, null, XMakeElements.message, true, "SolutionVenusProjectNoClean");
             }
             else if (targetName == "Publish")
             {
-                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of 
-                // a "Publish" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of
+                // a "Publish" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageInstance(newTarget, null, XMakeElements.message, true, "SolutionVenusProjectNoPublish");
             }
@@ -1434,7 +1434,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
 
                 // We're going to build up an MSBuild condition string that represents the valid Configurations.
                 // We do this by OR'ing together individual conditions, each of which compares $(Configuration)
-                // with a valid configuration name.  We init our condition string to "false", so we can easily 
+                // with a valid configuration name.  We init our condition string to "false", so we can easily
                 // OR together more stuff as we go, and also easily take the negation of the condition by putting
                 // a ! around the whole thing.
                 var conditionDescribingValidConfigurations = new StringBuilder("(false)");
@@ -1446,7 +1446,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
                     var aspNetCompilerParameters = (AspNetCompilerParameters)aspNetConfiguration.Value;
 
                     // We only add the PropertyGroup once per Venus project.  Without the following "if", we would add
-                    // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with 
+                    // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with
                     // subTargetName=null and once when subTargetName="Rebuild".
                     if (targetName == null)
                     {
@@ -1486,7 +1486,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
                 // Add tasks to capture the auto-refreshed file references (those .REFRESH files).
                 AddTasksToResolveAutoRefreshFileReferences(newTarget, project, referenceItemName.ToString());
 
-                // Add a call to RAR (ResolveAssemblyReference) and the Copy task to put the referenced 
+                // Add a call to RAR (ResolveAssemblyReference) and the Copy task to put the referenced
                 // project outputs in the right place
                 AddTasksToCopyAllDependenciesIntoBinDir(newTarget, project, referenceItemName.ToString(), conditionDescribingValidConfigurations.ToString());
 
@@ -1570,7 +1570,7 @@ private void ValidateTargetFrameworkForWebProject(ProjectInSolution project)
             }
         }
 
-        // As of .NET Framework 4.0, there are only two versions of aspnet_compiler.exe: 2.0 and 4.0.  If 
+        // As of .NET Framework 4.0, there are only two versions of aspnet_compiler.exe: 2.0 and 4.0.  If
         // the TargetFrameworkVersion is less than 4.0, use the 2.0 version.  Otherwise, just use the 4.0
         // version of the executable, so that if say FV 4.1 is passed in, we don't throw an error.
         private void SetToolPathForAspNetCompilerTask(ProjectInSolution project, ProjectTaskInstance task)
@@ -1722,7 +1722,7 @@ private static void AddPropertyGroupForAspNetConfiguration(
 
                 if (!String.IsNullOrEmpty(lastFolderInPhysicalPath))
                 {
-                    // If there is a global property called "OutDir" set, that means the caller is trying to 
+                    // If there is a global property called "OutDir" set, that means the caller is trying to
                     // override the AspNetTargetPath.  What we want to do in this case is concatenate:
                     // $(OutDir) + "\_PublishedWebsites" + (the last portion of the folder in the AspNetPhysicalPath).
                     if (traversalProject.EvaluateCondition(" '$(OutDir)' != '' "))
@@ -2076,7 +2076,7 @@ private IDictionary<string, string> GetMetaprojectGlobalProperties(ProjectInstan
             }
 
             // If we have a sub-toolset version, it will be set on the P2P from the solution metaproj, so we need
-            // to make sure it's set here, too, so the global properties will match.  
+            // to make sure it's set here, too, so the global properties will match.
             if (traversalProject.SubToolsetVersion != null)
             {
                 if (traversalProject.SubToolsetVersion.Equals("4.0", StringComparison.OrdinalIgnoreCase))
@@ -2124,7 +2124,7 @@ private void ScanProjectDependencies(string childProjectToolsVersion, string ful
 
             foreach (ProjectInSolution project in _solutionFile.ProjectsInOrder)
             {
-                // We only need to scan .wdproj projects: Everything else is either MSBuildFormat or 
+                // We only need to scan .wdproj projects: Everything else is either MSBuildFormat or
                 // something we don't know how to do anything with anyway
                 if (project.ProjectType == SolutionProjectType.WebDeploymentProject)
                 {
@@ -2138,11 +2138,11 @@ private void ScanProjectDependencies(string childProjectToolsVersion, string ful
                     {
                         Project msbuildProject = new Project(project.AbsolutePath, _globalProperties, childProjectToolsVersion);
 
-                        // ProjectDependency items work exactly like ProjectReference items from the point of 
+                        // ProjectDependency items work exactly like ProjectReference items from the point of
                         // view of determining that project B depends on project A.  This item must cause
                         // project A to be built prior to project B.
                         //
-                        // This has the format 
+                        // This has the format
                         // <ProjectDependency Include="DependentProjectRelativePath">
                         //   <Project>{GUID}</Project>
                         // </Project>
diff --git a/src/Build/Construction/UsingTaskParameterGroupElement.cs b/src/Build/Construction/UsingTaskParameterGroupElement.cs
index 3e76edb1e85..9bbc27f71e2 100644
--- a/src/Build/Construction/UsingTaskParameterGroupElement.cs
+++ b/src/Build/Construction/UsingTaskParameterGroupElement.cs
@@ -45,7 +45,7 @@ private UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, Projec
         }
 
         /// <summary>
-        /// Condition should never be set, but the getter returns null instead of throwing 
+        /// Condition should never be set, but the getter returns null instead of throwing
         /// because a nonexistent condition is implicitly true
         /// </summary>
         public override string Condition
@@ -128,7 +128,7 @@ private static void VerifyCorrectParent(ProjectElementContainer parent)
             ProjectUsingTaskElement parentUsingTask = parent as ProjectUsingTaskElement;
             ErrorUtilities.VerifyThrowInvalidOperation(parentUsingTask != null, "OM_CannotAcceptParent");
 
-            // Now since there is not goign to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and 
+            // Now since there is not goign to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and
             // that it is not empty
             if (parentUsingTask.TaskFactory.Length == 0)
             {
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 106b1ca08ee..d785f9f8c50 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -912,7 +912,7 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         /// uberGlob.IsMatch("foo.cs");
         /// ]]>
         /// </code>
-        /// 
+        ///
         /// </remarks>
         /// <returns>
         /// List of <see cref="GlobResult"/>.
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 5d2bf851cef..924b3e25db7 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1154,7 +1154,7 @@ public Project LoadProject(string fileName, IDictionary<string, string> globalPr
                 {
                     // We need to update the set of global properties to merge in the ProjectCollection global properties --
                     // otherwise we might end up declaring "not matching" a project that actually does ... and then throw
-                    // an exception when we go to actually add the newly created project to the ProjectCollection. 
+                    // an exception when we go to actually add the newly created project to the ProjectCollection.
                     // BUT remember that project global properties win -- don't override a property that already exists.
                     foreach (KeyValuePair<string, string> globalProperty in GlobalProperties)
                     {
@@ -1171,9 +1171,9 @@ public Project LoadProject(string fileName, IDictionary<string, string> globalPr
 
                 if (toolsVersion == null)
                 {
-                    // Load the project XML to get any ToolsVersion attribute. 
+                    // Load the project XML to get any ToolsVersion attribute.
                     // If there isn't already an equivalent project loaded, the real load we'll do will be satisfied from the cache.
-                    // If there is already an equivalent project loaded, we'll never need this XML -- but it'll already 
+                    // If there is already an equivalent project loaded, we'll never need this XML -- but it'll already
                     // have been loaded by that project so it will have been satisfied from the ProjectRootElementCache.
                     // Either way, no time wasted.
                     try
@@ -1350,7 +1350,7 @@ public void UnloadProject(Project project)
 
                 // Aggressively release any strings from all the contributing documents.
                 // It's fine if we cache less (by now we likely did a lot of loading and got the benefits)
-                // If we don't do this, we could be releasing the last reference to a 
+                // If we don't do this, we could be releasing the last reference to a
                 // ProjectRootElement, causing it to fall out of the weak cache leaving its strings and XML
                 // behind in the string cache.
                 project.Xml.XmlDocument.ClearAnyCachedStrings();
@@ -1578,12 +1578,12 @@ internal void OnAfterRenameLoadedProject(string oldFullPathIfAny, Project projec
                     ErrorUtilities.VerifyThrowInvalidOperation(existed, "OM_ProjectWasNotLoaded");
                 }
 
-                // The only time this ever gets called with a null full path is when the project is first being 
-                // constructed.  The mere fact that this method is being called means that this project will belong 
-                // to this project collection.  As such, it has already had all necessary global properties applied 
-                // when being constructed -- we don't need to do anything special here. 
-                // If we did add global properties here, we would just end up either duplicating work or possibly 
-                // wiping out global properties set on the project meant to override the ProjectCollection copies. 
+                // The only time this ever gets called with a null full path is when the project is first being
+                // constructed.  The mere fact that this method is being called means that this project will belong
+                // to this project collection.  As such, it has already had all necessary global properties applied
+                // when being constructed -- we don't need to do anything special here.
+                // If we did add global properties here, we would just end up either duplicating work or possibly
+                // wiping out global properties set on the project meant to override the ProjectCollection copies.
                 _loadedProjects.AddProject(project);
 
                 if (_hostServices != null)
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 645f8810cc0..ddcf37f6b30 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -42,30 +42,30 @@ public class ProjectItem : IItem<ProjectMetadata>, IProjectMetadataParent
         /// </summary>
         /// <remarks>
         /// This is ONLY used to figure out %(RecursiveDir) when it is requested.
-        /// It's likely too expensive to figure that out if it isn't needed, so we store 
+        /// It's likely too expensive to figure that out if it isn't needed, so we store
         /// the necessary material here.
         /// </remarks>
         private readonly string _evaluatedIncludeBeforeWildcardExpansionEscaped;
 
         /// <summary>
         /// Item definitions are stored in one single table shared by all items of a particular item type.
-        /// 
+        ///
         /// When an item is created from another item, such as by using an expression like Include="@(x)",
-        /// any item definition metadata those source items have must override any item definition metadata 
-        /// associated with the new item type. 
-        /// 
+        /// any item definition metadata those source items have must override any item definition metadata
+        /// associated with the new item type.
+        ///
         /// Copying all those item definition metadata into real metadata on this item would be very inefficient, because
         /// it would turn a single shared table into a separate table for every item.
-        /// 
+        ///
         /// Instead, we get a reference to the item definition of the source items, and consult
         /// that table before we consult our own item type's item definition. Since item definitions can't change at this point,
         /// it's safe to reference their original table.
-        /// 
+        ///
         /// If our item gets copied again, we need a reference to the inherited item definition and we need the real item
         /// definition of the source items. Thus a list is created. On copying, a list is created, beginning with a clone
         /// of any list the source item had, and ending with the item definition list of the source item type.
-        /// 
-        /// When we look up a metadata value we look at 
+        ///
+        /// When we look up a metadata value we look at
         /// (1) directly associated metadata and built-in metadata
         /// (2) the inherited item definition list, starting from the top
         /// (3) the item definition associated with our item type
@@ -194,7 +194,7 @@ public string UnevaluatedInclude
         }
 
         /// <summary>
-        /// Gets the evaluated value of the include, unescaped. 
+        /// Gets the evaluated value of the include, unescaped.
         /// </summary>
         public string EvaluatedInclude
         {
@@ -425,7 +425,7 @@ public ProjectMetadata GetMetadata(string name)
         }
 
         /// <summary>
-        /// Get the evaluated value of a metadata on this item, possibly from an item definition. 
+        /// Get the evaluated value of a metadata on this item, possibly from an item definition.
         /// Returns empty string if it does not exist.
         /// To determine whether a piece of metadata does not exist vs. simply has no value, use <see cref="HasMetadata(string)">HasMetadata</see>.
         /// May be used to access the value of built-in metadata, such as "FullPath".
@@ -468,8 +468,8 @@ public bool HasMetadata(string name)
         }
 
         /// <summary>
-        /// See <see cref="GetMetadataValue(string)">GetMetadataValue</see> for a more detailed explanation.  
-        /// Returns the escaped value of the metadatum requested.  
+        /// See <see cref="GetMetadataValue(string)">GetMetadataValue</see> for a more detailed explanation.
+        /// Returns the escaped value of the metadatum requested.
         /// </summary>
         string IItem.GetMetadataValueEscaped(string name)
         {
@@ -523,7 +523,7 @@ ProjectMetadata IItem<ProjectMetadata>.GetMetadata(string name)
         }
 
         /// <summary>
-        /// Adds a ProjectMetadata to the item. 
+        /// Adds a ProjectMetadata to the item.
         /// This is ONLY called during evaluation and does not affect the XML.
         /// </summary>
         ProjectMetadata IItem<ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude)
@@ -558,7 +558,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
         /// <summary>
         /// Overload of <see cref="SetMetadataValue(string,string)"/>. Adds the option of not splitting the item element and thus affecting all sibling items.
         /// Sibling items are defined as all ProjectItem instances that were created from the same item element.
-        /// 
+        ///
         /// This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state without a reevaluation
         /// </summary>
         /// /// <param name="name">Metadata name</param>
@@ -663,7 +663,7 @@ public bool RemoveMetadata(string name)
         /// <summary>
         /// Renames the item.
         /// Equivalent to setting the <see cref="UnevaluatedInclude"/> value.
-        /// Generally, no expansion occurs. This is because it would potentially result in several items, 
+        /// Generally, no expansion occurs. This is because it would potentially result in several items,
         /// which is not meaningful semantics when renaming a single item.
         /// However if the item does not need to be split (which would invalidate its ProjectItemElement),
         /// and the new value expands to exactly one item, then its evaluated include is updated
@@ -671,12 +671,12 @@ public bool RemoveMetadata(string name)
         /// </summary>
         /// <remarks>
         /// Even if the new value expands to zero items, we do not expand it.
-        /// The common case we are interested in for expansion here is setting something 
-        /// like "$(sourcesroot)\foo.cs" and expanding that to a single item. 
-        /// If say "@(foo)" is set as the new name, and it expands to blank, that might 
-        /// be surprising to the host and maybe even unhandled, if on full reevaluation 
-        /// it wouldn’t expand to blank. That’s why we're being cautious and supporting 
-        /// the most common scenario only. 
+        /// The common case we are interested in for expansion here is setting something
+        /// like "$(sourcesroot)\foo.cs" and expanding that to a single item.
+        /// If say "@(foo)" is set as the new name, and it expands to blank, that might
+        /// be surprising to the host and maybe even unhandled, if on full reevaluation
+        /// it wouldn’t expand to blank. That’s why we're being cautious and supporting
+        /// the most common scenario only.
         /// Many hosts will do a ReevaluateIfNecessary before reading anyway.
         /// </remarks>
         public void Rename(string name)
@@ -826,7 +826,7 @@ internal void SplitOwnItemElement()
                 return;
             }
 
-            // ProjectMetadata objects may be being shared with other ProjectItem objects, 
+            // ProjectMetadata objects may be being shared with other ProjectItem objects,
             // or originate from item definitions, so it is necessary to replace ours with
             // new ones.
             List<ProjectMetadata> temporary = new List<ProjectMetadata>(_directMetadata.Count);
@@ -957,8 +957,8 @@ public ProjectItemElement ItemElement
             /// <param name="definingProject">The path to the project that defined the item.</param>
             /// <returns>A new project item.</returns>
             /// <comments>
-            /// NOTE: defining project is ignored because we already know the ItemElement associated with 
-            /// this item, and use that for where it is defined. 
+            /// NOTE: defining project is ignored because we already know the ItemElement associated with
+            /// this item, and use that for where it is defined.
             /// </comments>
             public ProjectItem CreateItem(string include, string definingProject)
             {
@@ -974,8 +974,8 @@ public ProjectItem CreateItem(string include, string definingProject)
             /// setting metadata should create new XML.
             /// </summary>
             /// <comments>
-            /// NOTE: defining project is ignored because we already know the ItemElement associated with 
-            /// this item, and use that for where it is defined. 
+            /// NOTE: defining project is ignored because we already know the ItemElement associated with
+            /// this item, and use that for where it is defined.
             /// </comments>
             public ProjectItem CreateItem(ProjectItem source, string definingProject)
             {
@@ -994,8 +994,8 @@ public ProjectItem CreateItem(ProjectItem source, string definingProject)
             /// If it's not, we have to clone that too.
             /// </remarks>
             /// <comments>
-            /// NOTE: defining project is ignored because we already know the ItemElement associated with 
-            /// this item, and use that for where it is defined. 
+            /// NOTE: defining project is ignored because we already know the ItemElement associated with
+            /// this item, and use that for where it is defined.
             /// </comments>
             public ProjectItem CreateItem(string evaluatedIncludeEscaped, ProjectItem source, string definingProject)
             {
@@ -1007,8 +1007,8 @@ public ProjectItem CreateItem(string evaluatedIncludeEscaped, ProjectItem source
             /// This is to support creating items from an include that may have a wildcard expression in it.
             /// </summary>
             /// <comments>
-            /// NOTE: defining project is ignored because we already know the ItemElement associated with 
-            /// this item, and use that for where it is defined. 
+            /// NOTE: defining project is ignored because we already know the ItemElement associated with
+            /// this item, and use that for where it is defined.
             /// </comments>
             public ProjectItem CreateItem(string evaluatedIncludeEscaped, string evaluatedIncludeBeforeWildcardExpansion, string definingProject)
             {
@@ -1020,11 +1020,11 @@ public ProjectItem CreateItem(string evaluatedIncludeEscaped, string evaluatedIn
             /// <summary>
             /// Applies the supplied metadata to the destination item.
             /// </summary>
-            public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<ProjectItem> destinationItems)
+            public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<ProjectItem> destinationItems)
             {
                 foreach (IItem<ProjectMetadata> item in destinationItems)
                 {
-                    foreach (Pair<ProjectMetadataElement, string> metadatum in metadata)
+                    foreach (KeyValuePair<ProjectMetadataElement, string> metadatum in metadata)
                     {
                         item.SetMetadata(metadatum.Key, metadatum.Value);
                     }
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index cfffb456d72..d3d70ef98de 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -105,7 +105,7 @@ public int MetadataCount
         }
 
         /// <summary>
-        /// Implementation of IKeyed exposing the item type, so these 
+        /// Implementation of IKeyed exposing the item type, so these
         /// can be put in a dictionary conveniently.
         /// </summary>
         string IKeyed.Key
@@ -168,7 +168,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
                 }
             }
 
-            // We can't use the item definition that this object came from as a root, as it doesn't map directly 
+            // We can't use the item definition that this object came from as a root, as it doesn't map directly
             // to a single XML element. Instead, add a new one to the project. Best we can do.
             ProjectItemDefinitionElement itemDefinition = _project.Xml.AddItemDefinition(_itemType);
 
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index bd4cc51c88a..df770c85ce7 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -65,7 +65,7 @@ internal ProjectMetadata(object parent, ProjectMetadataElement xml)
         }
 
         /// <summary>
-        /// Creates a metadata backed by XML. 
+        /// Creates a metadata backed by XML.
         /// Constructed during evaluation of a project.
         /// </summary>
         internal ProjectMetadata(IProjectMetadataParent parent, ProjectMetadataElement xml, string evaluatedValueEscaped, ProjectMetadata predecessor)
@@ -106,19 +106,19 @@ public string EvaluatedValue
 
         /// <summary>
         /// Gets or sets the unevaluated metadata value.
-        /// 
+        ///
         /// As well as updating the unevaluated value, the setter updates the evaluated value, but does not affect anything else in the project until reevaluation. For example,
         ///     --if a piece of metadata named "m" is modified on item of type "i", it does not affect "j" which is evaluated from "@(j->'%(m)')" until reevaluation.
         ///     --if the unevaluated value of "m" is set to something that is modified by evaluation, such as "$(p)", the evaluated value will be set to "$(p)" until reevaluation.
         /// This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state.
-        /// 
+        ///
         /// Setting metadata through a ProjectItem may cause the underlying ProjectItemElement to be split, if it originated with an itemlist, wildcard, or semicolon expression,
         /// because it was clear that the caller intended to only affect that particular item.
         /// Setting metadata through a ProjectMetadata does not cause any splitting, because we assume the caller presumably intends to affect all items using the underlying
         /// ProjectMetadataElement. At least, this seems a reasonable assumption, and it avoids the need for metadata to hold a pointer to their containing items.
         /// </summary>
         /// <remarks>
-        /// The containing project will be dirtied by the XML modification.  Unevaluated values are assumed to be passed in escaped as necessary. 
+        /// The containing project will be dirtied by the XML modification.  Unevaluated values are assumed to be passed in escaped as necessary.
         /// </remarks>
         public string UnevaluatedValue
         {
diff --git a/src/Build/Definition/SubToolset.cs b/src/Build/Definition/SubToolset.cs
index 95cf1aa153e..84747bbb9d2 100644
--- a/src/Build/Definition/SubToolset.cs
+++ b/src/Build/Definition/SubToolset.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// Aggregation of a set of properties that correspond to a particular sub-toolset.  
+    /// Aggregation of a set of properties that correspond to a particular sub-toolset.
     /// </summary>
     [DebuggerDisplay("SubToolsetVersion={SubToolsetVersion} #Properties={_properties.Count}")]
     public class SubToolset : ITranslatable
@@ -28,11 +28,11 @@ public class SubToolset : ITranslatable
 
         /// <summary>
         /// The properties defined by the subtoolset.
-        /// </summary> 
+        /// </summary>
         private PropertyDictionary<ProjectPropertyInstance> _properties;
 
         /// <summary>
-        /// Constructor that associates a set of properties with a sub-toolset version.  
+        /// Constructor that associates a set of properties with a sub-toolset version.
         /// </summary>
         internal SubToolset(string subToolsetVersion, PropertyDictionary<ProjectPropertyInstance> properties)
         {
@@ -62,7 +62,7 @@ public string SubToolsetVersion
         }
 
         /// <summary>
-        /// The properties that correspond to this particular sub-toolset. 
+        /// The properties that correspond to this particular sub-toolset.
         /// </summary>
         public IDictionary<string, ProjectPropertyInstance> Properties
         {
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 58b18cadab1..212fb7fecc1 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -902,7 +902,7 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
             try
             {
-                
+
                 List<ProjectPropertyInstance> reservedProperties = new List<ProjectPropertyInstance>();
 
                 reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.binPath, EscapingUtilities.Escape(ToolsPath), mayBeReserved: true));
diff --git a/src/Build/Definition/ToolsetPropertyDefinition.cs b/src/Build/Definition/ToolsetPropertyDefinition.cs
index da172891cd1..c7ee19a570d 100644
--- a/src/Build/Definition/ToolsetPropertyDefinition.cs
+++ b/src/Build/Definition/ToolsetPropertyDefinition.cs
@@ -79,7 +79,7 @@ public string Value
 
         /// <summary>
         /// A description of the location where the property was defined,
-        /// such as a registry key path or a path to a config file and 
+        /// such as a registry key path or a path to a config file and
         /// line number.
         /// </summary>
         public IElementLocation Source
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index d7d81e88dc6..dc91a43e774 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -115,7 +115,7 @@ internal static string ReadAllToolsets(
             initialProperties.ImportProperties(globalProperties);
 
             // The ordering here is important because the configuration file should have greater precedence
-            // than the registry, and we do a check and don't read in the new toolset if there's already one. 
+            // than the registry, and we do a check and don't read in the new toolset if there's already one.
             string defaultToolsVersionFromConfiguration = null;
             string overrideTasksPathFromConfiguration = null;
             string defaultOverrideToolsVersionFromConfiguration = null;
@@ -248,12 +248,12 @@ void ReadConfigToolset()
                 }
             }
 
-            // The 2.0 .NET Framework installer did not write a ToolsVersion key for itself in the registry. 
-            // The 3.5 installer writes one for 2.0, but 3.5 might not be installed.  
-            // The 4.0 and subsequent installers can't keep writing the 2.0 one, because (a) it causes SxS issues and (b) we 
+            // The 2.0 .NET Framework installer did not write a ToolsVersion key for itself in the registry.
+            // The 3.5 installer writes one for 2.0, but 3.5 might not be installed.
+            // The 4.0 and subsequent installers can't keep writing the 2.0 one, because (a) it causes SxS issues and (b) we
             // don't want it unless 2.0 is installed.
             // So if the 2.0 framework is actually installed, we're reading the registry, and either the registry or the config
-            // file have not already created the 2.0 toolset, mock up a fake one.  
+            // file have not already created the 2.0 toolset, mock up a fake one.
             if (((locations & ToolsetDefinitionLocations.Registry) != 0) && !toolsets.ContainsKey("2.0")
                 && FrameworkLocationHelper.PathToDotNetFrameworkV20 != null)
             {
@@ -396,8 +396,8 @@ internal string ReadToolsets(
         protected abstract IEnumerable<string> GetSubToolsetVersions(string toolsVersion);
 
         /// <summary>
-        /// Provides an enumerator over property definitions for a specified sub-toolset version 
-        /// under a specified toolset version. 
+        /// Provides an enumerator over property definitions for a specified sub-toolset version
+        /// under a specified toolset version.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version.</param>
@@ -421,10 +421,10 @@ private void ReadEachToolset(
             foreach (ToolsetPropertyDefinition toolsVersion in ToolsVersions)
             {
                 // If there's already an existing toolset, it's of higher precedence, so
-                // don't even bother to read this toolset in.  
+                // don't even bother to read this toolset in.
                 if (!toolsets.ContainsKey(toolsVersion.Name))
                 {
-                    // We clone here because we don't want to interfere with the evaluation 
+                    // We clone here because we don't want to interfere with the evaluation
                     // of subsequent Toolsets; otherwise, properties found during the evaluation
                     // of this Toolset would be persisted in initialProperties and appear
                     // to later Toolsets as Global or Environment properties from the Engine.
@@ -509,7 +509,7 @@ private Toolset ReadToolset(
                 IEnumerable<ToolsetPropertyDefinition> rawSubToolsetProperties = GetSubToolsetPropertyDefinitions(toolsVersion.Name, subToolsetVersion);
                 PropertyDictionary<ProjectPropertyInstance> subToolsetProperties = new PropertyDictionary<ProjectPropertyInstance>();
 
-                // If we have a sub-toolset, any values defined here will override the toolset properties. 
+                // If we have a sub-toolset, any values defined here will override the toolset properties.
                 foreach (ToolsetPropertyDefinition property in rawSubToolsetProperties)
                 {
                     EvaluateAndSetProperty(property, subToolsetProperties, globalProperties, initialProperties, false /* do not ever accumulate sub-toolset properties */, ref subToolsetToolsPath, ref subToolsetBinPath, ref expander);
@@ -646,7 +646,7 @@ private static void AppendStandardProperties(
         }
 
         /// <summary>
-        /// Processes a particular ToolsetPropertyDefinition into the correct value and location in the initial and/or final property set. 
+        /// Processes a particular ToolsetPropertyDefinition into the correct value and location in the initial and/or final property set.
         /// </summary>
         /// <param name="property">The ToolsetPropertyDefinition being analyzed.</param>
         /// <param name="properties">The final set of properties that we wish this toolset property to be added to. </param>
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 8d84d5dc908..2dd2bb89a95 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -301,8 +301,8 @@ public override int Column
         /// For when the line and column each fit in a short - under 65536
         /// (almost always will: microsoft.common.targets is less than 5000 lines long)
         /// When loading Australian Government, for example, there are over 31,000 ElementLocation
-        /// objects so this saves 4 bytes each = 123KB 
-        /// 
+        /// objects so this saves 4 bytes each = 123KB
+        ///
         /// A "very small" variation that used two bytes (or halves of a short) would fit about half of them
         /// and save 4 more bytes each, but the CLR packs each field to 4 bytes, so it isn't actually any smaller.
         /// </summary>
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 88b0de71dbb..71f51e9f272 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Construction
     /// <remarks>
     /// XmlDocument has many members, and this can't substitute for all of them. Location finding probably won't work if
     /// certain XmlDocument members are used. So for extra robustness, this could wrap an XmlDocument instead,
-    /// and expose the small number of members that the MSBuild code actually uses. 
+    /// and expose the small number of members that the MSBuild code actually uses.
     /// </remarks>
     internal class XmlDocumentWithLocation : XmlDocument
     {
diff --git a/src/Build/ElementLocation/XmlElementWithLocation.cs b/src/Build/ElementLocation/XmlElementWithLocation.cs
index ddbf27a08de..b45ccb5b723 100644
--- a/src/Build/ElementLocation/XmlElementWithLocation.cs
+++ b/src/Build/ElementLocation/XmlElementWithLocation.cs
@@ -128,7 +128,7 @@ public XmlAttributeWithLocation GetAttributeWithLocation(string name)
         }
 
         /// <summary>
-        /// Overridden to convert the display of the element from open form (separate open and closed tags) to closed form 
+        /// Overridden to convert the display of the element from open form (separate open and closed tags) to closed form
         /// (single closed tag) if the last child is being removed. This is simply for tidiness of the project file.
         /// For example, removing the only piece of metadata from an item will leave behind one tag instead of two.
         /// </summary>
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 7bc6e4a135d..fe42d76e2fb 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -80,7 +80,7 @@ internal InvalidProjectFileException(string message, InvalidProjectFileException
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
@@ -370,7 +370,7 @@ public string HelpKeyword
         }
 
         /// <summary>
-        /// Whether the exception has already been logged. Allows the exception to be logged at the 
+        /// Whether the exception has already been logged. Allows the exception to be logged at the
         /// most appropriate location, but continue to be propagated.
         /// </summary>
         public bool HasBeenLogged
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 1ebc9c9d1b1..df5b2a09797 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -139,7 +139,7 @@ public string ErrorCode
 
         /// <summary>
         /// Throws an InvalidToolsetDefinitionException.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -156,7 +156,7 @@ internal static void Throw(
         /// <summary>
         /// Throws an InvalidToolsetDefinitionException including a specified inner exception,
         /// which may be interesting to hosts.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index aeb2bc7414e..1d231597726 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -23,7 +23,7 @@ internal static class ConditionEvaluator
         /// inside of a condition and the string values that they are being tested against.
         /// So, for example, if the condition was " '$(Configuration)' == 'Debug' ", we
         /// would get passed in leftValue="$(Configuration)" and rightValueExpanded="Debug".
-        /// This call would add the string "Debug" to the list of possible values for the 
+        /// This call would add the string "Debug" to the list of possible values for the
         /// "Configuration" property.
         ///
         /// This method also handles the case when two or more properties are being
@@ -62,7 +62,7 @@ internal static void UpdateConditionedPropertiesTable(
                         string rightValueExpandedPiece;
 
                         // If there was no vertical bar, then just use the remainder of the right-hand-side
-                        // expression as the value of the property, and terminate the loop after this iteration.  
+                        // expression as the value of the property, and terminate the loop after this iteration.
                         // Also, if we're on the last segment of the left-hand-side, then use the remainder
                         // of the right-hand-side expression as the value of the property.
                         if ((indexOfVerticalBar == -1) || lastPiece)
@@ -73,7 +73,7 @@ internal static void UpdateConditionedPropertiesTable(
                         else
                         {
                             // If we found a vertical bar, then the portion before the vertical bar is the
-                            // property value which we will store in our table.  Then remove that portion 
+                            // property value which we will store in our table.  Then remove that portion
                             // from the original string so that the next iteration of the loop can easily search
                             // for the first vertical bar again.
                             rightValueExpandedPiece = rightValueExpanded.Substring(0, indexOfVerticalBar);
@@ -383,7 +383,7 @@ internal interface IConditionEvaluationState
         }
 
         /// <summary>
-        /// All the state necessary for the evaluation of conditionals so that the expression tree 
+        /// All the state necessary for the evaluation of conditionals so that the expression tree
         /// is stateless and reusable
         /// </summary>
         internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
@@ -414,7 +414,7 @@ internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
             public Dictionary<string, List<string>>? ConditionedPropertiesInProject { get; }
 
             /// <summary>
-            /// PRE collection. 
+            /// PRE collection.
             /// </summary>
             public ProjectRootElementCacheBase? LoadedProjectsCache { get; }
 
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index ee3ccbe9b2d..e16e7537379 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -63,7 +63,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     // Ignore invalid characters or path related exceptions
 
                     // We will ignore the PathTooLong exception caused by GetFullPath because in single proc this code
-                    // is not executed and the condition is just evaluated to false as File.Exists and Directory.Exists does not throw in this situation. 
+                    // is not executed and the condition is just evaluated to false as File.Exists and Directory.Exists does not throw in this situation.
                     // To be consistant with that we will return a false in this case also.
                     // DevDiv Bugs: 46035
 
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index aa512c045b3..3d0d6d99456 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -43,7 +43,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         internal abstract string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal abstract void ResetState();
@@ -90,7 +90,7 @@ internal virtual bool PossibleOrCollision
         internal bool PotentialAndOrConflict()
         {
             // The values of the functions are assigned to boolean locals
-            // in order to force evaluation of the functions even when the 
+            // in order to force evaluation of the functions even when the
             // first one returns false
             bool detectOr = DetectOr();
             bool detectAnd = DetectAnd();
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index e1cf63fd6bf..208794b3603 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -45,11 +45,11 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                  "IllFormedCondition",
                  state.Condition);
 
-            // It's sometimes possible to bail out of expansion early if we just need to know whether 
+            // It's sometimes possible to bail out of expansion early if we just need to know whether
             // the result is empty string.
-            // If at least one of the left or the right hand side will evaluate to empty, 
+            // If at least one of the left or the right hand side will evaluate to empty,
             // and we know which do, then we already have enough information to evaluate this expression.
-            // That means we don't have to fully expand a condition like " '@(X)' == '' " 
+            // That means we don't have to fully expand a condition like " '@(X)' == '' "
             // which is a performance advantage if @(X) is a huge item list.
             bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
             bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 536ac17ae9b..acfdd72bce9 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -56,7 +56,7 @@ internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluatio
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 0f20ef208c3..2c172a9af0a 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -52,7 +52,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 0984647db61..0407cd0d7f5 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -53,7 +53,7 @@ internal sealed class Parser
 
         private BuildEventContext _logBuildEventContext;
         /// <summary>
-        ///  Location contextual information which are attached to logging events to 
+        ///  Location contextual information which are attached to logging events to
         ///  say where they are in relation to the process, engine, project, target,task which is executing
         /// </summary>
         internal BuildEventContext LogBuildEventContext
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 2f05a821326..2c3dcc080df 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -148,7 +148,7 @@ internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluatio
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Build/Evaluation/Conditionals/Token.cs b/src/Build/Evaluation/Conditionals/Token.cs
index 182c3e3c6b0..9f86503f454 100644
--- a/src/Build/Evaluation/Conditionals/Token.cs
+++ b/src/Build/Evaluation/Conditionals/Token.cs
@@ -117,7 +117,7 @@ internal bool Expandable
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="type"></param>
         /// <returns></returns>
@@ -135,7 +135,7 @@ internal string String
                     return _tokenString;
                 }
 
-                // Return a token string for 
+                // Return a token string for
                 // an error message.
                 switch (_tokenType)
                 {
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index d28c9210e29..649ae9ac856 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -110,7 +110,7 @@ private EvaluationContext CreateUsedIsolatedContext()
 
         internal EvaluationContext ContextForNewProject()
         {
-            // Projects using isolated contexts need to get a new context instance 
+            // Projects using isolated contexts need to get a new context instance
             switch (Policy)
             {
                 case SharingPolicy.Shared:
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index f5db7b9d74a..e048e5dd371 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -92,7 +92,7 @@ internal class Evaluator<P, I, M, D>
         /// Key is the directory of the file importing the usingTask, which is needed
         /// to handle any relative paths in the usingTask.
         /// </summary>
-        private readonly List<Pair<string, ProjectUsingTaskElement>> _usingTaskElements;
+        private readonly List<KeyValuePair<string, ProjectUsingTaskElement>> _usingTaskElements;
 
         /// <summary>
         /// List of ProjectTargetElement's traversing into imports.
@@ -115,7 +115,7 @@ internal class Evaluator<P, I, M, D>
         /// Dictionary of project full paths and a boolean that indicates whether at least one
         /// of their targets has the "Returns" attribute set.
         /// </summary>
-        private readonly Dictionary<ProjectRootElement, NGen<bool>> _projectSupportsReturnsAttribute;
+        private readonly Dictionary<ProjectRootElement, bool> _projectSupportsReturnsAttribute;
 
         /// <summary>
         /// The Project Xml to be evaluated.
@@ -249,11 +249,11 @@ private Evaluator(
             _data = data;
             _itemGroupElements = new List<ProjectItemGroupElement>();
             _itemDefinitionGroupElements = new List<ProjectItemDefinitionGroupElement>();
-            _usingTaskElements = new List<Pair<string, ProjectUsingTaskElement>>();
+            _usingTaskElements = new List<KeyValuePair<string, ProjectUsingTaskElement>>();
             _targetElements = new List<ProjectTargetElement>();
             _importsSeen = new Dictionary<string, ProjectImportElement>(StringComparer.OrdinalIgnoreCase);
             _initialTargetsList = new List<string>();
-            _projectSupportsReturnsAttribute = new Dictionary<ProjectRootElement, NGen<bool>>();
+            _projectSupportsReturnsAttribute = new Dictionary<ProjectRootElement, bool>();
             _projectRootElement = projectRootElement;
             _loadSettings = loadSettings;
             _maxNodeCount = maxNodeCount;
@@ -901,7 +901,7 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
                             break;
                         case ProjectTargetElement target:
                             // Defaults to false
-                            _projectSupportsReturnsAttribute.TryGetValue(currentProjectOrImport, out NGen<bool> projectSupportsReturnsAttribute);
+                            _projectSupportsReturnsAttribute.TryGetValue(currentProjectOrImport, out bool projectSupportsReturnsAttribute);
 
                             _projectSupportsReturnsAttribute[currentProjectOrImport] = projectSupportsReturnsAttribute || (target.Returns != null);
                             _targetElements.Add(target);
@@ -913,7 +913,7 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
                             EvaluateImportGroupElement(currentProjectOrImport.DirectoryPath, importGroup);
                             break;
                         case ProjectUsingTaskElement usingTask:
-                            _usingTaskElements.Add(new Pair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
+                            _usingTaskElements.Add(new KeyValuePair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
                             break;
                         case ProjectChooseElement choose:
                             EvaluateChooseElement(choose);
@@ -1348,13 +1348,30 @@ private void LogPropertyReassignment(P predecessor, P property, string location)
 
             if (newValue != oldValue)
             {
-                _evaluationLoggingContext.LogComment(
-                    MessageImportance.Low,
-                    "PropertyReassignment",
-                    property.Name,
-                    newValue,
-                    oldValue,
-                    location);
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
+                {
+                    var args = new PropertyReassignmentEventArgs(
+                        property.Name,
+                        oldValue,
+                        newValue,
+                        location,
+                        message: null)
+                    {
+                        BuildEventContext = _evaluationLoggingContext.BuildEventContext,
+                    };
+
+                    _evaluationLoggingContext.LogBuildEvent(args);
+                }
+                else
+                {
+                    _evaluationLoggingContext.LogComment(
+                        MessageImportance.Low,
+                        "PropertyReassignment",
+                        property.Name,
+                        newValue,
+                        oldValue,
+                        location);
+                }
             }
         }
 
@@ -2536,7 +2553,16 @@ private void ThrowForImportedProjectWithSearchPathsNotFound(ProjectImportPathMat
                         importElement.Project.Replace(searchPathMatch.MsBuildPropertyFormat, extensionsPathPropValue),
                         ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
 
-                relativeProjectPath = FileUtilities.MakeRelative(extensionsPathPropValue, importExpandedWithDefaultPath);
+                try
+                {
+                    relativeProjectPath = FileUtilities.MakeRelative(extensionsPathPropValue, importExpandedWithDefaultPath);
+                }
+                catch (ArgumentException ex)
+                {
+                    // https://github.com/dotnet/msbuild/issues/8762 .Catch the exceptions when extensionsPathPropValue is null or importExpandedWithDefaultPath is empty. In NET Framework, Path.* function also throws exceptions if the path contains invalid characters.
+                    ProjectErrorUtilities.ThrowInvalidProject(importElement.Location, "InvalidAttributeValueWithException", importExpandedWithDefaultPath, XMakeAttributes.project, XMakeElements.import, ex.Message);
+                    return;
+                }
             }
             else
             {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 6e812c58767..c998910190e 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -616,7 +616,7 @@ internal bool ExpandExpressionCapture(
             ExpanderOptions options,
             bool includeNullEntries,
             out bool isTransformExpression,
-            out List<Pair<string, I>> itemsFromCapture)
+            out List<KeyValuePair<string, I>> itemsFromCapture)
         {
             return ItemExpander.ExpandExpressionCapture(this, expressionCapture, _items, elementLocation, options, includeNullEntries, out isTransformExpression, out itemsFromCapture);
         }
@@ -1055,7 +1055,7 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
                             _metadata is IItemTypeDefinition itemMetadata &&
                             (string.IsNullOrEmpty(itemType) || string.Equals(itemType, itemMetadata.ItemType, StringComparison.Ordinal)))
                         {
-                            _loggingContext.LogComment(MessageImportance.High, new BuildEventFileInfo(_elementLocation),
+                            _loggingContext.LogComment(MessageImportance.Low, new BuildEventFileInfo(_elementLocation),
                                 "ItemReferencingSelfInTarget", itemMetadata.ItemType, metadataName);
                         }
 
@@ -1742,7 +1742,7 @@ private static class ItemExpander
             /// Execute the list of transform functions.
             /// </summary>
             /// <typeparam name="S">class, IItem.</typeparam>
-            internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<Pair<string, S>> itemsOfType)
+            internal static IEnumerable<KeyValuePair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<KeyValuePair<string, S>> itemsOfType)
                 where S : class, IItem
             {
                 // If we have transforms on our stack, then we'll execute those first
@@ -1751,7 +1751,7 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
                 {
                     TransformFunction<S> function = transformFunctionStack.Pop();
 
-                    foreach (Pair<string, S> item in Transform(expander, includeNullEntries, transformFunctionStack, function.Execute(expander, includeNullEntries, itemsOfType)))
+                    foreach (KeyValuePair<string, S> item in Transform(expander, includeNullEntries, transformFunctionStack, function.Execute(expander, includeNullEntries, itemsOfType)))
                     {
                         yield return item;
                     }
@@ -1760,7 +1760,7 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
                 {
                     // When we have no more tranforms on the stack, iterate over the items
                     // that we have to return them
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         yield return item;
                     }
@@ -1893,7 +1893,7 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                     return result;
                 }
 
-                List<Pair<string, S>> itemsFromCapture;
+                List<KeyValuePair<string, S>> itemsFromCapture;
                 brokeEarlyNonEmpty = ExpandExpressionCapture(expander, expressionCapture, items, elementLocation /* including null items */, options, true, out isTransformExpression, out itemsFromCapture);
 
                 if (brokeEarlyNonEmpty)
@@ -1959,7 +1959,7 @@ internal static bool ExpandExpressionCapture<S>(
                 ExpanderOptions options,
                 bool includeNullEntries,
                 out bool isTransformExpression,
-                out List<Pair<string, S>> itemsFromCapture)
+                out List<KeyValuePair<string, S>> itemsFromCapture)
                 where S : class, IItem
             {
                 ErrorUtilities.VerifyThrow(evaluatedItems != null, "Cannot expand items without providing items");
@@ -1980,7 +1980,7 @@ internal static bool ExpandExpressionCapture<S>(
                         if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
                             expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
                         {
-                            itemsFromCapture = new List<Pair<string, S>>();
+                            itemsFromCapture = new List<KeyValuePair<string, S>>();
                             return false;
                         }
                     }
@@ -1991,7 +1991,7 @@ internal static bool ExpandExpressionCapture<S>(
                     isTransformExpression = true;
                 }
 
-                itemsFromCapture = new List<Pair<string, S>>(itemsOfType.Count);
+                itemsFromCapture = new List<KeyValuePair<string, S>>(itemsOfType.Count);
 
                 if (!isTransformExpression)
                 {
@@ -2003,7 +2003,7 @@ internal static bool ExpandExpressionCapture<S>(
                             return true;
                         }
 
-                        itemsFromCapture.Add(new Pair<string, S>(item.EvaluatedIncludeEscaped, item));
+                        itemsFromCapture.Add(new KeyValuePair<string, S>(item.EvaluatedIncludeEscaped, item));
                     }
                 }
                 else
@@ -2011,7 +2011,7 @@ internal static bool ExpandExpressionCapture<S>(
                     Stack<TransformFunction<S>> transformFunctionStack = PrepareTransformStackFromMatch<S>(elementLocation, expressionCapture);
 
                     // iterate over the tranform chain, creating the final items from its results
-                    foreach (Pair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
+                    foreach (KeyValuePair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
                     {
                         if (!string.IsNullOrEmpty(itemTuple.Key) && (options & ExpanderOptions.BreakOnNotEmpty) != 0)
                         {
@@ -2026,7 +2026,7 @@ internal static bool ExpandExpressionCapture<S>(
                 {
                     var joinedItems = string.Join(expressionCapture.Separator, itemsFromCapture.Select(i => i.Key));
                     itemsFromCapture.Clear();
-                    itemsFromCapture.Add(new Pair<string, S>(joinedItems, null));
+                    itemsFromCapture.Add(new KeyValuePair<string, S>(joinedItems, null));
                 }
 
                 return false; // did not break early
@@ -2144,7 +2144,7 @@ private static bool ExpandExpressionCaptureIntoStringBuilder<S>(
                 ExpanderOptions options)
                 where S : class, IItem
             {
-                List<Pair<string, S>> itemsFromCapture;
+                List<KeyValuePair<string, S>> itemsFromCapture;
                 bool throwaway;
                 var brokeEarlyNonEmpty = ExpandExpressionCapture(expander, capture, evaluatedItems, elementLocation /* including null items */, options, true, out throwaway, out itemsFromCapture);
 
@@ -2205,7 +2205,7 @@ internal static class IntrinsicItemFunctions<S>
                 /// Delegate that represents the signature of all item transformation functions
                 /// This is used to support calling the functions by name.
                 /// </summary>
-                public delegate IEnumerable<Pair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments);
+                public delegate IEnumerable<KeyValuePair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments);
 
                 /// <summary>
                 /// Get a delegate to the given item transformation function by supplying the name and the
@@ -2268,7 +2268,7 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
                 /// Create an enumerator from a base IEnumerable of items into an enumerable
                 /// of transformation result which includes the new itemspec and the base item.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
+                internal static IEnumerable<KeyValuePair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
                 {
                     // iterate over the items, and yield out items in the tuple format
                     foreach (var item in itemsOfType)
@@ -2281,12 +2281,12 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                                     item.EvaluatedIncludeEscaped,
                                     forceEvaluate: true))
                             {
-                                yield return new Pair<string, S>(resultantItem, item);
+                                yield return new KeyValuePair<string, S>(resultantItem, item);
                             }
                         }
                         else
                         {
-                            yield return new Pair<string, S>(item.EvaluatedIncludeEscaped, item);
+                            yield return new KeyValuePair<string, S>(item.EvaluatedIncludeEscaped, item);
                         }
                     }
                 }
@@ -2294,20 +2294,20 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                 /// <summary>
                 /// Intrinsic function that returns the number of items in the list.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
-                    yield return new Pair<string, S>(Convert.ToString(itemsOfType.Count(), CultureInfo.InvariantCulture), null /* no base item */);
+                    yield return new KeyValuePair<string, S>(Convert.ToString(itemsOfType.Count(), CultureInfo.InvariantCulture), null /* no base item */);
                 }
 
                 /// <summary>
                 /// Intrinsic function that returns the specified built-in modifer value of the items in itemsOfType
                 /// Tuple is {current item include, item under transformation}.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         // If the item include has become empty,
                         // this is the end of the pipeline for this item
@@ -2339,11 +2339,11 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                         {
                             // GetItemSpecModifier will have returned us an escaped string
                             // there is nothing more to do than yield it into the pipeline
-                            yield return new Pair<string, S>(result, item.Value);
+                            yield return new KeyValuePair<string, S>(result, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2351,11 +2351,11 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                 /// <summary>
                 /// Intrinsic function that returns the subset of items that actually exist on disk.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Exists(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2398,13 +2398,13 @@ internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IEl
                 /// <summary>
                 /// Intrinsic function that combines the existing paths of the input items with a given relative path.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string relativePath = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2415,14 +2415,14 @@ internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IE
                         string unescapedPath = EscapingUtilities.UnescapeAll(item.Key);
                         string combinedPath = Path.Combine(unescapedPath, relativePath);
                         string escapedPath = EscapingUtilities.Escape(combinedPath);
-                        yield return new Pair<string, S>(escapedPath, null);
+                        yield return new KeyValuePair<string, S>(escapedPath, null);
                     }
                 }
 
                 /// <summary>
                 /// Intrinsic function that returns all ancestor directories of the given items.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> GetPathsOfAllDirectoriesAbove(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
@@ -2430,7 +2430,7 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
 
                     SortedSet<string> directories = new SortedSet<string>(StringComparer.OrdinalIgnoreCase);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2490,7 +2490,7 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
                     foreach (string directoryPath in directories)
                     {
                         string escapedDirectoryPath = EscapingUtilities.Escape(directoryPath);
-                        yield return new Pair<string, S>(escapedDirectoryPath, null);
+                        yield return new KeyValuePair<string, S>(escapedDirectoryPath, null);
                     }
                 }
 
@@ -2498,13 +2498,13 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
                 /// Intrinsic function that returns the DirectoryName of the items in itemsOfType
                 /// UNDONE: This can be removed in favor of a built-in %(DirectoryName) metadata in future.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> DirectoryName(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     Dictionary<string, string> directoryNameTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         // If the item include has become empty,
                         // this is the end of the pipeline for this item
@@ -2553,11 +2553,11 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                         if (!String.IsNullOrEmpty(directoryName))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(directoryName, item.Value);
+                            yield return new KeyValuePair<string, S>(directoryName, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2565,13 +2565,13 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 /// <summary>
                 /// Intrinsic function that returns the contents of the metadata in specified in argument[0].
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (item.Value != null)
                         {
@@ -2598,18 +2598,18 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                                     foreach (string itemSpec in splits)
                                     {
                                         // return a result through the enumerator
-                                        yield return new Pair<string, S>(itemSpec, item.Value);
+                                        yield return new KeyValuePair<string, S>(itemSpec, item.Value);
                                     }
                                 }
                                 else
                                 {
                                     // return a result through the enumerator
-                                    yield return new Pair<string, S>(metadataValue, item.Value);
+                                    yield return new KeyValuePair<string, S>(metadataValue, item.Value);
                                 }
                             }
                             else if (metadataValue != String.Empty && includeNullEntries)
                             {
-                                yield return new Pair<string, S>(metadataValue, item.Value);
+                                yield return new KeyValuePair<string, S>(metadataValue, item.Value);
                             }
                         }
                     }
@@ -2619,7 +2619,7 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case sensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     return DistinctWithComparer(expander, elementLocation, includeNullEntries, functionName, itemsOfType, arguments, StringComparer.Ordinal);
                 }
@@ -2628,7 +2628,7 @@ internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> exp
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     return DistinctWithComparer(expander, elementLocation, includeNullEntries, functionName, itemsOfType, arguments, StringComparer.OrdinalIgnoreCase);
                 }
@@ -2637,20 +2637,18 @@ internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, I
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
+                internal static IEnumerable<KeyValuePair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     // This dictionary will ensure that we only return one result per unique itemspec
-                    Dictionary<string, S> seenItems = new Dictionary<string, S>(comparer);
+                    HashSet<string> seenItems = new HashSet<string>(comparer);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
-                        if (item.Key != null && !seenItems.ContainsKey(item.Key))
+                        if (item.Key != null && seenItems.Add(item.Key))
                         {
-                            seenItems[item.Key] = item.Value;
-
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2658,23 +2656,20 @@ internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I>
                 /// <summary>
                 /// Intrinsic function reverses the item list.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Reverse(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
-                    foreach (Pair<String, S> item in itemsOfType.Reverse())
-                    {
-                        yield return new Pair<string, S>(item.Key, item.Value);
-                    }
+                    return itemsOfType.Reverse();
                 }
 
                 /// <summary>
                 /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)').
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         MetadataMatchEvaluator matchEvaluator;
                         string include = null;
@@ -2697,11 +2692,11 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                         // We pass in the existing item so we can copy over its metadata
                         if (!string.IsNullOrEmpty(include))
                         {
-                            yield return new Pair<string, S>(include, item.Value);
+                            yield return new KeyValuePair<string, S>(include, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2710,17 +2705,17 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                 /// Intrinsic function that transforms expressions by invoking methods of System.String on the itemspec
                 /// of the item in the pipeline.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
+                internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
                     Expander<P, I> expander,
                     IElementLocation elementLocation,
                     bool includeNullEntries,
                     string functionName,
-                    IEnumerable<Pair<string, S>> itemsOfType,
+                    IEnumerable<KeyValuePair<string, S>> itemsOfType,
                     string[] arguments)
                 {
                     // Transform: expression is like @(Compile->'%(foo)'), so create completely new items,
                     // using the Include from the source items
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         Function<P> function = new Function<P>(
                             typeof(string),
@@ -2740,11 +2735,11 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                         // We pass in the existing item so we can copy over its metadata
                         if (include.Length > 0)
                         {
-                            yield return new Pair<string, S>(include, item.Value);
+                            yield return new KeyValuePair<string, S>(include, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2752,15 +2747,15 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                 /// <summary>
                 /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (includeNullEntries || item.Key != null)
                         {
-                            yield return new Pair<string, S>(item.Key, null);
+                            yield return new KeyValuePair<string, S>(item.Key, null);
                         }
                     }
                 }
@@ -2769,13 +2764,13 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
                 /// Intrinsic function that returns only those items that have a not-blank value for the metadata specified
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2794,7 +2789,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                         if (!string.IsNullOrEmpty(metadataValue))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2803,14 +2798,14 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                 /// Intrinsic function that returns only those items have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2827,7 +2822,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                         if (metadataValue != null && String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2836,14 +2831,14 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                 /// Intrinsic function that returns those items don't have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> WithoutMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2860,7 +2855,7 @@ internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I>
                         if (!String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2869,7 +2864,7 @@ internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I>
                 /// Intrinsic function that returns a boolean to indicate if any of the items have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
@@ -2877,7 +2872,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                     string metadataValueToFind = arguments[1];
                     bool metadataFound = false;
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (item.Value != null)
                         {
@@ -2898,7 +2893,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                                 metadataFound = true;
 
                                 // return a result through the enumerator
-                                yield return new Pair<string, S>("true", item.Value);
+                                yield return new KeyValuePair<string, S>("true", item.Value);
 
                                 // break out as soon as we found a match
                                 yield break;
@@ -2909,7 +2904,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                     if (!metadataFound)
                     {
                         // We did not locate an item with the required metadata
-                        yield return new Pair<string, S>("false", null);
+                        yield return new KeyValuePair<string, S>("false", null);
                     }
                 }
             }
@@ -2971,7 +2966,7 @@ public IElementLocation ElementLocation
                 /// <summary>
                 /// Execute this transform function with the arguments contained within this TransformFunction instance.
                 /// </summary>
-                public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<Pair<string, S>> itemsOfType)
+                public IEnumerable<KeyValuePair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<KeyValuePair<string, S>> itemsOfType)
                 {
                     // Execute via the delegate
                     return _transform(expander, _elementLocation, includeNullEntries, _functionName, itemsOfType, _arguments);
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index 360843f9b58..fd102dff143 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -634,8 +634,8 @@ private static bool SinkValidName(string expression, ref int i, int end)
         }
 
         /// <summary>
-        /// Returns true if the character at the specified index 
-        /// is the specified char. 
+        /// Returns true if the character at the specified index
+        /// is the specified char.
         /// Leaves index one past the character.
         /// </summary>
         private static bool Sink(string expression, ref int i, char c)
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 729e99b48ab..d6074d17f46 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -45,7 +45,7 @@ string Directory
         }
 
         /// <summary>
-        /// Task classes and locations known to this project. 
+        /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
         /// the toolset's task registry.
         /// </summary>
@@ -64,8 +64,8 @@ Toolset Toolset
         }
 
         /// <summary>
-        /// The sub-toolset version that should be used with this toolset to determine 
-        /// the full set of properties to be used by the build. 
+        /// The sub-toolset version that should be used with this toolset to determine
+        /// the full set of properties to be used by the build.
         /// </summary>
         string SubToolsetVersion
         {
@@ -92,7 +92,7 @@ PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary
         }
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         ISet<string> GlobalPropertiesToTreatAsLocal
         {
@@ -174,7 +174,7 @@ PropertyDictionary<P> Properties
         /// <summary>
         /// Enumerator over all item definitions.
         /// Exposed for debugging display.
-        /// Ideally the dictionary would be exposed, but there are 
+        /// Ideally the dictionary would be exposed, but there are
         /// covariance problems. (A dictionary of Key, Value cannot be upcast
         /// to a Dictionary of Key, IValue).
         /// </summary>
@@ -186,7 +186,7 @@ IEnumerable<D> ItemDefinitionsEnumerable
         /// <summary>
         /// Enumerator over all items.
         /// Exposed for debugging display.
-        /// Ideally the dictionary would be exposed, but there are 
+        /// Ideally the dictionary would be exposed, but there are
         /// covariance problems. (A dictionary of Key, Value cannot be upcast
         /// to a Dictionary of Key, IValue).
         /// </summary>
@@ -238,7 +238,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Properties encountered during evaluation. These are read during the first evaluation pass.
         /// Unlike those returned by the Properties property, these are ordered, and include any properties that
-        /// were subsequently overridden by others with the same name. It does not include any 
+        /// were subsequently overridden by others with the same name. It does not include any
         /// properties whose conditions did not evaluate to true.
         /// </summary>
         void AddToAllEvaluatedPropertiesList(P property);
@@ -246,7 +246,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
         /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-        /// were subsequently overridden by others with the same name and item type. It does not include any 
+        /// were subsequently overridden by others with the same name and item type. It does not include any
         /// elements whose conditions did not evaluate to true.
         /// </summary>
         void AddToAllEvaluatedItemDefinitionMetadataList(M itemDefinitionMetadatum);
diff --git a/src/Build/Evaluation/IItemFactory.cs b/src/Build/Evaluation/IItemFactory.cs
index 2125968bf6c..9624d90a562 100644
--- a/src/Build/Evaluation/IItemFactory.cs
+++ b/src/Build/Evaluation/IItemFactory.cs
@@ -49,18 +49,18 @@ ProjectItemElement ItemElement
 
         /// <summary>
         /// Creates an item based off the provided item, with cloning semantics.
-        /// New item is associated with the passed in defining project, not that of the original item. 
+        /// New item is associated with the passed in defining project, not that of the original item.
         /// </summary>
         T CreateItem(S source, string definingProject);
 
         /// <summary>
         /// Creates an item with the specified include and the metadata from the specified base item
-        /// New item is associated with the passed in defining project, not that of the original item. 
+        /// New item is associated with the passed in defining project, not that of the original item.
         /// </summary>
         T CreateItem(string include, S baseItem, string definingProject);
 
         /// <summary>
-        /// Creates an item using the specified evaluated include, include before wildcard expansion, 
+        /// Creates an item using the specified evaluated include, include before wildcard expansion,
         /// and defining project.
         /// </summary>
         T CreateItem(string include, string includeBeforeWildcardExpansion, string definingProject);
@@ -68,6 +68,6 @@ ProjectItemElement ItemElement
         /// <summary>
         /// Applies the supplied metadata to the destination items.
         /// </summary>
-        void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<T> destinationItems);
+        void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<T> destinationItems);
     }
 }
diff --git a/src/Build/Evaluation/IItemProvider.cs b/src/Build/Evaluation/IItemProvider.cs
index e4b2766c861..a8c30d5c4ba 100644
--- a/src/Build/Evaluation/IItemProvider.cs
+++ b/src/Build/Evaluation/IItemProvider.cs
@@ -15,7 +15,7 @@ internal interface IItemProvider<T> where T : IItem
     {
         /// <summary>
         /// Returns a list of items with the specified item type.
-        /// 
+        ///
         /// If there are no items of this type, returns an empty list.
         /// </summary>
         /// <param name="itemType">The item type of items to return.</param>
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 3fff5c28e65..0f721647326 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -35,7 +35,7 @@ internal static class IntrinsicFunctions
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
 
-        private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => new NuGetFrameworkWrapper());
+        private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => NuGetFrameworkWrapper.CreateInstance());
 
         /// <summary>
         /// Add two doubles
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 6adca4bf208..9dfd281b165 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -104,7 +104,7 @@ protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Build
                             string[] includeSplitFilesEscaped;
                             if (MSBuildEventSource.Log.IsEnabled())
                             {
-                                MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                                MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory ?? string.Empty, glob, string.Join(", ", excludePatternsForGlobs));
                             }
 
                             using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
@@ -121,7 +121,7 @@ protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Build
 
                             if (MSBuildEventSource.Log.IsEnabled())
                             {
-                                MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                                MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory ?? string.Empty, glob, string.Join(", ", excludePatternsForGlobs));
                             }
 
                             foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs b/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
index 722d467c342..99c7166189b 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
@@ -75,7 +75,7 @@ public I CreateItem(string include, I baseItem, string definingProject)
                 return _wrappedItemFactory.CreateItem(include, baseItem, definingProject);
             }
 
-            public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<I> destinationItems)
+            public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<I> destinationItems)
             {
                 SetItemElement();
                 _wrappedItemFactory.SetMetadata(metadata, destinationItems);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 43fffb961a6..485162b1638 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -169,9 +169,9 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                     ////////////////////////////////////////////////////
                     // UNDONE: Implement batching here.
                     //
-                    // We want to allow built-in metadata in metadata values here. 
+                    // We want to allow built-in metadata in metadata values here.
                     // For example, so that an Idl file can specify that its Tlb output should be named %(Filename).tlb.
-                    // 
+                    //
                     // In other words, we want batching. However, we won't need to go to the trouble of using the regular batching code!
                     // That's because that code is all about grouping into buckets of similar items. In this context, we're not
                     // invoking a task, and it's fine to process each item individually, which will always give the correct results.
@@ -183,7 +183,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                     //    or whether they contain any custom metadata && the Include involved an @(itemlist) expression.
                     // -- if either case is found, we go ahead and evaluate all the metadata separately for each item.
                     // -- otherwise we can do the old thing (evaluating all metadata once then applying to all items)
-                    // 
+                    //
                     // This algorithm gives the correct results except when:
                     // -- batchable expressions exist on the include, exclude, or condition on the item element itself
                     //
@@ -230,7 +230,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                         _expander.Metadata = metadataTable;
 
                         // Also keep a list of everything so we can get the predecessor objects correct.
-                        List<Pair<ProjectMetadataElement, string>> metadataList = new(metadata.Length);
+                        List<KeyValuePair<ProjectMetadataElement, string>> metadataList = new(metadata.Length);
 
                         foreach (var metadataElement in metadata)
                         {
@@ -252,7 +252,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
-                            metadataList.Add(new Pair<ProjectMetadataElement, string>(metadataElement, evaluatedValue));
+                            metadataList.Add(new KeyValuePair<ProjectMetadataElement, string>(metadataElement, evaluatedValue));
                         }
 
                         // Apply those metadata to each item
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs b/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
index 180d4565c72..6c7aac4421c 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
@@ -16,7 +16,7 @@ internal sealed class EvaluationLocationTabSeparatedPrettyPrinter : EvaluationLo
     {
         private const string Separator = "\t";
 
-        /// <inheritdoc/> 
+        /// <inheritdoc/>
         internal override void AppendHeader(StringBuilder stringBuilder)
         {
             AppendDefaultHeaderWithSeparator(stringBuilder, Separator);
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
index dc1132049de..7753ae7e5a5 100644
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ b/src/Build/Evaluation/ProjectStringCache.cs
@@ -218,7 +218,7 @@ private void VerifyState()
                     uniqueEntries.Add(entry);
                     ErrorUtilities.VerifyThrow(entry.RefCount > 0, "extra deref");
 
-                    // We only ever create one StringCacheEntry instance per unique string, and that instance should be 
+                    // We only ever create one StringCacheEntry instance per unique string, and that instance should be
                     // the same in both collections.
                     ErrorUtilities.VerifyThrow(Object.ReferenceEquals(entry, _strings[entry.CachedString]), "bad state");
                 }
@@ -228,7 +228,7 @@ private void VerifyState()
         }
 
         /// <summary>
-        /// Handle event that is fired when an entry in the project root element cache is removed 
+        /// Handle event that is fired when an entry in the project root element cache is removed
         /// from its strong cache.
         /// </summary>
         /// <remarks>
diff --git a/src/Build/Evaluation/SemiColonTokenizer.cs b/src/Build/Evaluation/SemiColonTokenizer.cs
index 6d00f63dff7..7cc65cfb2d5 100644
--- a/src/Build/Evaluation/SemiColonTokenizer.cs
+++ b/src/Build/Evaluation/SemiColonTokenizer.cs
@@ -70,7 +70,7 @@ public bool MoveNext()
                 string segment;
 
                 // Walk along the string, keeping track of whether we are in an item list expression.
-                // If we hit a semi-colon or the end of the string and we aren't in an item list, 
+                // If we hit a semi-colon or the end of the string and we aren't in an item list,
                 // add the segment to the list.
                 for (; _index < _expression.Length; _index++)
                 {
diff --git a/src/Build/Evaluation/StringMetadataTable.cs b/src/Build/Evaluation/StringMetadataTable.cs
index 0b0dd6b4e45..5e920a99c23 100644
--- a/src/Build/Evaluation/StringMetadataTable.cs
+++ b/src/Build/Evaluation/StringMetadataTable.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Evaluation
     internal class StringMetadataTable : IMetadataTable
     {
         /// <summary>
-        /// Table of metadata values. 
+        /// Table of metadata values.
         /// Each key may be qualified ("itemtype.name") or unqualified ("name").
         /// Unqualified are considered to apply to all item types.
         /// May be null, if empty.
diff --git a/src/Build/Evaluation/ToolsetProvider.cs b/src/Build/Evaluation/ToolsetProvider.cs
index 01fa37d33e2..bf1b87243a5 100644
--- a/src/Build/Evaluation/ToolsetProvider.cs
+++ b/src/Build/Evaluation/ToolsetProvider.cs
@@ -57,7 +57,7 @@ private ToolsetProvider(ITranslator translator)
         /// Retrieves the toolsets.
         /// </summary>
         /// <comments>
-        /// ValueCollection is already read-only. 
+        /// ValueCollection is already read-only.
         /// </comments>
         public ICollection<Toolset> Toolsets => _toolsets.Values;
 
@@ -96,8 +96,8 @@ internal static ToolsetProvider FactoryForDeserialization(ITranslator translator
         #endregion
 
         /// <summary>
-        /// Populate Toolsets with a dictionary of (toolset version, Toolset) 
-        /// using information from the registry and config file, if any.  
+        /// Populate Toolsets with a dictionary of (toolset version, Toolset)
+        /// using information from the registry and config file, if any.
         /// </summary>
         private void InitializeToolsetCollection(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations toolsetDefinitionLocations)
         {
diff --git a/src/Build/FileAccess/DesiredAccess.cs b/src/Build/FileAccess/DesiredAccess.cs
new file mode 100644
index 00000000000..b9bdea98c0f
--- /dev/null
+++ b/src/Build/FileAccess/DesiredAccess.cs
@@ -0,0 +1,112 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.DesiredAccess.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// The requested access to the file or device.
+    /// </summary>
+    /// <remarks>
+    /// See https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants for a full list of values.
+    /// </remarks>
+    [Flags]
+    [CLSCompliant(false)]
+    public enum DesiredAccess : uint
+    {
+        /// <summary>
+        /// For a directory, the right to list the contents of the directory.
+        /// </summary>
+        FILE_LIST_DIRECTORY = 0x00000001,
+
+        /// <summary>
+        /// For a directory, the right to create a file in the directory.
+        /// </summary>
+        FILE_ADD_FILE = 0x00000002,
+
+        /// <summary>
+        /// For a directory, the right to create a subdirectory.
+        /// </summary>
+        FILE_ADD_SUBDIRECTORY = 0x00000004,
+
+        /// <summary>
+        /// The right to read extended file attributes.
+        /// </summary>
+        FILE_READ_EA = 0x00000008,
+
+        /// <summary>
+        /// Right to delete an object.
+        /// </summary>
+        DELETE = 0x00010000,
+
+        /// <summary>
+        /// Right to wait on a handle.
+        /// </summary>
+        SYNCHRONIZE = 0x00100000,
+
+        /// <summary>
+        /// For a file object, the right to append data to the file. (For local files, write operations will not overwrite existing
+        /// data if this flag is specified without <see cref="FILE_WRITE_DATA"/>.) For a directory object, the right to create a subdirectory
+        /// (<see cref="FILE_ADD_SUBDIRECTORY"/>).
+        /// </summary>
+        FILE_APPEND_DATA = 0x00000004,
+
+        /// <summary>
+        /// The right to write extended file attributes.
+        /// </summary>
+        FILE_WRITE_EA = 0x00000010,
+
+        /// <summary>
+        /// For a native code file, the right to execute the file. This access right given to scripts may cause the script to be executable, depending on the script interpreter.
+        /// </summary>
+        FILE_EXECUTE = 0x00000020,
+
+        /// <summary>
+        /// For a directory, the right to delete a directory and all the files it contains, including read-only files.
+        /// </summary>
+        FILE_DELETE_CHILD = 0x00000040,
+
+        /// <summary>
+        /// The right to read file attributes.
+        /// </summary>
+        FILE_READ_ATTRIBUTES = 0x00000080,
+
+        /// <summary>
+        /// The right to write file attributes.
+        /// </summary>
+        FILE_WRITE_ATTRIBUTES = 0x00000100,
+
+        /// <summary>
+        /// For a file object, the right to write data to the file. For a directory object, the right to create a file in the
+        /// directory (<see cref="FILE_ADD_FILE"/>).
+        /// </summary>
+        FILE_WRITE_DATA = 0x00000002,
+
+        /// <summary>
+        /// All possible access rights.
+        /// </summary>
+        GENERIC_ALL = 0x10000000,
+
+        /// <summary>
+        /// Execute access.
+        /// </summary>
+        GENERIC_EXECUTE = 0x20000000,
+
+        /// <summary>
+        /// Write access.
+        /// </summary>
+        GENERIC_WRITE = 0x40000000,
+
+        /// <summary>
+        /// Read access.
+        /// </summary>
+        GENERIC_READ = 0x80000000,
+    }
+}
diff --git a/src/Build/FileAccess/FileAccessData.cs b/src/Build/FileAccess/FileAccessData.cs
new file mode 100644
index 00000000000..64cd45a92d4
--- /dev/null
+++ b/src/Build/FileAccess/FileAccessData.cs
@@ -0,0 +1,125 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /// <summary>
+    /// File access data.
+    /// </summary>
+    [CLSCompliant(false)]
+    public struct FileAccessData
+        : ITranslatable
+    {
+        private ReportedFileOperation _operation;
+        private RequestedAccess _requestedAccess;
+        private uint _processId;
+        private uint _error;
+        private DesiredAccess _desiredAccess;
+        private FlagsAndAttributes _flagsAndAttributes;
+        private string _path;
+        private string? _processArgs;
+        private bool _isAnAugmentedFileAccess;
+
+        public FileAccessData(
+            ReportedFileOperation operation,
+            RequestedAccess requestedAccess,
+            uint processId,
+            uint error,
+            DesiredAccess desiredAccess,
+            FlagsAndAttributes flagsAndAttributes,
+            string path,
+            string? processArgs,
+            bool isAnAugmentedFileAccess)
+        {
+            _operation = operation;
+            _requestedAccess = requestedAccess;
+            _processId = processId;
+            _error = error;
+            _desiredAccess = desiredAccess;
+            _flagsAndAttributes = flagsAndAttributes;
+            _path = path;
+            _processArgs = processArgs;
+            _isAnAugmentedFileAccess = isAnAugmentedFileAccess;
+        }
+
+        /// <summary>The operation that performed the file access.</summary>
+        public ReportedFileOperation Operation
+        {
+            readonly get => _operation;
+            private set => _operation = value;
+        }
+
+        /// <summary>The requested access.</summary>
+        public RequestedAccess RequestedAccess
+        {
+            get => _requestedAccess;
+            private set => _requestedAccess = value;
+        }
+
+        /// <summary>The process id.</summary>
+        public uint ProcessId
+        {
+            readonly get => _processId;
+            private set => _processId = value;
+        }
+
+        /// <summary>The error code of the operation.</summary>
+        public uint Error
+        {
+            readonly get => _error;
+            private set => _error = value;
+        }
+
+        /// <summary>The desired access.</summary>
+        public DesiredAccess DesiredAccess
+        {
+            readonly get => _desiredAccess;
+            private set => _desiredAccess = value;
+        }
+
+        /// <summary>The file flags and attributes.</summary>
+        public FlagsAndAttributes FlagsAndAttributes
+        {
+            readonly get => _flagsAndAttributes;
+            private set => _flagsAndAttributes = value;
+        }
+
+        /// <summary>The path being accessed.</summary>
+        public string Path
+        {
+            readonly get => _path;
+            private set => _path = value;
+        }
+
+        /// <summary>The process arguments.</summary>
+        public string? ProcessArgs
+        {
+            readonly get => _processArgs;
+            private set => _processArgs = value;
+        }
+
+        /// <summary>Whether the file access is augmented.</summary>
+        public bool IsAnAugmentedFileAccess
+        {
+            readonly get => _isAnAugmentedFileAccess;
+            private set => _isAnAugmentedFileAccess = value;
+        }
+
+        void ITranslatable.Translate(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _operation, (int)_operation);
+            translator.TranslateEnum(ref _requestedAccess, (int)_requestedAccess);
+            translator.Translate(ref _processId);
+            translator.Translate(ref _error);
+            translator.TranslateEnum(ref _desiredAccess, (int)_desiredAccess);
+            translator.TranslateEnum(ref _flagsAndAttributes, (int)_flagsAndAttributes);
+            translator.Translate(ref _path);
+            translator.Translate(ref _processArgs);
+            translator.Translate(ref _isAnAugmentedFileAccess);
+        }
+    }
+}
diff --git a/src/Build/FileAccess/FlagsAndAttributes.cs b/src/Build/FileAccess/FlagsAndAttributes.cs
new file mode 100644
index 00000000000..c02ca45a969
--- /dev/null
+++ b/src/Build/FileAccess/FlagsAndAttributes.cs
@@ -0,0 +1,185 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.FlagsAndAttributes.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// The file or device attributes and flags.
+    /// </summary>
+    [Flags]
+    [CLSCompliant(false)]
+    public enum FlagsAndAttributes : uint
+    {
+        /// <summary>
+        /// The file is read only. Applications can read the file but cannot write to or delete it.
+        /// </summary>
+        FILE_ATTRIBUTE_READONLY = 0x00000001,
+
+        /// <summary>
+        /// The file is hidden. Do not include it in an ordinary directory listing.
+        /// </summary>
+        FILE_ATTRIBUTE_HIDDEN = 0x00000002,
+
+        /// <summary>
+        /// The file is part of or used exclusively by an operating system.
+        /// </summary>
+        FILE_ATTRIBUTE_SYSTEM = 0x00000004,
+
+        /// <summary>
+        /// The path is a directory.
+        /// </summary>
+        FILE_ATTRIBUTE_DIRECTORY = 0x00000010,
+
+        /// <summary>
+        /// The file should be archived. Applications use this attribute to mark files for backup or removal.
+        /// </summary>
+        FILE_ATTRIBUTE_ARCHIVE = 0x00000020,
+
+        /// <summary>
+        /// The file does not have other attributes set. This attribute is valid only if used alone.
+        /// </summary>
+        FILE_ATTRIBUTE_NORMAL = 0x00000080,
+
+        /// <summary>
+        /// The file is being used for temporary storage.
+        /// </summary>
+        /// <remarks>
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_ATTRIBUTE_TEMPORARY = 0x00000100,
+
+        /// <summary>
+        /// The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline
+        /// storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should
+        /// not arbitrarily change this attribute.
+        /// </summary>
+        FILE_ATTRIBUTE_OFFLINE = 0x00001000,
+
+        /// <summary>
+        /// The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory,
+        /// this means that encryption is the default for newly created files and subdirectories. For more information, see File
+        /// Encryption.
+        /// </summary>
+        /// <remarks>
+        /// This flag has no effect if <see cref="FILE_ATTRIBUTE_SYSTEM"/> is also specified.
+        /// This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
+        /// </remarks>
+        FILE_ATTRIBUTE_ENCRYPED = 0x00004000,
+
+        /// <summary>
+        /// The file data is requested, but it should continue to be located in remote storage. It should not be transported back
+        /// to local storage. This flag is for use by remote storage systems.
+        /// </summary>
+        FILE_FLAG_OPEN_NO_RECALL = 0x00100000,
+
+        /// <summary>
+        /// Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file is
+        /// opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
+        /// </summary>
+        /// <remarks>
+        /// This flag cannot be used with the CREATE_ALWAYS flag.
+        /// If the file is not a reparse point, then this flag is ignored.
+        /// For more information, see the Remarks section.
+        /// </remarks>
+        FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000,
+
+        /// <summary>
+        /// The file or device is being opened with session awareness. If this flag is not specified, then per-session devices
+        /// (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no effect for
+        /// callers not in session 0. This flag is supported only on server editions of Windows.
+        /// </summary>
+        /// <remarks>
+        /// Windows Server 2008 R2, Windows Server 2008, and Windows Server 2003: This flag is not supported before Windows Server
+        /// 2012.
+        /// </remarks>
+        FILE_FLAG_SESSION_AWARE = 0x00800000,
+
+        /// <summary>
+        /// Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case,
+        /// for file systems that support that naming. Use care when using this option, because files created with this flag may
+        /// not be accessible by applications that are written for MS-DOS or 16-bit Windows.
+        /// </summary>
+        FILE_FLAG_POSIX_SEMANTICS = 0x01000000,
+
+        /// <summary>
+        /// The file is being opened or created for a backup or restore operation. The system ensures that the calling process
+        /// overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
+        /// information, see Changing Privileges in a Token.
+        /// </summary>
+        /// <remarks>
+        /// You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of
+        /// a file handle. For more information, see the Remarks section.
+        /// </remarks>
+        FILE_FLAG_BACKUP_SEMANTICS = 0x02000000,
+
+        /// <summary>
+        /// The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any
+        /// other open or duplicated handles.
+        /// </summary>
+        /// <remarks>
+        /// If there are existing open handles to a file, the call fails unless they were all opened with the FILE_SHARE_DELETE
+        /// share mode.
+        /// Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified.
+        /// </remarks>
+        FILE_FLAG_DELETE_ON_CLOSE = 0x04000000,
+
+        /// <summary>
+        /// Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.
+        /// </summary>
+        /// <remarks>
+        /// This flag should not be used if read-behind (that is, reverse scans) will be used.
+        /// This flag has no effect if the file system does not support cached I/O and <see cref="FILE_FLAG_NO_BUFFERING"/> .
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000,
+
+        /// <summary>
+        /// Access is intended to be random. The system can use this as a hint to optimize file caching.
+        /// </summary>
+        /// <remarks>
+        /// This flag has no effect if the file system does not support cached I/O and <see cref="FILE_FLAG_NO_BUFFERING"/>.
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_RANDOM_ACCESS = 0x10000000,
+
+        /// <summary>
+        /// The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard
+        /// disk caching or memory mapped files.
+        /// </summary>
+        /// <remarks>
+        /// There are strict requirements for successfully working with files opened with CreateFile using this
+        /// flag; for details, see File Buffering.
+        /// </remarks>
+        FILE_FLAG_NO_BUFFERING = 0x20000000,
+
+        /// <summary>
+        /// The file or device is being opened or created for asynchronous I/O.
+        /// </summary>
+        /// <remarks>
+        /// When subsequent I/O operations are completed on this handle, the event specified in the OVERLAPPED structure will be
+        /// set to the signaled state.
+        /// If this flag is specified, the file can be used for simultaneous read and write operations.
+        /// If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions
+        /// specify an OVERLAPPED structure.
+        /// For information about considerations when using a file handle created with this flag, see the Synchronous and
+        /// Asynchronous I/O Handles section of this topic.
+        /// </remarks>
+        FILE_FLAG_OVERLAPPED = 0x40000000,
+
+        /// <summary>
+        /// Write operations will not go through any intermediate cache; they will go directly to disk.
+        /// </summary>
+        /// <remarks>
+        /// For additional information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_WRITE_THROUGH = 0x80000000,
+    }
+}
diff --git a/src/Build/FileAccess/ProcessData.cs b/src/Build/FileAccess/ProcessData.cs
new file mode 100644
index 00000000000..aa274054545
--- /dev/null
+++ b/src/Build/FileAccess/ProcessData.cs
@@ -0,0 +1,85 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /// <summary>
+    /// Process data.
+    /// </summary>
+    [CLSCompliant(false)]
+    public struct ProcessData : ITranslatable
+    {
+        private string _processName;
+        private uint _processId;
+        private uint _parentProcessId;
+        private DateTime _creationDateTime;
+        private DateTime _exitDateTime;
+        private uint _exitCode;
+
+        public ProcessData(string processName, uint processId, uint parentProcessId, DateTime creationDateTime, DateTime exitDateTime, uint exitCode)
+        {
+            _processName = processName;
+            _processId = processId;
+            _parentProcessId = parentProcessId;
+            _creationDateTime = creationDateTime;
+            _exitDateTime = exitDateTime;
+            _exitCode = exitCode;
+        }
+
+        /// <summary>The process name.</summary>
+        public string ProcessName
+        {
+            get => _processName;
+            private set => _processName = value;
+        }
+
+        /// <summary>The process id.</summary>
+        public uint ProcessId
+        {
+            get => _processId;
+            private set => _processId = value;
+        }
+
+        /// <summary>The parent process id.</summary>
+        public uint ParentProcessId
+        {
+            get => _parentProcessId;
+            private set => _parentProcessId = value;
+        }
+
+        /// <summary>The creation date time.</summary>
+        public DateTime CreationDateTime
+        {
+            get => _creationDateTime;
+            private set => _creationDateTime = value;
+        }
+
+        /// <summary>The exit date time.</summary>
+        public DateTime ExitDateTime
+        {
+            get => _exitDateTime;
+            private set => _exitDateTime = value;
+        }
+
+        /// <summary>The exit code.</summary>
+        public uint ExitCode
+        {
+            get => _exitCode;
+            private set => _exitCode = value;
+        }
+
+        void ITranslatable.Translate(ITranslator translator)
+        {
+            translator.Translate(ref _processName);
+            translator.Translate(ref _processId);
+            translator.Translate(ref _parentProcessId);
+            translator.Translate(ref _creationDateTime);
+            translator.Translate(ref _exitDateTime);
+            translator.Translate(ref _exitCode);
+        }
+    }
+}
diff --git a/src/Build/FileAccess/ReportedFileOperation.cs b/src/Build/FileAccess/ReportedFileOperation.cs
new file mode 100644
index 00000000000..c3b846cedde
--- /dev/null
+++ b/src/Build/FileAccess/ReportedFileOperation.cs
@@ -0,0 +1,263 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.ReportedFileOperation.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// Which operation resulted in a reported file access.
+    /// </summary>
+    public enum ReportedFileOperation : byte
+    {
+        /// <summary>
+        /// Unknown operation.
+        /// </summary>
+        Unknown = 0,
+
+        /// <summary>
+        /// CreateFile.
+        /// </summary>
+        CreateFile,
+
+        /// <summary>
+        /// CreateProcess.
+        /// </summary>
+        CreateProcess,
+
+        /// <summary>
+        /// GetFileAttributes.
+        /// </summary>
+        GetFileAttributes,
+
+        /// <summary>
+        /// GetFileAttributesEx.
+        /// </summary>
+        GetFileAttributesEx,
+
+        /// <summary>
+        /// Process forked.
+        /// </summary>
+        Process,
+
+        /// <summary>
+        /// FindFirstFileEx.
+        /// </summary>
+        /// <remarks>
+        /// FindFirstFile also indicates this op, since we implement it in terms of FindFirstFileEx.
+        /// </remarks>
+        FindFirstFileEx,
+
+        /// <summary>
+        /// FindNextFile.
+        /// </summary>
+        FindNextFile,
+
+        /// <summary>
+        /// CreateDirectory.
+        /// </summary>
+        CreateDirectory,
+
+        /// <summary>
+        /// DeleteFile.
+        /// </summary>
+        DeleteFile,
+
+        /// <summary>
+        /// MoveFile (source; read and deleted).
+        /// </summary>
+        MoveFileSource,
+
+        /// <summary>
+        /// MoveFile (destination; written).
+        /// </summary>
+        MoveFileDestination,
+
+        /// <summary>
+        /// SetFileInformationByHandleSource (source; read and deleted).
+        /// </summary>
+        SetFileInformationByHandleSource,
+
+        /// <summary>
+        /// SetFileInformationByHandleDest (destination; written).
+        /// </summary>
+        SetFileInformationByHandleDest,
+
+        /// <summary>
+        /// ZwSetRenameInformationFileSource (source; read and deleted).
+        /// </summary>
+        ZwSetRenameInformationFileSource,
+
+        /// <summary>
+        /// ZwSetRenameInformationFileDest (destination; written).
+        /// </summary>
+        ZwSetRenameInformationFileDest,
+
+        /// <summary>
+        /// ZwSetLinkInformationFileDest.
+        /// </summary>
+        ZwSetLinkInformationFile,
+
+        /// <summary>
+        /// ZwSetDispositionInformationFile (delete-on-close; deleted).
+        /// </summary>
+        ZwSetDispositionInformationFile,
+
+        /// <summary>
+        /// ZwSetModeInformationFile (delete-on-close; deleted).
+        /// </summary>
+        ZwSetModeInformationFile,
+
+        /// <summary>
+        /// ZwSetFileNameInformationFile (source; read and written).
+        /// </summary>
+        ZwSetFileNameInformationFileSource,
+
+        /// <summary>
+        /// ZwSetFileNameInformationFile (destination; written).
+        /// </summary>
+        ZwSetFileNameInformationFileDest,
+
+        /// <summary>
+        /// CopyFile (source; read).
+        /// </summary>
+        CopyFileSource,
+
+        /// <summary>
+        /// CopyFile (destination; written).
+        /// </summary>
+        CopyFileDestination,
+
+        /// <summary>
+        /// CreateHardLink (source; read).
+        /// </summary>
+        CreateHardLinkSource,
+
+        /// <summary>
+        /// CreateHardLink (destination; written).
+        /// </summary>
+        CreateHardLinkDestination,
+
+        /// <summary>
+        /// RemoveDirectory.
+        /// </summary>
+        RemoveDirectory,
+
+        /// <summary>
+        /// RemoveDirectory (source; written).
+        /// </summary>
+        RemoveDirectorySource,
+
+        /// <summary>
+        /// NtQueryDirectoryFile.
+        /// </summary>
+        NtQueryDirectoryFile,
+
+        /// <summary>
+        /// ZwQueryDirectoryFile.
+        /// </summary>
+        ZwQueryDirectoryFile,
+
+        /// <summary>
+        /// NtCreateFile.
+        /// </summary>
+        NtCreateFile,
+
+        /// <summary>
+        /// ZwCreateFile.
+        /// </summary>
+        ZwCreateFile,
+
+        /// <summary>
+        /// ZwOpenFile.
+        /// </summary>
+        ZwOpenFile,
+
+        /// <summary>
+        /// This is a quasi operation. We issue this
+        /// report when Detours is changing file open
+        /// request with Read/Write access to Read access only.
+        /// </summary>
+        ChangedReadWriteToReadAccess,
+
+        /// <summary>
+        /// This is a quasi operation. The sandbox issues this only when FileAccessPolicy.OverrideAllowWriteForExistingFiles is set, representing
+        /// that an allow for write check was performed for a given path for the first time (in the scope of a process, another process in the same process
+        /// tree may also report this for the same path).
+        /// </summary>
+        FirstAllowWriteCheckInProcess,
+
+        /// <summary>
+        /// This operation used to indicate to the engine by the Linux sandbox that a process being executed statically links libc
+        /// and may have missing file observations.
+        /// </summary>
+        StaticallyLinkedProcess,
+
+        /// <summary>
+        /// Access of reparse point target.
+        /// </summary>
+        ReparsePointTarget,
+
+        /// <summary>
+        /// Access of reparse point target, cached by Detours.
+        /// </summary>
+        ReparsePointTargetCached,
+
+        /// <summary>
+        /// Access checks for source of CreateSymbolicLink API.
+        /// </summary>
+        CreateSymbolicLinkSource,
+
+        /// <summary>
+        /// Access check for MoveFileWithgProgress source target.
+        /// </summary>
+        MoveFileWithProgressSource,
+
+        /// <summary>
+        /// Access check for MoveFileWithProgress dest target.
+        /// </summary>
+        MoveFileWithProgressDest,
+
+        /// <summary>
+        /// Multiple operations lumped into one.
+        /// </summary>
+        MultipleOperations,
+
+        /// <summary>
+        /// Process exited.
+        /// </summary>
+        ProcessExit,
+
+        #region Operation Names Reported by BuildXLSandbox (macOS sandbox implementation)
+        MacLookup,
+        MacReadlink,
+        MacVNodeCreate,
+        KAuthMoveSource,
+        KAuthMoveDest,
+        KAuthCreateHardlinkSource,
+        KAuthCreateHardlinkDest,
+        KAuthCopySource,
+        KAuthCopyDest,
+        KAuthDeleteDir,
+        KAuthDeleteFile,
+        KAuthOpenDir,
+        KAuthReadFile,
+        KAuthCreateDir,
+        KAuthWriteFile,
+        KAuthClose,
+        KAuthCloseModified,
+        KAuthGetAttributes,
+        KAuthVNodeExecute,
+        KAuthVNodeWrite,
+        KAuthVNodeRead,
+        KAuthVNodeProbe,
+        MacVNodeWrite,
+        MacVNodeCloneSource,
+        MacVNodeCloneDest,
+        #endregion
+    }
+}
diff --git a/src/Build/FileAccess/RequestedAccess.cs b/src/Build/FileAccess/RequestedAccess.cs
new file mode 100644
index 00000000000..e0e83f176ed
--- /dev/null
+++ b/src/Build/FileAccess/RequestedAccess.cs
@@ -0,0 +1,60 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.RequestedAccess.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// Level of access requested by a reported file operation.
+    /// </summary>
+    [Flags]
+    public enum RequestedAccess : byte
+    {
+        /// <summary>
+        /// No access requested.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// Read access requested.
+        /// </summary>
+        Read = 1,
+
+        /// <summary>
+        /// Write access requested.
+        /// </summary>
+        Write = 2,
+
+        /// <summary>
+        /// Metadata-only probe access requested (e.g. <see cref="ReportedFileOperation.GetFileAttributes"/>).
+        /// </summary>
+        Probe = 4,
+
+        /// <summary>
+        /// Directory enumeration access requested (on the directory itself; immediate children will be enumerated).
+        /// </summary>
+        Enumerate = 8,
+
+        /// <summary>
+        /// Metadata-only probe access requested; probed as part of a directory enumeration (e.g. <see cref="ReportedFileOperation.FindNextFile"/>).
+        /// </summary>
+        EnumerationProbe = 16,
+
+        /// <summary>
+        /// Both read and write access requested.
+        /// </summary>
+        ReadWrite = Read | Write,
+
+        /// <summary>
+        /// All defined access levels requested.
+        /// </summary>
+        All = Read | Write | Probe | Enumerate | EnumerationProbe,
+    }
+}
diff --git a/src/Build/Globbing/IMSBuildGlob.cs b/src/Build/Globbing/IMSBuildGlob.cs
index a101b9541de..115e71bf1c2 100644
--- a/src/Build/Globbing/IMSBuildGlob.cs
+++ b/src/Build/Globbing/IMSBuildGlob.cs
@@ -16,7 +16,7 @@ public interface IMSBuildGlob
         ///     - slashes are normalized
         ///     - arguments representing relative paths are normalized against the glob's root.
         ///     For example, the glob **/*.cs does not match ../a.cs, since ../a.cs points outside of the glob root.
-        /// 
+        ///
         ///     Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters.
         /// </summary>
         /// <param name="stringToMatch">The string to match. If the string represents a relative path, it will get normalized against the glob's root. Cannot be null.</param>
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index a92da0f73f9..e343a98c4cc 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -48,6 +48,7 @@ internal class GraphBuilder
 
         private readonly ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory;
         private IReadOnlyDictionary<string, IReadOnlyCollection<string>> _solutionDependencies;
+        private ConcurrentDictionary<ConfigurationMetadata, Lazy<ProjectInstance>> _platformNegotiationInstancesCache = new();
 
         public GraphBuilder(
             IEnumerable<ProjectGraphEntryPoint> entryPoints,
@@ -92,6 +93,9 @@ public void BuildGraph()
 
             RootNodes = GetGraphRoots(EntryPointNodes);
             ProjectNodes = allParsedProjects.Values.Select(p => p.GraphNode).ToList();
+
+            // Clean and release some temporary used large memory objects.
+            _platformNegotiationInstancesCache.Clear();
         }
 
         private static IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection<ProjectGraphNode> entryPointNodes)
@@ -277,8 +281,6 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                         string.Join(";", solution.SolutionParserErrorCodes)));
             }
 
-            IReadOnlyCollection<ProjectInSolution> projectsInSolution = GetBuildableProjects(solution);
-
             // Mimic behavior of SolutionProjectGenerator
             SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionEntryPoint.GlobalProperties);
             solutionGlobalPropertiesBuilder["Configuration"] = currentSolutionConfiguration.ConfigurationName;
@@ -303,40 +305,71 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
             // Project configurations are reused heavily, so cache the global properties for each
             Dictionary<string, ImmutableDictionary<string, string>> globalPropertiesForProjectConfiguration = new(StringComparer.OrdinalIgnoreCase);
 
-            var newEntryPoints = new List<ProjectGraphEntryPoint>(projectsInSolution.Count);
+            IReadOnlyList<ProjectInSolution> projectsInSolution = solution.ProjectsInOrder;
+            List<ProjectGraphEntryPoint> newEntryPoints = new(projectsInSolution.Count);
+            Dictionary<string, IReadOnlyCollection<string>> solutionDependencies = new();
 
             foreach (ProjectInSolution project in projectsInSolution)
             {
-                if (project.ProjectConfigurations.Count == 0)
+                if (!SolutionFile.IsBuildableProject(project))
                 {
                     continue;
                 }
 
                 ProjectConfigurationInSolution projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
 
-                if (projectConfiguration.IncludeInBuild)
+                if (!SolutionProjectGenerator.WouldProjectBuild(solution, currentSolutionConfiguration.FullName, project, projectConfiguration))
+                {
+                    continue;
+                }
+
+                if (!globalPropertiesForProjectConfiguration.TryGetValue(projectConfiguration.FullName, out ImmutableDictionary<string, string> projectGlobalProperties))
+                {
+                    solutionGlobalPropertiesBuilder["Configuration"] = projectConfiguration.ConfigurationName;
+                    solutionGlobalPropertiesBuilder["Platform"] = projectConfiguration.PlatformName;
+
+                    projectGlobalProperties = solutionGlobalPropertiesBuilder.ToImmutable();
+                    globalPropertiesForProjectConfiguration.Add(projectConfiguration.FullName, projectGlobalProperties);
+                }
+
+                newEntryPoints.Add(new ProjectGraphEntryPoint(project.AbsolutePath, projectGlobalProperties));
+
+                if (project.Dependencies.Count > 0)
                 {
-                    if (!globalPropertiesForProjectConfiguration.TryGetValue(projectConfiguration.FullName, out ImmutableDictionary<string, string> projectGlobalProperties))
+                    // code snippet cloned from SolutionProjectGenerator.GetSolutionConfiguration
+
+                    List<string> solutionDependenciesForProject = new(project.Dependencies.Count);
+                    foreach (string dependencyProjectGuid in project.Dependencies)
                     {
-                        solutionGlobalPropertiesBuilder["Configuration"] = projectConfiguration.ConfigurationName;
-                        solutionGlobalPropertiesBuilder["Platform"] = projectConfiguration.PlatformName;
+                        if (!solution.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
+                        {
+                            ProjectFileErrorUtilities.ThrowInvalidProjectFile(
+                                "SubCategoryForSolutionParsingErrors",
+                                new BuildEventFileInfo(solution.FullPath),
+                                "SolutionParseProjectDepNotFoundError",
+                                project.ProjectGuid,
+                                dependencyProjectGuid);
+                        }
 
-                        projectGlobalProperties = solutionGlobalPropertiesBuilder.ToImmutable();
-                        globalPropertiesForProjectConfiguration.Add(projectConfiguration.FullName, projectGlobalProperties);
+                        // Add it to the list of dependencies, but only if it should build in this solution configuration
+                        // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
+                        // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise
+                        if (dependencyProject.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat)
+                        {
+                            solutionDependenciesForProject.Add(dependencyProject.AbsolutePath);
+                        }
                     }
 
-                    newEntryPoints.Add(new ProjectGraphEntryPoint(project.AbsolutePath, projectGlobalProperties));
+                    if (solutionDependenciesForProject.Count > 0)
+                    {
+                        solutionDependencies.Add(project.AbsolutePath, solutionDependenciesForProject);
+                    }
                 }
             }
 
             newEntryPoints.TrimExcess();
 
-            return (newEntryPoints, GetSolutionDependencies(solution));
-
-            IReadOnlyCollection<ProjectInSolution> GetBuildableProjects(SolutionFile solutionFile)
-            {
-                return solutionFile.ProjectsInOrder.Where(p => p.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat && solutionFile.ProjectShouldBuild(p.RelativePath)).ToImmutableArray();
-            }
+            return (newEntryPoints, solutionDependencies);
 
             SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
             {
@@ -367,43 +400,6 @@ ProjectConfigurationInSolution SelectProjectConfiguration(
                 var partiallyMarchedConfig = projectConfigs.FirstOrDefault(pc => pc.Value.ConfigurationName.Equals(solutionConfig.ConfigurationName, StringComparison.OrdinalIgnoreCase)).Value;
                 return partiallyMarchedConfig ?? projectConfigs.First().Value;
             }
-
-            IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies(SolutionFile solutionFile)
-            {
-                var solutionDependencies = new Dictionary<string, IReadOnlyCollection<string>>();
-
-                foreach (var projectWithDependencies in solutionFile.ProjectsInOrder.Where(p => p.Dependencies.Count != 0))
-                {
-                    solutionDependencies[projectWithDependencies.AbsolutePath] = projectWithDependencies.Dependencies.Select(
-                        dependencyGuid =>
-                        {
-                            // code snippet cloned from SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration
-
-                            if (!solutionFile.ProjectsByGuid.TryGetValue(dependencyGuid, out var dependencyProject))
-                            {
-                                // If it's not itself part of the solution, that's an invalid solution
-                                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                                    dependencyProject != null,
-                                    "SubCategoryForSolutionParsingErrors",
-                                    new BuildEventFileInfo(solutionFile.FullPath),
-                                    "SolutionParseProjectDepNotFoundError",
-                                    projectWithDependencies.ProjectGuid,
-                                    dependencyGuid);
-                            }
-
-                            // Add it to the list of dependencies, but only if it should build in this solution configuration 
-                            // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
-                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise 
-                            return dependencyProject?.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat
-                                ? dependencyProject.AbsolutePath
-                                : null;
-                        })
-                        .Where(p => p != null)
-                        .ToArray();
-                }
-
-                return solutionDependencies;
-            }
         }
 
         private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)
@@ -487,7 +483,7 @@ private void DetectCycles(
                             }
 
                             // the project being evaluated has a circular dependency involving multiple projects
-                            // add this project to the list of projects involved in cycle 
+                            // add this project to the list of projects involved in cycle
                             var projectsInCycle = new List<string> { referenceNode.ProjectInstance.FullPath };
                             return (false, projectsInCycle);
                         }
@@ -576,7 +572,7 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
         {
             var referenceInfos = new List<ProjectInterpretation.ReferenceInfo>();
 
-            foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, _projectInstanceFactory))
+            foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, GetInstanceForPlatformNegotiationWithCaching))
             {
                 if (FileUtilities.IsSolutionFilename(referenceInfo.ReferenceConfiguration.ProjectFullPath))
                 {
@@ -594,6 +590,16 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
             return referenceInfos;
         }
 
+        private ProjectInstance GetInstanceForPlatformNegotiationWithCaching(
+            string projectPath,
+            Dictionary<string, string> globalProperties,
+            ProjectCollection projectCollection)
+        {
+            return _platformNegotiationInstancesCache.GetOrAdd(
+                new ConfigurationMetadata(projectPath, CreatePropertyDictionary(globalProperties)),
+                new Lazy<ProjectInstance>(() => _projectInstanceFactory(projectPath, globalProperties, projectCollection))).Value;
+        }
+
         internal static string FormatCircularDependencyError(List<string> projectsInCycle)
         {
             var errorMessage = new StringBuilder(projectsInCycle.Select(p => p.Length).Sum());
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index c636ae81b41..0be0eeee71e 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -498,7 +498,7 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// </summary>
         internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ILoggingService loggingService, int visualStudioVersionFromSolution, ProjectCollection projectCollection, ISdkResolverService sdkResolverService, int submissionId)
         {
-            BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            BuildEventContext buildEventContext = new BuildEventContext(submissionId, 0, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
             Initialize(xml, globalProperties, toolsVersion, null, visualStudioVersionFromSolution, new BuildParameters(projectCollection), loggingService, buildEventContext, sdkResolverService, submissionId);
         }
 
@@ -1982,7 +1982,7 @@ public ProjectRootElement ToProjectRootElement()
             rootElement.DefaultTargets = String.Join(";", DefaultTargets);
             rootElement.ToolsVersion = ToolsVersion;
 
-            // Add all of the item definitions.            
+            // Add all of the item definitions.
             ProjectItemDefinitionGroupElement itemDefinitionGroupElement = rootElement.AddItemDefinitionGroup();
             foreach (ProjectItemDefinitionInstance itemDefinitionInstance in _itemDefinitions.Values)
             {
@@ -2253,7 +2253,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(
             }
 
             // If a ToolsVersion has been passed in using the /tv:xx switch, we want to generate an
-            // old-style solution wrapper project if it's < 4.0, to work around ordering issues.  
+            // old-style solution wrapper project if it's < 4.0, to work around ordering issues.
             if (toolsVersion != null)
             {
                 if (
@@ -2261,7 +2261,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(
                        String.Equals(toolsVersion, "3.0", StringComparison.OrdinalIgnoreCase) ||
                        String.Equals(toolsVersion, "3.5", StringComparison.OrdinalIgnoreCase))
                 {
-                    // Spawn the Orcas SolutionWrapperProject generator.  
+                    // Spawn the Orcas SolutionWrapperProject generator.
                     loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedExplicitToolsVersion", toolsVersion);
                     projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
                 }
@@ -2272,7 +2272,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(
             }
 
             // If the user didn't pass in a ToolsVersion, still try to make a best-effort guess as to whether
-            // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution. 
+            // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution.
             else
             {
                 string solutionFile = projectFile;
@@ -2282,9 +2282,9 @@ internal static ProjectInstance[] LoadSolutionForBuild(
                 }
                 SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
 
-                // If we get to this point, it's because it's a valid version.  Map the solution version 
-                // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old 
-                // engine to generate the solution wrapper.  
+                // If we get to this point, it's because it's a valid version.  Map the solution version
+                // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old
+                // engine to generate the solution wrapper.
                 if (solutionVersion <= 9) /* Whidbey or before */
                 {
                     loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "2.0", solutionVersion);
@@ -2600,7 +2600,7 @@ private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(
             int submissionId)
         {
             // Pass the toolsVersion of this project through, which will never be null -- either we passed the /tv:nn
-            // switch straight through, or we fabricated a ToolsVersion based on the solution version.  
+            // switch straight through, or we fabricated a ToolsVersion based on the solution version.
             // It's needed to determine which <UsingTask> tags to put in, whether to put a ToolsVersion parameter
             // on the <MSBuild> task tags, and what MSBuildToolsPath to use when scanning child projects
             // for dependency information.
@@ -2771,7 +2771,7 @@ private void Initialize(
                 this.SubToolsetVersion = this.Toolset.GenerateSubToolsetVersionUsingVisualStudioVersion(globalProperties, visualStudioVersionFromSolution);
             }
 
-            // Create a task registry which will fall back on the toolset task registry if necessary.          
+            // Create a task registry which will fall back on the toolset task registry if necessary.
             this.TaskRegistry = new TaskRegistry(this.Toolset, ProjectRootElementCache);
 
             if (globalProperties != null)
@@ -2780,9 +2780,9 @@ private void Initialize(
                 {
                     if (String.Equals(globalProperty.Key, Constants.SubToolsetVersionPropertyName, StringComparison.OrdinalIgnoreCase) && explicitSubToolsetVersion != null)
                     {
-                        // if we have a sub-toolset version explicitly provided by the ProjectInstance constructor, AND a sub-toolset version provided as a global property, 
-                        // make sure that the one passed in with the constructor wins.  If there isn't a matching global property, the sub-toolset version will be set at 
-                        // a later point. 
+                        // if we have a sub-toolset version explicitly provided by the ProjectInstance constructor, AND a sub-toolset version provided as a global property,
+                        // make sure that the one passed in with the constructor wins.  If there isn't a matching global property, the sub-toolset version will be set at
+                        // a later point.
                         _globalProperties.Set(ProjectPropertyInstance.Create(globalProperty.Key, explicitSubToolsetVersion, false /* may not be reserved */, _isImmutable));
                     }
                     else
@@ -2996,7 +2996,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
 
             foreach (ProjectProperty property in properties)
             {
-                // Allow reserved property names, since this is how they are added to the project instance. 
+                // Allow reserved property names, since this is how they are added to the project instance.
                 // The caller has prevented users setting them themselves.
                 ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
                 _properties.Set(instance);
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 4db93ab3bb0..cf6fc186770 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -2007,7 +2007,7 @@ public ProjectItemInstance CreateItem(string evaluatedInclude, string evaluatedI
                 /// <summary>
                 /// Applies the supplied metadata to the destination item.
                 /// </summary>
-                public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadataList, IEnumerable<ProjectItemInstance> destinationItems)
+                public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadataList, IEnumerable<ProjectItemInstance> destinationItems)
                 {
                     // Set up a single dictionary that can be applied to all the items
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
@@ -2172,7 +2172,7 @@ public TaskItem CreateItem(string includeEscaped, string includeBeforeWildcardEx
                 /// <summary>
                 /// Applies the supplied metadata to the destination item.
                 /// </summary>
-                public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<TaskItem> destinationItems)
+                public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<TaskItem> destinationItems)
                 {
                     // Not difficult to implement, but we do not expect to go here.
                     ErrorUtilities.ThrowInternalErrorUnreachable();
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index dc807f89574..9726d2de0d2 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -99,7 +99,7 @@ private ProjectMetadataInstance(ITranslator translator)
         /// Name of the metadata
         /// </summary>
         /// <remarks>
-        /// This cannot be set, as it is used as the key into 
+        /// This cannot be set, as it is used as the key into
         /// the item's metadata table.
         /// </remarks>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -111,7 +111,7 @@ public string Name
         }
 
         /// <summary>
-        /// Evaluated value of the metadatum. 
+        /// Evaluated value of the metadatum.
         /// Never null.
         /// </summary>
         public string EvaluatedValue
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index efcc5bbec16..9c2d9ed766e 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -29,7 +29,7 @@ public class ProjectPropertyInstance : IKeyed, IValued, IProperty, IEquatable<Pr
         private string _name;
 
         /// <summary>
-        /// Evaluated value: stored escaped. 
+        /// Evaluated value: stored escaped.
         /// </summary>
         private string _escapedValue;
 
@@ -46,7 +46,7 @@ private ProjectPropertyInstance(string name, string escapedValue)
         /// Name of the property
         /// </summary>
         /// <remarks>
-        /// This cannot be set, as it is used as the key into 
+        /// This cannot be set, as it is used as the key into
         /// the project's properties table.
         /// </remarks>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -163,7 +163,7 @@ public override string ToString()
         }
 
         /// <summary>
-        /// Called before the build when virtual properties are added, 
+        /// Called before the build when virtual properties are added,
         /// and during the build when tasks emit properties.
         /// If name is invalid or reserved, throws ArgumentException.
         /// Creates mutable object.
@@ -177,7 +177,7 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue)
         }
 
         /// <summary>
-        /// Called before the build when virtual properties are added, 
+        /// Called before the build when virtual properties are added,
         /// and during the build when tasks emit properties.
         /// If name is invalid or reserved, throws ArgumentException.
         /// Creates mutable object.
diff --git a/src/Build/Instance/ProjectTargetInstanceChild.cs b/src/Build/Instance/ProjectTargetInstanceChild.cs
index a44cf35b295..37434efd537 100644
--- a/src/Build/Instance/ProjectTargetInstanceChild.cs
+++ b/src/Build/Instance/ProjectTargetInstanceChild.cs
@@ -21,9 +21,9 @@ public abstract class ProjectTargetInstanceChild : ITranslatable
         public abstract string Condition { get; }
 
         /// <summary>
-        /// Full path to the file in which the originating element was originally 
+        /// Full path to the file in which the originating element was originally
         /// defined.
-        /// If it originated in a project that was not loaded and has never been 
+        /// If it originated in a project that was not loaded and has never been
         /// given a path, returns an empty string.
         /// </summary>
         public string FullPath
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 15bb1ebc0cc..616a99de8f3 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -55,16 +55,16 @@ internal class AssemblyTaskFactory : ITaskFactory2
         private IDictionary<string, string> _factoryIdentityParameters;
 
         /// <summary>
-        /// Tracks whether, in the UsingTask invocation, we were specifically asked to use 
-        /// the task host.  If so, that overrides all other concerns, and we will launch 
-        /// the task host even if the requested runtime / architecture match that of the 
-        /// current MSBuild process. 
+        /// Tracks whether, in the UsingTask invocation, we were specifically asked to use
+        /// the task host.  If so, that overrides all other concerns, and we will launch
+        /// the task host even if the requested runtime / architecture match that of the
+        /// current MSBuild process.
         /// </summary>
         private bool _taskHostFactoryExplicitlyRequested;
 
         /// <summary>
-        /// Need to store away the taskloggingcontext used by CreateTaskInstance so that 
-        /// TaskLoader will be able to call back with errors.  
+        /// Need to store away the taskloggingcontext used by CreateTaskInstance so that
+        /// TaskLoader will be able to call back with errors.
         /// </summary>
         private TaskLoggingContext _taskLoggingContext;
 
@@ -123,16 +123,16 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> pa
         /// Initializes this factory for instantiating tasks with a particular inline task block and a set of UsingTask parameters.
         /// </summary>
         /// <param name="taskName">Name of the task.</param>
-        /// <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks, 
-        /// such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This 
+        /// <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks,
+        /// such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This
         /// is the set of parameters that was set on the UsingTask using e.g. the UsingTask Runtime and Architecture parameters.</param>
         /// <param name="parameterGroup">The parameter group.</param>
         /// <param name="taskBody">The task body.</param>
         /// <param name="taskFactoryLoggingHost">The task factory logging host.</param>
         /// <returns>A value indicating whether initialization was successful.</returns>
         /// <remarks>
-        /// <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the 
-        /// factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2, 
+        /// <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the
+        /// factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2,
         /// this Initialize method will be called in place of ITaskFactory.Initialize.</para>
         /// <para>
         /// The taskFactoryLoggingHost will log messages in the context of the target where the task is first used.
@@ -175,12 +175,12 @@ public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
         /// The task factory logging host will log messages in the context of the task.
         /// </param>
         /// <param name="taskIdentityParameters">
-        /// Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.  
-        /// The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was 
-        /// set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.  
+        /// Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.
+        /// The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was
+        /// set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.
         /// </param>
         /// <remarks>
-        /// If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.  
+        /// If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.
         /// </remarks>
         /// <returns>
         /// The generated task, or <c>null</c> if the task failed to be created.
@@ -323,10 +323,10 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             IDictionary<string, string> mergedParameters = null;
             _taskLoggingContext = taskLoggingContext;
 
-            // Optimization for the common (vanilla AssemblyTaskFactory) case -- only calculate 
-            // the task factory parameters if we have any to calculate; otherwise even if we 
-            // still launch the task factory, it will be with parameters corresponding to the 
-            // current process. 
+            // Optimization for the common (vanilla AssemblyTaskFactory) case -- only calculate
+            // the task factory parameters if we have any to calculate; otherwise even if we
+            // still launch the task factory, it will be with parameters corresponding to the
+            // current process.
             if ((_factoryIdentityParameters?.Count > 0) || (taskIdentityParameters?.Count > 0))
             {
                 VerifyThrowIdentityParametersValid(taskIdentityParameters, taskLocation, _taskName, "MSBuildRuntime", "MSBuildArchitecture");
@@ -338,9 +338,9 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             }
             else
             {
-                // if we don't have any task host parameters specified on either the using task or the 
+                // if we don't have any task host parameters specified on either the using task or the
                 // task invocation, then we will run in-proc UNLESS "TaskHostFactory" is explicitly specified
-                // as the task factory.  
+                // as the task factory.
                 useTaskFactory = _taskHostFactoryExplicitlyRequested;
             }
 
@@ -415,8 +415,8 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
         }
 
         /// <summary>
-        /// Is the given task name able to be created by the task factory. In the case of an assembly task factory 
-        /// this question is answered by checking the assembly wrapped by the task factory to see if it exists. 
+        /// Is the given task name able to be created by the task factory. In the case of an assembly task factory
+        /// this question is answered by checking the assembly wrapped by the task factory to see if it exists.
         /// </summary>
         internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, string> taskIdentityParameters, string taskProjectFile, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)
         {
@@ -428,7 +428,7 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
             try
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, "TaskName");
-                // Parameters match, so now we check to see if the task exists. 
+                // Parameters match, so now we check to see if the task exists.
                 return _typeLoader.ReflectionOnlyLoad(taskName, _loadedType.Assembly) != null;
             }
             catch (TargetInvocationException e)
@@ -468,7 +468,7 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
         #region Private members
 
         /// <summary>
-        /// Validates the given set of parameters, logging the appropriate errors as necessary. 
+        /// Validates the given set of parameters, logging the appropriate errors as necessary.
         /// </summary>
         private static void VerifyThrowIdentityParametersValid(IDictionary<string, string> identityParameters, IElementLocation errorLocation, string taskName, string runtimeName, string architectureName)
         {
@@ -514,14 +514,14 @@ private static void VerifyThrowIdentityParametersValid(IDictionary<string, strin
         }
 
         /// <summary>
-        /// Given the set of parameters that are set to the factory, and the set of parameters coming from the task invocation that we're searching for 
-        /// a matching record to, determine whether the parameters match this record.  
+        /// Given the set of parameters that are set to the factory, and the set of parameters coming from the task invocation that we're searching for
+        /// a matching record to, determine whether the parameters match this record.
         /// </summary>
         private static bool TaskIdentityParametersMatchFactory(IDictionary<string, string> factoryIdentityParameters, IDictionary<string, string> taskIdentityParameters)
         {
             if (taskIdentityParameters == null || taskIdentityParameters.Count == 0 || factoryIdentityParameters == null || factoryIdentityParameters.Count == 0)
             {
-                // either the task or the using task doesn't care about anything, in which case we match by default.  
+                // either the task or the using task doesn't care about anything, in which case we match by default.
                 return true;
             }
 
@@ -544,7 +544,7 @@ private static bool TaskIdentityParametersMatchFactory(IDictionary<string, strin
                 }
             }
 
-            // one or more does not match, so we don't match.  
+            // one or more does not match, so we don't match.
             return false;
         }
 
@@ -607,14 +607,14 @@ private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictio
         }
 
         /// <summary>
-        /// Returns true if the provided set of task host parameters matches the current process, 
-        /// and false otherwise. 
+        /// Returns true if the provided set of task host parameters matches the current process,
+        /// and false otherwise.
         /// </summary>
         private static bool TaskHostParametersMatchCurrentProcess(IDictionary<string, string> mergedParameters)
         {
             if (mergedParameters == null || mergedParameters.Count == 0)
             {
-                // We don't care, so they match by default. 
+                // We don't care, so they match by default.
                 return true;
             }
 
@@ -647,7 +647,7 @@ private static bool TaskHostParametersMatchCurrentProcess(IDictionary<string, st
         }
 
         /// <summary>
-        /// Log errors from TaskLoader. 
+        /// Log errors from TaskLoader.
         /// </summary>
         private void ErrorLoggingDelegate(string taskLocation, int taskLine, int taskColumn, string message, params object[] messageArgs)
         {
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 0b874696321..20f381dda93 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -9,7 +9,9 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
@@ -18,35 +20,35 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// The wrapper task for tasks that wish to take advantage of the 
+    /// The wrapper task for tasks that wish to take advantage of the
     /// task host factory feature.  Generated by AssemblyTaskFactory
-    /// when it wants to run the loaded task in the task host. 
+    /// when it wants to run the loaded task in the task host.
     /// </summary>
     internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactory, INodePacketHandler
     {
         /// <summary>
-        /// The IBuildEngine callback object.  
+        /// The IBuildEngine callback object.
         /// </summary>
         private IBuildEngine _buildEngine;
 
         /// <summary>
-        /// The host object that can be passed to this task.  
+        /// The host object that can be passed to this task.
         /// </summary>
         private ITaskHost _hostObject;
 
         /// <summary>
-        /// Logging context for logging errors / issues 
-        /// encountered in the TaskHostTask itself. 
+        /// Logging context for logging errors / issues
+        /// encountered in the TaskHostTask itself.
         /// </summary>
         private TaskLoggingContext _taskLoggingContext;
 
         /// <summary>
-        /// Location of the task in the project file. 
+        /// Location of the task in the project file.
         /// </summary>
         private IElementLocation _taskLocation;
 
         /// <summary>
-        ///  The provider for the task host nodes. 
+        ///  The provider for the task host nodes.
         /// </summary>
         private IBuildComponentHost _buildComponentHost;
 
@@ -66,57 +68,57 @@ internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactor
         private ConcurrentQueue<INodePacket> _receivedPackets;
 
         /// <summary>
-        /// The set of parameters used to decide which host to launch.  
+        /// The set of parameters used to decide which host to launch.
         /// </summary>
         private IDictionary<string, string> _taskHostParameters;
 
         /// <summary>
-        /// The type of the task that we are wrapping.  
+        /// The type of the task that we are wrapping.
         /// </summary>
         private LoadedType _taskType;
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// The AppDomainSetup we'll want to apply to the AppDomain that we may 
-        /// want to load the OOP task into. 
+        /// The AppDomainSetup we'll want to apply to the AppDomain that we may
+        /// want to load the OOP task into.
         /// </summary>
         private AppDomainSetup _appDomainSetup;
 #endif
 
         /// <summary>
-        /// The task host context of the task host we're launching -- used to 
-        /// communicate with the task host. 
+        /// The task host context of the task host we're launching -- used to
+        /// communicate with the task host.
         /// </summary>
         private HandshakeOptions _requiredContext = HandshakeOptions.None;
 
         /// <summary>
-        /// True if currently connected to the task host; false otherwise. 
+        /// True if currently connected to the task host; false otherwise.
         /// </summary>
         private bool _connectedToTaskHost = false;
 
         /// <summary>
-        /// The provider for task host nodes. 
+        /// The provider for task host nodes.
         /// </summary>
         private NodeProviderOutOfProcTaskHost _taskHostProvider;
 
         /// <summary>
-        /// Lock object to serialize access to the task host. 
+        /// Lock object to serialize access to the task host.
         /// </summary>
         private Object _taskHostLock;
 
         /// <summary>
-        /// Keeps track of whether the wrapped task has had cancel called against it. 
+        /// Keeps track of whether the wrapped task has had cancel called against it.
         /// </summary>
         private bool _taskCancelled;
 
         /// <summary>
-        /// The set of parameters that has been set to this wrapped task -- save them 
-        /// here so that we can forward them on to the task host. 
+        /// The set of parameters that has been set to this wrapped task -- save them
+        /// here so that we can forward them on to the task host.
         /// </summary>
         private IDictionary<string, object> _setParameters;
 
         /// <summary>
-        /// Did the task succeed? 
+        /// Did the task succeed?
         /// </summary>
         private bool _taskExecutionSucceeded = false;
 
@@ -178,7 +180,7 @@ public IBuildEngine BuildEngine
         }
 
         /// <summary>
-        /// The host object that can be passed to this task.  
+        /// The host object that can be passed to this task.
         /// </summary>
         public ITaskHost HostObject
         {
@@ -194,7 +196,7 @@ public ITaskHost HostObject
         }
 
         /// <summary>
-        /// Sets the requested task parameter to the requested value. 
+        /// Sets the requested task parameter to the requested value.
         /// </summary>
         public void SetPropertyValue(TaskPropertyInfo property, object value)
         {
@@ -208,8 +210,8 @@ public object GetPropertyValue(TaskPropertyInfo property)
         {
             if (_setParameters.TryGetValue(property.Name, out object value))
             {
-                // If we returned an exception, then we want to throw it when we 
-                // do the get.  
+                // If we returned an exception, then we want to throw it when we
+                // do the get.
                 if (value is Exception ex)
                 {
                     throw ex;
@@ -393,16 +395,16 @@ public void PacketReceived(int node, INodePacket packet)
         }
 
         /// <summary>
-        /// Called by TaskHostFactory to let the task know that if it needs to do any additional cleanup steps, 
-        /// now would be the time.  
+        /// Called by TaskHostFactory to let the task know that if it needs to do any additional cleanup steps,
+        /// now would be the time.
         /// </summary>
         internal void Cleanup()
         {
-            // for now, do nothing. 
+            // for now, do nothing.
         }
 
         /// <summary>
-        /// Handles the packets received from the task host. 
+        /// Handles the packets received from the task host.
         /// </summary>
         private void HandlePacket(INodePacket packet, out bool taskFinished)
         {
@@ -433,14 +435,25 @@ private void HandlePacket(INodePacket packet, out bool taskFinished)
         /// </summary>
         private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplete)
         {
-            // If it crashed, or if it failed, it didn't succeed.   
+#if FEATURE_REPORTFILEACCESSES
+            if (taskHostTaskComplete.FileAccessData?.Count > 0)
+            {
+                IFileAccessManager fileAccessManager = ((IFileAccessManager)_buildComponentHost.GetComponent(BuildComponentType.FileAccessManager));
+                foreach (FileAccessData fileAccessData in taskHostTaskComplete.FileAccessData)
+                {
+                    fileAccessManager.ReportFileAccess(fileAccessData, _buildComponentHost.BuildParameters.NodeId);
+                }
+            }
+#endif
+
+            // If it crashed, or if it failed, it didn't succeed.
             _taskExecutionSucceeded = taskHostTaskComplete.TaskResult == TaskCompleteType.Success ? true : false;
 
             // reset the environment, as though the task were executed in this process all along.
             CommunicationsUtilities.SetEnvironment(taskHostTaskComplete.BuildProcessEnvironment);
 
-            // If it crashed during the execution phase, then we can effectively replicate the inproc task execution 
-            // behaviour by just throwing here and letting the taskbuilder code take care of it the way it would 
+            // If it crashed during the execution phase, then we can effectively replicate the inproc task execution
+            // behaviour by just throwing here and letting the taskbuilder code take care of it the way it would
             // have normally.
             // We will also replicate the same behaviour if the TaskHost caught some exceptions after execution of the task.
             if ((taskHostTaskComplete.TaskResult == TaskCompleteType.CrashedDuringExecution) ||
@@ -450,14 +463,14 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
             }
 
             // On the other hand, if it crashed during initialization, there's not really a way to effectively replicate
-            // the inproc behavior -- in the inproc case, the task would have failed to load and crashed long before now.  
-            // Furthermore, if we were just to throw here like in the execution case, we'd lose the ability to log 
-            // different messages based on the circumstances of the initialization failure -- whether it was a setter failure, 
-            // the task just could not be loaded, etc.  
-
-            // So instead, when we catch the exception in the task host, we'll also record what message we want it to use 
-            // when the error is logged; and given that information, log that error here.  This has the effect of differing 
-            // from the inproc case insofar as ContinueOnError is now respected, instead of forcing a stop here.  
+            // the inproc behavior -- in the inproc case, the task would have failed to load and crashed long before now.
+            // Furthermore, if we were just to throw here like in the execution case, we'd lose the ability to log
+            // different messages based on the circumstances of the initialization failure -- whether it was a setter failure,
+            // the task just could not be loaded, etc.
+
+            // So instead, when we catch the exception in the task host, we'll also record what message we want it to use
+            // when the error is logged; and given that information, log that error here.  This has the effect of differing
+            // from the inproc case insofar as ContinueOnError is now respected, instead of forcing a stop here.
             if (taskHostTaskComplete.TaskResult == TaskCompleteType.CrashedDuringInitialization)
             {
                 string exceptionMessage;
@@ -486,14 +499,14 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
         }
 
         /// <summary>
-        /// The task host node failed for some reason 
+        /// The task host node failed for some reason
         /// </summary>
         private void HandleNodeShutdown(NodeShutdown nodeShutdown)
         {
-            // if the task was canceled, it may send the shutdown packet before the task itself has exited -- 
-            // in this case, the shutdown is expected, so don't log errors.  Also don't update taskExecutionSucceeded, 
-            // as it has already been set properly (likely also to false) when we dealt with the TaskComplete 
-            // packet that was sent immediately prior to this.  
+            // if the task was canceled, it may send the shutdown packet before the task itself has exited --
+            // in this case, the shutdown is expected, so don't log errors.  Also don't update taskExecutionSucceeded,
+            // as it has already been set properly (likely also to false) when we dealt with the TaskComplete
+            // packet that was sent immediately prior to this.
             if (!_taskCancelled)
             {
                 // nothing much else to say.
@@ -523,8 +536,8 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
                 case LoggingEventType.CustomEvent:
                     BuildEventArgs buildEvent = logMessagePacket.NodeBuildEvent.Value.Value;
 
-                    // "Custom events" in terms of the communications infrastructure can also be, e.g. custom error events, 
-                    // in which case they need to be dealt with in the same way as their base type of event. 
+                    // "Custom events" in terms of the communications infrastructure can also be, e.g. custom error events,
+                    // in which case they need to be dealt with in the same way as their base type of event.
                     if (buildEvent is BuildErrorEventArgs buildErrorEventArgs)
                     {
                         this.BuildEngine.LogErrorEvent(buildErrorEventArgs);
@@ -552,12 +565,12 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
 
         /// <summary>
         /// Since we log that we weren't able to connect to the task host in a couple of different places,
-        /// extract it out into a separate method. 
+        /// extract it out into a separate method.
         /// </summary>
         private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)
         {
             string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext) ??
-                // We don't know the path -- probably we're trying to get a 64-bit assembly on a 
+                // We don't know the path -- probably we're trying to get a 64-bit assembly on a
                 // 32-bit machine.  At least give them the exe name to look for, though ...
                 ((requiredContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2 ? "MSBuildTaskHost.exe" : "MSBuild.exe");
 
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 25c8c79067b..1fbad6a47b6 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -157,8 +157,8 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
-            // If we are in building across process we need the events to be serializable. This method will 
-            // check to see if we are building with multiple process and if the event is serializable. It will 
+            // If we are in building across process we need the events to be serializable. This method will
+            // check to see if we are building with multiple process and if the event is serializable. It will
             // also log a warning if the event is not serializable and drop the logging message.
             if (IsRunningMultipleNodes && !IsEventSerializable(e))
             {
@@ -178,8 +178,8 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
-            // If we are in building across process we need the events to be serializable. This method will 
-            // check to see if we are building with multiple process and if the event is serializable. It will 
+            // If we are in building across process we need the events to be serializable. This method will
+            // check to see if we are building with multiple process and if the event is serializable. It will
             // also log a warning if the event is not serializable and drop the logging message.
             if (IsRunningMultipleNodes && !IsEventSerializable(e))
             {
@@ -199,8 +199,8 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
-            // If we are in building across process we need the events to be serializable. This method will 
-            // check to see if we are building with multiple process and if the event is serializable. It will 
+            // If we are in building across process we need the events to be serializable. This method will
+            // check to see if we are building with multiple process and if the event is serializable. It will
             // also log a warning if the event is not serializable and drop the logging message.
             if (IsRunningMultipleNodes && !IsEventSerializable(e))
             {
@@ -220,8 +220,8 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
-            // If we are in building across process we need the events to be serializable. This method will 
-            // check to see if we are building with multiple process and if the event is serializable. It will 
+            // If we are in building across process we need the events to be serializable. This method will
+            // check to see if we are building with multiple process and if the event is serializable. It will
             // also log a warning if the event is not serializable and drop the logging message.
             if (IsRunningMultipleNodes && !IsEventSerializable(e))
             {
@@ -262,7 +262,7 @@ public override object InitializeLifetimeService()
             ILease lease = (ILease)base.InitializeLifetimeService();
 
             // Set how long a lease should be initially. Once a lease expires
-            // the remote object will be disconnected and it will be marked as being availiable 
+            // the remote object will be disconnected and it will be marked as being availiable
             // for garbage collection
             int initialLeaseTime = 1;
 
@@ -284,7 +284,7 @@ public override object InitializeLifetimeService()
             // increase the lease time allowing the object to stay in memory
             _sponsor = new ClientSponsor();
 
-            // When a new lease is requested lets make it last 1 minutes longer. 
+            // When a new lease is requested lets make it last 1 minutes longer.
             int leaseExtensionTime = 1;
 
             string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDENGINEPROXYLEASEEXTENSIONTIME");
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index 4f7d6eb4f01..6a6f117d129 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -68,7 +68,7 @@ public PropertyData(
         private string _taskName;
 
         /// <summary>
-        /// The set of special parameters that, along with the name, contribute to the identity of 
+        /// The set of special parameters that, along with the name, contribute to the identity of
         /// this factory.
         /// </summary>
         private IDictionary<string, string> _factoryIdentityParameters;
@@ -153,8 +153,8 @@ public string Name
         }
 
         /// <summary>
-        /// The set of task identity parameters that were set on 
-        /// this particular factory's UsingTask statement. 
+        /// The set of task identity parameters that were set on
+        /// this particular factory's UsingTask statement.
         /// </summary>
         public IDictionary<string, string> FactoryIdentityParameters
         {
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 3627688d174..5b65829e926 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -375,11 +375,11 @@ private static void RegisterTasksFromUsingTaskElement
 
                 if (String.Equals(taskFactory, RegisteredTaskRecord.CodeTaskFactory, StringComparison.OrdinalIgnoreCase) || String.Equals(taskFactory, RegisteredTaskRecord.XamlTaskFactory, StringComparison.OrdinalIgnoreCase))
                 {
-                    // SHIM: One common pattern for people using CodeTaskFactory or XamlTaskFactory from M.B.T.v4.0.dll is to 
+                    // SHIM: One common pattern for people using CodeTaskFactory or XamlTaskFactory from M.B.T.v4.0.dll is to
                     // specify it using $(MSBuildToolsPath) -- which now no longer contains M.B.T.v4.0.dll.  This same pattern
-                    // may also occur if someone is using CodeTaskFactory or XamlTaskFactory from M.B.T.v12.0.dll.  So if we have a 
-                    // situation where the path being used doesn't contain the v4 or v12 tasks but DOES contain the v14+ tasks, just 
-                    // secretly substitute it here. 
+                    // may also occur if someone is using CodeTaskFactory or XamlTaskFactory from M.B.T.v12.0.dll.  So if we have a
+                    // situation where the path being used doesn't contain the v4 or v12 tasks but DOES contain the v14+ tasks, just
+                    // secretly substitute it here.
                     if (
                             assemblyFile != null &&
                             (assemblyFile.EndsWith(s_tasksV4Filename, StringComparison.OrdinalIgnoreCase) || assemblyFile.EndsWith(s_tasksV12Filename, StringComparison.OrdinalIgnoreCase)) &&
@@ -394,10 +394,10 @@ private static void RegisterTasksFromUsingTaskElement
                     }
                     else if (assemblyName != null)
                     {
-                        // SHIM: Another common pattern for people using CodeTaskFactory or XamlTaskFactory from 
-                        // M.B.T.v4.0.dll is to specify it using AssemblyName with a simple name -- which works only if that 
-                        // that assembly is in the current directory.  Much like with the above case, if we detect that 
-                        // situation, secretly substitute it here so that the majority of task factory users aren't broken. 
+                        // SHIM: Another common pattern for people using CodeTaskFactory or XamlTaskFactory from
+                        // M.B.T.v4.0.dll is to specify it using AssemblyName with a simple name -- which works only if that
+                        // that assembly is in the current directory.  Much like with the above case, if we detect that
+                        // situation, secretly substitute it here so that the majority of task factory users aren't broken.
                         if
                             (
                                 assemblyName.Equals(s_tasksV4SimpleName, StringComparison.OrdinalIgnoreCase) &&
@@ -577,9 +577,9 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
                             // otherwise, check the "short list" of everything else included here to see if one of them matches
                             foreach (RegisteredTaskRecord record in taskRecords.Values)
                             {
-                                // Just return the first one that actually matches.  There may be nulls in here as well, if we've previously attempted to 
-                                // find a variation on this task record and failed.  In that case, since it wasn't an exact match (otherwise it would have 
-                                // been picked up by the check above) just ignore it, the way we ignore task records that don't work with this set of 
+                                // Just return the first one that actually matches.  There may be nulls in here as well, if we've previously attempted to
+                                // find a variation on this task record and failed.  In that case, since it wasn't an exact match (otherwise it would have
+                                // been picked up by the check above) just ignore it, the way we ignore task records that don't work with this set of
                                 // parameters.
                                 if (record != null)
                                 {
@@ -592,7 +592,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
                             }
                         }
 
-                        // otherwise, nothing fit, so act like we never hit the cache at all.  
+                        // otherwise, nothing fit, so act like we never hit the cache at all.
                     }
                 }
 
@@ -618,19 +618,19 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             else
             {
                 // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
-                // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.  
+                // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.
                 //
-                // To prevent us inadvertently leaking something incompatible, in this case, we need to store not just the 
-                // record that we got this time, but ALL of the records that have previously matched this key.  
-                // 
-                // Furthermore, the first level key needs to be the name of the task, not its identity -- otherwise we might 
-                // end up with multiple entries containing subsets of the same fuzzy-matchable tasks.  E.g. with the following 
-                // set of steps: 
+                // To prevent us inadvertently leaking something incompatible, in this case, we need to store not just the
+                // record that we got this time, but ALL of the records that have previously matched this key.
+                //
+                // Furthermore, the first level key needs to be the name of the task, not its identity -- otherwise we might
+                // end up with multiple entries containing subsets of the same fuzzy-matchable tasks.  E.g. with the following
+                // set of steps:
                 // 1. Look up Foo | bar
-                // 2. Look up Foo | * (goes into Foo | bar cache entry) 
+                // 2. Look up Foo | * (goes into Foo | bar cache entry)
                 // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)
-                // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up 
-                //    first, might get Foo | baz, which also matches, instead) 
+                // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up
+                //    first, might get Foo | baz, which also matches, instead)
                 ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords
                     = _cachedTaskRecordsWithFuzzyMatch.GetOrAdd(taskIdentity.Name,
                         _ => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));
@@ -916,7 +916,7 @@ public bool Equals(RegisteredTaskIdentity x, RegisteredTaskIdentity y)
                         return false;
                     }
 
-                    // have to have the same name 
+                    // have to have the same name
                     if (String.Equals(x.Name, y.Name, StringComparison.OrdinalIgnoreCase))
                     {
                         return IdentityParametersMatch(x.TaskIdentityParameters, y.TaskIdentityParameters, _exactMatchRequired);
@@ -939,9 +939,9 @@ public int GetHashCode(RegisteredTaskIdentity obj)
 
                     int nameHash = String.IsNullOrEmpty(obj.Name) ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(obj.Name);
 
-                    // Since equality for the exact comparer depends on the exact values of the parameters, 
-                    // we need our hash code to depend on them as well. However, for fuzzy matches, we just 
-                    // need the ultimate meaning of the parameters to be the same. 
+                    // Since equality for the exact comparer depends on the exact values of the parameters,
+                    // we need our hash code to depend on them as well. However, for fuzzy matches, we just
+                    // need the ultimate meaning of the parameters to be the same.
                     string runtime = null;
                     string architecture = null;
 
@@ -961,12 +961,12 @@ public int GetHashCode(RegisteredTaskIdentity obj)
                     }
                     else
                     {
-                        // Ideally, we'd like a hash code that returns the same thing for any runtime or 
-                        // architecture that is counted as a match in Runtime/ArchitectureValuesMatch.  
-                        // But since we can't really know that without having someone to compare against, 
-                        // in this case just give up and don't try to factor the runtime / architecture 
-                        // in, and take the minor hit of having more matching hash codes than we would 
-                        // have otherwise. 
+                        // Ideally, we'd like a hash code that returns the same thing for any runtime or
+                        // architecture that is counted as a match in Runtime/ArchitectureValuesMatch.
+                        // But since we can't really know that without having someone to compare against,
+                        // in this case just give up and don't try to factor the runtime / architecture
+                        // in, and take the minor hit of having more matching hash codes than we would
+                        // have otherwise.
                         paramHash = 0;
                     }
 
@@ -997,7 +997,7 @@ private static bool IdentityParametersMatch(IDictionary<string, string> x, IDict
                             return false;
                         }
 
-                        // make sure that each parameter value matches as well 
+                        // make sure that each parameter value matches as well
                         foreach (KeyValuePair<string, string> param in x)
                         {
                             string value;
@@ -1034,7 +1034,7 @@ private static bool IdentityParametersMatch(IDictionary<string, string> x, IDict
                             y.TryGetValue(XMakeAttributes.architecture, out architectureY);
                         }
 
-                        // null is OK -- it's treated as a "don't care" 
+                        // null is OK -- it's treated as a "don't care"
                         if (!XMakeAttributes.RuntimeValuesMatch(runtimeX, runtimeY))
                         {
                             return false;
@@ -1046,7 +1046,7 @@ private static bool IdentityParametersMatch(IDictionary<string, string> x, IDict
                         }
                     }
 
-                    // if we didn't return before now, all parameters were found and matched.  
+                    // if we didn't return before now, all parameters were found and matched.
                     return true;
                 }
             }
@@ -1292,7 +1292,7 @@ internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile,
                             if (TaskFactoryAttributeName == AssemblyTaskFactory || TaskFactoryAttributeName == TaskHostFactory)
                             {
                                 // Also we only need to check to see if the task name can be created by the factory if the taskName does not equal the Registered name
-                                // and the identity parameters don't match the factory's declared parameters. 
+                                // and the identity parameters don't match the factory's declared parameters.
                                 // This is because when the task factory is instantiated we try and load the Registered name from the task factory and fail it it cannot be loaded
                                 // therefore the fact that we have a factory means the Registered type and parameters can be created by the factory.
                                 if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Fuzzy.Equals(this.TaskIdentity, taskIdentity))
@@ -1399,7 +1399,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                     }
                     else
                     {
-                        // We are not one of the default factories. 
+                        // We are not one of the default factories.
                         TaskEngineAssemblyResolver resolver = null;
 
                         try
@@ -1424,7 +1424,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
 
                                 if (loadedType == null)
                                 {
-                                    // We could not find the type (this is what null means from the Load method) but there is no reason given so we can only log the fact that 
+                                    // We could not find the type (this is what null means from the Load method) but there is no reason given so we can only log the fact that
                                     // we could not find the name given in the task factory attribute in the class specified in the assembly File or assemblyName fields.
                                     ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CouldNotFindFactory", TaskFactoryAttributeName, taskFactoryLoadInfo.AssemblyLocation);
                                 }
@@ -1701,7 +1701,7 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                         if (expandedType.StartsWith("Microsoft.Build.Framework.", StringComparison.OrdinalIgnoreCase) && !expandedType.Contains(","))
                         {
                             // This is workaround for internal bug https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1448821
-                            // Visual Studio can load different version of Microsoft.Build.Framework.dll and non fully classified type could be resolved from it 
+                            // Visual Studio can load different version of Microsoft.Build.Framework.dll and non fully classified type could be resolved from it
                             // which cause InvalidProjectFileException with "UnsupportedTaskParameterTypeError" message.
                             // Another way to address this is to load types from compiled assembly - that would be more robust solution but also much more complex and risky code changes.
                             paramType = Type.GetType(expandedType + "," + typeof(ITaskItem).GetTypeInfo().Assembly.FullName, false /* don't throw on error */, true /* case-insensitive */) ??
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index f4143ccaae7..96942d03d55 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -1285,7 +1285,7 @@ StringBuilder IStringBuilderProvider.Acquire(int capacity)
 
             // Prepare for next use.
             // Equivalent of sb.Clear() that works on .Net 3.5
-            shared.Length = 0; 
+            shared.Length = 0;
 
             return shared;
         }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index fb8e59007e3..a935708e681 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Logging
     /// <remarks>The logger is public so that it can be instantiated from MSBuild.exe via command-line switch.</remarks>
     public sealed class BinaryLogger : ILogger
     {
-        // version 2: 
+        // version 2:
         //   - new BuildEventContext.EvaluationId
         //   - new record kinds: ProjectEvaluationStarted, ProjectEvaluationFinished
         // version 3:
@@ -61,7 +61,9 @@ public sealed class BinaryLogger : ILogger
         //   - new record kind: ResponseFileUsedEventArgs
         // version 16:
         //   - AssemblyLoadBuildEventArgs
-        internal const int FileFormatVersion = 16;
+        // version 17:
+        //   - Added extended data for types implementing IExtendedBuildEventArgs
+        internal const int FileFormatVersion = 17;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -108,7 +110,7 @@ public enum ProjectImportsCollectionMode
         public LoggerVerbosity Verbosity { get; set; } = LoggerVerbosity.Diagnostic;
 
         /// <summary>
-        /// Gets or sets the parameters. The only supported parameter is the output log file path (for example, "msbuild.binlog"). 
+        /// Gets or sets the parameters. The only supported parameter is the output log file path (for example, "msbuild.binlog").
         /// </summary>
         public string Parameters { get; set; }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
index 65468da0972..0f579c2a549 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
@@ -29,6 +29,7 @@ internal enum BuildEventArgsFieldFlags
         EndLineNumber = 1 << 12,
         EndColumnNumber = 1 << 13,
         Arguments = 1 << 14,
-        Importance = 1 << 15
+        Importance = 1 << 15,
+        Extended = 1 << 16,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
index f5aba4eb60c..fcc7c4433ff 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
@@ -32,5 +32,6 @@ internal class BuildEventArgsFields
         public int ColumnNumber { get; set; }
         public int EndLineNumber { get; set; }
         public int EndColumnNumber { get; set; }
+        public ExtendedDataFields Extended { get; set; }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 4b13c438721..38e391565de 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -198,8 +198,6 @@ public void Dispose()
                 case BinaryLogRecordKind.AssemblyLoad:
                     result = ReadAssemblyLoadEventArgs();
                     break;
-                default:
-                    break;
             }
 
             recordNumber += 1;
@@ -606,21 +604,50 @@ private BuildEventArgs ReadBuildErrorEventArgs()
             var fields = ReadBuildEventArgsFields();
             ReadDiagnosticFields(fields);
 
-            var e = new BuildErrorEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildErrorEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildErrorEventArgs(
+                    fields.Extended.ExtendedType,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended.ExtendedMetadataAsDictionary,
+                    ExtendedData = fields.Extended.ExtendedData,
+                };
+            }
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+
             return e;
         }
 
@@ -629,21 +656,50 @@ private BuildEventArgs ReadBuildWarningEventArgs()
             var fields = ReadBuildEventArgsFields();
             ReadDiagnosticFields(fields);
 
-            var e = new BuildWarningEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildWarningEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildWarningEventArgs(
+                    fields.Extended.ExtendedType,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended.ExtendedMetadataAsDictionary,
+                    ExtendedData = fields.Extended.ExtendedData,
+                };
+            }
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+
             return e;
         }
 
@@ -651,22 +707,53 @@ private BuildEventArgs ReadBuildMessageEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            var e = new BuildMessageEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Importance,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildMessageEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Importance,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildMessageEventArgs(
+                    fields.Extended?.ExtendedType ?? string.Empty,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Importance,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended?.ExtendedMetadataAsDictionary,
+                    ExtendedData = fields.Extended?.ExtendedData,
+                };
+            }
+
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+
             return e;
         }
 
@@ -711,21 +798,49 @@ private BuildEventArgs ReadCriticalBuildMessageEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            var e = new CriticalBuildMessageEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new CriticalBuildMessageEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                };
+            }
+            else
+            {
+                e = new ExtendedCriticalBuildMessageEventArgs(
+                    fields.Extended?.ExtendedType ?? string.Empty,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended?.ExtendedMetadataAsDictionary,
+                    ExtendedData = fields.Extended?.ExtendedData,
+                };
+            }
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
             return e;
         }
 
@@ -857,12 +972,23 @@ private void ReadDiagnosticFields(BuildEventArgsFields fields)
             fields.EndColumnNumber = ReadInt32();
         }
 
+        private ExtendedDataFields? ReadExtendedDataFields()
+        {
+            string extendedType = ReadOptionalString()!;
+            IDictionary<string, string?>? extendedMetadata = ReadStringDictionary()!;
+            string? extendedData = ReadOptionalString();
+
+            return new ExtendedDataFields(extendedType, extendedMetadata, extendedData);
+        }
+
         private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = false)
         {
             BuildEventArgsFieldFlags flags = (BuildEventArgsFieldFlags)ReadInt32();
             var result = new BuildEventArgsFields();
             result.Flags = flags;
 
+            // Base Fields
+
             if ((flags & BuildEventArgsFieldFlags.Message) != 0)
             {
                 result.Message = ReadDeduplicatedString();
@@ -893,6 +1019,13 @@ private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = fals
                 result.Timestamp = ReadDateTime();
             }
 
+            if ((flags & BuildEventArgsFieldFlags.Extended) != 0)
+            {
+                result.Extended = ReadExtendedDataFields();
+            }
+
+            // End of BaseFields
+
             if ((flags & BuildEventArgsFieldFlags.Subcategory) != 0)
             {
                 result.Subcategory = ReadDeduplicatedString();
@@ -1252,9 +1385,9 @@ private bool ReadBoolean()
             return binaryReader.ReadBoolean();
         }
 
-        private unsafe Guid ReadGuid()
+        private Guid ReadGuid()
         {
-            return new Guid(binaryReader.ReadBytes(sizeof(Guid)));
+            return new Guid(binaryReader.ReadBytes(16 /*sizeof(Guid) - to avoid unsafe context, Guid will never change in size */));
         }
 
         private DateTime ReadDateTime()
@@ -1440,7 +1573,7 @@ public void Dispose()
                 }
                 catch
                 {
-                    // The StringStorage class is not crucial for other functionality and if 
+                    // The StringStorage class is not crucial for other functionality and if
                     // there are exceptions when closing the temp file, it's too late to do anything about it.
                     // Since we don't want to disrupt anything and the file is in the TEMP directory, it will
                     // get cleaned up at some point anyway.
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index bc96814843e..0a21182e83c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -198,12 +198,31 @@ private void WriteCore(BuildEventArgs e)
                 default:
                     // convert all unrecognized objects to message
                     // and just preserve the message
-                    var buildMessageEventArgs = new BuildMessageEventArgs(
-                        e.Message,
-                        e.HelpKeyword,
-                        e.SenderName,
-                        MessageImportance.Normal,
-                        e.Timestamp);
+                    BuildMessageEventArgs buildMessageEventArgs;
+                    if (e is IExtendedBuildEventArgs extendedData)
+                    {
+                        // For Extended events convert to ExtendedBuildMessageEventArgs
+                        buildMessageEventArgs = new ExtendedBuildMessageEventArgs(
+                            extendedData.ExtendedType,
+                            e.Message,
+                            e.HelpKeyword,
+                            e.SenderName,
+                            MessageImportance.Normal,
+                            e.Timestamp)
+                        {
+                            ExtendedData = extendedData.ExtendedData,
+                            ExtendedMetadata = extendedData.ExtendedMetadata,
+                        };
+                    }
+                    else
+                    {
+                        buildMessageEventArgs = new BuildMessageEventArgs(
+                            e.Message,
+                            e.HelpKeyword,
+                            e.SenderName,
+                            MessageImportance.Normal,
+                            e.Timestamp);
+                    }
                     buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
                     Write(buildMessageEventArgs);
                     break;
@@ -610,6 +629,11 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
             {
                 Write(e.Timestamp);
             }
+
+            if ((flags & BuildEventArgsFieldFlags.Extended) != 0)
+            {
+                Write(e as IExtendedBuildEventArgs);
+            }
         }
 
         private void WriteMessageFields(BuildMessageEventArgs e, bool writeMessage = true, bool writeImportance = false)
@@ -775,6 +799,11 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
                 flags |= BuildEventArgsFieldFlags.Timestamp;
             }
 
+            if (e is IExtendedBuildEventArgs extendedData)
+            {
+                flags |= BuildEventArgsFieldFlags.Extended;
+            }
+
             return flags;
         }
 
@@ -1218,6 +1247,16 @@ private void Write(ProfiledLocation e)
             Write(e.InclusiveTime);
         }
 
+        private void Write(IExtendedBuildEventArgs extendedData)
+        {
+            if (extendedData?.ExtendedType != null)
+            {
+                WriteDeduplicatedString(extendedData.ExtendedType);
+                Write(extendedData.ExtendedMetadata);
+                WriteDeduplicatedString(extendedData.ExtendedData);
+            }
+        }
+
         internal readonly struct HashKey : IEquatable<HashKey>
         {
             private readonly ulong value;
diff --git a/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs b/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
new file mode 100644
index 00000000000..12912cc3e70
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
@@ -0,0 +1,30 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Logging;
+
+internal class ExtendedDataFields
+{
+    public ExtendedDataFields(string extendedType, IDictionary<string, string?>? extendedMetadata, string? extendedData)
+    {
+        ExtendedType = extendedType;
+        ExtendedMetadata = extendedMetadata;
+        ExtendedData = extendedData;
+    }
+
+    public string ExtendedType { get; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; }
+    public string? ExtendedData { get; }
+
+    /// <summary>
+    /// We need to this for Extended event args have Dictionary as ExtendedMetadata.
+    /// </summary>
+    public Dictionary<string, string?>? ExtendedMetadataAsDictionary =>
+        ExtendedMetadata == null ?
+            null :
+            ExtendedMetadata is Dictionary<string, string?> asDictionary ?
+                asDictionary :
+                new Dictionary<string, string?>(ExtendedMetadata);
+}
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 136b0c94d7f..35886babcca 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -38,8 +38,8 @@ namespace Microsoft.Build.Logging
 
     /// <summary>
     /// This class implements the default logger that outputs event data
-    /// to the console (stdout). 
-    /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger, 
+    /// to the console (stdout).
+    /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger,
     /// either SerialConsoleLogger or ParallelConsoleLogger.
     /// </summary>
     /// <remarks>This class is not thread safe.</remarks>
@@ -329,7 +329,7 @@ protected WriteHandler WriteHandler
 
         /// <summary>
         /// Apply a parameter.
-        /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has 
+        /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has
         /// no good reason for being public.
         /// </summary>
         public void ApplyParameter(string parameterName, string parameterValue)
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 7f90d035fd6..21271e12fb0 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -215,7 +215,7 @@ public string Parameters
         #region Data
         // The file logger which will do the actual logging of the node's build output
         private FileLogger _nodeFileLogger;
-        // Reference for the central logger 
+        // Reference for the central logger
         private IEventRedirector _buildEventRedirector;
         // The Id of the node the forwardingLogger is attached to
         private int _nodeId;
diff --git a/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs b/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
index 85824638836..d557bf890d2 100644
--- a/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
+++ b/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Logging
 {
     /// <summary>
-    /// Comparer for <see cref="EvaluationLocation"/> that ignores 
+    /// Comparer for <see cref="EvaluationLocation"/> that ignores
     /// both <see cref="EvaluationLocation.Id"/> and <see cref="EvaluationLocation.ParentId"/>
     /// </summary>
     internal class EvaluationLocationIdAgnosticComparer : IEqualityComparer<EvaluationLocation>
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index bd0abc891b9..f325ea36d27 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Logging
 {
     /// <summary>
     /// A specialization of the ConsoleLogger that logs to a file instead of the console.
-    /// The output in terms of what is written and how it looks is identical. For example you can 
+    /// The output in terms of what is written and how it looks is identical. For example you can
     /// log verbosely to a file using the FileLogger while simultaneously logging only high priority events
     /// to the console using a ConsoleLogger.
     /// </summary>
diff --git a/src/Build/Logging/LogFormatter.cs b/src/Build/Logging/LogFormatter.cs
index 280feeedc1f..b03391a34a1 100644
--- a/src/Build/Logging/LogFormatter.cs
+++ b/src/Build/Logging/LogFormatter.cs
@@ -20,7 +20,7 @@ internal static class LogFormatter
         internal static string FormatLogTimeStamp(DateTime timeStamp)
         {
             // From http://msdn2.microsoft.com/en-us/library/8kb3ddd4.aspx
-            // Custom DateTime Format Strings  
+            // Custom DateTime Format Strings
             //
             // HH Represents the hour as a number from 00 through 23, that is,
             //    the hour as represented by a zero-based 24-hour clock that counts the hours since midnight.
diff --git a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
index 63e8f26bbe3..876227f72f9 100644
--- a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
+++ b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
@@ -38,7 +38,7 @@ public ConsoleOutputAligner(int bufferWidth, bool alignMessages, IStringBuilderP
 
         /// <summary>
         /// Based on bufferWidth split message into multiple lines and indent if needed.
-        /// TAB character are interpreted by standard Console logic. 
+        /// TAB character are interpreted by standard Console logic.
         /// </summary>
         /// <param name="message">Input message. May contains tabs and new lines. Both \r\n and \n is supported but replaced into current environment new line.</param>
         /// <param name="prefixAlreadyWritten">true if message already contains prefix (message context, timestamp, etc...).</param>
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index d8d1dce3a34..280d61a3bad 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -181,7 +181,7 @@ private void ShownBuildEventContext(BuildEventContext e)
 
         /// <summary>
         /// Reset the states of per-build member variables
-        /// VSW#516376 
+        /// VSW#516376
         /// </summary>
         internal override void ResetConsoleLoggerState()
         {
@@ -339,7 +339,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// Does this in a "flat" style, without context.
         /// </summary>
@@ -351,7 +351,7 @@ private void ShowFlatErrorWarningSummary()
             }
 
             // If we're showing only warnings and/or errors, don't summarize.
-            // This is the buildc.err case. There's no point summarizing since we'd just 
+            // This is the buildc.err case. There's no point summarizing since we'd just
             // repeat the entire log content again.
             if (showOnlyErrors || showOnlyWarnings)
             {
@@ -384,7 +384,7 @@ private void ShowFlatErrorWarningSummary()
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// Does this in a "nested" style.
         /// </summary>
@@ -396,7 +396,7 @@ private void ShowNestedErrorWarningSummary()
             }
 
             // If we're showing only warnings and/or errors, don't summarize.
-            // This is the buildc.err case. There's no point summarizing since we'd just 
+            // This is the buildc.err case. There's no point summarizing since we'd just
             // repeat the entire log content again.
             if (showOnlyErrors || showOnlyWarnings)
             {
@@ -427,13 +427,13 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
             foreach (BuildEventArgs errorWarningEventArgs in listToProcess)
             {
                 // Target event may be null for a couple of reasons:
-                // 1) If the event was from a project load, or engine 
+                // 1) If the event was from a project load, or engine
                 // 2) If the flushing of the event queue for each request and result is turned off
                 // as this could cause errors and warnings to be seen by the logger after the target finished event
                 // which would cause the error or warning to have no matching target started event as they are removed
                 // when a target finished event is logged.
-                // 3) On NORMAL verbosity if the error or warning occurs in a project load then the error or warning and the target started event will be forwarded to 
-                // different forwarding loggers which cannot communicate to each other, meaning there will be no matching target started event logged 
+                // 3) On NORMAL verbosity if the error or warning occurs in a project load then the error or warning and the target started event will be forwarded to
+                // different forwarding loggers which cannot communicate to each other, meaning there will be no matching target started event logged
                 // as the forwarding logger did not know to forward the target started event
                 string targetName = null;
                 TargetStartedEventMinimumFields targetEvent = _buildEventManager.GetTargetStartedEvent(errorWarningEventArgs.BuildEventContext);
@@ -705,7 +705,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                             }
                         }
 
-                        // In single proc only make a space between the project done event and the next line, this 
+                        // In single proc only make a space between the project done event and the next line, this
                         // is to increase the readability on the single proc log when there are a number of done events
                         // or a mix of done events and project started events. Also only do this on the console and not any log file.
                         if (NumberOfProcessors == 1 && runningWithCharacterFileType)
@@ -725,7 +725,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="e">A <see cref="BuildEventArgs"/> object containing information about the build event.</param>
@@ -792,7 +792,7 @@ internal override void OutputEnvironment(IDictionary<string, string> environment
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="e">A <see cref="BuildEventArgs"/> object containing information about the build event.</param>
@@ -1026,10 +1026,10 @@ internal string FindLogOutputProperties(BuildEventArgs e)
         public override void ErrorHandler(object sender, BuildErrorEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
-            // Keep track of the number of error events raised 
+            // Keep track of the number of error events raised
             errorCount++;
 
-            // If there is an error we need to walk up the call stack and make sure that 
+            // If there is an error we need to walk up the call stack and make sure that
             // the project started events back to the root project know an error has occurred
             // and are not removed when they finish
             _buildEventManager.SetErrorWarningFlagOnCallStack(e.BuildEventContext);
@@ -1075,7 +1075,7 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
             // Keep track of the number of warning events raised during the build
             warningCount++;
 
-            // If there is a warning we need to walk up the call stack and make sure that 
+            // If there is a warning we need to walk up the call stack and make sure that
             // the project started events back to the root project know a warning has occurred
             // and are not removed when they finish
             _buildEventManager.SetErrorWarningFlagOnCallStack(e.BuildEventContext);
@@ -1149,7 +1149,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
 
             if (print)
             {
-                // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be 
+                // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be
                 // buffered until the project started event is fired
                 if (
                        _hasBuildStarted
@@ -1221,14 +1221,14 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
                 return;
             }
 
-            // Display any project started events which were deferred until a visible 
+            // Display any project started events which were deferred until a visible
             // message from their project is displayed
             if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
             {
                 DisplayDeferredProjectStartedEvent(e);
             }
 
-            // Display any target started events which were deferred until a visible 
+            // Display any target started events which were deferred until a visible
             // message from their target is displayed
             if (IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
@@ -1554,7 +1554,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         resetColor();
                     }
 
-                    // Make the last shown build event context to be null so that the next message will always print out the target name. If this is not null 
+                    // Make the last shown build event context to be null so that the next message will always print out the target name. If this is not null
                     // then the first message after the project started event will not have the target name printed out which was causing some confusion.
                     ShownBuildEventContext(null);
                 }
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index d7612d7f3a6..de9c04f2c57 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -272,7 +272,7 @@ public int GetHashCode(T x)
     }
 
     /// <summary>
-    /// This class stands in for a full project started event because it contains only the 
+    /// This class stands in for a full project started event because it contains only the
     /// minimum amount of inforomation needed for the logger
     /// </summary>
     internal class ProjectStartedEventMinimumFields
@@ -410,7 +410,7 @@ internal ProjectStartedEventMinimumFields(int projectKey, int entryPointKey, Pro
     }
 
     /// <summary>
-    /// This class stands in for a full target started event because it contains only the 
+    /// This class stands in for a full target started event because it contains only the
     /// minimum amount of inforomation needed for the logger
     /// </summary>
     internal class TargetStartedEventMinimumFields
@@ -530,7 +530,7 @@ internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent, bo
     }
 
     /// <summary>
-    /// This class is used as a key to group warnings and errors by the project entry point and the target they 
+    /// This class is used as a key to group warnings and errors by the project entry point and the target they
     /// error or warning was in
     /// </summary>
     internal class ErrorWarningSummaryDictionaryKey
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index a67d513a099..77c521d5452 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -113,7 +113,7 @@ private void ProjectEvaluationFinishedRaised(object sender, BuildEventArgs e)
         /// <param name="pruneSmallItems">Whether small items should be pruned. This is called with false on some tests since the result may vary depending on the evaluator speed</param>
         /// <remarks>
         /// Not thread safe. After this method is called, the assumption is that no new ProjectEvaluationFinishedEventArgs will arrive.
-        /// In the regular code path, this method is called only once per build. But some test cases may call it multiple times to validate 
+        /// In the regular code path, this method is called only once per build. But some test cases may call it multiple times to validate
         /// the aggregated data.
         /// </remarks>
         internal ProfilerResult GetAggregatedResult(bool pruneSmallItems = true)
@@ -219,7 +219,7 @@ private static Dictionary<EvaluationLocation, ProfiledLocation> PruneSmallItems(
 
             // Let's build an index of profiled locations by id, to speed up subsequent queries
             var idTable = aggregatedLocations.ToDictionary(pair => pair.Key.Id,
-                pair => new Pair<EvaluationLocation, ProfiledLocation>(pair.Key, pair.Value));
+                pair => new KeyValuePair<EvaluationLocation, ProfiledLocation>(pair.Key, pair.Value));
 
             // We want to keep all evaluation pass entries plus the big enough regular entries
             foreach (var prunedPair in aggregatedLocations.Where(pair =>
@@ -237,7 +237,7 @@ private static Dictionary<EvaluationLocation, ProfiledLocation> PruneSmallItems(
         /// <summary>
         /// Finds the first ancestor of parentId (which could be itself) that is either an evaluation pass location or a big enough profiled data.
         /// </summary>
-        private static long? FindBigEnoughParentId(IDictionary<long, Pair<EvaluationLocation, ProfiledLocation>> idTable,
+        private static long? FindBigEnoughParentId(IDictionary<long, KeyValuePair<EvaluationLocation, ProfiledLocation>> idTable,
             long? parentId)
         {
             // The parent id is null, which means the item was pointing to an evaluation pass item. So we keep it as is.
@@ -278,7 +278,7 @@ private static ProfiledLocation AggregateProfiledLocation(ProfiledLocation locat
         /// Pretty prints the aggregated results and saves it to disk.
         /// </summary>
         /// <remarks>
-        /// If the extension of the file to log is 'md', markdown content is generated. Otherwise, it falls 
+        /// If the extension of the file to log is 'md', markdown content is generated. Otherwise, it falls
         /// back to a tab separated format.
         /// </remarks>
         private void GenerateProfilerReport()
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index ac0ce5609c3..61f750ff472 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -67,7 +67,7 @@ public SerialConsoleLogger(
 
         /// <summary>
         /// Reset the states of per-build member variables
-        /// VSW#516376 
+        /// VSW#516376
         /// </summary>
         internal override void ResetConsoleLoggerState()
         {
@@ -182,7 +182,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// </summary>
         private void ShowErrorWarningSummary()
@@ -298,7 +298,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                 counter.InScope = false;
             }
 
-            // if verbosity is detailed or diagnostic, 
+            // if verbosity is detailed or diagnostic,
             // or there was an error or warning
             if (contextStack.Peek().hasErrorsOrWarnings
                 || (IsVerbosityAtLeast(LoggerVerbosity.Detailed)))
@@ -375,7 +375,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
 
             bool targetHasErrorsOrWarnings = contextStack.Peek().hasErrorsOrWarnings;
 
-            // if verbosity is diagnostic, 
+            // if verbosity is diagnostic,
             // or there was an error or warning and verbosity is normal or detailed
             if ((targetHasErrorsOrWarnings && (IsVerbosityAtLeast(LoggerVerbosity.Normal)))
                   || Verbosity == LoggerVerbosity.Diagnostic)
@@ -885,8 +885,8 @@ internal Frame(
 
             /// <summary>
             /// For TargetStarted events, this stores the filename where the Target is defined
-            /// (e.g., Microsoft.Common.targets).  This is different than the project that is 
-            /// being built.  
+            /// (e.g., Microsoft.Common.targets).  This is different than the project that is
+            /// being built.
             /// For ProjectStarted events, this is null.
             /// </summary>
             internal string file;
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
index b895ab67f64..a1e387f69aa 100644
--- a/src/Build/Logging/SimpleErrorLogger.cs
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Logging.TerminalLogger;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging.SimpleErrorLogger
@@ -44,30 +45,36 @@ public void Initialize(IEventSource eventSource, int nodeCount)
         {
             eventSource.ErrorRaised += HandleErrorEvent;
             eventSource.WarningRaised += HandleWarningEvent;
+
+            // This needs to happen so binary loggers can get evaluation properties and items
+            if (eventSource is IEventSource4 eventSource4)
+            {
+                eventSource4.IncludeEvaluationPropertiesAndItems();
+            }
         }
 
         private void HandleErrorEvent(object sender, BuildErrorEventArgs e)
         {
             HasLoggedErrors = true;
-            LogErrorEvent(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true), "\x1b[31;1m");
+            LogWithColor(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true),
+                TerminalColor.Red);
         }
 
         private void HandleWarningEvent(object sender, BuildWarningEventArgs e)
         {
-            LogErrorEvent(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true), "\x1b[33;1m");
+            LogWithColor(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true),
+                TerminalColor.Yellow);
         }
 
-        private void LogErrorEvent(string s, string color)
+        private void LogWithColor(string message, TerminalColor color)
         {
             if (acceptAnsiColorCodes)
             {
-                Console.Error.Write(color);
-                Console.Error.Write(s);
-                Console.Error.WriteLine("\x1b[m");
+                Console.Error.WriteLine(AnsiCodes.Colorize(message, color));
             }
             else
             {
-                Console.Error.Write(s);
+                Console.Error.WriteLine(message);
             }
         }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 39a953f2948..7248660300c 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -32,16 +32,19 @@
 
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
+    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
+    <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
-    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
+    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Reference Include="System.IO.Compression" />
@@ -51,7 +54,6 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="System.Reflection.Metadata" />
-    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
 
@@ -76,20 +78,12 @@
     </Compile>
     <Compile Include="..\Shared\CanonicalError.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\CanonicalError.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
       <Link>IConstrainedEqualityComparer.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\NGen.cs">
-      <Link>SharedUtilities\NGen.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\Pair.cs">
-      <Link>SharedUtilities\Pair.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\PropertyParser.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\StringExtensions.cs">
       <Link>SharedUtilities\StringExtensions.cs</Link>
@@ -118,25 +112,20 @@
     <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\Shared\PlatformNegotiation.cs">
       <Link>PlatformNegotiation.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\SolutionConfiguration.cs" />
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelper.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TaskLoggingHelperExtension.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelperExtension.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
-    <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs" />
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="BackEnd\BuildManager\BuildManager.cs" />
@@ -152,13 +141,26 @@
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\Communications\CurrentHost.cs" />
+    <Compile Include="BackEnd\Components\Communications\DetouredNodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\SerializationContractInitializer.cs" />
     <Compile Include="BackEnd\Components\Communications\ServerNodeEndpointOutOfProc.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\IFileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\FileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\FileAccessReport.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\OutOfProcNodeFileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\ProcessReport.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\AssemblyLoadsTracker.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
+    <Compile Include="FileAccess\DesiredAccess.cs" />
+    <Compile Include="FileAccess\FileAccessData.cs" />
+    <Compile Include="FileAccess\FlagsAndAttributes.cs" />
+    <Compile Include="FileAccess\ProcessData.cs" />
+    <Compile Include="FileAccess\ReportedFileOperation.cs" />
+    <Compile Include="FileAccess\RequestedAccess.cs" />
+    <Compile Include="Logging\BinaryLogger\ExtendedDataFields.cs" />
     <Compile Include="Logging\BinaryLogger\IBuildEventArgsReaderNotifications.cs" />
     <Compile Include="Logging\BinaryLogger\IBuildEventStringsReader.cs" />
     <Compile Include="Logging\BinaryLogger\StringReadEventArgs.cs" />
@@ -213,14 +215,10 @@
     <Compile Include="BackEnd\Components\Logging\ProjectLoggingContext.cs" />
     <Compile Include="BackEnd\Components\Logging\TargetLoggingContext.cs" />
     <Compile Include="BackEnd\Components\Logging\TaskLoggingContext.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\CallTarget.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\CallTarget.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\IntrinsicTaskFactory.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\ItemGroupLoggingHelper.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\MSBuild.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\MSBuild.cs" />
     <Compile Include="BackEnd\Components\Scheduler\SchedulableRequest.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\FullTracking.cs" />
     <Compile Include="BackEnd\Components\Scheduler\SchedulingData.cs" />
@@ -228,6 +226,7 @@
     <Compile Include="BackEnd\Components\Scheduler\SchedulerCircularDependencyException.cs" />
     <Compile Include="BackEnd\Components\Scheduler\ScheduleTimeRecord.cs" />
     <Compile Include="BackEnd\Components\Scheduler\SchedulingPlan.cs" />
+    <Compile Include="BackEnd\Components\SdkResolution\CachingSdkResolverLoader.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\DefaultSdkResolver.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\ISdkResolverService.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\OutOfProcNodeSdkResolverService.cs" />
@@ -248,18 +247,10 @@
     <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
     <Compile Include="Collections\ConcurrentStackExtensions.cs" />
     <Compile Include="Collections\LookasideStringInterner.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSet.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Collections\RetrievableEntryHashSet\HashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
@@ -316,9 +307,7 @@
     <Compile Include="BackEnd\Components\Communications\NodeProviderOutOfProc.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderOutOfProcBase.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderOutOfProcTaskHost.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\BatchingEngine.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\BatchingEngine.cs" />
     <Compile Include="BackEnd\BuildManager\BuildRequestData.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTask.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\ItemGroupIntrinsicTask.cs" />
@@ -334,18 +323,12 @@
     <Compile Include="BackEnd\Components\RequestBuilder\IRequestBuilderCallback.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\ITargetBuilder.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\ITaskBuilder.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\ItemBucket.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="BackEnd\Components\RequestBuilder\Lookup.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\ItemBucket.cs" />
+    <Compile Include="BackEnd\Components\RequestBuilder\Lookup.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\RequestBuilder.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\TargetBuilder.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\TargetEntry.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\TargetUpToDateChecker.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\TargetUpToDateChecker.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\TaskBuilder.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\TaskHost.cs" />
     <Compile Include="BackEnd\Shared\BuildRequest.cs" />
@@ -361,6 +344,7 @@
     <Compile Include="BackEnd\Shared\TargetResult.cs" />
     <Compile Include="BackEnd\Shared\WorkUnitResult.cs" />
     <Compile Include="BackEnd\Components\BuildRequestEngine\IBuildRequestEngine.cs" />
+    <Compile Include="BackEnd\Components\Communications\INodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\INodeManager.cs" />
     <Compile Include="BackEnd\Components\Communications\INodeProvider.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeEndpointInProc.cs" />
@@ -384,9 +368,7 @@
     </Compile>
     <Compile Include="Collections\CopyOnWritePropertyDictionary.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
-    <Compile Include="Collections\HashTableUtility.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Collections\HashTableUtility.cs" />
     <Compile Include="Collections\ItemDictionary.cs" />
     <Compile Include="Collections\IImmutable.cs" />
     <Compile Include="Collections\MultiDictionary.cs" />
@@ -424,12 +406,8 @@
     <Compile Include="Construction\ProjectUsingTaskBodyElement.cs" />
     <Compile Include="Construction\Solution\SolutionConfigurationInSolution.cs" />
     <Compile Include="Construction\Solution\ProjectConfigurationInSolution.cs" />
-    <Compile Include="Construction\Solution\ProjectInSolution.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Construction\Solution\SolutionFile.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Construction\Solution\ProjectInSolution.cs" />
+    <Compile Include="Construction\Solution\SolutionFile.cs" />
     <!-- #### DEFINITION MODEL ### -->
     <Compile Include="Definition\BuiltInMetadata.cs" />
     <Compile Include="Definition\ProjectCollection.cs" />
@@ -442,9 +420,7 @@
     <Compile Include="Definition\SubToolset.cs" />
     <Compile Include="Definition\Toolset.cs" />
     <Compile Include="Definition\ToolsetConfigurationReader.cs" />
-    <Compile Include="..\Shared\ToolsetElement.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\ToolsetElement.cs" />
     <Compile Include="Definition\ToolsetPropertyDefinition.cs" />
     <Compile Include="Definition\ToolsetReader.cs" />
     <Compile Include="Definition\ToolsetRegistryReader.cs" />
@@ -455,85 +431,33 @@
     <Compile Include="ElementLocation\XmlDocumentWithLocation.cs" />
     <Compile Include="ElementLocation\XmlElementWithLocation.cs" />
     <Compile Include="ElementLocation\XmlNameTableThreadSafe.cs" />
-    <Compile Include="Errors\InternalLoggerException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Errors\InvalidProjectFileException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Errors\InvalidToolsetDefinitionException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Errors\RegistryException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Errors\InternalLoggerException.cs" />
+    <Compile Include="Errors\InvalidProjectFileException.cs" />
+    <Compile Include="Errors\InvalidToolsetDefinitionException.cs" />
+    <Compile Include="Errors\RegistryException.cs" />
     <!-- #### EVALUATION ### -->
-    <Compile Include="Evaluation\ConditionEvaluator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\AndExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\CharacterUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\EqualExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\FunctionCallExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\GenericExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\GreaterThanExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\GreaterThanOrEqualExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\LessThanExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\LessThanOrEqualExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\MultipleComparisonExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\NotEqualExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\NotExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\NumericComparisonExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\NumericExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\OperandExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\OperatorExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\OrExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\Parser.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\Scanner.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\StringExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\Token.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Evaluation\ConditionEvaluator.cs" />
+    <Compile Include="Evaluation\Conditionals\AndExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\CharacterUtilities.cs" />
+    <Compile Include="Evaluation\Conditionals\EqualExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\FunctionCallExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\GenericExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\GreaterThanExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\GreaterThanOrEqualExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\LessThanExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\LessThanOrEqualExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\MultipleComparisonExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\NotEqualExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\NotExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\NumericComparisonExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\NumericExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\OperandExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\OperatorExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\OrExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\Parser.cs" />
+    <Compile Include="Evaluation\Conditionals\Scanner.cs" />
+    <Compile Include="Evaluation\Conditionals\StringExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\Token.cs" />
     <Compile Include="Evaluation\EvaluatorMetadataTable.cs" />
     <Compile Include="Evaluation\IEvaluatorData.cs" />
     <Compile Include="Evaluation\IItem.cs" />
@@ -593,9 +517,7 @@
     <Compile Include="Instance\TaskRegistry.cs" />
     <!-- ######################## -->
     <Compile Include="Evaluation\LazyItemEvaluator.LazyItemOperation.cs" />
-    <Compile Include="Logging\BaseConsoleLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Logging\BaseConsoleLogger.cs" />
     <Compile Include="Logging\BinaryLogger\BinaryLogger.cs" />
     <Compile Include="Logging\BinaryLogger\BinaryLogRecordKind.cs" />
     <Compile Include="Logging\BinaryLogger\BinaryLogReplayEventSource.cs" />
@@ -605,39 +527,19 @@
     <Compile Include="Logging\BinaryLogger\BuildEventArgsReader.cs" />
     <Compile Include="Logging\BinaryLogger\BuildEventArgsWriter.cs" />
     <Compile Include="Logging\BinaryLogger\ProjectImportsCollector.cs" />
-    <Compile Include="Logging\ConsoleLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\DistributedLoggers\DistributedFileLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\DistributedLoggers\ConfigurableForwardingLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\NullCentralLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\LoggerDescription.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Logging\ConsoleLogger.cs" />
+    <Compile Include="Logging\DistributedLoggers\DistributedFileLogger.cs" />
+    <Compile Include="Logging\DistributedLoggers\ConfigurableForwardingLogger.cs" />
+    <Compile Include="Logging\NullCentralLogger.cs" />
+    <Compile Include="Logging\LoggerDescription.cs" />
     <Compile Include="Logging\OptimizedStringIndenter.cs" />
-    <Compile Include="Logging\ParallelLogger\ParallelLoggerHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\ParallelLogger\ParallelConsoleLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Logging\ParallelLogger\ParallelLoggerHelpers.cs" />
+    <Compile Include="Logging\ParallelLogger\ParallelConsoleLogger.cs" />
     <Compile Include="Logging\SimpleErrorLogger.cs" />
     <Compile Include="Logging\ParallelLogger\ConsoleOutputAligner.cs" />
-    <Compile Include="Logging\FileLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\LogFormatter.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\SerialConsoleLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Logging\FileLogger.cs" />
+    <Compile Include="Logging\LogFormatter.cs" />
+    <Compile Include="Logging\SerialConsoleLogger.cs" />
     <Compile Include="ObjectModelRemoting\DefinitionObjectsLinks\ProjectMetadataLink.cs" />
     <Compile Include="ObjectModelRemoting\DefinitionObjectsLinks\ProjectPropertyLink.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectElementContainerLink.cs" />
@@ -651,120 +553,87 @@
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectTargetElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectTaskElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskBodyElementLink.cs" />
-    <Compile Include="Resources\AssemblyResources.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Resources\Constants.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Resources\AssemblyResources.cs" />
+    <Compile Include="Resources\Constants.cs" />
     <Compile Include="Resources\MSBuildAssemblyFileVersion.cs" />
     <!-- ######################## -->
     <!-- ######################## -->
     <!-- ######################## -->
-    <Compile Include="Utilities\EngineFileUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Utilities\EngineFileUtilities.cs" />
     <Compile Include="Utilities\FileSpecMatchTester.cs" />
-    <Compile Include="Utilities\RegistryKeyWrapper.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Utilities\Utilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Utilities\RegistryKeyWrapper.cs" />
+    <Compile Include="Utilities\Utilities.cs" />
     <Compile Include="Utilities\SimpleVersion.cs" />
     <Compile Include="Xml\ProjectXmlUtilities.XmlElementChildIterator.cs" />
-    <Compile Include="Xml\ProjectXmlUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Xml\ProjectXmlUtilities.cs" />
     <Compile Include="Xml\XmlReaderExtension.cs" />
     <Compile Include="..\Shared\AssemblyLoadInfo.cs">
       <Link>SharedUtilities\AssemblyLoadInfo.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs">
       <Link>SharedUtilities\ReadOnlyEmptyDictionary.cs</Link>
     </Compile>
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <Link>SharedUtilities\AssemblyNameExtension.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\BuildEventFileInfo.cs">
       <Link>SharedUtilities\BuildEventFileInfo.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ConversionUtilities.cs">
       <Link>SharedUtilities\ConversionUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\FileDelegates.cs">
       <Link>SharedUtilities\FileDelegates.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <Link>Errors\ErrorUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\EscapingUtilities.cs">
       <Link>SharedUtilities\EscapingUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\VersionUtilities.cs">
       <Link>SharedUtilities\VersionUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\EventArgsFormatting.cs">
       <Link>SharedUtilities\EventArgsFormatting.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <Link>SharedUtilities\ExceptionHandling.cs</Link>
     </Compile>
     <Compile Include="..\Shared\FileMatcher.cs">
       <Link>SharedUtilities\FileMatcher.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>SharedUtilities\FileUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs" />
-    <Compile Include="..\Shared\Modifiers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\Modifiers.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>SharedUtilities\FileUtilitiesRegex.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\FrameworkLocationHelper.cs">
       <Link>SharedUtilities\FrameworkLocationHelper.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\IElementLocation.cs">
       <Link>SharedUtilities\IElementLocation.cs</Link>
     </Compile>
     <Compile Include="..\Shared\LoadedType.cs">
       <Link>SharedUtilities\LoadedType.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>InprocTrackingNativeMethods.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ProjectErrorUtilities.cs">
       <Link>Errors\ProjectErrorUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ProjectFileErrorUtilities.cs">
       <Link>Errors\ProjectFileErrorUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ProjectWriter.cs">
       <Link>SharedUtilities\ProjectWriter.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <Link>SharedUtilities\ResourceUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\Tracing.cs" />
     <Compile Include="..\Shared\CoreCLRAssemblyLoader.cs" Condition="'$(TargetFrameworkIdentifier)'!='.NETFramework'" />
@@ -779,15 +648,12 @@
     </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
       <Link>Resources\XMakeAttributes.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\XMakeElements.cs">
       <Link>Resources\XMakeElements.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\XmlUtilities.cs">
       <Link>SharedUtilities\XmlUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="Evaluation\LazyItemEvaluator.EvaluatorData.cs" />
 
@@ -804,4 +670,54 @@
       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>
     </EmbeddedResource>
   </ItemGroup>
+
+  <PropertyGroup>
+    <NuGetFrameworkWrapperRedirects_FilePath>$(IntermediateOutputPath)NuGetFrameworkWrapper.redirects.cs</NuGetFrameworkWrapperRedirects_FilePath>
+  </PropertyGroup>
+
+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->
+  <Target Name="GenerateAppDomainConfig"
+          Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config"
+          Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)"
+          BeforeTargets="CoreCompile"
+          Condition="'$(FeatureAppDomain)' == 'true'">
+    <PropertyGroup>
+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>
+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>
+    </PropertyGroup>
+
+    <XmlPeek XmlInputPath="..\MSBuild\app.config" Query="$(BindingRedirectXPath)" Namespaces="$(BindingRedirectNamespace)">
+      <Output TaskParameter="Result" ItemName="BindingRedirect32" />
+    </XmlPeek>
+    <XmlPeek XmlInputPath="..\MSBuild\app.amd64.config" Query="$(BindingRedirectXPath)" Namespaces="$(BindingRedirectNamespace)">
+      <Output TaskParameter="Result" ItemName="BindingRedirect64" />
+    </XmlPeek>
+
+    <PropertyGroup>
+      <NuGetFrameworkWrapperRedirects_Content><![CDATA[
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Evaluation%3B;
+
+[System.CodeDom.Compiler.GeneratedCode("GenerateAppDomainConfig", "1.0")]
+internal sealed partial class NuGetFrameworkWrapper
+{
+    private const string _bindingRedirect32 = """;@(BindingRedirect32);"""%3B;
+    private const string _bindingRedirect64 = """;@(BindingRedirect64);"""%3B;
+}
+]]>
+      </NuGetFrameworkWrapperRedirects_Content>
+    </PropertyGroup>
+
+    <WriteLinesToFile File="$(NuGetFrameworkWrapperRedirects_FilePath)" Overwrite="true" WriteOnlyWhenDifferent="true" Lines="$(NuGetFrameworkWrapperRedirects_Content)" />
+
+    <ItemGroup>
+      <Compile Remove="$(NuGetFrameworkWrapperRedirects_FilePath)" />
+      <Compile Include="$(NuGetFrameworkWrapperRedirects_FilePath)">
+        <Link>Utilities\NuGetFrameworkWrapper.redirects.cs</Link>
+      </Compile>
+      <FileWrites Include="$(NuGetFrameworkWrapperRedirects_FilePath)" />
+    </ItemGroup>
+  </Target>
 </Project>
diff --git a/src/Build/Microsoft.Build.pkgdef b/src/Build/Microsoft.Build.pkgdef
index 74546cfe4fe..5ade779232c 100644
--- a/src/Build/Microsoft.Build.pkgdef
+++ b/src/Build/Microsoft.Build.pkgdef
@@ -5,3 +5,27 @@
 "culture"="neutral"
 "oldVersion"="0.0.0.0-99.9.9.9"
 "newVersion"="15.1.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{F74A7C60-AC4A-4EC4-A8DB-1FE89FDB53CD}]
+"name"="BuildXL.Processes"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Processes.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{A038F286-A634-460D-9964-75465129EEF2}]
+"name"="BuildXL.Utilities.Core"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Utilities.Core.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{0EE5D593-1F73-4FA2-98D7-B347DFD50186}]
+"name"="BuildXL.Native"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Native.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
diff --git a/src/Build/Resources/AssemblyResources.cs b/src/Build/Resources/AssemblyResources.cs
index 19954b16396..0eca428e261 100644
--- a/src/Build/Resources/AssemblyResources.cs
+++ b/src/Build/Resources/AssemblyResources.cs
@@ -20,7 +20,7 @@ internal static class AssemblyResources
         private static ResourceManager s_msbuildExeResourceManager;
 
         /// <summary>
-        /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and 
+        /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and
         /// ResourceUtilities class that uses it. To make this possible, MSBuild.exe registers its resources here and they are
         /// normally consulted last. This assumes that there are no duplicated resource ID's between the Engine and MSBuild.exe.
         /// (Actually there are currently two: LoggerCreationError and LoggerNotFoundError.
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index ed2e16683ba..f6c7a968081 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -132,17 +132,17 @@ internal static class Constants
         internal const string VisualStudioVersionPropertyName = "VisualStudioVersion";
 
         /// <summary>
-        /// Name of the property used to select which sub-toolset to use. 
+        /// Name of the property used to select which sub-toolset to use.
         /// </summary>
         internal const string SubToolsetVersionPropertyName = VisualStudioVersionPropertyName;
 
         /// <summary>
-        /// Value we should be setting VisualStudioVersion as the ultimate fallback when Dev10 is installed. 
+        /// Value we should be setting VisualStudioVersion as the ultimate fallback when Dev10 is installed.
         /// </summary>
         internal const string Dev10SubToolsetValue = "10.0";
 
         /// <summary>
-        /// Current version of this MSBuild Engine assembly in the 
+        /// Current version of this MSBuild Engine assembly in the
         /// form, e.g, "4.0"
         /// </summary>
         internal static string AssemblyVersion
@@ -231,12 +231,12 @@ internal static Tuple<string, Type> GetValue(string key)
         }
 
         /// <summary>
-        /// Tries to retrieve the type information for a type name / method name combination. 
-        /// 
+        /// Tries to retrieve the type information for a type name / method name combination.
+        ///
         /// It does 2 lookups:
         /// 1st try: 'typeFullName'
         /// 2nd try: 'typeFullName::simpleMethodName'
-        /// 
+        ///
         /// </summary>
         /// <param name="typeFullName">namespace qualified type name</param>
         /// <param name="simpleMethodName">name of the method</param>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 3a046f4d554..632884ce86c 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -158,6 +158,12 @@
   <data name="BuildFinishedFailure" xml:space="preserve">
     <value>Build FAILED.</value>
   </data>
+  <data name="BuildFinishedQuestionFailure" xml:space="preserve">
+    <value>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</value>
+  </data>
+  <data name="BuildFinishedQuestionSuccess" xml:space="preserve">
+    <value>Question build succeeded. Up-to-date checks passed.</value>
+  </data>
   <data name="BuildFinishedSuccess" xml:space="preserve">
     <value>Build succeeded.</value>
   </data>
@@ -1883,7 +1889,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Property initial value: $({0})="{1}" Source: {2}</value>
   </data>
   <data name="NuGetAssemblyNotFound" xml:space="preserve">
-    <value>A required NuGet assembly was not found. Expected Path: {0}</value>
+    <value>A required NuGet assembly '{0}' could not be loaded.</value>
   </data>
   <data name="StaticGraphConstructionMetrics" xml:space="preserve">
     <value>Static graph loaded in {0} seconds: {1} nodes, {2} edges</value>
@@ -1906,6 +1912,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectCacheShutdownFailed" xml:space="preserve">
     <value>MSB4268: The project cache failed to shut down properly.</value>
   </data>
+  <data name="ProjectCacheHandleBuildResultFailed" xml:space="preserve">
+    <value>MSB4269: The project cache failed while handling a build result for the following project: {0}.</value>
+  </data>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
@@ -1984,6 +1993,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="TaskAssemblyLoaded" xml:space="preserve">
     <value>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</value>
   </data>
+  <data name="TaskAssemblyLoadedWithAssemblyLoadContext" xml:space="preserve">
+    <value>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</value>
+  </data>
   <data name="NodeReused" xml:space="preserve">
     <value>Reusing node {0} (PID: {1}).</value>
   </data>
@@ -1995,6 +2007,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>MSB4277: Cannot copy from object of that type.</value>
     <comment>{StrBegin="MSB4277: "}</comment>
   </data>
+  <data name="ReportFileAccessesX64Only" xml:space="preserve">
+    <value>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 0fb219fdd76..047911f93bf 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">Vytvoření otázky SELHALO. Vytváření bylo předčasně ukončeno, protože se při něm narazilo na cíl nebo úlohu, které nebyly aktuální.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">Otázka byla úspěšně vytvořena. Kontroly aktuálnosti proběhly úspěšně.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">Operaci nebylo možno dokončit, protože sestavení již probíhá.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Požadované sestavení NuGet se nenašlo. Očekávaná cesta: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">Požadované sestavení NuGet se nenašlo. Očekávaná cesta: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: Mezipaměť projektu vyvolala neošetřenou výjimku z metody {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Mezipaměť projektu selhala při zpracování výsledku sestavení pro následující projekt: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Přístup do mezipaměti projektu pro „{0}“ (výchozí cíle).</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: Zakázání uzlu inproc způsobí snížení výkonu při používání modulů plug-in mezipaměti projektu, které vysílají žádosti o sestavení proxy serveru.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Přístupy k souborům sestav se v současné době podporují jenom pomocí varianty x64 nástroje MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Selhání překladače sady SDK: {0}</target>
@@ -441,6 +461,11 @@
         <target state="translated">Sestavení načtené během {0}{1}: {2} (umístění: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Sestavení načteno během {0}{1}: {2} (umístění: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Úloha {0} uvolnila tento počet jader: {1}. Teď používá celkem tento počet jader: {2}</target>
@@ -1475,7 +1500,7 @@
       </trans-unit>
       <trans-unit id="SolutionVenusProjectSkipped">
         <source>Skipping because the "$(AspNetConfiguration)" configuration is not supported for this web project.  You can use the AspNetConfiguration property to override the configuration used for building web projects, by adding /p:AspNetConfiguration=&lt;value&gt; to the command line. Currently web projects only support Debug and Release configurations.</source>
-        <target state="translated">Vynecháno, protože konfigurace $(AspNetConfiguration) není pro tento webový projekt podporována. Pomocí vlastnosti AspNetConfiguration můžete přepsat konfiguraci používanou k sestavování webových projektů, a to přidáním příkazu /p:AspNetConfiguration=&lt;hodnota&gt; do příkazového řádku. Webové projekty nyní podporují pouze konfigurace Debug a Release.</target>
+        <target state="translated">Vynecháno, protože konfigurace "$(AspNetConfiguration)" není pro tento webový projekt podporována. Pomocí vlastnosti AspNetConfiguration můžete přepsat konfiguraci používanou k sestavování webových projektů, a to přidáním příkazu /p:AspNetConfiguration=&lt;hodnota&gt; do příkazového řádku. Webové projekty nyní podporují pouze konfigurace Debug a Release.</target>
         <note>
     UE: This is not an error, so doesn't need an error code.
     LOCALIZATION: Do NOT localize "AspNetConfiguration", "Debug", "Release".
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 34f2984b55a..9d40c5707dd 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">Fehler beim Erstellen der Frage. Der Build wurde früh beendet, da ein Ziel oder eine Aufgabe gefunden wurde, die nicht aktuell war.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">Die Frage wurde erfolgreich erstellt. Aktualitätsprüfungen bestanden.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">Der Vorgang kann nicht abgeschlossen werden, da bereits ein Buildvorgang stattfindet.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: Der Projektcache hat über die Methode {0} eine unbehandelte Ausnahme ausgelöst.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Fehler beim Verarbeiten eines Buildergebnisses für das folgende Projekt im Projektcache: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Projektcachetreffer für „{0}“ (Standardziele).</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: Das Deaktivieren des In-Process-Knotens führt zu Leistungseinbußen bei der Verwendung von Projektcache-Plug-Ins, die Proxybuildanforderungen ausgeben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Das Melden von Dateizugriffen wird derzeit nur mit der x64-Variante von MSBuild unterstützt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Fehler bei SDK-Resolver: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">Assembly während {0}{1} geladen: {2} (Speicherort: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Assembly während {0}{1} geladen: {2} (Speicherort: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Die Aufgabe "{0}" hat {1} Kerne freigegeben und belegt jetzt insgesamt {2} Kerne.</target>
@@ -467,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled
+        <target state="translated">Dies ist ein Ausnahmefehler in MSBuild. STIMMEN SIE EINEM VORHANDENEN ISSUE ZU, ODER ERSTELLEN SIE EIN NEUES ISSUE UNTER https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ad3fa5bce70..4ad2cedbfe7 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">La creación de la pregunta ha FALLADO. La creación finalizó antes de tiempo al encontrar un objetivo o tarea que no estaba actualizado.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">La creación de preguntas ha tenido éxito. Comprobaciones actualizadas superadas.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">La operación no se puede completar porque ya hay una compilación en curso.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">No se encontró un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">No se encontró un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: la caché del proyecto inició una excepción no controlada desde el método {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: error en la caché del proyecto al controlar un resultado de compilación para el siguiente proyecto: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Acierto de caché de proyecto para "{0}" (destinos predeterminados).</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: Al deshabilitar el nodo InProc, se degrada el rendimiento cuando use los complementos de caché de proyectos que emiten solicitudes de compilación de proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Los accesos a archivos de informes solo se admiten actualmente con el tipo x64 de MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Error del solucionador del SDK: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">Ensamblado cargado durante {0}{1}: {2} (ubicación: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Ensamblado cargado durante {0}{1}: {2}(ubicación: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tarea "{0}" liberó {1} núcleos y ahora retiene un total de {2} núcleos.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 62958ed7308..3c1431c28be 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">ÉCHEC de la génération de la question. La génération s’est arrêtée tôt, car elle a rencontré une cible ou une tâche qui n’était pas à jour.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">La génération de la question a réussi. Contrôles de mise à jour réussis.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">Impossible d'effectuer l'opération car une génération est déjà en cours.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attendu : {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">Un assembly NuGet obligatoire est introuvable. Chemin attendu : {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: le cache de projet a levé une exception non gérée à partir de la méthode {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: le cache du projet a échoué lors de la gestion d’un résultat de build pour le projet suivant : {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Le cache de projet a été atteint pour « {0} » (cibles par défaut).</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: la désactivation du nœud inproc entraîne une détérioration des performances lors de l’utilisation de plug-ins de cache de projet qui émettent des requêtes de build proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Les accès aux fichiers de création de rapports sont uniquement pris en charge à l’aide de la saveur x64 de MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Échec du Programme de Résolution SDK : «{0}»</target>
@@ -441,6 +461,11 @@
         <target state="translated">Assembly chargé pendant {0}{1}: {2} (emplacement : {3}, MVID : {4}, AppDomain : {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Assembly chargé pendant {0}{1} : {2} (emplacement : {3}, MVID : {4}, AssemblyLoadContext : {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tâche "{0}" a libéré {1} cœur. Elle détient désormais {2} cœurs au total.</target>
@@ -467,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Il s’agit d’une exception non gérée dans MSBuild –– VOTEZ POUR UN PROBLÈME EXISTANT OU ENTREZ UN NOUVEAU FICHIER À https://aka.ms/msbuild/unhandled.
+        <target state="translated">Il s’agit d’une exception non prise en charge dans MSBuild –– VOTEZ POUR UN PROBLÈME EXISTANT OU CRÉEZ-EN UN SUR https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index b78569055ff..af45d49d4d6 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">Compilazione della domanda NON RIUSCITA. La compilazione è terminata in anticipo perché è stata rilevata una destinazione o un'attività non aggiornata.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">Compilazione della domanda riuscita. Controlli aggiornati superati.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">Non è possibile completare l'operazione perché è già in corso una compilazione.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Un assembly NuGet obbligatorio non è stato trovato. Percorso previsto: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">Un assembly NuGet obbligatorio non è stato trovato. Percorso previsto: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: la cache del progetto ha generato un'eccezione non gestita dal metodo {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: errore della cache del progetto durante la gestione di un risultato di compilazione per il progetto seguente: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Riscontro nella cache del progetto per "{0}" (destinazioni predefinite).</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: la disabilitazione del nodo InProc porta a una riduzione del livello delle prestazioni quando si usano plug-in della cache del progetto che emettono richieste di compilazione proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Gli accessi ai file di report sono attualmente supportati solo con la versione x64 di MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: errore sistema di risoluzione SDK: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">Assembly caricato durante {0}{1}: {2} (percorso: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Assembly caricato durante {0}{1}: {2} (percorso: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">L'attività "{0}" ha rilasciato {1} core e ora contiene {2} core in totale.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 6b1cdb3452c..09f3ec01754 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">質問のビルドに失敗しました。ビルドは、最新ではないターゲットまたはタスクが検出されたため、早期に終了しました。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">質問のビルドに成功しました。最新状態のチェックに合格しました。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">ビルドは既に進行中であるため、操作を完了できません。</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">必要な NuGet アセンブリが見つかりませんでした。想定されるパス: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">必要な NuGet アセンブリが見つかりませんでした。想定されるパス: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: プロジェクト キャッシュが {0} メソッドで処理されていない例外が返されました。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: 次のプロジェクトのビルド結果を処理中にプロジェクト キャッシュが失敗しました: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" のプロジェクト キャッシュ ヒット (既定のターゲット)。</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: プロキシ・ビルド要求を出すプロジェクト キャッシュ プラグインを使用する場合、InProc ノードを無効にするとパフォーマンスが低下します。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">ファイル アクセスのレポートは、現在、MSBuild の x64 フレーバーを使用してのみサポートされています。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK リゾルバー エラー: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">{0}{1} 中にアセンブリが読み込まれました: {2} (場所: {3}、MVID: {4}、AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">{0}{1} 中にアセンブリが読み込まれました: {2} (場所: {3}、MVID: {4}、AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">タスク "{0}" では、{1} 個のコアを解放したため、現在合計 {2} 個のコアを保持しています。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 76064b46602..5f21196ef4c 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">질문 빌드에 실패했습니다. 빌드가 최신이 아닌 대상 또는 작업을 발견하여 일찍 종료되었습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">질문 빌드에 성공했습니다. 최신 검사를 통과했습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">빌드가 이미 진행되고 있으므로 작업을 완료할 수 없습니다.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">필요한 NuGet 어셈블리를 찾을 수 없습니다. 예상 경로: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">필요한 NuGet 어셈블리를 찾을 수 없습니다. 예상 경로: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: 프로젝트 캐시는 {0} 메서드에서 처리되지 않은 예외를 발생시켰습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: {0} 프로젝트에 대한 빌드 결과를 처리하는 동안 프로젝트 캐시가 실패했습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}"(기본 대상)에 대한 프로젝트 캐시 적중입니다.</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: 프록시 빌드 요청을 내보내는 프로젝트 캐시 플러그 인을 사용할 때 inproc 노드를 사용하지 않도록 설정하면 성능이 저하됩니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">파일 액세스 보고는 현재 x64 버전의 MSBuild를 사용하는 경우에만 지원됩니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK 해결 프로그램 오류: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">{0}{1} 동안 로드된 어셈블리: {2}(위치: {3}%1, MVID: {4}%2, AppDomain: {5}%2).</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">{0}{1} 동안 로드된 어셈블리: {2}(위치: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" 작업에서 코어 {1}개를 해제했고 지금 총 {2}개의 코어를 보유하고 있습니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index a4ea3f9b1d4..dafb394d614 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">NIEPOWODZENIE kompilacji pytania. Kompilacja została zakończona wcześniej, ponieważ napotkała element docelowy lub zadanie, które nie było aktualne.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">Pomyślnie skompilowano pytanie. Pomyślnie wykonano kontrole.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">Nie można zakończyć tej operacji, ponieważ trwa kompilacja.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ścieżki {0}.</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ścieżki {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: pamięć podręczna projektu zgłosiła nieobsługiwany wyjątek z metody {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: pamięć podręczna projektu nie powiodła się podczas obsługi wyniku kompilacji dla następującego projektu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Trafienie pamięci podręcznej projektu dla „{0}” (domyślne elementy docelowe).</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: wyłączenie węzła InProc prowadzi do obniżenia wydajności, gdy używane są wtyczki pamięci podręcznej projektu, które emitują żądania kompilowania serwera proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Raportowanie dostępu do plików jest obecnie obsługiwane tylko przy użyciu wersji x64 programu MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: niepowodzenia programu do rozpoznawania zestawu SDK: „{0}”</target>
@@ -441,6 +461,11 @@
         <target state="translated">Załadowano zestaw podczas {0}{1}: {2} (lokalizacja: {3}, MVID: {4}, domena aplikacji: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Załadowano zestaw podczas {0}{1}: {2} (lokalizacja: {3}, MVID: {4}, kontekst ładowania zestawu: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Zadanie „{0}” zwolniło rdzenie ({1}) i teraz jego łączna liczba rdzeni to {2}.</target>
@@ -467,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Jest to nieobsługiwany wyjątek w aplikacji MSBuild -- ZAGŁOSUJ NA ISTNIEJĄCY PROBLEM LUB ZAGŁOSUJ NA NOWY NA https://aka.ms/msbuild/unhandled.
+        <target state="translated">Jest to nieobsługiwany wyjątek na platformie MSBuild -- ZAGŁOSUJ NA ISTNIEJĄCY PROBLEM LUB ZAREJESTRUJ NOWY W WITRYNIE https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 6ca0dd891e9..c9b2d280391 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">FALHA na compilação da pergunta. A compilação foi encerrada antecipadamente ao se deparar com um alvo ou tarefa que não estava atualizado.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">Compilação de pergunta bem-sucedida. Verificações atualizadas aprovadas.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">A operação não pode ser concluída porque uma compilação está em andamento.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Um assembly NuGet necessário não foi encontrado. Caminho Esperado: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">Um assembly NuGet necessário não foi encontrado. Caminho Esperado: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: O cache do projeto lançou uma exceção sem tratamento do método {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: O cache do projeto falhou ao manipular um resultado de construção para o seguinte projeto: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Acerto de cache do projeto para "{0}" (destinos padrão).</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: desativar o nó inproc leva à degradação do desempenho ao usar plug-ins de cache de projeto que emitem solicitações de construção de proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Atualmente, o relatório de acessos a arquivos só tem suporte usando o tipo x64 do MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Falha no Resolvedor do SDK: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">Montagem carregada durante {0}{1}: {2} (localização: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Assembly carregado durante {0}{1}: {2} (local: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">A tarefa "{0}" liberou {1} núcleos e agora contém {2} núcleos no total.</target>
@@ -467,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Esta é uma exceção não tratada no MSBuild -- POR FAVOR, APOIE UM PROBLEMA EXISTENTE OU ARQUIVE UM NOVO EM https://aka.ms/msbuild/unhandled
+        <target state="translated">Essa é uma exceção não tratada no MSBuild -- POR FAVOR, ATUALIZE UMA QUESTÃO EXISTENTE OU ENCAMINHE UMA NOVA EM https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index d54d3bca5a4..42cc6134536 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">СБОЙ сборки вопроса. Выход из сборки выполнен раньше, так как была обнаружена цель или задача без обновления.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">Сборка вопроса успешно выполнена. Проверки актуальности пройдены.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">Не удалось завершить операцию, так как уже выполняется сборка.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Не найдена обязательная сборка NuGet. Ожидаемый путь: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">Не найдена обязательная сборка NuGet. Ожидаемый путь: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: в кэше проектов возникло необработанное исключение из метода {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: сбой кэша проекта при обработке результата сборки для следующего проекта: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Попадание в кэше проекта для "{0}" (целевые объекты по умолчанию).</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: Отключение внутрипроцессного узла приводит к замедлению при использовании плагинов кэша проекта, которые создают запросы на сборку прокси-сервера.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Доступ к файлам отчетов сейчас поддерживается только при использовании 64-разрядного варианта приложения MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: сбой сопоставителя SDK: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">Сборка загружена во время {0}{1}: {2} (расположение: {3}, MVID: {4}, домен приложения: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Сборка загружена во время {0}{1}: {2} (расположение: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Задача "{0}" освободила указанное число ядер ({1}). Теперь общее число ядер, которыми располагает задача, равно {2}.</target>
@@ -467,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Это необработанное исключение в MSBuild. Проголосуйте за существующую проблему или сообщите о новой по адресу https://aka.ms/msbuild/unhandled
+        <target state="translated">Это необработанное исключение в MSBuild. ПРОГОЛОСУЙТЕ ЗА СУЩЕСТВУЮЩУЮ ПРОБЛЕМУ ИЛИ СООБЩИТЕ О НОВУЙ НА https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 2d211d40f45..809c1d969fe 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">Soru derleme BAŞARISIZ oldu. Güncel olmayan bir hedef veya görev ile karşılaştığından derleme işleminden erken çıkıldı.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">Soru derleme başarılı oldu. Güncellik denetimleri başarılı oldu.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">Bir oluşturma zaten devam ettiği için işlem tamamlanamıyor.</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Gereken NuGet derlemesi bulunamadı. Beklenen Yol: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">Gereken NuGet derlemesi bulunamadı. Beklenen Yol: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: Proje önbelleği {0} yönteminden yakalanamayan özel durum oluşturdu.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Proje önbelleği şu proje için bir derleme sonucu işlenirken başarısız oldu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" (varsayılan hedefler) için proje önbelleği isabeti.</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: InProc düğümünün devre dışı bırakılması, ara sunucu oluşturma istekleri gönderen proje önbelleği eklentileri kullanılırken performans düşüşüne yol açar.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Raporlama dosyası erişimleri şu anda yalnızca MSBuild x64 varyantı kullanıldığında destekleniyor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK Çözümleyici Hatası: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">Derleme {0}{1} sırasında yüklendi: {2} (konum: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">Derleme {0}{1} sırasında yüklendi: {2} (konum: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" görevi {1} çekirdeği serbest bıraktı. Şu anda toplam {2} çekirdek tutuyor.</target>
@@ -467,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Bu, MSBuild'de işlenmeyen bir istisnadır -- LÜTFEN MEVCUT BİR SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESİNDE YENİ BİR SORUN DOSYALAYIN
+        <target state="translated">Bu, MSBuild'de işlenmeyen bir istisnadır -- LÜTFEN MEVCUT BİR SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESİNDE YENİ BİR SORUN OLUŞTURUN
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 1d2c6843628..89b16c2d43d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">问题生成失败。生成提前退出，因为遇到不是最新的目标或任务。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">问题生成成功。已通过最新检查。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">无法完成此操作，因为已经在进行某个生成。</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">未找到所需的 NuGet 程序集。所需路径: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">未找到所需的 NuGet 程序集。所需路径: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: 项目缓存从 {0} 方法引发了未经处理的异常。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: 处理以下项目的生成结果时，项目缓存失败: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">项目缓存命中 "{0}" (默认目标)。</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: 使用发出代理构建请求的项目缓存插件时，禁用 inproc 节点会导致性能下降。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">当前仅支持使用 x64 风格的 MSBuild 来报告文件访问情况。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK 解析程序失败: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">程序集加载期间 {0}{1}: {2} (位置: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">在 {0}{1} 期间加载的程序集: {2} (位置: {3}，MVID: {4}，AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">任务“{0}”发布了 {1} 个核心，现总共包含 {2} 个核心。</target>
@@ -2396,7 +2421,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="InvalidSdkFormat">
         <source>MSB4229: The value "{0}" is not valid for an Sdk specification. The attribute should be a semicolon-delimited list of Sdk-name/minimum-version pairs, separated by a forward slash.</source>
-        <target state="translated">MSB4229: 值“{0}”对 Sdk 规范无效。此属性应该是以分号分隔的Sdk-name/minimum-version 对（用正斜杠分隔）的列表。</target>
+        <target state="translated">MSB4229: 值“{0}”对 Sdk 规范无效。此属性应该是以分号分隔的Sdk-name/minimum-version 对 (用正斜杠分隔) 的列表。</target>
         <note>{StrBegin="MSB4229: "}</note>
       </trans-unit>
       <trans-unit id="TaskInstantiationFailureNotSupported">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index c073146888d..a28f9eadc87 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -26,6 +26,16 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="BuildFinishedQuestionFailure">
+        <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
+        <target state="translated">問題建立失敗。建置提早結束，因為它遇到不是最新的目標或工作。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinishedQuestionSuccess">
+        <source>Question build succeeded. Up-to-date checks passed.</source>
+        <target state="translated">問題建立成功。最新版本檢查已通過。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildInProgress">
         <source>The operation cannot be completed because a build is already in progress.</source>
         <target state="translated">無法完成作業，因為建置已經在進行中。</target>
@@ -212,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">找不到必要的 NuGet 元件。預期的路徑: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="needs-review-translation">找不到必要的 NuGet 元件。預期的路徑: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -264,6 +274,11 @@
         <target state="translated">MSB4273: 專案快取從 {0} 方法擲回未處理的例外狀況。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: 處理下列專案的組建結果時，專案快取失敗: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" 的專案快取命中 (預設目標)。</target>
@@ -370,6 +385,11 @@
         <target state="translated">MSB4274: 停用 inproc 節點會在使用可發出 proxy 組建要求的專案快取外掛程式時，導致效能降低。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">目前只支援使用 MSBuild 的 x64 變體來報告檔案存取。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK 解析程式失敗: "{0}"</target>
@@ -441,6 +461,11 @@
         <target state="translated">組件在 {0}{1} 期間載入: {2} (位置: {3}，MVID: {4}，AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="translated">組件在 {0}{1} 期間載入: {2} (位置: {3}，MVID: {4}，AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">工作 "{0}" 已發行 {1} 個核心，現在共保留 {2} 個核心。</target>
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 0c26f6e1a8b..5942dad9bad 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -193,7 +193,7 @@ private static string[] GetFileList(
 
             var noWildcards = !FilespecHasWildcards(filespecEscaped) || FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards);
 
-            // It is possible to return original string if no wildcard matches and no entries in Exclude set. 
+            // It is possible to return original string if no wildcard matches and no entries in Exclude set.
             if (noWildcards && excludeSpecsEscaped?.Any() != true)
             {
                 // Just return the original string.
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 367ef9ddf2b..0f5736349a8 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -16,47 +17,63 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// Wraps the NuGet.Frameworks assembly, which is referenced by reflection.
+    /// Wraps the NuGet.Frameworks assembly, which is referenced by reflection and optionally loaded into a separate AppDomain for performance.
     /// </summary>
-    internal class NuGetFrameworkWrapper
+    internal sealed partial class NuGetFrameworkWrapper
+#if FEATURE_APPDOMAIN
+        : MarshalByRefObject
+#endif
     {
+        private const string NuGetFrameworksAssemblyName = "NuGet.Frameworks";
+        private const string NuGetFrameworksFileName = NuGetFrameworksAssemblyName + ".dll";
+
         /// <summary>
-        /// NuGet Types
+        /// Methods, properties, and objects used from the NuGet.Frameworks assembly.
         /// </summary>
-        private static MethodInfo ParseMethod;
-        private static MethodInfo IsCompatibleMethod;
-        private static object DefaultCompatibilityProvider;
-        private static PropertyInfo FrameworkProperty;
-        private static PropertyInfo VersionProperty;
-        private static PropertyInfo PlatformProperty;
-        private static PropertyInfo PlatformVersionProperty;
-        private static PropertyInfo AllFrameworkVersionsProperty;
+        private MethodInfo ParseMethod;
+        private MethodInfo IsCompatibleMethod;
+        private object DefaultCompatibilityProvider;
+        private PropertyInfo FrameworkProperty;
+        private PropertyInfo VersionProperty;
+        private PropertyInfo PlatformProperty;
+        private PropertyInfo PlatformVersionProperty;
+        private PropertyInfo AllFrameworkVersionsProperty;
 
+        /// <summary>
+        /// Public constructor for cross-domain activation only. Use <see cref="CreateInstance"/> to instantiate.
+        /// </summary>
         public NuGetFrameworkWrapper()
+        { }
+
+        /// <summary>
+        /// Initialized this instance. May run in a separate AppDomain.
+        /// </summary>
+        /// <param name="assemblyName">The NuGet.Frameworks to be loaded or null to load by path.</param>
+        /// <param name="assemblyFilePath">The file path from which NuGet.Frameworks should be loaded of <paramref name="assemblyName"/> is null.</param>
+        public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
         {
-            // Resolve the location of the NuGet.Frameworks assembly
-            var assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
-                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
-                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
-            try
+            Assembly NuGetAssembly;
+            if (assemblyName != null)
             {
-                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
-                var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
-                var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
-                var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
-                ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
-                IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
-                DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
-                FrameworkProperty = NuGetFramework.GetProperty("Framework");
-                VersionProperty = NuGetFramework.GetProperty("Version");
-                PlatformProperty = NuGetFramework.GetProperty("Platform");
-                PlatformVersionProperty = NuGetFramework.GetProperty("PlatformVersion");
-                AllFrameworkVersionsProperty = NuGetFramework.GetProperty("AllFrameworkVersions");
+                // This will load the assembly into the default load context if possible, and fall back to LoadFrom context.
+                NuGetAssembly = Assembly.Load(assemblyName);
             }
-            catch
+            else
             {
-                throw new InternalErrorException(string.Format(AssemblyResources.GetString("NuGetAssemblyNotFound"), assemblyDirectory));
+                NuGetAssembly = Assembly.LoadFile(assemblyFilePath);
             }
+
+            var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
+            var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
+            var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
+            ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
+            IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
+            DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
+            FrameworkProperty = NuGetFramework.GetProperty("Framework");
+            VersionProperty = NuGetFramework.GetProperty("Version");
+            PlatformProperty = NuGetFramework.GetProperty("Platform");
+            PlatformVersionProperty = NuGetFramework.GetProperty("PlatformVersion");
+            AllFrameworkVersionsProperty = NuGetFramework.GetProperty("AllFrameworkVersions");
         }
 
         private object Parse(string tfm)
@@ -133,5 +150,99 @@ public string FilterTargetFrameworks(string incoming, string filter)
                 });
             }
         }
+
+#if FEATURE_APPDOMAIN
+        /// <summary>
+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.
+        /// </summary>
+        public override object InitializeLifetimeService() => null;
+
+        private static AppDomainSetup CreateAppDomainSetup(AssemblyName assemblyName, string assemblyPath)
+        {
+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();
+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);
+            for (int i = 0; i < publicKeyToken.Length; i++)
+            {
+                publicKeyTokenString.Append(publicKeyToken[i].ToString("x2", CultureInfo.InvariantCulture));
+            }
+
+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,
+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when
+            // NGENing MSBuild for the native images to be used.
+            string configuration = $"""
+<?xml version="1.0" encoding="utf-8"?>
+  <configuration>
+    <runtime>
+      <DisableFXClosureWalk enabled="true" />
+      <DeferFXClosureWalk enabled="true" />
+      <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
+        {(Environment.Is64BitProcess ? _bindingRedirect64 : _bindingRedirect32)}
+        <dependentAssembly>
+          <assemblyIdentity name="{NuGetFrameworksAssemblyName}" publicKeyToken="{publicKeyTokenString}" culture="{assemblyName.CultureName}" />
+          <codeBase version="{assemblyName.Version}" href="{assemblyPath}" />
+        </dependentAssembly>
+      </assemblyBinding>
+    </runtime>
+  </configuration>
+""";
+
+            AppDomainSetup appDomainSetup = AppDomain.CurrentDomain.SetupInformation;
+            appDomainSetup.SetConfigurationBytes(Encoding.UTF8.GetBytes(configuration));
+            return appDomainSetup;
+        }
+#endif
+
+        public static NuGetFrameworkWrapper CreateInstance()
+        {
+            // Resolve the location of the NuGet.Frameworks assembly
+            string assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
+                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
+                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
+
+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);
+
+            NuGetFrameworkWrapper instance = null;
+            AssemblyName assemblyName = null;
+#if FEATURE_APPDOMAIN
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) &&
+                (BuildEnvironmentHelper.Instance.RunningInMSBuildExe || BuildEnvironmentHelper.Instance.RunningInVisualStudio))
+            {
+                // If we are running in MSBuild.exe or VS, we can load the assembly with Assembly.Load, which enables
+                // the runtime to bind to the native image, eliminating some non-trivial JITting cost. Devenv.exe knows how to
+                // load the assembly by name. In MSBuild.exe, however, we don't know the version of the assembly statically so
+                // we create a separate AppDomain with the right binding redirects.
+                try
+                {
+                    assemblyName = AssemblyName.GetAssemblyName(assemblyPath);
+                    if (assemblyName != null && BuildEnvironmentHelper.Instance.RunningInMSBuildExe)
+                    {
+                        AppDomainSetup appDomainSetup = CreateAppDomainSetup(assemblyName, assemblyPath);
+                        if (appDomainSetup != null)
+                        {
+                            AppDomain appDomain = AppDomain.CreateDomain(nameof(NuGetFrameworkWrapper), null, appDomainSetup);
+                            instance = (NuGetFrameworkWrapper)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(NuGetFrameworkWrapper).FullName);
+                        }
+                    }
+                }
+                catch
+                {
+                    // If anything goes wrong just fall back to loading into current AD by path.
+                    instance = null;
+                    assemblyName = null;
+                }
+            }
+#endif
+            try
+            {
+                instance ??= new NuGetFrameworkWrapper();
+                instance.Initialize(assemblyName, assemblyPath);
+
+                return instance;
+            }
+            catch (Exception ex)
+            {
+                throw new InternalErrorException(string.Format(AssemblyResources.GetString("NuGetAssemblyNotFound"), assemblyDirectory), ex);
+            }
+        }
     }
 }
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index 32934034dee..ebe70f61d8c 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.Internal
 {
     /// <summary>
-    /// Thin wrapper around Microsoft.Win32.RegistryKey that can be 
+    /// Thin wrapper around Microsoft.Win32.RegistryKey that can be
     /// subclassed for testing purposes
     /// </summary>
     internal class RegistryKeyWrapper : IDisposable
@@ -92,7 +92,7 @@ public virtual string Name
         }
 
         /// <summary>
-        /// Convenient static helper method on RegistryKeyWrapper, for when someone is only intersted in knowing 
+        /// Convenient static helper method on RegistryKeyWrapper, for when someone is only intersted in knowing
         /// whether a particular registry key exists or not.
         /// </summary>
         public static bool KeyExists(string registryKeyPath, RegistryHive registryHive, RegistryView registryView)
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index 9ed8e0eb05d..f66c5bb3880 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -24,7 +24,7 @@ namespace Microsoft.Build.Utilities
     ///
     /// Ignores leading and trailing whitespace, but does not tolerate whitespace
     /// between components, unlike System.Version.
-    /// 
+    ///
     /// Also unlike System.Version, '+' is ignored as semver metadata as described
     /// above, not tolerated as positive sign of integer component.
     /// </summary>
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index c70d46dac78..67b454cc023 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -26,21 +26,21 @@ namespace Microsoft.Build.Internal
     internal static class Utilities
     {
         /// <summary>
-        /// Save off the contents of the environment variable that specifies whether we should treat higher toolsversions as the current 
+        /// Save off the contents of the environment variable that specifies whether we should treat higher toolsversions as the current
         /// toolsversion.  (Some hosts require this.)
         /// </summary>
         private static bool s_shouldTreatHigherToolsVersionsAsCurrent = (Environment.GetEnvironmentVariable("MSBUILDTREATHIGHERTOOLSVERSIONASCURRENT") != null);
 
         /// <summary>
-        /// Save off the contents of the environment variable that specifies whether we should treat all toolsversions, regardless of 
+        /// Save off the contents of the environment variable that specifies whether we should treat all toolsversions, regardless of
         /// whether they are higher or lower, as the current toolsversion.  (Some hosts require this.)
         /// </summary>
         private static bool s_shouldTreatOtherToolsVersionsAsCurrent = (Environment.GetEnvironmentVariable("MSBUILDTREATALLTOOLSVERSIONSASCURRENT") != null);
 
         /// <summary>
-        /// If set, default to the ToolsVersion from the project file (or if that doesn't isn't set, default to 2.0).  Otherwise, use Dev12+ 
-        /// defaulting logic: first check the MSBUILDDEFAULTTOOLSVERSION environment variable, then check for a DefaultOverrideToolsVersion, 
-        /// then if both fail, use the current ToolsVersion. 
+        /// If set, default to the ToolsVersion from the project file (or if that doesn't isn't set, default to 2.0).  Otherwise, use Dev12+
+        /// defaulting logic: first check the MSBUILDDEFAULTTOOLSVERSION environment variable, then check for a DefaultOverrideToolsVersion,
+        /// then if both fail, use the current ToolsVersion.
         /// </summary>
         private static bool s_uselegacyDefaultToolsVersionBehavior = (Environment.GetEnvironmentVariable("MSBUILDLEGACYDEFAULTTOOLSVERSION") != null);
 
@@ -56,10 +56,10 @@ internal static class Utilities
 
         /// <summary>
         /// INTERNAL FOR UNIT-TESTING ONLY
-        /// 
-        /// We've got several environment variables that we read into statics since we don't expect them to ever 
-        /// reasonably change, but we need some way of refreshing their values so that we can modify them for 
-        /// unit testing purposes. 
+        ///
+        /// We've got several environment variables that we read into statics since we don't expect them to ever
+        /// reasonably change, but we need some way of refreshing their values so that we can modify them for
+        /// unit testing purposes.
         /// </summary>
         internal static void RefreshInternalEnvironmentValues()
         {
@@ -94,7 +94,7 @@ internal static void SetXmlNodeInnerContents(XmlElementWithLocation node, string
                 }
             }
 
-            // The value does not contain valid XML markup.  Store it as text, so it gets 
+            // The value does not contain valid XML markup.  Store it as text, so it gets
             // escaped properly.
             node.InnerText = s;
         }
@@ -108,10 +108,10 @@ internal static string GetXmlNodeInnerContents(XmlElementWithLocation node)
         {
             // XmlNode.InnerXml gives back a string that consists of the set of characters
             // in between the opening and closing elements of the XML node, without doing any
-            // unescaping.  Any "strange" character sequences (like "<![CDATA[...]]>" will remain 
+            // unescaping.  Any "strange" character sequences (like "<![CDATA[...]]>" will remain
             // exactly so and will not be translated or interpreted.  The only modification that
             // .InnerXml will do is that it will normalize any Xml contained within.  This means
-            // normalizing whitespace between XML attributes and quote characters that surround XML 
+            // normalizing whitespace between XML attributes and quote characters that surround XML
             // attributes.  If PreserveWhitespace is false, then it will also normalize whitespace
             // between elements.
             //
@@ -138,19 +138,19 @@ internal static string GetXmlNodeInnerContents(XmlElementWithLocation node)
             // use ... InnerXml or InnerText.  There are two basic scenarios we care about.
             //
             // 1.)  The first scenario is that the user is trying to create a property whose
-            //      contents are actually XML.  That is to say that the contents may be written 
+            //      contents are actually XML.  That is to say that the contents may be written
             //      to a XML file, or may be passed in as a string to XmlDocument.LoadXml.
-            //      In this case, we would want to use XmlNode.InnerXml, because we DO NOT want 
-            //      character sequences to be unescaped.  If we did unescape them, then whatever 
+            //      In this case, we would want to use XmlNode.InnerXml, because we DO NOT want
+            //      character sequences to be unescaped.  If we did unescape them, then whatever
             //      XML parser tried to read in the stream as XML later on would totally barf.
             //
             // 2.)  The second scenario is the the user is trying to create a property that
             //      is just intended to be treated as a string.  That string may be very large
             //      and could contain all sorts of whitespace, carriage returns, special characters,
-            //      etc.  But in the end, it's just a big string.  In this case, whatever 
+            //      etc.  But in the end, it's just a big string.  In this case, whatever
             //      task is actually processing this string ... it's not going to know anything
             //      about character sequences such as &amp; and &lt;.  These character sequences
-            //      are specific to XML markup.  So, here we want to use XmlNode.InnerText so that 
+            //      are specific to XML markup.  So, here we want to use XmlNode.InnerText so that
             //      the character sequences get unescaped into their actual character before
             //      the string is passed to the task (or wherever else the property is used).
             //      Of course, if the string value of the property needs to contain characters
@@ -325,7 +325,7 @@ internal static string CreateToolsVersionListString(IEnumerable<Toolset> toolset
         }
 
         /// <summary>
-        /// Figure out what ToolsVersion to use to actually build the project with. 
+        /// Figure out what ToolsVersion to use to actually build the project with.
         /// </summary>
         /// <param name="explicitToolsVersion">The user-specified ToolsVersion (through e.g. /tv: on the command line)</param>
         /// <param name="toolsVersionFromProject">The ToolsVersion from the project file</param>
@@ -338,8 +338,8 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
         {
             string toolsVersionToUse = explicitToolsVersion;
 
-            // hosts may need to treat toolsversions later than the current one as the current one ... or may just 
-            // want to treat all toolsversions as though they're the current one, so give them that ability 
+            // hosts may need to treat toolsversions later than the current one as the current one ... or may just
+            // want to treat all toolsversions as though they're the current one, so give them that ability
             // through an environment variable
             if (s_shouldTreatOtherToolsVersionsAsCurrent)
             {
@@ -361,15 +361,15 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                     }
                 }
 
-                // If ToolsVersion has not either been explicitly set or been overridden via one of the methods 
+                // If ToolsVersion has not either been explicitly set or been overridden via one of the methods
                 // mentioned above
                 if (toolsVersionToUse == null)
                 {
-                    // We want to generate the ToolsVersion based on the legacy behavior if EITHER: 
-                    // - the environment variable (MSBUILDLEGACYDEFAULTTOOLSVERSION) is set 
-                    // - the current ToolsVersion doesn't actually exist.  This is extremely unlikely 
-                    //   to happen normally, but may happen in checked-in toolset scenarios, in which 
-                    //   case we want to make sure we're at least as tolerant as Dev11 was. 
+                    // We want to generate the ToolsVersion based on the legacy behavior if EITHER:
+                    // - the environment variable (MSBUILDLEGACYDEFAULTTOOLSVERSION) is set
+                    // - the current ToolsVersion doesn't actually exist.  This is extremely unlikely
+                    //   to happen normally, but may happen in checked-in toolset scenarios, in which
+                    //   case we want to make sure we're at least as tolerant as Dev11 was.
                     Toolset currentToolset = null;
 
                     if (getToolset != null)
@@ -377,11 +377,11 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                         currentToolset = getToolset(MSBuildConstants.CurrentToolsVersion);
                     }
 
-                    // if we want to do the legacy behavior, act as we did through Dev11:  
+                    // if we want to do the legacy behavior, act as we did through Dev11:
                     // - If project file defines a ToolsVersion that has a valid toolset associated with it, use that
                     // - Otherwise, if project file defines an invalid ToolsVersion, use the current ToolsVersion
-                    // - Otherwise, if project file does not define a ToolsVersion, use the default ToolsVersion (must 
-                    //   be "2.0" since 2.0 projects did not have a ToolsVersion field). 
+                    // - Otherwise, if project file does not define a ToolsVersion, use the default ToolsVersion (must
+                    //   be "2.0" since 2.0 projects did not have a ToolsVersion field).
                     if (s_uselegacyDefaultToolsVersionBehavior || (getToolset != null && currentToolset == null))
                     {
                         if (!String.IsNullOrEmpty(toolsVersionFromProject))
@@ -389,8 +389,8 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                             toolsVersionToUse = toolsVersionFromProject;
 
                             // If we can tell that the toolset specified in the project is not present
-                            // then we'll use the current version.  Otherwise, we'll assume our caller 
-                            // knew what it was doing. 
+                            // then we'll use the current version.  Otherwise, we'll assume our caller
+                            // knew what it was doing.
                             if (getToolset != null && getToolset(toolsVersionToUse) == null)
                             {
                                 toolsVersionToUse = MSBuildConstants.CurrentToolsVersion;
@@ -403,9 +403,9 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                     }
                     else
                     {
-                        // Otherwise, first check to see if the default ToolsVersion has been set in the environment.  
-                        // Ideally we'll check to make sure it's a valid ToolsVersion, but if we don't have the ability 
-                        // to do so, we'll assume the person who set the environment variable knew what they were doing. 
+                        // Otherwise, first check to see if the default ToolsVersion has been set in the environment.
+                        // Ideally we'll check to make sure it's a valid ToolsVersion, but if we don't have the ability
+                        // to do so, we'll assume the person who set the environment variable knew what they were doing.
                         if (!String.IsNullOrEmpty(s_defaultToolsVersionFromEnvironment))
                         {
                             if (getToolset == null || getToolset(s_defaultToolsVersionFromEnvironment) != null)
@@ -414,11 +414,11 @@ internal static string GenerateToolsVersionToUse(string explicitToolsVersion, st
                             }
                         }
 
-                        // Otherwise, check to see if the override default toolsversion from the toolset works.  Though 
-                        // it's attached to the Toolset, it's actually MSBuild version dependent, so any loaded Toolset 
-                        // should have the same one. 
+                        // Otherwise, check to see if the override default toolsversion from the toolset works.  Though
+                        // it's attached to the Toolset, it's actually MSBuild version dependent, so any loaded Toolset
+                        // should have the same one.
                         //
-                        // And if that doesn't work, then just fall back to the current ToolsVersion. 
+                        // And if that doesn't work, then just fall back to the current ToolsVersion.
                         if (toolsVersionToUse == null)
                         {
                             if (getToolset != null && currentToolset != null)
@@ -468,9 +468,9 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
 
             PropertyDictionary<ProjectPropertyInstance> environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(environmentVariablesBag.Count + 2);
 
-            // We set the MSBuildExtensionsPath variables here because we don't want to make them official 
-            // reserved properties; we need the ability for people to override our default in their 
-            // environment or as a global property.  
+            // We set the MSBuildExtensionsPath variables here because we don't want to make them official
+            // reserved properties; we need the ability for people to override our default in their
+            // environment or as a global property.
 
 #if !FEATURE_INSTALLED_MSBUILD
             string extensionsPath = BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
@@ -489,11 +489,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             string extensionsPath64 = extensionsPath;
             environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
 #else
-            // "MSBuildExtensionsPath64". This points to whatever the value of "Program Files" environment variable is on a 
+            // "MSBuildExtensionsPath64". This points to whatever the value of "Program Files" environment variable is on a
             // 64-bit machine, and is empty on a 32-bit machine.
             if (FrameworkLocationHelper.programFiles64 != null)
             {
-                // if ProgramFiles and ProgramFiles(x86) are the same, then this is a 32-bit box, 
+                // if ProgramFiles and ProgramFiles(x86) are the same, then this is a 32-bit box,
                 // so we only want to set MSBuildExtensionsPath64 if they're not
                 string extensionsPath64 = NativeMethodsShared.IsWindows
                                               ? Path.Combine(
@@ -505,9 +505,9 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
 #endif
 
 #if FEATURE_INSTALLED_MSBUILD
-            // MSBuildExtensionsPath:  The way this used to work is that it would point to "Program Files\MSBuild" on both 
+            // MSBuildExtensionsPath:  The way this used to work is that it would point to "Program Files\MSBuild" on both
             // 32-bit and 64-bit machines.  We have a switch to continue using that behavior; however the default is now for
-            // MSBuildExtensionsPath to always point to the same location as MSBuildExtensionsPath32. 
+            // MSBuildExtensionsPath to always point to the same location as MSBuildExtensionsPath32.
 
             bool useLegacyMSBuildExtensionsPathBehavior = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH"));
 
@@ -583,7 +583,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
         }
 
         /// <summary>
-        /// Extension to IEnumerable to get the count if it 
+        /// Extension to IEnumerable to get the count if it
         /// can be quickly gotten, otherwise 0.
         /// </summary>
         public static int FastCountOrZero(this IEnumerable enumerable)
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index d0cf997b9c7..bd14487bf55 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -64,7 +64,7 @@ private XmlReaderExtension(string file, bool loadAsReadOnly)
             }
             catch
             {
-                // GetXmlReader calls Read() to get Encoding and can throw. If it does, close 
+                // GetXmlReader calls Read() to get Encoding and can throw. If it does, close
                 // the streams as needed.
                 Dispose();
                 throw;
diff --git a/src/Deprecated/Conversion.UnitTests/OldVSProjectFileReader_Tests.cs b/src/Deprecated/Conversion.UnitTests/OldVSProjectFileReader_Tests.cs
index 1f71766cbd9..268e5d6c849 100644
--- a/src/Deprecated/Conversion.UnitTests/OldVSProjectFileReader_Tests.cs
+++ b/src/Deprecated/Conversion.UnitTests/OldVSProjectFileReader_Tests.cs
@@ -16,13 +16,13 @@
 namespace Microsoft.Build.UnitTests
 {
     /***************************************************************************
-     * 
+     *
      * Class:       OldVSProjectFileReader_Tests
      * Owner:       RGoel
-     * 
-     * This class contains the unit tests for the "OldVSProjectFileReader" class.  
+     *
+     * This class contains the unit tests for the "OldVSProjectFileReader" class.
      * See the comments in that class for a description of its purpose.
-     * 
+     *
      **************************************************************************/
     [TestClass]
     public class OldVSProjectFileReader_Tests
@@ -31,10 +31,10 @@ public class OldVSProjectFileReader_Tests
          *
          * Method:      OldVSProjectFileReader_Tests.CreateTemporaryProjectFile
          * Owner:       RGoel
-         * 
-         * Helper method which creates a temporary text file on disk with the 
+         *
+         * Helper method which creates a temporary text file on disk with the
          * specified contents.  Returns the temp filename as an [out] parameter.
-         * 
+         *
          **********************************************************************/
         private void CreateTemporaryProjectFile
             (
@@ -53,10 +53,10 @@ out string  projectFilename
          *
          * Method:      OldVSProjectFileReader_Tests.DeleteTemporaryProjectFile
          * Owner:       RGoel
-         * 
-         * Helper method to delete the temporary file created via 
+         *
+         * Helper method to delete the temporary file created via
          * "CreateTemporaryProjectFile".
-         * 
+         *
          **********************************************************************/
         private void DeleteTemporaryProjectFile
             (
@@ -70,28 +70,28 @@ string      projectFilename
          *
          * Method:      OldVSProjectFileReader_Tests.NoSpecialCharacters
          * Owner:       RGoel
-         * 
-         * Tests the OldVSProjectFileReader class, using a project file that 
+         *
+         * Tests the OldVSProjectFileReader class, using a project file that
          * does not contain any special characters.
-         * 
+         *
          **********************************************************************/
         [TestMethod]
-        public void NoSpecialCharacters 
+        public void NoSpecialCharacters
             (
             )
         {
             // The contents of the project file that we'll be testing.  Look at the
             // right side, for a cleaner copy without all the escaping.
-            string projectFileContents = 
+            string projectFileContents =
 
                 "<VisualStudioProject>\r\n" +                   //      <VisualStudioProject>
-                "\r\n" +                                        //      
+                "\r\n" +                                        //
                 "  <VisualBasic\r\n" +                          //        <VisualBasic
                 "    ProjectType = \"Local\"\r\n" +             //          ProjectType = "Local"
                 "    ProductVersion = \"7.10.3022\"\r\n" +      //          ProductVersion = "7.10.3022"
                 "  >\r\n" +                                     //        >
                 "  </VisualBasic>\r\n" +                        //        </VisualBasic>
-                "\r\n" +                                        //      
+                "\r\n" +                                        //
                 "</VisualStudioProject>\r\n";                   //      </VisualStudioProject>
 
             // Create a temp file on disk with the above contents.
@@ -161,7 +161,7 @@ public void NoSpecialCharacters
             // Read the next 20 characters into our buffer.
             charactersRead = reader.Read(characterBuffer, 0, 20);
 
-            // Read the next 20 characters into our buffer.  But actually, since 
+            // Read the next 20 characters into our buffer.  But actually, since
             // we're almost at the end of the file, we expect that only 7 characters
             // will actually be read.
             charactersRead = reader.Read(characterBuffer, 0, 20);
@@ -180,34 +180,34 @@ public void NoSpecialCharacters
             this.DeleteTemporaryProjectFile(projectFilename);
         }
 
-        
+
         /***********************************************************************
          *
          * Method:      OldVSProjectFileReader_Tests.XmlAttributesWithSpecialCharacters
          * Owner:       RGoel
-         * 
-         * Tests the OldVSProjectFileReader class, using a project file that 
+         *
+         * Tests the OldVSProjectFileReader class, using a project file that
          * contains special characters in some of the XML attribute values.
-         * 
+         *
          **********************************************************************/
         [TestMethod]
-        public void XmlAttributesWithSpecialCharacters 
+        public void XmlAttributesWithSpecialCharacters
             (
             )
         {
             // The contents of the project file that we'll be testing.  Look at the
             // right side, for a cleaner copy without all the escaping.
-            string projectFileContents = 
+            string projectFileContents =
 
                 "<VisualStudioProject>\r\n" +                   //      <VisualStudioProject>
-                "\r\n" +                                        //      
+                "\r\n" +                                        //
                 "  <VisualBasic\r\n" +                          //        <VisualBasic
                 "    ProjectType = \"Lo<cal\"\r\n" +            //          ProjectType = "Lo<cal"
                 "    ProductVersion = \"7<.10.>3022\"\r\n" +    //          ProductVersion = "7<.10.>3022"
                 "    A=\"blah>\" B=\"bloo<\"\r\n" +             //          A="blah>" B="bloo<"
                 "  >\r\n" +                                     //        >
                 "  </VisualBasic>\r\n" +                        //        </VisualBasic>
-                "\r\n" +                                        //      
+                "\r\n" +                                        //
                 "</VisualStudioProject>\r\n";                   //      </VisualStudioProject>
 
             // Create a temp file on disk with the above contents.
@@ -246,7 +246,7 @@ public void XmlAttributesWithSpecialCharacters
             // Read the remainder of the file.  Confirm that the < and > characters within
             // an attribute value got translated correctly.
             string restOfFile = reader.ReadToEnd();
-            Assert.AreEqual("10.&gt;3022\"\r\n    A=\"blah&gt;\" B=\"bloo&lt;\"\r\n  >\r\n  </VisualBasic>\r\n\r\n</VisualStudioProject>\r\n", 
+            Assert.AreEqual("10.&gt;3022\"\r\n    A=\"blah&gt;\" B=\"bloo&lt;\"\r\n  >\r\n  </VisualBasic>\r\n\r\n</VisualStudioProject>\r\n",
                 restOfFile);
 
             // Clean up.
@@ -258,12 +258,12 @@ public void XmlAttributesWithSpecialCharacters
          *
          * Method:      OldVSProjectFileReader_Tests.MultipleElementsOnSameLine
          * Owner:       RGoel
-         * 
-         * Tests the OldVSProjectFileReader class, using a project file that 
-         * contains multiple XML elements with attributes on the same line.  
+         *
+         * Tests the OldVSProjectFileReader class, using a project file that
+         * contains multiple XML elements with attributes on the same line.
          * This will actually never happen in a real VS7/Everett project file,
          * but it's good to test it anyway.
-         * 
+         *
          **********************************************************************/
         [TestMethod]
         public void MultipleElementsOnSameLine
@@ -272,7 +272,7 @@ public void MultipleElementsOnSameLine
         {
             // The contents of the project file that we'll be testing.  Look at the
             // right side, for a cleaner copy without all the escaping.
-            string projectFileContents = 
+            string projectFileContents =
 
                 "<Elem1 Attrib1=\"bl>>ah\"/><Elem2 Attrib2=\"bl<<oo\"/>";  //  <Elem1 Attrib1="bl>>ah"/><Elem2 Attrib2="bl<<oo"/>
 
@@ -287,7 +287,7 @@ public void MultipleElementsOnSameLine
             // an attribute value got translated correctly, but the < and > characters occurring
             // *outside* an attribute value are not touched.
             string wholeFile = reader.ReadToEnd();
-            Assert.AreEqual("<Elem1 Attrib1=\"bl&gt;&gt;ah\"/><Elem2 Attrib2=\"bl&lt;&lt;oo\"/>\r\n", 
+            Assert.AreEqual("<Elem1 Attrib1=\"bl&gt;&gt;ah\"/><Elem2 Attrib2=\"bl&lt;&lt;oo\"/>\r\n",
                 wholeFile);
 
             // Clean up.
@@ -307,7 +307,7 @@ public void AttributeValueUsingSingleQuotes
             )
         {
             // The contents of the project file that we'll be testing.
-            string projectFileContents = 
+            string projectFileContents =
                 "<Elem1 Attrib1 = '1234<56789 is a \"true\" statement'/>";
 
             // Create a temp file on disk with the above contents.
@@ -321,7 +321,7 @@ public void AttributeValueUsingSingleQuotes
             // an attribute value got translated correctly, but the < and > characters occurring
             // *outside* an attribute value are not touched.
             string wholeFile = reader.ReadToEnd();
-            Assert.AreEqual("<Elem1 Attrib1 = '1234&lt;56789 is a \"true\" statement'/>\r\n", 
+            Assert.AreEqual("<Elem1 Attrib1 = '1234&lt;56789 is a \"true\" statement'/>\r\n",
                 wholeFile);
 
             // Clean up.
@@ -416,7 +416,7 @@ public void Regress322573
             )
         {
             // The contents of the project file that we'll be testing.
-            string projectFileContents = 
+            string projectFileContents =
                 "<Elem1 StartArguments = \"???action=16&requestid=1000036&#14CA053601F66928BF0550E395A714E72C8D6066???  /HeadTraxStartversion 5.6.0.66 /RunningFromHeadTraxStart yes /HTXMutexName HTXMutex344\"/>";
 
             // Create a temp file on disk with the above contents.
@@ -429,7 +429,7 @@ public void Regress322573
             // Read the whole file into a string.  Confirm that the & character within
             // an attribute value got translated correctly.
             string wholeFile = reader.ReadToEnd();
-            Assert.AreEqual("<Elem1 StartArguments = \"???action=16&amp;requestid=1000036&amp;#14CA053601F66928BF0550E395A714E72C8D6066???  /HeadTraxStartversion 5.6.0.66 /RunningFromHeadTraxStart yes /HTXMutexName HTXMutex344\"/>\r\n", 
+            Assert.AreEqual("<Elem1 StartArguments = \"???action=16&amp;requestid=1000036&amp;#14CA053601F66928BF0550E395A714E72C8D6066???  /HeadTraxStartversion 5.6.0.66 /RunningFromHeadTraxStart yes /HTXMutexName HTXMutex344\"/>\r\n",
                 wholeFile);
 
             // Clean up.
@@ -457,7 +457,7 @@ public void Regress184573()
             // Instantiate our class with the project file.
             OldVSProjectFileReader reader = new OldVSProjectFileReader(projectFilename);
 
-            // Read the whole file into a string.  
+            // Read the whole file into a string.
             string wholeFile = reader.ReadToEnd();
             Assert.IsTrue(wholeFile.Length > 0, "High-bit character was stripped.");
 
@@ -484,7 +484,7 @@ public void Regress184573()
         }
 
         /// <summary>
-        /// Tests that a single ampersand replacement works correctly at the beginning of 
+        /// Tests that a single ampersand replacement works correctly at the beginning of
         /// a string, middle of a string, and end of a string.
         /// </summary>
         [TestMethod]
diff --git a/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs b/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
index 64fd843cc3b..c2992c6631c 100644
--- a/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
+++ b/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
@@ -86,13 +86,13 @@ internal static void ConvertAndCompare
     }
 
     /***************************************************************************
-     * 
+     *
      * Class:        ProjectFileConverter_Tests
      * Owner:       jomof
-     * 
-     * This class contains the unit tests for the " ProjectFileConverter" class.  
+     *
+     * This class contains the unit tests for the " ProjectFileConverter" class.
      * See the comments in that class for a description of its purpose.
-     * 
+     *
      **************************************************************************/
     [TestClass]
     public class  ProjectFileConverter_Tests
@@ -101,15 +101,15 @@ public class  ProjectFileConverter_Tests
          *
          * Method:   ProjectFileConverter_Tests.MakeRelativeWithHash
          * Owner:    jomof
-         * 
-         * Test where paths with '#' in them can be converted into relative 
+         *
+         * Test where paths with '#' in them can be converted into relative
          * paths
-         * 
+         *
          **********************************************************************/
         [TestMethod]
         public void MakeRelativeWithHash()
         {
-            // Intentionally making the paths not the same case, because this should be irrelevant.            
+            // Intentionally making the paths not the same case, because this should be irrelevant.
             string path1 = @"D:\Public\Samples\Visual J# .NET 2003\Crosslanguage\Copy (8) of TilePuzzle\TileDriver\TileDriver.vcproj";
             string path2 = @"D:\public\Samples\Visual J# .NET 2003\Crosslanguage\Copy (8) of TilePuzzle\PUZZLE.vjsproj";
 
@@ -118,15 +118,15 @@ public void MakeRelativeWithHash()
 
             Assert.AreEqual(@"TileDriver\TileDriver.vcproj", rel);
         }
-        
+
         /***********************************************************************
          *
          * Method:   ProjectFileConverter_Tests.MakeRelativeWithSpace
          * Owner:    RGoel
-         * 
+         *
          * Test where paths where the relative path ends up having a <space> in
          * it.
-         * 
+         *
          **********************************************************************/
         [TestMethod]
         public void MakeRelativeWithSpace()
@@ -401,7 +401,7 @@ public void RemoveReferencesToEmptyResxPerBug248965()
         public void VbConversionWithMyTypeAlreadySet()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
                 <VisualStudioProject>
@@ -607,7 +607,7 @@ public void VbConversionWithMyTypeAlreadySet()
         public void ConvertTrinityWithOfficeDocumentFile()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
                 <VisualStudioProject>
@@ -877,11 +877,11 @@ public void ConvertTrinityWithOfficeDocumentFile()
                     </ItemGroup>
                     <ProjectExtensions>
                         <VisualStudio>
-                            <UserProperties 
-                                OfficeDocumentPath=`.\EXCELPROJECT1.XLS` 
-                                OfficeProjectType=`XLS` 
-                                OfficeProject=`true` 
-                                TrustedAssembly=`c:\rajeev_temp_deleteme\ExcelProject1\ExcelProject1_bin\ExcelProject1.dll` 
+                            <UserProperties
+                                OfficeDocumentPath=`.\EXCELPROJECT1.XLS`
+                                OfficeProjectType=`XLS`
+                                OfficeProject=`true`
+                                TrustedAssembly=`c:\rajeev_temp_deleteme\ExcelProject1\ExcelProject1_bin\ExcelProject1.dll`
                              />
                         </VisualStudio>
                     </ProjectExtensions>
@@ -905,7 +905,7 @@ public void ConvertTrinityWithOfficeDocumentFile()
         public void ConvertEmptyFolders()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
 
@@ -1183,7 +1183,7 @@ public void ConvertP2PReference()
 
         /// <summary>
         /// This is to test that we convert Everett projects that are part of solutions including
-        /// VC++ projects. 
+        /// VC++ projects.
         /// </summary>
         [TestMethod]
         public void ConvertProjectWithVCInSolutionAndP2Ps()
@@ -1357,7 +1357,7 @@ public void ConvertProjectWithVCInSolutionAndP2Ps()
             File.Delete(everettProjectFile);
             File.Delete(everettSolutionFile);
         }
-        
+
         /// <summary>
         /// This is to test that we convert P2P references correctly by looking up the
         /// referenced project in the given .SLN file.  Force the conversion code to
@@ -1436,7 +1436,7 @@ public void ConvertP2PReferenceSearchForSolution()
             // **********************************************
             //                   EVERETT SOLUTION
             // **********************************************
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"WindowsApplication1.sln", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"WindowsApplication1.sln",
 
                 @"Microsoft Visual Studio Solution File, Format Version 8.00
                 Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `WindowsApplication1`, `Project\WindowsApplication1.csproj`, `{77E21864-797C-4220-974E-530BB832801B}`
@@ -1472,7 +1472,7 @@ public void ConvertP2PReferenceSearchForSolution()
             // **********************************************
             //                   RANDOM OTHER SOLUTION
             // **********************************************
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Project\Random.sln", 
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(@"Project\Random.sln",
 
                 @"Microsoft Visual Studio Solution File, Format Version 8.00
                 Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `ClassLibrary2`, `ClassLibrary2\ClassLibrary2.csproj`, `{11111111-9E5C-4FE8-BE84-96F37D47F45A}`
@@ -1553,10 +1553,10 @@ public void ConvertP2PReferenceSearchForSolution()
 
             Helpers.CompareProjectXml(whidbeyProjectContents, project.RawXml);
         }
-        
+
         /// <summary>
         /// This is a test for bug VSWhidbey 472064.  We are making sure that if DebugSymbols is true in
-        /// the original project file, then we also emit DebugType to the whidbey project file.  We also 
+        /// the original project file, then we also emit DebugType to the whidbey project file.  We also
         /// emit ErrorReport = prompt to the whidbey project file if the language is C#
         /// </summary>
         /// <owner>FaisalMo</owner>
@@ -1564,12 +1564,12 @@ public void ConvertP2PReferenceSearchForSolution()
         public void ConvertEverettProjectWithNoDebugInfoFlag()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
                 <VisualStudioProject>
                     <CSHARP
-                        ProjectType = `Local`                        
+                        ProjectType = `Local`
                         SchemaVersion = `2.0`
                         ProjectGuid = `{172D0AFF-7BF3-4297-8168-792C46DC89DD}`
                     >
@@ -1776,12 +1776,12 @@ public void ConvertEverettProjectWithNoDebugInfoFlag()
         public void ConvertEverettProjectWithSpecialCharaceters()
         {
             // **********************************************
-            //                   EVERETT 
+            //                   EVERETT
             // **********************************************
             string everettProjectContents = @"
                 <VisualStudioProject>
                     <CSHARP
-                        ProjectType = `Local`                        
+                        ProjectType = `Local`
                         SchemaVersion = `2.0`
                         ProjectGuid = `{172D0AFF-7BF3-4297-8168-792C46DC89DD}`
                     >
@@ -1989,9 +1989,9 @@ public void ConvertEverettProjectWithSpecialCharaceters()
         }
 
         /// <summary>
-        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains 
-        /// references to v3.5 and before VC projects (.vcproj), convert that reference to 
-        /// instead reference a .vcxproj of the same name. 
+        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains
+        /// references to v3.5 and before VC projects (.vcproj), convert that reference to
+        /// instead reference a .vcxproj of the same name.
         /// </summary>
         [TestMethod]
         public void ConvertVCProjectReferenceExtensions()
@@ -2016,9 +2016,9 @@ public void ConvertVCProjectReferenceExtensions()
         }
 
         /// <summary>
-        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains 
-        /// references to v3.5 and before VC projects (.vcproj), convert that reference to 
-        /// instead reference a .vcxproj of the same name. 
+        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains
+        /// references to v3.5 and before VC projects (.vcproj), convert that reference to
+        /// instead reference a .vcxproj of the same name.
         /// </summary>
         [TestMethod]
         public void ConvertVCProjectReferenceExtensionsWildcard()
@@ -2043,9 +2043,9 @@ public void ConvertVCProjectReferenceExtensionsWildcard()
         }
 
         /// <summary>
-        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains 
-        /// references to v3.5 and before VC projects (.vcproj), convert that reference to 
-        /// instead reference a .vcxproj of the same name. 
+        /// Dev10 Bug 557388: When converting a project to v4.0, if the project contains
+        /// references to v3.5 and before VC projects (.vcproj), convert that reference to
+        /// instead reference a .vcxproj of the same name.
         /// </summary>
         [TestMethod]
         public void ConvertVCProjectReferenceExtensionsTrimNeeded()
@@ -2309,7 +2309,7 @@ public void ConvertFSharpOrcasProjectFile()
                     <Compile Include=""Program.fs"" />
                   </ItemGroup>
                   <Import Project=""$(MSBuildExtensionsPath)\FSharp\1.0\Microsoft.FSharp.Targets"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2378,7 +2378,7 @@ public void ConvertFSharpOrcasProjectFile()
                     </Otherwise>
                   </Choose>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2442,7 +2442,7 @@ public void ConvertDev11PortableLibraryProjectFile()
                     <MinimumVisualStudioVersion Condition=""'$(MinimumVisualStudioVersion)' == ''"">11</MinimumVisualStudioVersion>
                   </PropertyGroup>
                   <Import Project=""$(MSBuildExtensionsPath32)\..\Microsoft SDKs\F#\3.0\Framework\v4.0\Microsoft.Portable.FSharp.Targets"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -2513,7 +2513,7 @@ public void ConvertDev11PortableLibraryProjectFile()
                     </Otherwise>
                   </Choose>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -2528,7 +2528,7 @@ public void ConvertDev11PortableLibraryProjectFile()
 
         [TestMethod]
         public void ConvertDev12PortableLibraryProjectFileShouldBeNoOp()
-        { 
+        {
             string asDev12ProjectFile = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion=""msbuilddefaulttoolsversion"" DefaultTargets=""Build"" xmlns=""msbuildnamespace"">
                   <Import Project=""$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props"" Condition=""Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')"" />
@@ -2581,7 +2581,7 @@ public void ConvertDev12PortableLibraryProjectFileShouldBeNoOp()
                     <FSharpTargetsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\FSharp\Microsoft.Portable.FSharp.Targets</FSharpTargetsPath>
                   </PropertyGroup>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -2646,7 +2646,7 @@ public void ConvertFSharpDev10ProjectFile()
                   </ItemGroup>
                   <Import Project=""$(MSBuildExtensionsPath32)\FSharp\1.0\Microsoft.FSharp.Targets"" Condition=""!Exists('$(MSBuildBinPath)\Microsoft.Build.Tasks.v4.0.dll')"" />
                   <Import Project=""$(MSBuildExtensionsPath32)\..\Microsoft F#\v4.0\Microsoft.FSharp.Targets"" Condition="" Exists('$(MSBuildBinPath)\Microsoft.Build.Tasks.v4.0.dll')"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2718,7 +2718,7 @@ public void ConvertFSharpDev10ProjectFile()
                     </Otherwise>
                   </Choose>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2785,7 +2785,7 @@ public void ConvertFSharpDev10ProjectFileWithMinVS()
                   </PropertyGroup>
                   <Import Project=""$(MSBuildExtensionsPath32)\FSharp\1.0\Microsoft.FSharp.Targets"" Condition=""!Exists('$(MSBuildBinPath)\Microsoft.Build.Tasks.v4.0.dll')"" />
                   <Import Project=""$(MSBuildExtensionsPath32)\..\Microsoft F#\v4.0\Microsoft.FSharp.Targets"" Condition="" Exists('$(MSBuildBinPath)\Microsoft.Build.Tasks.v4.0.dll')"" />
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2859,7 +2859,7 @@ public void ConvertFSharpDev10ProjectFileWithMinVS()
                     </Otherwise>
                   </Choose>
                   <Import Project=""$(FSharpTargetsPath)"" Condition=""Exists('$(FSharpTargetsPath)')""/>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                          Other similar extension points exist, see Microsoft.Common.targets.
                     <Target Name=""BeforeBuild"">
                     </Target>
@@ -2870,7 +2870,7 @@ public void ConvertFSharpDev10ProjectFileWithMinVS()
                 ";
             Helpers.ConvertAndCompare(sampleFSharpDev10ProjectFile, asDev11ProjectFile);
         }
-        
+
         [TestMethod]
         public void ConvertFSharpDev11ProjectFile()
         {
@@ -2923,7 +2923,7 @@ public void ConvertFSharpDev11ProjectFile()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -2996,7 +2996,7 @@ public void ConvertFSharpDev11ProjectFile()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -3062,7 +3062,7 @@ public void ConvertFSharpDev11ProjectFileWithCustomFSharpCoreLocation()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -3134,7 +3134,7 @@ public void ConvertFSharpDev11ProjectFileWithCustomFSharpCoreLocation()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -3202,7 +3202,7 @@ public void ConvertFSharpDev12ProjectFileShouldBeNoOp()
                     <Reference Include=""System.Core"" />
                     <Reference Include=""System.Numerics"" />
                   </ItemGroup>
-                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+                  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
                        Other similar extension points exist, see Microsoft.Common.targets.
                   <Target Name=""BeforeBuild"">
                   </Target>
@@ -3279,7 +3279,7 @@ public void ConvertWFProjectFile()
                   </ItemGroup>
                   <Import Project=""$(MSBuildBinPath)\Microsoft.CSharp.Targets"" />
                   <Import Project=""$(MSBuildExtensionsPath)\Microsoft\Windows Workflow Foundation\v3.0\Workflow.Targets"" />
-                </Project>                
+                </Project>
                     ";
             string wfDev10ProjectFile = ObjectModelHelpers.CleanupFileContents(@"
                     <Project DefaultTargets=""Build"" xmlns=""msbuildnamespace"" ToolsVersion=""msbuilddefaulttoolsversion"">
@@ -3655,7 +3655,7 @@ public void ConvertVB2008RepairRequired()
   </ItemGroup>
   <Import Project=""$(MSBuildBinPath)\Microsoft.VisualBasic.targets"" />
   <Import Project=""$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v9.0\WebApplications\Microsoft.WebApplication.targets"" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name=""BeforeBuild"">
   </Target>
@@ -3844,7 +3844,7 @@ public void ConvertVB2008RepairRequired()
   <Import Project=""$(MSBuildBinPath)\Microsoft.VisualBasic.targets"" />
   <Import Project=""$(VSToolsPath)\WebApplications\Microsoft.WebApplication.targets"" Condition=""'$(VSToolsPath)' != ''"" />
   <Import Project=""$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\WebApplications\Microsoft.WebApplication.targets"" Condition=""false"" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name=""BeforeBuild"">
   </Target>
@@ -5307,7 +5307,7 @@ public void ConvertVB2005ConversionRequired()
                           <LastGenOutput>Settings.Designer.vb</LastGenOutput>
                         </None>
                       </ItemGroup>
-                    </Project>  
+                    </Project>
                     ");
 
             Helpers.ConvertAndCompare(ProjectBefore, ProjectAfter);
@@ -5319,7 +5319,7 @@ public void ConvertVB2005ConversionRequired()
         [TestMethod]
         public void ConvertCS2005ExcelProjectConversionRequired()
         {
-            string projectBefore = 
+            string projectBefore =
                     @" <VisualStudioProject>
                         <CSHARP
                             ProjectType = ""Local""
@@ -5668,9 +5668,9 @@ public void CheckForReferencesReplacements()
         /// Check that when we're upgrading projects referencing and compiling .xaml source files
         /// we are correctly appending Generator and Subtype properties to the source file and not the
         /// reference
-        /// 
+        ///
         /// Check also that project references to vcproj have their extensions fixed to .vcxproj
-        /// 
+        ///
         /// Lastly, make sure that this still happens even if the ToolsVersion is > 3.5.
         /// </summary>
         [TestMethod]
@@ -5735,7 +5735,7 @@ public void CheckForReferencesReplacements_NewerToolsVersion()
 
         /// <summary>
         /// Check that when we're upgrading projects referencing and compiling .xaml source files
-        /// that we don't append the Generator and SubType properties to the source file if they 
+        /// that we don't append the Generator and SubType properties to the source file if they
         /// are already set.
         /// </summary>
         [TestMethod]
@@ -5806,8 +5806,8 @@ public void DoNotReplacePreExistingXamlProperties()
 
         /// <summary>
         /// Check that when we're upgrading projects referencing and compiling .xaml source files
-        /// that even if there are multiple instances of the metadata, we don't eliminate them -- 
-        /// we just also don't add any more. 
+        /// that even if there are multiple instances of the metadata, we don't eliminate them --
+        /// we just also don't add any more.
         /// </summary>
         [TestMethod]
         public void DontEliminateDuplicateXamlProperties()
@@ -5901,8 +5901,8 @@ public void DontEliminateDuplicateXamlProperties()
 
         /// <summary>
         /// Check that when we're upgrading projects referencing and compiling .xaml source files
-        /// that already have Generator and Subtype metadata, we don't make any changes and 
-        /// don't update the ToolsVersion. 
+        /// that already have Generator and Subtype metadata, we don't make any changes and
+        /// don't update the ToolsVersion.
         /// </summary>
         [TestMethod]
         public void DontUpdateToolsVersionIfNothingChanged()
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index b1460c62f46..422ae5277e6 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -144,7 +144,7 @@ string switchProjectPropertyName
     /// </summary>
     internal sealed class AdditionalOptionsParser
     {
-        // These are all that we recognize in the AdditionalOptions    
+        // These are all that we recognize in the AdditionalOptions
         private CompSwitchInfo[] validCompilerSwitches = new CompSwitchInfo[] {
             #region Info on the compiler switches to be parsed from AdditionalOptions
             // /codepage:<n>
diff --git a/src/Deprecated/Conversion/AssemblyInfo.cs b/src/Deprecated/Conversion/AssemblyInfo.cs
index 9f260a4bf6f..861a59d36f0 100644
--- a/src/Deprecated/Conversion/AssemblyInfo.cs
+++ b/src/Deprecated/Conversion/AssemblyInfo.cs
@@ -16,13 +16,13 @@
 #pragma warning restore 618
 
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
-// this assembly.  We should specify this explicitly, as opposed to letting 
+// this assembly.  We should specify this explicitly, as opposed to letting
 // tlbexp just pick whatever it wants.
 [assembly: GuidAttribute("634AFA8F-4271-4e2c-9525-D0B75DAA821A")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: CLSCompliant(true)]
diff --git a/src/Deprecated/Conversion/OldVSProjectFileReader.cs b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
index a0f8f164e17..995871eb31c 100644
--- a/src/Deprecated/Conversion/OldVSProjectFileReader.cs
+++ b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
@@ -15,21 +15,21 @@
 namespace Microsoft.Build.Conversion
 {
     /// <summary>
-    /// This class implements a custom text reader for the old VS7/Everett 
-    /// project file format.  The old format allowed certain XML special 
+    /// This class implements a custom text reader for the old VS7/Everett
+    /// project file format.  The old format allowed certain XML special
     /// characters to be present within an XML attribute value.  For example,
     ///
     ///     &lt;MyElement MyAttribute="My --> Value" /&gt;
     ///
     /// However, the System.Xml classes are more strict, and do not allow
-    /// the &lt; or &gt; characters to exist within an attribute value.  But 
+    /// the &lt; or &gt; characters to exist within an attribute value.  But
     /// the conversion utility still needs to be able to convert all old
     /// project files.  So the OldVSProjectFileReader class implements
     /// the TextReader interface, thereby effectively intercepting all of
     /// the calls which are used by the XmlTextReader to actually read the
-    /// raw text out of the file.  As we are reading the text out of the 
+    /// raw text out of the file.  As we are reading the text out of the
     /// file, we replace all &gt; (less-than) characters inside attribute values with "&gt;",
-    /// etc.  The XmlTextReader has no idea that this is going on, but 
+    /// etc.  The XmlTextReader has no idea that this is going on, but
     /// no longer complains about invalid characters.
     /// </summary>
     /// <owner>rgoel</owner>
@@ -80,7 +80,7 @@ public override void Close
 
         /// <summary>
         /// Returns the next character in the file, without actually advancing
-        /// the read pointer.  Returns -1 if we're already at the end of the file.  
+        /// the read pointer.  Returns -1 if we're already at the end of the file.
         /// </summary>
         /// <returns></returns>
         /// <owner>rgoel</owner>
@@ -88,7 +88,7 @@ public override int Peek
             (
             )
         {
-            // If necessary, read a new line of text into our internal buffer 
+            // If necessary, read a new line of text into our internal buffer
             // (this.singleLine).
             if (!this.ReadLineIntoInternalBuffer())
             {
@@ -101,7 +101,7 @@ public override int Peek
         }
 
         /// <summary>
-        /// Returns the next character in the file, and advances the read pointer.  
+        /// Returns the next character in the file, and advances the read pointer.
         /// Returns -1 if we're already at the end of the file.
         /// </summary>
         /// <returns></returns>
@@ -123,7 +123,7 @@ public override int Read
         }
 
         /// <summary>
-        /// Reads the specified number of characters into the caller's buffer, 
+        /// Reads the specified number of characters into the caller's buffer,
         /// starting at the specified index into the caller's buffer.  Returns
         /// the number of characters read, or 0 if we're already at the end of
         /// the file.
@@ -157,7 +157,7 @@ int charactersToRead        // The number of characters to read.
                 // Read more data from the underlying file if necessary.
                 if (!this.ReadLineIntoInternalBuffer())
                 {
-                    // If we've reached the end of the underlying file, exit the 
+                    // If we've reached the end of the underlying file, exit the
                     // loop.
                     break;
                 }
@@ -279,7 +279,7 @@ public override string ReadToEnd
 
         /// <summary>
         /// And this is where the real magic happens.  If our currently cached
-        /// "singleLine" has been used up, we read a new line of text from the 
+        /// "singleLine" has been used up, we read a new line of text from the
         /// underlying text file.  But as we read the line of text from the file,
         /// we immediately replace all instances of special characters that occur
         /// within double-quotes with the corresponding XML-friendly equivalents.
@@ -293,7 +293,7 @@ public override string ReadToEnd
         ///
         /// and we would store it this way in our "singleLine", so that the callers
         /// never know the difference.
-        /// 
+        ///
         /// This method returns true on success, and false if we were unable to
         /// read a new line (due to end of file).
         /// </summary>
@@ -319,7 +319,7 @@ private bool ReadLineIntoInternalBuffer
                 // with the escaped XML-friendly string equivalents.
                 this.singleLine = new StringBuilder(this.ReplaceSpecialCharacters(lineFromProjectFile));
 
-                // The underlying StreamReader.ReadLine method doesn't give us the 
+                // The underlying StreamReader.ReadLine method doesn't give us the
                 // trailing line endings, so add them back ourselves.
                 this.singleLine.Append(Environment.NewLine);
 
@@ -334,7 +334,7 @@ private bool ReadLineIntoInternalBuffer
         /// <summary>
         /// This method uses a regular expression to search for the stuff in
         /// between double-quotes.  We obviously don't want to touch the stuff
-        /// OUTSIDE of double-quotes, because then we would be mucking with the 
+        /// OUTSIDE of double-quotes, because then we would be mucking with the
         /// real angle-brackets that delimit the XML element names, etc.
         /// </summary>
         /// <param name="originalLine"></param>
@@ -345,7 +345,7 @@ private string ReplaceSpecialCharacters
             string originalLine
             )
         {
-            // Find the stuff within double-quotes, and send it off to the 
+            // Find the stuff within double-quotes, and send it off to the
             // "ReplaceSpecialCharactersInXmlAttribute" for proper replacement of
             // the special characters.
             Regex attributeValueInsideDoubleQuotesPattern = new Regex("= *\"[^\"]*\"");
@@ -353,7 +353,7 @@ string originalLine
             string replacedStuffInsideDoubleQuotes = attributeValueInsideDoubleQuotesPattern.Replace(originalLine,
                 new MatchEvaluator(this.ReplaceSpecialCharactersInXmlAttribute));
 
-            // Find the stuff within single-quotes, and send it off to the 
+            // Find the stuff within single-quotes, and send it off to the
             // "ReplaceSpecialCharactersInXmlAttribute" for proper replacement of
             // the special characters.
             Regex attributeValueInsideSingleQuotesPattern = new Regex("= *'[^']*'");
@@ -368,7 +368,7 @@ string originalLine
         /// This method is used as the delegate that is passed into Regex.Replace.
         /// It a regular expression to search for the stuff in
         /// between double-quotes.  We obviously don't want to touch the stuff
-        /// OUTSIDE of double-quotes, because then we would be mucking with the 
+        /// OUTSIDE of double-quotes, because then we would be mucking with the
         /// real angle-brackets that delimit the XML element names, etc.
         /// </summary>
         /// <param name="xmlAttribute"></param>
@@ -386,7 +386,7 @@ Match xmlAttribute
         }
 
         /// <summary>
-        /// This method actually does the replacement of special characters within the 
+        /// This method actually does the replacement of special characters within the
         /// text of the XML attribute.
         /// </summary>
         /// <param name="xmlAttributeText">Input string</param>
@@ -399,7 +399,7 @@ string xmlAttributeText
         {
             // Replace the special characters with their XML-friendly escaped equivalents.  The
             // "<" and ">" signs are easy, because if they exist at all within the value of an
-            // XML attribute, we know that they need to be replaced with "&lt;" and "&gt;" 
+            // XML attribute, we know that they need to be replaced with "&lt;" and "&gt;"
             // respectively.
             xmlAttributeText = xmlAttributeText.Replace("<", "&lt;");
             xmlAttributeText = xmlAttributeText.Replace(">", "&gt;");
@@ -415,8 +415,8 @@ string xmlAttributeText
         /// the "&amp;" character, it determines whether the "&amp;" character needs to be replaced
         /// with "&amp;amp;".  The old XML parser used in the VS.NET 2002/2003 project system
         /// was quite inconsistent in its treatment of escaped characters in XML, so here
-        /// we're having to make up for those bugs.  The new XML parser (System.Xml) 
-        /// is much more strict in enforcing proper XML syntax, and therefore doesn't 
+        /// we're having to make up for those bugs.  The new XML parser (System.Xml)
+        /// is much more strict in enforcing proper XML syntax, and therefore doesn't
         /// tolerate "&amp;" characters in the XML attribute value, unless the "&amp;" is being
         /// used to escape some special character.
         /// </summary>
@@ -429,7 +429,7 @@ string xmlAttributeText
             )
         {
             // Ampersands are a little trickier, because some instances of "&" we need to leave
-            // untouched, and some we need to replace with "&amp;".  For example, 
+            // untouched, and some we need to replace with "&amp;".  For example,
             //      aaa&bbb         should be replaced with         aaa&amp;bbb
             // But:
             //      aaa&lt;bbb      should not be touched.
@@ -457,7 +457,7 @@ string xmlAttributeText
 
                     // Perf note: Here we are walking through the entire list of entities, and
                     // doing a string comparison for each.  This is expensive, but this code
-                    // should only get executed in fairly rare circumstances.  It's not very 
+                    // should only get executed in fairly rare circumstances.  It's not very
                     // common for people to have these embedded into their project files.
                     bool foundEntity = false;
                     for (int i = 0; i < entities.Length; i++)
@@ -472,7 +472,7 @@ string xmlAttributeText
                         }
                     }
 
-                    // If it didn't match a well-known entity name, then the next thing to 
+                    // If it didn't match a well-known entity name, then the next thing to
                     // check is if it represents an ASCII code.  For example, in an XML
                     // attribute, if I wanted to represent the "+" sign, I could do this:
                     //
@@ -521,7 +521,7 @@ string xmlAttributeText
                         }
                     }
 
-                    // If the ampersand did not precede an actual well-known entity, then we DO want to 
+                    // If the ampersand did not precede an actual well-known entity, then we DO want to
                     // replace the "&" with a "&amp;".  Otherwise we don't.
                     if (!foundEntity)
                     {
@@ -568,7 +568,7 @@ int indexOfAmpersand
         // taken directly from the source code.
         private static readonly string[] entities =
         {
-            "quot",          // 
+            "quot",          //
             "amp",           // & - ampersand
             "apos",          // ' - apostrophe //// not part of HTML!
             "lt",            // < less than
@@ -685,7 +685,7 @@ int indexOfAmpersand
             "Zeta",         // greek capital letter zeta
             "Eta",          // greek capital letter eta
             "Theta",        // greek capital letter theta
-            "Iota",         // greek capital letter iota 
+            "Iota",         // greek capital letter iota
             "Kappa",        // greek capital letter kappa
             "Lambda",       // greek capital letter lambda
             "Mu",           // greek capital letter mu
@@ -699,7 +699,7 @@ int indexOfAmpersand
             "Upsilon",      // greek capital letter upsilon
             "Phi",          // greek capital letter phi
             "Chi",          // greek capital letter chi
-            "Psi",          // greek capital letter psi   
+            "Psi",          // greek capital letter psi
             "Omega",        // greek capital letter omega
             "alpha",        // greek small letter alpha
             "beta",         // greek small letter beta
@@ -709,7 +709,7 @@ int indexOfAmpersand
             "zeta",         // greek small letter zeta
             "eta",          // greek small letter eta
             "theta",        // greek small letter theta
-            "iota",         // greek small letter iota 
+            "iota",         // greek small letter iota
             "kappa",        // greek small letter kappa
             "lambda",       // greek small letter lambda
             "mu",           // greek small letter mu
@@ -724,7 +724,7 @@ int indexOfAmpersand
             "upsilon",      // greek small letter upsilon
             "phi",          // greek small letter phi
             "chi",          // greek small letter chi
-            "psi",          // greek small letter psi   
+            "psi",          // greek small letter psi
             "omega",        // greek small letter omega
             "thetasym",     // greek small letter theta symbol, U03D1 NEW
             "upsih",        // greek upsilon with hook symbol
@@ -755,71 +755,71 @@ int indexOfAmpersand
             "rsaquo",      // single right-pointing angle quotation mark, U203A ISO proposed
             "oline",       // overline, spacing overscore
             "frasl",       // fraction slash
-            "image",       // blackletter capital I, =imaginary part, U2111 ISOamso 
-            "weierp",      // script capital P, =power set, =Weierstrass p, U2118 ISOamso 
-            "real",        // blackletter capital R, =real part symbol, U211C ISOamso 
-            "trade",       // trade mark sign, U2122 ISOnum 
-            "alefsym",     // alef symbol, =first transfinite cardinal, U2135 NEW 
-            "larr",        // leftwards arrow, U2190 ISOnum 
+            "image",       // blackletter capital I, =imaginary part, U2111 ISOamso
+            "weierp",      // script capital P, =power set, =Weierstrass p, U2118 ISOamso
+            "real",        // blackletter capital R, =real part symbol, U211C ISOamso
+            "trade",       // trade mark sign, U2122 ISOnum
+            "alefsym",     // alef symbol, =first transfinite cardinal, U2135 NEW
+            "larr",        // leftwards arrow, U2190 ISOnum
             "uarr",        // upwards arrow, U2191 ISOnum
-            "rarr",        // rightwards arrow, U2192 ISOnum 
-            "darr",        // downwards arrow, U2193 ISOnum 
-            "harr",        // left right arrow, U2194 ISOamsa 
-            "crarr",       // downwards arrow with corner leftwards, =carriage return, U21B5 NEW 
-            "lArr",        // leftwards double arrow, U21D0 ISOtech 
-            "uArr",        // upwards double arrow, U21D1 ISOamsa 
-            "rArr",        // rightwards double arrow, U21D2 ISOtech 
-            "dArr",        // downwards double arrow, U21D3 ISOamsa 
-            "hArr",        // left right double arrow, U21D4 ISOamsa 
-            "forall",      // for all, U2200 ISOtech 
-            "part",        // partial differential, U2202 ISOtech  
-            "exist",       // there exists, U2203 ISOtech 
-            "empty",       // empty set, =null set, =diameter, U2205 ISOamso 
-            "nabla",       // nabla, =backward difference, U2207 ISOtech 
-            "isin",        // element of, U2208 ISOtech 
-            "notin",       // not an element of, U2209 ISOtech 
-            "ni",          // contains as member, U220B ISOtech 
-            "prod",        // n-ary product, =product sign, U220F ISOamsb 
-            "sum",         // n-ary sumation, U2211 ISOamsb 
-            "minus",       // minus sign, U2212 ISOtech 
-            "lowast",      // asterisk operator, U2217 ISOtech 
-            "radic",       // square root, =radical sign, U221A ISOtech 
-            "prop",        // proportional to, U221D ISOtech 
-            "infin",       // infinity, U221E ISOtech 
-            "ang",         // angle, U2220 ISOamso 
-            "and",         // logical and, =wedge, U2227 ISOtech 
-            "or",          // logical or, =vee, U2228 ISOtech 
-            "cap",         // intersection, =cap, U2229 ISOtech 
-            "cup",         // union, =cup, U222A ISOtech 
-            "int",         // integral, U222B ISOtech 
-            "there4",      // therefore, U2234 ISOtech 
-            "sim",         // tilde operator, =varies with, =similar to, U223C ISOtech 
-            "cong",        // approximately equal to, U2245 ISOtech 
-            "asymp",       // almost equal to, =asymptotic to, U2248 ISOamsr 
-            "ne",          // not equal to, U2260 ISOtech 
-            "equiv",       // identical to, U2261 ISOtech 
-            "le",          // less-than or equal to, U2264 ISOtech 
-            "ge",          // greater-than or equal to, U2265 ISOtech 
-            "sub",         // subset of, U2282 ISOtech 
-            "sup",         // superset of, U2283 ISOtech 
-            "nsub",        // not a subset of, U2284 ISOamsn 
-            "sube",        // subset of or equal to, U2286 ISOtech 
-            "supe",        // superset of or equal to, U2287 ISOtech 
-            "oplus",       // circled plus, =direct sum, U2295 ISOamsb 
-            "otimes",      // circled times, =vector product, U2297 ISOamsb 
-            "perp",        // up tack, =orthogonal to, =perpendicular, U22A5 ISOtech 
-            "sdot",        // dot operator, U22C5 ISOamsb 
-            "lceil",       // left ceiling, =apl upstile, U2308, ISOamsc  
-            "rceil",       // right ceiling, U2309, ISOamsc  
-            "lfloor",      // left floor, =apl downstile, U230A, ISOamsc  
-            "rfloor",      // right floor, U230B, ISOamsc  
-            "lang",        // left-pointing angle bracket, =bra, U2329 ISOtech 
-            "rang",        // right-pointing angle bracket, =ket, U232A ISOtech 
-            "loz",         // lozenge, U25CA ISOpub 
-            "spades",      // black spade suit, U2660 ISOpub 
-            "clubs",       // black club suit, =shamrock, U2663 ISOpub 
-            "hearts",      // black heart suit, =valentine, U2665 ISOpub 
-            "diams"        // black diamond suit, U2666 ISOpub 
+            "rarr",        // rightwards arrow, U2192 ISOnum
+            "darr",        // downwards arrow, U2193 ISOnum
+            "harr",        // left right arrow, U2194 ISOamsa
+            "crarr",       // downwards arrow with corner leftwards, =carriage return, U21B5 NEW
+            "lArr",        // leftwards double arrow, U21D0 ISOtech
+            "uArr",        // upwards double arrow, U21D1 ISOamsa
+            "rArr",        // rightwards double arrow, U21D2 ISOtech
+            "dArr",        // downwards double arrow, U21D3 ISOamsa
+            "hArr",        // left right double arrow, U21D4 ISOamsa
+            "forall",      // for all, U2200 ISOtech
+            "part",        // partial differential, U2202 ISOtech
+            "exist",       // there exists, U2203 ISOtech
+            "empty",       // empty set, =null set, =diameter, U2205 ISOamso
+            "nabla",       // nabla, =backward difference, U2207 ISOtech
+            "isin",        // element of, U2208 ISOtech
+            "notin",       // not an element of, U2209 ISOtech
+            "ni",          // contains as member, U220B ISOtech
+            "prod",        // n-ary product, =product sign, U220F ISOamsb
+            "sum",         // n-ary sumation, U2211 ISOamsb
+            "minus",       // minus sign, U2212 ISOtech
+            "lowast",      // asterisk operator, U2217 ISOtech
+            "radic",       // square root, =radical sign, U221A ISOtech
+            "prop",        // proportional to, U221D ISOtech
+            "infin",       // infinity, U221E ISOtech
+            "ang",         // angle, U2220 ISOamso
+            "and",         // logical and, =wedge, U2227 ISOtech
+            "or",          // logical or, =vee, U2228 ISOtech
+            "cap",         // intersection, =cap, U2229 ISOtech
+            "cup",         // union, =cup, U222A ISOtech
+            "int",         // integral, U222B ISOtech
+            "there4",      // therefore, U2234 ISOtech
+            "sim",         // tilde operator, =varies with, =similar to, U223C ISOtech
+            "cong",        // approximately equal to, U2245 ISOtech
+            "asymp",       // almost equal to, =asymptotic to, U2248 ISOamsr
+            "ne",          // not equal to, U2260 ISOtech
+            "equiv",       // identical to, U2261 ISOtech
+            "le",          // less-than or equal to, U2264 ISOtech
+            "ge",          // greater-than or equal to, U2265 ISOtech
+            "sub",         // subset of, U2282 ISOtech
+            "sup",         // superset of, U2283 ISOtech
+            "nsub",        // not a subset of, U2284 ISOamsn
+            "sube",        // subset of or equal to, U2286 ISOtech
+            "supe",        // superset of or equal to, U2287 ISOtech
+            "oplus",       // circled plus, =direct sum, U2295 ISOamsb
+            "otimes",      // circled times, =vector product, U2297 ISOamsb
+            "perp",        // up tack, =orthogonal to, =perpendicular, U22A5 ISOtech
+            "sdot",        // dot operator, U22C5 ISOamsb
+            "lceil",       // left ceiling, =apl upstile, U2308, ISOamsc
+            "rceil",       // right ceiling, U2309, ISOamsc
+            "lfloor",      // left floor, =apl downstile, U230A, ISOamsc
+            "rfloor",      // right floor, U230B, ISOamsc
+            "lang",        // left-pointing angle bracket, =bra, U2329 ISOtech
+            "rang",        // right-pointing angle bracket, =ket, U232A ISOtech
+            "loz",         // lozenge, U25CA ISOpub
+            "spades",      // black spade suit, U2660 ISOpub
+            "clubs",       // black club suit, =shamrock, U2663 ISOpub
+            "hearts",      // black heart suit, =valentine, U2665 ISOpub
+            "diams"        // black diamond suit, U2666 ISOpub
         };
     }
 }
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 808ea0749a1..5e08c084d76 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -667,7 +667,7 @@ private void ConvertInMemoryToMSBuildProject()
                     )
                 {
                     // If it's minor upgrade, or nothing changed and the project was already TV 4.0 or higher,
-                    // set the ToolsVersion back to its old value. 
+                    // set the ToolsVersion back to its old value.
                     xmakeProject.ToolsVersion = oldToolsVersion;
                 }
             }
@@ -888,7 +888,7 @@ private bool FixTargetFrameworkSubset()
             {
                 if (String.Equals(propertyElement.Name, XMakeProjectStrings.TargetFrameworkSubset, StringComparison.OrdinalIgnoreCase))
                 {
-                    // For the Client profile, which was the only profile supported in Orcas SP1, we want to replace 
+                    // For the Client profile, which was the only profile supported in Orcas SP1, we want to replace
                     // <TargetFrameworkSubset/> with <TargetFrameworkProfile/>.
                     if (String.Equals(propertyElement.Value, XMakeProjectStrings.ClientProfile, StringComparison.OrdinalIgnoreCase))
                     {
@@ -899,7 +899,7 @@ private bool FixTargetFrameworkSubset()
 
                     // In all cases, <TargetFrameworkSubset/> is no longer supported.  If it comes from the project
                     // that we're converting, then we forcibly remove it.  If it comes from some import... the user is
-                    // on their own.  
+                    // on their own.
                     if (propertyElement.ContainingProject == xmakeProject)
                     {
                         propertyElement.Parent.RemoveChild(propertyElement);
@@ -957,8 +957,8 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             // local function: wraps specified string value into Exists('value')
             Func<string, string> exists = s => string.Format(CultureInfo.InvariantCulture, "Exists('{0}')", s);
 
-            // local function: 
-            // Creates property group element containing one property fsharpDev12PlusProperty with value 'path'. 
+            // local function:
+            // Creates property group element containing one property fsharpDev12PlusProperty with value 'path'.
             // If addCondition is true, property group will have Exists(path) condition
             Action<string, ProjectElementContainer> appendPropertyGroupForDev12PlusTargetsPath =
                 (path, parent) =>
@@ -1061,7 +1061,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
 
                 someNonNullImportElement.Parent.InsertBeforeChild(chooseElement, someNonNullImportElement);
 
-                // Expected fragment of the project file after upgrade 
+                // Expected fragment of the project file after upgrade
                 //<Choose>
                 //  <When Condition="'$(VisualStudioVersion)' == '11.0'">
                 //    <PropertyGroup>
@@ -1074,7 +1074,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 //    </PropertyGroup>
                 //  </Otherwise>
                 //</Choose>
-                //<Import Project="$(FSharpTargetsPath)" Condition="Exists('$(FSharpTargetsPath)')" />           
+                //<Import Project="$(FSharpTargetsPath)" Condition="Exists('$(FSharpTargetsPath)')" />
 
                 var whenVsVersionIsDev11 = xmakeProject.CreateWhenElement("'$(VisualStudioVersion)' == '11.0'");
                 chooseElement.AppendChild(whenVsVersionIsDev11);
@@ -1148,7 +1148,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 }
             }
 
-            // try to find reference to FSharp.Core 
+            // try to find reference to FSharp.Core
             ProjectItemElement fsharpCoreItem = null;
             foreach (var item in xmakeProject.Items.Where(x => x.ItemType == ReferenceItemType))
             {
diff --git a/src/Deprecated/Engine.UnitTests/BatchingEngine_Tests.cs b/src/Deprecated/Engine.UnitTests/BatchingEngine_Tests.cs
index 591373a9614..affbc14d425 100644
--- a/src/Deprecated/Engine.UnitTests/BatchingEngine_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BatchingEngine_Tests.cs
@@ -33,7 +33,7 @@ private static string ExpandItemsIntoString
             string expression
             )
         {
-            
+
             Expander itemExpander = new Expander(new ReadOnlyLookup(bucket.Lookup), null, ExpanderOptions.ExpandItems);
             return itemExpander.ExpandAllIntoString(expression, (new XmlDocument()).CreateAttribute("foo"));
         }
@@ -216,7 +216,7 @@ public void NoItemsConsumed()
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: Missed test.
-        /// 
+        ///
         /// This test ensures that two items with duplicate attributes end up in exactly one batching
         /// bucket.
         /// </summary>
@@ -227,7 +227,7 @@ public void Regress_Mutation_DuplicateBatchingBucketsAreFoldedTogether()
             parameters.Add("%(File.Culture)");
 
             Hashtable itemsByType = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            
+
             BuildItemGroup items = new BuildItemGroup();
             items.AddNewItem("File", "a.foo");
             items.AddNewItem("File", "b.foo"); // Need at least two items for this test case to ensure multiple buckets might be possible
diff --git a/src/Deprecated/Engine.UnitTests/BuildItemDefinitionGroupXml_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildItemDefinitionGroupXml_Tests.cs
index 09bad8c8d39..98e5575a033 100644
--- a/src/Deprecated/Engine.UnitTests/BuildItemDefinitionGroupXml_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildItemDefinitionGroupXml_Tests.cs
@@ -184,7 +184,7 @@ public void BasicItemDefinitionInProject()
                     <CppCompile>
                       <Defines>DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemGroup>
                     <CppCompile Include='b.cpp'/>
                   </ItemGroup>
@@ -211,7 +211,7 @@ public void EscapingInItemDefinitionInProject()
                     <i Condition=`'%24'=='$'`>
                       <m Condition=`'%24'=='$'`>%24(xyz)</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -236,7 +236,7 @@ public void ItemDefinitionForOtherItemType()
                     <j>
                       <m>m1</m>
                     </j>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -261,13 +261,13 @@ public void RedefinitionLastOneWins()
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i>
                       <m>m2</m>
                       <o>o1</o>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)-%(i.n)-%(i.o)]`/>
                   </Target>
@@ -290,7 +290,7 @@ public void ItemExpressionInDefaultMetadataValueErrors()
                     <i>
                       <m>@(x)</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                 </Project>
             ", logger);
             p.Build("t");
@@ -341,16 +341,16 @@ public void MetadataConditionOnItemDefinition()
                     <j>
                       <n>n1</n>
                     </j>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i Condition=`'%(m)'=='m1'`>
                       <m>m2</m>
                     </i>
                     <!-- verify j metadata is distinct -->
                     <j Condition=`'%(j.n)'=='n1' and '%(n)'=='n1'`>
-                      <n>n2</n>   
+                      <n>n2</n>
                     </j>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                     <Message Text=`[%(j.n)]`/>
@@ -375,12 +375,12 @@ public void QualifiedMetadataConditionOnItemDefinitionBothQualifiedAndUnqualifie
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i Condition=`'%(i.m)'=='m1' and '%(m)'=='m1'`>
                       <m>m2</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -404,12 +404,12 @@ public void FalseMetadataConditionOnItemDefinitionBothQualifiedAndUnqualified()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i Condition=`'%(m)'=='m2' or '%(i.m)'!='m1'`>
                       <m>m3</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -434,12 +434,12 @@ public void MetadataConditionOnItemDefinitionChildBothQualifiedAndUnqualified()
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i>
                       <m Condition=`'%(m)'=='m1' and '%(n)'=='n1' and '%(i.m)'=='m1'`>m2</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -464,12 +464,12 @@ public void FalseMetadataConditionOnItemDefinitionChildBothQualifiedAndUnqualifi
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i>
                       <m Condition=`'%(m)'=='m2' or !('%(n)'=='n1') or '%(i.m)' != 'm1'`>m3</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -493,12 +493,12 @@ public void MetadataConditionOnItemDefinitionAndChildQualifiedWithUnrelatedItemT
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemDefinitionGroup>
                     <i Condition=`'%(j.m)'=='' and '%(j.m)'!='x'`>
                       <m Condition=`'%(j.m)'=='' and '%(j.m)'!='x'`>m2</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -511,8 +511,8 @@ public void MetadataConditionOnItemDefinitionAndChildQualifiedWithUnrelatedItemT
 
         /// <summary>
         /// Make ItemDefinitionGroup inside a target produce a nice error.
-        /// It will normally produce an error due to the invalid child tag, but 
-        /// we want to error even if there's no child tag. This will make it 
+        /// It will normally produce an error due to the invalid child tag, but
+        /// we want to error even if there's no child tag. This will make it
         /// easier to support it inside targets in a future version.
         /// </summary>
         [Test]
@@ -565,7 +565,7 @@ public void MetadataOnItemWins()
                     <CppCompile>
                       <Defines>DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(CppCompile.Identity)==%(CppCompile.Defines)]`/>
                   </Target>
@@ -591,7 +591,7 @@ public void MixtureOfItemAndDefaultMetadata()
                     <CppCompile>
                       <Defines>DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(CppCompile.Identity)==%(CppCompile.Defines)]`/>
                     <Message Text=`[%(CppCompile.Identity)==%(CppCompile.WarningLevel)]`/>
@@ -616,7 +616,7 @@ public void IntrinsicTaskModifyingDefaultMetadata()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i>
@@ -658,7 +658,7 @@ public void IntrinsicTaskConsumingDefaultMetadata()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i Condition=`'%(i.m)'=='m1'`>
@@ -689,13 +689,13 @@ public void DefinitionInImportedFile()
                     <CppCompile>
                       <Defines>DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                 </Project>
             ");
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
                     <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <ItemGroup>
-                        <CppCompile Include='a.cpp'/>                      
+                        <CppCompile Include='a.cpp'/>
                       </ItemGroup>
                       <Import Project='" + importedFile + @"'/>
                       <Target Name=`t`>
@@ -725,7 +725,7 @@ public void ProjectAddNewItemPicksUpProjectItemDefinitions()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                 </Project>
                 ");
 
@@ -746,7 +746,7 @@ public void ProjectAddNewItemExistingGroupPicksUpProjectItemDefinitions()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemGroup>
                     <i Include='i2'>
                       <m>m2</m>
@@ -775,7 +775,7 @@ public void ItemsEmittedByTaskPickUpItemDefinitions()
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <CreateItem Include=`i1` AdditionalMetadata=`n=n2`>
                       <Output ItemName=`i` TaskParameter=`Include`/>
@@ -801,7 +801,7 @@ public void ItemsEmittedByIntrinsicTaskPickUpItemDefinitions()
                       <m>m1</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i Include=`i1`>
@@ -829,10 +829,10 @@ public void MutualReferenceToDefinition1()
                       <m>m1</m>
                       <n>~%(m)~</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                     <ItemGroup>
                       <i Include=`i1`/>
-                    </ItemGroup>   
+                    </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)][%(i.n)]`/>
                   </Target>
@@ -855,10 +855,10 @@ public void MutualReferenceToDefinition2()
                       <m>~%(n)~</m>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                     <ItemGroup>
                       <i Include=`i1`/>
-                    </ItemGroup>   
+                    </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)][%(i.n)]`/>
                   </Target>
@@ -882,10 +882,10 @@ public void MutualReferenceToDefinition3()
                       <n>%(i.m)</n>
                       <o>%(j.m)</o>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                     <ItemGroup>
                       <i Include=`i1`/>
-                    </ItemGroup>   
+                    </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)][%(i.n)][%(i.o)]`/>
                   </Target>
@@ -914,7 +914,7 @@ public void ProjectReevaluationReevaluatesItemDefinitions()
                       <Defines Condition=`'$(BuildFlavor)'=='ret'`>$(Defines);RETAIL</Defines>
                       <Defines Condition=`'$(BuildFlavor)'=='chk'`>$(Defines);DEBUG</Defines>
                     </CppCompile>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(CppCompile.Identity)==%(CppCompile.Defines)]`/>
                   </Target>
@@ -957,7 +957,7 @@ public void MSBuildCallDoesNotAffectCallingProjectsDefinitions()
                     <i>
                       <m>m2</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=""t"">
                     <Message Text=""[CHILD:%(i.m)]""/>
                   </Target>
@@ -978,7 +978,7 @@ public void MSBuildCallDoesNotAffectCallingProjectsDefinitions()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=`t`>
                     <Message Text=`[PARENT-before:%(i.m)]`/>
                     <MSBuild Projects=`" + otherProject + @"`/>
@@ -1015,7 +1015,7 @@ public void DefaultMetadataTravelWithTargetOutputs()
                     <i>
                       <n>n1</n>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <Target Name=""t"" Outputs=""@(i)"">
                     <Message Text=""[CHILD:%(i.Identity):m=%(i.m),n=%(i.n)]""/>
                   </Target>
@@ -1058,7 +1058,7 @@ private static ItemDefinitionLibrary NewAndEvaluateItemDefinitionLibraryXml(XmlE
             library.Add(group);
 
             BuildPropertyGroup properties = new BuildPropertyGroup();
-            properties.SetProperty("p1", "v1");            
+            properties.SetProperty("p1", "v1");
             library.Evaluate(properties);
 
             return library;
diff --git a/src/Deprecated/Engine.UnitTests/BuildItemGroupProxy_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildItemGroupProxy_Tests.cs
index 36d2e5a250b..62ba6089195 100644
--- a/src/Deprecated/Engine.UnitTests/BuildItemGroupProxy_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildItemGroupProxy_Tests.cs
@@ -21,7 +21,7 @@ public class ItemGroupProxy_Tests
     {
         [Test]
         public void BasicProxying()
-        {          
+        {
             BuildItemGroup ig = new BuildItemGroup();
             BuildItem i1 = new BuildItem("name1", "value1");
             i1.SetMetadata("myMetaName", "myMetaValue");
diff --git a/src/Deprecated/Engine.UnitTests/BuildItemGroup_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildItemGroup_Tests.cs
index d3bfa33cdfe..423558040e6 100644
--- a/src/Deprecated/Engine.UnitTests/BuildItemGroup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildItemGroup_Tests.cs
@@ -223,7 +223,7 @@ public void AddExistingItemAt()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                 </Project>
             ", logger);
 
@@ -249,9 +249,9 @@ public void MutualReferenceToMetadata()
                     <i Include=`i1`>
                       <m>m1</m>
                       <m>%(m);m2</m>
-                      <m Condition='false'>%(m);m3</m> 
+                      <m Condition='false'>%(m);m3</m>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -276,9 +276,9 @@ public void MutualReferenceToMetadataQualified()
                     <i Include=`i1`>
                       <m>m1</m>
                       <m>%(i.m);m2</m>
-                      <m Condition='false'>%(m);m3</m> 
+                      <m Condition='false'>%(m);m3</m>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -303,14 +303,14 @@ public void MutualReferenceToMetadataMixed()
                     <i>
                       <l>l1</l>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemGroup>
                       <i Include=`i1`>
                       <n>overridden</n>
                       <m>m1</m>
                       <n>%(l);%(i.l);n1;%(m);%(i.m);%(o);%(i.o);n2</n>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.n)]`/>
                   </Target>
@@ -335,12 +335,12 @@ public void MetadataReferenceToMetadataDefinition()
                     <i>
                       <m>m1</m>
                     </i>
-                  </ItemDefinitionGroup> 
+                  </ItemDefinitionGroup>
                   <ItemGroup>
                     <i Include=`i1`>
                       <m>%(m);m2</m>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -365,7 +365,7 @@ public void EscapedMetadataReference()
                     <i Include=`i1`>
                       <m>%25(m)</m>
                     </i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`[%(i.m)]`/>
                   </Target>
@@ -529,11 +529,11 @@ public void AddItem1()
 
             item = CreatePersistedBuildItem(ig, "i", "i2");
             group.AddItem(item);
-            VerifyPersistedItemPosition(group, item, 1); // should be 2nd      
+            VerifyPersistedItemPosition(group, item, 1); // should be 2nd
 
             item = CreatePersistedBuildItem(ig, "i", "i0");
             group.AddItem(item);
-            VerifyPersistedItemPosition(group, item, 0); // should be first              
+            VerifyPersistedItemPosition(group, item, 0); // should be first
         }
 
         [Test]
@@ -559,7 +559,7 @@ public void AddItemEmptyNonPersistedGroup()
             group.AddItem(item);
             Assertion.AssertEquals(item, group[1]); // should be last again
         }
-        
+
         private static void VerifyPersistedItemPosition(BuildItemGroup group, BuildItem item, int position)
         {
             Assertion.AssertEquals(group[position].Include, group.ItemGroupElement.ChildNodes[position].Attributes["Include"].Value);
diff --git a/src/Deprecated/Engine.UnitTests/BuildItem_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildItem_Tests.cs
index 31e5f7f33bc..b9358208874 100644
--- a/src/Deprecated/Engine.UnitTests/BuildItem_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildItem_Tests.cs
@@ -95,7 +95,7 @@ public void Metadata()
 
             // Custom metadata count only
             Assertion.AssertEquals(2, item.CustomMetadataCount);
-            
+
             // All metadata count
             Assertion.AssertEquals(2 + FileUtilities.ItemSpecModifiers.All.Length, item.MetadataCount);
         }
@@ -103,7 +103,7 @@ public void Metadata()
         [Test]
         public void MetadataIncludesItemDefinitionMetadata()
         {
-            // Get an item of type "i" that has an item definition library 
+            // Get an item of type "i" that has an item definition library
             // for type "i" that has default value "m1" for metadata "m"
             // and has value "n1" for metadata "n"
             BuildItem item = GetXmlBackedItemWithDefinitionLibrary();
@@ -195,7 +195,7 @@ internal static BuildItem GetXmlBackedItemWithDefinitionLibrary()
             item.SetMetadata("n", "n1");
             return item;
         }
-        
+
         private static BuildItem CreateBuildItemFromXmlDocument(XmlDocument doc)
         {
             ItemDefinitionLibrary itemDefinitionLibrary = new ItemDefinitionLibrary(new Project());
diff --git a/src/Deprecated/Engine.UnitTests/BuildRequest_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildRequest_Tests.cs
index e9410241358..99734d73427 100644
--- a/src/Deprecated/Engine.UnitTests/BuildRequest_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildRequest_Tests.cs
@@ -60,8 +60,8 @@ public void TestConstructor1andProperties()
             Assert.IsTrue(string.Compare(buildProperty, "Value", StringComparison.OrdinalIgnoreCase) == 0, "Expected hashtable to contain a property group with a value of value");
             Assert.IsTrue((firstConstructorRequest.TargetNames.Length == 1) && (string.Compare("Build", firstConstructorRequest.TargetNames[0], StringComparison.OrdinalIgnoreCase) == 0), "Expected to have one target with a value of Build");
             Assert.IsTrue(string.Compare("ProjectFileName", firstConstructorRequest.ProjectFileName, StringComparison.OrdinalIgnoreCase) == 0, "Expected project file to be called ProjecFileName");
-      
-        
+
+
         }
 
         /// <summary>
@@ -158,8 +158,8 @@ public void GetTargetNamesList()
         {
             int nodeProxyId = 1;
             string projectFileName = "ProjectFileName";
-            string[] targetNames = null; 
-            
+            string[] targetNames = null;
+
             Dictionary<string, string> dictionary = null;
             int requestId = 1;
 
@@ -171,7 +171,7 @@ public void GetTargetNamesList()
             targetNames = new string[] { "Build" };
             buildRequest = new BuildRequest(nodeProxyId, projectFileName, targetNames, (IDictionary)dictionary, null, requestId, false, false);
             Assert.IsTrue(string.Compare("Build", buildRequest.GetTargetNamesList(),StringComparison.OrdinalIgnoreCase)==0, "Expected to see Build as the targetNamesList");
-           
+
             //Test the case where we pass in multiple targets
             targetNames = new string[] {"Build","Build2"};
             buildRequest = new BuildRequest(nodeProxyId, projectFileName, targetNames, (IDictionary)dictionary, null, requestId, false, false);
diff --git a/src/Deprecated/Engine.UnitTests/BuildResult_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildResult_Tests.cs
index fd513ec6bff..4a0f621d03c 100644
--- a/src/Deprecated/Engine.UnitTests/BuildResult_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildResult_Tests.cs
@@ -23,7 +23,7 @@ public class BuildResult_Tests
     {
         // A build result where the taskoutputs are null
         private BuildResult resultNoOutputs;
-        
+
         // A build result where the task outputs are acutal values
         private BuildResult resultWithOutputs;
 
@@ -36,7 +36,7 @@ public class BuildResult_Tests
         public void Initialize()
         {
             // Create some items and place them in a dictionary
-            // Add some include information so that when we check the final 
+            // Add some include information so that when we check the final
             // item spec we can verify that the item was recreated properly
             buildItem1.Include = "TestInclude1";
             buildItem2.Include = "TestInclude2";
@@ -76,13 +76,13 @@ public void TestConstructorsAndProperties()
             Assert.AreEqual(0, resultWithOutputsFromBuildResult.HandleId, "Expected resultWithOutputsFromBuildResult.NodeProxyId to be 0");
             Assert.AreEqual(1, resultWithOutputsFromBuildResult.RequestId, "Expected resultWithOutputsFromBuildResult.RequestId to be 1");
             Assert.AreEqual(2, resultWithOutputsFromBuildResult.ProjectId, "Expected resultWithOutputsFromBuildResult.ProjectId to be 1");
-            
+
             // Test some setters which are not set otherwise during the tests
             resultWithOutputsFromBuildResult.HandleId = 3;
             resultWithOutputsFromBuildResult.RequestId = 4;
             Assert.AreEqual(3, resultWithOutputsFromBuildResult.HandleId, "Expected resultWithOutputsFromBuildResult.NodeProxyId to be 3");
             Assert.AreEqual(4, resultWithOutputsFromBuildResult.RequestId, "Expected resultWithOutputsFromBuildResult.RequestId to be 4");
-            
+
             // Test the setting of RequestId
             resultWithOutputsFromBuildResult.RequestId = 4;
             Assert.AreEqual(4, resultWithOutputsFromBuildResult.RequestId, "Expected resultWithOutputsFromBuildResult.RequestId to be 4");
diff --git a/src/Deprecated/Engine.UnitTests/BuildTask_Tests.cs b/src/Deprecated/Engine.UnitTests/BuildTask_Tests.cs
index e86fcf19d40..cace4161d89 100644
--- a/src/Deprecated/Engine.UnitTests/BuildTask_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/BuildTask_Tests.cs
@@ -26,10 +26,10 @@ public class BuildTask_Tests
         /***********************************************************************
          * Test:            SetGetHostObjectInProject
          * Owner:           RGoel
-         * 
-         * Slightly more advanced unit test that loads a real project, finds the 
+         *
+         * Slightly more advanced unit test that loads a real project, finds the
          * appropriate task, and sets the host object for it.
-         * 
+         *
          **********************************************************************/
         [Test]
         public void SetGetHostObjectInProject()
@@ -42,7 +42,7 @@ public void SetGetHostObjectInProject()
                         <MakeDir Directories=`c:\rajeev` />
                         <Csc Sources=`foo.cs` />
                     </Target>
-                
+
                 </Project>
                 ";
 
diff --git a/src/Deprecated/Engine.UnitTests/CacheEntry_Tests.cs b/src/Deprecated/Engine.UnitTests/CacheEntry_Tests.cs
index a54dd736553..f01add7ddd7 100644
--- a/src/Deprecated/Engine.UnitTests/CacheEntry_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/CacheEntry_Tests.cs
@@ -49,7 +49,7 @@ public void CacheEntryGettersDefaultConstructors()
             BuildItemCacheEntry tice = new BuildItemCacheEntry();
             Assertion.AssertEquals(null, tice.Name);
             Assertion.AssertEquals(null, tice.BuildItems);
-            
+
             tice.Name = "tice";
             tice.BuildItems = buildItems;
             Assertion.AssertEquals("tice", tice.Name);
@@ -81,7 +81,7 @@ public void CacheEntryGettersDefaultConstructors()
         public void IsEquivalentProperty()
         {
             PropertyCacheEntry e = new PropertyCacheEntry("name", "value");
-            
+
             Assert.IsFalse(e.IsEquivalent(null));
             Assert.IsFalse(e.IsEquivalent(new BuildItemCacheEntry()));
             Assert.IsFalse(e.IsEquivalent(new PropertyCacheEntry()));
@@ -154,7 +154,7 @@ public void TestCacheEntryCustomSerialization()
                 BuildItemCacheEntry buildItemEntry = new BuildItemCacheEntry("Badger", buildItems);
                 BuildResultCacheEntry buildResultEntry = new BuildResultCacheEntry("Koi", buildItems, true);
                 PropertyCacheEntry propertyEntry = new PropertyCacheEntry("Seagull", "bread");
-                
+
                 stream.Position = 0;
                 // Serialize
                 buildItemEntry.WriteToStream(writer);
diff --git a/src/Deprecated/Engine.UnitTests/CacheManager_Tests.cs b/src/Deprecated/Engine.UnitTests/CacheManager_Tests.cs
index a29953fe147..7df64d0b0aa 100644
--- a/src/Deprecated/Engine.UnitTests/CacheManager_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/CacheManager_Tests.cs
@@ -34,7 +34,7 @@ public class CacheManager_Tests
         public void Initialize()
         {
             // Create some items and place them in a dictionary
-            // Add some include information so that when we check the final 
+            // Add some include information so that when we check the final
             // item spec we can verify that the item was recreated properly
             BuildItem buildItem1 = new BuildItem("BuildItem1", "Item1");
             buildItem1.Include = "TestInclude1";
@@ -42,7 +42,7 @@ public void Initialize()
             buildItems[0] = buildItem1;
             Dictionary<object, object> dictionary = new Dictionary<object, object>();
             dictionary.Add("TaskItems", buildItems);
-            
+
             Hashtable resultByTargetSuccess = new Hashtable(StringComparer.OrdinalIgnoreCase);
             resultByTargetSuccess.Add("TaskItems", Target.BuildState.CompletedSuccessfully);
             Hashtable resultByTargetFailure = new Hashtable(StringComparer.OrdinalIgnoreCase);
@@ -111,21 +111,21 @@ public void TestRequestCaching()
             string[] targets = new string[1]; targets[0] = "Target1";
             BuildRequest length1Request = new BuildRequest(1, "test.proj", targets, new BuildPropertyGroup(), null, 1, true, false);
             Assert.IsNull(cacheManager.GetCachedBuildResult(length1Request, out actuallyBuiltTargets), "Expect a null return value if no scope");
-            
+
             // Test the case when the scope exists but is empty
             CacheScope cacheScope = cacheManager.GetCacheScope("test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
             Assert.IsNull(cacheManager.GetCachedBuildResult(length1Request, out actuallyBuiltTargets), "Expect a null return value if scope is empty");
-            
+
             // Test the case when the scope exists but contains wrong data
             CacheEntry cacheEntry = new BuildResultCacheEntry("Target2", null, true);
             cacheManager.SetCacheEntries(new CacheEntry[] { cacheEntry }, "test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
             Assert.IsNull(cacheManager.GetCachedBuildResult(length1Request, out actuallyBuiltTargets), "Expect a null return value if scope contains wrong data");
-            
+
             // Test the case when everything is correct
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.defaultTargetCacheName, string.Empty));
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.initialTargetCacheName, string.Empty));
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.projectIdCacheName, "1"));
-            
+
             cacheEntry = new BuildResultCacheEntry("Target1", null, true);
             cacheManager.SetCacheEntries(new CacheEntry[] { cacheEntry }, "test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
             BuildResult buildResult = cacheManager.GetCachedBuildResult(length1Request, out actuallyBuiltTargets);
@@ -139,7 +139,7 @@ public void TestRequestCaching()
             targets = new string[2]; targets[0] = "Target2"; targets[1] = "Target3";
             BuildRequest length2Request = new BuildRequest(1, "test.proj", targets, new BuildPropertyGroup(), null, 1, true, false);
             Assert.IsNull(cacheManager.GetCachedBuildResult(length2Request, out actuallyBuiltTargets), "Expect a null return value if partial data in the scope");
-            
+
             // Test the correctness case for multiple targets
             cacheEntry = new BuildResultCacheEntry("Target3", null, true);
             cacheManager.SetCacheEntries(new CacheEntry[] { cacheEntry }, "test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
@@ -168,7 +168,7 @@ public void TestRequestCachingDefaultInitialTargets()
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.defaultTargetCacheName, "Target1;Target2"));
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.initialTargetCacheName, "Initial1"));
             cacheScope.AddCacheEntry(new PropertyCacheEntry(Constants.projectIdCacheName, "5"));
-            
+
             CacheEntry cacheEntry = new BuildResultCacheEntry("Initial1", null, true);
             cacheManager.SetCacheEntries(new CacheEntry[] { cacheEntry }, "test.proj", new BuildPropertyGroup(), "3.5", CacheContentType.BuildResults);
             cacheEntry = new BuildResultCacheEntry("Target1", null, true);
diff --git a/src/Deprecated/Engine.UnitTests/CacheScope_Tests.cs b/src/Deprecated/Engine.UnitTests/CacheScope_Tests.cs
index c31074ed5fd..a456c1f074d 100644
--- a/src/Deprecated/Engine.UnitTests/CacheScope_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/CacheScope_Tests.cs
@@ -33,7 +33,7 @@ public class CacheScope_Tests
         public void Initialize()
         {
             // Create some items and place them in a dictionary
-            // Add some include information so that when we check the final 
+            // Add some include information so that when we check the final
             // item spec we can verify that the item was recreated properly
             BuildItem[] buildItems = new BuildItem[1];
             buildItems[0] = new BuildItem("BuildItem1", "Item1");
diff --git a/src/Deprecated/Engine.UnitTests/Choose_Tests.cs b/src/Deprecated/Engine.UnitTests/Choose_Tests.cs
index 01740c10dbf..599b02f4046 100644
--- a/src/Deprecated/Engine.UnitTests/Choose_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Choose_Tests.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.UnitTests
      * Class:   ChooseTests
      * Owner:   davidle
      *
-     * 
+     *
      */
     [TestFixture]
     sealed public class ChooseTests
@@ -61,7 +61,7 @@ public void ExcessivelyNestedChoose()
          * Method:  Basic
          * Owner:   davidle
          *
-         * 
+         *
          */
         [Test]
         public void ChooseNotTaken()
@@ -94,7 +94,7 @@ public void ChooseNotTaken()
         public void NeitherConditionTaken()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <Choose>
                     <When Condition=`1==2`>
@@ -119,7 +119,7 @@ public void NeitherConditionTaken()
         public void OtherwiseTaken()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <Choose>
                     <When Condition=`1==2`>
@@ -148,7 +148,7 @@ public void TwoOtherwiseErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <When Condition=`true`><PropertyGroup><x/></PropertyGroup></When>
@@ -178,7 +178,7 @@ public void JunkAfterWhenErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <When Condition=`true`>xyz
@@ -209,7 +209,7 @@ public void JunkAfterOtherwiseErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <When Condition=`true`>
@@ -242,7 +242,7 @@ public void BogusElementUnderChooseCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <abc/>
@@ -274,7 +274,7 @@ public void ChooseWithConditionErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose Condition=`true`>
                         <When Condition=`true`>
@@ -304,7 +304,7 @@ public void OtherwiseWithConditionErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         <When Condition=`true`>
@@ -335,7 +335,7 @@ public void JunkUnderChooseErrorCase()
             {
                 fExceptionCaught = false;
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <Choose>
                         abc
@@ -363,7 +363,7 @@ public void JunkUnderChooseErrorCase()
         public void PropertyAssignmentToItemListCase()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <ItemGroup>
                     <x Include=`x1` />
@@ -393,7 +393,7 @@ public void PropertyAssignmentToItemListCase()
         public void ItemListAndPropertiesCase()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <Choose>
                     <When Condition=`1==1`>
@@ -428,7 +428,7 @@ public void ItemGroupInAChooseConditionCase()
             try
             {
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                
+
                     <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                       <ItemGroup><x Include=`x1`/></ItemGroup>
                       <Choose>
@@ -455,7 +455,7 @@ public void ItemGroupInAChooseConditionCase()
         public void NestedChooseAndPropertyInConditionCase()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <Choose>
                     <When Condition=`1==1`>
@@ -482,7 +482,7 @@ public void NestedChooseAndPropertyInConditionCase()
         public void ChooseTakesSameWhenInPass1And2()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <PropertyGroup><takefirst>true</takefirst></PropertyGroup>
                   <Choose>
@@ -509,7 +509,7 @@ public void ChooseTakesSameWhenInPass1And2()
         public void ChooseTakesOtherwiseInPass1And2()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-            
+
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                   <PropertyGroup><takefirst>false</takefirst></PropertyGroup>
                   <PropertyGroup><tookfirst>false</tookfirst></PropertyGroup>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
index 7367de52082..7cf7e0ed76c 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     /// <summary>
     /// Indirection delegate type for AddNewImport Method invocation
     /// </summary>
-    public delegate void AddNewImportDelegate(Project p, string path, string condition); 
+    public delegate void AddNewImportDelegate(Project p, string path, string condition);
 
     /// <summary>
     /// indirection for  tests of Project.AddNewImport and ImportCollection.AddNewImport
@@ -30,7 +30,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     public abstract class AddNewImportTests
     {
         #region Indirection Delegates
-     
+
         /// <summary>
         /// Indirection delegate for AddNewImport Method invocation
         /// </summary>
@@ -38,12 +38,12 @@ protected AddNewImportDelegate InvokeAddNewImportMethod
         {
             get;
             set;
-        } 
+        }
 
         #endregion
 
         /// <summary>
-        ///  AddNewImport Test, Empty 
+        ///  AddNewImport Test, Empty
         /// </summary>
         [Test]
         [ExpectedException(typeof(ArgumentException))]
@@ -54,7 +54,7 @@ public void AddNewImportFileName_Empty()
         }
 
         /// <summary>
-        ///  AddNewImport Test, Null 
+        ///  AddNewImport Test, Null
         /// </summary>
         [Test]
         [ExpectedException(typeof(ArgumentNullException))]
@@ -65,7 +65,7 @@ public void AddNewImportFileName_Null()
         }
 
         /// <summary>
-        ///  AddNewImport Test, Where imported file does not exist 
+        ///  AddNewImport Test, Where imported file does not exist
         /// </summary>
         [Test]
         public void AddNewImportFile_DoesNotExist()
@@ -95,7 +95,7 @@ public void AddNewImportFile_NoReadPermissions()
         }
 
         /// <summary>
-        ///  AddNewImport Test, Import a file with an empty condition. 
+        ///  AddNewImport Test, Import a file with an empty condition.
         /// </summary>
         [Test]
         public void AddNewImportFile_EmptyCondition()
@@ -276,7 +276,7 @@ public void AddNewImportStandardTwice()
                 Assertion.AssertEquals(0, p.Imports.Count);
                 object o = p.EvaluatedItems;  // force evaluation of imported projects.
                 Assertion.AssertEquals(2, CompatibilityTestHelpers.CountNodesWithName(p.Xml, "Import"));  // 2 in xml
-                Assertion.AssertEquals(1, p.Imports.Count); // 1 in OM. 
+                Assertion.AssertEquals(1, p.Imports.Count); // 1 in OM.
             }
             finally
             {
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroupCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroupCollection_Tests.cs
index 2e75151dd74..f759aadb7a7 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroupCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroupCollection_Tests.cs
@@ -146,7 +146,7 @@ public void CountOne()
         [Test]
         public void CountImportedOnly()
         {
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Import Project='import.proj' />
                     </Project>
@@ -262,7 +262,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = @" 
+                importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1ImportedItem1 Include='n1iImportedItem1' />
@@ -280,7 +280,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = @" 
+                parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nMainItem1 Include='nMainItem1' />
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroup_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroup_Tests.cs
index 3f23ef5418e..2d100b12d75 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItemGroup_Tests.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     /// Test Fixture Class for the v9 Object Model Public Interface Compatibility Tests for the BuildItemGroup Class.
     /// </summary>
     [TestFixture]
-    public sealed class BuildItemGroup_Tests 
+    public sealed class BuildItemGroup_Tests
     {
         #region Common Helpers
         /// <summary>
@@ -89,7 +89,7 @@ public void Cleanup()
         #endregion
 
         /// <summary>
-        /// Example test for BuildItemGroup 
+        /// Example test for BuildItemGroup
         /// ****Don't keep this test once you're done automating****
         /// </summary>
         [Test]
@@ -801,7 +801,7 @@ public void RemoveEvaluatedItem1()
                 Project p = new Project(new Engine());
                 BuildItemGroup group = p.AddNewItemGroup();
                 group.AddNewItem("foos", Path.Combine(ObjectModelHelpers.TempProjectDir, "*.foo"));
-                object o = p.EvaluatedItems; // this causes the failure 
+                object o = p.EvaluatedItems; // this causes the failure
                 group.RemoveItem(p.EvaluatedItems[0]); // Exception thrown here
                 Assertion.Fail("success as failure"); // should not get here due to exception above
             }
@@ -1156,7 +1156,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = @" 
+                importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nImported Include='iImported' />
@@ -1175,7 +1175,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = @" 
+                parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1Main Include='iMain' />
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItem_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItem_Tests.cs
index 36346a09aed..6d6f10f2a5a 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildItem_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildItem_Tests.cs
@@ -119,8 +119,8 @@ public sealed class BuildItem_Tests
         /// <summary>
         /// string array of all Reserved Names for BuildItem name
         /// </summary>
-        private string[] reservedNames = new string[] 
-                { 
+        private string[] reservedNames = new string[]
+                {
                     "VisualStudioProject",
                     "Target",
                     "PropertyGroup",
@@ -400,7 +400,7 @@ public void ConditionGetEmptyString()
         [Test]
         public void ConditionGetFromImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nImported Include='iImported' Condition=""'a' == 'b'"" />
@@ -570,7 +570,7 @@ public void IncludeExcludeGetFromImportedProject()
         }
 
         /// <summary>
-        /// Tests BuildItem.Include attempt Set for an Imported BuildItem 
+        /// Tests BuildItem.Include attempt Set for an Imported BuildItem
         /// </summary>
         [Test]
         [ExpectedException(typeof(InvalidOperationException))]
@@ -957,7 +957,7 @@ public void CustomMetadataCountNamesWithNoCustomMetadata()
         [Test]
         public void CustomMetadataCountNamesWhenComingOnlyFromImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <nImported Include='iImported'>
@@ -988,7 +988,7 @@ public void CustomMetadataCountNamesWhenComingOnlyFromImportedProject()
         [Test]
         public void CustomMetadataCountNamesWhenComingOnlyFromParentProjectNoneFromImport()
         {
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nMain Include='iMain'>
@@ -1020,7 +1020,7 @@ public void CustomMetadataCountNamesWhenComingOnlyFromParentProjectNoneFromImpor
         [Test]
         public void CustomMetadataCountNamesWhenComingFromBothParentAndImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1030,7 +1030,7 @@ public void CustomMetadataCountNamesWhenComingFromBothParentAndImportedProject()
                             </Project>
                         ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nMain Include='iMain'>
@@ -1146,7 +1146,7 @@ public void MetadataCountNamesFromImportedProjectNoCustomMetadata()
         [Test]
         public void MetadataCountNamesFromImportedProjectWithCustomMetadata()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <nImported Include='iImported'>
@@ -1228,7 +1228,7 @@ public void CopyCustomMetadataToSelf()
         [Test]
         public void CopyCustomMetadataToAnotherBuildItemWithNoCustomMetadataInSameProject()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1258,7 +1258,7 @@ public void CopyCustomMetadataToAnotherBuildItemWithNoCustomMetadataInSameProjec
         [Test]
         public void CopyCustomMetadataToAntherBuildItemWithAllOtherDifferentCustomMetadata()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1293,7 +1293,7 @@ public void CopyCustomMetadataToAntherBuildItemWithAllOtherDifferentCustomMetada
         [Test]
         public void CopyCustomMetadataToAnotherBuildItemWithAllOtherSameCustomMetadata()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1328,7 +1328,7 @@ public void CopyCustomMetadataToAnotherBuildItemWithAllOtherSameCustomMetadata()
         [Test]
         public void CopyCustomMetadataToAnotherBuildItemWithSomeOtherSameCustomMetadata()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1369,7 +1369,7 @@ public void CopyCustomMetadataToAnotherBuildItemWithSomeOtherSameCustomMetadata(
         [Test]
         public void CopyCustomMetadataToNonImportedBuildItemFromAnImportedBuildItem()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1379,7 +1379,7 @@ public void CopyCustomMetadataToNonImportedBuildItemFromAnImportedBuildItem()
                             </Project>
                         ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nMain Include='iMain'>
@@ -1408,7 +1408,7 @@ public void CopyCustomMetadataToNonImportedBuildItemFromAnImportedBuildItem()
         [ExpectedException(typeof(InvalidOperationException))]
         public void CopyCustomMetadataToImportedBuildItem()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1418,7 +1418,7 @@ public void CopyCustomMetadataToImportedBuildItem()
                             </Project>
                         ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nMain Include='iMain'>
@@ -1437,12 +1437,12 @@ public void CopyCustomMetadataToImportedBuildItem()
         }
 
         /// <summary>
-        /// Tests BuildItem.CopyCustomMetadataTo 
+        /// Tests BuildItem.CopyCustomMetadataTo
         /// </summary>
         [Test]
         public void CopyCustomMetadataToAnotherBuildItemThenSaveToDisk()
         {
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <n1 Include='i1'>
@@ -1488,7 +1488,7 @@ public void CopyCustomMetadataToAnotherBuildItemThenSaveToDisk()
         [Test]
         public void GetEvaluatedMetadataSimple()
         {
-            string projectContents = @" 
+            string projectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <n Include='i' >
@@ -1518,7 +1518,7 @@ public void GetEvaluatedMetadataSimple()
         [Test]
         public void GetEvaluatedMetadataFromImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <nImported Include='iImported'>
@@ -1529,7 +1529,7 @@ public void GetEvaluatedMetadataFromImportedProject()
                         </Project>
                     ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nMain Include='iMain' />
@@ -1554,7 +1554,7 @@ public void GetEvaluatedMetadataFromImportedProject()
         [Test]
         public void GetEvaluatedMetadataNoPropertyToEvaluateAgainst()
         {
-            string projectContents = @" 
+            string projectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <n Include='i' >
@@ -1656,7 +1656,7 @@ public void GetMetadataWhenValueContainsEscapableCharacters()
         [Test]
         public void GetMetadataWhenMetadataImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1837,7 +1837,7 @@ public void RemoveMetadataOfBuiltInMetadata()
         [ExpectedException(typeof(InvalidOperationException))]
         public void RemoveMetadataFromImportedMetadata()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -1974,7 +1974,7 @@ public void SetMetadataValueToNull()
         [ExpectedException(typeof(InvalidOperationException))]
         public void SetMetadataOnImportedProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <ItemGroup>
                                     <nImported Include='iImported'>
@@ -2081,7 +2081,7 @@ public void SetMetadataTreatMetadataValueAsLiteral()
         [Test]
         public void CloneBackedByXml()
         {
-            string projectContents = @" 
+            string projectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <n Include='i' Exclude='e' Condition=""'a' == 'b'"" >
@@ -2136,7 +2136,7 @@ public void CloneVirtual()
         [Test]
         public void CloneImportedBuildItem()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                         <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <nImported Include='iImported'>
@@ -2202,7 +2202,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = @" 
+                importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nImported Include='iImported' />
@@ -2213,7 +2213,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = @" 
+                parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                             <nMain Include='iMain' />
@@ -2383,7 +2383,7 @@ private void VerifyEscapeCharactersThrowExpectedException(TypeOfTest testType)
 
         /// <summary>
         /// Un-registers the existing logger and registers a new copy.
-        /// We will use this when we do multiple builds so that we can safely 
+        /// We will use this when we do multiple builds so that we can safely
         /// assert on log messages for that particular build.
         /// </summary>
         private void ResetLogger()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroupCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroupCollection_Tests.cs
index 0ecfa85e42f..f128a2e4a60 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroupCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroupCollection_Tests.cs
@@ -25,13 +25,13 @@ public class BuildPropertyGroupCollection_Tests
         /// <summary>
         /// Basic Project Contents with 1 Property Group
         /// </summary>
-        private string basicProjectContentsOnePropertyGroup = @" 
+        private string basicProjectContentsOnePropertyGroup = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <n>v</n>
                     </PropertyGroup>
                 </Project>
-                "; 
+                ";
         #endregion
 
         #region Count Tests
@@ -41,7 +41,7 @@ public class BuildPropertyGroupCollection_Tests
         [Test]
         public void CountZero()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 </Project>
                 ";
@@ -70,7 +70,7 @@ public void CountOne()
         [Test]
         public void CountMany()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <Optimize>true</Optimize>
@@ -240,7 +240,7 @@ public void IsSynchronizedDefault()
             BuildPropertyGroupCollection groups = p.PropertyGroups;
 
             Assertion.AssertEquals(false, groups.IsSynchronized);
-        } 
+        }
         #endregion
 
         #region Helper Methods
@@ -267,13 +267,13 @@ private static void RemovePropertyGroupThatContainsSpecifiedBuildProperty(Projec
 
         /// <summary>
         /// Helper Method to create a Main project that imports 1 other project.  Each project contains only one Build Property Group
-        ///     and each of those Build Property Groups contain a Build Property of a specific name (which is used as a flag/key) to 
+        ///     and each of those Build Property Groups contain a Build Property of a specific name (which is used as a flag/key) to
         ///     identify which Build Property Group we're working with.
         /// </summary>
         /// <returns>Project</returns>
         private static Project GetProjectWithOneImportProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <imported>v</imported>
@@ -281,7 +281,7 @@ private static Project GetProjectWithOneImportProject()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <main>v</main>
@@ -300,14 +300,14 @@ private static Project GetProjectWithOneImportProject()
             Project p = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory("main.proj", null);
             return p;
         }
-        
+
         /// <summary>
         /// Helper Method to create a Main project that imports 2 other projects, each with build property groups
         /// </summary>
         /// <returns>Project</returns>
         private static Project GetProjectWithTwoImportProjects()
         {
-            string subProjectContents = @" 
+            string subProjectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <n1>v1</n1>
@@ -318,7 +318,7 @@ private static Project GetProjectWithTwoImportProjects()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <n>v</n>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroup_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroup_Tests.cs
index 510aa0c0cc7..14337bd8b66 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildPropertyGroup_Tests.cs
@@ -25,7 +25,7 @@ public class BuildPropertyGroup_Tests
         /// <summary>
         /// Basic project content start
         /// </summary>
-        private string basicProjectContentsBefore = @" 
+        private string basicProjectContentsBefore = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -41,7 +41,7 @@ public class BuildPropertyGroup_Tests
         /// <summary>
         /// Basic project content with only one property group
         /// </summary>
-        private string basicProjectContentsWithOnePropertyGroup = @" 
+        private string basicProjectContentsWithOnePropertyGroup = @"
                             <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <PropertyGroup>
                                     <n>v</n>
@@ -508,7 +508,7 @@ public void RemovePropertyByBuildPropertyAllOfSeveral()
             group.SetProperty("n2", "v2");
             group.SetProperty("n3", "v3");
 
-            BuildProperty[] property = new BuildProperty[] 
+            BuildProperty[] property = new BuildProperty[]
                 {
                     GetSpecificBuildPropertyOutOfBuildPropertyGroup(group, "n1"),
                     GetSpecificBuildPropertyOutOfBuildPropertyGroup(group, "n2"),
@@ -582,7 +582,7 @@ public void AddNewPropertyValueToEmptyString()
             Project p = Build.UnitTests.ObjectModelHelpers.CreateInMemoryProject(basicProjectContentsBefore);
             AddNewPropertyToEachPropertyGroup(p, "n", String.Empty);
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -609,7 +609,7 @@ public void AddNewPropertySimpleNameValue()
             Project p = Build.UnitTests.ObjectModelHelpers.CreateInMemoryProject(basicProjectContentsBefore);
             AddNewPropertyToEachPropertyGroup(p, "n", "v");
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -639,7 +639,7 @@ public void AddNewPropertySeveralNameValuePairs()
             AddNewPropertyToEachPropertyGroup(p, "n3", "v3");
             AddNewPropertyToEachPropertyGroup(p, "n4", "v4");
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -672,7 +672,7 @@ public void AddNewPropertySimpleNameValueWithTreatPropertyValueAsLiteralTrue()
             Project p = Build.UnitTests.ObjectModelHelpers.CreateInMemoryProject(basicProjectContentsBefore);
             AddNewPropertyToEachPropertyGroupWithPropertyValueAsLiteral(p, "n", @"%*?@$();\", true);
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -699,7 +699,7 @@ public void AddNewPropertySimpleNameValueWithTreatPropertyValueAsLiteralFalse()
             Project p = Build.UnitTests.ObjectModelHelpers.CreateInMemoryProject(basicProjectContentsBefore);
             AddNewPropertyToEachPropertyGroupWithPropertyValueAsLiteral(p, "n", @"%*?@$();\", false);
 
-            string projectContentsAfter = @" 
+            string projectContentsAfter = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <p1>true</p1>
@@ -763,7 +763,7 @@ public void AddNewPropertyToInMemoryGroup()
         [Test]
         public void ConditionGetWhenSetItXML()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup Condition="" '$(Foo)' == 'Bar' "">
                         <n1>v1</n1>
@@ -871,7 +871,7 @@ public void ConditionSetWithSpecialCharacters()
         [Test]
         public void IsImportedAllFromMainProject()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <n1>v1</n1>
@@ -898,7 +898,7 @@ public void IsImportedAllFromMainProject()
         [Test]
         public void IsImportedAllFromImportProject()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -917,7 +917,7 @@ public void IsImportedAllFromImportProject()
         [Test]
         public void IsImportedFromMainProjectAndImported()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <PropertyGroup>
                         <n1>v1</n1>
@@ -965,7 +965,7 @@ public void IsImportedWithVirtualPropertyGroups()
         [Test]
         public void SetImportedPropertyGroupConditionTrue()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -985,7 +985,7 @@ public void SetImportedPropertyGroupConditionTrue()
         [Test]
         public void SetImportedPropertyGroupConditionFalse()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -1005,7 +1005,7 @@ public void SetImportedPropertyGroupConditionFalse()
         [Test]
         public void SetImportedPropertyGroupCondition()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -1025,7 +1025,7 @@ public void SetImportedPropertyGroupCondition()
         [Test]
         public void SetImportedPropertyGroupConditionToEmtpySTring()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
@@ -1045,7 +1045,7 @@ public void SetImportedPropertyGroupConditionToEmtpySTring()
         [Test]
         public void SetImportedPropertyGroupConditionToNull()
         {
-            string projectContents = @" 
+            string projectContents = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets' />
                 </Project>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/BuildTask_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/BuildTask_Tests.cs
index a4a1e25db4e..bcf2cd1b28f 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/BuildTask_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/BuildTask_Tests.cs
@@ -150,7 +150,7 @@ public void ConditionGetSpecialCharacters()
         [Test]
         public void ConditionGetFromImportedProject()
         {
-            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace'>
                         <Target Name='t2' >
                         <t2.Task Condition=""'a' == 'b'"" >
@@ -383,7 +383,7 @@ public void ContinueOnErrorGetInvalid()
         [Test]
         public void ContinueOnErrorGetFromImportedProject()
         {
-            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace'>
                         <Target Name='t2' >
                             <t2.Task ContinueOnError='true' />
@@ -1005,7 +1005,7 @@ public void ExecuteOnTaskThatDoesNothing()
         [Test]
         public void ExecuteFromImportedProject()
         {
-            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+            string importProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Target Name='t' >
                             <Message Text='t.message' />
@@ -1013,7 +1013,7 @@ public void ExecuteFromImportedProject()
                     </Project>
                 ");
 
-            string parentProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+            string parentProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Import Project='import.proj' />
                     </Project>
@@ -1025,7 +1025,7 @@ public void ExecuteFromImportedProject()
             Assertion.AssertEquals(true, task.Execute());
         }
         #endregion
-        
+
         #region GetParameterNames Tests
         /// <summary>
         /// Tests BuildTask.GetParameterNames when only one parameter exists on the BuildTask
@@ -1541,7 +1541,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+                importProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Target Name='t2' >
                             <t2.Task2 parameter='value' />
@@ -1555,7 +1555,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = ObjectModelHelpers.CleanupFileContents(@" 
+                parentProjectContents = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                         <Target Name='t1'>
                             <t1.Task1 parameter='value' />
@@ -1572,7 +1572,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
         /// <summary>
         /// Un-registers the existing logger and registers a new copy.
-        /// We will use this when we do multiple builds so that we can safely 
+        /// We will use this when we do multiple builds so that we can safely
         /// assert on log messages for that particular build.
         /// </summary>
         private void ResetLogger()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
index 78659e6084c..f0d85703be9 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
@@ -49,7 +49,7 @@ internal static class TestData
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <PropertyGroup>
                             <value>true</value>
-                        </PropertyGroup>  
+                        </PropertyGroup>
                        <UsingTask TaskName='TaskName' AssemblyFile='AssemblyName.dll' Condition='$(value)==true'/>
                     </Project>";
 
@@ -60,7 +60,7 @@ internal static class TestData
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <PropertyGroup>
                             <n>xmlValue</n>
-                        </PropertyGroup>     
+                        </PropertyGroup>
                     </Project>
                 ";
 
@@ -177,7 +177,7 @@ internal static class TestData
                         <Target Name='TestTarget'>
                             <Message Text='Executed TestTarget'/>
                         </Target>
-                    
+
                 ";
 
         /// <summary>
@@ -232,7 +232,7 @@ internal static class TestData
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <PropertyGroup>
                             <n>xmlValue</n>
-                        </PropertyGroup>                        
+                        </PropertyGroup>
                         <Target Name='CreatePropertyTarget'>
                             <CreateProperty Value='v'>
                                   <Output TaskParameter='Value' PropertyName='p'/>
@@ -247,7 +247,7 @@ internal static class TestData
                         <Target Name='printn'>
                             <Message Text='value is $(n)'/>
                         </Target>
-                       
+
                     </Project>
                 ";
 
@@ -266,14 +266,14 @@ internal static class TestData
                         </Target>
                         <Target Name='Target2'>
                             <Message Text='Executed Target 2'/>
-                        </Target>                           
+                        </Target>
                     </Project>
                 ";
 
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ContentInvalidTargetsWithOutput = @" 
+        internal const string ContentInvalidTargetsWithOutput = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='Target1' Outputs='$(p);@(i);$(q)'>
                             <CreateProperty Value='v'>
@@ -288,7 +288,7 @@ internal static class TestData
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ContentValidTargetsWithOutput = @" 
+        internal const string ContentValidTargetsWithOutput = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                                 <PropertyGroup>
                                 <x>y</x>
@@ -307,13 +307,13 @@ internal static class TestData
                                 <q>u</q>
                             </PropertyGroup>
                         </Target>
-                          
+
                     </Project>";
 
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ItemGroup = @" 
+        internal const string ItemGroup = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup>
                                 <i Include='a' Condition='1==0'/>
@@ -325,7 +325,7 @@ internal static class TestData
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ItemGroup2 = @" 
+        internal const string ItemGroup2 = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup Condition='true'>
                                 <j Include='2a' Condition='1==0'/>
@@ -336,19 +336,19 @@ internal static class TestData
                                 <i2 Include='2a' Condition='1==0'/>
                                 <i2 Include='2b' Condition='true'/>
                                 <i2 Include='2c' Condition='true'/>
-                            </ItemGroup>  
+                            </ItemGroup>
                             <ItemGroup>
                                 <k Include='2a' Condition='1==0'/>
                                 <k Include='2b' Condition='true'/>
                                 <k Include='2c' Condition='true'/>
                             </ItemGroup>
-                           
+
                     </Project>";
 
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ItemGroup3 = @" 
+        internal const string ItemGroup3 = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <ItemGroup Condition='true'>
                                 <i Include='2a' Condition='1==0'/>
@@ -362,7 +362,7 @@ internal static class TestData
                                 <i Include='2a' Condition='1==0'/>
                                 <i Include='2b' Condition='true'/>
                                 <i Include='2c' Condition='true'/>
-                            </ItemGroup>  
+                            </ItemGroup>
                             <ItemGroup>
                                 <i Include='2a' Condition='1==0'/>
                                 <i Include='2b' Condition='true'/>
@@ -373,7 +373,7 @@ internal static class TestData
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string PropertyGroup = @" 
+        internal const string PropertyGroup = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <PropertyGroup Condition='true'>
                                 <n1 Condition='true'>v1</n1>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestHelpers.cs b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestHelpers.cs
index dd4aa83b78d..4ed7cdfc03f 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestHelpers.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestHelpers.cs
@@ -35,14 +35,14 @@ public static class CompatibilityTestHelpers
         /// URI for the msbuild xml schema
         /// </summary>
         internal static readonly Uri SchemaUrlMSBuild = new Uri("http://schemas.microsoft.com/developer/msbuild/2003");
-        
+
         /// <summary>
         /// Path for the msbuild xml schema
         /// </summary>
         internal static readonly string SchemaPathMSBuild = Path.Combine(SuiteBinPath, @"Microsoft.Build.xsd");
 
         /// <summary>
-        /// Field for suitbinPath, reference SuiteBinPath instead. 
+        /// Field for suitbinPath, reference SuiteBinPath instead.
         /// </summary>
         private static string suiteBinPath = null;
 
@@ -72,7 +72,7 @@ internal static string CreateTempProjectFile()
         }
 
         /// <summary>
-        /// Overload for project file content. 
+        /// Overload for project file content.
         /// </summary>
         /// <returns>Project File Content</returns>
         internal static string CreateTempProjectFile(string projContent)
@@ -83,11 +83,11 @@ internal static string CreateTempProjectFile(string projContent)
         /// <summary>
         /// Generate a C:\ drive path that is over a certain minimum length
         /// </summary>
-        /// 
+        ///
         internal static string GenerateLongPath(int minLength)
         {
             string folderName = "directory";
-            string drive = @"C:" + Path.DirectorySeparatorChar; 
+            string drive = @"C:" + Path.DirectorySeparatorChar;
             string longPath = drive;
             while (longPath.Length < (minLength + folderName.Length)) // does not consider slashes
             {
@@ -177,7 +177,7 @@ internal static Import GetImportByProjectPath(ImportCollection imports, string p
             {
                 if (import.ProjectPath == projPath)
                 {
-                    return import;           
+                    return import;
                 }
             }
 
@@ -205,7 +205,7 @@ internal static XmlNodeList GetNodesWithName(string projectXml, string nodeName)
 
             return nodes;
         }
-        
+
         /// <summary>
         /// Find and return a specified BuildProperty from a given project
         /// </summary>
@@ -224,7 +224,7 @@ internal static BuildProperty FindBuildProperty(Project p, string buildPropertyN
 
             return null;
         }
-           
+
         /// <summary>
         /// Find and return a specified BuildPropertyGroup from a given BuildProperty in a project
         /// </summary>
@@ -312,13 +312,13 @@ internal static UsingTask FindUsingTaskByName(string taskName, UsingTaskCollecti
         }
 
         /// <summary>
-        /// Construct a namespace manager 
+        /// Construct a namespace manager
         /// </summary>
         private static XmlNamespaceManager GetNsManager(XmlDocument xmlDoc)
         {
             XmlNamespaceManager namespaceManager = new XmlNamespaceManager(xmlDoc.NameTable);
             namespaceManager.AddNamespace("msb", CompatibilityTestHelpers.SchemaUrlMSBuild.ToString());
             return namespaceManager;
-        }      
+        }
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/EngineFileUtilities_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/EngineFileUtilities_Tests.cs
index 6d52b2ad042..144f075a8af 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/EngineFileUtilities_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/EngineFileUtilities_Tests.cs
@@ -19,7 +19,7 @@
 namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
 {
     /// <summary>
-    /// Test Fixture Class for the v9 Object Model Public Interface Compatibility Tests for the EngineFileUtilities Class. 
+    /// Test Fixture Class for the v9 Object Model Public Interface Compatibility Tests for the EngineFileUtilities Class.
     /// This is not a PRI 1 class for coverage
     /// </summary>
     [TestFixture]
@@ -30,7 +30,7 @@ public class EngineFileUtilities_Tests
         /// </summary>
         /// <remarks>found by kevinpi, Managed Lanaguages Team</remarks>
         [Test]
-        public void EscapeString_Null() 
+        public void EscapeString_Null()
         {
             try
             {
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/Engine_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/Engine_Tests.cs
index fb8071e9797..7a1a2d58135 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/Engine_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/Engine_Tests.cs
@@ -27,7 +27,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     [TestFixture]
     public sealed class Engine_Tests
     {
-        //// Note to CTI - http://msdn2.microsoft.com/en-us/library/microsoft.build.buildengine.engine.aspx is the 
+        //// Note to CTI - http://msdn2.microsoft.com/en-us/library/microsoft.build.buildengine.engine.aspx is the
         ////    MSDN of the Engine Class.
         #region Common Helpers
         /// <summary>
@@ -54,7 +54,7 @@ public void ConstructorEngineNoParameters()
 
             if (binPath20 == null)
             {
-                // if 2.0 can't be found in the registry, it's still the default, 
+                // if 2.0 can't be found in the registry, it's still the default,
                 // but we need to get it another way.
                 binPath20 = FrameworkLocationHelper.PathToDotNetFrameworkV20;
             }
@@ -113,7 +113,7 @@ public void ConstructorEngineBinPathNull()
         }
 
         /// <summary>
-        /// Tests the Engine Constructor - Engine(string binPath) with binpath 
+        /// Tests the Engine Constructor - Engine(string binPath) with binpath
         ///     set to the system root drive
         /// </summary>
         [Test]
@@ -125,7 +125,7 @@ public void ConstructorEngineBinPathRootDrive()
 
         /// <summary>
         /// Tests the Engine Constructor - Engine(string binPath) with a simple path
-        ///     that contains a trailing backslash.  Verify trailing backslash is 
+        ///     that contains a trailing backslash.  Verify trailing backslash is
         ///     removed.
         /// </summary>
         [Test]
@@ -1056,7 +1056,7 @@ public void BuildProjectFileDeepFolderLocation()
 
         #region BuildProjectFile(string projectFile, string targetName)
         /* This overload calls BuildProjectFile(projectFile, new string[] {targetName}, this.GlobalProperties,
-         *      null, BuildSettings.None) as such, passing on the projectFile and your targetName.  Because the 
+         *      null, BuildSettings.None) as such, passing on the projectFile and your targetName.  Because the
          *      null targetName is already covered in the BuildProjectFile(projectFile) overload, we don't
          *      need to test it again.
          */
@@ -1093,7 +1093,7 @@ public void BuildProjectFileTargetNameDoesNotExist()
 
         #region BuildProjectFile(string projectFile, string[] targetNames)
         /* This overload calls BuildProjectFile(projectFile, targetNames, this.GlobalProperties,
-                null, BuildSettings.None) as such, passing on the projectFile and your targetNames.  Because the 
+                null, BuildSettings.None) as such, passing on the projectFile and your targetNames.  Because the
          *      null targetNames is already covered in the BuildProjectFile(projectFile) overload, we don't
          *      need to test it again.
          */
@@ -1159,7 +1159,7 @@ public void BuildProjectFileTargetNamesSomeExistingSomeNonExisting()
          */
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties)
         ///     where globalProperties are null
         /// </summary>
         [Test]
@@ -1169,7 +1169,7 @@ public void BuildProjectFileGlobalPropertiesNull()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties)
         ///     where globalProperties are valid, different
         /// </summary>
         [Test]
@@ -1179,7 +1179,7 @@ public void BuildProjectFileGlobalPropertiesValidDifferent()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties)
         ///     where globalProperties are valid, same
         /// </summary>
         [Test]
@@ -1196,7 +1196,7 @@ public void BuildProjectFileGlobalPropertiesValidSame()
          */
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs)
         ///     where targetOutputs are null
         /// </summary>
         [Test]
@@ -1206,7 +1206,7 @@ public void BuildProjectFileTargetOutputsNull()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs)
         ///     where targetOutputs String.Empty
         /// </summary>
         [Test]
@@ -1216,7 +1216,7 @@ public void BuildProjectFileTargetOutputsEmptyString()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs)
         ///     where targetOutputs simple valid
         /// </summary>
         [Test]
@@ -1226,7 +1226,7 @@ public void BuildProjectFileTargetOutputsValid()
         }
 
         /// <summary>
-        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs) 
+        /// Tests Engine.BuildProjectFile(projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs)
         ///     where targetOutputs invalid
         /// </summary>
         [Test]
@@ -1280,7 +1280,7 @@ public void BuildProjectFileBuildFlagsDoNotResetPreviouslyBuiltTargetsMultipleSa
         #endregion
 
         #region BuildProjectFile(string projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs, BuildSettings buildFlags, string toolsVersion)
-        /* This is the method that all of the other BuildProjectFile overloads call (with null toolsVersion).  Therefore, 
+        /* This is the method that all of the other BuildProjectFile overloads call (with null toolsVersion).  Therefore,
          *  we don't need to re-test setting toolsVersion to null.
          */
 
@@ -1337,7 +1337,7 @@ public void BuildProjectFileToolsVersionInvalid()
          *  the example Dev Unit test.
          */
         #region Example Dev Unit Test For BuildProjectFiles()
-        //// Also, note in this example, there are examples of other Engine.Objects that should be 
+        //// Also, note in this example, there are examples of other Engine.Objects that should be
         //// useful for you.  RegisterDistributedLogger() tests below, you'll need to look at this
         //// ***************START: Example Dev Unit test***************
         ////[Test]
@@ -1406,7 +1406,7 @@ public void BuildProjectFileToolsVersionInvalid()
 
         /// <summary>
         /// Tests Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject,
-        ///                                 BuildPropertyGroup[] globalPropertiesPerProject, 
+        ///                                 BuildPropertyGroup[] globalPropertiesPerProject,
         ///                                 IDictionary[] targetOutputsPerProject, BuildSettings buildFlags,
         ///                                 string [] toolsVersions) with several project files (no traversal projects)
         ///                                 with no Project to Project (P2P) references between set of projects
@@ -1419,7 +1419,7 @@ public void BuildProjectFilesSeveralProjects()
 
         /// <summary>
         /// Tests Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject,
-        ///                                 BuildPropertyGroup[] globalPropertiesPerProject, 
+        ///                                 BuildPropertyGroup[] globalPropertiesPerProject,
         ///                                 IDictionary[] targetOutputsPerProject, BuildSettings buildFlags,
         ///                                 string [] toolsVersions) with a single traversal project that
         ///                                 points to several projects (no P2P references)
@@ -1432,9 +1432,9 @@ public void BuildProjectFilesTraveralProjectWithProjectsNoP2Ps()
 
         /// <summary>
         /// Tests Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject,
-        ///                                 BuildPropertyGroup[] globalPropertiesPerProject, 
+        ///                                 BuildPropertyGroup[] globalPropertiesPerProject,
         ///                                 IDictionary[] targetOutputsPerProject, BuildSettings buildFlags,
-        ///                                 string [] toolsVersions) with a single traversal project that points to 
+        ///                                 string [] toolsVersions) with a single traversal project that points to
         ///                                 4 projects (projects A, B, C and D) where A has a P2P to C, and B has
         ///                                 a P2P to D.
         /// </summary>
@@ -1446,7 +1446,7 @@ public void BuildProjectFilesTraveralProjectWithProjectsThatHaveP2Ps()
 
         /// <summary>
         /// Tests Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject,
-        ///                                 BuildPropertyGroup[] globalPropertiesPerProject, 
+        ///                                 BuildPropertyGroup[] globalPropertiesPerProject,
         ///                                 IDictionary[] targetOutputsPerProject, BuildSettings buildFlags,
         ///                                 string [] toolsVersions) with a traversal project, which in turn
         ///                                 points to several other traversal projects, each of which have their
@@ -1510,7 +1510,7 @@ public void GetLoadedProjectExisting()
         }
 
         /// <summary>
-        /// Tests Engine.GetLoadedProject(string projectFullFileName) with projectFullFileName set to an non-existing 
+        /// Tests Engine.GetLoadedProject(string projectFullFileName) with projectFullFileName set to an non-existing
         /// project file name, yet path exist
         /// </summary>
         [Test]
@@ -1614,7 +1614,7 @@ public void RegisterDistributedLoggerSameLoggerForCentralAndForwarding()
 
         #region RegisterLogger Tests
         /// <summary>
-        /// Tests Engine.RegisterLogger(ILogger logger) with 
+        /// Tests Engine.RegisterLogger(ILogger logger) with
         /// </summary>
         [Test]
         [Ignore("nyi")]
@@ -1689,7 +1689,7 @@ public void ShutdownLoadProjectLoggersNoBuild()
         }
 
         /// <summary>
-        /// Tests Engine.Shutdown() when you've loaded a project, loggers, etc, built, then only unloaded the loggers, 
+        /// Tests Engine.Shutdown() when you've loaded a project, loggers, etc, built, then only unloaded the loggers,
         ///     project still loaded
         /// </summary>
         [Test]
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/ImportCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/ImportCollection_Tests.cs
index a5c628e1154..59618157eba 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/ImportCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/ImportCollection_Tests.cs
@@ -32,7 +32,7 @@ public class ImportCollection_Tests : AddNewImportTests
         public ImportCollection_Tests()
         {
             InvokeAddNewImportMethod = new AddNewImportDelegate(AddNewImportOverload);
-        } 
+        }
 
         /// <summary>
         /// Count Test. Increment Count on Import Add
@@ -276,7 +276,7 @@ public void RemoveImport_SimpleDirtyAfterRemove()
             {
                 importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified);
                 projectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("project.proj", TestData.Content3SimpleTargetsDefaultSpecified);
-                Project p = new Project(); 
+                Project p = new Project();
                 p.Imports.AddNewImport(importPath, "true");
                 object o = p.EvaluatedItems;
                 Import import = CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath);
@@ -289,7 +289,7 @@ public void RemoveImport_SimpleDirtyAfterRemove()
             finally
             {
                 CompatibilityTestHelpers.RemoveFile(importPath);
-                CompatibilityTestHelpers.RemoveFile(projectPath); 
+                CompatibilityTestHelpers.RemoveFile(projectPath);
             }
         }
 
@@ -359,7 +359,7 @@ public void GetEnumerator()
         }
 
         /// <summary>
-        /// SyncRoot Test, Take a lock on SyncRoot then iterate over it. 
+        /// SyncRoot Test, Take a lock on SyncRoot then iterate over it.
         /// </summary>
         [Test]
         public void SyncRoot()
@@ -376,10 +376,10 @@ public void SyncRoot()
                 object o = p.EvaluatedItems;
                 Import[] importArray = new Import[p.Imports.Count];
                 p.Imports.CopyTo(importArray, 0);
-                lock (p.Imports.SyncRoot) 
+                lock (p.Imports.SyncRoot)
                 {
                     int i = 0;
-                    foreach (Import import in p.Imports) 
+                    foreach (Import import in p.Imports)
                     {
                         Assertion.AssertEquals(importArray[i].ProjectPath, import.ProjectPath);
                        i++;
@@ -394,7 +394,7 @@ public void SyncRoot()
         }
 
          /// <summary>
-        /// isSynchronized, is false : returned collection is not threadsafe.  
+        /// isSynchronized, is false : returned collection is not threadsafe.
         /// </summary>
         [Test]
         public void IsSynchronized()
@@ -420,6 +420,6 @@ public void IsSynchronized()
         private void AddNewImportOverload(Project p, string path, string condition)
         {
             p.Imports.AddNewImport(path, condition);
-        } 
+        }
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/Import_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/Import_Tests.cs
index 24f45c85abb..047d4385a1f 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/Import_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/Import_Tests.cs
@@ -24,13 +24,13 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     /// Also see Toolset tests in the Project test class.
     /// </summary>
     [TestFixture]
-    public sealed class Import_Tests 
+    public sealed class Import_Tests
     {
         /// <summary>
         /// Condition Test, Simple Condition, assert only accessible after evaluation.
         /// </summary>
         [Test]
-        public void ConditionGet_Simple() 
+        public void ConditionGet_Simple()
         {
             string importPath = String.Empty;
             try
@@ -44,9 +44,9 @@ public void ConditionGet_Simple()
                 import = CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath);
                 Assertion.AssertEquals("true", import.Condition);
             }
-            finally 
+            finally
             {
-                CompatibilityTestHelpers.RemoveFile(importPath);           
+                CompatibilityTestHelpers.RemoveFile(importPath);
             }
         }
 
@@ -81,7 +81,7 @@ public void ConditionSet_Null()
             string importPath = String.Empty;
             try
             {
-                importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified); 
+                importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified);
                 Project p = new Project();
                 p.AddNewImport(importPath, "true");
                 object o = p.EvaluatedProperties;
@@ -122,9 +122,9 @@ public void ConditionSet_DirtyWhenSet()
                 CompatibilityTestHelpers.RemoveFile(projectPath);
             }
         }
-       
+
         /// <summary>
-        /// ProjectPath Test, get when set in the constructor. 
+        /// ProjectPath Test, get when set in the constructor.
         /// </summary>
         [Test]
         public void ProjectPathGetWhenSetInCtor()
@@ -135,10 +135,10 @@ public void ProjectPathGetWhenSetInCtor()
                 importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified);
                 Project p = new Project();
                 p.AddNewImport(importPath, "true");
-                object o = p.EvaluatedProperties;  
-   
+                object o = p.EvaluatedProperties;
+
                 // The verbosity of this assertion is to abstract the internal implentation of FindFirstMatchingImportByPath.
-                Assertion.AssertEquals(importPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).ProjectPath); 
+                Assertion.AssertEquals(importPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).ProjectPath);
             }
             finally
             {
@@ -147,7 +147,7 @@ public void ProjectPathGetWhenSetInCtor()
         }
 
         /// <summary>
-        /// ProjectPath Test, get when set in ctor 
+        /// ProjectPath Test, get when set in ctor
         /// </summary>
         [Test]
         public void EvaluatedProjectPathGetWhenSetInCtor()
@@ -159,7 +159,7 @@ public void EvaluatedProjectPathGetWhenSetInCtor()
             {
                 Project p = new Project();
                 p.Load(projectPath);
- 
+
                 // The verbosity of this assertion is to abstract the internal implentation of FindFirstMatchingImportByPath.
                 Assertion.AssertEquals(fullImportPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).EvaluatedProjectPath);
             }
@@ -171,14 +171,14 @@ public void EvaluatedProjectPathGetWhenSetInCtor()
         }
 
         /// <summary>
-        /// ProjectPath Test, get when set in loaded xml. 
+        /// ProjectPath Test, get when set in loaded xml.
         /// </summary>
         [Test]
         public void ProjectPathGetWhenSetInXML()
         {
             string projectPath = String.Empty;
             string importPath = String.Empty;
-            string fullImportPath = String.Empty;            
+            string fullImportPath = String.Empty;
             try
             {
                 projectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("project.proj", TestData.ContentImportA);
@@ -186,7 +186,7 @@ public void ProjectPathGetWhenSetInXML()
                 fullImportPath = ObjectModelHelpers.CreateFileInTempProjectDirectory(importPath, TestData.ContentA);
                 Project p = new Project();
                 p.Load(projectPath);
-                Assertion.AssertEquals(importPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).ProjectPath);           
+                Assertion.AssertEquals(importPath, CompatibilityTestHelpers.FindFirstMatchingImportByPath(p.Imports, importPath).ProjectPath);
             }
             finally
             {
@@ -264,7 +264,7 @@ public void IsImported_ProjectImport()
         }
 
         /// <summary>
-        /// IsImported Test, true when import is via an imported project. 
+        /// IsImported Test, true when import is via an imported project.
         /// </summary>
         [Test]
         public void IsImported_ProjectImportImport()
@@ -300,7 +300,7 @@ public void IsImported_ProjectImportImport()
         public void ProjectPathSet_ScalarValue()
         {
             string importPath = String.Empty;
-            string importPath2 = String.Empty;           
+            string importPath2 = String.Empty;
             try
             {
                 importPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("import.proj", TestData.Content3SimpleTargetsDefaultSpecified);
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/InvalidProjectfileException_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/InvalidProjectfileException_Tests.cs
index c0bf9b10207..c557ff04b8c 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/InvalidProjectfileException_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/InvalidProjectfileException_Tests.cs
@@ -125,7 +125,7 @@ public void CtorArity4_NullMessageString()
         }
 
         /// <summary>
-        ///  Ctor Test 
+        ///  Ctor Test
         /// </summary>
         [Test]
         [ExpectedException(typeof(ArgumentException))]
@@ -157,7 +157,7 @@ public void CtorArity4_EmptyStringOtherParams()
         }
 
         /// <summary>
-        ///  Ctor Test 
+        ///  Ctor Test
         /// </summary>
         [Test]
         public void CtorArity4_NullStringOtherParams()
@@ -195,8 +195,8 @@ public void Ctor_Arity9PositveInts()
         }
 
         /// <summary>
-        ///  Ctor Test, this enforces lack of bounds checking and the lack of range checking (end can come before start) 
-        ///  on the line and column number params. 
+        ///  Ctor Test, this enforces lack of bounds checking and the lack of range checking (end can come before start)
+        ///  on the line and column number params.
         /// </summary>
         [Test]
         public void CtorArity9NegativeInts()
@@ -229,7 +229,7 @@ public void BaseMessage()
         }
 
         /// <summary>
-        /// XML Serialization Test, not supported, throws invalid operation Exception. 
+        /// XML Serialization Test, not supported, throws invalid operation Exception.
         /// </summary>
         [Test]
         [ExpectedException(typeof(InvalidOperationException))]
@@ -262,7 +262,7 @@ public void SerializationBinary()
             MemoryStream memoryStream = null;
             InvalidProjectFileException invalidProjectFileException =
                 new InvalidProjectFileException(projectFile, 1, 2, 3, 4, message, "errorSubCategory", "errorCode", "HelpKeyword");
-            
+
             try
             {
                 memoryStream = new MemoryStream();
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/InvalidToolsetDefinitionException_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/InvalidToolsetDefinitionException_Tests.cs
index cd392c6aa53..dff8021ab7d 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/InvalidToolsetDefinitionException_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/InvalidToolsetDefinitionException_Tests.cs
@@ -23,7 +23,7 @@
 namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
 {
     /// <summary>
-    /// STUB Fixture Class for the v9 OM Public Interface Compatibility Tests. RemoteErrorException class 
+    /// STUB Fixture Class for the v9 OM Public Interface Compatibility Tests. RemoteErrorException class
     /// Also see Toolset tests in the Project test class.
     /// </summary>
     [TestFixture]
@@ -40,12 +40,12 @@ public void CtorMessage()
         }
 
         /// <summary>
-        /// Ctor Test, set a null message. We do not guard against this. 
+        /// Ctor Test, set a null message. We do not guard against this.
         /// </summary>
         [Test]
         public void CtorMessage_Null()
         {
-            InvalidToolsetDefinitionException toolSetException = new InvalidToolsetDefinitionException(null); 
+            InvalidToolsetDefinitionException toolSetException = new InvalidToolsetDefinitionException(null);
         }
 
         /// <summary>
@@ -93,7 +93,7 @@ public void CtorArity3()
         }
 
         /// <summary>
-        /// XML Serialization Test, not supported, throws invalid operation Exception. 
+        /// XML Serialization Test, not supported, throws invalid operation Exception.
         /// </summary>
         [Test]
         [ExpectedException(typeof(InvalidOperationException))]
@@ -111,9 +111,9 @@ public void SerializationXML()
             }
             finally
             {
-                memoryStream.Close(); 
+                memoryStream.Close();
             }
-        }       
+        }
 
         /// <summary>
         /// Binary Serialization Test, serialize the exception out and back in from a stream. This uses the protected constructor
@@ -140,7 +140,7 @@ public void SerializationBinary()
         }
 
         /// <summary>
-        /// Binary Serialization Test, serialize a inherited exception out and back in from a stream. 
+        /// Binary Serialization Test, serialize a inherited exception out and back in from a stream.
         /// </summary>
         [Test]
         public void ProtectedConstructorTest()
@@ -175,15 +175,15 @@ internal class ExtendsInvalidToolsetDefinitionException : InvalidToolsetDefiniti
             /// </summary>
             public ExtendsInvalidToolsetDefinitionException(string message, string errorCode)
                 : base(message, errorCode)
-            { 
+            {
             }
 
             /// <summary>
             /// Basic Constructor Override
             /// </summary>
             public ExtendsInvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
-                : base(info, context) 
-            { 
+                : base(info, context)
+            {
             }
         }
     }
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/Project_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/Project_Tests.cs
index 443f8ab355f..1872557281b 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/Project_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/Project_Tests.cs
@@ -92,7 +92,7 @@ public void ConstructToolsVersionKnown_3_5()
                 }
                 else
                 {
-                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed."); 
+                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed.");
                 }
             }
 
@@ -177,7 +177,7 @@ public void ConstructToolsVersion_Known()
             }
 
             /// <summary>
-            /// Constructor Test, with Engine object, Null ToolsVersion 
+            /// Constructor Test, with Engine object, Null ToolsVersion
             /// </summary>
             [Test]
             public void ConstructToolsVersion_Null()
@@ -228,7 +228,7 @@ public void DefaultToolsVersionSetGet_Unknown()
                 Project p = new Project(new Engine());
                 p.DefaultToolsVersion = "999999";
 
-                // setting an unknown ToolsVersion will cause the DefaultToolsVersion (and ToolsVersion) 
+                // setting an unknown ToolsVersion will cause the DefaultToolsVersion (and ToolsVersion)
                 // to default to "4.0"
                 Assertion.AssertEquals("4.0", p.DefaultToolsVersion);
             }
@@ -304,7 +304,7 @@ public void ToolsVersionGetWhenSetInXml_3_5()
                 }
                 else
                 {
-                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed."); 
+                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed.");
                 }
             }
 
@@ -343,7 +343,7 @@ public void ToolsVersionGetWhenSetInProjectConstructor_3_5()
                 }
                 else
                 {
-                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed."); 
+                    Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed.");
                 }
             }
 
@@ -364,7 +364,7 @@ public void ToolsVersionGetWhenSetInProjectConstructor_4_0()
         [TestFixture]
         public sealed class TargetsCollection
         {
-            // More Tests in the target collection class. 
+            // More Tests in the target collection class.
 
             /// <summary>
             /// Target Test, Get a list of targets
@@ -443,7 +443,7 @@ public void AddNewUsingTaskFromAssemblyName()
         }
 
         /// <summary>
-        /// Tests for HasUnsavedChanges TimeOfLastChange 
+        /// Tests for HasUnsavedChanges TimeOfLastChange
         /// </summary>
         [TestFixture]
         public sealed class Dirty
@@ -633,7 +633,7 @@ public void SchemaFileIsValidatedValidXmlInvalidSchema()
             }
 
             /// <summary>
-            ///  SchemaFileIsValidated Test, setup valid project xml against invalid schema but turn 
+            ///  SchemaFileIsValidated Test, setup valid project xml against invalid schema but turn
             ///  validation off so it never runs.
             /// </summary>
             [Test]
@@ -845,7 +845,7 @@ public void BuildImportRemovedImport()
                     Project p = ObjectModelHelpers.CreateInMemoryProject(TestData.Content3SimpleTargetsNoDefaultSpecified, logger);
                     p.Imports.AddNewImport(projImport1, "true");
                     p.Imports.AddNewImport(projImport2, "true");
-                    object o = p.EvaluatedItems; // force evaluation of imported projects.               
+                    object o = p.EvaluatedItems; // force evaluation of imported projects.
                     p.Imports.RemoveImport(CompatibilityTestHelpers.GetImportByProjectPath(p.Imports, projImport2));
                     p.Build("ImportTarget1b");
                     Assertion.AssertEquals(false, logger.FullLog.Contains("Executed ImportTarget 2a"));
@@ -911,7 +911,7 @@ public void BuildIncrementalTargetExecutionFlag_Off()
                 Project p = ObjectModelHelpers.CreateInMemoryProject(TestData.Content3SimpleTargetsNoDefaultSpecified, logger);
                 p.Build("Target2");
                 bool buildSuccessful = p.Build(new string[] { "Target1" }, null, BuildSettings.None);
-               
+
                 Assertion.AssertEquals(true, buildSuccessful);
                 string skippedMessage = ResourceUtilities.FormatResourceString("TargetAlreadyCompleteSuccess", "Target1");
                 string skippedMessage2 = ResourceUtilities.FormatResourceString("TargetAlreadyCompleteSuccess", "Target2");
@@ -981,7 +981,7 @@ public void ResetBuildVirtualPropertyRemoval()
                 p.Build("CreatePropertyTarget");
                 Assertion.AssertEquals("v", p.GetEvaluatedProperty("p"));
                 p.ResetBuildStatus();
-                Assertion.AssertEquals(null, p.GetEvaluatedProperty("p")); 
+                Assertion.AssertEquals(null, p.GetEvaluatedProperty("p"));
             }
 
             /// <summary>
@@ -1032,7 +1032,7 @@ public void ResetBuildVirtualItemReset()
                 Assertion.AssertEquals(preCount - 1, p.EvaluatedItems.Count);
             }
         }
-      
+
         /// <summary>
         /// Tests for BuildEnabled property.
         /// </summary>
@@ -1149,7 +1149,7 @@ public sealed class XmlEncoding
             // More extensive tests of this property elsewhere in unit testing framework.
 
             /// <summary>
-            /// Encoding Test, Get, when set to default (UTF8) 
+            /// Encoding Test, Get, when set to default (UTF8)
             /// </summary>
             [Test]
             public void Encoding_Get_Default_UTF8()
@@ -1171,7 +1171,7 @@ public void Encoding_Get_Custom_Invalid()
             }
 
             /// <summary>
-            /// Encoding Test, get when set to invalid encoding 
+            /// Encoding Test, get when set to invalid encoding
             /// </summary>
             [Test]
             public void Encoding_Get_Custom_UTF16()
@@ -1195,7 +1195,7 @@ public sealed class Load
             ///  <bug>
             ///   Project.cs
             ///   Before: ErrorUtilities.VerifyThrowArgument(projectFileName.Length > 0, "EmptyProjectFileName" +buildEventContext.ToString());
-            ///   After: ErrorUtilities.VerifyThrowArgument(projectFileName.Length > 0, "EmptyProjectFileName"); 
+            ///   After: ErrorUtilities.VerifyThrowArgument(projectFileName.Length > 0, "EmptyProjectFileName");
             ///   Threw ArgumentException due to invalid keying into resources.
             ///  </bug>
             /// </bugs>
@@ -1219,10 +1219,10 @@ public void LoadProjectFileName_Null()
             }
 
             /// <summary>
-            ///   Load Test, load a project file twice. Unload Previous project, dump from cache. 
+            ///   Load Test, load a project file twice. Unload Previous project, dump from cache.
             /// </summary>
             /// <remarks>
-            ///  This is a test for nametable colissions on shared engines. 
+            ///  This is a test for nametable colissions on shared engines.
             ///  An Debug assertion was removed from Engine to prevent the assert from blocking suites.
             /// </remarks>
             [Test]
@@ -1272,7 +1272,7 @@ public void LoadProjectFile_FileContentEmpty()
             /// <summary>
             /// Load Test, with Valid Project File Name, which does not exist.
             /// </summary>
-            /// <remarks> 
+            /// <remarks>
             /// FileNotFound throws to expose ArgumentException in version v9 and earlier
             /// versions post v9 should throw and expose FileNotFoundException
             /// </remarks>
@@ -1298,7 +1298,7 @@ public void LoadProjectFileName_FileSystemPath()
             }
 
             /// <summary>
-            /// Load Test, Check FullFileName is set 
+            /// Load Test, Check FullFileName is set
             /// </summary>
             /// <bugs>
             ///  <bug>
@@ -1316,7 +1316,7 @@ public void LoadProjectFileName_isFullFileNameSet()
             }
 
             /// <summary>
-            /// Load Test, Check FullFileName is set 
+            /// Load Test, Check FullFileName is set
             /// </summary>
             /// <bugs>
             ///  <bug>
@@ -1451,7 +1451,7 @@ public void LoadProjectFile_IOException()
             /// </summary>
             /// <remarks>
             /// The file refereced in this test does not exist, as it cannot be created in
-            /// the file system. 
+            /// the file system.
             /// </remarks>
             [Test]
             [ExpectedException(typeof(ArgumentException))]
@@ -1561,7 +1561,7 @@ public void LoadProjectXMLString_Valid()
             }
 
             /// <summary>
-            /// Load Test, from a string of INVALID xml, 
+            /// Load Test, from a string of INVALID xml,
             /// </summary>
             [Test]
             [ExpectedException(typeof(InvalidProjectFileException))]
@@ -1583,7 +1583,7 @@ public void LoadProjectXMLString_CatchMissingImports()
             }
 
             /// <summary>
-            /// Load Test, from a string of xml 
+            /// Load Test, from a string of xml
             /// </summary>
             [Test]
             public void LoadProjectXMLString_IsDirtyAfterLoad()
@@ -1594,7 +1594,7 @@ public void LoadProjectXMLString_IsDirtyAfterLoad()
             }
 
             /// <summary>
-            /// Load Test, from a string of invalid xml 
+            /// Load Test, from a string of invalid xml
             /// </summary>
             [Test]
             public void LoadProjectXMLString_IgnoreMissingImports()
@@ -1609,7 +1609,7 @@ public void LoadProjectXMLString_IgnoreMissingImports()
         /// Tests for Save, Save TextReader.
         /// </summary>
         [TestFixture]
-        public sealed class Save 
+        public sealed class Save
         {
             /// <summary>
             ///  Save Test, Path is empty String
@@ -1725,7 +1725,7 @@ public void SaveInvalidFileName()
             /// </summary>
             /// <remarks>
             /// The file refereced in this test does not exist, as it cannot be created in
-            /// the file system. 
+            /// the file system.
             /// </remarks>
             [Test]
             [ExpectedException(typeof(PathTooLongException))]
@@ -1845,7 +1845,7 @@ public void Xml_GetAfterOMChange()
         }
 
         /// <summary>
-        /// Tests for the DefaultTargets Property. 
+        /// Tests for the DefaultTargets Property.
         /// </summary>
         [TestFixture]
         public sealed class DefaultTargets
@@ -1896,7 +1896,7 @@ public void DefaultTargetsGetWhenNotExplicitySetInXml()
             }
 
             /// <summary>
-            /// DefaultTargets Test, Set where defaultTargets contains a target that does not exist. 
+            /// DefaultTargets Test, Set where defaultTargets contains a target that does not exist.
             /// </summary>
             [Test]
             public void DefaultTargetsSetMissingTarget()
@@ -1905,11 +1905,11 @@ public void DefaultTargetsSetMissingTarget()
                 Project p = ObjectModelHelpers.CreateInMemoryProject(TestData.Content3SimpleTargetsDefaultSpecified, logger);
                 p.DefaultTargets = "missingTarget";
                 p.Build();
-                Assertion.AssertEquals(true, logger.FullLog.Contains("MSB4057")); // error MSB4057, the target does not exist 
+                Assertion.AssertEquals(true, logger.FullLog.Contains("MSB4057")); // error MSB4057, the target does not exist
             }
 
             /// <summary>
-            /// DefaultTargets Test, where defaultTargets list contain null targets. 
+            /// DefaultTargets Test, where defaultTargets list contain null targets.
             /// </summary>
             [Test]
             public void DefaultTargetsSetNullItemsInTargetList()
@@ -1936,7 +1936,7 @@ public void DefaultTargetsSpecialCharacterDelimiter()
                 p.Build();
 
                 // Test
-                Assertion.AssertEquals(true, logger.FullLog.Contains("MSB4057")); // error MSB4057, the target "TestTarget;TestTarget1" does not exist 
+                Assertion.AssertEquals(true, logger.FullLog.Contains("MSB4057")); // error MSB4057, the target "TestTarget;TestTarget1" does not exist
             }
 
             /// <summary>
@@ -1948,11 +1948,11 @@ public void DefaultTargetsSpecialCharactersInTargetName()
                 // Execute
                 Project p = new Project(new Engine());
                 p.DefaultTargets = "valid@target;$\\valid;%valid()";
-                Assertion.AssertEquals("valid@target; $\\valid; %valid()", p.DefaultTargets); // note whitespace 
+                Assertion.AssertEquals("valid@target; $\\valid; %valid()", p.DefaultTargets); // note whitespace
             }
 
             /// <summary>
-            /// DefaultTargets Test, where value contains empty items and 
+            /// DefaultTargets Test, where value contains empty items and
             /// excess whitespace around target names
             /// </summary>
             [Test]
@@ -1994,7 +1994,7 @@ public void DefaultTargets_IsDirtyWhenSet()
                 Assertion.AssertEquals(true, p.IsDirty);
             }
         }
-        
+
         /// <summary>
         /// Tests for the FullfileName Property.
         /// </summary>
@@ -2002,7 +2002,7 @@ public void DefaultTargets_IsDirtyWhenSet()
         public sealed class FullFileName
         {
             /// <summary>
-            ///  FullFileName Test, set then get 
+            ///  FullFileName Test, set then get
             /// </summary>
             [Test]
             public void FullFileNameSetGet()
@@ -2053,7 +2053,7 @@ public void FullFileNameSetProjectIsNotDirtyAfter()
         public sealed class InitialTargets
         {
             /// <summary>
-            ///  InitialTargets Test, set then get 
+            ///  InitialTargets Test, set then get
             /// </summary>
             [Test]
             public void InitialTargetsSetGet()
@@ -2064,7 +2064,7 @@ public void InitialTargetsSetGet()
             }
 
             /// <summary>
-            ///  InitialTargets Test, set then get 
+            ///  InitialTargets Test, set then get
             /// </summary>
             [Test]
             public void InitialTargetsSetGetMultiple()
@@ -2075,7 +2075,7 @@ public void InitialTargetsSetGetMultiple()
             }
 
             /// <summary>
-            ///  InitialTargets Test, 
+            ///  InitialTargets Test,
             /// </summary>
             [Test]
             public void InitialTargetsSetGetMultipleSpecialcharacters()
@@ -2164,7 +2164,7 @@ public void RemoveImportedPropertyGroupInvalidOp()
                 {
                     importedProjFilename = ObjectModelHelpers.CreateTempFileOnDisk(TestData.PropertyGroup);
                     mainProjFilename = ObjectModelHelpers.CreateTempFileOnDisk(TestData.Content3SimpleTargetsDefaultSpecified);
-                    Project mainProject = new Project(new Engine());                                         
+                    Project mainProject = new Project(new Engine());
                     Project importedProject = new Project(mainProject.ParentEngine);
                     mainProject.Load(mainProjFilename);
                     importedProject.Load(importedProjFilename);
@@ -2246,7 +2246,7 @@ public void GetConditionedPropertyValues_Null()
                 Project p = new Project();
                 string[] values = p.GetConditionedPropertyValues(null);
             }
-        
+
             /// <summary>
             /// Test the RemoveAllPropertyGroups method.
             /// </summary>
@@ -2331,7 +2331,7 @@ public void RemoveAllPropertyGroupsByConditionWithChoose()
                             <PropertyGroup Condition=`'$(x)'=='y'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
-  
+
                             <PropertyGroup Condition=`'$(x)'=='z'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
@@ -2340,7 +2340,7 @@ public void RemoveAllPropertyGroupsByConditionWithChoose()
                             <PropertyGroup Condition=`'$(x)'=='y'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
-  
+
                             <PropertyGroup Condition=`'$(x)'=='z'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
@@ -2532,7 +2532,7 @@ public void SetPropertyBeforeImportDoesNotExists()
                     object o = p.EvaluatedItems;
                     Assertion.AssertEquals(true, p.Xml.IndexOf("vNew") < p.Xml.IndexOf("Import"));
                 }
-                finally 
+                finally
                 {
                     CompatibilityTestHelpers.RemoveFile(importPath);
                 }
@@ -2576,7 +2576,7 @@ public void SetPropertyAfterImportWherePropertyExistsBefore()
                     object o = p.EvaluatedItems;
                     Assertion.AssertEquals(true, p.Xml.IndexOf("vNew") < p.Xml.IndexOf("Import"));
                 }
-                finally 
+                finally
                 {
                     CompatibilityTestHelpers.RemoveFile(importPath);
                 }
@@ -2740,7 +2740,7 @@ public void AddNewProperty_InvalidOp()
 
             /// <summary>
             /// AddNewPropertyGroup Test, before other groups
-            /// 
+            ///
             /// If "insertAtEnd", is inserted at the very end. Otherwise,
             /// we add the new property group just after the last property group in the
             /// main project file.  If there are currently no property groups in the main
@@ -2760,7 +2760,7 @@ public void AddNewPropertyGroupBeforeWithOneOtherPropertyGroup()
 
             /// <summary>
             /// AddNewPropertyGroup Test, before other groups
-            /// 
+            ///
             /// If "insertAtEnd", is inserted at the very end. Otherwise,
             /// we add the new property group just after the last property group in the
             /// main project file.  If there are currently no property groups in the main
@@ -2874,9 +2874,9 @@ public Import()
             {
                 InvokeAddNewImportMethod = new AddNewImportDelegate(AddNewImportOverload);
             }
-          
+
             /// <summary>
-            ///  Import Test, Get Import 
+            ///  Import Test, Get Import
             /// </summary>
             [Test]
             public void ImportsGet()
@@ -2958,7 +2958,7 @@ public void SetImportedPropertyThatExists()
             /// </summary>
             [Test]
             public void SetPropertySetValueLiteralFlag()
-            { 
+            {
                 string importedProjFilename = String.Empty;
                 string mainProjFilename = String.Empty;
                 try
@@ -2988,7 +2988,7 @@ public void SetPropertySetValueLiteralFlag()
             }
 
             /// <summary>
-            ///  SetImportedProperty Test,  null property name 
+            ///  SetImportedProperty Test,  null property name
             /// </summary>
             [Test]
             [ExpectedException(typeof(ArgumentNullException))]
@@ -3078,7 +3078,7 @@ private void AddNewImportOverload(Project p, string path, string condition)
         /// Tests for ProjectExtensions
         /// </summary>
         [TestFixture]
-        public sealed class ProjectExtensions 
+        public sealed class ProjectExtensions
         {
             /// <summary>
             /// GetProjectExtensions Test, where item id exists
@@ -3111,7 +3111,7 @@ public void GetProjectExtensionsWhereElementofIdMissing()
             }
 
             /// <summary>
-            /// GetProjectExtensions Test, check that namespace attributes are removed from nodes under an Id. 
+            /// GetProjectExtensions Test, check that namespace attributes are removed from nodes under an Id.
             /// </summary>
             [Test]
             public void GetProjectExtensionsNodePurgeNamespace()
@@ -3160,7 +3160,7 @@ public void SetProjectExtensionsNewItem_Null()
         /// Tests for EvaluatedItems EvaluatedItemsIgnoringCondition
         /// </summary>
         [TestFixture]
-        public sealed class EvaluatedItems 
+        public sealed class EvaluatedItems
         {
             /// <summary>
             /// EvaluatedItems, add an item, check addition to OM and xml
@@ -3220,7 +3220,7 @@ public void EvaluatedItemsIgnoreCondition()
         /// </summary>
         [TestFixture]
         public sealed class BuildItems
-        { 
+        {
             /// <summary>
             /// AddNewItem Test, pass in a a null item name
             /// </summary>
@@ -3302,7 +3302,7 @@ public void AddNewItemIncludePrecidece_SameTypes()
                 p.AddNewItem("i2", "d");
                 XmlDocument xmldoc = new XmlDocument();
                 xmldoc.LoadXml(p.Xml);
-                Assertion.AssertEquals(true, CompatibilityTestHelpers.GetNodesWithName(p.Xml, "ItemGroup")[1].InnerXml.Contains("Include=\"d\"")); 
+                Assertion.AssertEquals(true, CompatibilityTestHelpers.GetNodesWithName(p.Xml, "ItemGroup")[1].InnerXml.Contains("Include=\"d\""));
             }
 
             /// <summary>
@@ -3310,7 +3310,7 @@ public void AddNewItemIncludePrecidece_SameTypes()
             /// </summary>
             [Test]
             public void AddNewItemIncludePrecidece_NewGroup()
-            {       
+            {
                 Project p = ObjectModelHelpers.CreateInMemoryProject(TestData.ItemGroup2);
                 XmlDocument xmldoc = new XmlDocument();
                 xmldoc.LoadXml(p.Xml);
@@ -3528,11 +3528,11 @@ public void RemoveItemDirtyAfterRemove()
 
             /// <summary>
             /// RemoveItem Test, check that itemgroup is removed if removed item
-            /// was the last in the group. 
+            /// was the last in the group.
             /// </summary>
             [Test]
             public void RemoveItemLastInGroup()
-            {    
+            {
                 Project p = new Project();
                 BuildItem buildItem = p.AddNewItem("n", "i");
                 Assertion.AssertEquals(1, p.ItemGroups.Count);
@@ -3561,7 +3561,7 @@ public void RemoveItemsByNameXmlAndVirtual()
                 p.AddNewItem("j", "virtual");
                 p.RemoveItemsByName("j");
             }
-              
+
             /// <summary>
             /// ItemGroups Test, Assert colection contains virutal an concrete items
             /// </summary>
@@ -3594,7 +3594,7 @@ public void GetEvaluatedItemsByNameDoesNotExistItem()
                 Project p = new Project();
                 string name = "notFound";
                 BuildItemGroup emptyGroup = p.GetEvaluatedItemsByName(name);
-                Assertion.AssertEquals(0, emptyGroup.Count);  
+                Assertion.AssertEquals(0, emptyGroup.Count);
             }
 
             /// <summary>
@@ -3605,7 +3605,7 @@ public void GetEvaluatedItemsByNameTwoItems()
             {
                 Project p = new Project();
                 string name = "new";
-                p.SetProperty("condition", "false");            
+                p.SetProperty("condition", "false");
                 BuildItem buildItem = p.AddNewItem(name, "i1");
                 buildItem.Condition = "$(condition)";
                 p.AddNewItem(name, "i2");
@@ -3633,7 +3633,7 @@ public void GetEvaluatedItemsByNameIgnoringCondition()
             /// RemoveAllItemGroups Test, Remove all Item groups
             /// </summary>
             [Test]
-            public void RemoveAllItemGroups() 
+            public void RemoveAllItemGroups()
             {
                 Project p = new Project();
                 p.AddNewItem("item", "i");
@@ -3643,7 +3643,7 @@ public void RemoveAllItemGroups()
             }
 
             /// <summary>
-            /// RemoveAllItemGroups Test, project 
+            /// RemoveAllItemGroups Test, project
             /// </summary>
             [Test]
             public void RemoveAllItemGroupsDirtyAfterRemove()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/TargetCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/TargetCollection_Tests.cs
index 929bbcd5363..c8cbac228f7 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/TargetCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/TargetCollection_Tests.cs
@@ -108,7 +108,7 @@ public void CountMany()
         [Test]
         public void CountWithImportedTargets()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t2'>
                             <Message Text='imported.t2.task' />
@@ -117,7 +117,7 @@ public void CountWithImportedTargets()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='parent.t1.task' />
@@ -139,7 +139,7 @@ public void CountWithImportedTargets()
         [Test]
         public void CountWhenImportedAndParentBothContainSameTarget()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='imported.t2.task' />
@@ -147,7 +147,7 @@ public void CountWhenImportedAndParentBothContainSameTarget()
                     </Project>
                 ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='parent.t1.task' />
@@ -245,7 +245,7 @@ public void ExistsOfImportedTarget()
         [Test]
         public void ExistsWhenImportedTargetAndParentTargetHaveSameName()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='imported.t2.task' />
@@ -253,7 +253,7 @@ public void ExistsWhenImportedTargetAndParentTargetHaveSameName()
                     </Project>
                 ";
 
-            string parentProjectContents = @" 
+            string parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='parent.t1.task' />
@@ -401,7 +401,7 @@ public void CopyToSimple()
 
             object[] array = new object[targets.Count];
             targets.CopyTo(array, 0);
-            
+
             List<string> listOfTargets = new List<string>();
             foreach (Target t in array)
             {
@@ -527,7 +527,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
         {
             if (String.IsNullOrEmpty(importProjectContents))
             {
-                importProjectContents = @" 
+                importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t2' />
                         <Target Name='t3' DependsOnTargets='t2' Inputs='in' Outputs='out' Condition=""'true' == 'true'""/>
@@ -538,7 +538,7 @@ private Project GetProjectThatImportsAnotherProject(string importProjectContents
 
             if (String.IsNullOrEmpty(parentProjectContents))
             {
-                parentProjectContents = @" 
+                parentProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='parent.t1.task' />
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/Target_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/Target_Tests.cs
index 5e0eb30a014..7668dea1cc5 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/Target_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/Target_Tests.cs
@@ -39,7 +39,7 @@ public class Target_Tests
         /// </summary>
         private const string ProjectContentOneTargetWithInputsOutputs = @"
                                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                                    <Target Name='t1' 
+                                    <Target Name='t1'
                                             Outputs='out'
                                             Inputs='in' />
                                 </Project>
@@ -837,7 +837,7 @@ public void RemoveTaskAttemptWithTaskThatsInAnotherTarget()
         /// <summary>
         /// Tests Target.RemoveTask by attempting to remove a task from an imported target
         /// </summary>
-        [Test]  
+        [Test]
         [ExpectedException(typeof(InvalidOperationException))]
         public void RemoveTaskAttemptRemovalOfAnImportedTask()
         {
@@ -1063,7 +1063,7 @@ public void IsImportedOfANonImportedTarget()
         [Test]
         public void IsImportedTargetOfSameNameInBothWhereImportedComesLast()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='imported.t1.task' />
@@ -1071,7 +1071,7 @@ public void IsImportedTargetOfSameNameInBothWhereImportedComesLast()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='main.t1.task' />
@@ -1097,7 +1097,7 @@ public void IsImportedTargetOfSameNameInBothWhereImportedComesLast()
         [Test]
         public void IsImportedTargetOfSameNameInBothWhereImportedComesFirst()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1'>
                             <Message Text='imported.t1.task' />
@@ -1105,7 +1105,7 @@ public void IsImportedTargetOfSameNameInBothWhereImportedComesFirst()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Import Project='import.proj' />
                         <Target Name='t1'>
@@ -1170,7 +1170,7 @@ private static void SaveProjectToDiskAndCompareAgainstExpectedContents(Project p
         /// <returns>Project</returns>
         private static Project GetProjectWithOneImportProject()
         {
-            string importProjectContents = @" 
+            string importProjectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='t1' Condition=""'true' == 'true'"" Inputs='in' Outputs='out'>
                             <Message Text='imported.t1.task1' />
@@ -1179,7 +1179,7 @@ private static Project GetProjectWithOneImportProject()
                     </Project>
                 ";
 
-            string projectContents = @" 
+            string projectContents = @"
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Import Project='import1.proj' />
                         <Target Name='Build'>
@@ -1249,7 +1249,7 @@ private ITaskItem[] BuildAndGatherOutputs(string targetToBuild)
 
         /// <summary>
         /// Un-registers the existing logger and registers a new copy.
-        /// We will use this when we do multiple builds so that we can safely 
+        /// We will use this when we do multiple builds so that we can safely
         /// assert on log messages for that particular build.
         /// </summary>
         private void ResetLogger()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/ToolSet_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/ToolSet_Tests.cs
index 40c3501be80..18f16e6a9c5 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/ToolSet_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/ToolSet_Tests.cs
@@ -130,7 +130,7 @@ public void ToolsetImportProperties()
         /// </summary>
         [Test]
         public void ToolsetImportPropertiesNull()
-        {           
+        {
             BuildPropertyGroup buildPropertyGroup = null;
             Toolset toolset = new Toolset("toolversion", "c:\aPath", buildPropertyGroup);
             Assertion.AssertEquals(0, toolset.BuildProperties.Count);
@@ -163,7 +163,7 @@ public void ToolVersionGet()
         }
 
         /// <summary>
-        /// Toolset Test. Get Path (note stripping of the last slash) 
+        /// Toolset Test. Get Path (note stripping of the last slash)
         /// </summary>
         [Test]
         public void ToolPathGetTrailingSlash()
@@ -173,7 +173,7 @@ public void ToolPathGetTrailingSlash()
         }
 
         /// <summary>
-        /// Toolset Test. Get Path (root path, don't strip slash) 
+        /// Toolset Test. Get Path (root path, don't strip slash)
         /// </summary>
         [Test]
         public void ToolPathGetRootPath()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/ToolsetCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/ToolsetCollection_Tests.cs
index b49e5d85d1d..35055c8c6a4 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/ToolsetCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/ToolsetCollection_Tests.cs
@@ -181,7 +181,7 @@ public void ContainsObject_found()
             Toolset toolset2 = new Toolset("v2", @"c:\path");
             e.Toolsets.Add(toolset1);
             e.Toolsets.Add(toolset2);
-            
+
             Assertion.AssertEquals(true, e.Toolsets.Contains(toolset1));
         }
 
@@ -199,7 +199,7 @@ public void ContainsObject_notFound()
         }
 
         /// <summary>
-        /// Contains Test, by object. 
+        /// Contains Test, by object.
         /// </summary>
         [Test]
         public void ContainsToolsVersion_found()
@@ -213,7 +213,7 @@ public void ContainsToolsVersion_found()
         }
 
         /// <summary>
-        /// Contains Test, by object. 
+        /// Contains Test, by object.
         /// </summary>
         [Test]
         public void ContainsToolsVersion_notFound()
@@ -227,7 +227,7 @@ public void ContainsToolsVersion_notFound()
         }
 
         /// <summary>
-        /// Contains Test, by object. 
+        /// Contains Test, by object.
         /// </summary>
         [Test]
         public void ContainsToolsVersion_escapedVersions()
@@ -254,7 +254,7 @@ public void CopyToTest_IndexZero()
             Toolset toolset2 = new Toolset("v2", @"c:\path");
             e.Toolsets.Add(toolset1);
             e.Toolsets.Add(toolset2);
-            Toolset[] toolsetArray = new Toolset[e.Toolsets.Count]; 
+            Toolset[] toolsetArray = new Toolset[e.Toolsets.Count];
             e.Toolsets.CopyTo(toolsetArray, 0);
             Assertion.AssertEquals(e.Toolsets.Count, toolsetArray.Length);
             Assertion.AssertEquals(true, 0 < Array.IndexOf(toolsetArray, toolset1));
@@ -281,7 +281,7 @@ public void CopyToTest_OffsetIndex()
         }
 
         /// <summary>
-        /// CopyTo Test, copy into array that is initialized too small to contain all toolsets, 
+        /// CopyTo Test, copy into array that is initialized too small to contain all toolsets,
         /// at index zero
         /// </summary>
         [Test]
@@ -291,7 +291,7 @@ public void CopyToTest_ArrayTooSmall()
             Engine e = new Engine();
             Toolset toolset1 = new Toolset("v1", @"c:\path");
             e.Toolsets.Add(toolset1);
-            e.Toolsets.CopyTo(new Toolset[e.Toolsets.Count - 1], 0);  
+            e.Toolsets.CopyTo(new Toolset[e.Toolsets.Count - 1], 0);
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/UsingTaskCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/UsingTaskCollection_Tests.cs
index 7e9875d1e9c..5f65032a302 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/UsingTaskCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/UsingTaskCollection_Tests.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.UnitTests.OM.OrcasCompatibility
     public class UsingTaskCollection_Tests
     {
         /// <summary>
-        /// Imports Cache issue causes xml not to be loaded 
+        /// Imports Cache issue causes xml not to be loaded
         /// This is a test case to reproduce some quirkiness  found when running tests out of order.
         /// </summary>
         [Test]
@@ -116,10 +116,10 @@ public void Count_DecrementOnRemove()
         }
 
         /// <summary>
-        /// IsSynchronized Test           
+        /// IsSynchronized Test
         /// </summary>
         [Test]
-        public void IsSynchronized() 
+        public void IsSynchronized()
         {
             Project p = new Project(new Engine());
             p.AddNewUsingTaskFromAssemblyFile("TaskName", "AssemblyFile.dll");
@@ -127,7 +127,7 @@ public void IsSynchronized()
         }
 
         /// <summary>
-        /// SyncRoot Test, ensure that SyncRoot returns and we can take a lock on it.           
+        /// SyncRoot Test, ensure that SyncRoot returns and we can take a lock on it.
         /// </summary>
         [Test]
         public void SyncRoot()
@@ -149,7 +149,7 @@ public void SyncRoot()
         }
 
         /// <summary>
-        /// SyncRoot Test, copy into a strongly typed array and assert content against the source collection.        
+        /// SyncRoot Test, copy into a strongly typed array and assert content against the source collection.
         /// </summary>
         [Test]
         public void CopyTo_ZeroIndex()
@@ -168,7 +168,7 @@ public void CopyTo_ZeroIndex()
         }
 
         /// <summary>
-        /// SyncRoot Test, copy into a strongly typed array and assert content against the source collection.        
+        /// SyncRoot Test, copy into a strongly typed array and assert content against the source collection.
         /// </summary>
         [Test]
         public void CopyTo_OffsetIndex()
@@ -189,7 +189,7 @@ public void CopyTo_OffsetIndex()
         }
 
         /// <summary>
-        /// SyncRoot Test, copy into a strongly typed array with an offset where the array is too small      
+        /// SyncRoot Test, copy into a strongly typed array with an offset where the array is too small
         /// </summary>
         [Test]
         [ExpectedException(typeof(ArgumentException))]
@@ -204,7 +204,7 @@ public void CopyTo_OffsetIndexArrayTooSmall()
         }
 
         /// <summary>
-        /// Copy to a weakly typed array, no offset. Itterate over collection 
+        /// Copy to a weakly typed array, no offset. Itterate over collection
         /// </summary>
         [Test]
         public void CopyTo_WeakAndGetEnumerator()
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/UsingTask_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/UsingTask_Tests.cs
index a18ddc9fb3c..1d3cc395fa9 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/UsingTask_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/UsingTask_Tests.cs
@@ -111,7 +111,7 @@ public void GetAssemblyFileNameSpecialCharsEscaped()
             string assemblyFileName = @"%25%2a%3f%40%24%28%29%3b\";
             Assertion.AssertNotNull(SetandGetAssemblyFileName(assemblyFileName));
         }
-        
+
         /// <summary>
         /// AssemblyFile test, set special non-escaped characters in ctor then get.
         /// </summary>
@@ -170,9 +170,9 @@ public void GetUsingTaskAssemblyFile_SetInXml()
             Assertion.AssertEquals("AssemblyName.dll", CompatibilityTestHelpers.FindUsingTaskByName("TaskName", p.UsingTasks).AssemblyFile);
         }
 
-        #endregion 
+        #endregion
 
-        #region TaskName 
+        #region TaskName
 
         /// <summary>
         /// TaskName Test, simple get
@@ -228,7 +228,7 @@ public void GetTaskNameSpeicalCharsEscaped()
         #region IsImported
 
         /// <summary>
-        /// IsImported Test, assert true for an improted file. 
+        /// IsImported Test, assert true for an improted file.
         /// </summary>
         [Test]
         public void IsImported_true()
@@ -251,7 +251,7 @@ public void IsImported_true()
         }
 
         /// <summary>
-        /// IsImported Test, assert true for an imported file. 
+        /// IsImported Test, assert true for an imported file.
         /// </summary>
         [Test]
         public void IsImported_false()
@@ -260,7 +260,7 @@ public void IsImported_false()
             p.LoadXml(TestData.ContentUsingTaskFile);
             object o = p.EvaluatedProperties;
             Assertion.AssertEquals(false, CompatibilityTestHelpers.FindUsingTaskByName("TaskName", p.UsingTasks).IsImported);
-        }   
+        }
 
         #endregion
 
@@ -303,7 +303,7 @@ public void GetUsingTaskCondition_SetInXml()
         #endregion
 
         /// <summary>
-        /// Set an assembly file name, then retrieve it. 
+        /// Set an assembly file name, then retrieve it.
         /// </summary>
         private string SetandGetAssemblyFileName(string assemblyFileName)
         {
@@ -312,6 +312,6 @@ private string SetandGetAssemblyFileName(string assemblyFileName)
             object o = p.EvaluatedItems;
             UsingTask usingTask = CompatibilityTestHelpers.FindUsingTaskByName("TaskName", p.UsingTasks);
             return usingTask.AssemblyFile;
-        }   
+        }
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/ConsoleLogger_Tests.cs b/src/Deprecated/Engine.UnitTests/ConsoleLogger_Tests.cs
index c20ec968081..1950b531777 100644
--- a/src/Deprecated/Engine.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ConsoleLogger_Tests.cs
@@ -104,7 +104,7 @@ private static void SingleMessageTest(LoggerVerbosity v, MessageImportance j, bo
                                   sc.Write, null, null);
                 L.Initialize(es, i);
                 string msg = "my 1337 message";
-                
+
                 BuildMessageEventArgs be = new BuildMessageEventArgs(msg, "help", "sender", j);
                 be.BuildEventContext = new BuildEventContext(1, 2, 3, 4);
                 es.RaiseMessageEvent(null, be);
@@ -279,7 +279,7 @@ public void TestVerbosityLessThan()
                 (new SerialConsoleLogger(LoggerVerbosity.Detailed)).IsVerbosityAtLeast(LoggerVerbosity.Detailed));
             Assertion.AssertEquals( false,
                 (new SerialConsoleLogger(LoggerVerbosity.Detailed)).IsVerbosityAtLeast(LoggerVerbosity.Diagnostic));
-            
+
             Assertion.AssertEquals( true,
                 (new SerialConsoleLogger(LoggerVerbosity.Diagnostic)).IsVerbosityAtLeast(LoggerVerbosity.Quiet));
             Assertion.AssertEquals( true,
@@ -362,7 +362,7 @@ public void SingleMessageTests_quiet_low()
         public void SingleMessageTests_quiet_medium()
         {
                 SingleMessageTest(LoggerVerbosity.Quiet,
-                                 MessageImportance.Normal, false); 
+                                 MessageImportance.Normal, false);
         }
 
         [Test]
@@ -373,7 +373,7 @@ public void SingleMessageTests_quiet_high()
         }
 
         [Test]
-        public void SingleMessageTests_medium_low() 
+        public void SingleMessageTests_medium_low()
         {
                 SingleMessageTest(LoggerVerbosity.Minimal,
                                  MessageImportance.Low, false);
@@ -383,7 +383,7 @@ public void SingleMessageTests_medium_low()
         public void SingleMessageTests_medium_medium()
         {
                 SingleMessageTest(LoggerVerbosity.Minimal,
-                                 MessageImportance.Normal, false); 
+                                 MessageImportance.Normal, false);
         }
 
         [Test]
@@ -402,9 +402,9 @@ public void SingleMessageTests_normal_low()
 
         [Test]
         public void SingleMessageTests_normal_medium()
-        { 
+        {
                 SingleMessageTest(LoggerVerbosity.Normal,
-                                 MessageImportance.Normal, true); 
+                                 MessageImportance.Normal, true);
         }
 
         [Test]
@@ -425,7 +425,7 @@ public void SingleMessageTests_detailed_low()
         public void SingleMessageTests_detailed_medium()
         {
                 SingleMessageTest(LoggerVerbosity.Detailed,
-                                 MessageImportance.Normal, true); 
+                                 MessageImportance.Normal, true);
         }
 
         [Test]
@@ -443,10 +443,10 @@ public void SingleMessageTests_diagnostic_low()
         }
 
         [Test]
-        public void SingleMessageTests_diagnostic_medium() 
+        public void SingleMessageTests_diagnostic_medium()
         {
                 SingleMessageTest(LoggerVerbosity.Diagnostic,
-                                 MessageImportance.Normal, true); 
+                                 MessageImportance.Normal, true);
         }
 
         [Test]
@@ -648,7 +648,7 @@ public void TestQuietWithError()
                 BuildErrorEventArgs beea = new BuildErrorEventArgs("VBC",
                                 "31415", "file.vb", 42, 0, 0, 0,
                                 "Some long message", "help", "sender");
-                
+
                 beea.BuildEventContext = buildEventContext;
                 es.RaiseErrorEvent(null, beea);
 
@@ -1076,7 +1076,7 @@ public void SingleLineFormatNoop()
             string ss = cl.IndentString(s, 0);
 
             //should be a no-op
-            Assertion.AssertEquals("foo" + Environment.NewLine, ss); 
+            Assertion.AssertEquals("foo" + Environment.NewLine, ss);
         }
 
         [Test]
@@ -1092,8 +1092,8 @@ public void MultilineFormatWindowsLineEndings()
             //should convert lines to system format
             Assertion.AssertEquals("    foo" + Environment.NewLine +
                                    "    bar" + Environment.NewLine +
-                                   "    baz" + Environment.NewLine + 
-                                   "    " + Environment.NewLine, ss); 
+                                   "    baz" + Environment.NewLine +
+                                   "    " + Environment.NewLine, ss);
         }
 
         [Test]
@@ -1107,7 +1107,7 @@ public void MultilineFormatUnixLineEndings()
             //should convert lines to system format
             Assertion.AssertEquals("foo" + Environment.NewLine +
                                    "bar" + Environment.NewLine +
-                                   "baz" + Environment.NewLine + Environment.NewLine, ss); 
+                                   "baz" + Environment.NewLine + Environment.NewLine, ss);
         }
 
         [Test]
@@ -1303,19 +1303,19 @@ public void NestedProjectNormal()
         [Test]
         public void CustomDisplayedAtDetailed()
         {
-            EventSource es = new EventSource(); 
-            SimulatedConsole sc = new SimulatedConsole(); 
+            EventSource es = new EventSource();
+            SimulatedConsole sc = new SimulatedConsole();
             ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Detailed,
                                                 sc.Write, null, null);
-            L.Initialize(es); 
+            L.Initialize(es);
 
-            MyCustomBuildEventArgs c = 
+            MyCustomBuildEventArgs c =
                     new MyCustomBuildEventArgs("msg");
 
             es.RaiseCustomEvent(null, c);
 
-            Assertion.AssertEquals("msg" + Environment.NewLine, 
-                                   sc.ToString()); 
+            Assertion.AssertEquals("msg" + Environment.NewLine,
+                                   sc.ToString());
         }
 
         [Test]
@@ -1338,18 +1338,18 @@ public void CustomDisplayedAtDiagnosticMP()
         [Test]
         public void CustomNotDisplayedAtNormal()
         {
-            EventSource es = new EventSource(); 
-            SimulatedConsole sc = new SimulatedConsole(); 
+            EventSource es = new EventSource();
+            SimulatedConsole sc = new SimulatedConsole();
             ConsoleLogger L = new ConsoleLogger(LoggerVerbosity.Normal,
                                                 sc.Write, null, null);
-            L.Initialize(es); 
+            L.Initialize(es);
 
-            MyCustomBuildEventArgs c = 
+            MyCustomBuildEventArgs c =
                     new MyCustomBuildEventArgs("msg");
 
             es.RaiseCustomEvent(null, c);
 
-            Assertion.AssertEquals(String.Empty, sc.ToString()); 
+            Assertion.AssertEquals(String.Empty, sc.ToString());
         }
 
         /// <summary>
@@ -1453,7 +1453,7 @@ public void DoNotDisplayPropertiesListIfDisabled()
             cl2.ParseParameters();
 
             WriteAndValidateProperties(cl, sc, false);
-        }       
+        }
 
         /// <summary>
         /// Create some items and log them
@@ -1488,7 +1488,7 @@ private void WriteAndValidateItems(BaseConsoleLogger cl, SimulatedConsole sc, bo
 
             item1type = "type" + Environment.NewLine;
             item2type = "type2" + Environment.NewLine;
-            
+
             string log = sc.ToString();
 
             Console.WriteLine("[" + log + "]");
@@ -1650,7 +1650,7 @@ public void DoNotDisplayItemListIfDisabled()
             cl2.ParseParameters();
 
             WriteAndValidateItems(cl2, sc, false);
-        }       
+        }
 
         [Test]
         public void ParametersEmptyTests()
@@ -1766,7 +1766,7 @@ public void ResetConsoleLoggerStateTestBasic()
             es.RaiseBuildStartedEvent(null,
                          new BuildStartedEventArgs("bs", null));
 
-            // BuildFinished 
+            // BuildFinished
             es.RaiseBuildFinishedEvent(null,
                           new BuildFinishedEventArgs("bf",
                                                      null, true));
@@ -1783,12 +1783,12 @@ public void ResetConsoleLoggerStateTestBasic()
             Assertion.Assert(!actualLog.Contains(warningString));
             Assertion.Assert(!actualLog.Contains("<red>"));
             Assertion.Assert(!actualLog.Contains("<yellow>"));
-            
+
             // errorString = 0 Error(s)
             // warningString = 0 Warning(s)
             errorString = ResourceUtilities.FormatResourceString("ErrorCount", 0);
             warningString = ResourceUtilities.FormatResourceString("WarningCount", 0);
-            
+
             // Verify that the log has correct error and warning string
             Assertion.Assert(actualLog.Contains(errorString));
             Assertion.Assert(actualLog.Contains(warningString));
@@ -1835,8 +1835,8 @@ public void ResetConsoleLoggerState_Initialize()
 
             es.RaiseErrorEvent(null, beea);
 
-            // NOTE: We don't call the es.RaiseBuildFinishedEvent(...) here as this 
-            // would call ResetConsoleLoggerState and we will fail to detect if Initialize() 
+            // NOTE: We don't call the es.RaiseBuildFinishedEvent(...) here as this
+            // would call ResetConsoleLoggerState and we will fail to detect if Initialize()
             // is not calling it.
 
             // Log so far
@@ -1860,7 +1860,7 @@ public void ResetConsoleLoggerState_Initialize()
             es.RaiseBuildStartedEvent(null,
                          new BuildStartedEventArgs("bs", null));
 
-            // BuildFinished 
+            // BuildFinished
             es.RaiseBuildFinishedEvent(null,
                           new BuildFinishedEventArgs("bf",
                                                      null, true));
@@ -1922,7 +1922,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
 
                 TaskStartedEventArgs taskStarted1 = new TaskStartedEventArgs(null, null, null, null, "task");
                 taskStarted1.BuildEventContext = project1Started.BuildEventContext;
-                // TaskStarted Event 
+                // TaskStarted Event
                 es.RaiseTaskStartedEvent(null, taskStarted1);
 
                 BuildMessageEventArgs messsage1 = new BuildMessageEventArgs(null, null, null, MessageImportance.High);
@@ -1950,7 +1950,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
 
                 TaskStartedEventArgs taskStarted2 = new TaskStartedEventArgs(null, null, null, null, "task2");
                 taskStarted2.BuildEventContext = project2Started.BuildEventContext;
-                // TaskStarted Event 
+                // TaskStarted Event
                 es.RaiseTaskStartedEvent(null, taskStarted2);
 
                 BuildMessageEventArgs messsage2 = new BuildMessageEventArgs(null, null, null, MessageImportance.High);
@@ -2000,7 +2000,7 @@ public void ResetConsoleLoggerState_PerformanceCounters()
                 // BuildStarted event
                 es.RaiseBuildStartedEvent(null,
                              new BuildStartedEventArgs("bs", null));
-                // BuildFinished 
+                // BuildFinished
                 es.RaiseBuildFinishedEvent(null,
                               new BuildFinishedEventArgs("bf",
                                                          null, true));
@@ -2054,7 +2054,7 @@ public void DeferredMessages()
                                                      null, true));
             actualLog = sc.ToString();
             Assertion.Assert(actualLog.Contains(ResourceUtilities.FormatResourceString("DeferredMessagesAvailiable")));
-            
+
             es = new EventSource();
             sc = new SimulatedConsole();
             // Create a ConsoleLogger with Normal verbosity
@@ -2159,9 +2159,9 @@ public void TestPrintTargetNamePerMessage()
         }
 
         /// <summary>
-        /// Verify that in the MP case and the older serial logger that there is no extra newline after the project done event. 
+        /// Verify that in the MP case and the older serial logger that there is no extra newline after the project done event.
         /// We cannot verify there is a newline after the project done event for the MP single proc log because
-        /// nunit is showing up as an unknown output type, this causes us to not print the newline because we think it may be to a 
+        /// nunit is showing up as an unknown output type, this causes us to not print the newline because we think it may be to a
         /// text file.
         /// </summary>
         [Test]
@@ -2172,7 +2172,7 @@ public void TestNewLineAfterProjectFinished()
             {
                 Console.Out.WriteLine("Iteration of I is {" + i + "}");
 
-                
+
                 EventSource es = new EventSource();
                 //Create a simulated console
                 SimulatedConsole sc = new SimulatedConsole();
diff --git a/src/Deprecated/Engine.UnitTests/CopyOnWriteHashtable_Tests.cs b/src/Deprecated/Engine.UnitTests/CopyOnWriteHashtable_Tests.cs
index 8a1b3cf86ea..0a277eee44a 100644
--- a/src/Deprecated/Engine.UnitTests/CopyOnWriteHashtable_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/CopyOnWriteHashtable_Tests.cs
@@ -29,7 +29,7 @@ public void Basic()
 
             // Just wrote to 'c' so it should contain data.
             Assertion.Assert(c.ContainsKey("Foo"));
-            
+
             // Writing to a depended upon hashtable should not be visible to the dependents.
             Assertion.Assert(!a.ContainsKey("Foo"));
             Assertion.Assert(!b.ContainsKey("Foo"));
@@ -63,7 +63,7 @@ public void Regress450669_CaseSensitiveBatch_HashtableCopyRespectsComparer()
         {
             Hashtable c = new Hashtable(StringComparer.OrdinalIgnoreCase);
             c["key"] = null;
-            CopyOnWriteHashtable refc = new CopyOnWriteHashtable(c, StringComparer.OrdinalIgnoreCase); 
+            CopyOnWriteHashtable refc = new CopyOnWriteHashtable(c, StringComparer.OrdinalIgnoreCase);
 
             Assertion.Assert(c.ContainsKey("kEy"));
             Assertion.Assert(refc.ContainsKey("kEy"));
@@ -72,7 +72,7 @@ public void Regress450669_CaseSensitiveBatch_HashtableCopyRespectsComparer()
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: (Note 1)
-        /// 
+        ///
         /// In this test, verify that a CopyOnWriteHashtable passed through the constructor that
         /// accepts an IDictionary results in a shallow copy not a deep copy.
         /// </summary>
@@ -88,7 +88,7 @@ public void Regress_Mutation_ConstructThroughDictionaryIsShallowCopy()
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: (Note 1)
-        /// 
+        ///
         /// In this test, verify that writing a value that exists already in a shallow copy
         /// doesn't cause a deep copy of the hash table.
         /// </summary>
@@ -98,7 +98,7 @@ public void Regress_Mutation_WritingSameValueShouldNotCauseDeepCopy()
             CopyOnWriteHashtable c = new CopyOnWriteHashtable(StringComparer.OrdinalIgnoreCase);
             c["answer"] = "yes";
             CopyOnWriteHashtable refc = new CopyOnWriteHashtable(c, StringComparer.OrdinalIgnoreCase);
-            
+
             Assertion.Assert(refc.IsShallowCopy);
             refc["answer"] = "yes";
             Assertion.Assert(refc.IsShallowCopy);  // Setting the same value should not cause a deep copy.
@@ -107,10 +107,10 @@ public void Regress_Mutation_WritingSameValueShouldNotCauseDeepCopy()
 
         /// <summary>
         /// Missing unittest found by mutation testing.
-        /// REASON TEST WASN'T ORIGINALLY PRESENT: This is a design change, we require a string comparer 
+        /// REASON TEST WASN'T ORIGINALLY PRESENT: This is a design change, we require a string comparer
         /// in all cases because we can't construct a deep copy without always knowing what string
         /// comparer to use.
-        /// 
+        ///
         /// In this test, try to construct a CopyOnWriteHashtable with no string comparer.
         /// </summary>
         [Test]
@@ -122,10 +122,10 @@ public void Regress_Mutation_MustHaveNonNullStringComparer()
 
         /// <summary>
         /// Missing unittest found by mutation testing.
-        /// REASON TEST WASN'T ORIGINALLY PRESENT: This is a design change, we require a string comparer 
+        /// REASON TEST WASN'T ORIGINALLY PRESENT: This is a design change, we require a string comparer
         /// in all cases because we can't construct a deep copy without always knowing what string
         /// comparer to use.
-        /// 
+        ///
         /// In this test, try to construct a CopyOnWriteHashtable with no string comparer.
         /// </summary>
         [Test]
@@ -138,7 +138,7 @@ public void Regress_Mutation_MustHaveNonNullStringComparer2()
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: Missed test.
-        /// 
+        ///
         /// In this test, make sure Clear works on shallow-copy hashtable.
         /// </summary>
         [Test]
@@ -157,11 +157,11 @@ public void Regress_Mutation_ClearReadOnlyData()
 
         /*
          * Root cause analysis: reasons for missing tests:
-         * 
+         *
          * (Note 1) It was intended that the user of CopyOnWriteHashtable should not be able to detect
          *          whether a shallow copy or deep copy was made. So there was no way to unittest this.
          *          This test required adding 'IsShallowCopy' to detect this case.
-         * 
+         *
          */
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/DualQueue_Tests.cs b/src/Deprecated/Engine.UnitTests/DualQueue_Tests.cs
index 36f96f964a3..a534f048eb9 100644
--- a/src/Deprecated/Engine.UnitTests/DualQueue_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/DualQueue_Tests.cs
@@ -34,8 +34,8 @@ public void TestQueueEnqueueMultipleWriterOneReader()
             // List of strings which are supposed to be in the queue
             List<string> stringsSupposedToBeInQueue  = new List<string>();
             // List of strings which are supposed to be in the queue which uses EnQueueArray
-            List<string> stringsSupposedToBeInQueueTwo = new List<string>();  
-            
+            List<string> stringsSupposedToBeInQueueTwo = new List<string>();
+
             // Array containing our set of ManualResetEvents which is the number of threads we are going to use
             ManualResetEvent[] waitHandles = new ManualResetEvent[50];
             for (int i = 0; i < waitHandles.Length; i++)
@@ -48,7 +48,7 @@ public void TestQueueEnqueueMultipleWriterOneReader()
                                   string string1 = System.Guid.NewGuid().ToString();
                                   string string2 = System.Guid.NewGuid().ToString();
                                   string string3 = System.Guid.NewGuid().ToString();
-                                  
+
                                   stringQueue.Enqueue(string1);
                                   lock (stringsSupposedToBeInQueue)
                                   {
@@ -61,18 +61,18 @@ public void TestQueueEnqueueMultipleWriterOneReader()
                                       stringsSupposedToBeInQueueTwo.Add(string2);
                                       stringsSupposedToBeInQueueTwo.Add(string3);
                                   }
-                                  
+
                                   // Say we are done the thread
                                   ((ManualResetEvent)state).Set();
                               }, waitHandles[i]);
             }
-            
+
           // Wait for all of the threads to complete
             foreach (ManualResetEvent resetEvent in waitHandles)
             {
                 resetEvent.WaitOne();
             }
-          
+
             // Pop off items from the queue and make sure that we got all of out items back out
             int numberOfItemsInQueue = 0;
             string result = null;
diff --git a/src/Deprecated/Engine.UnitTests/EngineLoggingServices_Tests.cs b/src/Deprecated/Engine.UnitTests/EngineLoggingServices_Tests.cs
index 523d1efcd70..0bed8bf8274 100644
--- a/src/Deprecated/Engine.UnitTests/EngineLoggingServices_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EngineLoggingServices_Tests.cs
@@ -42,7 +42,7 @@ internal EngineLoggingServicesHelper()
         }
 
         /// <summary>
-        /// We dont need to do anything to process events, we just want to get what events are in the queue 
+        /// We dont need to do anything to process events, we just want to get what events are in the queue
         /// </summary>
         internal override bool ProcessPostedLoggingEvents()
         {
@@ -153,7 +153,7 @@ public void TearDown()
         public void LogErrorEvent()
         {
             List<BuildEventArgs> eventList = new List<BuildEventArgs>();
-            
+
             // Log a number of events and then make sure that queue at the end contains all of those events
             for (int i = 0; i < 10; i++)
             {
@@ -164,17 +164,17 @@ public void LogErrorEvent()
 
             // Get the logging queue after we have logged a number of messages
            DualQueue<BuildEventArgs> currentQueue = engineLoggingServicesHelper.GetCurrentQueueBuildEvents();
-            
+
             // Assert that every event we sent to the logger exists in the queue
             Assert.IsTrue(eventList.TrueForAll(delegate(BuildEventArgs args)
                                                {
                                                    return currentQueue.Contains(args);
                                                }), "Expected to find all events sent to LogErrorEvent");
-            
+
             // Assert that every event in the queue is of the correct type
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<BuildErrorEventArgs>);
         }
-        
+
         /// <summary>
         /// Test the case where null events are attempted to be logged
         /// </summary>
@@ -184,7 +184,7 @@ public void LogErrorEventNullEvent()
         {
             engineLoggingServicesHelper.LogErrorEvent(null);
         }
-        
+
         /// <summary>
         /// Test warning events
         /// </summary>
@@ -192,7 +192,7 @@ public void LogErrorEventNullEvent()
         public void LogWarningEvent()
         {
             List<BuildEventArgs> eventList = new List<BuildEventArgs>();
-           
+
             // Log a number of events
             for (int i = 0; i < 10; i++)
             {
@@ -200,7 +200,7 @@ public void LogWarningEvent()
                 eventList.Add(eventToAdd);
                 engineLoggingServicesHelper.LogWarningEvent(eventToAdd);
             }
-            
+
             // Get the logged event queue from the "logger"
            DualQueue<BuildEventArgs> currentQueue = engineLoggingServicesHelper.GetCurrentQueueBuildEvents();
 
@@ -209,7 +209,7 @@ public void LogWarningEvent()
                                                {
                                                    return currentQueue.Contains(args);
                                                }), "Expected to find all events sent to LogWarningEvent");
-            
+
             // Assert that every event in the queue is of the correct type
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<BuildWarningEventArgs>);
         }
@@ -254,7 +254,7 @@ public void LogMessageEventNullEvent()
         public void LogMessageEvent()
         {
             List<BuildEventArgs> eventList = new List<BuildEventArgs>();
-            
+
             // Log a number of message events and keep track of the events we tried to log
             for (int i = 0; i < 10; i++)
             {
@@ -304,7 +304,7 @@ public void LogCustomEventNullEvent()
         public void LogCustomEvent()
         {
             List<BuildEventArgs> eventList = new List<BuildEventArgs>();
-            
+
             // Log a number of events and keep track of which events we sent to the logger
             for (int i = 0; i < 10; i++)
             {
@@ -321,7 +321,7 @@ public void LogCustomEvent()
                                                {
                                                    return currentQueue.Contains(args);
                                                }), "Expected to find all events sent to logcustomevent");
-            
+
             // Assert that every event in the queue is of the correct type
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<MyCustomBuildEventArgs>);
         }
@@ -378,7 +378,7 @@ public void PostLoggingEventMessageEvent()
         public void PostLoggingEventMultiThreaded()
         {
             List<BuildEventArgs> eventsAdded = new List<BuildEventArgs>();
-            
+
             // Add a number of events on multiple threads
             ManualResetEvent[] waitHandles = new ManualResetEvent[10];
             for (int i = 0; i < waitHandles.Length; i++)
@@ -439,7 +439,7 @@ public void LogCommentFromTextNullMessage()
             // Would have tested the case where null was passed and critical events is false, but this would cause an assertion window
             // to popup thereby failing the test
         }
-       
+
         /// <summary>
         /// Test logging messages to the logger
         /// </summary>
@@ -449,21 +449,21 @@ public void LogCommentFromTextGoodMessages()
             // Send a message, this message should be posted to the queue
             engineLoggingServicesHelper.LogCommentFromText(null, MessageImportance.Low, "Message");
             engineLoggingServicesHelper.LogCommentFromText(null, MessageImportance.Low, string.Empty);
-            
+
             // Make sure that the one message got posted to the queue
             DualQueue<BuildEventArgs> currentQueue = engineLoggingServicesHelper.GetCurrentQueueBuildEvents();
             Assert.IsTrue(currentQueue.Count == 2, "Expected to find two events on the queue");
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<BuildMessageEventArgs>);
 
         }
-        
+
         /// <summary>
         /// Test logging message comments to the logger
         /// </summary>
         [Test]
         public void LogCommentGoodMessages()
         {
-            // Send a message while not logging critical events, since comments are not considered critical they should 
+            // Send a message while not logging critical events, since comments are not considered critical they should
             // not show up in the queue
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogComment((BuildEventContext)null, MessageImportance.Normal, "ErrorConvertedIntoWarning");
@@ -478,13 +478,13 @@ public void LogCommentGoodMessages()
             engineLoggingServicesHelper.LogComment((BuildEventContext)null, MessageImportance.Normal, "ErrorConvertedIntoWarning", 3);
             engineLoggingServicesHelper.LogComment((BuildEventContext)null, "ErrorConvertedIntoWarning");
             engineLoggingServicesHelper.LogComment((BuildEventContext)null, "ErrorCount", 3);
-            
+
             // Get the queue from the logger
            DualQueue<BuildEventArgs> currentQueue = engineLoggingServicesHelper.GetCurrentQueueBuildEvents();
-            
+
             // Make sure we got all the events we sent to the logger
             Assert.IsTrue(currentQueue.Count == 4, "Expected to find four events on the queue");
-            
+
             // Make sure that every event in the queue is of the correct type
             AssertForEachEventInQueue(currentQueue, IsInstanceOfType<BuildMessageEventArgs>);
         }
@@ -552,7 +552,7 @@ public void LogTaskStarted()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogTaskStarted(null, "taskName", "projectFile", "projectFileOfTaskNode");
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogTaskStarted(null, "taskName", "projectFile", "projectFileOfTaskNode");
@@ -571,7 +571,7 @@ public void LogTaskFinished()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogTaskFinished(null, "taskName", "projectFile", "projectFileOfTaskNode", true);
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogTaskFinished(null, "taskName", "projectFile", "projectFileOfTaskNode", true);
@@ -590,7 +590,7 @@ public void LogTargetStarted()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogTargetStarted(null, "TargetName", "projectFile", "projectFileOfTargetNode");
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogTargetStarted(null, "targetName", "projectFile", "projectFileOfTargetNode");
@@ -609,7 +609,7 @@ public void LogTargetFinished()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogTargetFinished(null, "TargetName", "projectFile", "projectFileOfTargetNode", true);
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events, even non critical ones
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogTargetFinished(null, "TargetName", "projectFile", "projectFileOfTargetNode", true);
@@ -628,7 +628,7 @@ public void LogProjectStarted()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogProjectStarted(-1, null, null, "projectFile", "targetNames", null, null);
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected to find no events in the queue");
-            
+
             // Test logging while logging all events, even non critical ones
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogProjectStarted(-1, null, null, "projectFile", "targetNames", null, null);
@@ -647,7 +647,7 @@ public void LogProjectFinished()
             engineLoggingServicesHelper.OnlyLogCriticalEvents = true;
             engineLoggingServicesHelper.LogProjectFinished(null, "projectFile", true);
             Assert.IsTrue(engineLoggingServicesHelper.GetCurrentQueueBuildEvents().Count == 0, "Expected no events in queue but found some");
-            
+
             //Test logging while logging all events, even non critical ones
             engineLoggingServicesHelper.OnlyLogCriticalEvents = false;
             engineLoggingServicesHelper.LogProjectFinished(null, "projectFile", true);
@@ -1252,9 +1252,9 @@ public void ConfigurationByEngine()
         #endregion
 
         #region OutProcLoggingTest
-       
+
         /// <summary>
-        /// Test logging the out of proc logger by sending events to the logger and check 
+        /// Test logging the out of proc logger by sending events to the logger and check
         /// the inproc logger queue which is the eventual handler of the events
         /// </summary>
         [Test]
@@ -1263,14 +1263,14 @@ public void OutProcLoggingTest()
 
             VerifyEventSourceHelper eventSourceHelper = new VerifyEventSourceHelper();
             EngineLoggingServicesInProc inProcLoggingServicesEventsAllEvents = new EngineLoggingServicesInProc(eventSourceHelper.sourceForEvents, false, new ManualResetEvent(false));
-            
+
 
             Engine buildEngine = new Engine();
             buildEngine.LoggingServices = inProcLoggingServicesEventsAllEvents;
-            
+
             EngineCallback outProcessorProxy = new EngineCallback(buildEngine);
             int nodeId = buildEngine.GetNextNodeId();
-            Node parentNode = new Node(nodeId, new LoggerDescription[0], outProcessorProxy, null, 
+            Node parentNode = new Node(nodeId, new LoggerDescription[0], outProcessorProxy, null,
                 ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry, String.Empty);
 
 
@@ -1418,7 +1418,7 @@ public void OutProcLoggingTest()
             inProcLoggingServicesEventsAllEvents.ProcessPostedLoggingEvents();
             eventSourceHelper.AssertEventsAndNoOthers("anyEventRaised", "messageRaised");
             eventSourceHelper.ClearEvents();
-            
+
             //send a lot of events to test the event batching
             for (int i = 0; i < 600; i++)
             {
@@ -1432,7 +1432,7 @@ public void OutProcLoggingTest()
             // Check that the events are correctly sorted when posted with different logger ids
             loggingServicesOutProc.PostLoggingEvent(new BuildMessageEventArgs("Message", "help", "sender", MessageImportance.Low));
             loggingServicesOutProc.PostLoggingEvent(new NodeLoggingEventWithLoggerId(new BuildStartedEventArgs("message", "help"), EngineLoggingServicesInProc.FIRST_AVAILABLE_LOGGERID));
-            loggingServicesOutProc.PostLoggingEvent(new NodeLoggingEventWithLoggerId(new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true), 
+            loggingServicesOutProc.PostLoggingEvent(new NodeLoggingEventWithLoggerId(new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true),
                                                                                      EngineLoggingServicesInProc.FIRST_AVAILABLE_LOGGERID +1));
             loggingServicesOutProc.ProcessPostedLoggingEvents();
             inProcLoggingServicesEventsAllEvents.ProcessPostedLoggingEvents();
diff --git a/src/Deprecated/Engine.UnitTests/Engine_Tests.cs b/src/Deprecated/Engine.UnitTests/Engine_Tests.cs
index a1f4f2dd994..09d0fc9d8fb 100644
--- a/src/Deprecated/Engine.UnitTests/Engine_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Engine_Tests.cs
@@ -35,7 +35,7 @@ public void TestMSBuildForwardPropertiesFromChild()
             string[] propertiesToSerialize = childEngine.PropertyListToSerialize;
             Assert.IsNull(propertiesToSerialize, "Expected propertiesToSerialize to be null");
 	    childEngine.Shutdown();
-            
+
 	    Environment.SetEnvironmentVariable("MSBuildForwardPropertiesFromChild", string.Empty);
             childEngine = new Engine(new BuildPropertyGroup(), new ToolsetDefinitionLocations(), 3, true, 3, string.Empty, string.Empty);
             propertiesToSerialize = childEngine.PropertyListToSerialize;
@@ -71,7 +71,7 @@ public void TestMSBuildForwardPropertiesFromChild()
              Assert.IsTrue(string.Compare(propertiesToSerialize[0], "Platform") == 0);
              Assert.IsTrue(propertiesToSerialize.Length == 1);
              childEngine.Shutdown();
-             
+
             Environment.SetEnvironmentVariable("MSBuildForwardPropertiesFromChild", ";Platform");
              childEngine = new Engine(new BuildPropertyGroup(), new ToolsetDefinitionLocations(), 3, true, 3, string.Empty, string.Empty);
              propertiesToSerialize = childEngine.PropertyListToSerialize;
@@ -156,7 +156,7 @@ public void TestTEMBatchSizeSettings()
         public void SettingDefaultToolsVersionThrowsIfProjectsAlreadyLoaded()
         {
             Engine e = new Engine(ToolsetDefinitionLocations.None);
-            
+
             try
             {
                 e.AddToolset(new Toolset("1.0", "someToolsPath"));
@@ -166,7 +166,7 @@ public void SettingDefaultToolsVersionThrowsIfProjectsAlreadyLoaded()
             catch(InvalidOperationException)
             {
                 // Make sure the first one doesn't throw
-                Assertion.Assert(false); 
+                Assertion.Assert(false);
             }
 
             try
@@ -238,7 +238,7 @@ public void GetToolsVersionNames()
             // Check the contents after adding two more tools versions
             e.Toolsets.Add(new Toolset("Whidbey", @"C:\WhidbeyPath"));
             e.Toolsets.Add(new Toolset("orcas", @"C:\OrcasBinPath"));
-            
+
             Dictionary<string, object> toolsVersionNamesDictionary = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
             foreach (string name in e.Toolsets.ToolsVersions)
             {
@@ -367,11 +367,11 @@ public void MalformedProjectDoesNotGetAddedToEngine
                 // Get a little extra code coverage
                 myEngine.UnregisterAllLoggers();
                 myEngine.UnloadAllProjects();
-                
+
                 File.Delete(projectFile);
             }
         }
-        
+
         /// <summary>
         /// Engine.BuildProjectFile method with project file specified does not honor global properties set in the engine object
         /// Bug VSWhidbey 570988.
@@ -396,7 +396,7 @@ public void BuildProjectFileWithGlobalPropertiesSetInEngineObjectWithProjectFile
                 File.Delete(projectFile);
             }
         }
-        
+
         /// <summary>
         /// Engine.BuildProjectFile method with project file and target specified does not honor global properties set in the engine object
         /// Bug VSWhidbey 570988.
@@ -421,7 +421,7 @@ public void BuildProjectFileWithGlobalPropertiesSetInEngineObjectWithProjectFile
                 File.Delete(projectFile);
             }
         }
-        
+
         /// <summary>
         /// Engine.BuildProjectFile method with project file and target list specified does not honor global properties set in the engine object
         /// Bug VSWhidbey 570988.
@@ -512,10 +512,10 @@ public void BuildProjectFilesInParallel()
                 }
 
                 // Test building a traversal
-              
+
                 engine.BuildProjectFile(traversalProject);
                 engine.Shutdown();
-                
+
                 // Test building the same set of files in parallel
                 Console.Out.WriteLine("1:"+Process.GetCurrentProcess().MainModule.FileName);
                 Console.Out.WriteLine("2:" + AppDomain.CurrentDomain.BaseDirectory);
@@ -565,7 +565,7 @@ public void BuildProjectFilesInParallel2()
             string[][] targetNamesPerProject = new string[fileNames.Length][];
             IDictionary[] targetOutPutsPerProject = new IDictionary[fileNames.Length];
             BuildPropertyGroup[] globalPropertiesPerProject = new BuildPropertyGroup[fileNames.Length];
-            
+
             string[] tempfilesToDelete = new string[fileNames.Length];
             string[] tempfilesToDelete2 = new string[fileNames.Length];
             string[] tempfilesToDelete3 = new string[fileNames.Length];
@@ -584,7 +584,7 @@ public void BuildProjectFilesInParallel2()
                     fileNames2[i] = ProjectFiles2[0];
                     fileNamesLeafs[i] = FileNamesLeafs[0];
                     childTraversals[i] = ChildTraversals[0];
-                    
+
                     tempfilesToDelete[i] = ProjectFiles1[1];
                     tempfilesToDelete2[i] = ProjectFiles2[1];
                     tempfilesToDelete3[i] = FileNamesLeafs[1];
@@ -594,7 +594,7 @@ public void BuildProjectFilesInParallel2()
 
 
                 // Try building a traversal project that had other traversals
-                
+
                 engine.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
                 engine.BuildProjectFile(parentTraversal, new string[] { "Build" }, new BuildPropertyGroup(), null, BuildSettings.None, "3.5");
                 engine.Shutdown();
@@ -742,11 +742,11 @@ private string[] CreateSingleProjectTraversalFileWithExtension(string projectNam
                 fileStream.Write(projectFileContents);
             }
             return new string[] { projectFile, tempFile };
-        } 
+        }
 
         private string TraversalProjectFile(string extensionForChildProjects)
         {
-            
+
             string projectFileContents = @"
                 <Project ToolsVersion=""3.5"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
                     <ItemGroup>";
@@ -832,7 +832,7 @@ public void BuildProjectWithPoorlyFormattedGlobalProperty()
                          </Prj>
                        </ItemGroup>
                     <Target Name=`1`>
-                        <MSBuild Projects=`@(Prj)` />            
+                        <MSBuild Projects=`@(Prj)` />
                     </Target>
                  </Project>
                  ", childProject);
@@ -953,7 +953,7 @@ public void ProjectShouldUseDefaultToolsVersionIfOneIsNotSpecified()
             }
         }
 
-        
+
         /// <summary>
         /// Project built using MSBuild task should use the default tools version if one is not specified.
         /// </summary>
@@ -1083,7 +1083,7 @@ public void ProjectBuiltUsingMSBuildTaskAndToolsVersionShouldUseTheOneSpecifiedI
                 MockLogger logger = new MockLogger();
                 Engine e = new Engine();
                 e.RegisterLogger(logger);
-        
+
                 string p1Path = ObjectModelHelpers.CreateFileInTempProjectDirectory("p1.proj", projectContent);
                 string p2Path = ObjectModelHelpers.CreateFileInTempProjectDirectory("p2.proj", projectContent2);
 
diff --git a/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs b/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
index e724f3d0969..1bc062ea883 100644
--- a/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
@@ -148,7 +148,7 @@ public void AddNewItemWithSemicolon()
 
         /// <summary>
         /// If I try to add a new item to a project, and my new item's Include has a property that
-        /// contains an unescaped semicolon in it, then we shouldn't try to match it up against any existing 
+        /// contains an unescaped semicolon in it, then we shouldn't try to match it up against any existing
         /// wildcards.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -203,17 +203,17 @@ public void ModifyItemIncludeSemicolon()
         {
             // Populate the project directory with three physical files on disk -- a.weirdo, b.weirdo, c.weirdo.
             ModifyItem.CreateThreeWeirdoFilesHelper();
-            
+
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -221,7 +221,7 @@ public void ModifyItemIncludeSemicolon()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -229,7 +229,7 @@ public void ModifyItemIncludeSemicolon()
                         <MyWildcard Include=`foo;bar.weirdo` />
                         <MyWildcard Include=`c.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -250,17 +250,17 @@ public void ModifyItemIncludeEscapedSemicolon()
         {
             // Populate the project directory with three physical files on disk -- a.weirdo, b.weirdo, c.weirdo.
             ModifyItem.CreateThreeWeirdoFilesHelper();
-            
+
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -268,13 +268,13 @@ public void ModifyItemIncludeEscapedSemicolon()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -287,7 +287,7 @@ public void ModifyItemIncludeEscapedSemicolon()
 
         /// <summary>
         /// If I try to modify an item in a project, and my new item's Include has a property that
-        /// contains an unescaped semicolon in it, then we shouldn't try to match it up against any existing 
+        /// contains an unescaped semicolon in it, then we shouldn't try to match it up against any existing
         /// wildcards.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -296,11 +296,11 @@ public void ModifyItemAddPropertyContainingSemicolon()
         {
             // Populate the project directory with three physical files on disk -- a.weirdo, b.weirdo, c.weirdo.
             ModifyItem.CreateThreeWeirdoFilesHelper();
-            
+
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -310,7 +310,7 @@ public void ModifyItemAddPropertyContainingSemicolon()
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -318,7 +318,7 @@ public void ModifyItemAddPropertyContainingSemicolon()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -330,7 +330,7 @@ public void ModifyItemAddPropertyContainingSemicolon()
                         <MyWildcard Include=`$(FileNameWithSemicolon).weirdo` />
                         <MyWildcard Include=`c.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -547,7 +547,7 @@ public void SemicolonInConfiguration()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -607,7 +607,7 @@ public void SemicolonInAssemblyName()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -665,7 +665,7 @@ public void DollarSignInAssemblyName()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -723,7 +723,7 @@ public void SemicolonInSourceCodeFilename()
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
             ");
-            
+
             // ---------------------
             // Class1.cs
             // ---------------------
@@ -924,7 +924,7 @@ static void Main(string[] args)
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
 
                     <!-- The old OM, which is what this solution is being built under, doesn't understand
-                         BeforeTargets, so this test was failing, because _AssignManagedMetadata was set 
+                         BeforeTargets, so this test was failing, because _AssignManagedMetadata was set
                          up as a BeforeTarget for Build.  Copied here so that build will return the correct
                          information again. -->
                     <Target Name=`BeforeBuild`>
@@ -957,7 +957,7 @@ public class Class1
             MockLogger log = ObjectModelHelpers.BuildTempProjectFileWithTargetsExpectSuccess(@"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1.sln", new string[] { targetForFirstProject }, new BuildPropertyGroup());
 
             Assertion.Assert(@"Did not find expected file Console;!@(foo)'^(Application1.exe",
-                File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, 
+                File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir,
                 @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe")));
         }
     }
diff --git a/src/Deprecated/Engine.UnitTests/EventArgsFormatting_Tests.cs b/src/Deprecated/Engine.UnitTests/EventArgsFormatting_Tests.cs
index 4ec1aaea85f..b16138705af 100644
--- a/src/Deprecated/Engine.UnitTests/EventArgsFormatting_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EventArgsFormatting_Tests.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.UnitTests
     /// <summary>
     /// These tests are repeated in the Utilities unit test assembly. We know that this isn't
     /// too useful, because both Engine and Utilities pull the code from the same Shared file. But it
-    /// gets a bunch of lines of extra coverage of Engine that we weren't otherwise getting, and 
+    /// gets a bunch of lines of extra coverage of Engine that we weren't otherwise getting, and
     /// in theory at least the implementation in Engine should be tested too.
     /// </summary>
     [TestFixture]
diff --git a/src/Deprecated/Engine.UnitTests/Expander_Tests.cs b/src/Deprecated/Engine.UnitTests/Expander_Tests.cs
index 9286aad3558..aff4a25012c 100644
--- a/src/Deprecated/Engine.UnitTests/Expander_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Expander_Tests.cs
@@ -140,9 +140,9 @@ public void ZeroItemsInProjectExpandsToEmpty()
                 <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
 
                     <Target Name=`Build` Condition=`'@(foo)'!=''` >
-                        <Message Text=`This target should NOT run.`/>  
+                        <Message Text=`This target should NOT run.`/>
                     </Target>
-                  
+
                 </Project>
                 ");
 
@@ -158,7 +158,7 @@ public void ZeroItemsInProjectExpandsToEmpty()
                     <Target Name=`Build`>
                         <Message Text=`Item list foo contains @(foo)`/>
                     </Target>
-                  
+
                 </Project>
                 ");
 
@@ -266,11 +266,11 @@ public void ExpandAllIntoTaskItemsComplex()
 
             List<TaskItem> taskItems = expander.ExpandAllIntoTaskItems(
                 "@(Resource->'%(Filename)') ; @(Content) ; @(NonExistent) ; $(NonExistent) ; %(NonExistent) ; " +
-                "$(OutputPath) ; $(TargetPath) ; %(Language)_%(Culture)", 
+                "$(OutputPath) ; $(TargetPath) ; %(Language)_%(Culture)",
                  (new XmlDocument()).CreateAttribute("dummy"));
 
-            // the following items are passed to the TaskItem constructor, and thus their ItemSpecs should be 
-            // in escaped form. 
+            // the following items are passed to the TaskItem constructor, and thus their ItemSpecs should be
+            // in escaped form.
             ObjectModelHelpers.AssertItemsMatch(@"
                 string$(p): ddd=444
                 dialogs%253b: eee=555
@@ -337,7 +337,7 @@ public void ExpandAllIntoStringLeaveEscapedComplex()
         }
 
         /// <summary>
-        /// Exercises ExpandAllIntoString with a string that does not need expanding. 
+        /// Exercises ExpandAllIntoString with a string that does not need expanding.
         /// In this case the expanded string should be reference identical to the passed in string.
         /// </summary>
         [Test]
@@ -354,14 +354,14 @@ public void ExpandAllIntoStringExpectIdenticalReference()
             // Create a *non-literal* string. If we used a literal string, the CLR might (would) intern
             // it, which would mean that Expander would inevitably return a reference to the same string.
             // In real builds, the strings will never be literals, and we want to test the behavior in
-            // that situation. 
+            // that situation.
             xmlattribute.Value = "abc123" + new Random().Next();
             string expandedString = expander.ExpandAllIntoStringLeaveEscaped(xmlattribute.Value, xmlattribute);
 
             // Verify neither string got interned, so that this test is meaningful
             Assertion.Assert(null == string.IsInterned(xmlattribute.Value));
             Assertion.Assert(null == string.IsInterned(expandedString));
-            
+
             // Finally verify Expander indeed didn't create a new string.
             Assertion.Assert(Object.ReferenceEquals(xmlattribute.Value, expandedString));
         }
@@ -774,7 +774,7 @@ private XmlAttribute DummyAttribute
                 return dummyAttribute;
             }
         }
-        
+
         private bool EvaluateCondition(string conditionExpression, Expander expander)
         {
             Parser p = new Parser();
@@ -997,7 +997,7 @@ public void PropertyFunctionConstructor2()
         }
 
         /// <summary>
-        /// Expand property function calls a static method 
+        /// Expand property function calls a static method
         /// </summary>
         [Test]
         public void PropertyFunctionStaticMethodMakeRelative()
@@ -1071,7 +1071,7 @@ public void PropertyFunctionGetRegistryValueFromView_NonexistentKey()
         }
 
         /// <summary>
-        /// Expand property function calls a static method 
+        /// Expand property function calls a static method
         /// </summary>
         [Test]
         public void PropertyFunctionStaticMethod1()
@@ -1088,7 +1088,7 @@ public void PropertyFunctionStaticMethod1()
         }
 
         /// <summary>
-        /// Expand property function calls a static method 
+        /// Expand property function calls a static method
         /// </summary>
         [Test]
         public void PropertyFunctionStaticMethodQuoted1()
@@ -1147,9 +1147,9 @@ public void PropertyFunctionStaticMethodQuoted4()
 
             Assertion.AssertEquals(DateTime.Now.ToString("MM.dd.yyyy"), result);
         }
-        
+
         /// <summary>
-        /// Expand property function calls a static method 
+        /// Expand property function calls a static method
         /// </summary>
         [Test]
         public void PropertyFunctionStaticMethodNested()
@@ -1739,9 +1739,9 @@ public void RegistryPropertyMultiString()
             {
                 Registry.CurrentUser.DeleteSubKey(@"Software\Microsoft\MSBuild_test");
             }
-        }    
+        }
     }
- 
+
     /// <summary>
     /// Tests relating to SplitSemiColonSeparatedList method
     /// </summary>
diff --git a/src/Deprecated/Engine.UnitTests/ExpressionShredder_Tests.cs b/src/Deprecated/Engine.UnitTests/ExpressionShredder_Tests.cs
index ad182c69884..3d157e3478a 100644
--- a/src/Deprecated/Engine.UnitTests/ExpressionShredder_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ExpressionShredder_Tests.cs
@@ -31,20 +31,20 @@ public void Medley()
         {
             string[] tests = new string[]
             {
-                "a;@(foo,');');b", 
+                "a;@(foo,');');b",
                 "x@(z);@(zz)y",
                 "exists('@(u)')",
-                "a;b", 
+                "a;b",
                 "a;;",
-                "a", 
+                "a",
                 "@A->'%(x)'",
                 "@@(",
                 "@@",
                 "@(z1234567890_-AZaz->'z1234567890_-AZaz','a1234567890_-AZaz')",
-                "@(z1234567890_-AZaz,'a1234567890_-AZaz')", 
-                "@(z1234567890_-AZaz)", 
-                "@(z1234567890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'   )", 
-                "@(z123456.7890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'  )", 
+                "@(z1234567890_-AZaz,'a1234567890_-AZaz')",
+                "@(z1234567890_-AZaz)",
+                "@(z1234567890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'   )",
+                "@(z123456.7890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'  )",
                 "@(z->'%(x)",
                 "@(z->%(x)",
                 "@(z,'%(x)",
@@ -56,69 +56,69 @@ public void Medley()
                 "@(y)==$(d)",
                 "@(y)<=1",
                 "@(y -> '%(filename)')=='xxx'",
-                "@(x\u00DF)",   
-                "@(x1234567890_-AZaz->'x1234567890_-AZaz')", 
-                "@(x1234567890_-AZaz)", 
-                "@(x123 4567890_-AZaz->'x1234567890_-AZaz')", 
-                "@(x->)", 
+                "@(x\u00DF)",
+                "@(x1234567890_-AZaz->'x1234567890_-AZaz')",
+                "@(x1234567890_-AZaz)",
+                "@(x123 4567890_-AZaz->'x1234567890_-AZaz')",
+                "@(x->)",
                 "@(x->)",
                 "@(x->'x','')",
                 "@(x->'x',''",
                 "@(x->'x','",
-                "@(x->')", 
-                "@(x->''", 
+                "@(x->')",
+                "@(x->''",
                 "@(x->''",
                 "@(x->'",
-                "@(x->", 
+                "@(x->",
                 "@(x-",
-                "@(x,')", 
+                "@(x,')",
                 "@(x)@(x)",
                 "@(x)<x",
                 "@(x);@(x)",
                 "@(x)",
-                "@(x''';", 
-                "@(x", 
+                "@(x''';",
+                "@(x",
                 "@(x!)",
                 "@(w)>0",
                 "@(nonexistent)",
                 "@(nonexistent) and true",
                 "@(foo->'x')",
-                "@(foo->'abc;def', 'ghi;jkl')", 
-                "@(foo->';());', ';@();')", 
-                "@(foo->';');def;@ghi;", 
-                "@(foo->';')", 
+                "@(foo->'abc;def', 'ghi;jkl')",
+                "@(foo->';());', ';@();')",
+                "@(foo->';');def;@ghi;",
+                "@(foo->';')",
                 "@(foo-->'x')", // "foo-" is a legit item type
-                "@(foo, ';')", 
-                "@(a1234:567890_-AZaz->'z1234567890_-AZaz')", 
-                "@(a1234567890_-AZaz->'z1234567890_-AZaz')", 
-                "@(a1234567890_-AXZaxz  -> 'a1234567890_-AXZaxz'   ,  'z1234567890_-AXZaxz'   )", 
-                "@(a1234567890_-AXZaxz  , 'z123%%4567890_-AXZaxz'   )", 
-                "@(a->'a')", 
-                "@(a->'a'  ,  'a')", 
+                "@(foo, ';')",
+                "@(a1234:567890_-AZaz->'z1234567890_-AZaz')",
+                "@(a1234567890_-AZaz->'z1234567890_-AZaz')",
+                "@(a1234567890_-AXZaxz  -> 'a1234567890_-AXZaxz'   ,  'z1234567890_-AXZaxz'   )",
+                "@(a1234567890_-AXZaxz  , 'z123%%4567890_-AXZaxz'   )",
+                "@(a->'a')",
+                "@(a->'a'  ,  'a')",
                 "@(a)@(x)!=1",
-                "@(a)", 
+                "@(a)",
                 "@(a) @(x)!=1",
-                "@(a  ,  'a')", 
-                "@(_X->'_X','X')", 
-                "@(_X->'_X')", 
-                "@(_X,'X')", 
-                "@(_X)", 
+                "@(a  ,  'a')",
+                "@(_X->'_X','X')",
+                "@(_X->'_X')",
+                "@(_X,'X')",
+                "@(_X)",
                 "@(_->'@#$%$%^&*&*)','@#$%$%^&*&*)')",
                 "@(_->'@#$%$%^&*&*)')",
                 "@(_,'@#$%$%^&*&*)')",
                 "@(_)",
                 "@(\u1234%(x)",
                 "@(\u00DF)",
-                "@(Z1234567890_-AZaz)", 
-                "@(Z1234567890_-AZaz -> 'Z1234567890_-AZaz')", 
+                "@(Z1234567890_-AZaz)",
+                "@(Z1234567890_-AZaz -> 'Z1234567890_-AZaz')",
                 "@(Com:pile)",
                 "@(Com.pile)",
                 "@(Com%pile)",
                 "@(Com pile)",
-                "@(A1234567890_-AZaz,'!@#$%^&*)(_+'))", 
-                "@(A1234567890_-AZaz)", 
-                "@(A1234567890_-AZaz ->'A1234567890_-AZaz')", 
-                "@(A1234567890_-AZaz ->'A1234567890_-AZaz' , '!@#$%^&*)(_+'))", 
+                "@(A1234567890_-AZaz,'!@#$%^&*)(_+'))",
+                "@(A1234567890_-AZaz)",
+                "@(A1234567890_-AZaz ->'A1234567890_-AZaz')",
+                "@(A1234567890_-AZaz ->'A1234567890_-AZaz' , '!@#$%^&*)(_+'))",
                 "@(A->'foo%(x)bar',',')",
                 "@(A->'%(x))",
                 "@(A->'%(x)')@(B->'%(x);%(y)')@(C->'%(z)')",
@@ -129,14 +129,14 @@ public void Medley()
                 "@(A, '%(x)->%(y)')",
                 "@(A, '%(x)%(y)')",
                 "@(A > '%(x)','+')",
-                "@(:Z1234567890_-AZaz -> 'Z1234567890_-AZaz')", 
+                "@(:Z1234567890_-AZaz -> 'Z1234567890_-AZaz')",
                 "@(:Compile)",
                 "@(1x->'@#$%$%^&*&*)')",
                 "@(1Compile)",
-                "@(1->'a')", 
+                "@(1->'a')",
                 "@(.Compile)",
-                "@(.A1234567890_-AZaz ->'A1234567890_-AZaz')", 
-                "@(-x->'_X')", 
+                "@(.A1234567890_-AZaz ->'A1234567890_-AZaz')",
+                "@(-x->'_X')",
                 "@(-Compile)",
                 "@()",
                 "@() and true",
@@ -144,29 +144,29 @@ public void Medley()
                 "@(%(x)",
                 "@(", "@()", "@",
                 "@(",
-                "@( foo -> ';);' , ';);' )", 
-                "@( foo -> ');' )", 
+                "@( foo -> ';);' , ';);' )",
+                "@( foo -> ');' )",
                 "@( A -> '%(Directory)%(Filename)%(Extension)', ' ** ')",
                 "@( )",
-                "@(   foo  )", 
-                "@(   foo  ", 
-                "@(   a1234567890_-AXZaxz   )", 
+                "@(   foo  )",
+                "@(   foo  ",
+                "@(   a1234567890_-AXZaxz   )",
                 "@",
                 "@ (x)",
                 "@(x,'@(y)%(x)@(z->')",
                 "@(x,'@(y)')",   // verify items inside separators aren't found
-                "@(x,'@(y, '%(z)')')",   
-                "@(x,'@(y)%(z)')", 
+                "@(x,'@(y, '%(z)')')",
+                "@(x,'@(y)%(z)')",
                 "@(x,'@(y)%(x')",
                 "@(x,'')",
                 "@(x->'','')",
                 "@(x->'%(z)','')",
-                ";a;bbb;;c;;", 
-                ";;a", 
+                ";a;bbb;;c;;",
+                ";;a",
                 ";;;@(A->'%(x)');@(B)@(C->'%(y)');%(x)@(D->'%(y)');;",
-                ";;", 
-                ";", 
-                ";  ", 
+                ";;",
+                ";",
+                ";  ",
                 "1<=@(z)",
                 "1<=@(w)",
                 "'xxx!yyy'==@(z -> '%(filename)', '!')",
@@ -175,10 +175,10 @@ public void Medley()
                 "'$(c)@(y)'>1",
                 "%x)",
                 "%x",
-                "%(z1234567890_-AZaz.z1234567890_-AZaz)", 
-                "%(z1234567890_-AZaz)", 
-                "%(x1234567890_-AZaz.x1234567890_-AZaz)", 
-                "%(x1234567890_-AZaz)", 
+                "%(z1234567890_-AZaz.z1234567890_-AZaz)",
+                "%(z1234567890_-AZaz)",
+                "%(x1234567890_-AZaz.x1234567890_-AZaz)",
+                "%(x1234567890_-AZaz)",
                 "%(x._)",
                 "%(x)",
                 "%(x",
@@ -186,21 +186,21 @@ public void Medley()
                 "%(foo.bar.baz)",
                 "%(foo.bar baz)",
                 "%(foo bar.rhu barb)",
-                "%(abc._X)", 
+                "%(abc._X)",
                 "%(a@(z)",
-                "%(a1234567890_-AXZaxz)", 
-                "%(a12.a)", 
+                "%(a1234567890_-AXZaxz)",
+                "%(a12.a)",
                 "%(a.x)",
                 "%(a.x )",
                 "%(a.a@(z)",
                 "%(a.@(z)",
                 "%(a. x)",
-                "%(a)", 
+                "%(a)",
                 "%(a . x)",
-                "%(_X)", 
+                "%(_X)",
                 "%(_)",
-                "%(Z1234567890_-AZaz.Z1234567890_-AZaz)", 
-                "%(Z1234567890_-AZaz)", 
+                "%(Z1234567890_-AZaz.Z1234567890_-AZaz)",
+                "%(Z1234567890_-AZaz)",
                 "%(MyType.attr)",
                 "%(InvalidAttrWithA Space)",
                 "%(Foo.Bar.)",
@@ -212,8 +212,8 @@ public void Medley()
                 "%(Com%pile)",
                 "%(Com pile.Com pile)",
                 "%(Com pile)",
-                "%(A1234567890_-AZaz.A1234567890_-AZaz)", 
-                "%(A1234567890_-AZaz)", 
+                "%(A1234567890_-AZaz.A1234567890_-AZaz)",
+                "%(A1234567890_-AZaz)",
                 "%(A.x)%(b.x)",
                 "%(A.x)",
                 "%(A.x)  %( x )",
@@ -254,18 +254,18 @@ public void Medley()
                 "%(  Invalid AttrWithASpace  )",
                 "%(  A  .  )",
                 "%(   x   )",
-                "%(   a1234567890_-AXZaxz.a1234567890_-AXZaxz   )", 
+                "%(   a1234567890_-AXZaxz.a1234567890_-AXZaxz   )",
                 "% x",
                 "% (x)",
                 "$(c)@(y)>1",
-                "", 
+                "",
                 "",
                 "!@#$%^&*",
-                " @(foo->'', '')", 
-                " ->       ';abc;def;'   ,     'ghi;jkl'   )", 
+                " @(foo->'', '')",
+                " ->       ';abc;def;'   ,     'ghi;jkl'   )",
                 " %(A . x)%%%%%%%%(b . x) ",
-                "  ;  a   ;b   ;   ;c", 
-                "                $(AssemblyOriginatorKeyFile);\n\t                @(Compile);", 
+                "  ;  a   ;b   ;   ;c",
+                "                $(AssemblyOriginatorKeyFile);\n\t                @(Compile);",
                                 "@(_OutputPathItem->'%(FullPath)', ';');$(MSBuildAllProjects);"
             };
 
@@ -366,7 +366,7 @@ private static Hashtable GetConsumedItemReferences_OriginalImplementation(string
         /// <summary>
         /// Looks through the parameters of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Returns a Hashtable containing a bunch of MetadataReference
-        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <owner>SumedhK, RGoel</owner>
@@ -374,7 +374,7 @@ private static Hashtable GetConsumedItemReferences_OriginalImplementation(string
         private static Hashtable GetConsumedMetadataReferences_OriginalImplementation(string expression)
         {
             // The keys in the hash table are the qualified metadata names (e.g. "EmbeddedResource.Culture"
-            // or just "Culture").  The values are MetadataReference structs, which simply split out the item 
+            // or just "Culture").  The values are MetadataReference structs, which simply split out the item
             // name (possibly null) and the actual metadata name.
             Hashtable consumedMetadataReferences = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
@@ -386,7 +386,7 @@ private static Hashtable GetConsumedMetadataReferences_OriginalImplementation(st
         /// <summary>
         /// Looks through a single parameter of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Populates a Hashtable containing a bunch of MetadataReference
-        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// structs.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <param name="batchableObjectParameter"></param>
@@ -476,7 +476,7 @@ Hashtable consumedMetadataReferences
         /// <summary>
         /// Looks through a single parameter of the batchable object, and finds all references to item metadata
         /// (that aren't part of an item transform).  Populates a MatchCollection object with any regex matches
-        /// found in the input.  Each reference to item metadata may or may not be qualified with an item name (e.g., 
+        /// found in the input.  Each reference to item metadata may or may not be qualified with an item name (e.g.,
         /// %(Culture) vs. %(EmbeddedResource.Culture).
         /// </summary>
         /// <param name="batchableObjectParameter"></param>
diff --git a/src/Deprecated/Engine.UnitTests/ExpressionTree_Tests.cs b/src/Deprecated/Engine.UnitTests/ExpressionTree_Tests.cs
index a1fc5b6ac9b..19c3ee674e3 100644
--- a/src/Deprecated/Engine.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ExpressionTree_Tests.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.UnitTests
     [TestFixture]
     public class ExpressionTreeTest
     {
-        private XmlAttribute dummyAttribute; 
+        private XmlAttribute dummyAttribute;
         private XmlAttribute DummyAttribute
         {
             get
@@ -112,7 +112,7 @@ public void EvaluatedAVarietyOfExpressionsWithProjectPerThreadProjectDirectoryNo
         }
 
         /// <summary>
-        /// A whole bunch of conditionals, that should be true, false, or error 
+        /// A whole bunch of conditionals, that should be true, false, or error
         /// (many coincidentally like existing QA tests) to give breadth coverage.
         /// Please add more cases as they arise.
         /// </summary>
@@ -216,7 +216,7 @@ private void EvaluateAVarietyOfExpressions()
                     "0==0.0",
                     "1\n\t==1",
                     "+4==4",
-                    "44==+44.0 and -44==-44.0",                    
+                    "44==+44.0 and -44==-44.0",
                     "false==no",
                     "true==yes",
                     "true==!false",
@@ -285,7 +285,7 @@ private void EvaluateAVarietyOfExpressions()
                     "exists('%3b')",
                     "exists('%27')",
                     "exists('@(v);@(nonexistent)')",
-                    @"HASTRAILINGSLASH('foo\')", 
+                    @"HASTRAILINGSLASH('foo\')",
                     @"!HasTrailingSlash('foo')",
                     @"HasTrailingSlash('foo/')",
                     @"HasTrailingSlash($(has_trailing_slash))",
diff --git a/src/Deprecated/Engine.UnitTests/FileLogger_Tests.cs b/src/Deprecated/Engine.UnitTests/FileLogger_Tests.cs
index 5605b1e2310..c688bd3e4b8 100644
--- a/src/Deprecated/Engine.UnitTests/FileLogger_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/FileLogger_Tests.cs
@@ -31,7 +31,7 @@ public void Basic()
             FileLogger fileLogger = new FileLogger();
             string logFile = Path.GetTempFileName();
             fileLogger.Parameters = "verbosity=Normal;logfile=" + logFile;
-            
+
             Project project = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                     <Target Name=`Build`>
@@ -74,7 +74,7 @@ public void BasicNoExistingFile()
                 if (null != log) File.Delete(log);
             }
         }
-        
+
         /// <summary>
         /// Invalid file should error nicely
         /// </summary>
@@ -92,7 +92,7 @@ public void InvalidFile()
             {
                 if (null != log) File.Delete(log);
             }
-        }        
+        }
 
         /// <summary>
         /// Specific verbosity overrides global verbosity
diff --git a/src/Deprecated/Engine.UnitTests/GroupingCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/GroupingCollection_Tests.cs
index 7d069a7ae05..b5b967ff15b 100644
--- a/src/Deprecated/Engine.UnitTests/GroupingCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/GroupingCollection_Tests.cs
@@ -202,7 +202,7 @@ public void RemoveTest()
         }
 
         /// <summary>
-        /// Make sure linked property group and item group counting works correctly. 
+        /// Make sure linked property group and item group counting works correctly.
         /// Parent grouping collections depend on child grouping collections to update the count for nested groups.
         /// </summary>
         /// <owner>LukaszG</owner>
@@ -243,13 +243,13 @@ public void LinkedCount()
             nestedGroup.Clear();
             nestedGroup.InsertAtEnd(this.ig2);
             nestedGroup.InsertAfter(this.ig3, this.ig2);
-            
+
             childGroup1.RemovePropertyGroup(this.pg1);
             childGroup1.RemoveItemGroup(this.ig1);
             childGroup1.InsertAtEnd(this.ig3);
 
             childGroup2.RemovePropertyGroup(this.pg1);
-            
+
             masterGroup.RemoveItemGroup(this.ig2);
 
             Assertion.AssertEquals(nestedGroup.ItemGroupCount, 2);
diff --git a/src/Deprecated/Engine.UnitTests/HashTableUtility_Tests.cs b/src/Deprecated/Engine.UnitTests/HashTableUtility_Tests.cs
index 2a7d3f3edab..94da0bd2342 100644
--- a/src/Deprecated/Engine.UnitTests/HashTableUtility_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/HashTableUtility_Tests.cs
@@ -23,10 +23,10 @@ public class HashTableUtilityTests
         /// <summary>
         /// Missing unittest found by mutation testing.
         /// REASON TEST WASN'T ORIGINALLY PRESENT: HashTableUtility was not a separate class and
-        /// there was no way to hit this case through BatchingEngine directly because it never 
+        /// there was no way to hit this case through BatchingEngine directly because it never
         /// calls Compare() with unequal numbers of items.
-        /// 
-        /// This test ensures that hashtable     with unequal numbers of items are considered not 
+        ///
+        /// This test ensures that hashtable     with unequal numbers of items are considered not
         /// equivalent.
         /// </summary>
         [Test]
diff --git a/src/Deprecated/Engine.UnitTests/ImportCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/ImportCollection_Tests.cs
index f44a4169435..040c59c4a85 100644
--- a/src/Deprecated/Engine.UnitTests/ImportCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ImportCollection_Tests.cs
@@ -113,19 +113,19 @@ public void RemoveExistingImport()
                 ");
 
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory("main.proj", null);
-            
+
             ImportCollection imports = project.Imports;
             Assertion.AssertEquals(2, imports.Count);
-            
+
             imports.RemoveImport(imports[Path.Combine(ObjectModelHelpers.TempProjectDir, "import1.proj")]);
-            
+
             // First validate that the ImportCollection only contains a single Import
             Assertion.AssertEquals(1, imports.Count);
 
-            // Now validate that the ImportCollection properly updated its parent Project (by inspecting the 
+            // Now validate that the ImportCollection properly updated its parent Project (by inspecting the
             // project's in-memory Xml)
             int importCount = 0;
-            
+
             foreach (XmlNode childNode in project.ProjectElement)
             {
                 if (childNode.Name == XMakeElements.import)
@@ -177,7 +177,7 @@ public void AttemptToRemoveImportedImportShouldThrowException()
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory("main.proj", null);
 
             ImportCollection imports = project.Imports;
-            
+
             // Should throw an InvalidOperationException
             imports.RemoveImport(imports[Path.Combine(ObjectModelHelpers.TempProjectDir, "import3.proj")]);
         }
@@ -198,7 +198,7 @@ public void AttemptToRemoveImportFromAnotherProjectShouldThrowException()
                     <Project xmlns=`msbuildnamespace`>
 
                         <Import Project=`import1.proj` />
-            
+
                         <Target Name=`Build`>
                             <WashCar/>
                         </Target>
@@ -212,7 +212,7 @@ public void AttemptToRemoveImportFromAnotherProjectShouldThrowException()
                     <Project xmlns=`msbuildnamespace`>
 
                         <Import Project=`import1.proj` />
-            
+
                         <Target Name=`Build`>
                             <WashCar/>
                         </Target>
diff --git a/src/Deprecated/Engine.UnitTests/IntrinsicTask_Tests.cs b/src/Deprecated/Engine.UnitTests/IntrinsicTask_Tests.cs
index 35f4de5709f..8d79bf8724e 100644
--- a/src/Deprecated/Engine.UnitTests/IntrinsicTask_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/IntrinsicTask_Tests.cs
@@ -29,7 +29,7 @@ public void PropertyGroup()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -151,7 +151,7 @@ public void PropertyGroupWithConditionOnGroup()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition='false'> 
+                <PropertyGroup Condition='false'>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -164,7 +164,7 @@ public void PropertyGroupWithConditionOnGroup()
 
             content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition='true'> 
+                <PropertyGroup Condition='true'>
                     <p1>v1</p1>
                     <p2>v2</p2>
                 </PropertyGroup>
@@ -195,7 +195,7 @@ public void PropertyGroupWithConditionOnGroupUsingMetadataErrors()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition=""'%(i0.m)'=='m2'""> 
+                <PropertyGroup Condition=""'%(i0.m)'=='m2'"">
                     <p1>@(i0)</p1>
                     <p2>%(i0.m)</p2>
                 </PropertyGroup>
@@ -211,7 +211,7 @@ public void ItemGroup()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -256,7 +256,7 @@ public void ItemGroupTrims()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='  $(p0)  '/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -316,7 +316,7 @@ public void ItemGroupWithTransform()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a.cpp'/>
                     <i2 Include=""@(i1->'%(filename).obj')""/>
                 </ItemGroup>
@@ -336,7 +336,7 @@ public void ItemGroupWithTransformInMetadataValue()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a.cpp'/>
                     <i2 Include='@(i1)'>
                        <m>@(i1->'%(filename).obj')</m>
@@ -357,7 +357,7 @@ public void ItemGroupWithExclude()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'/>
                     <i2 Include='a1;@(i1);b1;b2' Exclude='@(i1);b1'/>
                 </ItemGroup>
@@ -377,7 +377,7 @@ public void ItemGroupWithMetadataInExclude()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>a1</m>
                     </i1>
@@ -401,7 +401,7 @@ public void ItemGroupWithConditionOnGroup()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup Condition='false'> 
+                <ItemGroup Condition='false'>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -415,7 +415,7 @@ public void ItemGroupWithConditionOnGroup()
 
             content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup Condition='true'> 
+                <ItemGroup Condition='true'>
                     <i1 Include='a1'/>
                     <i2 Include='b1'/>
                 </ItemGroup>
@@ -447,7 +447,7 @@ public void ItemGroupWithConditionOnGroupUsingMetadataErrors()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup Condition=""'%(i0.m)'!='m1'""> 
+                <ItemGroup Condition=""'%(i0.m)'!='m1'"">
                     <i1 Include='a1'/>
                     <i2 Include='%(i0.m)'/>
                     <i3 Include='%(i0.identity)'/>
@@ -467,7 +467,7 @@ public void PropertyGroupWithExternalPropertyReferences()
             // </PropertyGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>$(p0)</p1>
                 </PropertyGroup>
             </Target>";
@@ -488,7 +488,7 @@ public void ItemGroupWithPropertyReferences()
             // </PropertyGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='$(p0)'/>
                     <i2 Include='a2'/>
                 </ItemGroup>
@@ -509,7 +509,7 @@ public void ItemGroupWithMetadataReferences()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>m1</m>
                     </i1>
@@ -540,7 +540,7 @@ public void ItemGroupWithMetadataReferencesOnMetadataConditions()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='a1'>
                         <m>m1</m>
                     </i1>
@@ -609,7 +609,7 @@ public void ItemGroupWithExternalMetadataReferences()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include='b1'>
                         <m>%(i0.m)</m>
                     </i1>
@@ -641,7 +641,7 @@ public void PropertyGroupWithCumulativePropertyReferences()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1>v1</p1>
                     <p2>#$(p1)#</p2>
                     <p1>v2</p1>
@@ -677,7 +677,7 @@ public void PropertyGroupWithMetadataReferencesOnGroupErrors()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition=""'%(i0.m)' != m1""> 
+                <PropertyGroup Condition=""'%(i0.m)' != m1"">
                     <p1>%(i0.m)</p1>
                 </PropertyGroup>
             </Target>";
@@ -706,7 +706,7 @@ public void PropertyGroupWithMetadataReferencesOnProperty()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup> 
+                <PropertyGroup>
                     <p1 Condition=""'%(i0.n)' != n3"">%(i0.n)</p1>
                 </PropertyGroup>
             </Target>";
@@ -750,7 +750,7 @@ public void ItemsCanReferencePropertiesInSameTarget()
                     <PropertyGroup>
                         <p0>v0</p0>
                     </PropertyGroup>
-                    <ItemGroup> 
+                    <ItemGroup>
                         <i1 Include='$(p0)'/>
                     </ItemGroup>
                     <Message Text=`[@(i1)]`/>
@@ -857,7 +857,7 @@ public void PropertiesVisibleToSubsequentTarget()
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`[$(p)]`/>                    
+                    <Message Text=`[$(p)]`/>
                   </Target>
                   <Target Name=`t`>
                     <PropertyGroup>
@@ -897,7 +897,7 @@ public void ItemsVisibleToSubsequentTarget()
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`[@(i)]`/>                    
+                    <Message Text=`[@(i)]`/>
                   </Target>
                   <Target Name=`t`>
                     <ItemGroup>
@@ -920,13 +920,13 @@ public void ItemsNotVisibleToParallelTargetBatches()
                   <ItemGroup>
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <Message Text=`start:[@(i)]`/>
                     <ItemGroup>
                       <j Include=`%(i.identity)`/>
                     </ItemGroup>
-                    <Message Text=`end:[@(j)]`/>                    
+                    <Message Text=`end:[@(j)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -975,16 +975,16 @@ public void ItemsInPartialBuild()
                   <ItemGroup>
                     <i Include=`" + oldFiles[0] + "`><output>" + newFiles[0] + @"</output></i>
                     <i Include=`" + newFiles[1] + "`><output>" + oldFiles[1] + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[@(j)]`/>                    
+                    <Message Text=`final:[@(j)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[@(j)]`/>
                     <ItemGroup>
                       <j Include=`%(i.identity)`/>
                     </ItemGroup>
-                    <Message Text=`end:[@(j)]`/>                    
+                    <Message Text=`end:[@(j)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1016,16 +1016,16 @@ public void PropertiesInPartialBuild()
                   <ItemGroup>
                     <i Include=`" + oldFiles[0] + "`><output>" + newFiles[0] + @"</output></i>
                     <i Include=`" + newFiles[1] + "`><output>" + oldFiles[1] + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[$(p)]`/>                    
+                    <Message Text=`final:[$(p)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[$(p)]`/>
                     <PropertyGroup>
                       <p>@(i)</p>
                     </PropertyGroup>
-                    <Message Text=`end:[$(p)]`/>                    
+                    <Message Text=`end:[$(p)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1062,20 +1062,20 @@ public void ItemsInPartialBuildVisibleToSubsequentlyInferringTasks()
                   <ItemGroup>
                     <i Include=`" + oldInput + "`><output>" + newOutput + @"</output></i>
                     <i Include=`" + newInput + "`><output>" + oldOutput + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[@(i)]`/>                    
+                    <Message Text=`final:[@(i)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[@(i)]`/>
                     <ItemGroup>
                       <j Include=`%(i.identity)`/>
                     </ItemGroup>
-                    <Message Text=`middle:[@(i)][@(j)]`/> 
+                    <Message Text=`middle:[@(i)][@(j)]`/>
                     <CreateItem Include=`@(j)`>
                       <Output TaskParameter=`Include` ItemName=`i`/>
                     </CreateItem>
-                    <Message Text=`end:[@(i)]`/>                    
+                    <Message Text=`end:[@(i)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1084,11 +1084,11 @@ public void ItemsInPartialBuildVisibleToSubsequentlyInferringTasks()
                 // We should only see messages for the out of date inputs, but the itemgroup should do its work for both inputs;
                 // The final result should include the out of date inputs (twice) and the up to date inputs (twice).
                 // NOTE: outputs from regular tasks, like CreateItem, are gathered up and included in the project in the order (1) inferred (2) executed.
-                // Intrinsic tasks, because they affect the project directly, don't do this. So the final order we see is 
+                // Intrinsic tasks, because they affect the project directly, don't do this. So the final order we see is
                 // two inputs (old, new) from the ItemGroup; followed by the inferred CreateItem output, then the executed CreateItem output.
                 // I suggest this ordering isn't important: it's a new feature, so nobody will get broken.
-                logger.AssertLogContains(new string[] { "start:[" + newInput + "]", 
-                                                        "middle:[" + newInput + "][" + newInput + "]", 
+                logger.AssertLogContains(new string[] { "start:[" + newInput + "]",
+                                                        "middle:[" + newInput + "][" + newInput + "]",
                                                         "end:["   + newInput + ";" + newInput + "]",
                                                         "final:[" + oldInput + ";" + newInput + ";" + oldInput + ";" + newInput + "]" });
             }
@@ -1105,7 +1105,7 @@ public void IncludeNoOp()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Include=''/>
                 </ItemGroup>
             </Target>";
@@ -1118,7 +1118,7 @@ public void RemoveNoOp()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1 Remove='a1'/>
                 </ItemGroup>
             </Target>";
@@ -1135,7 +1135,7 @@ public void RemoveItemInTarget()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
+                    <i1 Include='a1'/>
                     <i1 Remove='a1'/>
                 </ItemGroup>
             </Target>";
@@ -1160,7 +1160,7 @@ public void RemoveOfItemAddedInTargetByParallelTargetBatchDoesNothing()
                     <!-- just to cause two target batches -->
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <ItemGroup>
                       <j Include=`a` Condition=`'%(i.Identity)'=='1.in'`/>
@@ -1196,7 +1196,7 @@ public void RemoveItemInTargetWithTransform()
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
                     <i0 Include='a.cpp;b.cpp'/>
-                    <i1 Include='a.obj;b.obj'/> 
+                    <i1 Include='a.obj;b.obj'/>
                     <i1 Remove=""@(i0->'%(filename).obj')""/>
                 </ItemGroup>
             </Target>";
@@ -1213,8 +1213,8 @@ public void RemoveWithMultipleItemspecs()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
-                    <i1 Include='a2'/> 
+                    <i1 Include='a1'/>
+                    <i1 Include='a2'/>
                     <i1 Remove='a1;a2'/>
                 </ItemGroup>
             </Target>";
@@ -1231,8 +1231,8 @@ public void RemoveAllItemsInList()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'/> 
-                    <i1 Include='a2'/> 
+                    <i1 Include='a1'/>
+                    <i1 Include='a2'/>
                     <i1 Remove='@(i1)'/>
                 </ItemGroup>
             </Target>";
@@ -1280,7 +1280,7 @@ public void RemoveItemOutsideTarget()
         }
 
         /// <summary>
-        /// Bare (batchable) metadata is prohibited on IG/PG conditions -- all other expressions 
+        /// Bare (batchable) metadata is prohibited on IG/PG conditions -- all other expressions
         /// should be allowed
         /// </summary>
         [Test]
@@ -1302,7 +1302,7 @@ public void ConditionOnPropertyGroupUsingPropertiesAndItemListsAndTransforms()
             // </PropertyGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <PropertyGroup Condition=""'$(p0)'=='v0' and '@(i0)'=='a1;a2;a3;a4' and '@(i0->'%(identity).x','|')'=='a1.x|a2.x|a3.x|a4.x'""> 
+                <PropertyGroup Condition=""'$(p0)'=='v0' and '@(i0)'=='a1;a2;a3;a4' and '@(i0->'%(identity).x','|')'=='a1.x|a2.x|a3.x|a4.x'"">
                   <p1>v1</p1>
                 </PropertyGroup>
             </Target>";
@@ -1318,7 +1318,7 @@ public void ConditionOnPropertyGroupUsingPropertiesAndItemListsAndTransforms()
         }
 
         /// <summary>
-        /// Bare (batchable) metadata is prohibited on IG/PG conditions -- all other expressions 
+        /// Bare (batchable) metadata is prohibited on IG/PG conditions -- all other expressions
         /// should be allowed
         /// </summary>
         [Test]
@@ -1340,7 +1340,7 @@ public void ConditionOnItemGroupUsingPropertiesAndItemListsAndTransforms()
             // </PropertyGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup Condition=""'$(p0)'=='v0' and '@(i0)'=='a1;a2;a3;a4' and '@(i0->'%(identity).x','|')'=='a1.x|a2.x|a3.x|a4.x'"">  
+                <ItemGroup Condition=""'$(p0)'=='v0' and '@(i0)'=='a1;a2;a3;a4' and '@(i0->'%(identity).x','|')'=='a1.x|a2.x|a3.x|a4.x'"">
                   <i1 Include='x'/>
                 </ItemGroup>
             </Target>";
@@ -1359,9 +1359,9 @@ public void ConditionOnItemGroupUsingPropertiesAndItemListsAndTransforms()
         /// <summary>
         /// This bug was caused by batching over the ItemGroup as well as over each child.
         /// If the condition on a child did not exclude it, an unwitting child could be included multiple times,
-        /// once for each outer batch. The fix was to abandon the idea of outer batching and just 
+        /// once for each outer batch. The fix was to abandon the idea of outer batching and just
         /// prohibit batchable expressions on the ItemGroup conditions. It's just too hard to write such expressions
-        /// in a comprehensible way.    
+        /// in a comprehensible way.
         /// </summary>
         [Test]
         public void RegressPCHBug68578()
@@ -1379,7 +1379,7 @@ public void RegressPCHBug68578()
             // </ItemGroup>
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                   <!-- squint and pretend i0 is 'CppCompile' and 'm' is 'ObjectFile' -->
                   <Link Include=""A_PCH""/>
                   <Link Include=""@(i0->'%(m).obj')"" Condition=""'%(i0.m)' == 'm1'""/>
@@ -1504,13 +1504,13 @@ public void RemovesOfPersistedItemsAreReversed3()
                   <ItemGroup>
                     <i0 Include='a1'>
                       <m>m1</m>
-                    </i0> 
+                    </i0>
                   </ItemGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i0 Include='a1'>
                         <m>m2</m>
-                      </i0> 
+                      </i0>
                       <i0 Remove=`a1`/>
                     </ItemGroup>
                     <Message Text=`[%(i0.m)]`/>
@@ -1574,13 +1574,13 @@ public void RemovesOfItemsOnlyWithMetadataValue()
                   <ItemGroup>
                     <i0 Include='a1'>
                       <m>m1</m>
-                    </i0> 
+                    </i0>
                   </ItemGroup>
                   <Target Name=`t`>
                     <ItemGroup>
                       <i0 Include='a1'>
                         <m>m2</m>
-                      </i0> 
+                      </i0>
                       <i0 Remove=`a1` Condition=`'%(i0.m)' == 'm1'`/>
                     </ItemGroup>
                     <Message Text=`[%(i0.m)]`/>
@@ -1634,7 +1634,7 @@ public void RemoveWithWildcards()
                 string content = @"
                 <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <ItemGroup>
-                        <i1 Include='" + files[0] + ";" + files[1] + @";other'/> 
+                        <i1 Include='" + files[0] + ";" + files[1] + @";other'/>
                         <i1 Remove='$(temp)\*.tmp'/>
                     </ItemGroup>
                 </Target>";
@@ -1662,13 +1662,13 @@ public void RemovesNotVisibleToParallelTargetBatches()
                   <ItemGroup>
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <Message Text=`start:[@(i)]`/>
                     <ItemGroup>
                       <i Remove=`1.in;2.in`/>
                     </ItemGroup>
-                    <Message Text=`end:[@(i)]`/>                    
+                    <Message Text=`end:[@(i)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1687,13 +1687,13 @@ public void RemovesNotVisibleToParallelTargetBatches2()
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
                     <j Include=`j1`/>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <Message Text=`start:[@(j)]`/>
                     <ItemGroup>
                       <j Remove=`@(j)`/>
                     </ItemGroup>
-                    <Message Text=`end:[@(j)]`/>                    
+                    <Message Text=`end:[@(j)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -1717,7 +1717,7 @@ public void RemovesAreVisibleToCalledTarget()
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <ItemGroup>
                     <i Include=`i1;i2`/>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t`>
                     <Message Text=`a:[@(i)]`/>
                     <ItemGroup>
@@ -1725,7 +1725,7 @@ public void RemovesAreVisibleToCalledTarget()
                     </ItemGroup>
                     <Message Text=`b:[@(i)]`/>
                     <CallTarget Targets=`t2`/>
-                    <Message Text=`d:[@(i)]`/>                    
+                    <Message Text=`d:[@(i)]`/>
                   </Target>
                   <Target Name=`t2`>
                     <Message Text=`c:[@(i)]`/>
@@ -1783,7 +1783,7 @@ public void CalledTargetItemsAreNotVisibleToCallerTarget()
 
         /// <summary>
         /// Whidbey behavior was that items/properties emitted by a target calling another target, were
-        /// not visible to the calling target. (That was because the project items and properties had been cloned for the target batches.) 
+        /// not visible to the calling target. (That was because the project items and properties had been cloned for the target batches.)
         /// We must match that behavior. (For now)
         /// </summary>
         [Test]
@@ -1829,7 +1829,7 @@ public void ModifyNoOp()
         {
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-                <ItemGroup> 
+                <ItemGroup>
                     <i1/>
                 </ItemGroup>
             </Target>";
@@ -1846,7 +1846,7 @@ public void ModifyItemInTarget()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
                     <i1>
@@ -1868,7 +1868,7 @@ public void ModifyItemInTargetLastMetadataWins()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
                     <i1>
@@ -1916,10 +1916,10 @@ public void ModifyItemInTargetWithCondition()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1 Condition=""'%(i1.m)'=='m2'"">
@@ -1945,10 +1945,10 @@ public void ModifyItemInTargetWithConditionOnMetadata()
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1>
@@ -1991,10 +1991,10 @@ public void ModifyItemInTargetWithConditionWithoutItemTypeOnMetadataInCondition(
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1 Condition=""'%(m)'=='m2'"">
@@ -2021,10 +2021,10 @@ public void ModifyItemInTargetWithConditionOnMetadataWithoutItemTypeOnMetadataIn
             string content = @"
             <Target Name='t' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                 <ItemGroup>
-                    <i1 Include='a1'> 
+                    <i1 Include='a1'>
                       <m>m1</m>
                     </i1>
-                    <i1 Include='a2'> 
+                    <i1 Include='a2'>
                       <m>m2</m>
                     </i1>
                     <i1>
@@ -2072,7 +2072,7 @@ public void ModifyItemOutsideTarget()
             IntrinsicTask task = CreateIntrinsicTask(content);
 
             Lookup lookup = GenerateLookup();
-            
+
             task.ExecuteTask(lookup);
 
             BuildItemGroup i0Group = lookup.GetItems("i0");
@@ -2149,7 +2149,7 @@ public void ModifiesOfPersistedItemsAreReversed1()
                     <ItemGroup>
                       <i0>
                         <m>m1</m>
-                      </i0> 
+                      </i0>
                     </ItemGroup>
                   </Target>
                   <Target Name=`t2`>
@@ -2190,7 +2190,7 @@ public void ModifiesOfPersistedItemsAreReversed2()
                       </i1>
                       <i1>
                         <n>n1</n>
-                      </i1> 
+                      </i1>
                     </ItemGroup>
                   </Target>
                   <Target Name=`t2`>
@@ -2307,7 +2307,7 @@ public void OutputPropertiesInTargetBatchesCreateItem()
                     <!-- just to cause two target batches -->
                     <i Include=`1.in`><output>1.out</output></i>
                     <i Include=`2.in`><output>2.out</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.output)`>
                     <Message Text=`start:[$(p)]`/>
                     <CreateProperty Value='$(p)--%(i.Identity)'>
@@ -2363,16 +2363,16 @@ public void PropertiesInInferredBuildCreateProperty()
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <ItemGroup>
                     <i Include=`" + files[0] + "`><output>" + files[1] + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[$(p)]`/>                    
+                    <Message Text=`final:[$(p)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[$(p)]`/>
                     <CreateProperty Value='@(i)'>
                       <Output TaskParameter='Value' PropertyName='p'/>
                     </CreateProperty>
-                    <Message Text=`end:[$(p)]`/>                    
+                    <Message Text=`end:[$(p)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -2405,7 +2405,7 @@ public void ModifyItemPreviouslyModified()
                       </x>
                       <x>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text=`[%(x.m1)]`/>
                   </Target>
@@ -2435,7 +2435,7 @@ public void ModifyItemPreviouslyModified2()
                     <ItemGroup>
                       <x>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text=`[%(x.m1)]`/>
                   </Target>
@@ -2517,7 +2517,7 @@ public void FilterItemPreviouslyModified()
                       </x>
                       <x Condition=`'%(x.m1)'=='1'`>
                         <m1>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text=`[%(x.m1)]`/>
                   </Target>
@@ -2545,7 +2545,7 @@ public void FilterItemPreviouslyModified2()
                       </x>
                       <x>
                         <m1 Condition=`'%(x.m1)'=='1'`>2</m1>
-                      </x>  
+                      </x>
                     </ItemGroup>
                     <Message Text=`[%(x.m1)]`/>
                   </Target>
@@ -2744,9 +2744,9 @@ private static IntrinsicTask CreateIntrinsicTask(string content)
             XmlDocument doc = new XmlDocument();
             doc.LoadXml(content);
 
-            IntrinsicTask task = new IntrinsicTask((XmlElement)doc.FirstChild.FirstChild, 
-                                                   new EngineLoggingServicesInProc(new EventSource(), true, null), 
-                                                   null, 
+            IntrinsicTask task = new IntrinsicTask((XmlElement)doc.FirstChild.FirstChild,
+                                                   new EngineLoggingServicesInProc(new EventSource(), true, null),
+                                                   null,
                                                    Directory.GetCurrentDirectory(),
                                                    new ItemDefinitionLibrary(new Project()));
             return task;
diff --git a/src/Deprecated/Engine.UnitTests/InvalidProjectFileException_Tests.cs b/src/Deprecated/Engine.UnitTests/InvalidProjectFileException_Tests.cs
index 599a19cfc3f..d11b243c0ef 100644
--- a/src/Deprecated/Engine.UnitTests/InvalidProjectFileException_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/InvalidProjectFileException_Tests.cs
@@ -30,11 +30,11 @@ public class InvalidProjectFileExceptionTests
         public void SerializeDeserialize()
         {
             InvalidProjectFileException e = new InvalidProjectFileException(
-                "projectFile", 
+                "projectFile",
                 1, 2, 3, 4,
                 "message",
                 "errorSubcategory",
-                "errorCode", 
+                "errorCode",
                 "helpKeyword");
 
             using (MemoryStream memstr = new MemoryStream())
diff --git a/src/Deprecated/Engine.UnitTests/ItemDefinitionLibrary_Tests.cs b/src/Deprecated/Engine.UnitTests/ItemDefinitionLibrary_Tests.cs
index db0a3760d63..b058f26bc06 100644
--- a/src/Deprecated/Engine.UnitTests/ItemDefinitionLibrary_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ItemDefinitionLibrary_Tests.cs
@@ -30,7 +30,7 @@ public void GetMetadataBeforeEvaluate()
             ItemDefinitionLibrary library = new ItemDefinitionLibrary(new Project());
             library.Add(group);
             library.GetDefaultMetadataValue("ccompile", "defines");
-        } 
+        }
 
         [Test]
         public void Basic()
@@ -44,7 +44,7 @@ public void Basic()
             library.Evaluate(null);
 
             Assertion.AssertEquals("DEBUG", library.GetDefaultMetadataValue("ccompile", "defines"));
-        }        
+        }
 
         [Test]
         public void SameGroupTwoChildrenSameItemTypeDifferentMetadata()
@@ -132,7 +132,7 @@ public void PropertyInMetadataValue()
 
         /// <summary>
         /// Verifies that, given metadata on an item definition, a corresponding item will pick up
-        /// that item definition metadata.  
+        /// that item definition metadata.
         /// </summary>
         [Test]
         public void ItemsPickUpItemDefinitionMetadata()
@@ -144,7 +144,7 @@ public void ItemsPickUpItemDefinitionMetadata()
                             <SomeMetadata>foo</SomeMetadata>
                         </ItemWithDefinition>
                     </ItemDefinitionGroup>
-                    
+
                     <ItemGroup>
                         <ItemWithDefinition Include=`foo.cs` />
                     </ItemGroup>
@@ -160,7 +160,7 @@ public void ItemsPickUpItemDefinitionMetadata()
 
         /// <summary>
         /// Verifies that, given metadata on an item definition, a corresponding item will pick up
-        /// that item definition metadata, even if the name of the item has since changed.  
+        /// that item definition metadata, even if the name of the item has since changed.
         /// </summary>
         [Test]
         public void ItemsPickUpItemDefinitionMetadataWithTransforms()
@@ -172,7 +172,7 @@ public void ItemsPickUpItemDefinitionMetadataWithTransforms()
                             <SomeMetadata>foo</SomeMetadata>
                         </ItemWithDefinition>
                     </ItemDefinitionGroup>
-                    
+
                     <ItemGroup>
                         <ItemWithDefinition Include=`foo.cs` />
                     </ItemGroup>
@@ -192,7 +192,7 @@ public void ItemsPickUpItemDefinitionMetadataWithTransforms()
 
         /// <summary>
         /// Verifies that, given metadata on an item definition, a corresponding item will pick up
-        /// that item definition metadata even if the definition is in a different project from the item.  
+        /// that item definition metadata even if the definition is in a different project from the item.
         /// </summary>
         [Test]
         public void ItemsPickUpItemDefinitionMetadataFromImportedProject()
diff --git a/src/Deprecated/Engine.UnitTests/ItemExpander_Tests.cs b/src/Deprecated/Engine.UnitTests/ItemExpander_Tests.cs
index a242d3b5282..eb909464aef 100644
--- a/src/Deprecated/Engine.UnitTests/ItemExpander_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ItemExpander_Tests.cs
@@ -157,7 +157,7 @@ public void ItemizeItemVectorNormal()
             Assertion.AssertEquals("First item WarningLevel should be 4", "4", compileItems[0].GetMetadata("WarningLevel"));
             Assertion.AssertEquals("First item should be b.cs", "b.cs", compileItems[1].FinalItemSpecEscaped);
             Assertion.AssertEquals("First item WarningLevel should be 3", "3", compileItems[1].GetMetadata("WarningLevel"));
-        }      
+        }
 
         /// <summary>
         /// Attempt to itemize an expression that is an @(...) item list concatenated with another string.
@@ -182,7 +182,7 @@ public void ItemizeItemVectorWithNoItemLists()
             Hashtable itemGroupsByType = this.GenerateTestItems();
 
             BuildItemGroup compileItems = ItemExpander.ItemizeItemVector("foobar", null, LookupHelpers.CreateLookup(itemGroupsByType).ReadOnlyLookup);
-            
+
             // If the specified expression does not contain any item lists, then we expect ItemizeItemVector
             // to give us back null, but not throw an exception.
             Assertion.AssertNull(compileItems);
@@ -278,17 +278,17 @@ public void ItemizeItemVectorWithSeparatorWithZeroItems2()
             logger.AssertLogContains("zz=[]");
         }
 
-        // Valid names. The goal here is that an item name is recognized iff it is valid 
+        // Valid names. The goal here is that an item name is recognized iff it is valid
         // in a project. (That is, iff it matches "[A-Za-z_][A-Za-z_0-9\-]*")
         private string[] validItemVectors = new string[]
         {
-            "@(   a1234567890_-AXZaxz   )", 
-            "@(z1234567890_-AZaz)", 
-            "@(A1234567890_-AZaz)", 
-            "@(Z1234567890_-AZaz)", 
-            "@(x1234567890_-AZaz)", 
-            "@(_X)", 
-            "@(a)", 
+            "@(   a1234567890_-AXZaxz   )",
+            "@(z1234567890_-AZaz)",
+            "@(A1234567890_-AZaz)",
+            "@(Z1234567890_-AZaz)",
+            "@(x1234567890_-AZaz)",
+            "@(_X)",
+            "@(a)",
             "@(_)"
         };
 
@@ -310,21 +310,21 @@ public void ItemizeItemVectorWithSeparatorWithZeroItems2()
 
         private string[] validMetadataExpressions = new string[]
         {
-            "%(   a1234567890_-AXZaxz.a1234567890_-AXZaxz   )", 
-            "%(z1234567890_-AZaz.z1234567890_-AZaz)", 
-            "%(A1234567890_-AZaz.A1234567890_-AZaz)", 
-            "%(Z1234567890_-AZaz.Z1234567890_-AZaz)", 
-            "%(x1234567890_-AZaz.x1234567890_-AZaz)", 
-            "%(abc._X)", 
-            "%(a12.a)", 
+            "%(   a1234567890_-AXZaxz.a1234567890_-AXZaxz   )",
+            "%(z1234567890_-AZaz.z1234567890_-AZaz)",
+            "%(A1234567890_-AZaz.A1234567890_-AZaz)",
+            "%(Z1234567890_-AZaz.Z1234567890_-AZaz)",
+            "%(x1234567890_-AZaz.x1234567890_-AZaz)",
+            "%(abc._X)",
+            "%(a12.a)",
             "%(x._)",
-            "%(a1234567890_-AXZaxz)", 
-            "%(z1234567890_-AZaz)", 
-            "%(A1234567890_-AZaz)", 
-            "%(Z1234567890_-AZaz)", 
-            "%(x1234567890_-AZaz)", 
-            "%(_X)", 
-            "%(a)", 
+            "%(a1234567890_-AXZaxz)",
+            "%(z1234567890_-AZaz)",
+            "%(A1234567890_-AZaz)",
+            "%(Z1234567890_-AZaz)",
+            "%(x1234567890_-AZaz)",
+            "%(_X)",
+            "%(a)",
             "%(_)"
         };
 
@@ -355,45 +355,45 @@ public void ItemizeItemVectorWithSeparatorWithZeroItems2()
 
         private string[] validItemVectorsWithTransforms = new string[]
         {
-            "@(z1234567890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'   )", 
-            "@(a1234567890_-AZaz->'z1234567890_-AZaz')", 
-            "@(A1234567890_-AZaz ->'A1234567890_-AZaz')", 
-            "@(Z1234567890_-AZaz -> 'Z1234567890_-AZaz')", 
-            "@(x1234567890_-AZaz->'x1234567890_-AZaz')", 
-            "@(_X->'_X')", 
-            "@(a->'a')", 
+            "@(z1234567890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'   )",
+            "@(a1234567890_-AZaz->'z1234567890_-AZaz')",
+            "@(A1234567890_-AZaz ->'A1234567890_-AZaz')",
+            "@(Z1234567890_-AZaz -> 'Z1234567890_-AZaz')",
+            "@(x1234567890_-AZaz->'x1234567890_-AZaz')",
+            "@(_X->'_X')",
+            "@(a->'a')",
             "@(_->'@#$%$%^&*&*)')"
         };
 
         private string[] validItemVectorsWithSeparators = new string[]
         {
-            "@(a1234567890_-AXZaxz  , 'z123%%4567890_-AXZaxz'   )", 
-            "@(z1234567890_-AZaz,'a1234567890_-AZaz')", 
-            "@(A1234567890_-AZaz,'!@#$%^&*)(_+'))", 
-            "@(_X,'X')", 
-            "@(a  ,  'a')", 
+            "@(a1234567890_-AXZaxz  , 'z123%%4567890_-AXZaxz'   )",
+            "@(z1234567890_-AZaz,'a1234567890_-AZaz')",
+            "@(A1234567890_-AZaz,'!@#$%^&*)(_+'))",
+            "@(_X,'X')",
+            "@(a  ,  'a')",
             "@(_,'@#$%$%^&*&*)')"
         };
 
         private string[] validItemVectorsWithTransformsAndSeparators = new string[]
         {
-            "@(a1234567890_-AXZaxz  -> 'a1234567890_-AXZaxz'   ,  'z1234567890_-AXZaxz'   )", 
-            "@(z1234567890_-AZaz->'z1234567890_-AZaz','a1234567890_-AZaz')", 
-            "@(A1234567890_-AZaz ->'A1234567890_-AZaz' , '!@#$%^&*)(_+'))", 
-            "@(_X->'_X','X')", 
-            "@(a->'a'  ,  'a')", 
+            "@(a1234567890_-AXZaxz  -> 'a1234567890_-AXZaxz'   ,  'z1234567890_-AXZaxz'   )",
+            "@(z1234567890_-AZaz->'z1234567890_-AZaz','a1234567890_-AZaz')",
+            "@(A1234567890_-AZaz ->'A1234567890_-AZaz' , '!@#$%^&*)(_+'))",
+            "@(_X->'_X','X')",
+            "@(a->'a'  ,  'a')",
             "@(_->'@#$%$%^&*&*)','@#$%$%^&*&*)')"
         };
 
         private string[] invalidItemVectorsWithTransforms = new string[]
         {
-            "@(z123456.7890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'  )", 
-            "@(a1234:567890_-AZaz->'z1234567890_-AZaz')", 
-            "@(.A1234567890_-AZaz ->'A1234567890_-AZaz')", 
-            "@(:Z1234567890_-AZaz -> 'Z1234567890_-AZaz')", 
-            "@(x123 4567890_-AZaz->'x1234567890_-AZaz')", 
-            "@(-x->'_X')", 
-            "@(1->'a')", 
+            "@(z123456.7890_-AXZaxz  -> '%(a1234567890_-AXZaxz).%(adfas)'  )",
+            "@(a1234:567890_-AZaz->'z1234567890_-AZaz')",
+            "@(.A1234567890_-AZaz ->'A1234567890_-AZaz')",
+            "@(:Z1234567890_-AZaz -> 'Z1234567890_-AZaz')",
+            "@(x123 4567890_-AZaz->'x1234567890_-AZaz')",
+            "@(-x->'_X')",
+            "@(1->'a')",
             "@(1x->'@#$%$%^&*&*)')"
         };
 
@@ -419,14 +419,14 @@ public void ItemizeItemVectorsWithValidNames()
 
         /// <summary>
         /// Ensure that leading sand trailing pace is ignored for the item name
-        /// This tests "itemVectorPattern". 
+        /// This tests "itemVectorPattern".
         /// </summary>
         /// <owner>danmose</owner>
         [Test]
         public void ItemizeItemVectorsWithLeadingAndTrailingSpaces()
         {
             Hashtable itemGroupsByType = this.GenerateTestItems();
-            
+
             // Spaces around are fine, but it's ignored for the item name
             BuildItemGroup items = ItemExpander.ItemizeItemVector("@(  Compile    )", null, LookupHelpers.CreateLookup(itemGroupsByType).ReadOnlyLookup);
             Assertion.AssertEquals("Resulting item group should have 2 items", 2, items.Count);
@@ -434,7 +434,7 @@ public void ItemizeItemVectorsWithLeadingAndTrailingSpaces()
 
         /// <summary>
         /// Ensure that invalid item list expressions are not matched.
-        /// This tests "itemVectorPattern". 
+        /// This tests "itemVectorPattern".
         /// </summary>
         /// <owner>danmose</owner>
         [Test]
@@ -442,7 +442,7 @@ public void ItemizeItemVectorsWithInvalidNames()
         {
             Hashtable itemGroupsByType = this.GenerateTestItems();
 
-            // First, verify that a valid but simply non-existent item list returns an empty BuildItemGroup, 
+            // First, verify that a valid but simply non-existent item list returns an empty BuildItemGroup,
             // not just null.
             BuildItemGroup control = ItemExpander.ItemizeItemVector("@(nonexistent)", null, LookupHelpers.CreateLookup(itemGroupsByType).ReadOnlyLookup);
             Assertion.AssertEquals(0, control.Count);
diff --git a/src/Deprecated/Engine.UnitTests/Item_Tests.cs b/src/Deprecated/Engine.UnitTests/Item_Tests.cs
index 9534bcbef79..2e87f865741 100644
--- a/src/Deprecated/Engine.UnitTests/Item_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Item_Tests.cs
@@ -80,7 +80,7 @@ public void IncludeAndExcludeUnescaping()
                 Assertion.Assert(") should exclude both from );%29", i9Items.Count == 0);
                 Assertion.Assert("%2a should exclude %2a", i10Items.Count == 0);
                 Assertion.Assert("* matching foo should exclude foo", i11Items.Count == 0);
-                Assertion.Assert("* should exclude *", i12Items.Count == 0); 
+                Assertion.Assert("* should exclude *", i12Items.Count == 0);
             }
             finally
             {
@@ -103,7 +103,7 @@ public void ItemMetadataShouldBeEvaluatedEarly()
                         </Compile>
                         <CultureItem Include=`french`/>
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -145,20 +145,20 @@ public void HasMetadataAndGetItemMetadata()
             BuildItemGroup iItems = project.GetEvaluatedItemsByName("i");
             // I believe it is safe to assume ordering as ItemGroup is backed up by an ArrayList
             Assertion.Assert(iItems[0].FinalItemSpecEscaped == "i1");
-            Assertion.Assert(!iItems[0].HasMetadata("Culture")); // Does not have it 
+            Assertion.Assert(!iItems[0].HasMetadata("Culture")); // Does not have it
             Assertion.Assert(iItems[1].FinalItemSpecEscaped == "i2");
             Assertion.Assert(iItems[1].HasMetadata("Culture"));
             Assertion.Assert(iItems[1].HasMetadata("CuLtUrE"));
             Assertion.Assert(iItems[1].GetMetadata("CuLtUrE") == "klingon");
             Assertion.Assert(iItems[2].FinalItemSpecEscaped == "i3");
             Assertion.Assert(iItems[2].HasMetadata("Culture"));
-            Assertion.Assert(iItems[2].GetMetadata("Culture") == ""); 
+            Assertion.Assert(iItems[2].GetMetadata("Culture") == "");
             Assertion.Assert(iItems[3].FinalItemSpecEscaped == "i4");
             Assertion.Assert(iItems[3].HasMetadata("Culture"));
-            Assertion.Assert(iItems[3].GetMetadata("Culture") == ""); 
+            Assertion.Assert(iItems[3].GetMetadata("Culture") == "");
             Assertion.Assert(iItems[4].FinalItemSpecEscaped == "i1");
-            Assertion.Assert(iItems[4].HasMetadata("Culture")); 
-            Assertion.Assert(iItems[4].GetMetadata("Culture") == "vulcan"); 
+            Assertion.Assert(iItems[4].HasMetadata("Culture"));
+            Assertion.Assert(iItems[4].GetMetadata("Culture") == "vulcan");
         }
 
         [Test]
diff --git a/src/Deprecated/Engine.UnitTests/LogFormatter_Tests.cs b/src/Deprecated/Engine.UnitTests/LogFormatter_Tests.cs
index dc8f5e5ea13..130a81a5e79 100644
--- a/src/Deprecated/Engine.UnitTests/LogFormatter_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/LogFormatter_Tests.cs
@@ -22,7 +22,7 @@ public class LogFormatterTest
         /*
         * Method:  TimeSpanMediumDuration
         * Owner:   jomof
-        * 
+        *
         * Tests the mainline: a medium length duration
         */
         [Test]
@@ -30,14 +30,14 @@ public void TimeSpanMediumDuration()
         {
             TimeSpan t = new TimeSpan(1254544900);
             string result = LogFormatter.FormatTimeSpan(t);
-            Assertion.AssertEquals("00:02:05.45", result);            
+            Assertion.AssertEquals("00:02:05.45", result);
         }
 
 
         /*
         * Method:  TimeSpanZeroDuration
         * Owner:   jomof
-        * 
+        *
         * Format a TimeSpan where the duration is zero.
         */
         [Test]
@@ -45,7 +45,7 @@ public void TimeSpanZeroDuration()
         {
             TimeSpan t = new TimeSpan(0);
             string result = LogFormatter.FormatTimeSpan(t);
-            Assertion.AssertEquals("00:00:00", result);            
+            Assertion.AssertEquals("00:00:00", result);
         }
 
         [Test]
diff --git a/src/Deprecated/Engine.UnitTests/LoggerDescription_Tests.cs b/src/Deprecated/Engine.UnitTests/LoggerDescription_Tests.cs
index 9b5fc6a0ed8..6e19d450bc8 100644
--- a/src/Deprecated/Engine.UnitTests/LoggerDescription_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/LoggerDescription_Tests.cs
@@ -22,7 +22,7 @@ public class LoggerDescription_Tests
         [Test]
         public void LoggerDescriptionCustomSerialization()
         {
-  
+
             string className = "Class";
             string loggerAssemblyName = "Class";
             string loggerFileAssembly = null;
diff --git a/src/Deprecated/Engine.UnitTests/LoggerException_Tests.cs b/src/Deprecated/Engine.UnitTests/LoggerException_Tests.cs
index 0dd9d40ee95..d8c89af6e3f 100644
--- a/src/Deprecated/Engine.UnitTests/LoggerException_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/LoggerException_Tests.cs
@@ -29,10 +29,10 @@ public class InternalLoggerExceptionTests
         [Test]
         public void SerializeDeserialize()
         {
-            InternalLoggerException e = new InternalLoggerException("message", 
-                new Exception("innerException"), 
-                new BuildStartedEventArgs("evMessage", "evHelpKeyword"), 
-                "errorCode", 
+            InternalLoggerException e = new InternalLoggerException("message",
+                new Exception("innerException"),
+                new BuildStartedEventArgs("evMessage", "evHelpKeyword"),
+                "errorCode",
                 "helpKeyword",
                 false);
 
diff --git a/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs b/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
index 5338d973fe7..29fffbb8319 100644
--- a/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
@@ -18,7 +18,7 @@
 using System.Threading;
 
 namespace Microsoft.Build.UnitTests
-{  
+{
     [TestFixture]
     public class Lookup_Tests
     {
@@ -99,13 +99,13 @@ public void AddsAreCombinedWithPopulates()
             // Start a target
             lookup.EnterScope();
 
-            // We see the one item 
+            // We see the one item
             Assertion.AssertEquals("a1", lookup.GetItems("i1")[0].FinalItemSpec);
 
             // One item in the project
             Assertion.AssertEquals("a1", group1[0].FinalItemSpec);
             Assertion.AssertEquals(1, group1.Count);
-            
+
             // Start a task (eg) and add a new item
             lookup.EnterScope();
             lookup.AddNewItem(new BuildItem("i1", "a2"));
@@ -120,7 +120,7 @@ public void AddsAreCombinedWithPopulates()
 
             // Finish the task
             lookup.LeaveScope();
-          
+
             // We still see two items
             Assertion.AssertEquals("a1", lookup.GetItems("i1")[0].FinalItemSpec);
             Assertion.AssertEquals("a2", lookup.GetItems("i1")[1].FinalItemSpec);
@@ -196,13 +196,13 @@ public void Removes()
 
 // These tests used to have an #if DEBUG around them, because the method they
 // are testing only gets called in chk builds; they have been removed
-// entirely due to BVT bug 527712:  Main is attempting to run chk unit tests 
+// entirely due to BVT bug 527712:  Main is attempting to run chk unit tests
 // against ret bits.  Please only uncomment these tests if you have verified
 // that that scenario works.
-#if NULL    
+#if NULL
         /// <summary>
         /// Lookup class should never be asked to add an item that was already removed;
-        /// this is not something that is possible through a project file: all adds create 
+        /// this is not something that is possible through a project file: all adds create
         /// brand new items.
         /// </summary>
         [Test]
@@ -406,7 +406,7 @@ public void ModifyItemModifiedInPreviousScope()
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -446,7 +446,7 @@ public void ModifyItemTwiceInSameScope1()
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -511,7 +511,7 @@ public void ModifyItemTwiceInSameScope2()
             Assertion.AssertEquals("n2", foundGroup[0].GetMetadata("n"));
             Assertion.AssertEquals("o1", foundGroup[0].GetMetadata("o"));
 
-            // Make a modification to the item to be n=n3 
+            // Make a modification to the item to be n=n3
             newMetadata = new Dictionary<string, string>();
             newMetadata.Add("n", "n3");
             lookup.ModifyItems("i1", group, newMetadata);
@@ -604,7 +604,7 @@ public void ModifyItemPreviouslyModifiedAndGottenThroughGetItem()
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -651,7 +651,7 @@ public void ModifyItemPreviouslyModifiedAndGottenThroughGetItem()
         [Test]
         public void ModifyItemInProjectPreviouslyModifiedAndGottenThroughGetItem()
         {
-            // Create some project state with an item with m=m1 and n=n1 
+            // Create some project state with an item with m=m1 and n=n1
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
@@ -708,7 +708,7 @@ public void RemoveItemPreviouslyModifiedAndGottenThroughGetItem()
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             Lookup lookup = LookupHelpers.CreateLookup(table1);
 
-            // Add an item with m=m1 and n=n1 
+            // Add an item with m=m1 and n=n1
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
             lookup.PopulateWithItem(item1);
@@ -741,7 +741,7 @@ public void RemoveItemPreviouslyModifiedAndGottenThroughGetItem()
         [Test]
         public void RemoveItemFromProjectPreviouslyModifiedAndGottenThroughGetItem()
         {
-            // Create some project state with an item with m=m1 and n=n1 
+            // Create some project state with an item with m=m1 and n=n1
             Hashtable table1 = new Hashtable(StringComparer.OrdinalIgnoreCase);
             BuildItem item1 = new BuildItem("i1", "a2");
             item1.SetMetadata("m", "m1");
@@ -836,7 +836,7 @@ public void ModifiedProperty()
 
             lookup.EnterScope();
 
-            // Change the value again in the new scope 
+            // Change the value again in the new scope
             lookup.SetProperty(new BuildProperty("p1", "v3", PropertyType.OutputProperty));
 
             // Lookup is updated, but not the original item group
@@ -845,14 +845,14 @@ public void ModifiedProperty()
 
             lookup.EnterScope();
 
-            // Change the value again in the new scope 
+            // Change the value again in the new scope
             lookup.SetProperty(new BuildProperty("p1", "v4", PropertyType.OutputProperty));
 
             Assertion.AssertEquals("v4", lookup.GetProperty("p1").FinalValue);
 
             lookup.LeaveScope();
 
-            Assertion.AssertEquals("v4", lookup.GetProperty("p1").FinalValue);              
+            Assertion.AssertEquals("v4", lookup.GetProperty("p1").FinalValue);
 
             // Leave to the outer scope
             lookup.LeaveScope();
@@ -1030,6 +1030,6 @@ internal static ItemDefinitionLibrary CreateEmptyEvaluatedItemDefinitionLibrary(
             ItemDefinitionLibrary itemDefinitionLibrary = new ItemDefinitionLibrary(new Project());
             itemDefinitionLibrary.Evaluate(new BuildPropertyGroup());
             return itemDefinitionLibrary;
-        }    
+        }
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/MockNode.cs b/src/Deprecated/Engine.UnitTests/MockNode.cs
index e15b49678e1..4fcc7f66145 100644
--- a/src/Deprecated/Engine.UnitTests/MockNode.cs
+++ b/src/Deprecated/Engine.UnitTests/MockNode.cs
@@ -60,7 +60,7 @@ long executionTime
             postTaskOutputsInputs.Add("taskExecutedSuccessfully", taskExecutedSuccessfully);
             postTaskOutputsInputs.Add("thrownException", thrownException);
         }
- 
+
         /// <summary>
         /// Override to BuildProject file to return true so we can test that
         /// </summary>
@@ -89,6 +89,6 @@ override internal void GetLineColumnOfXmlNode(int nodeProxyId, out int lineNumbe
             lineNumber = 0;
             columnNumber = 0;
         }
-        
+
     }
 }
diff --git a/src/Deprecated/Engine.UnitTests/MockProjectStartedLogger.cs b/src/Deprecated/Engine.UnitTests/MockProjectStartedLogger.cs
index 39b945d3b31..8589999d8ce 100644
--- a/src/Deprecated/Engine.UnitTests/MockProjectStartedLogger.cs
+++ b/src/Deprecated/Engine.UnitTests/MockProjectStartedLogger.cs
@@ -23,12 +23,12 @@ class MockProjectStartedLogger : ILogger
         /// </summary>
         public LoggerVerbosity Verbosity
         {
-            get 
-            { 
-                return LoggerVerbosity.Diagnostic; 
+            get
+            {
+                return LoggerVerbosity.Diagnostic;
             }
-            set 
-            { 
+            set
+            {
             }
         }
 
@@ -37,15 +37,15 @@ public LoggerVerbosity Verbosity
         /// </summary>
         public string Parameters
         {
-            get 
-            { 
-                return null; 
+            get
+            {
+                return null;
             }
             set
             {
             }
         }
-        
+
         /// <summary>
         /// Subscribing to the events
         /// </summary>
@@ -56,7 +56,7 @@ public void Initialize(IEventSource eventSource)
         }
 
         /// <summary>
-        /// Handler for the ProjectStarted event. 
+        /// Handler for the ProjectStarted event.
         /// </summary>
         /// <param name="sender"></param>
         /// <param name="e"></param>
diff --git a/src/Deprecated/Engine.UnitTests/MockTask.cs b/src/Deprecated/Engine.UnitTests/MockTask.cs
index e884fd59f52..bded93b80f2 100644
--- a/src/Deprecated/Engine.UnitTests/MockTask.cs
+++ b/src/Deprecated/Engine.UnitTests/MockTask.cs
@@ -236,7 +236,7 @@ public ArrayList MyArrayListOutputParam
         }
 
         /// <summary>
-        /// Null ITaskItem[] output parameter. 
+        /// Null ITaskItem[] output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -250,7 +250,7 @@ public ITaskItem[] NullITaskItemArrayOutputParameter
         }
 
         /// <summary>
-        /// Empty string output parameter. 
+        /// Empty string output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -263,7 +263,7 @@ public string EmptyStringOutputParameter
         }
 
         /// <summary>
-        /// Empty string output parameter. 
+        /// Empty string output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -277,7 +277,7 @@ public string[] EmptyStringInStringArrayOutputParameter
         }
 
         /// <summary>
-        /// ITaskItem output parameter. 
+        /// ITaskItem output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -291,7 +291,7 @@ public ITaskItem ITaskItemOutputParameter
         }
 
         /// <summary>
-        /// string output parameter. 
+        /// string output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -304,7 +304,7 @@ public string StringOutputParameter
         }
 
         /// <summary>
-        /// string array output parameter. 
+        /// string array output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -317,7 +317,7 @@ public string[] StringArrayOutputParameter
         }
 
         /// <summary>
-        /// int output parameter. 
+        /// int output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -330,7 +330,7 @@ public int IntOutputParameter
         }
 
         /// <summary>
-        /// int array output parameter. 
+        /// int array output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -343,7 +343,7 @@ public int[] IntArrayOutputParameter
         }
 
         /// <summary>
-        /// object array output parameter. 
+        /// object array output parameter.
         /// </summary>
         /// <owner>danmose</owner>
         [Output]
@@ -403,7 +403,7 @@ public TaskItem[] TaskItemArrayOutputParameter
             }
         }
     }
-    
+
     /// <summary>
     /// A simple mock task for use with Unit Testing.
     /// </summary>
@@ -429,7 +429,7 @@ public IBuildEngine BuildEngine
         {
             get {return this.e;}
             set {this.e = value;}
-        }        
+        }
 
         /// <summary>
         /// Access the host object.
@@ -439,7 +439,7 @@ public ITaskHost HostObject
         {
             get {return null;}
             set {}
-        }        
+        }
 
         /// <summary>
         /// Main Execute method of the task does nothing.
diff --git a/src/Deprecated/Engine.UnitTests/NodeLoggingEventTests.cs b/src/Deprecated/Engine.UnitTests/NodeLoggingEventTests.cs
index bf0059aecfd..06abc5cd23d 100644
--- a/src/Deprecated/Engine.UnitTests/NodeLoggingEventTests.cs
+++ b/src/Deprecated/Engine.UnitTests/NodeLoggingEventTests.cs
@@ -205,7 +205,7 @@ public void TestLoggingEventCustomerSerialization()
             nodeLoggingEvent = new NodeLoggingEvent(null);
             nodeLoggingEvent.CreateFromStream(reader, loggingTypeCacheReads);
             Assert.IsTrue(nodeLoggingEvent.BuildEvent.GetType() ==typeof( TaskCommandLineEventArgs));
-            
+
             long streamReadEndPosition = stream.Position;
             Assert.AreEqual(streamWriteEndPosition, streamReadEndPosition, "Expected Read and Write Positions to match");
         }
diff --git a/src/Deprecated/Engine.UnitTests/NodeManager_Tests.cs b/src/Deprecated/Engine.UnitTests/NodeManager_Tests.cs
index ffac549db5f..ba016d9b45b 100644
--- a/src/Deprecated/Engine.UnitTests/NodeManager_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/NodeManager_Tests.cs
@@ -67,10 +67,10 @@ public void RegisterNullNodeProviders()
         [Test]
         public void RegisterNodeProviders()
         {
-                      
+
             MockNodeProvider ProviderOneNode = new MockNodeProvider();
             ProviderOneNode.NodeDescriptions.Add(new MockNodeDescription("Provider One Node One"));
-           
+
             MockNodeProvider ProviderThreeNodes = new MockNodeProvider();
             ProviderThreeNodes.NodeDescriptions.Add(new MockNodeDescription("Provider Two Node One"));
             ProviderThreeNodes.NodeDescriptions.Add(new MockNodeDescription("Provider Two Node Two"));
@@ -205,7 +205,7 @@ public void TestPostBuildRequestToNode()
             nodeManager.PostBuildRequestToNode(2, new BuildRequest(2, "ProjectFile", null, new BuildPropertyGroup(), null, 2, false, false));
             nodeManager.PostBuildRequestToNode(3, new BuildRequest(3, "ProjectFile", null, new BuildPropertyGroup(), null, 3, false, false));
             nodeManager.PostBuildRequestToNode(4, new BuildRequest(4, "ProjectFile", null, new BuildPropertyGroup(), null, 4, false, false));
-            
+
             Assert.IsTrue(ProviderThreeNodes.buildRequestsSubmittedToProvider.Count == 3, "Expected there to be three build results in the mock provider");
             Assert.IsTrue(ProviderThreeNodes.buildRequestsSubmittedToProvider[0].HandleId == 1, "Expected first NodeProxyId to be 1");
             Assert.IsTrue(ProviderThreeNodes.buildRequestsSubmittedToProvider[1].HandleId == 2, "Expected second NodeProxyId to be 2");
@@ -295,7 +295,7 @@ void INodeProvider.RegisterNodeLogger(LoggerDescription description )
             if ( description == null )
             {
                 throw new ArgumentException("Logger description should be non-null");
-            } 
+            }
         }
 
         void INodeProvider.PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest)
@@ -332,7 +332,7 @@ void INodeProvider.ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
 
         public void UpdateSettings(bool enableOutOfProcLogging, bool enableOnlyLogCriticalEvents, bool useBreadthFirstTraversalSetting)
         {
-          
+
         }
 
         #endregion
@@ -342,7 +342,7 @@ public void UpdateSettings(bool enableOutOfProcLogging, bool enableOnlyLogCritic
 
         public void AssignNodeIdentifiers(int[] nodeIdentifiers)
         {
-           
+
         }
 
         public void RequestNodeStatus(int nodeIndex, int requestId)
diff --git a/src/Deprecated/Engine.UnitTests/NodeRequestMapping_Tests.cs b/src/Deprecated/Engine.UnitTests/NodeRequestMapping_Tests.cs
index 917333040ba..75006eafe8d 100644
--- a/src/Deprecated/Engine.UnitTests/NodeRequestMapping_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/NodeRequestMapping_Tests.cs
@@ -36,7 +36,7 @@ public class NodeRequestMapping_Tests
         public void Initialize()
         {
             // Create some items and place them in a dictionary
-            // Add some include information so that when we check the final 
+            // Add some include information so that when we check the final
             // item spec we can verify that the item was recreated properly
             BuildItem buildItem1 = new BuildItem("BuildItem1", "Item1");
             buildItem1.Include = "TestInclude1";
@@ -70,7 +70,7 @@ public void AddResultToCache()
             Assert.AreEqual(1,requestMapping.HandleId,"Expected NodeProxyId to be 1");
             Assert.AreEqual(1,requestMapping.RequestId,"Expected RequestId to be 1");
             requestMapping.AddResultToCache(resultWithOutputs);
-            Assert.IsTrue(resultWithOutputs.EvaluationResult == ((BuildResultCacheEntry)cacheScope.GetCacheEntry("TaskItems")).BuildResult, 
+            Assert.IsTrue(resultWithOutputs.EvaluationResult == ((BuildResultCacheEntry)cacheScope.GetCacheEntry("TaskItems")).BuildResult,
                 "Expected EvaluationResult to be the same after it was retrieved from the cache");
             Assert.IsTrue(((BuildItem[])resultWithOutputs.OutputsByTarget["TaskItems"])[0].Include == ((BuildResultCacheEntry)cacheScope.GetCacheEntry("TaskItems")).BuildItems[0].Include,
                 "Expected EvaluationResult to be the same after it was retrieved from the cache");
@@ -89,7 +89,7 @@ public void AddResultToCacheUncacheableResult()
             Assert.AreEqual(1, requestMapping.HandleId, "Expected NodeProxyId to be 1");
             Assert.AreEqual(1, requestMapping.RequestId, "Expected RequestId to be 1");
             requestMapping.AddResultToCache(uncacheableResult);
-            Assert.IsNull(cacheScope.GetCacheEntry("TaskItems"), 
+            Assert.IsNull(cacheScope.GetCacheEntry("TaskItems"),
                 "Expected null to be retrieved from the cache as the targetNamesList should not have been added");
         }
 
@@ -124,7 +124,7 @@ public void AddResultToPassInNullCacheScope()
         } */
 
         /// <summary>
-        /// Make sure that the correct InternalErrorException exception is thrown if a null build result is 
+        /// Make sure that the correct InternalErrorException exception is thrown if a null build result is
         /// attempted to be cached. This test is
         /// here to describe the behavior but it is not run because it causes a pop up.
         /// </summary>
diff --git a/src/Deprecated/Engine.UnitTests/OnError_Tests.cs b/src/Deprecated/Engine.UnitTests/OnError_Tests.cs
index c7ae69c3c7d..8bbe6704f56 100644
--- a/src/Deprecated/Engine.UnitTests/OnError_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/OnError_Tests.cs
@@ -35,7 +35,7 @@ public void Basic()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -90,9 +90,9 @@ public void FailingTaskStillPublishesOutputs()
                     </root>");
 
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                         <Target Name='Build'>
-                            
+
                             <GenerateResource
                                 Sources='" + resx + @"'
                                 ExecuteAsTool='false'
@@ -100,11 +100,11 @@ public void FailingTaskStillPublishesOutputs()
                                     <Output TaskParameter='FilesWritten' ItemName='FilesWrittenItem'/>
                                     <Output TaskParameter='FilesWritten' PropertyName='FilesWrittenProperty'/>
                             </GenerateResource>
-                                               
+
                             <OnError ExecuteTargets='ErrorTarget'/>
                         </Target>
 
-                        <Target Name='ErrorTarget'>    
+                        <Target Name='ErrorTarget'>
                             <Message Text='[@(fileswrittenitem)]'/>
                             <Message Text='[$(fileswrittenproperty)]'/>
                         </Target>
@@ -146,16 +146,16 @@ public void OnErrorSeesPropertiesAndItemsFromFirstTarget()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                    <Target Name='Build'>
                       <!-- Create a bunch of items and properties -->
                       <CreateItem Include='a1'>
                         <Output ItemName='i1' TaskParameter='Include'/>
-                      </CreateItem> 
+                      </CreateItem>
                       <ItemGroup>
                         <i1 Include='a2'/>
-                      </ItemGroup> 
+                      </ItemGroup>
                       <CreateProperty Value='v1'>
                         <Output PropertyName='p1' TaskParameter='Value'/>
                       </CreateProperty>
@@ -193,7 +193,7 @@ public void TwoExecuteTargets()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -227,7 +227,7 @@ public void TwoOnErrorClauses()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -263,7 +263,7 @@ public void DependentTarget()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp' DependsOnTargets='CleanUp2'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -298,7 +298,7 @@ public void ErrorInChildIsHandledInParent()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -332,7 +332,7 @@ public void NonExistentExecuteTarget()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='Build'>
                       <Error Text='This is an error.'/>
                       <OnError ExecuteTargets='CleanUp'/>
@@ -360,7 +360,7 @@ public void TrueCondition()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -390,7 +390,7 @@ public void FalseCondition()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp'>
                       <Message Text='CleanUp-was-called.'/>
                    </Target>
@@ -421,7 +421,7 @@ public void PropertiesInExecuteTargets()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <PropertyGroup>
                      <Part1>Clean</Part1>
                      <Part2>Up</Part2>
@@ -456,7 +456,7 @@ public void ErrorTargetsContinueAfterErrorsInErrorHandler()
             MockLogger l = new MockLogger();
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                    <Target Name='CleanUp1'>
                       <Message Text='CleanUp1-was-called.'/>
                       <Error Text='Error in CleanUp1.'/>
diff --git a/src/Deprecated/Engine.UnitTests/Parser_Tests.cs b/src/Deprecated/Engine.UnitTests/Parser_Tests.cs
index b37e54e36e6..3c355afad23 100644
--- a/src/Deprecated/Engine.UnitTests/Parser_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Parser_Tests.cs
@@ -133,13 +133,13 @@ public void FunctionCallParseTest()
             Parser p = new Parser();
             GenericExpressionNode tree;
             tree = p.Parse("SimpleFunctionCall()", null, ParserOptions.AllowAll);
-            
+
             tree = p.Parse("SimpleFunctionCall( 1234 )", null, ParserOptions.AllowAll);
             tree = p.Parse("SimpleFunctionCall( true )", null, ParserOptions.AllowAll);
             tree = p.Parse("SimpleFunctionCall( $(property) )", null, ParserOptions.AllowAll);
-            
+
             tree = p.Parse("SimpleFunctionCall( $(property), 1234, abcd, 'abcd efgh' )", null, ParserOptions.AllowAll);
-            
+
         }
 
         /// <owner>DavidLe</owner>
@@ -450,7 +450,7 @@ public void VerifyWarningForOrder()
                 ", new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath));
 
             // Make sure the log contains the correct strings.
-            Assertion.Assert("Need to warn for this expression - (a) == 1 and $(b) == 2 or $(c) == 3.", 
+            Assertion.Assert("Need to warn for this expression - (a) == 1 and $(b) == 2 or $(c) == 3.",
                 ml.FullLog.Contains("MSB4130:"));
 
             ml = ObjectModelHelpers.BuildProjectExpectSuccess(String.Format(@"
diff --git a/src/Deprecated/Engine.UnitTests/ProjectManager_Tests.cs b/src/Deprecated/Engine.UnitTests/ProjectManager_Tests.cs
index 41d99de4a84..fd25282c8a6 100644
--- a/src/Deprecated/Engine.UnitTests/ProjectManager_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ProjectManager_Tests.cs
@@ -24,7 +24,7 @@ namespace Microsoft.Build.UnitTests
     public class ProjectManager_Tests
     {
         /// <summary>
-        /// Add a project to the ProjectManager, and try to get it back out using the 
+        /// Add a project to the ProjectManager, and try to get it back out using the
         /// correct set of search criteria.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -37,7 +37,7 @@ public void SimpleAddAndRetrieveProject()
             // Instantiate new project manager.
             ProjectManager projectManager = new ProjectManager();
 
-            // Set up variables that represent the information we would be getting from 
+            // Set up variables that represent the information we would be getting from
             // the "MSBuild" task.
             string fullPath = @"c:\rajeev\temp\myapp.proj";
             BuildPropertyGroup globalProperties = new BuildPropertyGroup();
@@ -56,7 +56,7 @@ public void SimpleAddAndRetrieveProject()
             // and make sure we get back the same project we added.
             Assertion.AssertEquals(project1, projectManager.GetProject(fullPath, globalProperties, null));
         }
-        
+
         /// <summary>
         /// Verify project manager does not insert duplicates into project table.
         /// </summary>
@@ -128,7 +128,7 @@ public void TestForDuplicatesInProjectEntryTable()
         }
 
         /// <summary>
-        /// Add a project to the ProjectManager, and try to get it back out using the 
+        /// Add a project to the ProjectManager, and try to get it back out using the
         /// wrong set of search criteria (different set of global properties).
         /// </summary>
         /// <owner>RGoel</owner>
@@ -141,7 +141,7 @@ public void SimpleAddAndRetrieveProjectWithDifferentGlobals()
             // Instantiate new project manager.
             ProjectManager projectManager = new ProjectManager();
 
-            // Set up variables that represent the information we would be getting from 
+            // Set up variables that represent the information we would be getting from
             // the "MSBuild" task.
             string fullPath = @"c:\rajeev\temp\myapp.proj";
             BuildPropertyGroup globalProperties = new BuildPropertyGroup();
@@ -163,7 +163,7 @@ public void SimpleAddAndRetrieveProjectWithDifferentGlobals()
         }
 
         /// <summary>
-        /// Add a project to the ProjectManager, and try to get it back out using the 
+        /// Add a project to the ProjectManager, and try to get it back out using the
         /// wrong set of search criteria (different full path).
         /// </summary>
         /// <owner>RGoel</owner>
@@ -176,7 +176,7 @@ public void SimpleAddAndRetrieveProjectWithDifferentFullPath()
             // Instantiate new project manager.
             ProjectManager projectManager = new ProjectManager();
 
-            // Set up variables that represent the information we would be getting from 
+            // Set up variables that represent the information we would be getting from
             // the "MSBuild" task.
             BuildPropertyGroup globalProperties = new BuildPropertyGroup();
             globalProperties.SetProperty("Configuration", "Release");
diff --git a/src/Deprecated/Engine.UnitTests/PropertyGroup_Tests.cs b/src/Deprecated/Engine.UnitTests/PropertyGroup_Tests.cs
index a44c713c9b8..e843e109e04 100644
--- a/src/Deprecated/Engine.UnitTests/PropertyGroup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/PropertyGroup_Tests.cs
@@ -421,7 +421,7 @@ public void RemovePropertyFromPropertyGroupThatIsntItsParent()
                         break;
                     }
                 }
-                
+
                 //this should throw because the property comes from another property group
                 second.RemoveProperty(property);
             }
diff --git a/src/Deprecated/Engine.UnitTests/Scanner_Tests.cs b/src/Deprecated/Engine.UnitTests/Scanner_Tests.cs
index d1a2e0bf821..10edea8a5db 100644
--- a/src/Deprecated/Engine.UnitTests/Scanner_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Scanner_Tests.cs
@@ -41,9 +41,9 @@ public void ErrorPosition()
                 { " $(",                    "2",    "AllowAll"},              // Position of $
                 { " $",                     "2",    "AllowAll"},              // Position of $
                 { " @(foo)",                "2",    "AllowProperties"},       // Position of @
-                { " '@(foo)'",              "3",    "AllowProperties"},       // Position of @    
+                { " '@(foo)'",              "3",    "AllowProperties"},       // Position of @
                 /* test escaped chars: message shows them escaped so count should include them */
-                { "'%24%28x' == '%24(x''",   "21",  "AllowAll"}               // Position of extra quote 
+                { "'%24%28x' == '%24(x''",   "21",  "AllowAll"}               // Position of extra quote
             };
 
             // Some errors are caught by the Parser, not merely by the Lexer/Scanner. So we have to do a full Parse,
@@ -65,7 +65,7 @@ public void ErrorPosition()
                 }
             }
         }
- 
+
         /// <summary>
         /// Advance to the point of the lexer error. If the error is only caught by the parser, this isn't useful.
         /// </summary>
@@ -180,7 +180,7 @@ public void IllFormedQuotedString()
         public void NumericSingleTokenTests()
         {
             Scanner lexer;
-            
+
             lexer = new Scanner("1234", ParserOptions.AllowAll);
             Assertion.Assert(lexer.Advance());
             Assertion.AssertEquals(lexer.IsNext(Token.TokenType.Numeric), true);
diff --git a/src/Deprecated/Engine.UnitTests/SolutionWrapperProject_Tests.cs b/src/Deprecated/Engine.UnitTests/SolutionWrapperProject_Tests.cs
index 32930c3e3fb..8dcd83f8d6e 100644
--- a/src/Deprecated/Engine.UnitTests/SolutionWrapperProject_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/SolutionWrapperProject_Tests.cs
@@ -110,7 +110,7 @@ public void EmitToolsVersionAttributeToInMemoryProject9()
             }
             else
             {
-                Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed."); 
+                Assert.Ignore(".NET Framework 3.5 is required for this test, but is not installed.");
             }
         }
 
@@ -244,7 +244,7 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
             SolutionParser solution = SolutionParser_Tests.ParseSolutionHelper(solutionFileContents);
             BuildEventContext buildEventContext = new BuildEventContext(0, 0, 0, 0);
             SolutionWrapperProject.Generate(solution, project, "3.5", buildEventContext);
-            
+
             foreach (Target target in project.Targets)
             {
                 foreach (XmlNode childNode in target.TargetElement)
@@ -257,7 +257,7 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
 
                         Assertion.Assert(0 == String.Compare(
                                                             toolsVersionAttribute.Value,
-                                                            "$(ProjectToolsVersion)", 
+                                                            "$(ProjectToolsVersion)",
                                                             StringComparison.OrdinalIgnoreCase)
                                             );
                     }
@@ -300,15 +300,15 @@ public void ToolsVersionOverrideThrowsOnInvalidToolsVersion()
 
             try
             {
-                // We want to avoid using the solution cache -- it could lead to circumstances where detritus left 
-                // on the disk leads us down paths we didn't mean to go.  
+                // We want to avoid using the solution cache -- it could lead to circumstances where detritus left
+                // on the disk leads us down paths we didn't mean to go.
                 Environment.SetEnvironmentVariable("MSBuildUseNoSolutionCache", "1");
 
                 // We're not passing in a /tv:xx switch, so the solution project will have tools version 3.5
                 Project project = new Project();
                 SolutionParser solution = SolutionParser_Tests.ParseSolutionHelper(solutionFileContents);
                 BuildEventContext buildEventContext = new BuildEventContext(0, 0, 0, 0);
-            
+
                 SolutionWrapperProject.Generate(solution, project, "invalid", buildEventContext);
 
                 Assertion.AssertEquals("4.0", project.DefaultToolsVersion);
@@ -318,7 +318,7 @@ public void ToolsVersionOverrideThrowsOnInvalidToolsVersion()
                 Environment.SetEnvironmentVariable("MSBuildUseNoSolutionCache", oldUseNoCacheValue);
             }
         }
-            
+
         /// <summary>
         /// Test the SolutionWrapperProject.AddPropertyGroupForSolutionConfiguration method
         /// </summary>
@@ -383,7 +383,7 @@ public void TestDisambiguateProjectTargetName()
             // NOTE: ValidateSolutionConfiguration and ValidateToolsVersions are always added, so we need to add two extras
             Assertion.AssertEquals(ProjectInSolution.projectNamesToDisambiguate.Length + 2, countOfStandardTargets);
         }
-        
+
         /// <summary>
         /// Tests the algorithm for choosing default configuration/platform values for solutions
         /// </summary>
@@ -410,7 +410,7 @@ public void TestConfigurationPlatformDefaults1()
 
             Project msbuildProject = new Project();
             SolutionWrapperProject.Generate(solution, msbuildProject, null, null);
-            
+
             // Default for Configuration is "Debug", if present
             Assertion.AssertEquals("Debug", msbuildProject.GetEvaluatedProperty("Configuration"));
 
@@ -482,7 +482,7 @@ public void DefaultTargetFrameworkVersion()
 
             // v3.5 by default
             Assertion.AssertEquals("v4.0", msbuildProject.EvaluatedProperties["TargetFrameworkVersion"].Value);
-            // may be user defined 
+            // may be user defined
             msbuildProject.SetProperty("TargetFrameworkVersion", "userdefined");
             Assertion.AssertEquals("userdefined", msbuildProject.EvaluatedProperties["TargetFrameworkVersion"].Value);
             // v2.0 if MSBuildToolsVersion is 2.0
@@ -541,7 +541,7 @@ public void TestTargetFrameworkPaths2()
             msbuildProject.SetProperty("TargetFrameworkVersion", "v3.5");
             bool success = msbuildProject.Build("GetFrameworkPathAndRedistList");
             Assertion.AssertEquals(true, success);
-            
+
             AssertProjectContainsItem(msbuildProject, "_CombinedTargetFrameworkDirectoriesItem", FrameworkLocationHelper.PathToDotNetFrameworkV20);
             if (FrameworkLocationHelper.PathToDotNetFrameworkV35 != null && FrameworkLocationHelper.PathToDotNetFrameworkV30 != null)
             {
@@ -620,7 +620,7 @@ private static Project CreateVenusSolutionProject(BuildPropertyGroup globalPrope
             SolutionWrapperProject.Generate(solution, msbuildProject, toolsVersion, null);
             return msbuildProject;
         }
-  
+
         private void AssertProjectContainsItem(Project msbuildProject, string itemName, string itemSpec)
         {
             BuildItemGroup itemGroup = (BuildItemGroup)msbuildProject.EvaluatedItemsByName[itemName];
@@ -718,7 +718,7 @@ public void SolutionParserShouldNotIncreaseNumberOfProjectsLoadedByHost()
             Engine engine = new Engine();
             Project project = new Project(engine, null);
 
-            // This project considers itself loaded-by-host. Setting a file name on it, causes it to 
+            // This project considers itself loaded-by-host. Setting a file name on it, causes it to
             // ensure the engine believes it is loaded-by-host...
             project.FullFileName = "my project";
 
diff --git a/src/Deprecated/Engine.UnitTests/TargetCollection_Tests.cs b/src/Deprecated/Engine.UnitTests/TargetCollection_Tests.cs
index fa53fd1ac3e..86236768ef1 100644
--- a/src/Deprecated/Engine.UnitTests/TargetCollection_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TargetCollection_Tests.cs
@@ -51,7 +51,7 @@ public void Cleanup()
 
         /// <summary>
         /// Un-registers the existing logger and registers a new copy.
-        /// We will use this when we do multiple builds so that we can safely 
+        /// We will use this when we do multiple builds so that we can safely
         /// assert on log messages for that particular build.
         /// </summary>
         private void ResetLogger()
@@ -148,7 +148,7 @@ public void SetInputsOutputsIncremental()
                 Project p = ObjectModelHelpers.CreateInMemoryProject(@"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <Target Name=`t` Inputs=`" + newFile + "` Outputs=`" + oldFile + @"`>
-                    <Message Text=`building target !!`/>                  
+                    <Message Text=`building target !!`/>
                 </Target>
                 </Project>
             ", logger);
@@ -167,7 +167,7 @@ public void SetInputsOutputsIncremental()
                 p.Build(new string[] { "t" });
 
                 logger.AssertLogDoesntContain("building target !!");
-                
+
 
             }
             finally
@@ -234,7 +234,7 @@ public void GetValidTargetInputsAndOutputs()
         {
             string targetOutputsString = "target_output";
             string targetInputsString = "target_input";
-            
+
             Target myTarget = myProject.Targets.AddNewTarget("BuildMe");
             myTarget.Inputs = targetInputsString;
             myTarget.Outputs = targetOutputsString;
@@ -282,11 +282,11 @@ public void SetTargetInputsAndOutputsOnAnAlreadyBuiltTarget()
 
             ITaskItem[] outputItems = BuildAndGatherOutputs("BuildMe");
 
-            
+
             Assertion.Assert(myLogger.FullLog.Contains("afoo"));
             Assertion.Assert(myLogger.FullLog.Contains("bfoo"));
             Assertion.AssertEquals(outputItems[0].ToString(), "1");
-            Assertion.AssertEquals(outputItems[1].ToString(), "2"); 
+            Assertion.AssertEquals(outputItems[1].ToString(), "2");
         }
 
         /// <summary>
@@ -340,7 +340,7 @@ public void ChangingAnExistingTargetInputsAndOutputs()
 
             ITaskItem[] outputItems1 = BuildAndGatherOutputs("BuildMe");
 
-            
+
             Assertion.Assert(myLogger.FullLog.Contains("a2foo"));
             Assertion.Assert(myLogger.FullLog.Contains("b2foo"));
             Assertion.AssertEquals(outputItems1[0].ToString(), "1-1");
@@ -396,7 +396,7 @@ public void ChangingAnExistingTargetInputs()
 
             ITaskItem[] outputItems1 = BuildAndGatherOutputs("BuildMe");
 
-            
+
             Assertion.Assert(myLogger.FullLog.Contains("a;bfoo"));
             Assertion.Assert(myLogger.FullLog.Contains("a2foo"));
             Assertion.Assert(myLogger.FullLog.Contains("b2foo"));
@@ -592,7 +592,7 @@ public void AddNewTargetWithOutputsString()
             Assertion.Assert(myLogger.FullLog.Contains("Exec"));
             Assertion.Assert(myLogger.FullLog.Contains("a;bfoo"));
             Assertion.AssertEquals(outputItems[0].ToString(), "1");
-            Assertion.AssertEquals(outputItems[1].ToString(), "2"); 
+            Assertion.AssertEquals(outputItems[1].ToString(), "2");
         }
 
         /// <summary>
@@ -876,7 +876,7 @@ public void TransformInTargetConditionLegal()
                     <x Include=`a.ext;b.ext`/>
                   </ItemGroup>
                   <Target Name=`t` Condition=`@(x -> '%(filename)')=='a;b'`>
-                    <Message Text=`#@(x)#`/>                  
+                    <Message Text=`#@(x)#`/>
                 </Target>
                 </Project>
             ", logger);
diff --git a/src/Deprecated/Engine.UnitTests/TargetDependencyAnalyzer_Tests.cs b/src/Deprecated/Engine.UnitTests/TargetDependencyAnalyzer_Tests.cs
index a7ebf203b7f..d73c3addeed 100644
--- a/src/Deprecated/Engine.UnitTests/TargetDependencyAnalyzer_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TargetDependencyAnalyzer_Tests.cs
@@ -82,7 +82,7 @@ public void EmptyItemSpecInTargetOutputs()
             ml.AssertLogDoesntContain("Running Build target");
             ml.AssertLogContains("MSB4168");
 
-            // Clear the mock logger object out so it is not reused            
+            // Clear the mock logger object out so it is not reused
             ml = null;
 
             ml = ObjectModelHelpers.BuildProjectExpectFailure(@"
@@ -115,11 +115,11 @@ public void EmptyItemSpecInTargetOutputs()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items);c.cs"
         ///         Outputs="@(Items->'%(Filename).dll')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs], and only b.cs is out of date w/r/t its
         /// correlated output b.dll, then we should only build "b" incrementally.
         /// </summary>
@@ -128,8 +128,8 @@ public void MetaInputAndInputItemThatCorrelatesWithOutputItem()
         {
             string inputs = "@(Items);c.cs";
             string outputs = "@(Items->'%(Filename).dll')";
-            FileWriteInfo[] filesToAnalyze = new FileWriteInfo[] 
-                                             { 
+            FileWriteInfo[] filesToAnalyze = new FileWriteInfo[]
+                                             {
                                                  new FileWriteInfo("a.cs", yesterday),
                                                  new FileWriteInfo("a.dll", today),
                                                  new FileWriteInfo("b.cs", today),
@@ -151,11 +151,11 @@ public void MetaInputAndInputItemThatCorrelatesWithOutputItem()
 
         /// <summary>
         /// Tests this case:
-        /// 
+        ///
         /// <Target Name="x"
         ///         Inputs="@(Items)"
         ///         Outputs="@(Items->'%(Filename).dll');@(Items->'%(Filename).xml')" />
-        /// 
+        ///
         /// If Items = [a.cs;b.cs;c.cs], and only b.cs is out of date w/r/t its
         /// correlated outputs (dll or xml), then we should only build "b" incrementally.
         /// </summary>
@@ -165,8 +165,8 @@ public void InputItemThatCorrelatesWithMultipleTransformOutputItems()
             string inputs = "@(Items)";
             string outputs = "@(Items->'%(Filename).dll');@(Items->'%(Filename).xml')";
 
-            FileWriteInfo[] filesToAnalyze = new FileWriteInfo[] 
-                                             { 
+            FileWriteInfo[] filesToAnalyze = new FileWriteInfo[]
+                                             {
                                                  new FileWriteInfo("a.cs", yesterday),
                                                  new FileWriteInfo("a.dll", today),
                                                  new FileWriteInfo("a.xml", today),
@@ -182,7 +182,7 @@ public void InputItemThatCorrelatesWithMultipleTransformOutputItems()
             items.AddNewItem("Items", "a.cs");
             items.AddNewItem("Items", "b.cs");
             items.AddNewItem("Items", "c.cs");
-            
+
             Hashtable itemsByName = new Hashtable(StringComparer.OrdinalIgnoreCase);
             itemsByName.Add("Items", items);
 
@@ -264,7 +264,7 @@ out Hashtable upToDateTargetInputs
                 // now do the dependency analysis
                 ItemBucket itemBucket = new ItemBucket(null, null, LookupHelpers.CreateLookup(itemsByName), 0);
                 TargetDependencyAnalyzer analyzer = new TargetDependencyAnalyzer(ObjectModelHelpers.TempProjectDir, p.Targets["Build"], p.ParentEngine.LoggingServices, (BuildEventContext)null);
-                
+
                 return analyzer.PerformDependencyAnalysis(itemBucket, out changedTargetInputs, out upToDateTargetInputs);
             }
             finally
@@ -287,7 +287,7 @@ public void TestIsAnyOutOfDate1()
             IsAnyOutOfDateTestHelper
                 (
                 new DateTime(2000, 1, 1), /* input1 */
-                new DateTime(2000, 1, 1), /* input2 */ 
+                new DateTime(2000, 1, 1), /* input2 */
                 new DateTime(2001, 1, 1), /* output1 */
                 new DateTime(2001, 1, 1), /* output2 */
                 false /* none out of date */
@@ -549,7 +549,7 @@ bool isUpToDate
         /// <param name="isUpToDate"></param>
         private void IsAnyOutOfDateTestHelper
             (
-            DateTime? input1Time, 
+            DateTime? input1Time,
             DateTime? input2Time,
             DateTime? output1Time,
             DateTime? output2Time,
diff --git a/src/Deprecated/Engine.UnitTests/TargetInProgressState_Tests.cs b/src/Deprecated/Engine.UnitTests/TargetInProgressState_Tests.cs
index 7208e44a525..8d0c697a940 100644
--- a/src/Deprecated/Engine.UnitTests/TargetInProgressState_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TargetInProgressState_Tests.cs
@@ -43,7 +43,7 @@ public void TargetInProgressStateCustomSerialization()
                       <Target Name='t' DependsOnTargets='Build'/>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.Targets` />
                     </Project>
-                "); 
+                ");
             EngineCallback engineCallback = new EngineCallback(engine);
             Target build = project.Targets["Build"];
             List<ProjectBuildState> waitingBuildStates = null;
@@ -60,8 +60,8 @@ public void TargetInProgressStateCustomSerialization()
             initiatingRequest.AddBlockingTarget("Build");
             BuildRequest [] outstandingBuildRequests = null;
             string projectName = "SuperTestProject";
-            
-            
+
+
 
             TargetInProgessState targetInProgress1 = new TargetInProgessState(
                                                               engineCallback,
@@ -71,7 +71,7 @@ public void TargetInProgressStateCustomSerialization()
                                                               outstandingBuildRequests,
                                                               projectName
                                                           );
-            
+
             targetInProgress1.ParentTargetsForBuildRequests = null;
             Assertion.AssertNull(targetInProgress1.ParentTargetsForBuildRequests);
             Assertion.Assert(!targetInProgress1.RequestedByHost);
@@ -212,7 +212,7 @@ public void TargetIdWrapperCustomSerialization()
                 originalWrapper.name = string.Empty;
                 originalWrapper.nodeId = 6;
                 originalWrapper.projectId = 8;
-                
+
                 stream.Position = 0;
                 // Serialize
                 originalWrapper.WriteToStream(writer);
diff --git a/src/Deprecated/Engine.UnitTests/TaskEngine_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskEngine_Tests.cs
index 4ee7f8d6178..1408438e97c 100644
--- a/src/Deprecated/Engine.UnitTests/TaskEngine_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskEngine_Tests.cs
@@ -24,9 +24,9 @@ namespace Microsoft.Build.UnitTests
     public class TaskEngineTest
     {
         /*********************************************************************************
-         * 
+         *
          *                                     BOOL
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "bool" parameter where no XML attribute was specified on the task.
@@ -38,7 +38,7 @@ public void InitTask_Bool_NoAttribute()
             XmlElement taskNode;
             TaskEngine taskEngine;
             MockTask mockTask;
-            ItemBucket itemBucket; 
+            ItemBucket itemBucket;
             EngineProxy engineProxy;
             taskNode = CreateXmlTaskNode();
             taskNode.RemoveAttribute("MyBoolParam");
@@ -130,9 +130,9 @@ public void InitTask_Bool_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     BOOL[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "bool[]" parameter where no XML attribute was specified on the task.
@@ -235,9 +235,9 @@ public void InitTask_BoolArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     INT
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "int" parameter where no XML attribute was specified on the task.
@@ -340,9 +340,9 @@ public void InitTask_Int_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     INT[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "int[]" parameter where no XML attribute was specified on the task.
@@ -445,9 +445,9 @@ public void InitTask_IntArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     STRING
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "string" parameter where no XML attribute was specified on the task.
@@ -550,9 +550,9 @@ public void InitTask_String_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     STRING[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "string[]" parameter where no XML attribute was specified on the task.
@@ -680,9 +680,9 @@ public void InitTask_StringArray_SingleItem()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     ITASKITEM
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "ITaskItem" parameter where no XML attribute was specified on the task.
@@ -887,9 +887,9 @@ public void InitTask_ITaskItem_CannotAcceptTwoItems()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     ITASKITEM[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a "string[]" parameter where no XML attribute was specified on the task.
@@ -992,9 +992,9 @@ public void InitTask_ITaskItemArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] BOOL
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "bool" parameter where no XML attribute was specified on the task.
@@ -1077,9 +1077,9 @@ public void InitTask_Required_Bool_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] BOOL[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "bool[]" parameter where no XML attribute was specified on the task.
@@ -1174,9 +1174,9 @@ public void InitTask_Required_BoolArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] INT
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "int" parameter where no XML attribute was specified on the task.
@@ -1259,9 +1259,9 @@ public void InitTask_Required_Int_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] INT[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "int[]" parameter where no XML attribute was specified on the task.
@@ -1356,9 +1356,9 @@ public void InitTask_Required_IntArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] STRING
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "string" parameter where no XML attribute was specified on the task.
@@ -1441,9 +1441,9 @@ public void InitTask_Required_String_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] STRING[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "string[]" parameter where no XML attribute was specified on the task.
@@ -1538,9 +1538,9 @@ public void InitTask_Required_StringArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] ITASKITEM
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "ITaskItem" parameter where no XML attribute was specified on the task.
@@ -1623,9 +1623,9 @@ public void InitTask_Required_ITaskItem_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     [REQUIRED] ITASKITEM[]
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Initialize a REQUIRED "string[]" parameter where no XML attribute was specified on the task.
@@ -1720,9 +1720,9 @@ public void InitTask_Required_ITaskItemArray_ItemEvaluatesToEmpty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                  OUTPUT PARAMS
-         * 
+         *
          *********************************************************************************/
         /// <summary>
         /// Attempts to gather outputs from a task parameter of type "ArrayList".  This should fail. Bug #416910
@@ -1774,7 +1774,7 @@ public void TaskOutputsNullITaskItemArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(LookupHelpers.CreateLookup(new Hashtable()), myTaskOutputSpecification, "NullITaskItemArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1828,7 +1828,7 @@ public void TaskOutputsEmptyStringInStringArrayParameterIntoItemList()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(LookupHelpers.CreateLookup(new Hashtable()), myTaskOutputSpecification, "EmptyStringInStringArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1854,7 +1854,7 @@ public void TaskOutputsStringParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "StringOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1880,7 +1880,7 @@ public void TaskOutputsStringArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "StringArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1906,7 +1906,7 @@ public void TaskOutputsIntParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "IntOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -1932,7 +1932,7 @@ public void TaskOutputsIntArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "IntArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
 
@@ -1985,7 +1985,7 @@ public void TaskOutputsITaskItemParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(LookupHelpers.CreateLookup(new Hashtable()), myTaskOutputSpecification, "ITaskItemOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -2011,7 +2011,7 @@ public void TaskOutputsTaskItemParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "TaskItemOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -2037,7 +2037,7 @@ public void TaskOutputsTaskItemArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "TaskItemArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -2063,7 +2063,7 @@ public void TaskOutputsMyTaskItemParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "MyTaskItemOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         /// <summary>
@@ -2089,7 +2089,7 @@ public void TaskOutputsMyTaskItemArrayParameter()
             InstantiateMockTaskHelper(taskNode, out taskEngine, out mockTask, out itemBucket, out engineProxy);
 
             taskEngine.GatherGeneratedTaskOutputs(GetEnteredScopeLookup(), myTaskOutputSpecification, "MyTaskItemArrayOutputParameter", "MyItemList", null, mockTask);
-            // Did not throw InvalidProjectFileException  
+            // Did not throw InvalidProjectFileException
         }
 
         [Test]
@@ -2113,7 +2113,7 @@ public void TasksAreDiscoveredWhenTaskConditionTrue()
                                    TaskExecutionMode.ExecuteTaskAndGatherOutputs,
                                    LookupHelpers.CreateLookup(new Hashtable())));
         }
-        
+
         [Test]
         public void TasksNotDiscoveredWhenTaskConditionFalse()
         {
@@ -2238,7 +2238,7 @@ public void OverridePropertiesInCreateProperty()
                                      Condition=""'%(LogicalName)' != '' "">
                          <Output TaskParameter=""Value"" PropertyName=""LinkSwitches""/>
                     </CreateProperty>
-                    <Message Text=`final:[$(LinkSwitches)]`/>                    
+                    <Message Text=`final:[$(LinkSwitches)]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -2265,7 +2265,7 @@ public void OverridePropertiesInInferredCreateProperty()
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                   <ItemGroup>
                     <i Include=`" + files[0] + "`><output>" + files[1] + @"</output></i>
-                  </ItemGroup> 
+                  </ItemGroup>
                   <ItemGroup>
                      <EmbeddedResource Include='a.resx'>
                     <LogicalName>foo</LogicalName>
@@ -2278,7 +2278,7 @@ public void OverridePropertiesInInferredCreateProperty()
                     </EmbeddedResource>
                     </ItemGroup>
                   <Target Name=`t2` DependsOnTargets=`t`>
-                    <Message Text=`final:[$(LinkSwitches)]`/>   
+                    <Message Text=`final:[$(LinkSwitches)]`/>
                   </Target>
                   <Target Name=`t` Inputs=`%(i.Identity)` Outputs=`%(i.Output)`>
                     <Message Text=`start:[Hello]`/>
@@ -2286,7 +2286,7 @@ public void OverridePropertiesInInferredCreateProperty()
                                      Condition=""'%(LogicalName)' != '' "">
                          <Output TaskParameter=""Value"" PropertyName=""LinkSwitches""/>
                     </CreateProperty>
-                    <Message Text=`end:[hello]`/>                    
+                    <Message Text=`end:[hello]`/>
                 </Target>
                 </Project>
             ", logger);
@@ -2308,9 +2308,9 @@ public void OverridePropertiesInInferredCreateProperty()
         }
 
         /*********************************************************************************
-         * 
+         *
          *                                     Helpers
-         * 
+         *
          *********************************************************************************/
         private void InstantiateMockTaskHelper
             (
@@ -2347,7 +2347,7 @@ string condition
             Engine engine = new Engine(@"c:\");
             Project project = new Project(engine);
             EngineCallback engineCallback = new EngineCallback(engine);
-            TaskExecutionModule taskExecutionModule = new TaskExecutionModule(engineCallback, 
+            TaskExecutionModule taskExecutionModule = new TaskExecutionModule(engineCallback,
                                         TaskExecutionModule.TaskExecutionModuleMode.SingleProcMode, false);
             ProjectBuildState buildContext = new ProjectBuildState(null, null, new BuildEventContext(0, 1, 1, 1));
             int nodeProxyID = engineCallback.CreateTaskContext(project, null, buildContext, taskNode, EngineCallback.inProcNode, new BuildEventContext(BuildEventContext.InvalidNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId));
@@ -2359,7 +2359,7 @@ string condition
                                     project.FullFileName,
                                     engine.LoggingServices,
                                     nodeProxyID,
-                                    taskExecutionModule, 
+                                    taskExecutionModule,
                                     new BuildEventContext(0, 1, 1, 1)
                                 );
             taskEngine.TaskClass = taskClass;
diff --git a/src/Deprecated/Engine.UnitTests/TaskExecutionContext_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskExecutionContext_Tests.cs
index 9cca1f5f524..98b52a7bd56 100644
--- a/src/Deprecated/Engine.UnitTests/TaskExecutionContext_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskExecutionContext_Tests.cs
@@ -33,18 +33,18 @@ public void TaskExecutionContextCreation()
              // Create some items to instantiate a task execution context and check to make sure those values are set properly
             Engine engine = new Engine();
                    engine.BinPath="TestBinPath";
-          
-            ArrayList targetsToBuild = new ArrayList(); 
+
+            ArrayList targetsToBuild = new ArrayList();
             targetsToBuild.Add("targetName");
             ProjectBuildState projectContext = new ProjectBuildState(null, targetsToBuild, new BuildEventContext(0, 1, 1, 1));
 
             TaskExecutionContext context = new TaskExecutionContext(null, null, null, projectContext, 4, EngineCallback.inProcNode, new BuildEventContext(BuildEventContext.InvalidNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId));
-         
+
             Assert.IsTrue(context.BuildContext.TargetNamesToBuild.Contains("targetName"),"Expected target list to contain targetName");
             Assert.IsNull(context.ParentTarget,"ParentTarget should be null");
             Assert.IsNull(context.ThrownException,"ThrownException should be null");
             Assert.AreEqual(4,context.HandleId,"Node ProxyId should be 4");
-        } 
+        }
 
 
         /// <summary>
diff --git a/src/Deprecated/Engine.UnitTests/TaskExecutionState_Test.cs b/src/Deprecated/Engine.UnitTests/TaskExecutionState_Test.cs
index fe1a2deeeb3..6773c945fcd 100644
--- a/src/Deprecated/Engine.UnitTests/TaskExecutionState_Test.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskExecutionState_Test.cs
@@ -56,7 +56,7 @@ public void SetUp()
         }
 
         /// <summary>
-        /// Test the case where the execution directory does not equal the current directory. In that 
+        /// Test the case where the execution directory does not equal the current directory. In that
         /// case the current directory should be switched to the execution directory
         /// </summary>
         [Test]
@@ -195,7 +195,7 @@ int nodeProxyId
             )
             : base(howToExecuteTask,
                 lookupForInference,
-                lookupForExecution, 
+                lookupForExecution,
                 taskXmlNode,
                 hostObject,
                 projectFileOfTaskNode,
diff --git a/src/Deprecated/Engine.UnitTests/TaskItem_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskItem_Tests.cs
index d71b488df0a..9121f2694fe 100644
--- a/src/Deprecated/Engine.UnitTests/TaskItem_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskItem_Tests.cs
@@ -23,28 +23,28 @@ public class TaskItemTests
         /*
         * Method:  SimpleCopyMetadataTo
         * Owner:   jomof
-        * 
+        *
         * Try the most basic CopyMetadataTo(...)
-        * 
+        *
         */
         [Test]
         public void SimpleCopyMetadataTo()
         {
             TaskItem from = new TaskItem("myfile.txt");
             from.SetMetadata("Culture", "fr");
-            
+
             TaskItem to = new TaskItem("myfile.bin");
             from.CopyMetadataTo(to);
-            
+
             Assertion.AssertEquals("fr", to.GetMetadata("Culture"));
         }
-        
+
         /*
         * Method:  CopyMetadataToDoesNotCopyExtension
         * Owner:   jomof
-        * 
+        *
         * Make sure that CopyMetadataTo(...) does not copy extension.
-        * 
+        *
         */
         [Test]
         public void CopyMetadataToDoesNotCopyExtension()
@@ -53,7 +53,7 @@ public void CopyMetadataToDoesNotCopyExtension()
             TaskItem to = new TaskItem("myfile.bin");
 
             from.CopyMetadataTo(to);
-            
+
             Assertion.AssertEquals(".bin", to.GetMetadata("Extension"));
         }
 
diff --git a/src/Deprecated/Engine.UnitTests/TaskRegistry_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskRegistry_Tests.cs
index 0b70e2bc552..e5fb70692da 100644
--- a/src/Deprecated/Engine.UnitTests/TaskRegistry_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskRegistry_Tests.cs
@@ -290,13 +290,13 @@ internal class TaskRegistryHelperMethods
 
         internal static Expander RegistryExpander
         {
-            get 
+            get
             {
                 if (registryExpander == null)
                 {
                     registryExpander = GetExpander();
                 }
-                return registryExpander; 
+                return registryExpander;
             }
         }
 
diff --git a/src/Deprecated/Engine.UnitTests/TaskWorkerThread_Tests.cs b/src/Deprecated/Engine.UnitTests/TaskWorkerThread_Tests.cs
index 023dae3a02c..40e460cb8a1 100644
--- a/src/Deprecated/Engine.UnitTests/TaskWorkerThread_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/TaskWorkerThread_Tests.cs
@@ -144,13 +144,13 @@ private List<TaskExecutionStateHelper> InitializeTaskState()
 
         /// <summary>
         /// Right now we are just testing the fact that the TaskWorker thread will take in a couple of tasks, some doing blocking
-        /// callbacks and make sure that each of the tasks completed correctly. Since the tasks are the ones which will 
+        /// callbacks and make sure that each of the tasks completed correctly. Since the tasks are the ones which will
         /// in the end set the exit event, if the test does not complete then the test has failed.
         /// </summary>
         [Test]
         public void TaskWorkerThreadTest()
         {
-            // This event will be triggered right before a "engine" call back is made. 
+            // This event will be triggered right before a "engine" call back is made.
             // Once this event is fired we insert another item into the queue
             ManualResetEvent rightBeforeCallbackBlock = new ManualResetEvent(false);
 
@@ -179,7 +179,7 @@ public void TaskWorkerThreadTest()
 
             workerThread.ActivateThread();
 
-            // Wait for the call back to happen     
+            // Wait for the call back to happen
             rightBeforeCallbackBlock.WaitOne();
 
             // Lets insert a execution task which and post a work item which will cause a localDoneEvent to be set
diff --git a/src/Deprecated/Engine.UnitTests/ToolsVersion_Tests.cs b/src/Deprecated/Engine.UnitTests/ToolsVersion_Tests.cs
index 0a2eb0629af..3c6dad2f290 100644
--- a/src/Deprecated/Engine.UnitTests/ToolsVersion_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ToolsVersion_Tests.cs
@@ -82,7 +82,7 @@ public void InvalidToolPath()
             TaskRegistry taskRegistry = (TaskRegistry) t.GetTaskRegistry(null);
 
             Console.WriteLine(mockLogger.FullLog);
-            Assert.AreEqual(1, mockLogger.WarningCount, "Expected a warning for invalid character in toolpath"); 
+            Assert.AreEqual(1, mockLogger.WarningCount, "Expected a warning for invalid character in toolpath");
         }
 
         public ToolsetState_Tests()
@@ -154,7 +154,7 @@ private XmlDocument loadXmlFromPath(string path)
               new DefaultTasksFile("d:\\directory1\\directory2\\f.tasks",
                       @"<Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <UsingTask TaskName='f1' AssemblyName='f' />
-                       </Project>"), 
+                       </Project>"),
               new DefaultTasksFile("c:\\directory1\\directory2\\g.custom.tasks",
                       @"<Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                             <UsingTask TaskName='g1' AssemblyName='g' />
diff --git a/src/Deprecated/Engine.UnitTests/ToolsetConfigurationReader_Tests.cs b/src/Deprecated/Engine.UnitTests/ToolsetConfigurationReader_Tests.cs
index 735d39dbc35..13390e24c6c 100644
--- a/src/Deprecated/Engine.UnitTests/ToolsetConfigurationReader_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ToolsetConfigurationReader_Tests.cs
@@ -142,7 +142,7 @@ public void MSBuildToolsetsTest_BasicWithOtherConfigEntries()
         #region "Invalid cases (exception is expected to be thrown)"
 
         /// <summary>
-        /// name attribute is missing from toolset element 
+        /// name attribute is missing from toolset element
         /// </summary>
         [Test]
         [ExpectedException(typeof(ConfigurationErrorsException))]
@@ -196,7 +196,7 @@ public void ToolsVersionTest_MultipleElementsWithSameName()
         }
 
         /// <summary>
-        /// empty toolset element 
+        /// empty toolset element
         /// </summary>
         [Test]
         [ExpectedException(typeof(ConfigurationErrorsException))]
@@ -422,7 +422,7 @@ public void PropertyTest_GetValueByName()
             Assertion.AssertEquals(msbuildToolsetSection.Default, "2.0");
             Assertion.AssertEquals(1, msbuildToolsetSection.Toolsets.Count);
             Assertion.AssertEquals(2, msbuildToolsetSection.Toolsets.GetElement("2.0").PropertyElements.Count);
-            Assertion.AssertEquals(@"D:\windows\Microsoft.NET\Framework\v2.0.x86ret\", 
+            Assertion.AssertEquals(@"D:\windows\Microsoft.NET\Framework\v2.0.x86ret\",
                                    msbuildToolsetSection.Toolsets.GetElement("2.0").PropertyElements.GetElement("MSBuildBinPath").Value);
             Assertion.AssertEquals(@"SomeOtherPropertyValue",
                                    msbuildToolsetSection.Toolsets.GetElement("2.0").PropertyElements.GetElement("SomeOtherPropertyName").Value);
diff --git a/src/Deprecated/Engine.UnitTests/ToolsetReader_Tests.cs b/src/Deprecated/Engine.UnitTests/ToolsetReader_Tests.cs
index ceee9e343dd..2ace0785e85 100644
--- a/src/Deprecated/Engine.UnitTests/ToolsetReader_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ToolsetReader_Tests.cs
@@ -574,7 +574,7 @@ public void BlankPropertyNameInRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -626,7 +626,7 @@ public void BlankPropertyValueInRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -680,7 +680,7 @@ public void InvalidPropertyNameInRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -750,7 +750,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
 
         /// <summary>
         /// Tests that any escaped xml in config file, is treated well
-        /// Note that this comes for free with the current implementation using the 
+        /// Note that this comes for free with the current implementation using the
         /// framework api to access section in the config file
         /// </summary>
         [Test]
@@ -819,7 +819,7 @@ public void GetToolsetData_NoConflict()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry
                                                        );
@@ -868,7 +868,7 @@ public void ToolsetInitializationFlagsSetToNone()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.None
                                                        );
@@ -920,7 +920,7 @@ public void ToolsetInitializationFlagsSetToRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -950,7 +950,7 @@ public void ThrowOnNonStringRegistryValueTypes()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -973,7 +973,7 @@ public void PropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.Registry
                                                        );
@@ -1019,7 +1019,7 @@ public void ToolsetInitializationFlagsSetToConfigurationFile()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile
                                                        );
@@ -1068,7 +1068,7 @@ public void PropertyInConfigurationFileReferencesRegistryLocation()
                                                            values,
                                                            new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath)),
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry
                                                        );
@@ -1089,10 +1089,10 @@ public void ToolsPathInRegistryHasInvalidPathChars()
             currentVersionRegistryKey.SetValue("DefaultToolsVersion", "2.0");
             RegistryKey key1 = toolsVersionsRegistryKey.CreateSubKey("2.0");
             key1.SetValue("MSBuildBinPath", @"D:\some\foo|bar\path\");
-            
+
             ToolsetCollection values = new ToolsetCollection(new Engine(ToolsetDefinitionLocations.None));
 
-            // should throw... 
+            // should throw...
             string defaultToolsVersion = ToolsetReader.ReadAllToolsets
                                                        (
                                                            values,
@@ -1130,7 +1130,7 @@ public void SamePropertyDefinedMultipleTimesForSingleToolsVersionInConfiguration
                                                            values,
                                                            null,
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile
                                                        );
@@ -1162,7 +1162,7 @@ public void SamePropertyDifferentCaseDefinedMultipleTimesForSingleToolsVersionIn
                                                            values,
                                                            null,
                                                            new ToolsetConfigurationReader(new ReadApplicationConfiguration(ToolsetConfigurationReaderTestHelper.ReadApplicationConfigurationTest)),
-                                                           new BuildPropertyGroup(), 
+                                                           new BuildPropertyGroup(),
                                                            new BuildPropertyGroup(),
                                                            ToolsetDefinitionLocations.ConfigurationFile
                                                        );
@@ -1243,7 +1243,7 @@ public void SameToolsVersionDifferentCaseDefinedMultipleTimesInConfigurationFile
                                                            ToolsetDefinitionLocations.ConfigurationFile
                                                        );
         }
-        
+
         [Test]
         [ExpectedException(typeof(InvalidToolsetDefinitionException))]
         public void CannotSetReservedPropertyInConfigFile()
@@ -1295,7 +1295,7 @@ public void CannotSetReservedPropertyInRegistry()
                                                            ToolsetDefinitionLocations.Registry
                                                        );
         }
-        
+
         /// <summary>
         /// Properties defined in previously processed toolset definitions should
         /// not affect the evaluation of subsequent toolset definitions.
@@ -1335,7 +1335,7 @@ public void NoInterferenceBetweenToolsetDefinitions()
                                                        );
 
             Assertion.AssertEquals(2, values.Count);
-            
+
             Assertion.AssertEquals(@"D:\20\some\folder\on\disk", values["2.0"].ToolsPath);
             Assertion.AssertEquals(2, values["2.0"].BuildProperties.Count);
             Assertion.AssertEquals(@"another", values["2.0"].BuildProperties["p1"].Value);
@@ -1463,7 +1463,7 @@ public void RegistryValidRegistryExpressionRecursive()
         {
             // Property pointing to itself - should not hang :-)
             RegistryValidRegistryExpressionHelper
-                (@"$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"\ToolsVersions\2.0@p)", 
+                (@"$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"\ToolsVersions\2.0@p)",
                  @"$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"\ToolsVersions\2.0@p)");
         }
 
@@ -1707,8 +1707,8 @@ public void GetToolsetData_RegistryNotPresent()
 
         /// <summary>
         /// Test the case where nothing is specified in the config file
-        /// Note that config file not present is same as config file 
-        /// with no MSBuildToolsets Section 
+        /// Note that config file not present is same as config file
+        /// with no MSBuildToolsets Section
         /// </summary>
         [Test]
         public void GetToolsetData_ConfigFileNotPresent()
@@ -2097,7 +2097,7 @@ public void GlobalPropertiesInToolsetsAreExpandedButAreNotOverwritten()
                        <property name=""gp1"" value=""v2""/>
                        <property name=""p2"" value=""$(gp1)""/>
                      </toolset>
-                   </msbuildToolsets> 
+                   </msbuildToolsets>
                  </configuration>");
 
             Engine e = new Engine(ToolsetDefinitionLocations.None);
@@ -2105,7 +2105,7 @@ public void GlobalPropertiesInToolsetsAreExpandedButAreNotOverwritten()
 
             BuildPropertyGroup globalProperties = e.GlobalProperties;
             globalProperties.SetProperty("gp1", "gv1");
-            
+
             BuildPropertyGroup initialProperties = new BuildPropertyGroup();
             initialProperties.ImportProperties(e.EnvironmentProperties);
             initialProperties.ImportProperties(globalProperties);
@@ -2150,7 +2150,7 @@ public enum WhereToThrow
         protected MockRegistryKey(RegistryKey wrappedKey, RegistryKey registryHive)
             : base(wrappedKey, registryHive)
         { }
-        
+
         /// <summary>
         /// Construct the mock key with a wrapper
         /// </summary>
diff --git a/src/Deprecated/Engine.UnitTests/ToolsetRegistryReader_Tests.cs b/src/Deprecated/Engine.UnitTests/ToolsetRegistryReader_Tests.cs
index a15965d4f01..846fa1e8929 100644
--- a/src/Deprecated/Engine.UnitTests/ToolsetRegistryReader_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/ToolsetRegistryReader_Tests.cs
@@ -69,7 +69,7 @@ private void DeleteTestRegistryKey()
         public void ReadRegistry_DeletedKey()
         {
             DeleteTestRegistryKey();
-            
+
             ToolsetReader reader = new ToolsetRegistryReader(new MockRegistryKey(testRegistryPath));
             ToolsetCollection values = new ToolsetCollection(new Engine(ToolsetDefinitionLocations.None));
 
@@ -174,7 +174,7 @@ public void ReadRegistry_OnlyOneSubkey()
         public void ReadRegistry_Basic()
         {
             RegistryKey key1 = toolsVersionsRegistryKey.CreateSubKey("tv1");
-            key1.SetValue("msbuildtoolspath", "c:\\xxx");            
+            key1.SetValue("msbuildtoolspath", "c:\\xxx");
             key1.SetValue("name1", "value1");
             RegistryKey key2 = toolsVersionsRegistryKey.CreateSubKey("tv2");
             key2.SetValue("name2", "value2");
@@ -248,7 +248,7 @@ public void ReadRegistry_IgnoreSubKeysExceptTopMostSubKeys()
             Assertion.Assert(0 == String.Compare("c:\\yyy", values["tv2"].ToolsPath, StringComparison.OrdinalIgnoreCase));
             Assertion.Assert(0 == String.Compare("value2", values["tv2"].BuildProperties["name2"].Value, StringComparison.OrdinalIgnoreCase));
         }
-        
+
         /// <summary>
         /// Regular case of getting default tools version
         /// </summary>
diff --git a/src/Deprecated/Engine.UnitTests/Utilities_Tests.cs b/src/Deprecated/Engine.UnitTests/Utilities_Tests.cs
index 7d3d8fdcccd..89e9a47c74a 100644
--- a/src/Deprecated/Engine.UnitTests/Utilities_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Utilities_Tests.cs
@@ -27,11 +27,11 @@ public class UtilitiesTest
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)' == 'Debug'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -50,11 +50,11 @@ public void GatherReferencedPropertyNames1 ()
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     'Debug' != '$(Configuration)'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -70,14 +70,14 @@ public void GatherReferencedPropertyNames2 ()
             Assertion.AssertEquals(1, configurations.Count);
             Assertion.AssertEquals("Debug", configurations[0]);
         }
-        
+
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)|$(Platform)' != 'Debug|x86'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -96,14 +96,14 @@ public void GatherReferencedPropertyNames3 ()
             Assertion.AssertEquals("Debug", configurations[0]);
             Assertion.AssertEquals("x86", platforms[0]);
         }
-    
+
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     'Debug|x86' == '$(Configuration)|$(Platform)'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -125,11 +125,11 @@ public void GatherReferencedPropertyNames4 ()
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)|$(Platform)|$(Machine)' == 'Debug|x86|RGOEL3'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -154,11 +154,11 @@ public void GatherReferencedPropertyNames5 ()
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)|$(Platform)|$(Machine)' == 'Debug'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -179,11 +179,11 @@ public void GatherReferencedPropertyNames6 ()
 
         /// <summary>
         /// Tests our "Condition" parser's ability to extract certain property values
-        /// out, for the purposes of VS populating the "Configuration" and "Platform" 
+        /// out, for the purposes of VS populating the "Configuration" and "Platform"
         /// dropdown boxes.  This one tests the following expression:
-        /// 
+        ///
         ///     '$(Configuration)' == 'Debug|x86|RGOEL3'
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
@@ -228,7 +228,7 @@ public void IllegalConditionOnProjectExtensions()
         public void RepeatedProjectExtensions()
         {
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
-                <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`> 
+                <Project ToolsVersion=`3.5` xmlns=`msbuildnamespace`>
                     <ProjectExtensions/>
                     <Import Project=`$(MSBuildBinPath)\\Microsoft.CSharp.Targets` />
                     <ProjectExtensions/>
diff --git a/src/Deprecated/Engine.UnitTests/XmlSearcher_Tests.cs b/src/Deprecated/Engine.UnitTests/XmlSearcher_Tests.cs
index 88cf72e8dd1..91a3ddf7adc 100644
--- a/src/Deprecated/Engine.UnitTests/XmlSearcher_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/XmlSearcher_Tests.cs
@@ -146,7 +146,7 @@ public void GetLineColumnOfXmlNode()
             // Correct answer is:
             //      Line Number 9
             //      Column Number 5
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 7, 0, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(9, foundLineNumber);
             Assertion.AssertEquals(5, foundColumnNumber);
@@ -157,7 +157,7 @@ public void GetLineColumnOfXmlNode()
             //      Line Number 6
             //      Column Number 19
             // This is because the text node actually begins immediately after the closing ">" in "<WarningLevel>".
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 6, 0, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(6, foundLineNumber);
             Assertion.AssertEquals(19, foundColumnNumber);
@@ -167,7 +167,7 @@ public void GetLineColumnOfXmlNode()
             // Correct answer is:
             //      Line Number 4
             //      Column Number 18
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 2, 2, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(4, foundLineNumber);
             Assertion.AssertEquals(18, foundColumnNumber);
@@ -177,19 +177,19 @@ public void GetLineColumnOfXmlNode()
             // Correct answer is:
             //      Line Number 9
             //      Column Number 17
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 8, 0, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(9, foundLineNumber);
             Assertion.AssertEquals(17, foundColumnNumber);
 
             // Let's try passing in a bogus element number.
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 25, 0, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(0, foundLineNumber);
             Assertion.AssertEquals(0, foundColumnNumber);
 
             // And let's try passing in a bogus attribute number.
-            GetLineColumnFromProjectFileContentsHelper(projectFileContents, 
+            GetLineColumnFromProjectFileContentsHelper(projectFileContents,
                 7, 4, out foundLineNumber, out foundColumnNumber);
             Assertion.AssertEquals(0, foundLineNumber);
             Assertion.AssertEquals(0, foundColumnNumber);
@@ -197,7 +197,7 @@ public void GetLineColumnOfXmlNode()
 
         /// <summary>
         /// Given a string representing the contents of the project file, create a project file
-        /// on disk with those contents.  Then call the method to find the line/column number of 
+        /// on disk with those contents.  Then call the method to find the line/column number of
         /// a particular node in the project file, based on the element/attribute number of that node.
         /// </summary>
         /// <param name="projectFileContents"></param>
@@ -214,8 +214,8 @@ out int foundColumnNumber
         {
             string projectFile = ObjectModelHelpers.CreateTempFileOnDisk(projectFileContents);
 
-            XmlSearcher.GetLineColumnByNodeNumber(projectFile, 
-                xmlElementNumberToSearchFor, xmlAttributeNumberToSearchFor, 
+            XmlSearcher.GetLineColumnByNodeNumber(projectFile,
+                xmlElementNumberToSearchFor, xmlAttributeNumberToSearchFor,
                 out foundLineNumber, out foundColumnNumber);
 
             // Delete the temp file.
diff --git a/src/Deprecated/Engine.UnitTests/enginehelpers.cs b/src/Deprecated/Engine.UnitTests/enginehelpers.cs
index f2da5eaf5c5..b0ffab3708f 100644
--- a/src/Deprecated/Engine.UnitTests/enginehelpers.cs
+++ b/src/Deprecated/Engine.UnitTests/enginehelpers.cs
@@ -17,7 +17,7 @@
 using System.Text.RegularExpressions;
 using System.Collections.Generic;
 
-    
+
 namespace Microsoft.Build.UnitTests
 {
     /*
@@ -27,7 +27,7 @@ namespace Microsoft.Build.UnitTests
      * Utility methods for unit tests that work through the object model.
      *
      */
-    sealed public class EngineHelpers        
+    sealed public class EngineHelpers
     {
         internal static string EnsureNoLeadingSlash(string path)
         {
@@ -62,26 +62,26 @@ internal static bool IsSlash(char c)
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <owner>RGoel</owner>
         static internal void AssertItemsMatch
             (
-            string expectedItemsString, 
+            string expectedItemsString,
             BuildItem[] actualItems
             )
         {
@@ -89,27 +89,27 @@ BuildItem[] actualItems
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <owner>RGoel</owner>
         static internal void AssertItemsMatch
             (
-            string expectedItemsString, 
-            BuildItem[] actualItems, 
+            string expectedItemsString,
+            BuildItem[] actualItems,
             bool orderOfItemsShouldMatch
             )
         {
@@ -125,26 +125,26 @@ bool orderOfItemsShouldMatch
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <owner>RGoel</owner>
         static internal void AssertItemsMatch
             (
-            string expectedItemsString, 
+            string expectedItemsString,
             BuildItemGroup actualItems
             )
         {
@@ -152,27 +152,27 @@ BuildItemGroup actualItems
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
         /// <owner>RGoel</owner>
         static internal void AssertItemsMatch
             (
-            string expectedItemsString, 
-            BuildItemGroup actualItems, 
+            string expectedItemsString,
+            BuildItemGroup actualItems,
             bool orderOfItemsShouldMatch
             )
         {
diff --git a/src/Deprecated/Engine.UnitTests/projectschemavalidationhandler_tests.cs b/src/Deprecated/Engine.UnitTests/projectschemavalidationhandler_tests.cs
index 3a64926a5c5..38f8fe15228 100644
--- a/src/Deprecated/Engine.UnitTests/projectschemavalidationhandler_tests.cs
+++ b/src/Deprecated/Engine.UnitTests/projectschemavalidationhandler_tests.cs
@@ -21,13 +21,13 @@ namespace Microsoft.Build.UnitTests
     public class ProjectSchemaValidationHandlerTest
     {
         /***********************************************************************
-         * 
+         *
          * Test:        ProjectSchemaValidationHandlerTest.VerifyProjectSchema
          * Owner:       JomoF
-         *  
+         *
          * This calls VerifyProjectSchema to validate a project XML
          * specified in a string
-         * 
+         *
          **********************************************************************/
         [Test]
         [ExpectedException(typeof(InvalidProjectFileException))]
@@ -53,7 +53,7 @@ public void VerifyInvalidProjectSchema
 
                 try
                 {
-                    validator.VerifyProjectSchema(ObjectModelHelpers.CleanupFileContents(projectContents), 
+                    validator.VerifyProjectSchema(ObjectModelHelpers.CleanupFileContents(projectContents),
                         msbuildTempXsdFilenames[0]);
                 }
                 catch (InvalidProjectFileException e)
@@ -82,7 +82,7 @@ public void VerifyInvalidSchemaItself1
                 invalidSchemaFile = Path.GetTempFileName();
 
                 File.WriteAllText(invalidSchemaFile, "<this_is_invalid_schema_content/>");
-                
+
                 string projectContents = @"
                     <Project xmlns=`msbuildnamespace`>
                         <Target Name=`Build` />
@@ -163,13 +163,13 @@ public void VerifyInvalidSchemaItself2
         }
 
         /***********************************************************************
-         * 
+         *
          * Test:        ProjectSchemaValidationHandlerTest.VerifyProjectSchema
          * Owner:       JomoF
-         *  
+         *
          * This calls VerifyProjectSchema to validate a project XML
          * specified in a string
-         * 
+         *
          **********************************************************************/
         [Test]
         public void VerifyValidProjectSchema
@@ -191,7 +191,7 @@ public void VerifyValidProjectSchema
                 Engine e = new Engine(@"c:\");
                 ProjectSchemaValidationHandler validator = new ProjectSchemaValidationHandler(null, e.LoggingServices, @"c:\");
 
-                validator.VerifyProjectSchema(ObjectModelHelpers.CleanupFileContents(projectContents), 
+                validator.VerifyProjectSchema(ObjectModelHelpers.CleanupFileContents(projectContents),
                     msbuildTempXsdFilenames[0]);
             }
             finally
diff --git a/src/Deprecated/Engine/Choose/Choose.cs b/src/Deprecated/Engine/Choose/Choose.cs
index 0ca947a0486..4440f2adc84 100644
--- a/src/Deprecated/Engine/Choose/Choose.cs
+++ b/src/Deprecated/Engine/Choose/Choose.cs
@@ -81,7 +81,7 @@ int nestingDepth
             ProjectXmlUtilities.VerifyThrowElementName(chooseElement, XMakeElements.choose);
 
             // Stack overflow guard. The only way in the MSBuild file format that MSBuild elements can be
-            // legitimately nested without limit is the <Choose> construct. So, enforce a nesting limit 
+            // legitimately nested without limit is the <Choose> construct. So, enforce a nesting limit
             // to avoid blowing our stack.
             nestingDepth++;
             ProjectErrorUtilities.VerifyThrowInvalidProject(nestingDepth <= maximumChooseNesting, chooseElement, "ChooseOverflow", maximumChooseNesting);
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 16c60f1e1af..68b63ff1db0 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -102,7 +102,7 @@ internal bool IsSynchronized
             }
         }
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <remarks>
@@ -171,7 +171,7 @@ internal int ItemGroupCount
         }
 
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <remarks>
diff --git a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
index b3cf778c04d..1913af98416 100644
--- a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
+++ b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
@@ -116,7 +116,7 @@ private void ConstructFrom(CopyOnWriteHashtable that)
             {
                 this.writeableData = null;
 
-                // If the source it was writeable, need to transform it into 
+                // If the source it was writeable, need to transform it into
                 // read-only because we don't want subsequent writes to bleed through.
                 if (that.writeableData != null)
                 {
diff --git a/src/Deprecated/Engine/Collections/DualQueue.cs b/src/Deprecated/Engine/Collections/DualQueue.cs
index 4136db8a3e9..c5f80e33746 100644
--- a/src/Deprecated/Engine/Collections/DualQueue.cs
+++ b/src/Deprecated/Engine/Collections/DualQueue.cs
@@ -276,7 +276,7 @@ private Queue<T> GetReadingQueue()
         /// <returns></returns>
         internal bool Contains(T item)
         {
-            // The dual queue in general contains an item if the item exists 
+            // The dual queue in general contains an item if the item exists
             // in one or even both of the backing queues
             return backingQueueA.Contains(item) || backingQueueB.Contains(item);
         }
@@ -316,7 +316,7 @@ internal bool Contains(T item)
         private Queue<T> backingQueueB;
 
         /// <summary>
-        /// Count of the current writer queue - we only own the reader queue in Count so we have to keep 
+        /// Count of the current writer queue - we only own the reader queue in Count so we have to keep
         /// the count for the writer queue separately.
         /// </summary>
         private int writingQueueCount;
diff --git a/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs b/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
index 4355f02bb7b..df9a96b548c 100644
--- a/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
+++ b/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
@@ -11,7 +11,7 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// All the state necessary for the evaluation of conditionals so that the expression tree 
+    /// All the state necessary for the evaluation of conditionals so that the expression tree
     /// is stateless and reusable
     /// </summary>
     internal struct ConditionEvaluationState
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index bde7889d466..66cc6c8674e 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -57,8 +57,8 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
 
                         // Ignore invalid characters or path related exceptions
 
-                        // We will ignore the PathTooLong exception caused by GetFullPath becasue in single proc this code 
-                        // is not executed and the condition is just evaluated to false as File.Exists and Directory.Exists does not throw in this situation. 
+                        // We will ignore the PathTooLong exception caused by GetFullPath becasue in single proc this code
+                        // is not executed and the condition is just evaluated to false as File.Exists and Directory.Exists does not throw in this situation.
                         // To be consistant with that we will return a false in this case also.
                         // DevDiv Bugs: 46035
 
diff --git a/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs b/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
index f1bfdaf7f4d..2fcb5fc2cc8 100644
--- a/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
@@ -32,7 +32,7 @@ internal abstract class GenericExpressionNode
         internal abstract string GetUnexpandedValue(ConditionEvaluationState state);
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal abstract void ResetState();
@@ -70,7 +70,7 @@ internal virtual bool PossibleOrCollision
         internal bool PotentialAndOrConflict()
         {
             // The values of the functions are assigned to boolean locals
-            // in order to force evaluation of the functions even when the 
+            // in order to force evaluation of the functions even when the
             // first one returns false
             bool detectOr = DetectOr();
             bool detectAnd = DetectAnd();
diff --git a/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs b/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
index 53ae427394c..8d1c921e271 100644
--- a/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
@@ -68,7 +68,7 @@ internal override string GetExpandedValue(ConditionEvaluationState state)
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
index c090f79f569..90daa06c3a6 100644
--- a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
@@ -65,7 +65,7 @@ internal override string GetUnexpandedValue(ConditionEvaluationState state)
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index a6759139298..48cb79aa33b 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -48,7 +48,7 @@ internal sealed class Parser
 
         private BuildEventContext logBuildEventContext;
         /// <summary>
-        ///  Location contextual information which are attached to logging events to 
+        ///  Location contextual information which are attached to logging events to
         ///  say where they are in relation to the process, engine, project, target,task which is executing
         /// </summary>
         internal BuildEventContext LogBuildEventContext
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index ae786ef938b..58a1ad65a64 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.BuildEngine
     ///    do {
     ///      s.Advance();
     ///    while (s.IsNext(Token.EndOfInput));
-    /// 
+    ///
     ///  After Advance() is called, you can get the current token (s.CurrentToken),
     ///  check it's type (s.IsNext()), get the string for it (s.NextString()).
     /// </summary>
@@ -37,7 +37,7 @@ internal sealed class Scanner
         private ParserOptions options;
         private string errorResource = null;
 
-        // Shared instances of "hardcoded" token strings. These are only used 
+        // Shared instances of "hardcoded" token strings. These are only used
         // in error messages.
         private const string comma = ",";
         private const string leftParenthesis = "(";
@@ -129,7 +129,7 @@ internal int GetErrorPosition()
             return errorPosition;
         }
 
-        // The string (usually a single character) we found unexpectedly. 
+        // The string (usually a single character) we found unexpectedly.
         // We might want to show it in the error message, to help the user spot the error.
         internal string UnexpectedlyFound
         {
@@ -310,7 +310,7 @@ internal bool Advance()
         }
 
         /// <summary>
-        /// Parses either the $(propertyname) syntax or the %(metadataname) syntax, 
+        /// Parses either the $(propertyname) syntax or the %(metadataname) syntax,
         /// and returns the parsed string beginning with the '$' or '%', and ending with the
         /// closing parenthesis.
         /// </summary>
diff --git a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
index 6c4005ca9c9..1b50b71ac2e 100644
--- a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
@@ -73,7 +73,7 @@ internal override string GetExpandedValue(ConditionEvaluationState state)
         }
 
         /// <summary>
-        /// If any expression nodes cache any state for the duration of evaluation, 
+        /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
         /// </summary>
         internal override void ResetState()
diff --git a/src/Deprecated/Engine/Conditionals/Token.cs b/src/Deprecated/Engine/Conditionals/Token.cs
index d9fcca9d366..88fe9857196 100644
--- a/src/Deprecated/Engine/Conditionals/Token.cs
+++ b/src/Deprecated/Engine/Conditionals/Token.cs
@@ -44,7 +44,7 @@ internal Token(TokenType type, string tokenString)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="type"></param>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index 3b7b78a6015..04aa8cc8791 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -20,26 +20,26 @@ namespace Microsoft.Build.BuildEngine
     /// </summary>
     /// <remarks>
     /// What batching does
-    /// 
-    /// Batching partitions the items consumed by the batchable object into buckets, where each bucket 
-    /// contains a set of items that have the same value set on all item metadata consumed by the object. 
-    /// Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it 
+    ///
+    /// Batching partitions the items consumed by the batchable object into buckets, where each bucket
+    /// contains a set of items that have the same value set on all item metadata consumed by the object.
+    /// Metadata consumed may be unqualified, for example %(m), or qualified by the item list to which it
     /// refers, for example %(a.m).
-    /// 
-    /// If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the 
-    /// same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type �b� 
-    /// are considered to always have a blank value for %(a.m). This means items of type �b� will only be 
+    ///
+    /// If metadata is qualified, for example %(a.m), then this is considered distinct to metadata with the
+    /// same name on a different item type. For example, %(a.m) is distinct to %(b.m), and items of type �b�
+    /// are considered to always have a blank value for %(a.m). This means items of type �b� will only be
     /// placed in buckets where %(a.m) is blank. However %(a.m) is equivalent to %(m) on items of type �a�.
-    /// 
-    /// There is an extra ambiguity rule: every items consumed by the object must have an explicit value for 
-    /// every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item 
-    /// of type �a� must have a value for the metadata �m� but need not all necessarily have a value for the 
-    /// metadata �n�. This rule eliminates ambiguity about whether items that do not define values for an 
-    /// unqualified metadata should go in all buckets, or just into buckets with a blank value for 
+    ///
+    /// There is an extra ambiguity rule: every items consumed by the object must have an explicit value for
+    /// every piece of unqualified metadata. For example, if @(a), %(m), and %(a.n) are consumed, every item
+    /// of type �a� must have a value for the metadata �m� but need not all necessarily have a value for the
+    /// metadata �n�. This rule eliminates ambiguity about whether items that do not define values for an
+    /// unqualified metadata should go in all buckets, or just into buckets with a blank value for
     /// that metadata.
-    /// 
-    /// For example 
-    /// 
+    ///
+    /// For example
+    ///
     /// <ItemGroup>
     /// <a Include='a1;a2'>
     ///   <n>m0</n>
@@ -55,19 +55,19 @@ namespace Microsoft.Build.BuildEngine
     /// </b>
     /// <b Include='b4'/>
     /// </ItemGroup>
-    /// 
+    ///
     /// <Target Name="t" >
     ///   <Message Text="a={@(a).%(a.n)} b={@(b).%(b.n)}" />
     /// </Target>
-    /// 
-    /// Will produce 5 buckets: 
-    /// 
+    ///
+    /// Will produce 5 buckets:
+    ///
     /// a={a1;a2.m0} b={.}
     /// a={a3.m1} b={.}
     /// a={.} b={b1.n0}
     /// a={.} b={b2;b3.n1}
     /// a={.} b={b4.}
-    /// 
+    ///
     /// </remarks>
     internal static class BatchingEngine
     {
@@ -113,14 +113,14 @@ string implicitBatchableItemType
             ItemsAndMetadataPair pair = ExpressionShredder.GetReferencedItemNamesAndMetadata(batchableObjectParameters);
 
             // All the @(itemname) item list references in the tag, including transforms, etc.
-            // The keys in the hashtable are the item names, and the values are all String.Empty (not used).            
+            // The keys in the hashtable are the item names, and the values are all String.Empty (not used).
             Hashtable consumedItemReferences = pair.Items;
 
-            // All the %(itemname.metadataname) references in the tag (not counting those embedded 
+            // All the %(itemname.metadataname) references in the tag (not counting those embedded
             // inside item transforms), and note that the itemname portion is optional.
             // The keys in the returned hash table are the qualified metadata names (e.g. "EmbeddedResource.Culture"
-            // or just "Culture").  The values are MetadataReference structs, which simply split out the item 
-            // name (possibly null) and the actual metadata name.            
+            // or just "Culture").  The values are MetadataReference structs, which simply split out the item
+            // name (possibly null) and the actual metadata name.
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             ArrayList buckets = null;
@@ -136,14 +136,14 @@ string implicitBatchableItemType
                 // This method goes through all the item list references and figures out which ones
                 // will be participating in batching, and which ones won't.  We get back a hashtable
                 // where the key is the item name that will be participating in batching.  The values
-                // are all String.Empty (not used).  This method may return additional item names 
+                // are all String.Empty (not used).  This method may return additional item names
                 // that weren't represented in "consumedItemReferences"... this would happen if there
-                // were qualified metadata references in the consumedMetadataReferences table, such as 
+                // were qualified metadata references in the consumedMetadataReferences table, such as
                 // %(EmbeddedResource.Culture).
                 Hashtable itemListsToBeBatched = GetItemListsToBeBatched(parentNode, consumedMetadataReferences, consumedItemReferences, lookup);
 
-                // At this point, if there were any metadata references in the tag, but no item 
-                // references to batch on, we've got a problem because we can't figure out which 
+                // At this point, if there were any metadata references in the tag, but no item
+                // references to batch on, we've got a problem because we can't figure out which
                 // item lists the user wants us to batch.
                 if (itemListsToBeBatched.Count == 0)
                 {
@@ -179,16 +179,16 @@ string implicitBatchableItemType
 
         /// <summary>
         /// Of all the item lists that are referenced in this batchable object, which ones should we
-        /// batch on, and which ones should we just pass in wholesale to every invocation of the 
+        /// batch on, and which ones should we just pass in wholesale to every invocation of the
         /// target/task?
-        /// 
+        ///
         /// Rule #1.  If the user has referenced any *qualified* item metadata such as %(EmbeddedResource.Culture),
         /// then that item list "EmbeddedResource" will definitely get batched.
-        /// 
-        /// Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that 
+        ///
+        /// Rule #2.  For all the unqualified item metadata such as %(Culture), we make sure that
         /// every single item in every single item list being passed into the task contains a value
         /// for that metadata.  If not, it's an error.  If so, we batch all of those item lists.
-        /// 
+        ///
         /// All other item lists will not be batched, and instead will be passed in wholesale to all buckets.
         /// </summary>
         /// <returns>Hashtable containing the item names that should be batched.</returns>
@@ -213,11 +213,11 @@ Lookup lookup
                 if (consumedMetadataReference.itemName != null)
                 {
                     // Rule #1.  Qualified metadata reference.
-                    // For metadata references that are qualified with an item name 
-                    // (e.g., %(EmbeddedResource.Culture) ), we add that item name to the list of 
+                    // For metadata references that are qualified with an item name
+                    // (e.g., %(EmbeddedResource.Culture) ), we add that item name to the list of
                     // consumed item names, even if the item name wasn't otherwise referenced via
                     // @(...) syntax, and even if every item in the list doesn't necessary contain
-                    // a value for this metadata.  This is the special power that you get by qualifying 
+                    // a value for this metadata.  This is the special power that you get by qualifying
                     // the metadata reference with an item name.
                     itemListsToBeBatched[consumedMetadataReference.itemName] = String.Empty;
 
@@ -225,7 +225,7 @@ Lookup lookup
                     // %(EmbeddedResource.Culture) effectively means that @(EmbeddedResource) is
                     // being consumed, even though we may not see literally "@(EmbeddedResource)"
                     // in the tag anywhere.  Adding it to this list allows us (down below in this
-                    // method) to check that every item in this list has a value for each 
+                    // method) to check that every item in this list has a value for each
                     // unqualified metadata reference.
                     consumedItemReferenceNames = Utilities.CreateTableIfNecessary(consumedItemReferenceNames);
                     consumedItemReferenceNames[consumedMetadataReference.itemName] = String.Empty;
@@ -370,7 +370,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
         /// <summary>
         /// Gets the values of the specified metadata for the given item.
         /// The keys in the dictionary returned may be qualified and/or unqualified, exactly
-        /// as they are found in the metadata reference. 
+        /// as they are found in the metadata reference.
         /// For example if %(x) is found, the key is "x", if %(z.x) is found, the key is "z.x".
         /// This dictionary in each bucket is used by Expander to expand exactly the same metadata references, so
         /// %(x) is expanded using the key "x", and %(z.x) is expanded using the key "z.x".
diff --git a/src/Deprecated/Engine/Engine/BuildRequest.cs b/src/Deprecated/Engine/Engine/BuildRequest.cs
index 1e4f2694f47..08612a49045 100644
--- a/src/Deprecated/Engine/Engine/BuildRequest.cs
+++ b/src/Deprecated/Engine/Engine/BuildRequest.cs
@@ -579,7 +579,7 @@ internal BuildResult GetBuildResult()
         }
 
         /// <summary>
-        /// Provides unique identifers for the caching system so we can retrieve this set of targets 
+        /// Provides unique identifers for the caching system so we can retrieve this set of targets
         /// at a later time. This list should be either a null array or a list of strings which are not null.
         /// </summary>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index 35a9bf9fcf2..876aea82f2e 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -24,7 +24,7 @@ public class BuildTask
     {
         #region Member Data
 
-        // The task XML element, if this is a persisted target.  
+        // The task XML element, if this is a persisted target.
         private XmlElement taskElement = null;
 
         // This is the "Condition" attribute on the task element.
@@ -93,14 +93,14 @@ bool importedFromAnotherProject
                         this.continueOnErrorAttribute = taskAttribute;
                         break;
 
-                    // this only makes sense in the context of the new OM, 
-                    // so just ignore it.  
+                    // this only makes sense in the context of the new OM,
+                    // so just ignore it.
                     case XMakeAttributes.msbuildRuntime:
                         // do nothing
                         break;
 
-                    // this only makes sense in the context of the new OM, 
-                    // so just ignore it.  
+                    // this only makes sense in the context of the new OM,
+                    // so just ignore it.
                     case XMakeAttributes.msbuildArchitecture:
                         // do nothing
                         break;
@@ -152,7 +152,7 @@ public string Condition
 
             set
             {
-                // If this Task object is not actually represented by a 
+                // If this Task object is not actually represented by a
                 // task element in the project file, then do not allow
                 // the caller to set the condition.
                 error.VerifyThrowInvalidOperation(this.taskElement != null,
@@ -196,7 +196,7 @@ public bool ContinueOnError
 
             set
             {
-                // If this Task object is not actually represented by a 
+                // If this Task object is not actually represented by a
                 // task element in the project file, then do not allow
                 // the caller to set the attribute.
                 error.VerifyThrowInvalidOperation(this.taskElement != null,
diff --git a/src/Deprecated/Engine/Engine/CacheManager.cs b/src/Deprecated/Engine/Engine/CacheManager.cs
index 5dab13cb787..0d9d9c19f37 100644
--- a/src/Deprecated/Engine/Engine/CacheManager.cs
+++ b/src/Deprecated/Engine/Engine/CacheManager.cs
@@ -28,8 +28,8 @@ internal enum CacheContentType
     }
 
     /// <summary>
-    /// This class is responsible for maintaining the set of object 
-    /// cached during a build session. This class is not thread safe and 
+    /// This class is responsible for maintaining the set of object
+    /// cached during a build session. This class is not thread safe and
     /// is intended to be used from the Engine thread.
     /// </summary>
     internal class CacheManager
diff --git a/src/Deprecated/Engine/Engine/CacheScope.cs b/src/Deprecated/Engine/Engine/CacheScope.cs
index 99891eac6e5..5ddeae99288 100644
--- a/src/Deprecated/Engine/Engine/CacheScope.cs
+++ b/src/Deprecated/Engine/Engine/CacheScope.cs
@@ -20,9 +20,9 @@ namespace Microsoft.Build.BuildEngine
     /// threads. It is also lock free for multiple readers (via use of Hashtable as
     /// the backing store).
     /// We use a ReaderWriterLock in here so that when a request comes in for multiple
-    /// cache entries we guarantee that all the entries come from a consistent view of 
+    /// cache entries we guarantee that all the entries come from a consistent view of
     /// the cache at some point in time. Without a lock we might get a write in between
-    /// the reads and half of the entries would represent the values before the write and 
+    /// the reads and half of the entries would represent the values before the write and
     /// the rest after. This is unacceptable as at no point in time the cache actually contained
     /// the entries that would be returned without the lock. This is required by the caching APIs
     /// provided to the tasks which support retrieving multiple entries at once.
@@ -36,7 +36,7 @@ internal class CacheScope
         /// </summary>
         internal CacheScope(string scopeName, BuildPropertyGroup scopeProperties, string scopeToolsVersion)
         {
-            // Make certain we don't cache a reference to a Project object, which would defeat 
+            // Make certain we don't cache a reference to a Project object, which would defeat
             // the purpose of this cache
             scopeProperties.ClearParentProject();
 
@@ -215,7 +215,7 @@ internal void ClearCacheEntry(string name)
         }
 
         /// <summary>
-        /// This method returns true if the cache entry for a given name is present in the cache. 
+        /// This method returns true if the cache entry for a given name is present in the cache.
         /// This method is thread safe.
         /// </summary>
         internal bool ContainsCacheEntry(string name)
@@ -231,7 +231,7 @@ internal void AddCacheEntryForBuildResults(BuildResult buildResult)
         {
             ErrorUtilities.VerifyThrow(buildResult != null, "Expect a non-null build result");
 
-            // Don't cache results if they are marked as uncacheable 
+            // Don't cache results if they are marked as uncacheable
             if (!buildResult.UseResultCache)
             {
                 return;
diff --git a/src/Deprecated/Engine/Engine/EngineCallback.cs b/src/Deprecated/Engine/Engine/EngineCallback.cs
index c296b99e327..a8bdfe7a632 100644
--- a/src/Deprecated/Engine/Engine/EngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/EngineCallback.cs
@@ -45,7 +45,7 @@ public void PostBuildRequestsToHost(BuildRequest[] buildRequests)
             if (buildRequests.Length > 0)
             {
                 // We can safely assume that all requests need to be routed to the same engine because
-                // they originated from the same task 
+                // they originated from the same task
                 for (int i = 0; i < buildRequests.Length; i++)
                 {
                     ProcessBuildRequest(buildRequests[i]);
@@ -133,7 +133,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                     {
                         ErrorUtilities.VerifyThrow(parentProject != null, "Parent project must be non-null");
 
-                        // This means the caller (the MSBuild task) wants us to use the same project as the calling 
+                        // This means the caller (the MSBuild task) wants us to use the same project as the calling
                         // project.  This allows people to avoid passing in the Projects parameter on the MSBuild task.
                         Project projectToBuild = parentProject;
 
@@ -216,7 +216,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
                 Console.WriteLine("Received result for HandleId " + buildResult.HandleId + ":" + buildResult.RequestId + " mapped to " + routingContext.ParentHandleId + ":" + routingContext.ParentRequestId);
             }
 
-            // Update the results with the original handle id and request id, so that 
+            // Update the results with the original handle id and request id, so that
             buildResult.HandleId = routingContext.ParentHandleId;
 
             // If the build result is created from a generated build request a done notice should be posted as other targets could be waiting for this target to finish
@@ -262,7 +262,7 @@ public void SetCacheEntries
             {
                 // Property values are compared using case sensitive comparisons because the case of property values do have meaning.
                 // In this case we are using properties in a manner where we do not want case sensitive comparisons.
-                // There is not enough benefit for this one special case to add case insensitive 
+                // There is not enough benefit for this one special case to add case insensitive
                 // comparisons to build properties. We instead uppercase all of the keys for both get and set CachedEntries.
                 scopeProperties = new BuildPropertyGroup();
                 scopeProperties.SetProperty("CacheKey", cacheKey.ToUpper(CultureInfo.InvariantCulture));
@@ -315,7 +315,7 @@ public CacheEntry[] GetCacheEntries
             {
                 // Property values are compared using case sensitive comparisons because the case of property values do have meaning.
                 // In this case we are using properties in a manner where we do not want case sensitive comparisons.
-                // There is not enough benefit for this one special case to add case insensitive 
+                // There is not enough benefit for this one special case to add case insensitive
                 // comparisons to build properties. We instead uppercase all of the keys for both get and set CachedEntries.
                 scopeProperties = new BuildPropertyGroup();
                 scopeProperties.SetProperty("CacheKey", cacheKey.ToUpper(CultureInfo.InvariantCulture));
@@ -364,7 +364,7 @@ public CacheEntry[] GetCacheEntries
         public void PostLoggingMessagesToHost(int nodeId, NodeLoggingEvent[] nodeLoggingEventArray)
         {
             // We can safely assume that all messages need to be routed to the same engine because
-            // they originated from the same task. This is true as long as we don't allow multiple engines within 
+            // they originated from the same task. This is true as long as we don't allow multiple engines within
             // a single process to utilize external nodes.
             if (nodeLoggingEventArray.Length > 0)
             {
diff --git a/src/Deprecated/Engine/Engine/EngineCommand.cs b/src/Deprecated/Engine/Engine/EngineCommand.cs
index 5dd38dd9f98..f07861b2d3d 100644
--- a/src/Deprecated/Engine/Engine/EngineCommand.cs
+++ b/src/Deprecated/Engine/Engine/EngineCommand.cs
@@ -102,9 +102,9 @@ internal override void Execute(Engine parentEngine)
     internal class ChangeTraversalTypeCommand : EngineCommand
     {
         /// <summary>
-        /// Create a command that will switch the traversal of the system to breadthFirst traversal or depth first traveral. 
-        /// changeLocalTraversalOnly is used to determine whether or not to change the traversal for the whole system or only the current node. 
-        /// changeLocalTraversalOnly is set to true in the when a node is first started and in the updateNodeSettings method as these traversal changes are for the local node only. The reason 
+        /// Create a command that will switch the traversal of the system to breadthFirst traversal or depth first traveral.
+        /// changeLocalTraversalOnly is used to determine whether or not to change the traversal for the whole system or only the current node.
+        /// changeLocalTraversalOnly is set to true in the when a node is first started and in the updateNodeSettings method as these traversal changes are for the local node only. The reason
         /// is because updateNodeSettings is called when the parent has told the node to switch traversal types, there is no need to forward the change to the engine again.
         /// Also, when a node starts up it is set to breadth first traversal, this is the default so the parent engine need not be notified of this change.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index c07525b9d17..018b94a2ae6 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// This abstract class defines a logging service, provided by the engine, for internal logging 
+    /// This abstract class defines a logging service, provided by the engine, for internal logging
     /// purposes. This class is very different from the IBuildEngine interface which provides logging
     /// services for tasks. This class allows for better encapsulation by making it clear when only
     /// logging services are needed and not the rest of the engine data and methods. This class allows
@@ -232,7 +232,7 @@ internal virtual bool NeedsFlush(long currentTickCount)
         /// Raises ErrorEvent and AnyEvent at all registered loggers.
         /// </summary>
         /// <owner>t-jeffv, SumedhK</owner>
-        /// <param name="e"></param> 
+        /// <param name="e"></param>
         internal void LogErrorEvent(BuildErrorEventArgs e)
         {
             // We are intentionally passing in null for the "sender" object, even when
@@ -240,7 +240,7 @@ internal void LogErrorEvent(BuildErrorEventArgs e)
             // tight coupling between loggers and tasks in this way.  It's not good
             // for a logger to be able to call back into a task.  It could be a security
             // issue, and it apparently will also cause us problems if we adopt the
-            // new Longhorn Add-In Programming Model.  
+            // new Longhorn Add-In Programming Model.
 
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             PostLoggingEvent(e);
@@ -250,7 +250,7 @@ internal void LogErrorEvent(BuildErrorEventArgs e)
         /// Raises MessageEvent and AnyEvent at all registered loggers.
         /// </summary>
         /// <owner>t-jeffv, SumedhK</owner>
-        /// <param name="e"></param> 
+        /// <param name="e"></param>
         internal void LogMessageEvent(BuildMessageEventArgs e)
         {
             if (!OnlyLogCriticalEvents)
@@ -271,7 +271,7 @@ internal void LogMessageEvent(BuildMessageEventArgs e)
         /// Raises WarningEvent and AnyEvent at all registered loggers.
         /// </summary>
         /// <owner>t-jeffv, SumedhK</owner>
-        /// <param name="e"></param> 
+        /// <param name="e"></param>
         internal void LogWarningEvent(BuildWarningEventArgs e)
         {
             // We are intentionally passing in null for the "sender" object, even when
@@ -289,7 +289,7 @@ internal void LogWarningEvent(BuildWarningEventArgs e)
         /// Raises CustomEvent and AnyEvent at all registered loggers.
         /// </summary>
         /// <owner>t-jeffv, SumedhK</owner>
-        /// <param name="e"></param> 
+        /// <param name="e"></param>
         internal void LogCustomEvent(CustomBuildEventArgs e)
         {
             // We are intentionally passing in null for the "sender" object, even when
@@ -978,7 +978,7 @@ internal bool FlushBuildEventsImmediatly
         protected bool flushBuildEventsImmediatly;
 
         /// <summary>
-        /// A dual queue which allows for one reader multiple writer access (used to receive events from 
+        /// A dual queue which allows for one reader multiple writer access (used to receive events from
         /// the engine and the TEM)
         /// </summary>
         protected DualQueue<BuildEventArgs> loggingQueueOfBuildEvents;
@@ -1008,7 +1008,7 @@ internal bool FlushBuildEventsImmediatly
         protected bool requestedQueueFlush;
 
         /// <summary>
-        /// An event used to request a flush of the logging service. Typically triggered due to 
+        /// An event used to request a flush of the logging service. Typically triggered due to
         /// a spike in logging activity.
         /// </summary>
         protected ManualResetEvent flushRequestEvent;
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
index 6e9885a4a92..24f9abb42e4 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
@@ -102,7 +102,7 @@ internal override bool ProcessPostedLoggingEvents()
         }
 
         /// <summary>
-        /// This method process a single BuildEvent argument, it will raise the event to registered loggers and 
+        /// This method process a single BuildEvent argument, it will raise the event to registered loggers and
         /// check to see if the there are forwarding loggers who need to see the event also, if so the message will
         /// be posted to another logger
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
index de4d5685304..61eb63a4541 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
@@ -47,10 +47,10 @@ internal EngineLoggingServicesOutProc(Node parentNode, ManualResetEvent flushReq
 
         /// <summary>
         /// The out of proc logging service is concerned with flushing the events out to the node provider
-        /// to be sent to the parent engine. Events which are not marked with a logger id end up being wrapped 
+        /// to be sent to the parent engine. Events which are not marked with a logger id end up being wrapped
         /// in a NodeLoggingEvent which was a default loggerId of 0. All events posted as BuildEventArgs fall
         /// into this category. Events with a loggerId need be posted as NodeLoggerEventWithLoggerId objects.
-        /// This function is thread safe and is called both from the engine thread and communication threads to 
+        /// This function is thread safe and is called both from the engine thread and communication threads to
         /// ensure that the events are delivered in coherent order.
         /// </summary>
         internal override bool ProcessPostedLoggingEvents()
@@ -76,7 +76,7 @@ internal override bool ProcessPostedLoggingEvents()
                     processedEvents = true;
                 }
 
-                // Grab all the forwarded events 
+                // Grab all the forwarded events
                 NodeLoggingEvent nodeLoggingEvent = null;
                 while ((nodeLoggingEvent = loggingQueueOfNodeEvents.Dequeue()) != null)
                 {
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index 1adb71454fd..be9ddf33e89 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -156,7 +156,7 @@ public void LogErrorEvent(BuildErrorEventArgs e)
 
             if (ContinueOnError)
             {
-                // Convert the error into a warning.  We do this because the whole point of 
+                // Convert the error into a warning.  We do this because the whole point of
                 // ContinueOnError is that a project author expects that the task might fail,
                 // but wants to ignore the failures.  This implies that we shouldn't be logging
                 // errors either, because you should never have a successful build with errors.
@@ -225,7 +225,7 @@ public void LogWarningEvent(BuildWarningEventArgs e)
             {
                 // We'd like to add the project file to the message, but since this property
                 // is read-only on the BuildWarningEventArgs type, this requires creating a new
-                // instance.  However, if some task logged a custom warning type, we don't want 
+                // instance.  However, if some task logged a custom warning type, we don't want
                 // to impolitely throw the custom type data away.
 
                 string message = GetUpdatedMessage(e.File, e.Message, parentProjectFullFileName);
@@ -562,7 +562,7 @@ public override object InitializeLifetimeService()
             ILease lease = (ILease)base.InitializeLifetimeService();
 
             // Set how long a lease should be initially. Once a lease expires
-            // the remote object will be disconnected and it will be marked as being availiable 
+            // the remote object will be disconnected and it will be marked as being availiable
             // for garbage collection
             int initialLeaseTime = 1;
 
@@ -584,7 +584,7 @@ public override object InitializeLifetimeService()
             // increase the lease time allowing the object to stay in memory
             sponsor = new ClientSponsor();
 
-            // When a new lease is requested lets make it last 1 minutes longer. 
+            // When a new lease is requested lets make it last 1 minutes longer.
             int leaseExtensionTime = 1;
 
             string leaseExtensionTimeFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDENGINEPROXYLEASEEXTENSIONTIME");
diff --git a/src/Deprecated/Engine/Engine/EventSource.cs b/src/Deprecated/Engine/Engine/EventSource.cs
index 08ae814e058..7428ad2d1e5 100644
--- a/src/Deprecated/Engine/Engine/EventSource.cs
+++ b/src/Deprecated/Engine/Engine/EventSource.cs
@@ -650,8 +650,8 @@ internal void RaiseStronglyTypedEvent(BuildEventArgs e)
         public event CustomBuildEventHandler CustomEventRaised;
 
         /// <summary>
-        /// this event is raised to log build status events, such as 
-        /// build/project/target/task started/stopped 
+        /// this event is raised to log build status events, such as
+        /// build/project/target/task started/stopped
         /// </summary>
         /// <owner> t-jeffv, sumedhk </owner>
         public event BuildStatusEventHandler StatusEventRaised;
diff --git a/src/Deprecated/Engine/Engine/ExecutionContext.cs b/src/Deprecated/Engine/Engine/ExecutionContext.cs
index ef68b9c8f8c..026de371572 100644
--- a/src/Deprecated/Engine/Engine/ExecutionContext.cs
+++ b/src/Deprecated/Engine/Engine/ExecutionContext.cs
@@ -41,7 +41,7 @@ internal int HandleId
         }
 
         /// <summary>
-        /// The node on which this context is being executed 
+        /// The node on which this context is being executed
         /// </summary>
         internal int NodeIndex
         {
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index 3255c4ce3a0..bb29943dc58 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -36,7 +36,7 @@ internal class Expander
         // instead of using the overhead of a lookup
         private BuildPropertyGroup properties;
 
-        // Table of metadata values. 
+        // Table of metadata values.
         // May have some qualified keys (type.name) or all unqualified.
         // If all unqualified, the implicitMetadataItemType field indicates the type.
         private Dictionary<string, string> itemMetadata;
@@ -211,8 +211,8 @@ XmlAttribute expressionAttribute
 
         /// <summary>
         /// Expands item metadata, properties, and items (in that order), and produces a list of TaskItems.
-        /// 
-        /// All data accessed through the TaskItem (ItemSpec and metadata) is going to be unescaped, so it's nice 
+        ///
+        /// All data accessed through the TaskItem (ItemSpec and metadata) is going to be unescaped, so it's nice
         /// and ready for a task to consume.
         /// </summary>
         /// <param name="expression"></param>
@@ -463,7 +463,7 @@ XmlNode expressionNode
             // where we've essentially read up to and copied into the target string.
             int sourceIndex = 0;
 
-            // Search for "$(" in the sourceString.  Loop until we don't find it 
+            // Search for "$(" in the sourceString.  Loop until we don't find it
             // any more.
             while (propertyStartIndex != -1)
             {
@@ -496,9 +496,9 @@ XmlNode expressionNode
                 {
                     // Aha, we found the closing parenthesis.  All the stuff in
                     // between the "$(" and the ")" constitutes the property body.
-                    // Note: Current propertyStartIndex points to the "$", and 
+                    // Note: Current propertyStartIndex points to the "$", and
                     // propertyEndIndex points to the ")".  That's why we have to
-                    // add 2 for the start of the substring, and subtract 2 for 
+                    // add 2 for the start of the substring, and subtract 2 for
                     // the length.
                     string propertyBody = expression.Substring(propertyStartIndex + 2, propertyEndIndex - propertyStartIndex - 2);
 
@@ -525,7 +525,7 @@ XmlNode expressionNode
                         propertyValue = LookupProperty(properties, propertyBody, expressionNode);
                     }
 
-                    // If it's a property function result, it may return null, so check before we add it.  
+                    // If it's a property function result, it may return null, so check before we add it.
                     if (propertyValue != null)
                     {
                         // Append the property value to our targetString, and advance
@@ -553,7 +553,7 @@ XmlNode expressionNode
                 // PERF: This method is called very often - of the order of 3,000 times per project.
                 // StringBuilder by default is initialized with a 16 char string and doubles the length
                 // whenever it's too short. We want to avoid reallocation but also avoid excessive allocation.
-                // The length of the source string turns out to be a fair compromise. (The final result may 
+                // The length of the source string turns out to be a fair compromise. (The final result may
                 // be longer or it may be shorter.)
                 StringBuilder result = new StringBuilder(expression.Length);
 
@@ -759,7 +759,7 @@ private object ExpandPropertyBody(string propertyBody, object propertyValue, Bui
                 }
             }
 
-            // Find the property value in our property collection.  This 
+            // Find the property value in our property collection.  This
             // will automatically return "" (empty string) if the property
             // doesn't exist in the collection, and we're not executing a static function
             if (!String.IsNullOrEmpty(propertyName))
@@ -1180,10 +1180,10 @@ public object Execute(Expander expander, object objectInstance, BuildPropertyGro
                     }
 
                     // Handle special cases where the object type needs to affect the choice of method
-                    // The default binder and method invoke, often chooses the incorrect Equals and CompareTo and 
+                    // The default binder and method invoke, often chooses the incorrect Equals and CompareTo and
                     // fails the comparison, because what we have on the right is generally a string.
                     // This special casing is to realize that its a comparison that is taking place and handle the
-                    // argument type coercion accordingly; effectively pre-preparing the argument type so 
+                    // argument type coercion accordingly; effectively pre-preparing the argument type so
                     // that it matches the left hand side ready for the default binder�s method invoke.
                     if (objectInstance != null && args.Length == 1 && (String.Equals("Equals", this.name, StringComparison.OrdinalIgnoreCase) || String.Equals("CompareTo", this.name, StringComparison.OrdinalIgnoreCase)))
                     {
@@ -1215,7 +1215,7 @@ public object Execute(Expander expander, object objectInstance, BuildPropertyGro
                             if ((bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                             {
                                 // The standard binder failed, so do our best to coerce types into the arguments for the function
-                                // This may happen if the types need coercion, but it may also happen if the object represents a type that contains open type parameters, that is, ContainsGenericParameters returns true. 
+                                // This may happen if the types need coercion, but it may also happen if the object represents a type that contains open type parameters, that is, ContainsGenericParameters returns true.
                                 functionResult = LateBindExecute(ex, bindingFlags, objectInstance, args, false /* is not constructor */);
                             }
                             else
@@ -1668,7 +1668,7 @@ private static void AddArgument(List<string> arguments, StringBuilder argumentBu
                 // becomes possible through an empty argument between commas.
                 ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, nameof(argumentBuilder));
                 // we reached the end of an argument, add the builder's final result
-                // to our arguments. 
+                // to our arguments.
                 string argValue = argumentBuilder.ToString().Trim();
                 // We support passing of null through the argument constant value null
                 if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
@@ -1717,7 +1717,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                             // We'll also allow the user to specify the leaf or full type name on the enum
                             string argument = args[n].ToString().Replace('|', ',').Replace(typeFullName, "").Replace(typeLeafName, "");
 
-                            // Parse the string representation of the argument into the destination enum                                
+                            // Parse the string representation of the argument into the destination enum
                             coercedArguments[n] = Enum.Parse(enumType, argument);
                         }
                         else
@@ -1869,7 +1869,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
 
         /// <summary>
         /// Expands all embedded item metadata in the given string, using the bucketed items.
-        /// 
+        ///
         /// This method leaves the expression escaped.  Callers may need to unescape on their own as appropriate.
         /// </summary>
         /// <remarks>
diff --git a/src/Deprecated/Engine/Engine/IEngineCallback.cs b/src/Deprecated/Engine/Engine/IEngineCallback.cs
index cb5b1969340..46dbdc61083 100644
--- a/src/Deprecated/Engine/Engine/IEngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/IEngineCallback.cs
@@ -20,7 +20,7 @@ internal interface IEngineCallback
         void PostBuildRequestsToHost(BuildRequest[] buildRequests);
 
         /// <summary>
-        /// This method is called to send results to the parent engine in response to an earlier 
+        /// This method is called to send results to the parent engine in response to an earlier
         /// build request.
         /// </summary>
         /// <param name="buildResult"></param>
diff --git a/src/Deprecated/Engine/Engine/INodeProvider.cs b/src/Deprecated/Engine/Engine/INodeProvider.cs
index 9ae4d575f26..0f5e2d6106a 100644
--- a/src/Deprecated/Engine/Engine/INodeProvider.cs
+++ b/src/Deprecated/Engine/Engine/INodeProvider.cs
@@ -9,10 +9,10 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This interface is used by to provide an engine coordinating a build with access
-    /// to child engines which can execute parts of the build. The provider is entirely 
+    /// to child engines which can execute parts of the build. The provider is entirely
     /// responsible for establishing and maintaining the communication between the parent
-    /// engine and the child engines. The provider is also responsible for describing the 
-    /// capabilities of the communication channel and the machines on which the child engines 
+    /// engine and the child engines. The provider is also responsible for describing the
+    /// capabilities of the communication channel and the machines on which the child engines
     /// are running so that the parent engine can schedule and coordinate the work appropriately
     /// </summary>
     internal interface INodeProvider
@@ -31,9 +31,9 @@ void Initialize(string configuration, IEngineCallback engineCallback, BuildPrope
                         ToolsetDefinitionLocations toolsetSearchLocations, string startupDirectory);
 
         /// <summary>
-        /// This method is called by the NodeManager after the Initialize method to query 
+        /// This method is called by the NodeManager after the Initialize method to query
         /// the provider about number and capability of the nodes that it can make available to
-        /// the parent engine. 
+        /// the parent engine.
         /// </summary>
         /// <returns>Description of nodes that this provider</returns>
         INodeDescription[] QueryNodeDescriptions();
@@ -47,7 +47,7 @@ void Initialize(string configuration, IEngineCallback engineCallback, BuildPrope
         void AssignNodeIdentifiers(int[] nodeIdentifiers);
 
         /// <summary>
-        /// This method is called by the NodeManager to pass in a description of a forwarding logger 
+        /// This method is called by the NodeManager to pass in a description of a forwarding logger
         /// that should be loaded on the nodes exposed by the provider. This method can only be called
         /// after Initialize method has been called.
         /// </summary>
@@ -64,7 +64,7 @@ void Initialize(string configuration, IEngineCallback engineCallback, BuildPrope
         void PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest);
 
         /// <summary>
-        /// This method is called by the coordinating engine to send results requested by a 
+        /// This method is called by the coordinating engine to send results requested by a
         /// node during intermediate evaluation
         /// </summary>
         /// <param name="nodeIndex"></param>
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index 30b2bc929a9..e38ed53576e 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -116,7 +116,7 @@ internal static string Unescape(string escaped)
         }
 
         /// <summary>
-        /// Perform a bitwise OR on the first and second (first | second) 
+        /// Perform a bitwise OR on the first and second (first | second)
         /// </summary>
         internal static int BitwiseOr(int first, int second)
         {
@@ -124,7 +124,7 @@ internal static int BitwiseOr(int first, int second)
         }
 
         /// <summary>
-        /// Perform a bitwise AND on the first and second (first &amp; second) 
+        /// Perform a bitwise AND on the first and second (first &amp; second)
         /// </summary>
         internal static int BitwiseAnd(int first, int second)
         {
@@ -132,7 +132,7 @@ internal static int BitwiseAnd(int first, int second)
         }
 
         /// <summary>
-        /// Perform a bitwise XOR on the first and second (first ^ second) 
+        /// Perform a bitwise XOR on the first and second (first ^ second)
         /// </summary>
         internal static int BitwiseXor(int first, int second)
         {
@@ -140,7 +140,7 @@ internal static int BitwiseXor(int first, int second)
         }
 
         /// <summary>
-        /// Perform a bitwise NOT on the first and second (~first) 
+        /// Perform a bitwise NOT on the first and second (~first)
         /// </summary>
         internal static int BitwiseNot(int first)
         {
@@ -225,11 +225,11 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         }
 
         /// <summary>
-        /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location. 
+        /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
         /// Throws UriFormatException.
         /// </summary>
         /// <param name="basePath">
-        /// The base path we want to relativize to. Must be absolute.  
+        /// The base path we want to relativize to. Must be absolute.
         /// Should <i>not</i> include a filename as the last segment will be interpreted as a directory.
         /// </param>
         /// <param name="path">
@@ -297,11 +297,11 @@ internal static string ValueOrDefault(string conditionValue, string defaultValue
 
         /// <summary>
         /// Returns true if a task host exists that can service the requested runtime and architecture
-        /// values, and false otherwise. 
+        /// values, and false otherwise.
         /// </summary>
         /// <comments>
         /// The old engine ignores the concept of the task host entirely, so it shouldn't really
-        /// matter what we return.  So we return "true" because regardless of the task host parameters, 
+        /// matter what we return.  So we return "true" because regardless of the task host parameters,
         /// the task will be successfully run (in-proc).
         /// </comments>
         internal static bool DoesTaskHostExist(string runtime, string architecture)
diff --git a/src/Deprecated/Engine/Engine/ItemBucket.cs b/src/Deprecated/Engine/Engine/ItemBucket.cs
index 6cd83a31170..708426b1251 100644
--- a/src/Deprecated/Engine/Engine/ItemBucket.cs
+++ b/src/Deprecated/Engine/Engine/ItemBucket.cs
@@ -34,10 +34,10 @@ internal sealed class ItemBucket : IComparable
         private Lookup lookup;
 
         /// <summary>
-        /// When buckets are being created for batching purposes, this indicates which order the 
+        /// When buckets are being created for batching purposes, this indicates which order the
         /// buckets were created in, so that the target/task being batched gets called with the items
         /// in the same order as they were declared in the project file.  For example, the first
-        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets 
+        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
         private int bucketSequenceNumber;
@@ -147,10 +147,10 @@ internal Expander Expander
         }
 
         /// <summary>
-        /// When buckets are being created for batching purposes, this indicates which order the 
+        /// When buckets are being created for batching purposes, this indicates which order the
         /// buckets were created in, so that the target/task being batched gets called with the items
         /// in the same order as they were declared in the project file.  For example, the first
-        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets 
+        /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
         /// <owner>RGoel</owner>
diff --git a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
index 896a869526c..d6e579757fb 100644
--- a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
+++ b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
@@ -67,7 +67,7 @@ internal BuildEventArgs BuildEvent
         }
 
         /// <summary>
-        /// The ID of the central logger to which this event should be forwarded. By default 
+        /// The ID of the central logger to which this event should be forwarded. By default
         /// all regular non-forwarded events are sent to all loggers registered on the parent.
         /// </summary>
         internal virtual int LoggerId
diff --git a/src/Deprecated/Engine/Engine/NodeManager.cs b/src/Deprecated/Engine/Engine/NodeManager.cs
index 72dd15b4ae6..5846767cc00 100644
--- a/src/Deprecated/Engine/Engine/NodeManager.cs
+++ b/src/Deprecated/Engine/Engine/NodeManager.cs
@@ -218,7 +218,7 @@ internal void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
                     // At this point we have nulled out the task execution module and have told our task worker threads to exit
                     // we do not want the engine build loop to continue to do any work becasue the operations of the build loop
                     // require the task execution module in many cases. Before this fix, when the engine build loop was allowed
-                    // to do work after the task execution module we would get random null reference excetpions depending on 
+                    // to do work after the task execution module we would get random null reference excetpions depending on
                     // what was the first line to use the TEM after it was nulled out.
                     parentEngine.SetEngineAbortTo(true);
                 }
diff --git a/src/Deprecated/Engine/Engine/NodeWorkerThread.cs b/src/Deprecated/Engine/Engine/NodeWorkerThread.cs
index 4486e5be236..9f739801664 100644
--- a/src/Deprecated/Engine/Engine/NodeWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/NodeWorkerThread.cs
@@ -86,7 +86,7 @@ internal ManualResetEvent LocalDoneNoticeEvent
 
         /// <summary>
         /// This a base loop of a worker thread. The worker thread is asleep waiting for either an
-        /// event indicating that it should shut down or that it should become active and take 
+        /// event indicating that it should shut down or that it should become active and take
         /// ownership of the work item queue
         /// </summary>
         private void MainThreadLoop()
@@ -283,7 +283,7 @@ private void NodeActionLoop(NodeLoopExecutionMode executionMode, int nodeProxyId
                 else if (eventType == 1 && executionMode == NodeLoopExecutionMode.WaitingPassiveThread ||
                          eventType == 2 && executionMode == NodeLoopExecutionMode.WaitingActiveThread)
                 {
-                    // There maybe multiple results in the list so we need to loop over it 
+                    // There maybe multiple results in the list so we need to loop over it
                     // and store the results
                     int originalResultCount = resultCount;
                     lock (targetEvaluationResults)
@@ -291,7 +291,7 @@ private void NodeActionLoop(NodeLoopExecutionMode executionMode, int nodeProxyId
                         //Console.WriteLine("Worker thread for: " + nodeProxyId + " Got results");
                         LinkedListNode<BuildResult> currentNode = targetEvaluationResults.First;
                         while (currentNode != null)
-                        {   
+                        {
                             BuildResult buildResult = currentNode.Value;
                             ErrorUtilities.VerifyThrow(
                                             buildResult.RequestId < requestResults.Length,
@@ -315,7 +315,7 @@ private void NodeActionLoop(NodeLoopExecutionMode executionMode, int nodeProxyId
                     }
                 }
                 // Check if we need to update the state
-                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive) 
+                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive)
                 {
                     continueExecution = false;
                 }
@@ -364,7 +364,7 @@ internal void ActivateThread()
         internal static void WaitForResults(int nodeProxyId, BuildResult[] requestResults)
         {
             TaskWorkerThread workerThread = TaskWorkerThread.GetWorkerThreadForProxyId(nodeProxyId);
-            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread : 
+            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread :
                                         NodeLoopExecutionMode.WaitingPassiveThread,
                                         nodeProxyId, requestResults);
         }
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index e99d8f5961b..4f16c9086b6 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -80,7 +80,7 @@ public class Project
 
         // We need to know if the projectContextId which was generated during the
         // instantiation of the project instance has been used. If the Id has been used,
-        // which would make the value true, we will then generate a new projectContextId 
+        // which would make the value true, we will then generate a new projectContextId
         // on the next project started event
         private bool haveUsedInitialProjectContextId;
 
@@ -607,7 +607,7 @@ public string InitialTargets
         {
             get
             {
-                // Return the concatenation of the initial target names from the main project and the ones from 
+                // Return the concatenation of the initial target names from the main project and the ones from
                 // all the imported projects.  Join target names together with semicolons in between.
                 return String.Join("; ", (string[])this.CombinedInitialTargetNames.ToArray(typeof(string)));
             }
@@ -782,7 +782,7 @@ public string ToolsVersion
         {
             get
             {
-                // We could have a toolsversion already (either from the Project element, or 
+                // We could have a toolsversion already (either from the Project element, or
                 // from an externally set override value). If not, read it off the Project
                 // element now
                 if (!OverridingToolsVersion)
@@ -2753,7 +2753,7 @@ string itemInclude
                     {
                         if (String.Equals(originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
                         {
-                            // If the new item that the user is trying to add is already covered by 
+                            // If the new item that the user is trying to add is already covered by
                             // a wildcard in an existing item of the project, then there's really
                             // no need to physically touch the project file.  As long as the new item
                             // is on disk, the next reevaluation will automatically pick it up.  When
@@ -2779,7 +2779,7 @@ string itemInclude
 
                                 // Don't bother adding to item lists by name, as we're going to have to evaluate the project as a whole later anyway
 
-                                // We haven't actually changed the XML for the project, because we're 
+                                // We haven't actually changed the XML for the project, because we're
                                 // just piggybacking onto an existing item that was a wildcard.  However,
                                 // we should reevaluate on the next build.
                                 this.MarkProjectAsDirtyForReevaluation();
@@ -3283,7 +3283,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                      buildContext.CurrentBuildContextState != ProjectBuildState.BuildContextState.RequestFilled)
                 {
                     // If the target that threw an exception is being built due to an
-                    // dependson or onerror relationship, it is necessary to make sure 
+                    // dependson or onerror relationship, it is necessary to make sure
                     // the buildrequests waiting on targets below it get notified of the failure. In single
                     // threaded mode there is only a single outstanding request so this issue is avoided.
                     if (exitedDueToError)
@@ -3346,7 +3346,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
 
         internal void CalculateNextActionForProjectContext(ProjectBuildState buildContext)
         {
-            // If the build request has been already complete 
+            // If the build request has been already complete
             if (buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.RequestFilled)
             {
                 return;
@@ -3408,7 +3408,7 @@ internal void CalculateNextActionForProjectContext(ProjectBuildState buildContex
                             // Check if there are no more targets to run
                             if (buildContext.GetNextTarget() == null)
                             {
-                                // The request is complete 
+                                // The request is complete
                                 buildContext.RecordBuildCompletion(true);
                             }
                             else
@@ -3523,9 +3523,9 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                     // Flag the start of the project build.
                     //
                     // This also passes all the current properties/items and their values. The logger might want to use the
-                    // object it gets from this event to see updated property/item values later in the build: so be 
-                    // careful to use the original "evaluatedProperties" and "evaluatedItems" table, not the clone 
-                    // "EvaluatedProperties" or "EvaluatedItems" table. It's fine to pass these live tables, because we're 
+                    // object it gets from this event to see updated property/item values later in the build: so be
+                    // careful to use the original "evaluatedProperties" and "evaluatedItems" table, not the clone
+                    // "EvaluatedProperties" or "EvaluatedItems" table. It's fine to pass these live tables, because we're
                     // wrapping them in read-only proxies.
                     BuildPropertyGroup propertyGroupForStartedEvent = this.evaluatedProperties;
 
@@ -3848,7 +3848,7 @@ bool importedProject
 
             try
             {
-                // Make the correct project directory available. This is needed because it is 
+                // Make the correct project directory available. This is needed because it is
                 // used for evaluating "exists" in conditional expressions, for example on <Import> elements.
                 Project.PerThreadProjectDirectory = ProjectDirectory;
 
@@ -4279,7 +4279,7 @@ private void EvaluateProject(bool currentlyLoading)
                 }
                 finally
                 {
-                    // We reset the path back to the original value in case the 
+                    // We reset the path back to the original value in case the
                     // host is depending on the current directory to find projects
                     Project.PerThreadProjectDirectory = currentPerThreadProjectDirectory;
                 }
@@ -4376,7 +4376,7 @@ internal void AddToItemListByNameIgnoringCondition(BuildItem item)
             // used as a key into the overall hash table, is case-insensitive.
             BuildItemGroup itemListByNameIgnoringCondition = (BuildItemGroup)this.evaluatedItemsByNameIgnoringCondition[item.Name];
 
-            // If no such BuildItemGroup exists yet, create a new BuildItemGroup and add it to 
+            // If no such BuildItemGroup exists yet, create a new BuildItemGroup and add it to
             // the hashtable of ItemGroups by type.
             if (itemListByNameIgnoringCondition == null)
             {
@@ -4403,7 +4403,7 @@ internal void AddToItemListByName(BuildItem item)
             // used as a key into the overall hash table, is case-insensitive.
             BuildItemGroup itemListByName = (BuildItemGroup)this.evaluatedItemsByName[item.Name];
 
-            // If no such BuildItemGroup exists yet, create a new BuildItemGroup and add it to 
+            // If no such BuildItemGroup exists yet, create a new BuildItemGroup and add it to
             // the hashtable of ItemGroups by type.
             if (itemListByName == null)
             {
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index be2c64a3767..478876c6fe7 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class is used to maintain a state of execution of a build request. Once a build request is
-    /// received it is wrapped in this class 
+    /// received it is wrapped in this class
     /// </summary>
     [DebuggerDisplay("ProjectBuildState (NameOfTargetInProgress={NameOfTargetInProgress}, NameOfBlockingTarget={NameOfBlockingTarget}, BuildResult={BuildResult}, BuildComplete={BuildComplete})")]
     internal sealed class ProjectBuildState
@@ -152,7 +152,7 @@ internal string GetNextTarget()
         }
 
         /// <summary>
-        /// Remove the top blocking target 
+        /// Remove the top blocking target
         /// </summary>
         internal void RemoveBlockingTarget()
         {
@@ -161,7 +161,7 @@ internal void RemoveBlockingTarget()
         }
 
         /// <summary>
-        /// Add another blocking target 
+        /// Add another blocking target
         /// </summary>
         internal void AddBlockingTarget(string targetName)
         {
@@ -218,7 +218,7 @@ internal bool ContainsCycle(string name)
         }
 
         /// <summary>
-        /// This method return true if a given target name appears anywhere in the list of 
+        /// This method return true if a given target name appears anywhere in the list of
         /// blocking targets
         /// </summary>
         internal bool ContainsBlockingTarget(string name)
@@ -233,7 +233,7 @@ internal bool ContainsBlockingTarget(string name)
 
         /// <summary>
         /// This method is used by the target cycle detector to find the parent target for
-        /// the given target. The parent only exists if there is at least 1 
+        /// the given target. The parent only exists if there is at least 1
         /// blocking target. If there is less than 1 blocking target the parent is determined
         /// by the orgin of the build request that caused this build context.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/ProjectManager.cs b/src/Deprecated/Engine/Engine/ProjectManager.cs
index 3c4c1ad9e70..90d91d61884 100644
--- a/src/Deprecated/Engine/Engine/ProjectManager.cs
+++ b/src/Deprecated/Engine/Engine/ProjectManager.cs
@@ -58,7 +58,7 @@ string fullPath
         }
 
         /// <summary>
-        /// Searches our tables for a project with same full path, tools version, and global property settings 
+        /// Searches our tables for a project with same full path, tools version, and global property settings
         /// Removes particular project from the project manager.
         /// </summary>
         /// <param name="project"></param>
@@ -96,8 +96,8 @@ Project project
         }
 
         /// <summary>
-        /// Searches our tables for a project with same full path and global property settings 
-        /// as those passed in to the method.  
+        /// Searches our tables for a project with same full path and global property settings
+        /// as those passed in to the method.
         /// </summary>
         /// <param name="projectFileFullPath"></param>
         /// <param name="globalProperties"></param>
@@ -117,8 +117,8 @@ string toolsVersion
 
         /// <summary>
         /// Searches our tables for a project with same project id
-        /// as the one passed in to the method. Note this method is currently O(n) 
-        /// with the number of projects, so if it used on a hot code path it needs to 
+        /// as the one passed in to the method. Note this method is currently O(n)
+        /// with the number of projects, so if it used on a hot code path it needs to
         /// use an extra hashtable to achieve O(1).
         /// </summary>
         /// <param name="projectId"></param>
@@ -265,7 +265,7 @@ string toolsVersion
         #region Methods managing the record of unloaded projects
 
         /// <summary>
-        /// This function adds the project to the table of previously loaded projects, if it's 
+        /// This function adds the project to the table of previously loaded projects, if it's
         /// not already present.
         /// </summary>
         private void AddUnloadedProjectRecord
@@ -387,7 +387,7 @@ internal static Project GetProject(Hashtable table, string projectFileFullPath,
         }
 
         /// <summary>
-        /// Retrieve the project entry from the entry table based on project file name, globalProperties, and toolsVersion. 
+        /// Retrieve the project entry from the entry table based on project file name, globalProperties, and toolsVersion.
         /// </summary>
         internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projectFileFullPath, BuildPropertyGroup globalProperties, string toolsVersion)
         {
@@ -414,12 +414,12 @@ internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projec
         #region Data
         // This hash table tracks all the projects that are currently building,
         // or are being kept around from the last build for perf reasons (so
-        // we don't have to reload the same projects over and over in IDE 
+        // we don't have to reload the same projects over and over in IDE
         // scenarios.
         // The key for this hash table is the case-insensitive full path to the
         // project file.  The value in this hash table is an ArrayList of Project
         // objects that came from that full path.  The reason there could be
-        // multiple Project objects with the same full path is because they 
+        // multiple Project objects with the same full path is because they
         // may each be using a different set of global properties, and we can't
         // have them tromp on each other.
         private Hashtable projects;
@@ -431,7 +431,7 @@ internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projec
         private Hashtable unloadedProjects;
         #endregion
 
-        #region Helper class 
+        #region Helper class
         internal class ProjectEntry
         {
             internal BuildPropertyGroup globalProperties;
diff --git a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
index de94023867b..c7279efa3d0 100644
--- a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
+++ b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
@@ -124,7 +124,7 @@ string projectFile
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
 
-            // Log the schema file we're using, particularly since it can vary 
+            // Log the schema file we're using, particularly since it can vary
             // according to  the toolset being used
             engineLoggingServices.LogComment(buildEventContext, "SchemaFileLocation", schemaFile);
 
diff --git a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
index f7b892ae87e..7bbbd5d0915 100644
--- a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
+++ b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
@@ -15,7 +15,7 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// Thin wrapper around Microsoft.Win32.RegistryKey that can be 
+    /// Thin wrapper around Microsoft.Win32.RegistryKey that can be
     /// subclassed for testing purposes
     /// </summary>
     internal class RegistryKeyWrapper
diff --git a/src/Deprecated/Engine/Engine/RequestRoutingContext.cs b/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
index 958bbf9468e..c2d5e701a0a 100644
--- a/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
+++ b/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This context is created to contain information about a build request that has been forwarded to
-    /// a child node for execution. All further communication from the child with regard to the build 
+    /// a child node for execution. All further communication from the child with regard to the build
     /// request (such a logging messages, errors, follow up build requests or build result) will be
     /// processing using information from this context.
     /// </summary>
diff --git a/src/Deprecated/Engine/Engine/Router.cs b/src/Deprecated/Engine/Engine/Router.cs
index cd4de9d5bec..8b785aa17f1 100644
--- a/src/Deprecated/Engine/Engine/Router.cs
+++ b/src/Deprecated/Engine/Engine/Router.cs
@@ -39,7 +39,7 @@ internal Router(Engine parentEngine, Scheduler scheduler)
         #region Properties
 
         /// <summary>
-        /// Returns true on the child engine and false otherwise. this is used by the engine to determine if the engine is running on a child 
+        /// Returns true on the child engine and false otherwise. this is used by the engine to determine if the engine is running on a child
         /// process or not. The childMode is set to true in the NodeLocalEngineLoop which is only executed on a child process.
         /// </summary>
         internal bool ChildMode
@@ -90,12 +90,12 @@ internal bool SingleThreadedMode
         /// <summary>
         /// This method creates a BuildResult using the information contained in a completed build request and
         /// then routes it to the right node. On a child process, this means either consume the result localy,
-        /// or send it to the parent node. On a parent node, this means either consume the result locally or 
+        /// or send it to the parent node. On a parent node, this means either consume the result locally or
         /// send it to a child node
         /// </summary>
         internal void PostDoneNotice(BuildRequest buildRequest)
         {
-            // Create a container with the results of the evaluation 
+            // Create a container with the results of the evaluation
             BuildResult buildResult = buildRequest.GetBuildResult();
 
             // If we're supposed to use caching and this request wasn't restored from cache, cache it
@@ -105,7 +105,7 @@ internal void PostDoneNotice(BuildRequest buildRequest)
                 cacheScope.AddCacheEntryForBuildResults(buildResult);
             }
 
-            // an external request is any request that came from the parent engine, all requests to a child are external 
+            // an external request is any request that came from the parent engine, all requests to a child are external
             // unless the project was alredy loaded on the node itself
             if (buildRequest.IsExternalRequest)
             {
@@ -147,7 +147,7 @@ internal void PostDoneNotice(int nodeId, BuildResult buildResult)
 
         /// <summary>
         /// This method is called once the engine has decided to sent a build request to a child node.
-        /// Route the given BuildRequest to the given node. If necessary a routing context is 
+        /// Route the given BuildRequest to the given node. If necessary a routing context is
         /// created to manage future communication with the node regarding the build request.
         /// </summary>
         internal void PostBuildRequest(BuildRequest currentRequest, int nodeIndex)
@@ -212,6 +212,6 @@ internal void PostBuildRequest(BuildRequest currentRequest, int nodeIndex)
         /// What is the parent Node on which the engine is hosted if we are a child process
         /// </summary>
         private Node parentNode;
-        #endregion 
+        #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Engine/Scheduler.cs b/src/Deprecated/Engine/Engine/Scheduler.cs
index 0af5b3dbf00..5171c454631 100644
--- a/src/Deprecated/Engine/Engine/Scheduler.cs
+++ b/src/Deprecated/Engine/Engine/Scheduler.cs
@@ -112,7 +112,7 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
 
                         for (int i = 0; i < nodes.Length; i++)
                         {
-                            //postBlockCount indicates the number of projects which should be sent to a node to unblock it due to the 
+                            //postBlockCount indicates the number of projects which should be sent to a node to unblock it due to the
                             //node running out of work.
                             if (postBlockCount[i] != 0 && postBlockCount[i] < blockedNodeRemainingProjectCount)
                             {
@@ -157,7 +157,7 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
                     }
                     else
                     {
-                        // round robin schedule the build request 
+                        // round robin schedule the build request
                         nodeUsed = (lastUsedNode % nodes.Length);
 
                         // Running total of the number of times this round robin scheduler has been called
@@ -269,7 +269,7 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                         // Remove this build request from the list of requests the parent request is waiting on. This may unblock the parent request
                         parentRecord.ReportChildCompleted(recordKey);
 
-                        // If completing the child request has unblocked the parent request due to all of the the Child requests being completed 
+                        // If completing the child request has unblocked the parent request due to all of the the Child requests being completed
                         // decrement the number of blocked requests.
                         if (!parentRecord.Blocked)
                         {
@@ -305,7 +305,7 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
                     bool useBreadthFirstTraversal = false;
                     for (int i = 0; i < totalRequestsPerNode.Length; i++)
                     {
-                        // Continue using breadth-first traversal as long as the non-blocked work load for this node is below 
+                        // Continue using breadth-first traversal as long as the non-blocked work load for this node is below
                         // the nodeWorkloadProjectCount or its postBlockCount is non-zero
                         if ((totalRequestsPerNode[i] - blockedRequestsPerNode[i]) < nodeWorkLoadProjectCount || postBlockCount[i] != 0)
                         {
diff --git a/src/Deprecated/Engine/Engine/SchedulerRecord.cs b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
index 8695ba4205b..9113e2adf50 100644
--- a/src/Deprecated/Engine/Engine/SchedulerRecord.cs
+++ b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
@@ -41,7 +41,7 @@ string[] targetsBuild
 
         #region Properties
         /// <summary>
-        /// Returns true if this request is blocked waiting for the child requests to 
+        /// Returns true if this request is blocked waiting for the child requests to
         /// complete
         /// </summary>
         internal bool Blocked
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index 42435566ead..45612ae14d7 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -46,11 +46,11 @@ internal enum BuildState
             CompletedSuccessfully,
 
             // We have attempted to build this target and all its dependent
-            // targets.  However, something failed during that process, and 
+            // targets.  However, something failed during that process, and
             // we consider ourselves done with this target.
             CompletedUnsuccessfully,
 
-            // This target is to be skipped.  This state is the result of a target 
+            // This target is to be skipped.  This state is the result of a target
             // having a condition attribute and that condition evaluating to false.
             Skipped
         }
@@ -146,7 +146,7 @@ bool importedFromAnotherProject
             this.buildState = BuildState.NotStarted;
             this.id = project.ParentEngine.GetNextTargetId();
 
-            // The target name and target dependendencies (dependencies on other 
+            // The target name and target dependendencies (dependencies on other
             // targets) are specified as attributes of the <target> element.
 
             XmlAttribute returnsAttribute = null;
@@ -164,7 +164,7 @@ bool importedFromAnotherProject
                     case XMakeAttributes.name:
                         this.targetName = EscapingUtilities.UnescapeAll(targetAttribute.Value);
 
-                        // Target names cannot contain MSBuild special characters, embedded properties, 
+                        // Target names cannot contain MSBuild special characters, embedded properties,
                         // or item lists.
                         int indexOfSpecialCharacter = this.targetName.IndexOfAny(XMakeElements.illegalTargetNameCharacters);
                         if (indexOfSpecialCharacter >= 0)
@@ -204,7 +204,7 @@ bool importedFromAnotherProject
                         break;
 
                     // These are only recognized by the new OM:
-                    // while the solution wrapper generator is using 
+                    // while the solution wrapper generator is using
                     // the old OM to parse projects for dependencies,
                     // we must make sure to not fail for these
                     case XMakeAttributes.beforeTargets:
@@ -217,9 +217,9 @@ bool importedFromAnotherProject
                 }
             }
 
-            // Hack to help the 3.5 engine at least pretend to still be able to build on top of 
-            // the 4.0 targets.  In cases where there is no Outputs attribute, just a Returns attribute, 
-            // we can approximate the correct behaviour by making the Returns attribute our "outputs" attribute. 
+            // Hack to help the 3.5 engine at least pretend to still be able to build on top of
+            // the 4.0 targets.  In cases where there is no Outputs attribute, just a Returns attribute,
+            // we can approximate the correct behaviour by making the Returns attribute our "outputs" attribute.
             if (this.outputsAttribute == null && returnsAttribute != null)
             {
                 this.outputsAttribute = returnsAttribute;
@@ -506,7 +506,7 @@ internal TargetExecutionWrapper ExecutionState
         #region Methods
 
         /// <summary>
-        /// Allows the caller to use a foreach loop to enumerate through the individual 
+        /// Allows the caller to use a foreach loop to enumerate through the individual
         /// BuildTask objects contained within this Target.
         /// </summary>
         /// <returns></returns>
@@ -559,8 +559,8 @@ ProjectBuildState buildContext
             switch (buildState)
             {
                 case BuildState.InProgress:
-                    // In single proc mode if the build state was already "in progress" 
-                    // and somebody just told us to build ourselves, it means that there is 
+                    // In single proc mode if the build state was already "in progress"
+                    // and somebody just told us to build ourselves, it means that there is
                     // a loop (circular dependency) in the target dependency graph. In multi
                     // proc mode we need to analyze the dependency graph before we can
                     // tell if there a circular dependency or if two independent chains
@@ -593,7 +593,7 @@ ProjectBuildState buildContext
                         (buildState == BuildState.CompletedSuccessfully) ? "TargetAlreadyCompleteSuccess" : "TargetAlreadyCompleteFailure",
                         this.targetName);
 
-                    // Only contexts which are generated from an MSBuild task could need 
+                    // Only contexts which are generated from an MSBuild task could need
                     // the outputs of this target, such contexts have a non-null evaluation
                     // request
                     if ((buildState == BuildState.CompletedSuccessfully) &&
@@ -746,7 +746,7 @@ internal XmlAttribute SetOrRemoveTargetAttribute
             string attributeValue
             )
         {
-            // If this Target object is not actually represented by a 
+            // If this Target object is not actually represented by a
             // <Target> element in the parentProject.file, then do not allow
             // the caller to set the condition.
             error.VerifyThrowInvalidOperation(this.targetElement != null, "CannotSetCondition");
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index a936991ff67..a10b4ee96a5 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -127,7 +127,7 @@ public Target this[string index]
         #region Methods
 
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -160,7 +160,7 @@ public IEnumerator GetEnumerator
         /// <summary>
         /// Adds a new Target to our collection.  This method does nothing
         /// to manipulate the project's XML content.
-        /// If a target with the same name already exists, it is replaced by 
+        /// If a target with the same name already exists, it is replaced by
         /// the new one.
         /// </summary>
         /// <param name="newTarget">target to add</param>
@@ -196,7 +196,7 @@ string targetName
             this.targetTable[targetName] = newTarget;
 
             // The project file has been modified and needs to be saved and re-evaluated.
-            // Also though, adding/removing a target requires us to re-walk all the XML 
+            // Also though, adding/removing a target requires us to re-walk all the XML
             // in order to re-compute out the "first logical target" as well as re-compute
             // the target overriding rules.
             this.parentProject.MarkProjectAsDirtyForReprocessXml();
@@ -229,7 +229,7 @@ Target targetToRemove
             this.parentProject.ProjectElement.RemoveChild(targetToRemove.TargetElement);
 
             // Remove the target from our hashtable, if it exists.  It might not exist, and that's okay.
-            // The reason it might not exist is because of target overriding, and the fact that 
+            // The reason it might not exist is because of target overriding, and the fact that
             // our hashtable only stores the *last* target of a given name.
             if ((Target)this.targetTable[targetToRemove.Name] == targetToRemove)
             {
@@ -240,7 +240,7 @@ Target targetToRemove
             targetToRemove.ParentProject = null;
 
             // The project file has been modified and needs to be saved and re-evaluated.
-            // Also though, adding/removing a target requires us to re-walk all the XML 
+            // Also though, adding/removing a target requires us to re-walk all the XML
             // in order to re-compute the "first logical target" as well as re-compute
             // the target overriding rules.
             this.parentProject.MarkProjectAsDirtyForReprocessXml();
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index 3578916f165..61b57ba2378 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -208,14 +208,14 @@ out Hashtable upToDateTargetInputs
                          * At this point, we know the following:
                          * 1) the target has outputs
                          * 2) the target has NO discrete outputs
-                         * 
+                         *
                          * This implies:
                          * 1) the target only references vectors (incl. transforms) in its outputs
                          * 2) all vectors referenced in the outputs are also referenced in the inputs
                          * 3) the referenced vectors are not empty
-                         * 
+                         *
                          * We can thus conclude: the target MUST have (non-discrete) inputs
-                         * 
+                         *
                          */
                         ErrorUtilities.VerifyThrow(itemVectorsReferencedInBothTargetInputsAndOutputs.Count > 0, "The target must have inputs.");
                         Debug.Assert(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs).Count > 0, "The target must have inputs.");
@@ -755,8 +755,8 @@ ArrayList targetOutputItemSpecs
         /// each "partition" Hashtable is indexed by the item vector itself.
         /// </remarks>
         /// <owner>SumedhK</owner>
-        /// <param name="attributeContainingItems">The XML attribute which we're operating on here.  
-        /// The sole purpose of passing in this parameter is to be able to provide line/column number 
+        /// <param name="attributeContainingItems">The XML attribute which we're operating on here.
+        /// The sole purpose of passing in this parameter is to be able to provide line/column number
         /// information in the event there's an error.</param>
         /// <param name="items"></param>
         /// <param name="bucket"></param>
@@ -918,7 +918,7 @@ internal static bool IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAn
             // Algorithm: walk through all the outputs to find the oldest output
             //            walk through the inputs as far as we need to until we find one that's newer (if any)
 
-            // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely): 
+            // PERF -- we could change this to ensure that we walk the shortest list first (because we walk that one entirely):
             //         possibly the outputs list isn't actually the shortest list. However it always is the shortest
             //         in the cases I've seen, and adding this optimization would make the code hard to read.
 
@@ -1200,7 +1200,7 @@ private int CompareLastWriteTimes(string path1, string path2, out bool path1Does
 
         #endregion
 
-        // the project directory, all relative paths are 
+        // the project directory, all relative paths are
         // relative to here
         private string projectDirectory;
         // the target to analyze
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index b47e12001b6..84728a83d94 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -89,7 +89,7 @@ BuildEventContext targetBuildEventContext
 
         private bool haveRunANonIntrinsicTask = false;
 
-        // Lookup containing project content used to 
+        // Lookup containing project content used to
         // initialize the target batches
         private Lookup projectContent;
         private LookupEntry placeholderForClonedProjectContent;
@@ -139,9 +139,9 @@ internal void ContinueBuild
 
             try
             {
-                // In the single threaded mode we want to avoid looping all the way back to the 
+                // In the single threaded mode we want to avoid looping all the way back to the
                 // engine because there is no need for to be interruptable to address
-                // other build requests. Instead we loop inside this function untill the target is 
+                // other build requests. Instead we loop inside this function untill the target is
                 // fully built.
                 do
                 {
@@ -166,7 +166,7 @@ internal void ContinueBuild
                         ContinueBuildingErrorClause(buildContext);
                     }
 
-                    // In the single threaded mode we need to pull up the outputs of the previous 
+                    // In the single threaded mode we need to pull up the outputs of the previous
                     // step
                     if (parentEngine.Router.SingleThreadedMode &&
                         inProgressBuildState == InProgressBuildState.RunningTasks)
@@ -247,7 +247,7 @@ private void ContinueBuildingDependencies(ProjectBuildState buildContext)
                 return;
             }
 
-            // Now that the previous dependent target has been build we need to move to the next dependent target if 
+            // Now that the previous dependent target has been build we need to move to the next dependent target if
             // there is one
             currentDependentTarget++;
 
@@ -266,7 +266,7 @@ ProjectBuildState buildContext
                 string nameDependentTarget = dependsOnTargetNames[currentDependentTarget];
                 Target targetToBuild = parentProject.Targets[nameDependentTarget];
 
-                // If we couldn't find the dependent Target object, we have a problem. 
+                // If we couldn't find the dependent Target object, we have a problem.
                 ProjectErrorUtilities.VerifyThrowInvalidProject(targetToBuild != null, targetClass.DependsOnTargetsAttribute,
                     "TargetDoesNotExist", nameDependentTarget);
 
@@ -325,7 +325,7 @@ ProjectBuildState buildContext
                 string nameErrorTarget = onErrorTargets[currentErrorTarget];
                 Target targetToBuild = parentProject.Targets[nameErrorTarget];
 
-                // If we couldn't find the on error Target object, we have a problem. 
+                // If we couldn't find the on error Target object, we have a problem.
                 ProjectErrorUtilities.VerifyThrowInvalidProject(targetToBuild != null, targetElement,
                     "TargetDoesNotExist", nameErrorTarget);
 
@@ -434,7 +434,7 @@ bool startingFirstTask
             bool exitDueToError = true;
             try
             {
-                // If this is the first task - initialize for running it 
+                // If this is the first task - initialize for running it
                 if (startingFirstTask)
                 {
                     InitializeForRunningTargetBatches();
@@ -464,7 +464,7 @@ bool startingFirstTask
                         return;
                     }
 
-                    //Check if this was the last bucket 
+                    //Check if this was the last bucket
                     if (currentBucket == buckets.Count)
                     {
                         FinishRunningTargetBatches(buildContext);
@@ -569,7 +569,7 @@ private void InitializeForRunningSingleTargetBatch()
             if ((howToBuild != DependencyAnalysisResult.SkipNoInputs) &&
                 (howToBuild != DependencyAnalysisResult.SkipNoOutputs))
             {
-                // Within each target batch items are divided into lookup and execution; they must be 
+                // Within each target batch items are divided into lookup and execution; they must be
                 // kept separate: enforce this by cloning and entering scope
                 lookupForInference = bucket.Lookup;
                 lookupForExecution = bucket.Lookup.Clone();
@@ -691,7 +691,7 @@ private void ExecuteCurrentTask(ProjectBuildState buildContext)
 
             ErrorUtilities.VerifyThrow(taskElementList.Count > (currentTask - skippedNodeCount),
                 "The TaskElementCollection in this target doesn't have the same number of BuildTask objects as the number of actual task elements.");
-            // Send the task for execution 
+            // Send the task for execution
             SubmitNonIntrinsicTask(
                 (XmlElement)targetChildNode,
                 ((BuildTask)taskElementList[currentTask - skippedNodeCount]).HostObject,
@@ -839,8 +839,8 @@ private void ProcessTaskOutputs(TaskExecutionContext executionContext)
                     }
                     // We need to disable the execution of the task if it was previously enabled,
                     // and if were only doing execution we can stop processing at the point the
-                    // error occurred. If the task fails (which implies that ContinueOnError != 'true'), then do 
-                    // not execute the remaining tasks because they may depend on the completion 
+                    // error occurred. If the task fails (which implies that ContinueOnError != 'true'), then do
+                    // not execute the remaining tasks because they may depend on the completion
                     // of this task.
                     ErrorUtilities.VerifyThrow(howToBuild == DependencyAnalysisResult.FullBuild ||
                                                 howToBuild == DependencyAnalysisResult.IncrementalBuild,
@@ -910,7 +910,7 @@ private void FinishRunningTargetBatches(ProjectBuildState buildContext)
                 // used for dependency analysis, but we assume that's what the user intended
                 GatherTargetOutputs();
 
-                // Only contexts which are generated from an MSBuild task could need 
+                // Only contexts which are generated from an MSBuild task could need
                 // the outputs of the target, such contexts have a non-null evaluation
                 // request
                 if (buildContext.BuildRequest.OutputsByTarget != null &&
@@ -943,9 +943,9 @@ private void GatherTargetOutputs()
 
             XmlAttribute targetOutputsAttribute = targetElement.Attributes[XMakeAttributes.outputs];
 
-            // Hack to help the 3.5 engine at least pretend to still be able to build on top of 
-            // the 4.0 targets.  In cases where there is no Outputs attribute, just a Returns attribute, 
-            // we can approximate the correct behaviour by making the Returns attribute our "outputs" attribute. 
+            // Hack to help the 3.5 engine at least pretend to still be able to build on top of
+            // the 4.0 targets.  In cases where there is no Outputs attribute, just a Returns attribute,
+            // we can approximate the correct behaviour by making the Returns attribute our "outputs" attribute.
             if (targetOutputsAttribute == null)
             {
                 targetOutputsAttribute = targetElement.Attributes[XMakeAttributes.returns];
@@ -1010,7 +1010,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 waitingTargets.RemoveAt(0);
 
                 //Don't report any messages within the context in which the error occurred. That context
-                //is addressed as the base of the stack 
+                //is addressed as the base of the stack
                 if (buildContext == errorContext ||
                     buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.RequestFilled)
                 {
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index e7b5a534131..7d32fb9648c 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -300,7 +300,7 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
 
                 engineProxy?.MarkAsInActive();
 
-                // Now all task batches are done, apply all item adds to the outer 
+                // Now all task batches are done, apply all item adds to the outer
                 // target batch; we do this even if the task wasn't found (in that case,
                 // no items or properties will have been added to the scope)
                 if (buckets != null)
@@ -355,7 +355,7 @@ private bool ExecuteBucket(EngineProxy engineProxy, ItemBucket bucket, int bucke
             {
                 // Now that we know we will need to execute the task,
                 // Ensure the TaskEngine is initialized with the task class
-                // This does the work of task discovery, if it 
+                // This does the work of task discovery, if it
                 // hasn't already been done.
                 bool taskClassWasFound = FindTask();
 
@@ -738,7 +738,7 @@ private bool ExecuteInstantiatedTask(EngineProxy engineProxy, ItemBucket bucket,
                     {
                         loggingServices.LogTaskWarningFromException(buildEventContext, e,
                             // Don't try and log the line/column number for this error if
-                            // ContinueOnError=true, because it's too expensive to do so, 
+                            // ContinueOnError=true, because it's too expensive to do so,
                             // and this error may be fairly common and expected.
                             new BuildEventFileInfo(projectFileOfTaskNode), TaskName);
 
@@ -1189,8 +1189,8 @@ private List<TaskOutput> GetTaskOutputSpecifications(bool showWarnings)
                 {
                     TaskOutput taskOutputSpecification = new TaskOutput((XmlElement)childNode);
 
-                    // The "ItemName" attribute of the <Output> tag is usually just a straight 
-                    // string representing the item name.  If it contains any "@" signs, the 
+                    // The "ItemName" attribute of the <Output> tag is usually just a straight
+                    // string representing the item name.  If it contains any "@" signs, the
                     // project author most likely made a mistake, and so we throw a warning here.
                     XmlAttribute itemNameAttribute = taskOutputSpecification.ItemNameAttribute;
                     if (showWarnings && taskOutputSpecification.IsItemVector &&
@@ -1200,8 +1200,8 @@ private List<TaskOutput> GetTaskOutputSpecifications(bool showWarnings)
                             projectFileOfTaskNode), "AtSignInTaskOutputItemName", itemNameAttribute.Value);
                     }
 
-                    // The "PropertyName" attribute of the <Output> tag is usually just a straight 
-                    // string representing the property name.  If it contains any "$" signs, the 
+                    // The "PropertyName" attribute of the <Output> tag is usually just a straight
+                    // string representing the property name.  If it contains any "$" signs, the
                     // project author most likely made a mistake, and so we throw a warning here.
                     XmlAttribute propertyNameAttribute = taskOutputSpecification.PropertyNameAttribute;
                     if (showWarnings && taskOutputSpecification.IsProperty &&
@@ -1485,8 +1485,8 @@ out bool taskParameterSet
                     finalTaskInputs.AddRange(finalTaskItems);
                 }
 
-                // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required 
-                // parameter, in which case we made an explicit decision to pass in an empty array.  This is 
+                // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required
+                // parameter, in which case we made an explicit decision to pass in an empty array.  This is
                 // to avoid project authors having to add Conditions on all their tasks to avoid calling them
                 // when a particular item list is empty.  This way, we just call the task with an empty list,
                 // the task will loop over an empty list, and return quickly.
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
index 892ae43873b..d87825821f6 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
@@ -50,7 +50,7 @@ bool profileExecution
 
             SetBatchRequestSize();
 
-            // In singleproc mode the task execution module executes tasks on the engine thread. In multi proc mode a new thread is 
+            // In singleproc mode the task execution module executes tasks on the engine thread. In multi proc mode a new thread is
             // created so the TEM can submit tasks to a worker queue which will run the tasks on a new thread.
             if (moduleMode != TaskExecutionModuleMode.SingleProcMode)
             {
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionState.cs b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
index 2da1fadc4bb..80fc3861753 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionState.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.BuildEngine
     /// The node completes the class instantiating by providing the object with node side data.
     /// This class is distinct from the task engine in that it (possibly) travels cross process
     /// between the engine and the node carrying with it the data needed to instantiate the task
-    /// engine. The task engine can't subsume this class because the task engine is bound to the 
+    /// engine. The task engine can't subsume this class because the task engine is bound to the
     /// node process and can't travel cross process.
     /// </summary>
     internal class TaskExecutionState
@@ -216,8 +216,8 @@ internal void NotifyOfWait(long waitStartTime)
 
         #region MethodsNeededForUnitTesting
         /// <summary>
-        /// Since we could not derrive from TaskEngine and have no Interface, we need to overide the method in here and 
-        /// replace the calls when testing the class because of the calls to TaskEngine. If at a future time we get a mock task 
+        /// Since we could not derrive from TaskEngine and have no Interface, we need to overide the method in here and
+        /// replace the calls when testing the class because of the calls to TaskEngine. If at a future time we get a mock task
         /// engine, Interface or a non sealed TaskEngine these methods can disappear.
         /// </summary>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/Engine/TaskRegistry.cs b/src/Deprecated/Engine/Engine/TaskRegistry.cs
index b9769cbf454..0b8e3b7e7a3 100644
--- a/src/Deprecated/Engine/Engine/TaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/TaskRegistry.cs
@@ -30,7 +30,7 @@ namespace Microsoft.Build.BuildEngine
     /// <example>
     /// &lt;UsingTask TaskName="Microsoft.Build.Tasks.Csc"                     ==> look for the "Csc" task in the
     ///            AssemblyName="Microsoft.Build.Tasks"/&gt;                       weakly-named "Microsoft.Build.Tasks" assembly
-    /// 
+    ///
     /// &lt;UsingTask TaskName="t1"                                            ==> look for the "t1" task in the
     ///            AssemblyName="mytasks, Culture=en, Version=1.0.0.0"/&gt;        strongly-named "mytasks" assembly
     ///
diff --git a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
index a944142b0a3..8c60ecd9468 100644
--- a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
@@ -424,7 +424,7 @@ BuildResult[] buildResults
                 else if ((eventType == 1 && executionMode == NodeLoopExecutionMode.WaitingPassiveThread) ||
                          (eventType == 2 && executionMode == NodeLoopExecutionMode.WaitingActiveThread))
                 {
-                    // There maybe multiple results in the list so we need to loop over it 
+                    // There maybe multiple results in the list so we need to loop over it
                     // and store the results
                     int originalResultCount = resultCount;
                     lock (postedBuildResults)
@@ -532,7 +532,7 @@ internal int[] GetWaitingTasksData(List<BuildRequest[]> outstandingRequests)
                 int i = 0;
                 foreach (DictionaryEntry entry in waitingTasks)
                 {
-                    // Store the node proxy 
+                    // Store the node proxy
                     waitingTasksArray[i] = (int)entry.Key;
                     // Loop through the build requests and add uncomplete requests to the list
                     WaitingTaskData taskData = (WaitingTaskData)entry.Value;
@@ -597,7 +597,7 @@ internal void Shutdown()
         private WaitHandle[] WaitingActiveThreadWaitHandles;
         private WaitHandle[] WaitingPassiveThreadWaitHandles;
 
-        // Data shared between worked threads for one TEM, this data is initialized by the first 
+        // Data shared between worked threads for one TEM, this data is initialized by the first
         // thread
         private ManualResetEvent exitTaskThreads;          // Used to signal all threads to exit
         private ExitTaskCache exitTaskThreadsCache;        // cached value to avoid waiting on the kernel event
diff --git a/src/Deprecated/Engine/Engine/Toolset.cs b/src/Deprecated/Engine/Engine/Toolset.cs
index be0f64d822f..e67724efe90 100644
--- a/src/Deprecated/Engine/Engine/Toolset.cs
+++ b/src/Deprecated/Engine/Engine/Toolset.cs
@@ -22,7 +22,7 @@ public class Toolset
         // The MSBuildBinPath (and ToolsPath) for this tools version
         private string toolsPath;
 
-        // Properties 
+        // Properties
         private BuildPropertyGroup properties;
 
         /// <summary>
@@ -69,7 +69,7 @@ public string ToolsVersion
         }
 
         /// <summary>
-        /// Path to this toolset's tasks and targets. Corresponds to $(MSBuildToolsPath) in a project or targets file. 
+        /// Path to this toolset's tasks and targets. Corresponds to $(MSBuildToolsPath) in a project or targets file.
         /// </summary>
         public string ToolsPath
         {
diff --git a/src/Deprecated/Engine/Engine/ToolsetCollection.cs b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
index 78fa2e1cf1b..e5e85a280cb 100644
--- a/src/Deprecated/Engine/Engine/ToolsetCollection.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
@@ -21,14 +21,14 @@ namespace Microsoft.Build.BuildEngine
     /// </summary>
     public class ToolsetCollection : ICollection<Toolset>
     {
-        // the parent engine 
+        // the parent engine
         private Engine parentEngine = null;
 
         // underlying map keyed off toolsVersion
         private Dictionary<string, Toolset> toolsetMap = null;
 
         /// <summary>
-        /// Private default Ctor. Other classes should not be constructing 
+        /// Private default Ctor. Other classes should not be constructing
         /// instances of this class without providing an Engine object.
         /// </summary>
         private ToolsetCollection()
diff --git a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
index e2e91a177d0..dee78cabbf1 100644
--- a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
@@ -137,7 +137,7 @@ private ToolsetConfigurationSection ConfigurationSection
                     {
                         Configuration configuration = readApplicationConfiguration();
 
-                        // This will be null if the application config file does not have the following section 
+                        // This will be null if the application config file does not have the following section
                         // definition for the msbuildToolsets section as the first child element.
                         //   <configSections>
                         //     <section name=""msbuildToolsets"" type=""Microsoft.Build.BuildEngine.ToolsetConfigurationSection, Microsoft.Build.Engine"" />
@@ -153,8 +153,8 @@ private ToolsetConfigurationSection ConfigurationSection
                             configurationSection = configuration.GetSection("msbuildToolsets") as ToolsetConfigurationSection;
                         }
                     }
-                    // ConfigurationException is obsolete, but we catch it rather than 
-                    // ConfigurationErrorsException (which is what we throw below) because it is more 
+                    // ConfigurationException is obsolete, but we catch it rather than
+                    // ConfigurationErrorsException (which is what we throw below) because it is more
                     // general and we don't want to miss catching some other derived exception.
                     catch (ConfigurationException ex)
                     {
@@ -181,7 +181,7 @@ private ToolsetConfigurationSection ConfigurationSection
     /// <summary>
     /// This class is used to programmatically read msbuildToolsets section
     /// in from the configuration file.  An example of application config file:
-    /// 
+    ///
     /// &lt;configuration&gt;
     ///     &lt;msbuildToolsets default="2.0"&gt;
     ///         &lt;toolset toolsVersion="2.0"&gt;
@@ -193,7 +193,7 @@ private ToolsetConfigurationSection ConfigurationSection
     ///         &lt;/toolset&gt;
     ///     &lt;/msbuildToolsets&gt;
     /// &lt;/configuration&gt;
-    /// 
+    ///
     /// </summary>
     /// <remarks>
     /// Internal for unit testing only
@@ -201,7 +201,7 @@ private ToolsetConfigurationSection ConfigurationSection
     internal sealed class ToolsetConfigurationSection : ConfigurationSection
     {
         /// <summary>
-        /// toolsVersion element collection 
+        /// toolsVersion element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public ToolsetElementCollection Toolsets
@@ -392,7 +392,7 @@ public string toolsVersion
         }
 
         /// <summary>
-        /// Property element collection 
+        /// Property element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public PropertyElementCollection PropertyElements
@@ -479,7 +479,7 @@ protected override object GetElementKey(ConfigurationElement element)
 
             /// <summary>
             /// Collection type
-            /// This has to be public as cannot change access modifier when overriding  
+            /// This has to be public as cannot change access modifier when overriding
             /// </summary>
             public override ConfigurationElementCollectionType CollectionType
             {
diff --git a/src/Deprecated/Engine/Engine/ToolsetReader.cs b/src/Deprecated/Engine/Engine/ToolsetReader.cs
index e476e2b9a2e..14f68b2d47a 100644
--- a/src/Deprecated/Engine/Engine/ToolsetReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetReader.cs
@@ -115,11 +115,11 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
                                                BuildPropertyGroup initialProperties,
                                                ToolsetDefinitionLocations locations)
         {
-            // The 2.0 .NET Framework installer did not write a ToolsVersion key for itself in the registry. 
-            // The 3.5 installer writes one for 2.0, but 3.5 might not be installed.  
-            // The 4.0 and subsequent installers can't keep writing the 2.0 one, because (a) it causes SxS issues and (b) we 
+            // The 2.0 .NET Framework installer did not write a ToolsVersion key for itself in the registry.
+            // The 3.5 installer writes one for 2.0, but 3.5 might not be installed.
+            // The 4.0 and subsequent installers can't keep writing the 2.0 one, because (a) it causes SxS issues and (b) we
             // don't want it unless 2.0 is installed.
-            // So if the 2.0 framework is actually installed, and we're reading the registry, create a toolset for it. 
+            // So if the 2.0 framework is actually installed, and we're reading the registry, create a toolset for it.
             // The registry and config file can overwrite it.
             if (
                 ((locations & ToolsetDefinitionLocations.Registry) != 0) &&
@@ -186,7 +186,7 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
                     ErrorUtilities.VerifyThrow(Constants.defaultToolsVersion == "2.0", "Getting 2.0 FX path so default should be 2.0");
                     string pathToFramework = FrameworkLocationHelper.PathToDotNetFrameworkV20;
 
-                    // We could not find the default toolsversion because it was not installed on the machine. Fallback to the 
+                    // We could not find the default toolsversion because it was not installed on the machine. Fallback to the
                     // one we expect to always be there when running msbuild 4.0.
                     if (pathToFramework == null)
                     {
@@ -280,7 +280,7 @@ private void ReadEachToolset(ToolsetCollection toolsets,
         {
             foreach (PropertyDefinition toolsVersion in ToolsVersions)
             {
-                // We clone here because we don't want to interfere with the evaluation 
+                // We clone here because we don't want to interfere with the evaluation
                 // of subsequent Toolsets; otherwise, properties found during the evaluation
                 // of this Toolset would be persisted in initialProperties and appear
                 // to later Toolsets as Global or Environment properties from the Engine.
diff --git a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
index 46a2434dab9..1aca18c0ebd 100644
--- a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
@@ -154,7 +154,7 @@ private static string GetValue(RegistryKeyWrapper wrapper, string valueName)
                 object result = wrapper.GetValue(valueName);
 
                 // RegistryKey.GetValue returns null if the value is not present
-                // and String.Empty if the value is present and no data is defined. 
+                // and String.Empty if the value is present and no data is defined.
                 // We preserve this distinction, because a string property in the registry with
                 // no value really has an empty string for a value (which is a valid property value)
                 // rather than null for a value (which is an invalid property value)
diff --git a/src/Deprecated/Engine/Engine/UsingTask.cs b/src/Deprecated/Engine/Engine/UsingTask.cs
index 119da7388b2..1d51301bf7d 100644
--- a/src/Deprecated/Engine/Engine/UsingTask.cs
+++ b/src/Deprecated/Engine/Engine/UsingTask.cs
@@ -139,7 +139,7 @@ internal UsingTask(XmlElement usingTaskNode, bool isImported)
                         // ignore
                         break;
                     case XMakeElements.usingTaskParameterGroup:
-                        // ignore 
+                        // ignore
                         break;
                     default:
                         illegalChildElementFound = true;
@@ -153,9 +153,9 @@ internal UsingTask(XmlElement usingTaskNode, bool isImported)
                 }
             }
 
-            // UsingTask has no valid child elements in 3.5 syntax, but in 4.0 syntax it does. 
+            // UsingTask has no valid child elements in 3.5 syntax, but in 4.0 syntax it does.
             // So ignore any valid 4.0 child elements and try to load the project as usual, but
-            // still error out if something we don't expect is found. 
+            // still error out if something we don't expect is found.
             if (illegalChildElementFound)
             {
                 ProjectXmlUtilities.ThrowProjectInvalidChildElement(illegalChildElement);
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index f3ccf678690..a88f594fef9 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -30,7 +30,7 @@ public static class Utilities
         /// inside of a condition and the string values that they are being tested against.
         /// So, for example, if the condition was " '$(Configuration)' == 'Debug' ", we
         /// would get passed in leftValue="$(Configuration)" and rightValueExpanded="Debug".
-        /// This call would add the string "Debug" to the list of possible values for the 
+        /// This call would add the string "Debug" to the list of possible values for the
         /// "Configuration" property.
         ///
         /// This method also handles the case when two or more properties are being
@@ -73,7 +73,7 @@ string rightValueExpanded               // The fully expanded value on the right
                         string rightValueExpandedPiece;
 
                         // If there was no vertical bar, then just use the remainder of the right-hand-side
-                        // expression as the value of the property, and terminate the loop after this iteration.  
+                        // expression as the value of the property, and terminate the loop after this iteration.
                         // Also, if we're on the last segment of the left-hand-side, then use the remainder
                         // of the right-hand-side expression as the value of the property.
                         if ((indexOfVerticalBar == -1) || (i == (leftValuePieces.Length - 1)))
@@ -84,7 +84,7 @@ string rightValueExpanded               // The fully expanded value on the right
                         else
                         {
                             // If we found a vertical bar, then the portion before the vertical bar is the
-                            // property value which we will store in our table.  Then remove that portion 
+                            // property value which we will store in our table.  Then remove that portion
                             // from the original string so that the next iteration of the loop can easily search
                             // for the first vertical bar again.
                             rightValueExpandedPiece = rightValueExpanded.Substring(0, indexOfVerticalBar);
@@ -120,7 +120,7 @@ string rightValueExpanded               // The fully expanded value on the right
         /*
          * Method:  GatherReferencedPropertyNames
          * Owner:   DavidLe
-         * 
+         *
          * Find and record all of the properties that are referenced in the given
          * condition.
          *
@@ -137,7 +137,7 @@ Hashtable conditionedPropertiesTable  // Can be null
             EvaluateCondition(condition, conditionAttribute, expander, conditionedPropertiesTable, ParserOptions.AllowProperties | ParserOptions.AllowItemLists, null, null);
         }
 
-        // An array of hashtables with cached expression trees for all the combinations of condition strings 
+        // An array of hashtables with cached expression trees for all the combinations of condition strings
         // and parser options
         private static volatile Hashtable[] cachedExpressionTrees = new Hashtable[8 /* == ParserOptions.AllowAll*/]
             {
@@ -258,7 +258,7 @@ BuildEventContext buildEventContext
 
                 parsedExpression = conditionParser.Parse(condition, conditionAttribute, itemListOptions);
 
-                // It's possible two threads will add a different tree to the same entry in the hashtable, 
+                // It's possible two threads will add a different tree to the same entry in the hashtable,
                 // but it should be rare and it's not a problem - the previous entry will be thrown away.
                 // We could ensure no dupes with double check locking but it's not really necessary here.
                 // Also, we don't want to lock on every read.
@@ -308,7 +308,7 @@ internal static void SetXmlNodeInnerContents(XmlNode node, string s)
                 }
             }
 
-            // The value does not contain valid XML markup.  Store it as text, so it gets 
+            // The value does not contain valid XML markup.  Store it as text, so it gets
             // escaped properly.
             node.InnerText = s;
         }
@@ -323,10 +323,10 @@ internal static string GetXmlNodeInnerContents(XmlNode node)
         {
             // XmlNode.InnerXml gives back a string that consists of the set of characters
             // in between the opening and closing elements of the XML node, without doing any
-            // unescaping.  Any "strange" character sequences (like "<![CDATA[...]]>" will remain 
+            // unescaping.  Any "strange" character sequences (like "<![CDATA[...]]>" will remain
             // exactly so and will not be translated or interpreted.  The only modification that
             // .InnerXml will do is that it will normalize any Xml contained within.  This means
-            // normalizing whitespace between XML attributes and quote characters that surround XML 
+            // normalizing whitespace between XML attributes and quote characters that surround XML
             // attributes.  If PreserveWhitespace is false, then it will also normalize whitespace
             // between elements.
             //
@@ -353,19 +353,19 @@ internal static string GetXmlNodeInnerContents(XmlNode node)
             // use ... InnerXml or InnerText.  There are two basic scenarios we care about.
             //
             // 1.)  The first scenario is that the user is trying to create a property whose
-            //      contents are actually XML.  That is to say that the contents may be written 
+            //      contents are actually XML.  That is to say that the contents may be written
             //      to a XML file, or may be passed in as a string to XmlDocument.LoadXml.
-            //      In this case, we would want to use XmlNode.InnerXml, because we DO NOT want 
-            //      character sequences to be unescaped.  If we did unescape them, then whatever 
+            //      In this case, we would want to use XmlNode.InnerXml, because we DO NOT want
+            //      character sequences to be unescaped.  If we did unescape them, then whatever
             //      XML parser tried to read in the stream as XML later on would totally barf.
             //
             // 2.)  The second scenario is the the user is trying to create a property that
             //      is just intended to be treated as a string.  That string may be very large
             //      and could contain all sorts of whitespace, carriage returns, special characters,
-            //      etc.  But in the end, it's just a big string.  In this case, whatever 
+            //      etc.  But in the end, it's just a big string.  In this case, whatever
             //      task is actually processing this string ... it's not going to know anything
             //      about character sequences such as &amp; and &lt;.  These character sequences
-            //      are specific to XML markup.  So, here we want to use XmlNode.InnerText so that 
+            //      are specific to XML markup.  So, here we want to use XmlNode.InnerText so that
             //      the character sequences get unescaped into their actual character before
             //      the string is passed to the task (or wherever else the property is used).
             //      Of course, if the string value of the property needs to contain characters
diff --git a/src/Deprecated/Engine/Engine/XmlSearcher.cs b/src/Deprecated/Engine/Engine/XmlSearcher.cs
index 033ed172e99..ec51217b82f 100644
--- a/src/Deprecated/Engine/Engine/XmlSearcher.cs
+++ b/src/Deprecated/Engine/Engine/XmlSearcher.cs
@@ -57,8 +57,8 @@ out int foundColumnNumber
             // the given XmlNode in its original container document.  Element number is
             // simply a 1-based number identifying a particular XML element starting from
             // the beginning of the document, ignoring depth.  As you're walking the tree,
-            // visiting each node in order, and recursing deeper whenever possible, the Nth 
-            // element you visit has element number N.  Attribute number is simply the 
+            // visiting each node in order, and recursing deeper whenever possible, the Nth
+            // element you visit has element number N.  Attribute number is simply the
             // 1-based index of the attribute within the given Xml element.  An attribute
             // number of zero indicates that we're not searching for a particular attribute,
             // and all we care about is the element as a whole.
@@ -99,8 +99,8 @@ out int attributeNumber
 
             XmlNode elementToFind;
 
-            // First determine the XmlNode in the main hierarchy to search for.  If the passed-in 
-            // node is already an XmlElement or Text node, then we already have the node 
+            // First determine the XmlNode in the main hierarchy to search for.  If the passed-in
+            // node is already an XmlElement or Text node, then we already have the node
             // that we're searching for.  But if the passed-in node is an XmlAttribute, then
             // we want to search for the XmlElement that contains that attribute.
             // If the node is any other type, try the parent node. It's a better line number than no line number.
@@ -130,7 +130,7 @@ out int attributeNumber
             }
 
             // Figure out the element number for this particular XML element, by iteratively
-            // visiting every single node in the XmlDocument in sequence.  Start with the 
+            // visiting every single node in the XmlDocument in sequence.  Start with the
             // root node which is the XmlDocument node.
             XmlNode xmlNode = xmlNodeToFind.OwnerDocument;
             while (true)
@@ -182,7 +182,7 @@ out int attributeNumber
 
             if (xmlNode == null)
             {
-                // We visited every XmlElement in the document without finding the 
+                // We visited every XmlElement in the document without finding the
                 // specific XmlElement we were supposed to.  Oh well, too bad.
                 elementNumber = 0;
                 return false;
@@ -218,8 +218,8 @@ out int attributeNumber
         }
 
         /// <summary>
-        /// Read through the entire XML of a given project file, searching for the element/attribute 
-        /// specified by element number and attribute number.  Return the line number and column 
+        /// Read through the entire XML of a given project file, searching for the element/attribute
+        /// specified by element number and attribute number.  Return the line number and column
         /// number where it was found.
         /// </summary>
         /// <param name="projectFile">Path to project file on disk.</param>
@@ -257,7 +257,7 @@ out int foundColumnNumber
                     reader.DtdProcessing = DtdProcessing.Ignore;
                     int currentXmlElementNumber = 0;
 
-                    // While we haven't reached the end of the file, and we haven't found the 
+                    // While we haven't reached the end of the file, and we haven't found the
                     // specified node ...
                     while (reader.Read() && (foundColumnNumber == 0) && (foundLineNumber == 0))
                     {
@@ -291,7 +291,7 @@ out int foundColumnNumber
                                 else if (reader.MoveToFirstAttribute())
                                 {
                                     // Caller wants a particular attribute within the element,
-                                    // and the element does have 1 or more attributes.  So let's 
+                                    // and the element does have 1 or more attributes.  So let's
                                     // try to find the right one.
                                     int currentXmlAttributeNumber = 0;
 
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index 9a09530d884..f62d0a4f61d 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -75,7 +75,7 @@ public InvalidProjectFileException(string message, Exception innerException)
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
@@ -331,7 +331,7 @@ public string HelpKeyword
         }
 
         /// <summary>
-        /// Whether the exception has already been logged. Allows the exception to be logged at the 
+        /// Whether the exception has already been logged. Allows the exception to be logged at the
         /// most appropriate location, but continue to be propagated.
         /// </summary>
         internal bool HasBeenLogged
diff --git a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
index 7beacba7655..492a829536a 100644
--- a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
@@ -119,7 +119,7 @@ public string ErrorCode
 
         /// <summary>
         /// Throws an InvalidToolsetDefinitionException.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -138,7 +138,7 @@ params object[] args
         /// <summary>
         /// Throws an InvalidToolsetDefinitionException including a specified inner exception,
         /// which may be interesting to hosts.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index a2e3e5493b6..a8d62fd2b3e 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -32,7 +32,7 @@ internal RemoteErrorException(string message, Exception innerException, BuildEve
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
diff --git a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
index 43d4d1681f8..ab7cf76f593 100644
--- a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
+++ b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
@@ -146,7 +146,7 @@ internal bool FindCycles()
                     BreadthFirstTraversal(node);
                 }
             }
-            // Verify that all nodes have been reached 
+            // Verify that all nodes have been reached
             foreach (GraphNode node in dependencyGraph.Values)
             {
                 if (node.traversalIndex == GraphNode.InvalidIndex)
@@ -199,10 +199,10 @@ private void LinkCrossNodeBuildRequests()
                     }
 
                     // If the request being analyzed came from one of the child nodes, its incoming external request's
-                    // handleId will point at a routing context on the parent engine. If the outgoing request 
-                    // orginated from another child the two requests (outgoing and incoming) point at different 
-                    // routing contexts. In that case it is necessary to unwind the incoming request to the routing 
-                    // context of the outgoing request. If outgoing request originated from the parent node - 
+                    // handleId will point at a routing context on the parent engine. If the outgoing request
+                    // orginated from another child the two requests (outgoing and incoming) point at different
+                    // routing contexts. In that case it is necessary to unwind the incoming request to the routing
+                    // context of the outgoing request. If outgoing request originated from the parent node -
                     // there will be only one routing request.
                     if (node.targetState.TargetId.nodeId != 0)
                     {
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index 96b17f23abc..c3f7438d0a8 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class is used to construct and contain the state of an inprogress targets. The primary data
-    /// includes build requests blocked until this target completes and build requests that must complete 
+    /// includes build requests blocked until this target completes and build requests that must complete
     /// before this target can make forward process.
     /// </summary>
     internal class TargetInProgessState
@@ -87,7 +87,7 @@ internal TargetIdWrapper TargetId
         }
 
         /// <summary>
-        /// List of unique identifiers for the targets that are blocked until the current 
+        /// List of unique identifiers for the targets that are blocked until the current
         /// target completes
         /// </summary>
         internal List<TargetIdWrapper> ParentTargets
@@ -99,7 +99,7 @@ internal List<TargetIdWrapper> ParentTargets
         }
 
         /// <summary>
-        /// List of build requests that are blocked until the current 
+        /// List of build requests that are blocked until the current
         /// target completes
         /// </summary>
         internal List<BuildRequest> ParentBuildRequests
@@ -111,7 +111,7 @@ internal List<BuildRequest> ParentBuildRequests
         }
 
         /// <summary>
-        /// Array of build requests that must complete before the current 
+        /// Array of build requests that must complete before the current
         /// target can make forward process
         internal BuildRequest[] OutstandingBuildRequests
         {
@@ -233,7 +233,7 @@ out BuildRequest parentTriggeringRequest
                 {
                     return new TargetIdWrapper(((TaskExecutionContext)executionContext).ParentTarget);
                 }
-                // If the parent context if a routing context the parent target is not available 
+                // If the parent context if a routing context the parent target is not available
                 // on the current node, so store the request instead
                 else
                 {
@@ -604,7 +604,7 @@ public override int GetHashCode()
 
             // Target name
             internal string name;
-            // Id for the parent project 
+            // Id for the parent project
             internal int projectId;
             // Id for the node where the target exists
             internal int nodeId;
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index e398bba1776..338456d3812 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -53,7 +53,7 @@ public class BuildItem
 
         // This is the "Include" value of a virtual item. This
         // may contain wildcards.
-        // For persisted (non-virtual) items, the include is gotten from 
+        // For persisted (non-virtual) items, the include is gotten from
         // the backing xml; there is no point storing a copy here, and this
         // remains null.
         private string include = null;
@@ -400,7 +400,7 @@ internal BuildItem(XmlDocument ownerDocument, string name, string include, ItemD
         /// when a build generates a large number of items.
         /// </remarks>
         /// <param name="ownerDocument">can be null</param>
-        /// <param name="name">can be null</param> 
+        /// <param name="name">can be null</param>
         private BuildItem(XmlDocument ownerDocument, string name, string include, bool createCustomMetadataCache, ItemDefinitionLibrary itemDefinitionLibrary)
         {
             BuildItemHelper(ownerDocument, name, include, createCustomMetadataCache, itemDefinitionLibrary);
@@ -1133,7 +1133,7 @@ internal static BuildItem CreateClonedParentedItem(BuildItem childItem, BuildIte
         /// FUTURE: Currently this isn't done when the item is constructed; so for example HasMetadata will always return
         /// false until EvaluatedAllItemMetadata is explicitly called. The reason for this is that Metadata are
         /// not first class objects, they are merely string pairs produced by running over the child XML with a particular expander.
-        /// When Metadata are first class objects this method can be changed to merely evaluate them, 
+        /// When Metadata are first class objects this method can be changed to merely evaluate them,
         /// just as BuildItemGroup.Evaluate does for BuildItem, then methods like HasMetadata behave more sanely. Of course this
         /// could be a breaking change.
         /// </remarks>
@@ -1205,7 +1205,7 @@ public bool HasMetadata(string metadataName)
             ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
             ErrorUtilities.VerifyThrow(this.unevaluatedCustomMetadata != null, "Item not initialized properly. unevaluatedCustomAttributes is null.");
 #if DEBUG
-            // The hashtable of metadata (this.unevaluatedCustomMetadata) should never contain 
+            // The hashtable of metadata (this.unevaluatedCustomMetadata) should never contain
             // values for those reserved metadata that the engine provides (Filename, RelativeDir,
             // Extension, etc.).  The one exception is that the hashtable is allowed to contain
             // a value for "RecursiveDir" because that one is extra special ... tasks are allowed
@@ -1272,7 +1272,7 @@ public string GetMetadata(string metadataName)
         }
 
         /// <summary>
-        /// Retrieves an arbitrary metadata from the item element, expands any property and item references within it, and 
+        /// Retrieves an arbitrary metadata from the item element, expands any property and item references within it, and
         /// unescapes it.
         /// </summary>
         /// <remarks>Custom attributes on virtual items are not evaluated.</remarks>
@@ -1901,7 +1901,7 @@ public BuildItem Clone()
         }
 
         /// <summary>
-        /// Updates the build item xml backing store with the passed in xml backing store. 
+        /// Updates the build item xml backing store with the passed in xml backing store.
         /// </summary>
         internal void UpdateBackingXml(BuildItemGroupChildXml backingXml)
         {
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index 7d0238b9222..c3e6cb2d3c0 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -350,7 +350,7 @@ internal void AddExistingItemAt(int index, BuildItem itemToAdd)
                 itemToAdd.ItemDefinitionLibrary = parentProject.ItemDefinitionLibrary;
             }
 
-            // If this BuildItemGroup is a persisted <ItemGroup>, then we need the 
+            // If this BuildItemGroup is a persisted <ItemGroup>, then we need the
             // items to have a reference back to their parent BuildItemGroup.  This
             // makes it *much* easier to delete items through the object model.
             if (IsPersisted)
@@ -383,11 +383,11 @@ internal void AddItem(BuildItem itemToAdd)
                 ErrorUtilities.VerifyThrow(itemToAdd.ItemElement.OwnerDocument == xml.OwnerDocument, "Cannot add an Item with a different XML owner document.");
 
                 // Generally, the desired behavior is to keep items of the same Type physically
-                // contiguous within the BuildItemGroup.  (It's just easier to read that way.)  So we 
+                // contiguous within the BuildItemGroup.  (It's just easier to read that way.)  So we
                 // scan through the existing items in our BuildItemGroup, and try to find the spot where
-                // the new item would fit in alphabetically.  This is nice because it helps 
-                // source code control scenarios where multiple clients are adding items to 
-                // the same list.  By putting them in alphabetical order, there's less of a 
+                // the new item would fit in alphabetically.  This is nice because it helps
+                // source code control scenarios where multiple clients are adding items to
+                // the same list.  By putting them in alphabetical order, there's less of a
                 // chance of merge conflicts.
                 int insertionIndex = items.Count;
                 for (int i = 0; i < items.Count; i++)
@@ -488,7 +488,7 @@ internal void RemoveItemWithBackup(BuildItem itemToRemove)
                 BackupPersistedItems();
             }
 
-            // Don't remove the XML node, or mark the itemgroup as dirty; this is 
+            // Don't remove the XML node, or mark the itemgroup as dirty; this is
             // strictly an operation on temporary items, because we'll be un-backing up the
             // persisted items at the end of the build
 
@@ -859,7 +859,7 @@ bool expandMetadata
                 BuildItemGroup itemizedGroup = expander.ExpandSingleItemListExpressionIntoItemsLeaveEscaped(itemIncludePieces[i], originalItem.IncludeAttribute);
                 if (itemizedGroup == null)
                 {
-                    // The expression did not represent a single @(...) item list reference. 
+                    // The expression did not represent a single @(...) item list reference.
                     if (expandMetadata)
                     {
                         // We're inside a target: metadata expressions like %(foo) are legal, so expand them now
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
index 4a08bf3edab..481b6a9e178 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.BuildEngine
     /// This class represents a collection of persisted &lt;ItemGroup&gt;'s.  Each
     /// MSBuild project has exactly one BuildItemGroupCollection, which includes
     /// all the imported ItemGroups as well as the ones in the main project file.
-    /// 
+    ///
     /// The implementation of this class is that it's basically a Facade.  It just
     /// calls into the GroupingCollection within the Project to do it's work.  It
     /// doesn't maintain any BuildPropertyGroup state on its own.
@@ -120,8 +120,8 @@ internal BuildItemGroup LastLocalItemGroup
                 {
                     if (itemGroup.IsImported)
                     {
-                        // As soon as we hit an imported BuildItemGroup, we want to 
-                        // completely bail out.  The goal of this function is 
+                        // As soon as we hit an imported BuildItemGroup, we want to
+                        // completely bail out.  The goal of this function is
                         // to return the last itemGroup that is *before* any
                         // imported itemGroups.
                         break;
@@ -141,7 +141,7 @@ internal BuildItemGroup LastLocalItemGroup
         #region Methods
 
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <owner>DavidLe</owner>
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs b/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
index 117abf65a61..a97cd96962d 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
@@ -10,12 +10,12 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// An enumerable wrapper for a hashtable-by-name of BuildItemGroups that allows read-only 
+    /// An enumerable wrapper for a hashtable-by-name of BuildItemGroups that allows read-only
     /// access to the items.
     /// </summary>
     /// <remarks>
     /// This class is designed to be passed to loggers.
-    /// The expense of copying items is only incurred if and when 
+    /// The expense of copying items is only incurred if and when
     /// a logger chooses to enumerate over it.
     /// </remarks>
     /// <owner>danmose</owner>
diff --git a/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs b/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
index a53bff392ac..345e22ce67d 100644
--- a/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
+++ b/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
@@ -173,7 +173,7 @@ private void MustBeEvaluated()
         /// <remarks>
         /// Only used by ItemDefinitionLibrary -- private and nested inside it as no other class should know about this.
         /// Since at present this has no OM or editing support, and is not passed around,
-        /// there are currently no separate classes for the child tags, and no separate BuildItemDefinitionGroup class. 
+        /// there are currently no separate classes for the child tags, and no separate BuildItemDefinitionGroup class.
         /// They can be broken out in future if necessary.
         /// </remarks>
         private class BuildItemDefinitionGroupXml
@@ -211,7 +211,7 @@ internal BuildItemDefinitionGroupXml(XmlElement element, Project parentProject)
             #region Public Methods
 
             /// <summary>
-            /// Given the properties and dictionary of previously encountered item definitions, evaluates 
+            /// Given the properties and dictionary of previously encountered item definitions, evaluates
             /// this group of item definitions and adds to the dictionary as necessary.
             /// </summary>
             /// <exception cref="InvalidProjectFileException">If the item definitions are incorrectly defined</exception>
@@ -233,7 +233,7 @@ internal void Evaluate(BuildPropertyGroup properties, ItemDefinitionsDictionary
             }
 
             /// <summary>
-            /// Given the properties and dictionary of previously encountered item definitions, evaluates 
+            /// Given the properties and dictionary of previously encountered item definitions, evaluates
             /// this specific item definition element and adds to the dictionary as necessary.
             /// </summary>
             /// <exception cref="InvalidProjectFileException">If the item definition is incorrectly defined</exception>
@@ -264,7 +264,7 @@ private void EvaluateItemDefinitionElement(XmlElement itemDefinitionElement, Bui
             }
 
             /// <summary>
-            /// Given the properties and dictionary of previously encountered item definitions, evaluates 
+            /// Given the properties and dictionary of previously encountered item definitions, evaluates
             /// this specific item definition child element and adds to the dictionary as necessary.
             /// </summary>
             /// <exception cref="InvalidProjectFileException">If the item definition is incorrectly defined</exception>
@@ -303,7 +303,7 @@ private void EvaluateItemDefinitionChildElement(XmlElement itemDefinitionChildEl
                     itemDefinitionsDictionary.Add(itemType, metadataDictionary);
                 }
 
-                // We only store the evaluated value; build items store the unevaluated value as well, but apparently only to 
+                // We only store the evaluated value; build items store the unevaluated value as well, but apparently only to
                 // gather recursive portions (its re-evaluation always goes back to the XML).
                 // Overwrite any existing default value for this particular metadata
                 metadataDictionary[itemDefinitionChildElement.Name] = evaluatedMetadataValue;
diff --git a/src/Deprecated/Engine/Items/ItemExpander.cs b/src/Deprecated/Engine/Items/ItemExpander.cs
index 8aa0fd4540c..0a07bfe84cd 100644
--- a/src/Deprecated/Engine/Items/ItemExpander.cs
+++ b/src/Deprecated/Engine/Items/ItemExpander.cs
@@ -131,7 +131,7 @@ ReadOnlyLookup readOnlyLookup
         /// <returns>Given string, with embedded item vectors expanded.</returns>
         internal static string ExpandEmbeddedItemVectors(string s, XmlNode parentNode, ReadOnlyLookup readOnlyLookup)
         {
-            // Before we do the expensive RegEx stuff, at least make sure there's 
+            // Before we do the expensive RegEx stuff, at least make sure there's
             // an @ sign in the expression somewhere.  If not, skip all the hard work.
             if (s.IndexOf('@') != -1)
             {
@@ -167,9 +167,9 @@ ReadOnlyLookup readOnlyLookup
         }
 
         /// <summary>
-        /// Attempts to extract the items in the given item vector expression. Item vectors embedded in strings, 
-        /// and item vectors with separator specifications are considered invalid, because it is not clear 
-        /// if those item vectors are meant to be lists or strings -- if the latter, the ExpandEmbeddedItemVectors() 
+        /// Attempts to extract the items in the given item vector expression. Item vectors embedded in strings,
+        /// and item vectors with separator specifications are considered invalid, because it is not clear
+        /// if those item vectors are meant to be lists or strings -- if the latter, the ExpandEmbeddedItemVectors()
         /// method should be used instead.
         /// </summary>
         /// <param name="itemVectorExpression"></param>
@@ -250,7 +250,7 @@ private static Match GetItemVectorMatches(string expression)
         {
             Match itemVectorMatch = null;
 
-            // Before we do the expensive RegEx stuff, at least make sure there's 
+            // Before we do the expensive RegEx stuff, at least make sure there's
             // an @ sign in the expression somewhere.  If not, skip all the hard work.
             if (expression.IndexOf('@') != -1)
             {
@@ -304,15 +304,15 @@ private BuildItemGroup ItemizeItemVector(Match itemVector)
 
         /// <summary>
         /// Expands a single item vector.
-        /// 
+        ///
         /// Item vectors are composed of a name, a transform, and a separator i.e.
-        /// 
+        ///
         ///     @(&lt;name&gt;->'&lt;transform&gt;','&lt;separator&gt;')
-        /// 
+        ///
         /// If a separator is not specified it defaults to a semi-colon. The transform expression is also optional, but if
         /// specified, it allows each item in the vector to have its item-spec converted to a different form. The transform
         /// expression can reference any custom metadata defined on the item, as well as the pre-defined item-spec modifiers.
-        /// 
+        ///
         /// NOTE:
         /// 1) white space between &lt;name&gt;, &lt;transform&gt; and &lt;separator&gt; is ignored
         ///    i.e. @(&lt;name&gt;, '&lt;separator&gt;') is valid
@@ -324,19 +324,19 @@ private BuildItemGroup ItemizeItemVector(Match itemVector)
         /// <remarks>This is the MatchEvaluator delegate passed to Regex.Replace().</remarks>
         /// <example>
         /// if @(files) is a vector for the files a.txt and b.txt, then:
-        /// 
+        ///
         ///     "my list: @(files)"                                 expands to      "my list: a.txt;b.txt"
-        /// 
+        ///
         ///     "my list: @(files,' ')"                             expands to      "my list: a.txt b.txt"
-        /// 
+        ///
         ///     "my list: @(files, '')"                             expands to      "my list: a.txtb.txt"
-        /// 
+        ///
         ///     "my list: @(files, '; ')"                           expands to      "my list: a.txt; b.txt"
-        /// 
+        ///
         ///     "my list: @(files->'%(Filename)')"                  expands to      "my list: a;b"
-        /// 
+        ///
         ///     "my list: @(files -> 'temp\%(Filename).xml', ' ')   expands to      "my list: temp\a.xml temp\b.xml"
-        /// 
+        ///
         ///     "my list: @(files->'')                              expands to      "my list: ;"
         /// </example>
         /// <owner>SumedhK</owner>
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index fe15c1e9287..6122f522356 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -38,7 +38,7 @@ internal static List<string> SplitSemiColonSeparatedList(string expression)
             string segment;
 
             // Walk along the string, keeping track of whether we are in an item list expression.
-            // If we hit a semi-colon or the end of the string and we aren't in an item list, 
+            // If we hit a semi-colon or the end of the string and we aren't in an item list,
             // add the segment to the list.
             for (int current = 0; current < expression.Length; current++)
             {
@@ -348,8 +348,8 @@ private static bool SinkValidName(string expression, ref int i, int end)
         }
 
         /// <summary>
-        /// Returns true if the character at the specified index 
-        /// is the specified char. 
+        /// Returns true if the character at the specified index
+        /// is the specified char.
         /// Leaves index one past the character.
         /// </summary>
         private static bool Sink(string expression, ref int i, char c)
diff --git a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
index db111e979dc..5d3c0c41de2 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
@@ -19,45 +19,45 @@ namespace Microsoft.Build.BuildEngine
     ///     - quick lookups
     ///     - scoping down of item subsets in nested scopes (useful for batches)
     ///     - isolation of adds, removes, modifies, and property sets inside nested scopes
-    ///     
+    ///
     /// When retrieving the item group for an item type, each table is consulted in turn,
     /// starting with the primary table (the "top" or "innermost" table), until a table is found that has an entry for that type.
     /// When an entry is found, it is returned without looking deeper.
     /// This makes it possible to let callers see only a subset of items without affecting or cloning the original item groups,
     /// by populating a scope with item groups that are empty or contain subsets of items in lower scopes.
-    /// 
+    ///
     /// Instances of this class can be cloned with Clone() to share between batches.
-    /// 
+    ///
     /// When EnterScope() is called, a fresh primary table is inserted, and all adds and removes will be invisible to
     /// any clones made before the scope was entered and anyone who has access to item groups in lower tables.
-    /// 
+    ///
     /// When LeaveScope() is called, the primary tables are merged into the secondary tables, and the primary tables are discarded.
     /// This makes the adds and removes in the primary tables visible to clones made during the previous scope.
-    /// 
+    ///
     /// Scopes can be populated (before Adds, Removes, and Lookups) using PopulateWithItem(). This reduces the set of items of a particular
     /// type that are visible in a scope, because lookups of items of this type will stop at this level and see the subset, rather than the
     /// larger set in a scope below.
-    /// 
+    ///
     /// Items can be added or removed by calling AddNewItem() and RemoveItem(). Only the primary level is modified.
     /// When items are added or removed they enter into a primary table exclusively for adds or removes, instead of the main primary table.
     /// This allows the adds and removes to be applied to the scope below on LeaveScope(). Even when LeaveScope() is called, the adds and removes
     /// stay in their separate add and remove tables: if they were applied to a main table, they could truncate the downward traversal performed by lookups
     /// and hide items in a lower main table. Only on the final call of LeaveScope() can all adds and removes be applied to the outermost table, i.e., the project.
-    /// 
+    ///
     /// Much the same applies to properties.
-    /// 
+    ///
     /// For sensible semantics, only the current primary scope can be modified at any point.
     /// </summary>
     /// <remarks>
     /// THREAD SAFETY:
-    ///     - BuildItemGroups are currently unsafe for concurrent reading and writing (they have a List field). So a Lookup cannot be read and written to 
+    ///     - BuildItemGroups are currently unsafe for concurrent reading and writing (they have a List field). So a Lookup cannot be read and written to
     ///       concurrently.
-    ///     - To avoid this problem, the lookup can be populated with a clone of an item group, and lookup can be Truncate()'d at the level of that clone 
+    ///     - To avoid this problem, the lookup can be populated with a clone of an item group, and lookup can be Truncate()'d at the level of that clone
     ///       until control of the lookup goes back to the safe thread.
-    /// 
+    ///
     /// FUTURE:
-    ///     - We could eliminate all the code performing resetting of project build state (currently implemented using special tables for Output properties and 
-    ///       backups of persisted item groups and metadata before modification) by using a Lookup, entering scope at the start of a build, 
+    ///     - We could eliminate all the code performing resetting of project build state (currently implemented using special tables for Output properties and
+    ///       backups of persisted item groups and metadata before modification) by using a Lookup, entering scope at the start of a build,
     ///       then when build state needs to be reset, throwing away the Lookup (rather than leaving scope).
     /// </remarks>
     internal class Lookup
@@ -81,7 +81,7 @@ internal class Lookup
 
         /// <summary>
         /// Projects store their items in a hashtable of item groups by name (which we handle in our lookup table)
-        /// but also in a single item group. When we leave scope the last time, we have to update this item group as 
+        /// but also in a single item group. When we leave scope the last time, we have to update this item group as
         /// well. This is only used when we leave scope the last time.
         /// </summary>
         private BuildItemGroup projectItems;
@@ -299,8 +299,8 @@ internal void LeaveScope()
             MustBeOwningThread();
             ErrorUtilities.VerifyThrowNoAssert(lookupEntries.Count >= 2, "Too many calls to Leave().");
 
-            // Our lookup works by stopping the first time it finds an item group of the appropriate type. 
-            // So we can't apply an add directly into the table below because that could create a new group 
+            // Our lookup works by stopping the first time it finds an item group of the appropriate type.
+            // So we can't apply an add directly into the table below because that could create a new group
             // of that type, which would cause the next lookup to stop there and miss any existing items in a table below.
             // Instead we keep adds stored separately until we're leaving the very last scope. Until then
             // we only move adds down into the next add table below, and when we lookup we consider both tables.
@@ -316,7 +316,7 @@ internal void LeaveScope()
 
             // Let go of our pointer into the clone table; we assume we won't need it after leaving scope and want to save memory.
             // This is an assumption on IntrinsicTask, that it won't ask to remove or modify a clone in a higher scope than it was handed out in.
-            // We mustn't call cloneTable.Clear() because other clones of this lookup may still be using it. When the last lookup clone leaves scope, 
+            // We mustn't call cloneTable.Clear() because other clones of this lookup may still be using it. When the last lookup clone leaves scope,
             // the table will be collected.
             cloneTable = null;
 
@@ -458,7 +458,7 @@ private void MergeScopeIntoLastScope()
         /// </summary>
         internal BuildProperty GetProperty(string name)
         {
-            // Walk down the tables and stop when the first 
+            // Walk down the tables and stop when the first
             // property with this name is found
             foreach (LookupEntry entry in lookupEntries)
             {
@@ -746,8 +746,8 @@ internal void RemoveItem(BuildItem item)
             PrimaryRemoveTable = Utilities.CreateTableIfNecessary(PrimaryRemoveTable);
             ImportItemIntoTable(PrimaryRemoveTable, item);
 
-            // No need to remove this item from the primary add table if it's 
-            // already there -- we always apply removes after adds, so that add 
+            // No need to remove this item from the primary add table if it's
+            // already there -- we always apply removes after adds, so that add
             // will be reversed anyway.
         }
 
@@ -763,7 +763,7 @@ internal void ModifyItems(string name, BuildItemGroup group, Dictionary<string,
             MustNotBeOuterScope();
 
 #if DEBUG
-            // This item should not already be in any remove table; there is no way a project can 
+            // This item should not already be in any remove table; there is no way a project can
             // modify items that were already removed
             // Obviously, do this only in debug, as it's a slow check for bugs.
             LinkedListNode<LookupEntry> node = lookupEntries.First;
@@ -1043,7 +1043,7 @@ private void MustNotBeInTable(Hashtable table, string name, BuildItemGroup group
 
         /// <summary>
         /// Verify item is not in any table in any scope
-        /// </summary>        
+        /// </summary>
         private void MustNotBeInAnyTables(BuildItem item)
         {
             // This item should not already be in any table; there is no way a project can
@@ -1088,7 +1088,7 @@ private void MustNotBeOuterScope()
     /// <summary>
     /// Read-only wrapper around a lookup.
     /// Passed to Expander and ItemExpander, which only need to
-    /// use a lookup in a read-only fashion, thus increasing 
+    /// use a lookup in a read-only fashion, thus increasing
     /// encapsulation of the data in the Lookup.
     /// </summary>
     internal class ReadOnlyLookup
@@ -1150,8 +1150,8 @@ internal LookupEntry(Hashtable items, BuildPropertyGroup properties)
 
         /// <summary>
         /// The main table, populated with items that
-        /// are initially visible in this scope. Does not 
-        /// include adds or removes unless it's the table in 
+        /// are initially visible in this scope. Does not
+        /// include adds or removes unless it's the table in
         /// the outermost scope.
         /// </summary>
         internal Hashtable Items
diff --git a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
index 8a68a2a2f19..6ccaf624e4e 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.BuildEngine
     /// This call is used to contain, serialize and deserialize arguments for call
     /// made via INodeProvider and IEngineCallback interfaces. To make calls via these
     /// interfaces asyncronous the parameters are queued up for a IO thread which
-    /// reads/writes the shared memory buffer to transfer these parameters cross 
+    /// reads/writes the shared memory buffer to transfer these parameters cross
     /// process.
     /// </summary>
     internal abstract class LocalCallDescriptor
@@ -316,7 +316,7 @@ internal BuildRequest[] BuildRequests
                 return buildRequests;
             }
         }
-        #endregion 
+        #endregion
 
         #region CustomSerializationToStream
         internal override void WriteToStream(BinaryWriter writer)
@@ -1439,7 +1439,7 @@ internal override void WriteToStream(BinaryWriter writer)
                 writer.Write((byte)1);
                 writer.Write(scopeName);
             }
-            #endregion 
+            #endregion
             #region ScopeProperties
             if (scopeProperties == null)
             {
@@ -1461,7 +1461,7 @@ internal override void WriteToStream(BinaryWriter writer)
                 writer.Write((byte)1);
                 writer.Write(scopeToolsVersion);
             }
-            #endregion 
+            #endregion
             writer.Write((byte)cacheContentType);
         }
         internal override void CreateFromStream(BinaryReader reader)
@@ -1572,7 +1572,7 @@ internal enum LocalCallType
         /// </summary>
         ShutdownNode = 8,
         /// <summary>
-        /// Call type for the node to indicate that it has shutdown 
+        /// Call type for the node to indicate that it has shutdown
         /// </summary>
         ShutdownComplete = 9,
         /// <summary>
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index e8b4a9f0417..73869190849 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -110,10 +110,10 @@ private void StartCommunicationThreads()
             // The writer thread should be created before the
             // reader thread because some LocalCallDescriptors
             // assume the shared memory for the writer thread
-            // has already been created. The method will both 
-            // instantiate the shared memory for the writer 
+            // has already been created. The method will both
+            // instantiate the shared memory for the writer
             // thread and also start the writer thread itself.
-            // We will verifyThrow in the method if the 
+            // We will verifyThrow in the method if the
             // sharedMemory was not created correctly.
             engineCallback.StartWriterThread(nodeNumber);
 
@@ -124,7 +124,7 @@ private void StartCommunicationThreads()
                         // Generate the name for the shared memory region
                         LocalNodeProviderGlobalNames.NodeInputMemoryName(nodeNumber),
                         SharedMemoryType.ReadOnly,
-                        // Reuse an existing shared memory region as it should have already 
+                        // Reuse an existing shared memory region as it should have already
                         // been created by the parent node side
                         true
                   );
@@ -150,7 +150,7 @@ private void StopCommunicationThreads()
             Thread writerThread = engineCallback.GetWriterThread();
             // The threads may not exist if the child has timed out before the parent has told the node
             // to start up its communication threads. This can happen if the node is started with /nodemode:x
-            // and no parent is running, or if the parent node has spawned a new process and then crashed 
+            // and no parent is running, or if the parent node has spawned a new process and then crashed
             // before establishing communication with the child node.
             writerThread?.Join();
 
@@ -263,7 +263,7 @@ public static void StartLocalNodeServer(int nodeNumber)
                     globalNodeActivate.Reset();
                     // Set the global inuse event so other parent processes know this node is now initialized
                     globalNodeInUse.Set();
-                    // Make a copy of the parents handle to protect ourselves in case the parent dies, 
+                    // Make a copy of the parents handle to protect ourselves in case the parent dies,
                     // this is to prevent a parent from reserving a node another parent is trying to use.
                     globalNodeReserveHandle =
                         new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeReserveEventName(nodeNumber));
@@ -359,7 +359,7 @@ private void SharedMemoryReaderThread()
                     {
                         // Read the list of LocalCallDescriptors from sharedMemory,
                         // this will be null if a large object is being read from shared
-                        // memory and will continue to be null until the large object has 
+                        // memory and will continue to be null until the large object has
                         // been completly sent.
                         IList localCallDescriptorList = sharedMemory.Read();
 
@@ -472,7 +472,7 @@ string parentStartupDirectory
 
             inUseEvent.Set();
 
-            // Clear the environment so that we dont have extra variables laying around, this 
+            // Clear the environment so that we dont have extra variables laying around, this
             // may be a performance hog but needs to be done
             IDictionary variableDictionary = Environment.GetEnvironmentVariables();
             foreach (string variableName in variableDictionary.Keys)
@@ -518,7 +518,7 @@ private bool IsParentProcessAlive()
 
             if (!isParentAlive)
             {
-                // No logging's going to reach the parent at this point: 
+                // No logging's going to reach the parent at this point:
                 // indicate on the console what's going on
                 string message = ResourceUtilities.FormatResourceString("ParentProcessUnexpectedlyDied", node.NodeId);
                 Console.WriteLine(message);
@@ -605,8 +605,8 @@ internal static string DumpFileName
         // This event is used to cause the child to create the shared memory structures to start communication
         // with the parent
         private static EventWaitHandle globalInitiateActivationEvent;
-        // This event is used to indicate to the parent that shared memory buffers have been created and are ready for 
-        // use 
+        // This event is used to indicate to the parent that shared memory buffers have been created and are ready for
+        // use
         private static EventWaitHandle globalNodeActivate;
         // Private local events
         private static ManualResetEvent communicationThreadExitEvent = new ManualResetEvent(false);
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
index d88fc4c9267..fd704d3f171 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
@@ -93,7 +93,7 @@ internal static string NodeInitiateActivationEventName(int nodeNumber)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="nodeNumber"></param>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
index 7eb8902bcd6..6956ca4e3e0 100644
--- a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
+++ b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
@@ -38,7 +38,7 @@ internal enum ObjectType
         // Has the object been serialized using .net serialization (binary formatter)
         NetSerialization = 1,
         // Used to mark that the next int read represents how many bytes are in the
-        // large object which is about to be sent      
+        // large object which is about to be sent
         FrameMarker = 2,
         // Mark the end of the batch in sharedMemory.
         EndMarker = 3,
@@ -121,7 +121,7 @@ internal SharedMemory(string name, SharedMemoryType type, bool allowExistingMapp
                 InitializeStreams(type);
                 try
                 {
-                    // This could fail if two different administrator accounts try and 
+                    // This could fail if two different administrator accounts try and
                     // access each others nodes as events and semaphores are protected
                     // against cross account access
                     InitializeSynchronization();
@@ -156,8 +156,8 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
             IntPtr pSDNative = IntPtr.Zero;
             try
             {
-                // Check to see if the user is an administrator, this is done to prevent non 
-                // administrator processes from accessing the shared memory. On a vista machine 
+                // Check to see if the user is an administrator, this is done to prevent non
+                // administrator processes from accessing the shared memory. On a vista machine
                 // the check does not differentiate beween the application being elevated to have
                 // administrator rights or the application being started with administrator rights.
                 // If the user is an administator create a new set of securityAttributes which make
@@ -178,7 +178,7 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
                     Marshal.StructureToPtr(saAttr, pointerToSecurityAttributes, true);
                 }
 
-                // The file mapping has either the default (current user) security permissions or 
+                // The file mapping has either the default (current user) security permissions or
                 // permissions restricted to only administrator users depending on the check above.
                 // If pointerToSecurityAttributes is null the default permissions are used.
                 this.pageFileMapping =
@@ -213,7 +213,7 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
 
             if (!this.pageFileMapping.IsInvalid && !pageFileMapping.IsClosed)
             {
-                // Maps a view of a file mapping into the address space of the calling process so that we can use the 
+                // Maps a view of a file mapping into the address space of the calling process so that we can use the
                 // view to read and write to the shared memory region.
                 this.pageFileView =
                     NativeMethods.MapViewOfFile
@@ -375,7 +375,7 @@ private bool IsFull
             get
             {
                 // If the flag is set true is returned
-                // A timeout of 0 means the WaitOne will time out 
+                // A timeout of 0 means the WaitOne will time out
                 // instantly and return false if the flag is not set.
                 return fullFlag.WaitOne(0, false);
             }
@@ -603,7 +603,7 @@ private void SerializeCallDescriptorToStream(DualQueue<LocalCallDescriptor> obje
         {
             // Get the object by peeking at the queue rather than dequeueing the object. This is done
             // because we only want to dequeue the object when it has completely been put in shared memory.
-            // This may be done right away if the object is small enough to fit in the shared memory or 
+            // This may be done right away if the object is small enough to fit in the shared memory or
             // may happen after a the object is sent as a number of smaller chunks.
             object objectToWrite = objectsToWrite.Peek();
             Debug.Assert(objectToWrite != null, "Expect to get a non-null object from the queue");
@@ -703,19 +703,19 @@ internal IList Read()
             {
                 if (NumberOfUnreadBatches > 0)
                 {
-                    // The read stream is a memory stream where data read from the shared memory section 
-                    // will be copied to. From  this memory stream LocalCallDescriptors are deserialized. 
+                    // The read stream is a memory stream where data read from the shared memory section
+                    // will be copied to. From  this memory stream LocalCallDescriptors are deserialized.
                     // Stream position may not be 0 if we are reading a multipart object
                     int readStartPosition = (int)readStream.Position;
 
-                    // Read the first int from the memory file. This indicates the number of bytes written to 
+                    // Read the first int from the memory file. This indicates the number of bytes written to
                     // shared memory by the write method.
                     int endWritePosition = Marshal.ReadInt32((IntPtr)((int)pageFileView));
 
                     // Copy the bytes written into the shared memory section into the readStream memory stream.
                     Marshal.Copy
                     (
-                        (IntPtr)((int)pageFileView + 4 + readStream.Position), // Source 
+                        (IntPtr)((int)pageFileView + 4 + readStream.Position), // Source
                         readBuffer, //Destination
                         (int)(readStream.Position + (readBytesTotal - readBytesRemaining)), // Start Index
                         (int)(endWritePosition - readStream.Position) //Length of data
@@ -774,8 +774,8 @@ internal IList Read()
                             }
                         }
 
-                        // Deserialized the objects in the read stream and add them into the arrayList as long as 
-                        // we did not encounter a frameMarker which says a large object is next or the end marker 
+                        // Deserialized the objects in the read stream and add them into the arrayList as long as
+                        // we did not encounter a frameMarker which says a large object is next or the end marker
                         // which marks the end of the batch.
                         while (((int)ObjectType.EndMarker != objectId) && ((int)ObjectType.FrameMarker != objectId))
                         {
@@ -911,7 +911,7 @@ internal void Reset()
 
         private BinaryFormatter binaryFormatter;
 
-        // Binary reader and writer used to read and write from the memory streams used to contain the deserialized LocalCallDescriptors before and after they are copied 
+        // Binary reader and writer used to read and write from the memory streams used to contain the deserialized LocalCallDescriptors before and after they are copied
         // to and from the shared memory region.
         private BinaryWriter binaryWriter;
         private BinaryReader binaryReader;
@@ -926,8 +926,8 @@ internal void Reset()
         private MemoryStream readStream;
 
         // The count on a semaphore is decremented each time a thread enters the semaphore,
-        // and incremented when a thread releases the semaphore. 
-        // When the count is zero, subsequent requests block until other threads release the semaphore. 
+        // and incremented when a thread releases the semaphore.
+        // When the count is zero, subsequent requests block until other threads release the semaphore.
         // A semaphore is considered siginaled when the count > 1 and not siginaled when the count is 0.
 
         // unreadBatchCounter is used to track how many batches are remaining to be read from shared memory.
@@ -960,10 +960,10 @@ internal void Reset()
 
         // Because we are using reflection to get the writeToStream and readFromStream methods from the classes in the framework assembly we found
         // we were spending a lot of time reflecting for these methods. The loggingTypeCache, caches the methodInfo for the classes and then look them
-        // up when serializing or deserializing the objects. 
+        // up when serializing or deserializing the objects.
         private Hashtable loggingTypeCache;
 
-        // Keep a pointer to the queue which contains the large object which is being deserialized. We do this because we want to make sure 
+        // Keep a pointer to the queue which contains the large object which is being deserialized. We do this because we want to make sure
         // after the object is properly sent we dequeue off the correct queue.
         private DualQueue<LocalCallDescriptor> largeObjectsQueue;
         #endregion
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index 81bcca5a7f1..e95d131901a 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -137,7 +137,7 @@ public void ParseParameters()
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the keys 
+        /// An implementation of IComparer useful for comparing the keys
         /// on DictionaryEntry's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -153,7 +153,7 @@ public int Compare(Object a, Object b)
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the ItemSpecs 
+        /// An implementation of IComparer useful for comparing the ItemSpecs
         /// on ITaskItem's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -238,7 +238,7 @@ internal void WriteLinePrettyFromResource(int indentLevel, string resourceString
         }
 
         /// <summary>
-        /// Writes to the log, using the default indentation. Does not 
+        /// Writes to the log, using the default indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(string formattedString)
@@ -291,7 +291,7 @@ internal void ShowPerfSummary()
         }
 
         /// <summary>
-        /// Writes to the log, using the specified indentation. Does not 
+        /// Writes to the log, using the specified indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(int indentLevel, string formattedString)
@@ -448,7 +448,7 @@ internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandle
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="properties">List of properties</param>
@@ -502,7 +502,7 @@ internal virtual void OutputProperties(ArrayList list)
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="items">List of items</param>
@@ -765,7 +765,7 @@ internal virtual void PrintCounterMessage(WriteLinePrettyFromResourceDelegate Wr
             }
 
             /// <summary>
-            /// Returns an IComparer that will put erformance counters 
+            /// Returns an IComparer that will put erformance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal static IComparer DescendingByElapsedTimeComparer
@@ -774,7 +774,7 @@ internal static IComparer DescendingByElapsedTimeComparer
             }
 
             /// <summary>
-            /// Private IComparer class for sorting performance counters 
+            /// Private IComparer class for sorting performance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal class DescendingByElapsedTime : IComparer
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index 049c264d0ac..6405295a126 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -36,8 +36,8 @@ namespace Microsoft.Build.BuildEngine
 
     /// <summary>
     /// This class implements the default logger that outputs event data
-    /// to the console (stdout). 
-    /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger, 
+    /// to the console (stdout).
+    /// It is a facade: it creates, wraps and delegates to a kind of BaseConsoleLogger,
     /// either SerialConsoleLogger or ParallelConsoleLogger.
     /// </summary>
     /// <remarks>This class is not thread safe.</remarks>
@@ -287,7 +287,7 @@ protected WriteHandler WriteHandler
 
         /// <summary>
         /// Apply a parameter.
-        /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has 
+        /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has
         /// no good reason for being public.
         /// </summary>
         public void ApplyParameter(string parameterName, string parameterValue)
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index 334a6a4c43d..05f5b1d2269 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -196,7 +196,7 @@ public string Parameters
         #region Data
         // The file logger which will do the actual logging of the node's build output
         private FileLogger nodeFileLogger;
-        // Reference for the central logger 
+        // Reference for the central logger
         private IEventRedirector buildEventRedirector;
 
         // The Id of the node the forwardingLogger is attached to
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 1f574b8af5e..25db6182dcf 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// A specialization of the ConsoleLogger that logs to a file instead of the console.
-    /// The output in terms of what is written and how it looks is identical. For example you can 
+    /// The output in terms of what is written and how it looks is identical. For example you can
     /// log verbosely to a file using the FileLogger while simultaneously logging only high priority events
     /// to the console using a ConsoleLogger.
     /// </summary>
diff --git a/src/Deprecated/Engine/Logging/LogFormatter.cs b/src/Deprecated/Engine/Logging/LogFormatter.cs
index 34d8ee31a0c..dfa7ff4a349 100644
--- a/src/Deprecated/Engine/Logging/LogFormatter.cs
+++ b/src/Deprecated/Engine/Logging/LogFormatter.cs
@@ -22,7 +22,7 @@ internal static class LogFormatter
         internal static string FormatLogTimeStamp(DateTime timeStamp)
         {
             // From http://msdn2.microsoft.com/en-us/library/8kb3ddd4.aspx
-            // Custom DateTime Format Strings  
+            // Custom DateTime Format Strings
             //
             // HH Represents the hour as a number from 00 through 23, that is,
             //    the hour as represented by a zero-based 24-hour clock that counts the hours since midnight.
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index 227d86a6940..fabc6e48949 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -317,7 +317,7 @@ internal void CreateFromStream(BinaryReader reader)
             {
                 loggerClassName = reader.ReadString();
             }
-            #endregion 
+            #endregion
             #region LoggerSwitchParameters
             if (reader.ReadByte() == 0)
             {
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index f90d16e88e4..ecf3dc192b4 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -152,7 +152,7 @@ private void ShownBuildEventContext(BuildEventContext e)
 
         /// <summary>
         /// Reset the states of per-build member variables
-        /// VSW#516376 
+        /// VSW#516376
         /// </summary>
         internal override void ResetConsoleLoggerState()
         {
@@ -293,7 +293,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
                 // if verbosity is normal, detailed or diagnostic
                 if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
                 {
-                    // The time elapsed is the difference between when the BuildStartedEventArg 
+                    // The time elapsed is the difference between when the BuildStartedEventArg
                     // was created and when the BuildFinishedEventArg was created
                     string timeElapsed = LogFormatter.FormatTimeSpan(e.Timestamp - buildStarted);
 
@@ -307,7 +307,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// Does this in a "flat" style, without context.
         /// </summary>
@@ -319,7 +319,7 @@ private void ShowFlatErrorWarningSummary()
             }
 
             // If we're showing only warnings and/or errors, don't summarize.
-            // This is the buildc.err case. There's no point summarizing since we'd just 
+            // This is the buildc.err case. There's no point summarizing since we'd just
             // repeat the entire log content again.
             if (showOnlyErrors || showOnlyWarnings)
             {
@@ -352,7 +352,7 @@ private void ShowFlatErrorWarningSummary()
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// Does this in a "nested" style.
         /// </summary>
@@ -364,7 +364,7 @@ private void ShowNestedErrorWarningSummary()
             }
 
             // If we're showing only warnings and/or errors, don't summarize.
-            // This is the buildc.err case. There's no point summarizing since we'd just 
+            // This is the buildc.err case. There's no point summarizing since we'd just
             // repeat the entire log content again.
             if (showOnlyErrors || showOnlyWarnings)
             {
@@ -397,13 +397,13 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
                 T errorWarningEventArgs = (T)listToProcess[listCount];
 
                 // Target event may be null for a couple of reasons:
-                // 1) If the event was from a project load, or engine 
+                // 1) If the event was from a project load, or engine
                 // 2) If the flushing of the event queue for each request and result is turned off
                 // as this could cause errors and warnings to be seen by the logger after the target finished event
                 // which would cause the error or warning to have no matching target started event as they are removed
                 // when a target finished event is logged.
-                // 3) On NORMAL verbosity if the error or warning occurres in a project load then the error or warning and the target started event will be forwarded to 
-                // different forwarding loggers which cannot communicate to each other, meaning there will be no matching target started event logged 
+                // 3) On NORMAL verbosity if the error or warning occurres in a project load then the error or warning and the target started event will be forwarded to
+                // different forwarding loggers which cannot communicate to each other, meaning there will be no matching target started event logged
                 // as the forwarding logger did not know to forward the target started event
                 string targetName = null;
                 TargetStartedEventMinimumFields targetEvent = buildEventManager.GetTargetStartedEvent(errorWarningEventArgs.BuildEventContext);
@@ -591,7 +591,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                             }
                         }
 
-                        // In single proc only make a space between the project done event and the next line, this 
+                        // In single proc only make a space between the project done event and the next line, this
                         // is to increase the readability on the single proc log when there are a number of done events
                         // or a mix of done events and project started events. Also only do this on the console and not any log file.
                         if (numberOfProcessors == 1 && runningWithCharacterFileType)
@@ -611,7 +611,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="properties">List of properties</param>
@@ -653,7 +653,7 @@ internal override void OutputProperties(ArrayList list)
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="items">List of items</param>
@@ -851,10 +851,10 @@ public override void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         public override void ErrorHandler(object sender, BuildErrorEventArgs e)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
-            // Keep track of the number of error events raisd 
+            // Keep track of the number of error events raisd
             errorCount++;
 
-            // If there is an error we need to walk up the call stack and make sure that 
+            // If there is an error we need to walk up the call stack and make sure that
             // the project started events back to the root project know an error has occurred
             // and are not removed when they finish
             buildEventManager.SetErrorWarningFlagOnCallStack(e.BuildEventContext);
@@ -900,7 +900,7 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
             // Keep track of the number of warning events raised during the build
             warningCount++;
 
-            // If there is a warning we need to walk up the call stack and make sure that 
+            // If there is a warning we need to walk up the call stack and make sure that
             // the project started events back to the root project know a warning has ocured
             // and are not removed when they finish
             buildEventManager.SetErrorWarningFlagOnCallStack(e.BuildEventContext);
@@ -984,7 +984,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
 
             if (print)
             {
-                // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be 
+                // If the event has a valid Project contextId but the project started event has not been fired, the message needs to be
                 // buffered until the project started event is fired
                 if (
                        hasBuildStarted
@@ -1022,14 +1022,14 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
                 return;
             }
 
-            // Display any project started events which were deferred until a visible 
+            // Display any project started events which were deferred until a visible
             // message from their project is displayed
             if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
             {
                 DisplayDeferredProjectStartedEvent(e);
             }
 
-            // Display any target started events which were deferred until a visible 
+            // Display any target started events which were deferred until a visible
             // message from their target is displayed
             if (IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
@@ -1185,7 +1185,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                     // Take into account the new line char which will be added to the end or each reformatted string
                     int bufferWidthMinusNewLine = bufferWidth - 1;
 
-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. 
+                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages.
                     // If there is not enough room just print the message out and let the console do the formatting
                     bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;
                     bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 919014c2898..648e5f48a44 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -295,7 +295,7 @@ public int GetHashCode(T x)
     }
 
     /// <summary>
-    /// This class stands in for a full project started event because it contains only the 
+    /// This class stands in for a full project started event because it contains only the
     /// minimum amount of inforomation needed for the logger
     /// </summary>
     internal class ProjectStartedEventMinimumFields
@@ -430,7 +430,7 @@ internal ProjectStartedEventMinimumFields(int projectKey, int entryPointKey, Pro
     }
 
     /// <summary>
-    /// This class stands in for a full target started event because it contains only the 
+    /// This class stands in for a full target started event because it contains only the
     /// minimum amount of inforomation needed for the logger
     /// </summary>
     internal class TargetStartedEventMinimumFields
@@ -517,7 +517,7 @@ internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent)
     }
 
     /// <summary>
-    /// This class is used as a key to group warnings and errors by the project entry point and the target they 
+    /// This class is used as a key to group warnings and errors by the project entry point and the target they
     /// error or warning was in
     /// </summary>
     internal class ErrorWarningSummaryDictionaryKey
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index 35a75e0f540..7fd23470acf 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -72,7 +72,7 @@ ColorResetter colorReset
 
         /// <summary>
         /// Reset the states of per-build member variables
-        /// VSW#516376 
+        /// VSW#516376
         /// </summary>
         internal override void ResetConsoleLoggerState()
         {
@@ -182,7 +182,7 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         }
 
         /// <summary>
-        /// At the end of the build, repeats the errors and warnings that occurred 
+        /// At the end of the build, repeats the errors and warnings that occurred
         /// during the build, and displays the error count and warning count.
         /// </summary>
         private void ShowErrorWarningSummary()
@@ -300,7 +300,7 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                 counter.InScope = false;
             }
 
-            // if verbosity is detailed or diagnostic, 
+            // if verbosity is detailed or diagnostic,
             // or there was an error or warning
             if (contextStack.Peek().hasErrorsOrWarnings
                 || (IsVerbosityAtLeast(LoggerVerbosity.Detailed)))
@@ -379,7 +379,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
 
             bool targetHasErrorsOrWarnings = contextStack.Peek().hasErrorsOrWarnings;
 
-            // if verbosity is diagnostic, 
+            // if verbosity is diagnostic,
             // or there was an error or warning and verbosity is normal or detailed
             if ((targetHasErrorsOrWarnings && (IsVerbosityAtLeast(LoggerVerbosity.Normal)))
                   || Verbosity == LoggerVerbosity.Diagnostic)
@@ -882,8 +882,8 @@ string parent
 
             /// <summary>
             /// For TargetStarted events, this stores the filename where the Target is defined
-            /// (e.g., Microsoft.Common.targets).  This is different than the project that is 
-            /// being built.  
+            /// (e.g., Microsoft.Common.targets).  This is different than the project that is
+            /// being built.
             /// For ProjectStarted events, this is null.
             /// </summary>
             internal string file;
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index 80cb2bc1705..a90066fefd3 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -27,19 +27,19 @@ internal enum PropertyType
         // by the author.
         NormalProperty,
 
-        // An "imported" property is like a "normal" property, except that 
+        // An "imported" property is like a "normal" property, except that
         // instead of coming directly from the project file, its definition
         // is in one of the imported files (e.g., "CSharp.buildrules").
         ImportedProperty,
 
         // A "global" property is the kind that is set outside of the project file.
         // Once such a property is set, it cannot be overridden by the project file.
-        // For example, when the user sets a property via a switch on the XMake 
+        // For example, when the user sets a property via a switch on the XMake
         // command-line, this is a global property.  In the IDE case, "Configuration"
         // would be a global property set by the IDE.
         GlobalProperty,
 
-        // A "reserved" property behaves much like a read-only property, except 
+        // A "reserved" property behaves much like a read-only property, except
         // that the names are not arbitrary; they are chosen by us.  Also,
         // no user can ever set or override these properties.  For example,
         // "XMakeProjectName" would be a property that is only settable by
@@ -88,15 +88,15 @@ public class BuildProperty
         // this node may look like this:
         //      <WarningLevel Condition="...">4</WarningLevel>
         //
-        // If this property is not represented by an actual XML element in the 
+        // If this property is not represented by an actual XML element in the
         // project file, it's okay if this is null.
         private XmlElement propertyElement = null;
 
-        // This is the specific XML attribute in the above XML element which 
+        // This is the specific XML attribute in the above XML element which
         // contains the "Condition".
         private XmlAttribute conditionAttribute = null;
 
-        // If this property is persisted in the project file, then we need to 
+        // If this property is persisted in the project file, then we need to
         // store a reference to the parent <PropertyGroup>.
         private BuildPropertyGroup parentPersistedPropertyGroup = null;
 
@@ -696,7 +696,7 @@ internal bool IsEquivalent
             BuildProperty compareToProperty
         )
         {
-            // Intentionally do not compare parentPersistedPropertyGroup, because this is 
+            // Intentionally do not compare parentPersistedPropertyGroup, because this is
             // just a back-pointer, and doesn't really contribute to the "identity" of
             // the property.
 
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index c067add2c83..ecbd7f6b82b 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -32,7 +32,7 @@ public class BuildPropertyGroup : IItemPropertyGrouping, IEnumerable
 
         // This is the XML element representing the <PropertyGroup> in the XMake
         // project file.  If this BuildPropertyGroup object doesn't represent an
-        // actual <PropertyGroup> element in the XMake project file, it's 
+        // actual <PropertyGroup> element in the XMake project file, it's
         // okay if this remains null throughout the life of this object.
         private XmlElement propertyGroupElement = null;
 
@@ -66,7 +66,7 @@ public class BuildPropertyGroup : IItemPropertyGrouping, IEnumerable
         // in the order that they appear in the project file.  In this list,
         // there can be multiple properties of the same name.  This member
         // is only valid (non-null) if this is a persisted <PropertyGroup>.
-        // For virtual property groups (e.g., evaluated property groups, 
+        // For virtual property groups (e.g., evaluated property groups,
         // global property groups, etc.), this will remain null.
         private ArrayList propertyList = null;
 
@@ -343,7 +343,7 @@ public string Condition
 
             set
             {
-                // If this BuildPropertyGroup object is not actually represented by a 
+                // If this BuildPropertyGroup object is not actually represented by a
                 // <PropertyGroup> element in the project file, then do not allow
                 // the caller to set the condition.
                 MustBePersisted("CannotSetCondition", null);
@@ -363,7 +363,7 @@ public string Condition
         /// </summary>
         public void SetImportedPropertyGroupCondition(string condition)
         {
-            // If this BuildPropertyGroup object is not actually represented by a 
+            // If this BuildPropertyGroup object is not actually represented by a
             // <PropertyGroup> element in the project file, then do not allow
             // the caller to set the condition.
             MustBePersisted("CannotSetCondition", null);
@@ -538,12 +538,12 @@ public BuildProperty this[string propertyName]
             get
             {
                 // We don't support this method for PropertyGroups that are persisted.
-                // This is because persisted PropertyGroups can contain multiple 
+                // This is because persisted PropertyGroups can contain multiple
                 // properties with the same name, so you can't index by name.
                 MustBeVirtual("CannotAccessPropertyByName");
 
-                // Do the lookup in the hash table using the hash table's 
-                // indexer method.  Get back the property data object, 
+                // Do the lookup in the hash table using the hash table's
+                // indexer method.  Get back the property data object,
                 // which will be "null" if the property hasn't been set. Note
                 // that we key off property names in a case-insensitive fashion.
                 return (BuildProperty)propertyTableByName[propertyName];
@@ -630,7 +630,7 @@ bool deepClone
 
                 if (deepClone)
                 {
-                    // Loop through every BuildProperty in our collection, and add those same properties 
+                    // Loop through every BuildProperty in our collection, and add those same properties
                     // to the cloned collection.
 
                     // Create a new virtual BuildPropertyGroup.
@@ -697,7 +697,7 @@ part of the project */
                     this.importedFromAnotherProject
                     );
 
-                // Loop through every BuildProperty in our collection, and add those same properties 
+                // Loop through every BuildProperty in our collection, and add those same properties
                 // to the cloned collection.
                 foreach (BuildProperty property in this)
                 {
@@ -734,8 +734,8 @@ internal void ImportInitialProperties
             BuildPropertyGroup globalProperties
         )
         {
-            // The consumer of the OM has the ability to add new properties to the 
-            // GlobalProperties BuildPropertyGroup, and the OM doesn't expose the 
+            // The consumer of the OM has the ability to add new properties to the
+            // GlobalProperties BuildPropertyGroup, and the OM doesn't expose the
             // property type, because that would be too dangerous.  So all properties
             // created by the OM consumer will be "normal" properties, even those
             // set in the GlobalProperties BuildPropertyGroup.  But in order to make
@@ -782,7 +782,7 @@ BuildProperty newProperty
         {
             // We don't support this method for PropertyGroups that are
             // represented by an actual <PropertyGroup> element.  This is because
-            // persisted PropertyGroups can contain multiple properties with the same 
+            // persisted PropertyGroups can contain multiple properties with the same
             // name, so the behavior of SetProperty becomes ambiguous.
             MustBeVirtual("NeedVirtualPropertyGroup");
 
@@ -794,12 +794,12 @@ BuildProperty newProperty
 
             if (existingProperty != null)
             {
-                // If the existing property is an XMake reserved property, we may have an 
+                // If the existing property is an XMake reserved property, we may have an
                 // invalid project file, because reserved properties are not allowed to
                 // be set.
-                // Don't fail if the new property is itself a "reserved" property.  We 
-                // want to be able to override reserved properties with new reserved 
-                // properties, otherwise the engine itself would never be allowed to 
+                // Don't fail if the new property is itself a "reserved" property.  We
+                // want to be able to override reserved properties with new reserved
+                // properties, otherwise the engine itself would never be allowed to
                 // change the value of a reserved property.
                 ProjectErrorUtilities.VerifyThrowInvalidProject(
                     (existingProperty.Type != PropertyType.ReservedProperty) ||
@@ -808,7 +808,7 @@ BuildProperty newProperty
 
                 // Also make sure it's not a read-only property (such as a property
                 // that was set at the XMake command-line), but don't actually throw
-                // an error in this case.  Only output properties from tasks are allowed 
+                // an error in this case.  Only output properties from tasks are allowed
                 // to override read-only properties
                 if ((existingProperty.Type == PropertyType.GlobalProperty) &&
                     (newProperty.Type != PropertyType.OutputProperty))
@@ -1037,7 +1037,7 @@ BuildProperty property
         {
             error.VerifyThrowArgumentNull(property, nameof(property));
 
-            // If this is a persisted <PropertyGroup>, then remove the property element from 
+            // If this is a persisted <PropertyGroup>, then remove the property element from
             // the XML and from the array list.
             if (IsPersisted)
             {
@@ -1085,10 +1085,10 @@ string propertyName
             {
                 MustBePersisted("NeedPersistedPropertyGroup", XMakeElements.propertyGroup);
 
-                // For persisted <PropertyGroup>'s, there could be multiple properties 
-                // with the given name.  We need to loop through our arraylist of properties, 
-                // finding all the ones with the given property name, and delete them.  But we 
-                // shouldn't be modifying the arraylist while we're still enumerating through 
+                // For persisted <PropertyGroup>'s, there could be multiple properties
+                // with the given name.  We need to loop through our arraylist of properties,
+                // finding all the ones with the given property name, and delete them.  But we
+                // shouldn't be modifying the arraylist while we're still enumerating through
                 // it.  So, first we create a new list of all the properties we want to remove,
                 // and then we later go through and actually remove them.
                 ArrayList propertiesToRemove = new ArrayList();
@@ -1114,7 +1114,7 @@ string propertyName
             {
                 MustBeVirtual("NeedVirtualPropertyGroup");
 
-                // We only need to remove the BuildProperty object with the given name from 
+                // We only need to remove the BuildProperty object with the given name from
                 // the Hashtable.  There can be only one.
                 this.propertyTableByName.Remove(propertyName);
 
@@ -1191,7 +1191,7 @@ BuildPropertyGroup sourceProperties
         /// </summary>
         internal void ClearHelper(bool clearImportedPropertyGroup)
         {
-            // If this group is backed by XML, clear all attributes and 
+            // If this group is backed by XML, clear all attributes and
             // children out unless it's an imported group, in which case we don't want to modify the XML
             if (IsPersisted && !clearImportedPropertyGroup)
             {
@@ -1273,7 +1273,7 @@ internal void MarkPropertyGroupAsDirty
                 else
                 {
                     // This is not a change to the contents of the project file, however
-                    // this change does require a re-evaluation of the project.  For 
+                    // this change does require a re-evaluation of the project.  For
                     // example, if a global property changes....
                     this.ParentProject.MarkProjectAsDirtyForReevaluation();
                 }
@@ -1326,9 +1326,9 @@ internal void GatherEnvironmentVariables()
         /// </summary>
         private void SetExtensionsPathProperties()
         {
-            // We set the MSBuildExtensionsPath variables here because we don't want to make them official 
-            // reserved properties; we need the ability for people to override our default in their 
-            // environment or as a global property.  
+            // We set the MSBuildExtensionsPath variables here because we don't want to make them official
+            // reserved properties; we need the ability for people to override our default in their
+            // environment or as a global property.
 
             // "MSBuildExtensionsPath32". This points to whatever the value of "Program Files (x86)" environment variable is;
             // but on a 32 bit box this isn't set, and we should use "Program Files" instead.
@@ -1346,9 +1346,9 @@ private void SetExtensionsPathProperties()
             string extensionsPath32 = Path.Combine(programFiles32, ReservedPropertyNames.extensionsPathSuffix);
             SetProperty(new BuildProperty(ReservedPropertyNames.extensionsPath32, extensionsPath32, PropertyType.EnvironmentProperty));
 
-            // MSBuildExtensionsPath:  The way this used to work is that it would point to "Program Files\MSBuild" on both 
+            // MSBuildExtensionsPath:  The way this used to work is that it would point to "Program Files\MSBuild" on both
             // 32-bit and 64-bit machines.  We have a switch to continue using that behavior; however the default is now for
-            // MSBuildExtensionsPath to always point to the same location as MSBuildExtensionsPath32. 
+            // MSBuildExtensionsPath to always point to the same location as MSBuildExtensionsPath32.
 
             bool useLegacyMSBuildExtensionsPathBehavior = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH"));
 
@@ -1398,7 +1398,7 @@ BuildPropertyGroup compareToPropertyGroup
             if (this.Count == compareToPropertyGroup.Count)
             {
                 // If both bags do have the same number of elements, it should
-                // be sufficient to check if one bag contains all of the 
+                // be sufficient to check if one bag contains all of the
                 // elements in the other.
                 foreach (DictionaryEntry entry in this.propertyTableByName)
                 {
@@ -1449,8 +1449,8 @@ string errorResourceName
         {
             error.VerifyThrowInvalidOperation(IsVirtual, errorResourceName, XMakeElements.propertyGroup);
 
-            // If this is a virtual BuildPropertyGroup (not a <PropertyGroup> element), then 
-            // we should not have an ArrayList of BuildProperty objects ... we should only have 
+            // If this is a virtual BuildPropertyGroup (not a <PropertyGroup> element), then
+            // we should not have an ArrayList of BuildProperty objects ... we should only have
             // the hash table.
             error.VerifyThrow(this.propertyList == null,
                 "ArrayList of BuildProperty objects not expected for a virtual BuildPropertyGroup.");
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
index 8a9b3a26939..15751e39f9c 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BuildEngine
     /// This class represents a collection of persisted &lt;PropertyGroup&gt;'s.  Each
     /// MSBuild project has exactly one BuildPropertyGroupCollection, which includes
     /// all the imported PropertyGroups as well as the ones in the main project file.
-    /// 
+    ///
     /// The implementation of this class is that it's basically a Facade.  It just
     /// calls into the GroupingCollection within the Project to do it's work.  It
     /// doesn't maintain any BuildPropertyGroup state on its own.
@@ -113,8 +113,8 @@ internal BuildPropertyGroup LastLocalPropertyGroup
                 {
                     if (propertyGroup.IsImported)
                     {
-                        // As soon as we hit an imported BuildPropertyGroup, we want to 
-                        // completely bail out.  The goal of this function is 
+                        // As soon as we hit an imported BuildPropertyGroup, we want to
+                        // completely bail out.  The goal of this function is
                         // to return the last BuildPropertyGroup that is *before* any
                         // imported PropertyGroups.
                         break;
@@ -134,7 +134,7 @@ internal BuildPropertyGroup LastLocalPropertyGroup
         #region Methods
 
         /// <summary>
-        /// This ICollection method copies the contents of this collection to an 
+        /// This ICollection method copies the contents of this collection to an
         /// array.
         /// </summary>
         /// <owner>RGoel</owner>
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
index 4304d1e91d4..41fb6995ac2 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
@@ -10,12 +10,12 @@
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
-    /// An enumerable wrapper for a BuildPropertyGroup that allows read-only 
+    /// An enumerable wrapper for a BuildPropertyGroup that allows read-only
     /// access to the properties.
     /// </summary>
     /// <remarks>
     /// This class is designed to be passed to loggers.
-    /// The expense of copying properties is only incurred if and when 
+    /// The expense of copying properties is only incurred if and when
     /// a logger chooses to enumerate over it.
     /// </remarks>
     /// <owner>danmose</owner>
diff --git a/src/Deprecated/Engine/Resources/AssemblyResources.cs b/src/Deprecated/Engine/Resources/AssemblyResources.cs
index c7ed902495b..31da122b840 100644
--- a/src/Deprecated/Engine/Resources/AssemblyResources.cs
+++ b/src/Deprecated/Engine/Resources/AssemblyResources.cs
@@ -23,7 +23,7 @@ internal static class AssemblyResources
         private static ResourceManager msbuildExeResourceManager;
 
         /// <summary>
-        /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and 
+        /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and
         /// ResourceUtilities class that uses it. To make this possible, MSBuild.exe registers its resources here and they are
         /// normally consulted last. This assumes that there are no duplicated resource ID's between the Engine and MSBuild.exe.
         /// (Actually there are currently two: LoggerCreationError and LoggerNotFoundError.
diff --git a/src/Deprecated/Engine/Resources/Constants.cs b/src/Deprecated/Engine/Resources/Constants.cs
index ce6972f0b2a..8078797df60 100644
--- a/src/Deprecated/Engine/Resources/Constants.cs
+++ b/src/Deprecated/Engine/Resources/Constants.cs
@@ -81,7 +81,7 @@ internal static class Constants
         internal const string defaultSolutionWrapperProjectToolsVersion = "4.0";
 
         /// <summary>
-        /// Current version of this MSBuild Engine assembly in the 
+        /// Current version of this MSBuild Engine assembly in the
         /// form, e.g, "4.0"
         /// </summary>
         internal static string AssemblyVersion
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index 394b68bbee2..2f2aa8920eb 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -56,7 +56,7 @@ internal AssemblyNameExtension(string assemblyName)
 
         /// <summary>
         /// Construct from a string, but immediately construct a real AssemblyName.
-        /// This will cause an exception to be thrown up front if the assembly name 
+        /// This will cause an exception to be thrown up front if the assembly name
         /// isn't well formed.
         /// </summary>
         /// <param name="assemblyName">
@@ -253,7 +253,7 @@ internal int CompareTo(AssemblyNameExtension that)
         /// <returns></returns>
         internal new int GetHashCode()
         {
-            // Ok, so this isn't a great hashing algorithm. However, basenames with different 
+            // Ok, so this isn't a great hashing algorithm. However, basenames with different
             // versions or PKTs are relatively uncommon and so collisions should be low.
             // Hashing on FullName is wrong because the order of tuple fields is undefined.
             int hash = StringComparer.OrdinalIgnoreCase.GetHashCode(this.Name);
@@ -288,7 +288,7 @@ internal int CompareBaseNameTo(AssemblyNameExtension that)
         }
 
         /// <summary>
-        /// An implementation of compare that compares two base 
+        /// An implementation of compare that compares two base
         /// names as quickly as possible.
         /// </summary>
         /// <param name="that"></param>
@@ -480,7 +480,7 @@ private static AssemblyName GetAssemblyNameFromDisplayName(string displayName)
         }
 
         /// <summary>
-        /// Return a string that has AssemblyName special characters escaped. 
+        /// Return a string that has AssemblyName special characters escaped.
         /// Those characters are Equals(=), Comma(,), Quote("), Apostrophe('), Backslash(\).
         /// </summary>
         /// <remarks>
diff --git a/src/Deprecated/Engine/Shared/ConversionUtilities.cs b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
index a339ba5793f..4533e5ba505 100644
--- a/src/Deprecated/Engine/Shared/ConversionUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
@@ -14,12 +14,12 @@ namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
     /// This class contains only static methods, which are useful throughout many
-    /// of the MSBuild classes and don't really belong in any specific class.   
+    /// of the MSBuild classes and don't really belong in any specific class.
     /// </summary>
     internal static class ConversionUtilities
     {
         /// <summary>
-        /// Converts a string to a bool.  We consider "true/false", "on/off", and 
+        /// Converts a string to a bool.  We consider "true/false", "on/off", and
         /// "yes/no" to be valid boolean representations in the XML.
         /// </summary>
         /// <param name="parameterValue">The string to convert.</param>
diff --git a/src/Deprecated/Engine/Shared/EscapingUtilities.cs b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
index 618918de5af..a3dba500388 100644
--- a/src/Deprecated/Engine/Shared/EscapingUtilities.cs
+++ b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
@@ -127,7 +127,7 @@ string unescapedString
             // This is where we're going to build up the final string to return to the caller.
             StringBuilder escapedString = new StringBuilder(unescapedString);
 
-            // Replace each unescaped special character with an escape sequence one            
+            // Replace each unescaped special character with an escape sequence one
             foreach (char unescapedChar in charsToEscape)
             {
                 int unescapedCharCode = Convert.ToInt32(unescapedChar);
diff --git a/src/Deprecated/Engine/Shared/ExceptionHandling.cs b/src/Deprecated/Engine/Shared/ExceptionHandling.cs
index a3a04ef335a..bf6a914bc26 100644
--- a/src/Deprecated/Engine/Shared/ExceptionHandling.cs
+++ b/src/Deprecated/Engine/Shared/ExceptionHandling.cs
@@ -94,7 +94,7 @@ internal static bool NotExpectedReflectionException(Exception e)
                 || e is InvalidCastException
                 || e is AmbiguousMatchException         // thrown when binding to a member results in more than one member matching the binding criteria
                 || e is InvalidFilterCriteriaException  // thrown in FindMembers when the filter criteria is not valid for the type of filter you are using
-                || e is TargetException                 // thrown when an attempt is made to invoke a non-static method on a null object.  This may occur because the caller does not 
+                || e is TargetException                 // thrown when an attempt is made to invoke a non-static method on a null object.  This may occur because the caller does not
                                                         //     have access to the member, or because the target does not define the member, and so on.
                 || e is MissingFieldException           // thrown when code in a dependent assembly attempts to access a missing field in an assembly that was modified.
                 || !NotExpectedException(e)             // Reflection can throw IO exceptions if the assembly cannot be opened
diff --git a/src/Deprecated/Engine/Shared/FileMatcher.cs b/src/Deprecated/Engine/Shared/FileMatcher.cs
index 13f25e1be16..a7328b6cf4e 100644
--- a/src/Deprecated/Engine/Shared/FileMatcher.cs
+++ b/src/Deprecated/Engine/Shared/FileMatcher.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
-    /// Functions for matching file names with patterns. 
+    /// Functions for matching file names with patterns.
     /// </summary>
     /// <owner>JomoF</owner>
     internal static class FileMatcher
@@ -134,7 +134,7 @@ private static string[] GetAccessibleFilesAndDirectories(string path, string pat
         /// <summary>
         /// Same as Directory.GetFiles(...) except that files that
         /// aren't accessible are skipped instead of throwing an exception.
-        /// 
+        ///
         /// Other exceptions are passed through.
         /// </summary>
         /// <param name="path">The path.</param>
@@ -193,7 +193,7 @@ bool stripProjectDirectory
         /// <summary>
         /// Same as Directory.GetDirectories(...) except that files that
         /// aren't accessible are skipped instead of throwing an exception.
-        /// 
+        ///
         /// Other exceptions are passed through.
         /// </summary>
         /// <param name="path">The path.</param>
@@ -372,7 +372,7 @@ GetFileSystemEntries getFileSystemEntries
                 out filenamePart
             );
 
-            /* 
+            /*
              * Handle the special case in which filenamePart is '**'.
              * In this case, filenamePart becomes '*.*' and the '**' is appended
              * to the end of the wildcardDirectory part.
@@ -412,12 +412,12 @@ out string filenamePart
             {
                 /*
                  * No dir separator found. This is either this form,
-                 * 
+                 *
                  *      Source.cs
                  *      *.cs
-                 * 
+                 *
                  *  or this form,
-                 * 
+                 *
                  *     **
                  */
                 fixedDirectoryPart = String.Empty;
@@ -438,14 +438,14 @@ out string filenamePart
                  * wildcard is after the dir separator.
                  *
                  * The form is one of these:
-                 * 
+                 *
                  *      dir1\Source.cs
                  *      dir1\*.cs
-                 * 
+                 *
                  * Where the trailing spec is meant to be a filename. Or,
-                 * 
+                 *
                  *      dir1\**
-                 * 
+                 *
                  * Where the trailing spec is meant to be any file recursively.
                  */
 
@@ -465,11 +465,11 @@ out string filenamePart
             {
                 /*
                  * There is no separator before the wildcard, so the form is like this:
-                 * 
+                 *
                  *      dir?\Source.cs
-                 * 
+                 *
                  * or this,
-                 * 
+                 *
                  *      dir?\**
                  */
                 fixedDirectoryPart = String.Empty;
@@ -487,7 +487,7 @@ out string filenamePart
         }
 
         /// <summary>
-        /// Removes the leading ".\" from all of the paths in the array. 
+        /// Removes the leading ".\" from all of the paths in the array.
         /// </summary>
         /// <param name="paths">Paths to remove .\ from.</param>
         private static void RemoveInitialDotSlash
@@ -515,7 +515,7 @@ internal static bool IsDirectorySeparator(char c)
             return c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar;
         }
         /// <summary>
-        /// Removes the current directory converting the file back to relative path 
+        /// Removes the current directory converting the file back to relative path
         /// </summary>
         /// <param name="paths">Paths to remove current directory from.</param>
         /// <param name="projectDirectory"></param>
@@ -549,7 +549,7 @@ string projectDirectory
         }
 
         /// <summary>
-        /// Get all files that match either the file-spec or the regular expression. 
+        /// Get all files that match either the file-spec or the regular expression.
         /// </summary>
         /// <param name="listOfFiles">List of files that gets populated.</param>
         /// <param name="baseDirectory">The path to enumerate</param>
@@ -645,7 +645,7 @@ GetFileSystemEntries getFileSystemEntries
                     //        foo\**\bar
                     //
                     // back into remainingWildcardDirectory.
-                    // This is a performance optimization. We don't want to enumerate everything if we 
+                    // This is a performance optimization. We don't want to enumerate everything if we
                     // don't have to.
                     pattern = remainingWildcardDirectory.Substring(0, indexOfNextSlash);
                     remainingWildcardDirectory = remainingWildcardDirectory.Substring(indexOfNextSlash + 1);
@@ -658,7 +658,7 @@ GetFileSystemEntries getFileSystemEntries
                     }
                 }
 
-                // We never want to strip the project directory from the leaves, because the current 
+                // We never want to strip the project directory from the leaves, because the current
                 // process directory maybe different
                 string[] subdirs = getFileSystemEntries(FileSystemEntity.Directories, baseDirectory, pattern, null, false);
                 foreach (string subdir in subdirs)
@@ -671,7 +671,7 @@ GetFileSystemEntries getFileSystemEntries
         /// <summary>
         /// Given a file spec, create a regular expression that will match that
         /// file spec.
-        /// 
+        ///
         /// PERF WARNING: this method is called in performance-critical
         /// scenarios, so keep it fast and cheap
         /// </summary>
@@ -693,7 +693,7 @@ out bool isLegalFileSpec
             /*
              * The code below uses tags in the form <:tag:> to encode special information
              * while building the regular expression.
-             * 
+             *
              * This format was chosen because it's not a legal form for filespecs. If the
              * filespec comes in with either "<:" or ":>", return isLegalFileSpec=false to
              * prevent intrusion into the special processing.
@@ -718,13 +718,13 @@ out bool isLegalFileSpec
                 return String.Empty;
             }
 
-            /* 
+            /*
              * Trailing dots in file names have to be treated specially.
              * We want:
-             * 
+             *
              *     *. to match foo
-             * 
-             * but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful 
+             *
+             * but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful
              * not to match 'foo.txt'
              */
             if (filenamePart.EndsWith(".", StringComparison.Ordinal))
@@ -760,33 +760,33 @@ out bool isLegalFileSpec
 
             /*
              * Iteratively reduce four cases involving directory separators
-             * 
+             *
              *  (1) <:dirseparator:>.<:dirseparator:> -> <:dirseparator:>
              *        This is an identity, so for example, these two are equivalent,
-             * 
+             *
              *            dir1\.\dir2 == dir1\dir2
-             * 
+             *
              *    (2) <:dirseparator:><:dirseparator:> -> <:dirseparator:>
              *      Double directory separators are treated as a single directory separator,
              *      so, for example, this is an identity:
-             * 
+             *
              *          f:\dir1\\dir2 == f:\dir1\dir2
-             * 
+             *
              *      The single exemption is for UNC path names, like this:
-             * 
+             *
              *          \\server\share != \server\share
-             * 
+             *
              *      This case is handled by the <:uncslashslash:> which was substituted in
              *      a prior step.
-             * 
+             *
              *  (3) <:fixeddir:>.<:dirseparator:>.<:dirseparator:> -> <:fixeddir:>.<:dirseparator:>
              *      A ".\" at the beginning of a line is equivalent to nothing, so:
-             * 
+             *
              *          .\.\dir1\file.txt == .\dir1\file.txt
-             * 
+             *
              *  (4) <:dirseparator:>.<:eol:> -> <:eol:>
              *      A "\." at the end of a line is equivalent to nothing, so:
-             * 
+             *
              *          dir1\dir2\. == dir1\dir2             *
              */
             int sizeBefore;
@@ -822,11 +822,11 @@ out bool isLegalFileSpec
 
             /*
              * Call out legal recursion operators:
-             * 
+             *
              *        fixed-directory + **\
              *        \**\
              *        **\**
-             * 
+             *
              */
             do
             {
@@ -900,7 +900,7 @@ out bool isLegalFileSpec
         }
 
         /// <summary>
-        /// Given a filespec, get the information needed for file matching. 
+        /// Given a filespec, get the information needed for file matching.
         /// </summary>
         /// <param name="filespec">The filespec.</param>
         /// <param name="regexFileMatch">Receives the regular expression.</param>
@@ -976,7 +976,7 @@ GetFileSystemEntries getFileSystemEntries
 
             /*
              * Check for patterns in the filespec that are explicitly illegal.
-             * 
+             *
              * Any path with "..." in it is illegal.
              */
             if (-1 != filespec.IndexOf("...", StringComparison.Ordinal))
@@ -988,9 +988,9 @@ GetFileSystemEntries getFileSystemEntries
             /*
              * If there is a ':' anywhere but the second character, this is an illegal pattern.
              * Catches this case among others,
-             * 
+             *
              *        http://www.website.com
-             * 
+             *
              */
             int rightmostColon = filespec.LastIndexOf(":", StringComparison.Ordinal);
 
@@ -1111,7 +1111,7 @@ GetFileSystemEntries getFileSystemEntries
         }
 
         /// <summary>
-        /// Given a filespec, find the files that match. 
+        /// Given a filespec, find the files that match.
         /// </summary>
         /// <param name="filespec">Get files that match the given file spec.</param>
         /// <returns>The array of files.</returns>
@@ -1126,7 +1126,7 @@ string filespec
         }
 
         /// <summary>
-        /// Given a filespec, find the files that match. 
+        /// Given a filespec, find the files that match.
         /// </summary>
         /// <param name="filespec">Get files that match the given file spec.</param>
         /// <param name="getFileSystemEntries">Get files that match the given file spec.</param>
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index 7b19c8ec90a..41e312d62b6 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
     /// This class contains utility methods for file IO.
-    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
+    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
     /// each class get pulled into the resulting assembly.
     /// </summary>
     /// <owner>SumedhK</owner>
@@ -31,7 +31,7 @@ internal static class FileUtilities
         /// <owner>SumedhK</owner>
         internal static class ItemSpecModifiers
         {
-            // NOTE: If you add an item here that starts with a new letter, you need to update the case 
+            // NOTE: If you add an item here that starts with a new letter, you need to update the case
             // statements in IsItemSpecModifier and IsDerivableItemSpecModifier.
             internal const string FullPath = "FullPath";
             internal const string RootDir = "RootDir";
@@ -97,21 +97,21 @@ internal static bool IsItemSpecModifier(string name)
                 return false;
             }
 
-            /* 
+            /*
              * What follows requires some explanation.
-             * 
-             * This function is called many times and slowness here will be amplified 
+             *
+             * This function is called many times and slowness here will be amplified
              * in critical performance scenarios.
-             * 
+             *
              * The following switch statement attempts to identify item spec modifiers that
-             * have the exact case that our constants in ItemSpecModifiers have. This is the 
+             * have the exact case that our constants in ItemSpecModifiers have. This is the
              * 99% case.
-             * 
+             *
              * Further, the switch statement can identify certain cases in which there is
              * definitely no chance that 'name' is an item spec modifier. For example, a
              * 7 letter 'name' that doesn't start with 'r' or 'R' can't be RootDir and
              * therefore is not an item spec modifier.
-             * 
+             *
              */
             switch (name.Length)
             {
@@ -263,7 +263,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
                 {
                     if (name[0] == 'R' || name[0] == 'r')
                     {
-                        // The only 12 letter ItemSpecModifier that starts with 'R' is 'RecursiveDir' 
+                        // The only 12 letter ItemSpecModifier that starts with 'R' is 'RecursiveDir'
                         return false;
                     }
                 }
@@ -274,7 +274,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
 
         /// <summary>
         /// Performs path manipulations on the given item-spec as directed.
-        /// 
+        ///
         /// Supported modifiers:
         ///     %(FullPath)         = full path of item
         ///     %(RootDir)          = root directory of item
@@ -287,7 +287,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
         ///     %(ModifiedTime)     = last write time of item
         ///     %(CreatedTime)      = creation time of item
         ///     %(AccessedTime)     = last access time of item
-        /// 
+        ///
         /// NOTES:
         /// 1) This method always returns an empty string for the %(RecursiveDir) modifier because it does not have enough
         ///    information to compute it -- only the BuildItem class can compute this modifier.
@@ -298,7 +298,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
         /// 1) successive slashes are combined into 1 slash
         /// 2) trailing periods are discarded
         /// 3) forward slashes are changed to back-slashes
-        /// 
+        ///
         /// As a result, we cannot rely on any file-spec that has passed through a Path method to remain the same. We will
         /// therefore not bother preserving slashes and periods when file-specs are transformed.
         /// </remarks>
@@ -459,7 +459,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            // File does not exist, or path is a directory                        
+                            // File does not exist, or path is a directory
                             modifiedItemSpec = String.Empty;
                         }
                     }
@@ -477,7 +477,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            // File does not exist, or path is a directory                        
+                            // File does not exist, or path is a directory
                             modifiedItemSpec = String.Empty;
                         }
                     }
@@ -573,7 +573,7 @@ internal static bool EndsWithSlash(string fileSpec)
         }
 
         /// <summary>
-        /// Indicates if the given character is a slash. 
+        /// Indicates if the given character is a slash.
         /// </summary>
         /// <owner>SumedhK</owner>
         /// <param name="c"></param>
@@ -722,7 +722,7 @@ internal static string CurrentExecutableConfigurationFilePath
         /// <summary>
         /// Gets a file info object for the specified file path. If the file path
         /// is invalid, or is a directory, or cannot be accessed, or does not exist,
-        /// it returns null rather than throwing or returning a FileInfo around a non-existent file. 
+        /// it returns null rather than throwing or returning a FileInfo around a non-existent file.
         /// This allows it to be called where File.Exists() (which never throws, and returns false
         /// for directories) was called - but with the advantage that a FileInfo object is returned
         /// that can be queried (e.g., for LastWriteTime) without hitting the disk again.
@@ -784,11 +784,11 @@ internal static bool IsVCProjFilename(string filename)
         }
 
         /// <summary>
-        /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location. 
+        /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
         /// Throws UriFormatException.
         /// </summary>
         /// <param name="basePath">
-        /// The base path we want to relativize to. Must be absolute.  
+        /// The base path we want to relativize to. Must be absolute.
         /// Should <i>not</i> include a filename as the last segment will be interpreted as a directory.
         /// </param>
         /// <param name="path">
diff --git a/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs b/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
index 528bb121c15..097c2d3b1c3 100644
--- a/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
@@ -15,13 +15,13 @@ namespace Microsoft.Build.BuildEngine.Shared
     /// <summary>
     /// This class contains utility methods for file IO.
     /// Separate from FileUtilities because some assemblies may only need the patterns.
-    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
+    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
     /// each class get pulled into the resulting assembly.
     /// </summary>
     /// <owner>SumedhK, JomoF</owner>
     internal static class FileUtilitiesRegex
     {
-        // regular expression used to match file-specs beginning with "<drive letter>:" 
+        // regular expression used to match file-specs beginning with "<drive letter>:"
         internal static readonly Regex DrivePattern = new Regex(@"^[A-Za-z]:");
 
         // regular expression used to match UNC paths beginning with "\\<server>\<share>"
diff --git a/src/Deprecated/Engine/Shared/InternalErrorException.cs b/src/Deprecated/Engine/Shared/InternalErrorException.cs
index 218c3e31f65..b4e04642429 100644
--- a/src/Deprecated/Engine/Shared/InternalErrorException.cs
+++ b/src/Deprecated/Engine/Shared/InternalErrorException.cs
@@ -14,12 +14,12 @@ namespace Microsoft.Build.BuildEngine.Shared
     /// This exception is to be thrown whenever an assumption we have made in the code turns out to be false. Thus, if this
     /// exception ever gets thrown, it is because of a bug in our own code, not because of something the user or project author
     /// did wrong.
-    /// 
+    ///
     /// !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
     /// WARNING: When this file is shared into multiple assemblies each assembly will view this as a different type.
     ///          Don't throw this exception from one assembly and catch it in another.
     /// !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
-    ///     
+    ///
     /// </summary>
     /// <owner>RGoel</owner>
     [Serializable]
diff --git a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
index 6b4863fedc9..a411b606cbb 100644
--- a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
+++ b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
@@ -103,9 +103,9 @@ internal static string FindOnPath(string filename)
         #region PInvoke
 
         /// <summary>
-        /// Gets the current OEM code page which is used by console apps 
+        /// Gets the current OEM code page which is used by console apps
         /// (as opposed to the Windows/ANSI code page)
-        /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page 
+        /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
         /// that needs to be used for instance when writing to batch files
         /// </summary>
         /// <owner>LukaszG</owner>
diff --git a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
index efddac5040a..d5f7d9097e4 100644
--- a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
@@ -43,7 +43,7 @@ internal bool IncludeInBuild
         /// This is a hacky method to remove the space in the "Any CPU" platform in project configurations.
         /// The problem is that this platform is stored as "AnyCPU" in project files, but the project system
         /// reports it as "Any CPU" to the solution configuration manager. Because of that all solution configurations
-        /// contain the version with a space in it, and when we try and give that name to actual projects, 
+        /// contain the version with a space in it, and when we try and give that name to actual projects,
         /// they have no clue what we're talking about. We need to remove the space in project platforms so that
         /// the platform name matches the one used in projects.
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs b/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
index c4e02764d55..7c93d4bf4bc 100644
--- a/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
@@ -8,14 +8,14 @@
 using System.Xml;
 
 /******************************************************************************
- * 
+ *
  *                              !! WARNING !!
- * 
+ *
  * This class depends on the build engine assembly! Do not share this class
  * into any assembly that is not supposed to take a dependency on the build
  * engine assembly!
- * 
- * 
+ *
+ *
  ******************************************************************************/
 
 namespace Microsoft.Build.BuildEngine.Shared
@@ -321,7 +321,7 @@ object arg3
 
         /// <summary>
         /// Throws an InvalidProjectFileException using the given data.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
diff --git a/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs b/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
index d04ee7cc6bb..12b2ab979d5 100644
--- a/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
@@ -16,7 +16,7 @@ internal static class ProjectFileErrorUtilities
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -39,7 +39,7 @@ params object[] args
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/ProjectInSolution.cs b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
index 8e025bb32ae..9d2bc12f0d8 100644
--- a/src/Deprecated/Engine/Shared/ProjectInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
@@ -87,7 +87,7 @@ internal sealed class ProjectInSolution
         /// <summary>
         /// The project configuration in given solution configuration
         /// K: full solution configuration name (cfg + platform)
-        /// V: project configuration 
+        /// V: project configuration
         /// </summary>
         private Dictionary<string, ProjectConfigurationInSolution> projectConfigurations;
 
@@ -356,7 +356,7 @@ private static string CleanseProjectName(string projectName)
             // This is where we're going to work on the final string to return to the caller.
             StringBuilder cleanProjectName = new StringBuilder(projectName);
 
-            // Replace each unclean character with a clean one            
+            // Replace each unclean character with a clean one
             foreach (char uncleanChar in charsToCleanse)
             {
                 cleanProjectName.Replace(uncleanChar, cleanCharacter);
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index 396ff96d1f8..7eeac400a28 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -72,7 +72,7 @@ private static string GetHelpKeyword(string resourceName)
         /// <summary>
         /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they too are returned.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -94,7 +94,7 @@ internal static string FormatResourceString(out string code, out string helpKeyw
         /// <summary>
         /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they are discarded.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -113,7 +113,7 @@ internal static string FormatResourceString(string resourceName, params object[]
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -142,12 +142,12 @@ internal static string FormatString(string unformatted, params object[] args)
                 // String.Format() will throw a FormatException if args does
                 // not have enough elements to match each format parameter.
                 // However, it provides no feedback in the case when args contains
-                // more elements than necessary to replace each format 
+                // more elements than necessary to replace each format
                 // parameter.  We'd like to know if we're providing too much
                 // data in cases like these, so we'll fail if this code runs.
                 //
                 // See DevDiv Bugs 15210 for more information.
-                                
+
                 // We create an array with one fewer element
                 object[] trimmedArgs = new object[args.Length - 1];
                 Array.Copy(args, 0, trimmedArgs, 0, args.Length - 1);
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 68d1bfee87b..6e146f197df 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -142,7 +142,7 @@ internal ArrayList SolutionParserComments
         }
 
         /// <summary>
-        /// This property returns the list of error codes for warnings/errors that were generated during solution parsing. 
+        /// This property returns the list of error codes for warnings/errors that were generated during solution parsing.
         /// UNIT TESTING ONLY
         /// </summary>
         internal ArrayList SolutionParserErrorCodes
@@ -414,11 +414,11 @@ internal void ParseSolution()
         /// <summary>
         /// This method searches the first two lines of the solution file opened by the specified
         /// StreamReader for the solution file header.  An exception is thrown if it is not found.
-        /// 
+        ///
         /// The solution file header looks like this:
-        /// 
+        ///
         ///     Microsoft Visual Studio Solution File, Format Version 9.00
-        /// 
+        ///
         /// </summary>
         /// <owner>RGoel</owner>
         private void ParseFileHeader()
@@ -454,11 +454,11 @@ private void ParseFileHeader()
         /// This method extracts the whole part of the version number from the specified line
         /// containing the solution file format header, and throws an exception if the version number
         /// is outside of the valid range.
-        /// 
+        ///
         /// The solution file header looks like this:
-        /// 
+        ///
         ///     Microsoft Visual Studio Solution File, Format Version 9.00
-        /// 
+        ///
         /// </summary>
         /// <param name="versionString"></param>
         /// <owner>RGoel</owner>
@@ -506,7 +506,7 @@ private void ValidateSolutionFileVersion(string versionString)
         }
 
         /// <summary>
-        /// 
+        ///
         /// This method processes a "Project" section in the solution file opened by the specified
         /// StreamReader, and returns a populated ProjectInSolution instance, if successful.
         /// An exception is thrown if the solution file is invalid.
@@ -519,7 +519,7 @@ private void ValidateSolutionFileVersion(string versionString)
         ///          ...
         ///      EndProjectSection
         ///  EndProject
-        /// 
+        ///
         /// </summary>
         /// <param name="firstLine"></param>
         /// <returns></returns>
@@ -567,7 +567,7 @@ private void ParseProject(string firstLine)
                 else if (line.StartsWith("ProjectSection(WebsiteProperties)", StringComparison.Ordinal))
                 {
                     // We have a WebsiteProperties section.  This section is present only in Venus
-                    // projects, and contains properties that we'll need in order to call the 
+                    // projects, and contains properties that we'll need in order to call the
                     // AspNetCompiler task.
                     line = ReadLine();
                     while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
@@ -593,7 +593,7 @@ private void ParseProject(string firstLine)
             {
                 // Add the project to the collection
                 AddProjectToSolution(proj);
-                // If the project is an etp project then parse the etp project file 
+                // If the project is an etp project then parse the etp project file
                 // to get the projects contained in it.
                 if (IsEtpProjectFile(proj.RelativePath))
                 {
@@ -603,7 +603,7 @@ private void ParseProject(string firstLine)
         } // ParseProject()
 
         /// <summary>
-        /// This method will parse a .etp project recursively and 
+        /// This method will parse a .etp project recursively and
         /// add all the projects found to projects and projectsInOrder
         /// </summary>
         /// <param name="etpProj">ETP Project</param>
@@ -648,8 +648,8 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
 
                 // We need to parse the .etp project file to get the names of projects contained
                 // in the .etp Project. The projects are listed under /EFPROJECT/GENERAL/References/Reference node in the .etp project file.
-                // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain 
-                // all the projects in the .etp project. Therefore, we need to look at 
+                // The /EFPROJECT/GENERAL/Views/ProjectExplorer node will not necessarily contain
+                // all the projects in the .etp project. Therefore, we need to look at
                 // /EFPROJECT/GENERAL/References/Reference.
                 // Find the /EFPROJECT/GENERAL/References/Reference node
                 // Note that this is case sensitive
@@ -676,10 +676,10 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                             proj.ProjectGuid = projGuidNode.InnerText;
                         }
                         // It is ok for a project to not have a guid inside an etp project.
-                        // If a solution file contains a project without a guid it fails to 
-                        // load in Everett. But if an etp project contains a project without 
+                        // If a solution file contains a project without a guid it fails to
+                        // load in Everett. But if an etp project contains a project without
                         // a guid it loads well in Everett and p2p references to/from this project
-                        // are preserved. So we should make sure that we don�t error in this 
+                        // are preserved. So we should make sure that we don�t error in this
                         // situation while upgrading.
                         else
                         {
@@ -700,7 +700,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle security errors
             catch (SecurityException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
@@ -710,7 +710,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in path resolution
             catch (NotSupportedException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
@@ -720,7 +720,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in loading project file
             catch (IOException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
@@ -730,17 +730,17 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             // handle errors in loading project file
             catch (UnauthorizedAccessException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
                 solutionParserWarnings.Add(warning);
                 solutionParserErrorCodes.Add(errorCode);
             }
-            // handle XML parsing errors 
+            // handle XML parsing errors
             catch (XmlException e)
             {
-                // Log a warning 
+                // Log a warning
                 string errorCode, ignoredKeyword;
                 string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.InvalidProjectFile",
                    etpProj.RelativePath, e.Message);
@@ -814,7 +814,7 @@ string propertyValue
             //
             // Project("{E24C65DC-7377-472B-9ABA-BC803B73C61A}") = "c:\...\myfirstwebsite\", "..\..\..\..\..\..\rajeev\temp\websites\myfirstwebsite", "{956CC04E-FD59-49A9-9099-96888CB6F366}"
             //     ProjectSection(WebsiteProperties) = preProject
-            //       ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
+            //       ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
             //       Debug.AspNetCompiler.VirtualPath = "/publishfirst"
             //       Debug.AspNetCompiler.PhysicalPath = "..\..\..\..\..\..\rajeev\temp\websites\myfirstwebsite\"
             //       Debug.AspNetCompiler.TargetPath = "..\..\..\..\..\..\rajeev\temp\publishfirst\"
@@ -936,7 +936,7 @@ string propertyValue
             }
             else
             {
-                // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
+                // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
                 if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' });
@@ -945,7 +945,7 @@ string propertyValue
                     {
                         int indexOfBar = projectReferenceEntry.IndexOf('|');
 
-                        // indexOfBar could be -1 if we had semicolons in the file names, so skip entries that 
+                        // indexOfBar could be -1 if we had semicolons in the file names, so skip entries that
                         // don't contain a guid. File names may not contain the '|' character
                         if (indexOfBar != -1)
                         {
@@ -993,7 +993,7 @@ string property
         /// Parse the first line of a Project section of a solution file. This line should look like:
         ///
         ///  Project("{Project type GUID}") = "Project name", "Relative path to project file", "{Project GUID}"
-        /// 
+        ///
         /// </summary>
         /// <param name="firstLine"></param>
         /// <param name="proj"></param>
@@ -1076,11 +1076,11 @@ internal void ParseNestedProjects()
         }
 
         /// <summary>
-        /// Read solution configuration section. 
+        /// Read solution configuration section.
         /// </summary>
         /// <remarks>
         /// A sample section:
-        /// 
+        ///
         /// GlobalSection(SolutionConfigurationPlatforms) = preSolution
         ///     Debug|Any CPU = Debug|Any CPU
         ///     Release|Any CPU = Release|Any CPU
@@ -1104,7 +1104,7 @@ internal void ParseSolutionConfigurations()
 
                 string[] configurationNames = str.Split(nameValueSeparators);
 
-                // There should be exactly one '=' character, separating two names. 
+                // There should be exactly one '=' character, separating two names.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(configurationNames.Length == 2, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), "SolutionParseInvalidSolutionConfigurationEntry", str);
 
@@ -1135,7 +1135,7 @@ internal void ParseSolutionConfigurations()
         /// </summary>
         /// <remarks>
         /// A sample (incomplete) section:
-        /// 
+        ///
         /// GlobalSection(ProjectConfigurationPlatforms) = postSolution
         /// 	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
         /// 	{6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
@@ -1166,7 +1166,7 @@ internal Hashtable ParseProjectConfigurations()
 
                 string[] nameValue = str.Split(new char[] { '=' });
 
-                // There should be exactly one '=' character, separating the name and value. 
+                // There should be exactly one '=' character, separating the name and value.
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(nameValue.Length == 2, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(SolutionFile, this.currentLineNumber, 0), "SolutionParseInvalidProjectSolutionConfigurationEntry", str);
 
@@ -1178,18 +1178,18 @@ internal Hashtable ParseProjectConfigurations()
         }
 
         /// <summary>
-        /// Read the project configuration information for every project in the solution, using pre-cached 
-        /// solution section data. 
+        /// Read the project configuration information for every project in the solution, using pre-cached
+        /// solution section data.
         /// </summary>
         /// <param name="rawProjectConfigurationsEntries">Cached data from the project configuration section</param>
         /// <owner>LukaszG</owner>
         internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurationsEntries)
         {
-            // Instead of parsing the data line by line, we parse it project by project, constructing the 
-            // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its 
+            // Instead of parsing the data line by line, we parse it project by project, constructing the
+            // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its
             // value from the raw data. The reason for this is that the IDE does it this way, and as the result
             // the '.' character is allowed in configuration names although it technically separates different
-            // parts of the entry name string. This could lead to ambiguous results if we tried to parse 
+            // parts of the entry name string. This could lead to ambiguous results if we tried to parse
             // the entry name instead of constructing it and looking it up. Although it's pretty unlikely that
             // this would ever be a problem, it's safer to do it the same way VS IDE does it.
             char[] configPlatformSeparators = new char[] { ConfigurationInSolution.configurationPlatformSeparator };
@@ -1207,9 +1207,9 @@ internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurati
                             project.ProjectGuid, solutionConfiguration.FullName);
 
                         // The "Build.0" entry tells us whether to build the project configuration in the given solution configuration.
-                        // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial, 
-                        // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used). 
-                        // The configuration name is not used, and the whole entry means "build the project configuration" 
+                        // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial,
+                        // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used).
+                        // The configuration name is not used, and the whole entry means "build the project configuration"
                         // if it's present in the solution file, and "don't build" if it's not.
                         string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0",
                             project.ProjectGuid, solutionConfiguration.FullName);
diff --git a/src/Deprecated/Engine/Shared/UnitTests/FileMatcher_Tests.cs b/src/Deprecated/Engine/Shared/UnitTests/FileMatcher_Tests.cs
index b3b15a8d70b..72f6c5dd81b 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/FileMatcher_Tests.cs
@@ -26,13 +26,13 @@ public class FileMatcherTest
        /*
         * Method:  GetFileSystemEntries
         * Owner:   jomof
-        * 
+        *
         * Simulate Directories.GetFileSystemEntries where file names are short.
-        * 
+        *
         */
         private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
         {
-            if 
+            if
             (
                 pattern==@"LONGDI~1"
                 && (@"D:\"==path || @"\\server\share\"==path || path.Length==0)
@@ -40,7 +40,7 @@ private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entity
             {
                 return new string [] {Path.Combine(path, "LongDirectoryName")};
             }
-            else if 
+            else if
             (
                 pattern==@"LONGSU~1"
                 && (@"D:\LongDirectoryName"==path || @"\\server\share\LongDirectoryName"==path || @"LongDirectoryName"==path)
@@ -48,7 +48,7 @@ private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entity
             {
                 return new string [] {Path.Combine (path, "LongSubDirectory")};
             }
-            else if 
+            else if
             (
                 pattern==@"LONGFI~1.TXT"
                 && (@"D:\LongDirectoryName\LongSubDirectory"==path || @"\\server\share\LongDirectoryName\LongSubDirectory"==path || @"LongDirectoryName\LongSubDirectory"==path)
@@ -56,14 +56,14 @@ private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entity
             {
                 return new string[] { Path.Combine (path, "LongFileName.txt") };
             }
-            else if 
+            else if
             (
                 pattern==@"pomegr~1"
                 && @"c:\apple\banana\tomato"==path
             )
             {
                 return new string[] { Path.Combine (path, "pomegranate") };
-            } 
+            }
             else if
             (
                 @"c:\apple\banana\tomato\pomegranate\orange"==path
@@ -71,8 +71,8 @@ private static string[] GetFileSystemEntries(FileMatcher.FileSystemEntity entity
             {
                 // No files exist here. This is an empty directory.
                 return new string[0];
-            }            
-            else            
+            }
+            else
             {
                 Console.WriteLine("GetFileSystemEntries('{0}', '{1}')", path, pattern);
                 Assertion.Assert("Unexpected input into GetFileSystemEntries", false);
@@ -102,12 +102,12 @@ public void BasicMatchDriver()
                 null
             );
         }
-        
+
         /// <summary>
         /// This pattern should *not* recurse indefinitely since there is no '**' in the pattern:
-        /// 
+        ///
         ///        c:\?emp\foo
-        /// 
+        ///
         /// </summary>
         [Test]
         public void Regress162390()
@@ -118,9 +118,9 @@ public void Regress162390()
                 new string[] { @"c:\temp\foo.txt" },    // Should match
                 new string[] { @"c:\timp\foo.txt" },    // Shouldn't match
                 new string[]                            // Should not even consider.
-                { 
+                {
                     @"c:\temp\sub\foo.txt"
-                } 
+                }
             );
         }
 
@@ -128,9 +128,9 @@ public void Regress162390()
         /*
         * Method:  GetLongFileNameForShortLocalPath
         * Owner:   jomof
-        * 
+        *
         * Convert a short local path to a long path.
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForShortLocalPath()
@@ -140,16 +140,16 @@ public void GetLongFileNameForShortLocalPath()
                 @"D:\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        } 
-               
+        }
+
         /*
         * Method:  GetLongFileNameForLongLocalPath
         * Owner:   jomof
-        * 
+        *
         * Convert a long local path to a long path (nop).
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForLongLocalPath()
@@ -159,16 +159,16 @@ public void GetLongFileNameForLongLocalPath()
                 @"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"D:\LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        }    
-        
+        }
+
         /*
         * Method:  GetLongFileNameForShortUncPath
         * Owner:   jomof
-        * 
+        *
         * Convert a short UNC path to a long path.
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForShortUncPath()
@@ -178,16 +178,16 @@ public void GetLongFileNameForShortUncPath()
                 @"\\server\share\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        } 
-               
+        }
+
         /*
         * Method:  GetLongFileNameForLongUncPath
         * Owner:   jomof
-        * 
+        *
         * Convert a long UNC path to a long path (nop)
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForLongUncPath()
@@ -197,16 +197,16 @@ public void GetLongFileNameForLongUncPath()
                 @"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"\\server\share\LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        }     
-        
+        }
+
         /*
         * Method:  GetLongFileNameForRelativePath
         * Owner:   jomof
-        * 
+        *
         * Convert a short relative path to a long path
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForRelativePath()
@@ -216,16 +216,16 @@ public void GetLongFileNameForRelativePath()
                 @"LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(longPath, @"LongDirectoryName\LongSubDirectory\LongFileName.txt");
-        }       
-        
+        }
+
         /*
         * Method:  GetLongFileNameForRelativePathPreservesTrailingSlash
         * Owner:   jomof
-        * 
+        *
         * Convert a short relative path with a trailing backslash to a long path
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForRelativePathPreservesTrailingSlash()
@@ -235,16 +235,16 @@ public void GetLongFileNameForRelativePathPreservesTrailingSlash()
                 @"LONGDI~1\LONGSU~1\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(@"LongDirectoryName\LongSubDirectory\", longPath);
-        }           
-        
+        }
+
         /*
         * Method:  GetLongFileNameForRelativePathPreservesExtraSlashes
         * Owner:   jomof
-        * 
+        *
         * Convert a short relative path with doubled embedded backslashes to a long path
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForRelativePathPreservesExtraSlashes()
@@ -254,16 +254,16 @@ public void GetLongFileNameForRelativePathPreservesExtraSlashes()
                 @"LONGDI~1\\LONGSU~1\\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals(@"LongDirectoryName\\LongSubDirectory\\", longPath);
-        }  
-            
+        }
+
         /*
         * Method:  GetLongFileNameForMixedLongAndShort
         * Owner:   jomof
-        * 
+        *
         * Only part of the path might be short.
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameForMixedLongAndShort()
@@ -273,17 +273,17 @@ public void GetLongFileNameForMixedLongAndShort()
                 @"c:\apple\banana\tomato\pomegr~1\orange\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals (@"c:\apple\banana\tomato\pomegranate\orange\", longPath);
-        } 
-        
+        }
+
         /*
         * Method:  GetLongFileNameWherePartOfThePathDoesntExist
         * Owner:   jomof
-        * 
+        *
         * Part of the path may not exist. In this case, we treat the non-existent parts
         * as if they were already a long file name.
-        * 
+        *
         */
         [Test]
         public void GetLongFileNameWherePartOfThePathDoesntExist()
@@ -293,44 +293,44 @@ public void GetLongFileNameWherePartOfThePathDoesntExist()
                 @"c:\apple\banana\tomato\pomegr~1\orange\chocol~1\vanila~1",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries)
             );
-            
+
             Assertion.AssertEquals (@"c:\apple\banana\tomato\pomegranate\orange\chocol~1\vanila~1", longPath);
-        }                
-        
+        }
+
         [Test]
         public void BasicMatch()
         {
             ValidateFileMatch("file.txt", "File.txt", false);
             ValidateNoFileMatch("file.txt", "File.bin", false);
         }
-        
+
         [Test]
         public void MatchSingleCharacter()
         {
             ValidateFileMatch("file.?xt", "File.txt", false);
             ValidateNoFileMatch("file.?xt", "File.bin", false);
         }
-        
+
         [Test]
         public void MatchMultipleCharacters()
         {
             ValidateFileMatch("*.txt", "*.txt", false);
             ValidateNoFileMatch("*.txt", "*.bin", false);
         }
-        
+
         [Test]
         public void SimpleRecursive()
         {
             ValidateFileMatch("**", ".\\File.txt", true);
         }
-        
+
         [Test]
         public void DotForCurrentDirectory()
         {
             ValidateFileMatch(".\\file.txt", ".\\File.txt", false);
             ValidateNoFileMatch(".\\file.txt", ".\\File.bin", false);
         }
-                                        
+
         [Test]
         public void DotDotForParentDirectory()
         {
@@ -339,17 +339,17 @@ public void DotDotForParentDirectory()
             ValidateNoFileMatch("..\\..\\*.*", "..\\..\\dir1\\dir2\\File.txt", false);
             ValidateNoFileMatch("..\\..\\*.*", "..\\..\\dir1\\dir2\\File", false);
         }
-        
+
         [Test]
         public void ReduceDoubleSlashesBaseline()
         {
             // Baseline
             ValidateFileMatch("f:\\dir1\\dir2\\file.txt", "f:\\dir1\\dir2\\file.txt", false);
             ValidateFileMatch("**\\*.cs", "dir1\\dir2\\file.cs", true);
-            ValidateFileMatch("**\\*.cs", "file.cs", true);     
-        } 
-           
-            
+            ValidateFileMatch("**\\*.cs", "file.cs", true);
+        }
+
+
         [Test]
         public void ReduceDoubleSlashes()
         {
@@ -371,7 +371,7 @@ public void DoubleSlashesOnBothSidesOfComparison()
             ValidateFileMatch("..\\**/.\\*.cs", "..\\dir1\\dir2//\\file.cs", true, false);
             ValidateFileMatch("..\\**\\./.\\*.cs", "..\\dir1/\\/\\/dir2\\file.cs", true, false);
         }
-        
+
         [Test]
         public void DecomposeDotSlash()
         {
@@ -387,11 +387,11 @@ public void DecomposeDotSlash()
             ValidateFileMatch(".//dir1\\dir2\\file.txt", ".\\dir1\\dir2\\file.txt", false);
             ValidateFileMatch(".//.//dir1\\dir2\\file.txt", ".\\dir1\\dir2\\file.txt", false);
         }
-        
+
         [Test]
         public void RecursiveDirRecursive()
         {
-           // Check that a wildcardpath of **\x\**\ matches correctly since, \**\ is a 
+           // Check that a wildcardpath of **\x\**\ matches correctly since, \**\ is a
             // separate code path.
             ValidateFileMatch(@"c:\foo\**\x\**\*.*", @"c:\foo\x\file.txt", true);
             ValidateFileMatch(@"c:\foo\**\x\**\*.*", @"c:\foo\y\x\file.txt", true);
@@ -411,23 +411,23 @@ public void Regress155731()
             ValidateFileMatch(@"a\b\**\**\**\e\*", @"a\b\c\d\e\f.txt", true);
             ValidateFileMatch(@"a\b\**\**\**\**\e\*", @"a\b\c\d\e\f.txt", true);
         }
-           
+
         [Test]
         public void ParentWithoutSlash()
         {
             // However, we don't wtool this to match,
             ValidateNoFileMatch(@"C:\foo\**", @"C:\foo", true);
             // becase we don't know whether foo is a file or folder.
-            
+
             // Same for UNC
             ValidateNoFileMatch
                 (
                 "\\\\server\\c$\\Documents and Settings\\User\\**",
                 "\\\\server\\c$\\Documents and Settings\\User",
                 true
-                );            
-        } 
-                                       
+                );
+        }
+
         [Test]
         public void Unc()
         {
@@ -465,9 +465,9 @@ public void Unc()
                 "\\\\server\\c$\\Documents and Settings\\User\\Source.cs",
                 true
                 );
-        
+
         }
-        
+
         [Test]
         public void ExplicitToolCompatibility()
         {
@@ -491,45 +491,45 @@ public void ExplicitToolCompatibility()
             ValidateFileMatch("org/IIS/**/SourceSafe/*", "org/IIS\\SourceSafe/Entries", true);
             ValidateFileMatch("org/IIS/**/SourceSafe/*", "org/IIS/pluggin/tools/tool/SourceSafe/Entries", true);
             ValidateNoFileMatch("org/IIS/**/SourceSafe/*", "org/IIS/SourceSafe/foo/bar/Entries", true);
-            ValidateNoFileMatch("org/IIS/**/SourceSafe/*", "org/IISSourceSage/Entries", true);        
+            ValidateNoFileMatch("org/IIS/**/SourceSafe/*", "org/IISSourceSage/Entries", true);
         }
-        
+
         [Test]
         public void ExplicitToolIncompatibility()
         {
             // NOTE: Weirdly, ANT syntax is to match a file here.
             // We don't because MSBuild philosophy is that a trailing slash indicates a directory
-            ValidateNoFileMatch("**/test/**", ".\\test", true); 
+            ValidateNoFileMatch("**/test/**", ".\\test", true);
 
             // NOTE: We deviate from ANT format here. ANT would append a ** to any path
             // that ends with '/' or '\'. We think this is the wrong thing because 'folder\'
             // is a valid folder name.
             ValidateNoFileMatch("org/", "org/IISSourceSage/Entries", false);
-            ValidateNoFileMatch("org\\", "org/IISSourceSage/Entries", false);        
+            ValidateNoFileMatch("org\\", "org/IISSourceSage/Entries", false);
         }
-        
+
         [Test]
         public void MultipleStarStar()
         {
-            // Multiple-** matches 
+            // Multiple-** matches
             ValidateFileMatch("c:\\**\\jomof\\**\\*.*", "c:\\Documents and Settings\\JomoF\\NTUSER.DAT", true);
             ValidateNoFileMatch("c:\\**\\jomof1\\**\\*.*", "c:\\Documents and Settings\\JomoF\\NTUSER.DAT", true);
             ValidateFileMatch("c:\\**\\jomof\\**\\*.*", "c://Documents and Settings\\JomoF\\NTUSER.DAT", true);
             ValidateNoFileMatch("c:\\**\\jomof1\\**\\*.*", "c:\\Documents and Settings//JomoF\\NTUSER.DAT", true);
-    
+
         }
-        
+
         [Test]
         public void Regress54411()
         {
             // Regress bug#54411:  Item recursion doesn't work as expected on "c:\foo\**"
-            ValidateFileMatch("c:\\foo\\**", "c:\\foo\\bar\\subfile.txt", true);    
+            ValidateFileMatch("c:\\foo\\**", "c:\\foo\\bar\\subfile.txt", true);
         }
-        
+
         [Test]
         public void IllegalPaths()
         {
-            
+
             // Certain patterns are illegal.
             ValidateIllegal("**.cs");
             ValidateIllegal("***");
@@ -578,7 +578,7 @@ public void Regress367780_CrashOnStarDotDot()
                 Directory.Delete(workingPathSubfolder);
                 Directory.Delete(workingPath);
             }
-            
+
         }
 
         [Test]
@@ -1061,12 +1061,12 @@ internal bool DirectoryExists(string path)
 
         /// <summary>
         /// A general purpose method used to:
-        /// 
+        ///
         /// (1) Simulate a file system.
         /// (2) Check whether all matchingFiles where hit by the filespec pattern.
         /// (3) Check whether all nonmatchingFiles were *not* hit by the filespec pattern.
         /// (4) Check whether all untouchableFiles were not even requested (usually for perf reasons).
-        /// 
+        ///
         /// These can be used in various combinations to test the filematcher framework.
         /// </summary>
         /// <param name="filespec">A FileMatcher filespec, possibly with wildcards.</param>
@@ -1163,17 +1163,17 @@ string expectedFilenamePart
                 string filenamePart;
                 FileMatcher.SplitFileSpec
                 (
-                    filespec, 
-                    out fixedDirectoryPart, 
-                    out wildcardDirectoryPart, 
+                    filespec,
+                    out fixedDirectoryPart,
+                    out wildcardDirectoryPart,
                     out filenamePart,
                     new FileMatcher.GetFileSystemEntries(GetFileSystemEntriesLoopBack)
                 );
 
-                if 
+                if
                     (
-                    expectedWildcardDirectoryPart!=wildcardDirectoryPart 
-                    || expectedFixedDirectoryPart!=fixedDirectoryPart 
+                    expectedWildcardDirectoryPart!=wildcardDirectoryPart
+                    || expectedFixedDirectoryPart!=fixedDirectoryPart
                     || expectedFilenamePart!=filenamePart
                     )
                 {
@@ -1197,7 +1197,7 @@ bool shouldBeRecursive
             {
                 ValidateFileMatch(filespec, fileToMatch, shouldBeRecursive, /* Simulate filesystem? */ true);
             }
-            
+
             /*************************************************************************************
             * Given a pattern (filespec) and a candidate filename (fileToMatch). Verify that they
             * do indeed match.
@@ -1216,7 +1216,7 @@ bool fileSystemSimulation
                 }
 
                 // Now, simulate a filesystem with only fileToMatch. Make sure the file exists that way.
-                if (fileSystemSimulation) 
+                if (fileSystemSimulation)
                 {
                     MatchDriver
                     (
@@ -1320,7 +1320,7 @@ bool shouldBeRecursive
 
 
 
-#endregion        
+#endregion
     }
 }
 
diff --git a/src/Deprecated/Engine/Shared/UnitTests/FileUtilities_Tests.cs b/src/Deprecated/Engine/Shared/UnitTests/FileUtilities_Tests.cs
index a51a2a98b5b..8237c76152d 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/FileUtilities_Tests.cs
@@ -266,7 +266,7 @@ public void IsItemSpecModifier()
             Assertion.Assert("test 57", !FileUtilities.IsItemSpecModifier("createdxxxx"));
             Assertion.Assert("test 58", !FileUtilities.IsItemSpecModifier("Createdxxxx"));
             Assertion.Assert("test 59", !FileUtilities.IsItemSpecModifier("xxxxxxxxxxx"));
-            
+
             Assertion.Assert("test 60", !FileUtilities.IsItemSpecModifier("recursivexxx"));
             Assertion.Assert("test 61", !FileUtilities.IsItemSpecModifier("Recursivexxx"));
             Assertion.Assert("test 62", !FileUtilities.IsItemSpecModifier("accessedxxxx"));
@@ -274,7 +274,7 @@ public void IsItemSpecModifier()
             Assertion.Assert("test 64", !FileUtilities.IsItemSpecModifier("modifiedxxxx"));
             Assertion.Assert("test 65", !FileUtilities.IsItemSpecModifier("Modifiedxxxx"));
             Assertion.Assert("test 66", !FileUtilities.IsItemSpecModifier("xxxxxxxxxxxx"));
-            
+
             Assertion.Assert("test 67", !FileUtilities.IsItemSpecModifier(null));
         }
 
diff --git a/src/Deprecated/Engine/Shared/UnitTests/MockEngine.cs b/src/Deprecated/Engine/Shared/UnitTests/MockEngine.cs
index 0d6c712ce5c..6c955fb201c 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/MockEngine.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/MockEngine.cs
@@ -18,19 +18,19 @@
 namespace Microsoft.Build.UnitTests
 {
     /***************************************************************************
-     * 
+     *
      * Class:       MockEngine
      * Owner:       RGoel
-     * 
+     *
      * In order to execute tasks, we have to pass in an Engine object, so the
      * task can log events.  It doesn't have to be the real Engine object, just
      * something that implements the IBuildEngine2 interface.  So, we mock up
      * a fake engine object here, so we're able to execute tasks from the unit tests.
-     * 
+     *
      * The unit tests could have instantiated the real Engine object, but then
      * we would have had to take a reference onto the Microsoft.Build.Engine assembly, which
      * is somewhat of a no-no for task assemblies.
-     * 
+     *
      **************************************************************************/
     sealed internal class MockEngine : IBuildEngine2
     {
@@ -167,7 +167,7 @@ public int ColumnNumberOfTaskNode
                 return 0;
             }
         }
-        
+
         public BuildPropertyGroup GlobalProperties
         {
             set { engineGlobalProperties = value; }
@@ -179,7 +179,7 @@ internal string Log
             set { log = value; }
             get { return log; }
         }
-        
+
         public bool IsRunningMultipleNodes
         {
             get { return isRunningMultipleNodes; }
@@ -188,9 +188,9 @@ public bool IsRunningMultipleNodes
 
         public bool BuildProjectFile
             (
-            string projectFileName, 
-            string[] targetNames, 
-            IDictionary globalPropertiesPassedIntoTask, 
+            string projectFileName,
+            string[] targetNames,
+            IDictionary globalPropertiesPassedIntoTask,
             IDictionary targetOutputs
             )
         {
@@ -220,7 +220,7 @@ string toolsVersion
 
             return engine.BuildProjectFile(projectFileName, targetNames, finalGlobalProperties, targetOutputs, BuildSettings.None, toolsVersion);
         }
-        
+
         public bool BuildProjectFilesInParallel
         (
             string[] projectFileNames,
@@ -238,7 +238,7 @@ bool unloadProjectsOnCompletion
             for (int i = 0; i < projectFileNames.Length; i++)
             {
 
-                BuildPropertyGroup finalGlobalProperties = null;  
+                BuildPropertyGroup finalGlobalProperties = null;
                 if (globalProperties[i] != null)
                 {
                     finalGlobalProperties = new BuildPropertyGroup();
@@ -265,7 +265,7 @@ string projectFileName
 
         public bool BuildProjectFile
             (
-            string projectFileName, 
+            string projectFileName,
             string[] targetNames
             )
         {
@@ -275,7 +275,7 @@ string[] targetNames
 
         public bool BuildProjectFile
             (
-            string projectFileName, 
+            string projectFileName,
             string targetName
             )
         {
@@ -292,14 +292,14 @@ BuildPropertyGroup globalProperties
         {
             return engine.BuildProjectFile(projectFile, targetNames, globalProperties);
         }
-        
+
         public void UnregisterAllLoggers
             (
             )
         {
             engine.UnregisterAllLoggers();
         }
-        
+
         public void UnloadAllProjects
             (
             )
@@ -321,7 +321,7 @@ internal void AssertLogContains(string contains)
                 upperLog = log;
                 upperLog = upperLog.ToUpperInvariant();
             }
-            
+
             // If we do not contain this string than pass it to
             // MockLogger. Since MockLogger is also registered as
             // a logger it may have this string.
@@ -331,7 +331,7 @@ internal void AssertLogContains(string contains)
                 )
               )
             {
-               mockLogger.AssertLogContains(contains); 
+               mockLogger.AssertLogContains(contains);
             }
         }
 
@@ -356,7 +356,7 @@ internal void AssertLogDoesntContain(string contains)
                     contains.ToUpperInvariant()
                 )
             );
-            
+
             // If we do not contain this string than pass it to
             // MockLogger. Since MockLogger is also registered as
             // a logger it may have this string.
diff --git a/src/Deprecated/Engine/Shared/UnitTests/MockLogger.cs b/src/Deprecated/Engine/Shared/UnitTests/MockLogger.cs
index 330c0d1a9d7..91576965afd 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/MockLogger.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/MockLogger.cs
@@ -17,7 +17,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 
-    
+
 namespace Microsoft.Build.UnitTests
 {
     /*
@@ -38,7 +38,7 @@ internal sealed class MockLogger : ILogger
         private List<BuildWarningEventArgs> warnings = new List<BuildWarningEventArgs>();
         private List<ExternalProjectStartedEventArgs> externalProjectStartedEvents = new List<ExternalProjectStartedEventArgs>();
         private List<ExternalProjectFinishedEventArgs> externalProjectFinishedEvents = new List<ExternalProjectFinishedEventArgs>();
-        
+
         /*
          * Method:  ErrorCount
          * Owner:   jomof
@@ -49,8 +49,8 @@ internal sealed class MockLogger : ILogger
         internal int ErrorCount
         {
             get { return this.errorCount; }
-        }          
-        
+        }
+
         /*
          * Method:  WarningCount
          * Owner:   jomof
@@ -113,9 +113,9 @@ internal List<ExternalProjectFinishedEventArgs> ExternalProjectFinishedEvents
         internal string FullLog
         {
             get { return this.fullLog.ToString(); }
-        }      
-#endregion                    
-        
+        }
+#endregion
+
 #region Minimal ILogger implementation
 
         /*
@@ -129,14 +129,14 @@ public LoggerVerbosity Verbosity
         {
             get  {return LoggerVerbosity.Normal;}
             set  {/* do nothing */}
-        }  
-        
+        }
+
         /*
          * Property:    Parameters
          * Owner:       SumedhK
-         * 
+         *
          * The mock logger does not take parameters.
-         * 
+         *
          */
         public string Parameters
         {
@@ -150,7 +150,7 @@ public string Parameters
                 // do nothing
             }
         }
-        
+
         /*
          * Method:  Initialize
          * Owner:   jomof
@@ -175,9 +175,9 @@ public void ClearLog()
         /*
          * Method:  Shutdown
          * Owner:   SumedhK
-         * 
+         *
          * The mock logger does not need to release any resources.
-         * 
+         *
          */
         public void Shutdown()
         {
@@ -203,7 +203,7 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                 if (w.Code != "MSB4056" && !w.Message.Contains("MSB4056"))
                 {
                     fullLog.AppendFormat("{0}({1},{2}): {3} warning {4}: {5}\r\n",
-                        w.File, 
+                        w.File,
                         w.LineNumber,
                         w.ColumnNumber,
                         w.Subcategory,
@@ -219,7 +219,7 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                 BuildErrorEventArgs e = (BuildErrorEventArgs) eventArgs;
 
                 fullLog.AppendFormat("{0}({1},{2}): {3} error {4}: {5}\r\n",
-                    e.File, 
+                    e.File,
                     e.LineNumber,
                     e.ColumnNumber,
                     e.Subcategory,
diff --git a/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs b/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
index 1d28600ad11..980d0451b44 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
@@ -20,7 +20,7 @@
 using Microsoft.Build.BuildEngine;
 using Microsoft.Build.Framework;
 using Microsoft.VisualStudio.Internal;
-    
+
 namespace Microsoft.Build.UnitTests
 {
     /*
@@ -30,14 +30,14 @@ namespace Microsoft.Build.UnitTests
      * Utility methods for unit tests that work through the object model.
      *
      */
-    public static class ObjectModelHelpers        
+    public static class ObjectModelHelpers
     {
         private const string msbuildNamespace = "http://schemas.microsoft.com/developer/msbuild/2003";
         private const string msbuildDefaultToolsVersion = BrandNames.VSGeneralVersion;
         private const string msbuildAssemblyVersion = BrandNames.VSGeneralAssemblyVersion;
 
         /// <summary>
-        /// Return the default tools version 
+        /// Return the default tools version
         /// </summary>
         internal static string MSBuildDefaultToolsVersion
         {
@@ -52,7 +52,7 @@ private set
         }
 
         /// <summary>
-        /// Return the current assembly version 
+        /// Return the current assembly version
         /// </summary>
         internal static string MSBuildAssemblyVersion
         {
@@ -124,7 +124,7 @@ static internal BuildItem AssertSingleItem(Project p, string type, string itemIn
 
         /// <summary>
         /// Given a hash table of ITaskItems, make sure there is exactly one
-        /// item and that the key is 'key' and the Value is an ITaskItem with 
+        /// item and that the key is 'key' and the Value is an ITaskItem with
         /// an item spec of 'itemSpec'
         /// </summary>
         /// <param name="d"></param>
@@ -151,19 +151,19 @@ static internal void AssertSingleItemInDictionary(IDictionary d, string expected
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
@@ -174,19 +174,19 @@ static internal void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
         }
 
         /// <summary>
-        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from 
+        /// Amazingly sophisticated :) helper function to determine if the set of ITaskItems returned from
         /// a task match the expected set of ITaskItems.  It can also check that the ITaskItems have the expected
         /// metadata, and that the ITaskItems are returned in the correct order.
-        /// 
+        ///
         /// The "expectedItemsString" is a formatted way of easily specifying which items you expect to see.
         /// The format is:
-        /// 
+        ///
         ///         itemspec1 :   metadataname1=metadatavalue1 ; metadataname2=metadatavalue2 ; ...
         ///         itemspec2 :   metadataname3=metadatavalue3 ; metadataname4=metadatavalue4 ; ...
         ///         itemspec3 :   metadataname5=metadatavalue5 ; metadataname6=metadatavalue6 ; ...
-        /// 
+        ///
         /// (Each item needs to be on its own line.)
-        /// 
+        ///
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <param name="actualItems"></param>
@@ -226,7 +226,7 @@ static internal void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
             for (int actualItemIndex = 0 ; actualItemIndex < actualItems.Length ; actualItemIndex++)
             {
                 ITaskItem actualItem = actualItems[actualItemIndex];
-                
+
                 // Loop through all the expected items to find one with the same item spec.
                 ITaskItem expectedItem = null;
                 int expectedItemIndex;
@@ -260,13 +260,13 @@ static internal void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
                         string expectedMetadataValue = expectedItem.GetMetadata(metadataName);
                         string actualMetadataValue = actualItem.GetMetadata(metadataName);
 
-                        Assertion.Assert(string.Format("Item '{0}' does not have expected metadata '{1}'.", actualItem.ItemSpec, metadataName), 
+                        Assertion.Assert(string.Format("Item '{0}' does not have expected metadata '{1}'.", actualItem.ItemSpec, metadataName),
                             actualMetadataValue.Length > 0 || expectedMetadataValue.Length == 0);
 
-                        Assertion.Assert(string.Format("Item '{0}' has unexpected metadata {1}={2}.", actualItem.ItemSpec, metadataName, actualMetadataValue), 
+                        Assertion.Assert(string.Format("Item '{0}' has unexpected metadata {1}={2}.", actualItem.ItemSpec, metadataName, actualMetadataValue),
                             actualMetadataValue.Length == 0 || expectedMetadataValue.Length > 0);
 
-                        Assertion.Assert(string.Format("Item '{0}' has metadata {1}={2} instead of expected {1}={3}.", 
+                        Assertion.Assert(string.Format("Item '{0}' has metadata {1}={2} instead of expected {1}={3}.",
                             actualItem.ItemSpec, metadataName, actualMetadataValue, expectedMetadataValue),
                             actualMetadataValue == expectedMetadataValue);
                     }
@@ -377,7 +377,7 @@ static internal string CleanupFileContents(string projectFileContents)
         /// <owner>RGoel</owner>
         static private string NormalizeXmlWhitespace(XmlDocument xmldoc)
         {
-            // Normalize all the whitespace by writing the Xml document out to a 
+            // Normalize all the whitespace by writing the Xml document out to a
             // string, with PreserveWhitespace=false.
             xmldoc.PreserveWhitespace = false;
             StringWriter stringWriter = new StringWriter();
@@ -421,7 +421,7 @@ static internal Project CreateInMemoryProject(string xml)
         {
             return CreateInMemoryProject(xml, new ConsoleLogger());
         }
-        
+
         /// <summary>
         /// Create a project in memory. Load up the given XML.
         /// </summary>
@@ -488,7 +488,7 @@ static internal Project CreateInMemoryProject(Engine e, string xml, ILogger logg
             // Return to the original directory.
             Directory.SetCurrentDirectory(originalDir);
 
-            return p;   
+            return p;
         }
 
         /// <summary>
@@ -591,10 +591,10 @@ internal static void DeleteTempProjectDirectory()
             // For some reason sometimes get "directory is not empty"
             // Try to be as robust as possible using retries and catching all exceptions.
             for (int retries = 0; retries < 5; retries++)
-            {          
+            {
                 try
                 {
-                    // Manually deleting all children, but intentionally leaving the 
+                    // Manually deleting all children, but intentionally leaving the
                     // Temp project directory behind due to locking issues which were causing
                     // failures in main on Amd64-WOW runs.
                     if (Directory.Exists(TempProjectDir))
@@ -630,7 +630,7 @@ internal static string CreateFileInTempProjectDirectory(string fileRelativePath,
 
             // retries to deal with occasional locking issues where the file can't be written to initially
             for (int retries = 0; retries < 5; retries++)
-            {          
+            {
                 try
                 {
                     File.WriteAllText(fullFilePath, CleanupFileContents(fileContents));
@@ -642,11 +642,11 @@ internal static string CreateFileInTempProjectDirectory(string fileRelativePath,
                     {
                         Console.WriteLine(ex.ToString());
                     }
-                    else 
+                    else
                     {
-                        // All the retries have failed, so we're pretty much screwed. Might as well fail with the 
-                        // actual problem now instead of with some more difficult-to-understand 
-                        // issue later. 
+                        // All the retries have failed, so we're pretty much screwed. Might as well fail with the
+                        // actual problem now instead of with some more difficult-to-understand
+                        // issue later.
                         throw ex;
                     }
                 }
diff --git a/src/Deprecated/Engine/Shared/UnitTests/SolutionParser_Tests.cs b/src/Deprecated/Engine/Shared/UnitTests/SolutionParser_Tests.cs
index cfebd960b5a..2d8491dfb9a 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/SolutionParser_Tests.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/SolutionParser_Tests.cs
@@ -34,7 +34,7 @@ public void BasicParseFirstProjectLine()
 
             p.ParseFirstProjectLine
             (
-                "Project(\"{Project GUID}\") = \"Project name\", \"Relative path to project file\", \"Unique name-GUID\"", 
+                "Project(\"{Project GUID}\") = \"Project name\", \"Relative path to project file\", \"Unique name-GUID\"",
                  proj
             );
             Assertion.AssertEquals(SolutionProjectType.Unknown, proj.ProjectType);
@@ -56,7 +56,7 @@ public void ParseFirstProjectLineWithDifferentSpacing()
 
             p.ParseFirstProjectLine
             (
-                "Project(\" {Project GUID} \")  = \" Project name \",  \" Relative path to project file \"    , \" Unique name-GUID \"", 
+                "Project(\" {Project GUID} \")  = \" Project name \",  \" Relative path to project file \"    , \" Unique name-GUID \"",
                  proj
             );
             Assertion.AssertEquals(SolutionProjectType.Unknown, proj.ProjectType);
@@ -94,7 +94,7 @@ public void ParseEtpProject()
                         </References>
                     </GENERAL>
                 </EFPROJECT>";
-               
+
                 File.WriteAllText(proj1Path, etpProjContent);
 
                 // Create the SolutionParser object
@@ -350,7 +350,7 @@ public void ParseNestedEtpProjectMultipleLevel()
                 File.Delete(proj2Path);
                 File.Delete(proj3Path);
             }
-            
+
         }
 
         /// <summary>
@@ -450,14 +450,14 @@ public void ParseFirstProjectLineWhereProjectNameHasSpecialCharacters()
 
             p.ParseFirstProjectLine
             (
-                "Project(\"{Project GUID}\")  = \"MyProject,(=IsGreat)\",  \"Relative path to project file\"    , \"Unique name-GUID\"", 
+                "Project(\"{Project GUID}\")  = \"MyProject,(=IsGreat)\",  \"Relative path to project file\"    , \"Unique name-GUID\"",
                  proj
             );
             Assertion.AssertEquals(SolutionProjectType.Unknown, proj.ProjectType);
             Assertion.AssertEquals("MyProject,(=IsGreat)", proj.ProjectName);
             Assertion.AssertEquals("Relative path to project file", proj.RelativePath);
             Assertion.AssertEquals("Unique name-GUID", proj.ProjectGuid);
-        }   
+        }
 
         /// <summary>
         /// Helper method to create a SolutionParser object, and call it to parse the SLN file
@@ -502,7 +502,7 @@ public void BadVersionStamp()
 
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
         }
-        
+
         /// <summary>
         /// Expected version numbers less than 7 to cause an invalid project file exception.
         /// </summary>
@@ -547,7 +547,7 @@ public void Version9()
                 ";
 
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
-            
+
             Assertion.AssertEquals(9, solution.Version);
         }
 
@@ -566,7 +566,7 @@ public void Version10()
         }
 
         /// <summary>
-        /// Test to parse a very basic .sln file to validate that description property in a solution file 
+        /// Test to parse a very basic .sln file to validate that description property in a solution file
         /// is properly handled.
         /// </summary>
         /// <owner>yroy</owner>
@@ -650,7 +650,7 @@ public void BasicSolution()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
 
             Assertion.AssertEquals(3, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(SolutionProjectType.ManagedProject,  solution.Projects[0].ProjectType);
             Assertion.AssertEquals("ConsoleApplication1",                      solution.Projects[0].ProjectName);
             Assertion.AssertEquals(@"ConsoleApplication1\ConsoleApplication1.vbproj", solution.Projects[0].RelativePath);
@@ -675,7 +675,7 @@ public void BasicSolution()
             Assertion.AssertEquals(null,                                       solution.Projects[2].ParentProjectGuid);
             Assertion.AssertEquals("ClassLibrary1",                            solution.Projects[2].GetUniqueProjectName());
 
-        }   
+        }
 
         /// <summary>
         /// Exercises solution folders, and makes sure that samely named projects in different
@@ -731,7 +731,7 @@ public void SolutionFolders()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
 
             Assertion.AssertEquals(5, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(@"ClassLibrary1\ClassLibrary1.csproj",      solution.Projects[0].RelativePath);
             Assertion.AssertEquals("{34E0D07D-CF8F-459D-9449-C4188D8C5564}",   solution.Projects[0].ProjectGuid);
             Assertion.AssertEquals(0,                                          solution.Projects[0].Dependencies.Count);
@@ -815,7 +815,7 @@ public void SolutionDependencies()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
 
             Assertion.AssertEquals(3, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(@"ClassLibrary1\ClassLibrary1.csproj",      solution.Projects[0].RelativePath);
             Assertion.AssertEquals("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}",   solution.Projects[0].ProjectGuid);
             Assertion.AssertEquals(1,                                          solution.Projects[0].Dependencies.Count);
@@ -891,7 +891,7 @@ public void VenusProject()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents.Replace('`', '"'));
 
             Assertion.AssertEquals(1, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(SolutionProjectType.WebProject,      solution.Projects[0].ProjectType);
             Assertion.AssertEquals(@"C:\WebSites\WebApplication3\",            solution.Projects[0].ProjectName);
             Assertion.AssertEquals(@"C:\WebSites\WebApplication3\",            solution.Projects[0].RelativePath);
@@ -974,7 +974,7 @@ public void VenusProjectInASolutionFolder()
             SolutionParser solution = ParseSolutionHelper(solutionFileContents);
 
             Assertion.AssertEquals(3, solution.Projects.Length);
-            
+
             Assertion.AssertEquals(SolutionProjectType.WebProject,      solution.Projects[0].ProjectType);
             Assertion.AssertEquals(@"C:\WebSites\WebApplication3\",            solution.Projects[0].GetUniqueProjectName());
 
@@ -1138,7 +1138,7 @@ public void ParseInvalidSolutionConfigurations3()
         }
 
         /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly 
+        /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
         /// </summary>
         /// <owner>LukaszG</owner>
@@ -1237,7 +1237,7 @@ public void ParseProjectConfigurationsInSolutionConfigurations1()
         }
 
         /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly 
+        /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a more tricky solution
         /// </summary>
         /// <owner>LukaszG</owner>
diff --git a/src/Deprecated/Engine/Shared/UnitTests/XmlUtilities_Tests.cs b/src/Deprecated/Engine/Shared/UnitTests/XmlUtilities_Tests.cs
index 56948d3d86b..55f9f452285 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/XmlUtilities_Tests.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/XmlUtilities_Tests.cs
@@ -46,7 +46,7 @@ public void InvalidNameErrorLocation()
         }
 
         /// <summary>
-        /// Helper for invalid name error location test 
+        /// Helper for invalid name error location test
         /// </summary>
         /// <param name="name"></param>
         /// <param name="badChar"></param>
diff --git a/src/Deprecated/Engine/Shared/XMakeElements.cs b/src/Deprecated/Engine/Shared/XMakeElements.cs
index f179b6c2add..3e759935887 100644
--- a/src/Deprecated/Engine/Shared/XMakeElements.cs
+++ b/src/Deprecated/Engine/Shared/XMakeElements.cs
@@ -54,8 +54,8 @@ internal static bool IsValidTaskChildNode(XmlNode childNode)
         internal static readonly char[] illegalTargetNameCharacters = new char[] { '$', '@', '(', ')', '%', '*', '?', '.' };
 
         // Names that cannot be used as property or item names because they are reserved
-        internal static readonly string[] illegalPropertyOrItemNames = new string[] { 
-//            XMakeElements.project, // "Project" is not reserved, because unfortunately ProjectReference items 
+        internal static readonly string[] illegalPropertyOrItemNames = new string[] {
+//            XMakeElements.project, // "Project" is not reserved, because unfortunately ProjectReference items
                                      // already use it as metadata name.
             XMakeElements.visualStudioProject,
             XMakeElements.target,
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index 78f2965d971..700cbfdb753 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -81,7 +81,7 @@ internal static string GetXmlNodeFile(XmlNode node, string defaultFile)
         }
 
         /// <summary>
-        /// An XML document can have many root nodes, but usually we want the single root 
+        /// An XML document can have many root nodes, but usually we want the single root
         /// element. Callers can test each root node in turn with this method, until it returns
         /// true.
         /// </summary>
@@ -154,8 +154,8 @@ internal static bool IsValidElementName(string name)
         }
 
         /// <summary>
-        /// Finds the location of the first invalid character, if any, in the name of an 
-        /// item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none. 
+        /// Finds the location of the first invalid character, if any, in the name of an
+        /// item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none.
         /// Valid names must match this pattern:  [A-Za-z_][A-Za-z_0-9\-.]*
         /// Note, this is a subset of all possible valid XmlElement names: we use a subset because we also
         /// have to match this same set in our regular expressions, and allowing all valid XmlElement name
@@ -192,8 +192,8 @@ internal static int LocateFirstInvalidElementNameCharacter(string name)
         }
 
         /// <summary>
-        /// Load the xml file using XMLTextReader and locate the element and attribute specified and then 
-        /// return the value. This is a quick way to peek at the xml file whithout having the go through 
+        /// Load the xml file using XMLTextReader and locate the element and attribute specified and then
+        /// return the value. This is a quick way to peek at the xml file whithout having the go through
         /// the XMLDocument (MSDN article (Chapter 9 - Improving XML Performance)).
         /// </summary>
         internal static string GetAttributeValueForElementFromFile
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index a0bdcf41c6d..f8c02067a6f 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -213,7 +213,7 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile, st
                 return false;
             }
 
-            // We also store the version of MSBuild that wrote the file and verify it's the same as ours: that ensures that we 
+            // We also store the version of MSBuild that wrote the file and verify it's the same as ours: that ensures that we
             // don't read possibly incompatible caches.
             string thisVersion = Constants.AssemblyVersion;
             if (!String.Equals(cacheVersion, thisVersion, StringComparison.OrdinalIgnoreCase))
@@ -238,11 +238,11 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile, st
                 return false;
             }
 
-            // If there are inputs to check, we should also add the solution file, as we need to make sure the 
+            // If there are inputs to check, we should also add the solution file, as we need to make sure the
             // solution file is up to date with respect to the cache file
 
             // Get the solution file name because the solution file may be something like myDirectory\mysolution.sln
-            // and since we have already calculated the directory for the solution file, we just need the filename name to 
+            // and since we have already calculated the directory for the solution file, we just need the filename name to
             // combine with the directory to get the full path to the solution file without having to call GetFullPath again.
             string solutionFileName = Path.GetFileName(solutionFile);
             string solutionFileLocation = Path.Combine(solutionFileDirectory, solutionFileName);
@@ -297,8 +297,8 @@ private static Project CreateNewProject(SolutionParser solution, string wrapperP
         /// </summary>
         private static void CreateSolutionProject(SolutionParser solution, Project msbuildProject, BuildEventContext projectBuildEventContext, string wrapperProjectToolsVersion, Engine parentEngine, string solutionProjectCache)
         {
-            // We have to figure out what tools version the children will be built with, because we will 
-            // have to load and scan them to construct the solution wrapper project, and we should use the 
+            // We have to figure out what tools version the children will be built with, because we will
+            // have to load and scan them to construct the solution wrapper project, and we should use the
             // same tools version they'll build with.
             string childProjectToolsVersion = DetermineChildProjectToolsVersion(parentEngine, wrapperProjectToolsVersion);
 
@@ -676,7 +676,7 @@ string fullConfigurationName
             newTask.SetParameterValue("SolutionFile", solutionPath, true /* treat as literal */);
 
             // If the user passed in an override stylesheet for this .VCPROJ (by specifying a global
-            // property called VCBuildOverride), we need to use it to resolve the output path.  Override 
+            // property called VCBuildOverride), we need to use it to resolve the output path.  Override
             // stylesheets can be used to change the directory that VC projects get built to.
             newTask.SetParameterValue("Override", "$(VCBuildOverride)");
 
@@ -783,7 +783,7 @@ out string addedReferenceGuids
                         addCreateItem = true;
                     }
 
-                    // Add create item if either of the conditions above was true. 
+                    // Add create item if either of the conditions above was true.
                     // This merges the one-item item list into the main list, adding the appropriate guid metadata
                     if (addCreateItem)
                     {
@@ -914,8 +914,8 @@ string subTargetName
 
             if (subTargetName == "Publish")
             {
-                // Well, hmmm.  The VCBuild doesn't support any kind of 
-                // a "Publish" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The VCBuild doesn't support any kind of
+                // a "Publish" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageElement(newTarget, XMakeElements.warning, true, "SolutionVCProjectNoPublish");
 
@@ -1113,10 +1113,10 @@ string conditionDescribingValidConfigurations
             string destinationFolder = String.Format(CultureInfo.InvariantCulture,
                 @"$({0})\Bin\", GenerateSafePropertyName(proj, "AspNetPhysicalPath"));
 
-            // This is a bit of a hack.  We're actually calling the "Copy" task on all of 
-            // the *non-existent* files.  Why?  Because we want to emit a warning in the 
+            // This is a bit of a hack.  We're actually calling the "Copy" task on all of
+            // the *non-existent* files.  Why?  Because we want to emit a warning in the
             // log for each non-existent file, and the Copy task does that nicely for us.
-            // I would have used the <Warning> task except for the fact that we are in 
+            // I would have used the <Warning> task except for the fact that we are in
             // string-resource lockdown.
             BuildTask copyNonExistentReferencesTask = target.AddNewTask("Copy");
             copyNonExistentReferencesTask.SetParameterValue("SourceFiles", "@(" + referenceItemName + "->'%(FullPath)')", false /* Do not treat as literal */);
@@ -1124,7 +1124,7 @@ string conditionDescribingValidConfigurations
             copyNonExistentReferencesTask.Condition = String.Format(CultureInfo.InvariantCulture, "!Exists('%({0}.Identity)')", referenceItemName);
             copyNonExistentReferencesTask.ContinueOnError = true;
 
-            // Call ResolveAssemblyReference on each of the .DLL files that were found on 
+            // Call ResolveAssemblyReference on each of the .DLL files that were found on
             // disk from the .REFRESH files as well as the P2P references.  RAR will crack
             // the dependencies, find PDBs, satellite assemblies, etc., and determine which
             // files need to be copy-localed.
@@ -1222,7 +1222,7 @@ string solutionFile
 
                 if (!String.IsNullOrEmpty(lastFolderInPhysicalPath))
                 {
-                    // If there is a global property called "OutDir" set, that means the caller is trying to 
+                    // If there is a global property called "OutDir" set, that means the caller is trying to
                     // override the AspNetTargetPath.  What we want to do in this case is concatenate:
                     //  $(OutDir) + "\_PublishedWebsites" + (the last portion of the folder in the AspNetPhysicalPath).
                     BuildProperty targetPathOverrideProperty = newPropertyGroup.AddNewProperty(GenerateSafePropertyName(proj, "AspNetTargetPath"),
@@ -1360,15 +1360,15 @@ string subTargetName
 
             if (subTargetName == "Clean")
             {
-                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of 
-                // a "Clean" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of
+                // a "Clean" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageElement(newTarget, XMakeElements.message, true, "SolutionVenusProjectNoClean");
             }
             else if (subTargetName == "Publish")
             {
-                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of 
-                // a "Publish" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The AspNetCompiler task doesn't support any kind of
+                // a "Publish" operation.  The best we can really do is offer up a
                 // message saying so.
                 AddErrorWarningMessageElement(newTarget, XMakeElements.message, true, "SolutionVenusProjectNoPublish");
             }
@@ -1384,7 +1384,7 @@ string subTargetName
 
                 // We're going to build up an MSBuild condition string that represents the valid Configurations.
                 // We do this by OR'ing together individual conditions, each of which compares $(Configuration)
-                // with a valid configuration name.  We init our condition string to "false", so we can easily 
+                // with a valid configuration name.  We init our condition string to "false", so we can easily
                 // OR together more stuff as we go, and also easily take the negation of the condition by putting
                 // a ! around the whole thing.
                 StringBuilder conditionDescribingValidConfigurations = new StringBuilder("(false)");
@@ -1396,7 +1396,7 @@ string subTargetName
                     AspNetCompilerParameters aspNetCompilerParameters = (AspNetCompilerParameters)aspNetConfiguration.Value;
 
                     // We only add the PropertyGroup once per Venus project.  Without the following "if", we would add
-                    // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with 
+                    // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with
                     // subTargetName=null and once when subTargetName="Rebuild".
                     if (subTargetName == null)
                     {
@@ -1434,7 +1434,7 @@ string subTargetName
                 // Add tasks to capture the auto-refreshed file references (those .REFRESH files).
                 AddTasksToResolveAutoRefreshFileReferences(newTarget, proj, referenceItemName.ToString());
 
-                // Add a call to RAR (ResolveAssemblyReference) and the Copy task to put the referenced 
+                // Add a call to RAR (ResolveAssemblyReference) and the Copy task to put the referenced
                 // project outputs in the right place
                 AddTasksToCopyAllDependenciesIntoBinDir(newTarget, proj, referenceItemName.ToString(), conditionDescribingValidConfigurations.ToString());
 
@@ -2045,7 +2045,7 @@ private static void ScanProjectDependencies(SolutionParser solution, Engine pare
                         // the one containing the solution file, and we'd get the relative path wrong
                         msbuildProject.Load(project.AbsolutePath);
 
-                        // Project references for MSBuild projects could be affected by the active configuration, 
+                        // Project references for MSBuild projects could be affected by the active configuration,
                         // so set it before retrieving references.
                         msbuildProject.GlobalProperties.SetProperty("Configuration",
                             project.ProjectConfigurations[fullSolutionConfigurationName].ConfigurationName, true /* treat as literal */);
@@ -2061,7 +2061,7 @@ private static void ScanProjectDependencies(SolutionParser solution, Engine pare
                         }
 
                         //
-                        // ProjectDependency items work exactly like ProjectReference items from the point of 
+                        // ProjectDependency items work exactly like ProjectReference items from the point of
                         // view of determining that project B depends on project A.  This item must cause
                         // project A to be built prior to project B.
                         //
diff --git a/src/Deprecated/Engine/Solution/VCProjectParser.cs b/src/Deprecated/Engine/Solution/VCProjectParser.cs
index 285725eb8e2..34a790dfcf9 100644
--- a/src/Deprecated/Engine/Solution/VCProjectParser.cs
+++ b/src/Deprecated/Engine/Solution/VCProjectParser.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BuildEngine
     internal static class VCProjectParser
     {
         /// <summary>
-        /// For a given VC project, retrieves the projects it references 
+        /// For a given VC project, retrieves the projects it references
         /// </summary>
         /// <param name="projectPath"></param>
         /// <returns></returns>
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index 95534559b85..b8b79a7e356 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -35,8 +35,8 @@ string subTargetName
             Target newTarget = msbuildProject.Targets.AddNewTarget(targetName);
             if (subTargetName == "Publish")
             {
-                // Well, hmmm.  The VCBuild doesn't support any kind of 
-                // a "Publish" operation.  The best we can really do is offer up a 
+                // Well, hmmm.  The VCBuild doesn't support any kind of
+                // a "Publish" operation.  The best we can really do is offer up a
                 // message saying so.
                 SolutionWrapperProject.AddErrorWarningMessageElement(newTarget, XMakeElements.error, true, "SolutionVCProjectNoPublish");
             }
@@ -221,7 +221,7 @@ internal static string VCBuildLocationHint
         }
 
         // The code below is mostly copied from the VCBuild task that we shipped in 3.5.
-        // It is the logic it uses to find vcbuild.exe. That logic had a flaw - 
+        // It is the logic it uses to find vcbuild.exe. That logic had a flaw -
         // in 64 bit MSBuild, in a vanilla command window (like in Team Build) it would not
         // find vcbuild.exe. We use the logic below to predict whether VCBuild will find it,
         // and if it won't, we will pass the "hint" to use the 64 bit program files location.
@@ -231,7 +231,7 @@ internal static string VCBuildLocationHint
         /// </summary>
         // root registry key for VS9
         private const string vs9RegKey = @"SOFTWARE\Microsoft\VisualStudio\9.0";
-        // the name of the value containing disk install directory for the IDE components 
+        // the name of the value containing disk install directory for the IDE components
         // ("...\common7\ide" for layouts)
         private const string vs9InstallDirValueName = "InstallDir";
         // relative path from the above directory to vcbuild.exe on layouts
@@ -244,7 +244,7 @@ internal static string VCBuildLocationHint
         /// </summary>
         // root registry key for VC9
         private const string vc9RegKey = @"SOFTWARE\Microsoft\VCExpress\9.0";
-        // the name of the value containing disk install directory for the IDE components 
+        // the name of the value containing disk install directory for the IDE components
         // ("...\common7\ide" for layouts)
         private const string vc9InstallDirValueName = "InstallDir";
         // relative path from the above directory to vcbuild.exe on layouts
diff --git a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
index cfd1bf7c879..5c833b7e4b6 100644
--- a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
+++ b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
@@ -68,7 +68,7 @@ internal IntrinsicTask(XmlElement taskNodeXmlElement, EngineLoggingServices logg
         #region Methods
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         internal void ExecuteTask(Lookup lookup)
         {
@@ -157,7 +157,7 @@ private void ExecuteItemGroup(Lookup lookup)
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
                     {
-                        // Gather the outputs, but don't make them visible to other buckets 
+                        // Gather the outputs, but don't make them visible to other buckets
                         switch (child.ChildType)
                         {
                             case ChildType.BuildItemAdd:
@@ -204,7 +204,7 @@ private void ExecuteAdd(BuildItemGroupChildXml child, ItemBucket bucket)
         }
 
         /// <summary>
-        /// Remove items from the world. Removes to items that are part of the project manifest are backed up, so 
+        /// Remove items from the world. Removes to items that are part of the project manifest are backed up, so
         /// they can be reverted when the project is reset after the end of the build.
         /// </summary>
         private void ExecuteRemove(BuildItemGroupChildXml child, ItemBucket bucket)
@@ -230,7 +230,7 @@ private void ExecuteRemove(BuildItemGroupChildXml child, ItemBucket bucket)
         }
 
         /// <summary>
-        /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so 
+        /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so
         /// they can be reverted when the project is reset after the end of the build.
         /// </summary>
         /// <param name="child"></param>
@@ -375,6 +375,6 @@ internal static bool IsIntrinsicTaskName(string name)
                 || String.Equals(name, XMakeElements.itemGroup, StringComparison.Ordinal);
         }
 
-        #endregion  
+        #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs b/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
index 630ce7f29a6..eb7abc45aa8 100644
--- a/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
+++ b/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
@@ -36,9 +36,9 @@ string filespec
 
             if (containsEscapedWildcards && containsRealWildcards)
             {
-                // Umm, this makes no sense.  The item's Include has both escaped wildcards and 
+                // Umm, this makes no sense.  The item's Include has both escaped wildcards and
                 // real wildcards.  What does he want us to do?  Go to the file system and find
-                // files that literally have '*' in their filename?  Well, that's not going to 
+                // files that literally have '*' in their filename?  Well, that's not going to
                 // happen because '*' is an illegal character to have in a filename.
 
                 // Just return the original string.
@@ -64,7 +64,7 @@ string filespec
                 // and on every machine.
                 Array.Sort(fileList);
 
-                // We must now go back and make sure all special characters are escaped because we always 
+                // We must now go back and make sure all special characters are escaped because we always
                 // store data in the engine in escaped form so it doesn't screw up our parsing.
                 // Note that this means that characters that were not escaped in the original filespec
                 // may now be escaped, but that's not easy to avoid.
@@ -75,7 +75,7 @@ string filespec
             }
             else
             {
-                // No real wildcards means we just return the original string.  Don't even bother 
+                // No real wildcards means we just return the original string.  Don't even bother
                 // escaping ... it should already be escaped appropriately since it came directly
                 // from the project file or the OM host.
                 fileList = new string[] { filespec };
diff --git a/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs b/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
index 7cbe04cbcdc..59cecdf0b05 100644
--- a/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
+++ b/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
@@ -154,8 +154,8 @@ internal static XmlAttribute GetConditionAttribute(XmlElement element, bool veri
                         condition = attribute;
                         break;
 
-                    // Label  is only recognized by the new OM.  
-                    // Ignore BUT ONLY if the caller of this function is a 
+                    // Label  is only recognized by the new OM.
+                    // Ignore BUT ONLY if the caller of this function is a
                     // PropertyGroup, ItemDefinitionGroup, or ItemGroup: the "Label"
                     // attribute is only legal on those element types.
                     case XMakeAttributes.label:
@@ -200,7 +200,7 @@ internal static XmlAttribute SetOrRemoveAttribute(XmlElement element, string nam
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
+        /// Returns the value of the attribute.
         /// If the attribute is null, returns an empty string.
         /// </summary>
         internal static string GetAttributeValue(XmlAttribute attribute)
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index d136a2607c9..0352fbf056b 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -117,4 +117,9 @@
     <FeatureMSIORedist>true</FeatureMSIORedist>
   </PropertyGroup>
 
+  <PropertyGroup Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">
+    <DefineConstants>$(DefineConstants);FEATURE_REPORTFILEACCESSES</DefineConstants>
+    <FeatureReportFileAccesses>true</FeatureReportFileAccesses>
+  </PropertyGroup>
+
 </Project>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 68295e63b40..67f3b7d2a26 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -106,11 +106,6 @@
     </ItemGroup>
   </Target>
 
-  <!-- Override in-box GenerateSatelliteAssemblies, as we are using CoreGenerateSatelliteAssemblies instead.
-       With https://github.com/dotnet/msbuild/pull/2726 this is no longer necessary, but that change is not
-       in VS 15.5 (which is what we use for Jenkins right now). -->
-  <Target Name="GenerateSatelliteAssemblies" />
-
   <Target Name="RemoveSatelliteDllsFromBuildOutputInPackage"
           BeforeTargets="GenerateNuspec"
           Condition=" '$(IncludeSatelliteOutputInPack)' == 'false' ">
diff --git a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
index 703349fde83..aa52ae16cdb 100644
--- a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
@@ -31,7 +31,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class BuildFinishedEventArgs2 : BuildFinishedEventArgs
diff --git a/src/Framework.UnitTests/BuildMessageEventArgs_Tests.cs b/src/Framework.UnitTests/BuildMessageEventArgs_Tests.cs
index 4d829a9222d..d347eece0b0 100644
--- a/src/Framework.UnitTests/BuildMessageEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildMessageEventArgs_Tests.cs
@@ -37,7 +37,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class BuildMessageEventArgs2 : BuildMessageEventArgs
diff --git a/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
index c3a2115e069..6e19e294d9d 100644
--- a/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildStartedEventArgs_Tests.cs
@@ -35,7 +35,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Trivially exercise getHashCode. 
+        /// Trivially exercise getHashCode.
         /// </summary>
         [Fact]
         public void TestGetHashCode()
@@ -44,7 +44,7 @@ public void TestGetHashCode()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class BuildStartedEventArgs2 : BuildStartedEventArgs
diff --git a/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs b/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
index 919bcc523d1..361e4044ebf 100644
--- a/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildWarningEventArgs_Tests.cs
@@ -47,7 +47,7 @@ public void TestGetHashCode()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class BuildWarningEventArgs2 : BuildWarningEventArgs
diff --git a/src/Framework.UnitTests/CriticalBuildMessageEventArgs_Tests.cs b/src/Framework.UnitTests/CriticalBuildMessageEventArgs_Tests.cs
index 0fe6a0094a4..ed16a63a917 100644
--- a/src/Framework.UnitTests/CriticalBuildMessageEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/CriticalBuildMessageEventArgs_Tests.cs
@@ -30,7 +30,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class CriticalBuildMessageEventArgs2 : CriticalBuildMessageEventArgs
diff --git a/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs b/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
index ec67a9b96aa..5e65f74a575 100644
--- a/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
+++ b/src/Framework.UnitTests/CustomEventArgSerialization_Tests.cs
@@ -192,7 +192,7 @@ public void TestBuildErrorEventArgs()
         }
 
         /// <summary>
-        /// Compare two BuildEventArgs 
+        /// Compare two BuildEventArgs
         /// </summary>
         private static void VerifyBuildErrorEventArgs(BuildErrorEventArgs genericEvent, BuildErrorEventArgs newGenericEvent)
         {
@@ -614,7 +614,7 @@ public void TestProjectStartedPropertySerialization()
         }
 
         /// <summary>
-        /// Compare the BuildProperties in propertyList with the Name Value pairs in the entryList. 
+        /// Compare the BuildProperties in propertyList with the Name Value pairs in the entryList.
         /// We need to make sure that each of the BuildProperties passed into the serializer come out correctly
         /// </summary>
         /// <param name="entryList">List of DictionaryEntries which were deserialized</param>
@@ -701,7 +701,7 @@ public void TestProjectStartedEventArgs()
         }
 
         /// <summary>
-        /// Compare two project started events 
+        /// Compare two project started events
         /// </summary>
         private static void VerifyProjectStartedEvent(ProjectStartedEventArgs genericEvent, ProjectStartedEventArgs newGenericEvent)
         {
diff --git a/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs b/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
index d1bcb987a1f..6739c53bc98 100644
--- a/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
@@ -156,6 +156,43 @@ public void ExtendedMessageEventArgs_SerializationDeserialization(bool withOptio
         argDeserialized.Should().BeEquivalentTo(arg);
     }
 
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedCriticalMessageEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedCriticalBuildMessageEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildMessageEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
     [Fact]
     public void ExtendedCustomBuildEventArgs_Ctors()
     {
@@ -215,4 +252,14 @@ public void ExtendedBuildMessageEventArgs_Ctors()
         ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default, DateTime.Now);
         ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default, DateTime.Now, null);
     }
+
+    [Fact]
+    public void ExtendedCriticalBuildMessageEventArgs_Ctors()
+    {
+        var ea = new ExtendedCriticalBuildMessageEventArgs();
+        ea = new ExtendedCriticalBuildMessageEventArgs("type");
+        ea = new ExtendedCriticalBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
+        ea = new ExtendedCriticalBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
+        ea = new ExtendedCriticalBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "arg1", "arg2");
+    }
 }
diff --git a/src/Framework.UnitTests/ExternalProjectFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/ExternalProjectFinishedEventArgs_Tests.cs
index 9f21ebb48fa..b6b7290ba12 100644
--- a/src/Framework.UnitTests/ExternalProjectFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ExternalProjectFinishedEventArgs_Tests.cs
@@ -29,7 +29,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class ExternalProjectFinishedEventArgs2 : ExternalProjectFinishedEventArgs
diff --git a/src/Framework.UnitTests/ExternalProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ExternalProjectStartedEventArgs_Tests.cs
index c3a47382a31..12e34378a48 100644
--- a/src/Framework.UnitTests/ExternalProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ExternalProjectStartedEventArgs_Tests.cs
@@ -29,7 +29,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class ExternalProjectStartedEventArgs2 : ExternalProjectStartedEventArgs
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index 09c42cc408e..7821be8ff91 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -13,7 +13,7 @@
   <ItemGroup>
     <PackageReference Include="FluentAssertions" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
-    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
   </ItemGroup>
diff --git a/src/Framework.UnitTests/ProjectFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectFinishedEventArgs_Tests.cs
index d55d227ec28..c7a17d9889c 100644
--- a/src/Framework.UnitTests/ProjectFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectFinishedEventArgs_Tests.cs
@@ -28,7 +28,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class ProjectFinishedEventArgs2 : ProjectFinishedEventArgs
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 2ab1af0fbd1..67bacf49a74 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -51,7 +51,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Verify different Items and properties are not taken into account in the equals comparison. They should 
+        /// Verify different Items and properties are not taken into account in the equals comparison. They should
         /// not be considered as part of the equals evaluation
         /// </summary>
         [Fact]
@@ -75,7 +75,7 @@ public void ItemsAndPropertiesDifferentEquals()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class ProjectStartedEventArgs2 : ProjectStartedEventArgs
diff --git a/src/Framework.UnitTests/TargetFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/TargetFinishedEventArgs_Tests.cs
index 6bd3ad2ba7f..5f5fe57ead6 100644
--- a/src/Framework.UnitTests/TargetFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TargetFinishedEventArgs_Tests.cs
@@ -31,7 +31,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TargetFinishedEventArgs2 : TargetFinishedEventArgs
diff --git a/src/Framework.UnitTests/TargetStartedEventArgs_Tests.cs b/src/Framework.UnitTests/TargetStartedEventArgs_Tests.cs
index 6eb88790fb7..571f57c4690 100644
--- a/src/Framework.UnitTests/TargetStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TargetStartedEventArgs_Tests.cs
@@ -31,7 +31,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TargetStartedEventArgs2 : TargetStartedEventArgs
diff --git a/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs b/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
index 4d053b565cb..dcc3c74c515 100644
--- a/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TaskCommandLineEventArgs_Tests.cs
@@ -29,7 +29,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TaskCommandLineEventArgs2 : TaskCommandLineEventArgs
diff --git a/src/Framework.UnitTests/TaskFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/TaskFinishedEventArgs_Tests.cs
index 1c5af624176..4a567d7f69a 100644
--- a/src/Framework.UnitTests/TaskFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TaskFinishedEventArgs_Tests.cs
@@ -29,7 +29,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TaskFinishedEventArgs2 : TaskFinishedEventArgs
diff --git a/src/Framework.UnitTests/TaskStartedEventArgs_Tests.cs b/src/Framework.UnitTests/TaskStartedEventArgs_Tests.cs
index b5cee33aa50..8a6358f4d2e 100644
--- a/src/Framework.UnitTests/TaskStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/TaskStartedEventArgs_Tests.cs
@@ -31,7 +31,7 @@ public void EventArgsCtors()
         }
 
         /// <summary>
-        /// Create a derived class so that we can test the default constructor in order to increase code coverage and 
+        /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
         /// </summary>
         private sealed class TaskStartedEventArgs2 : TaskStartedEventArgs
diff --git a/src/Framework/AssemblyLoadBuildEventArgs.cs b/src/Framework/AssemblyLoadBuildEventArgs.cs
index 49f827b19c9..767772f5fc8 100644
--- a/src/Framework/AssemblyLoadBuildEventArgs.cs
+++ b/src/Framework/AssemblyLoadBuildEventArgs.cs
@@ -39,7 +39,8 @@ public AssemblyLoadBuildEventArgs(
         public string? AssemblyName { get; private set; }
         public string? AssemblyPath { get; private set; }
         public Guid MVID { get; private set; }
-        // Null string indicates that load occurred on Default AppDomain (for both Core and Framework).
+        // Null string indicates that load occurred on Default AppDomain (for Framework).
+        // For Core, string won't be null.
         public string? AppDomainDescriptor { get; private set; }
 
         internal override void WriteToStream(BinaryWriter writer)
@@ -77,7 +78,12 @@ public override string Message
                 if (RawMessage == null)
                 {
                     string? loadingInitiator = LoadingInitiator == null ? null : $" ({LoadingInitiator})";
-                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TaskAssemblyLoaded", LoadingContext.ToString(), loadingInitiator, AssemblyName, AssemblyPath, MVID.ToString(), AppDomainDescriptor ?? DefaultAppDomainDescriptor);
+#if FEATURE_ASSEMBLYLOADCONTEXT
+                    string resourceName = "TaskAssemblyLoadedWithAssemblyLoadContext";
+#else
+                    string resourceName = "TaskAssemblyLoaded";
+#endif
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword(resourceName, LoadingContext.ToString(), loadingInitiator, AssemblyName, AssemblyPath, MVID.ToString(), AppDomainDescriptor ?? DefaultAppDomainDescriptor);
                 }
 
                 return RawMessage;
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 995cfebfbc7..d3ae3878226 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -172,6 +172,9 @@ public void Translate(ref int value)
                 value = _reader.ReadInt32();
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref uint unsignedInteger) => unsignedInteger = _reader.ReadUInt32();
+
             /// <summary>
             /// Translates an <see langword="int"/> array.
             /// </summary>
@@ -396,9 +399,9 @@ public void Translate(ref TimeSpan value)
                 value = new System.TimeSpan(ticks);
             }
 
-            // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.  
-            // However, it also does not ever need to translate BuildEventContexts, so it should be perfectly safe to 
-            // compile this method out of that assembly. 
+            // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.
+            // However, it also does not ever need to translate BuildEventContexts, so it should be perfectly safe to
+            // compile this method out of that assembly.
 #if !CLR2COMPATIBILITY
 
             /// <summary>
@@ -420,7 +423,6 @@ public void Translate(ref BuildEventContext value)
                     _reader.ReadInt32(),
                     _reader.ReadInt32());
             }
-
 #endif
 
             /// <summary>
@@ -501,12 +503,6 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                {
-                    TranslateDotNet<Exception>(ref value);
-                    return;
-                }
-
                 if (!TranslateNullable(value))
                 {
                     return;
@@ -639,7 +635,7 @@ public void TranslateDictionary<K, V>(
             }
 
             /// <summary>
-            /// Translates a dictionary of { string, T }.  
+            /// Translates a dictionary of { string, T }.
             /// </summary>
             /// <typeparam name="T">The reference type for the values</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
@@ -884,6 +880,9 @@ public void Translate(ref int value)
                 _writer.Write(value);
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref uint unsignedInteger) => _writer.Write(unsignedInteger);
+
             /// <summary>
             /// Translates an <see langword="int"/> array.
             /// </summary>
@@ -1085,9 +1084,9 @@ public void Translate(ref TimeSpan value)
                 _writer.Write(value.Ticks);
             }
 
-            // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.  
-            // However, it also does not ever need to translate BuildEventContexts, so it should be perfectly safe to 
-            // compile this method out of that assembly. 
+            // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext.
+            // However, it also does not ever need to translate BuildEventContexts, so it should be perfectly safe to
+            // compile this method out of that assembly.
 #if !CLR2COMPATIBILITY
 
             /// <summary>
@@ -1108,8 +1107,7 @@ public void Translate(ref BuildEventContext value)
                 _writer.Write(value.TargetId);
                 _writer.Write(value.TaskId);
             }
-
-#endif 
+#endif
 
             /// <summary>
             /// Translates a CultureInfo
@@ -1155,12 +1153,6 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                {
-                    TranslateDotNet<Exception>(ref value);
-                    return;
-                }
-
                 if (!TranslateNullable(value))
                 {
                     return;
@@ -1312,7 +1304,7 @@ public void TranslateDictionary<K, V>(
             }
 
             /// <summary>
-            /// Translates a dictionary of { string, T }.  
+            /// Translates a dictionary of { string, T }.
             /// </summary>
             /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
             /// <param name="dictionary">The dictionary to be translated.</param>
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 206ab7fa5a9..883bbca9d12 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This class encapsulates the default data associated with build events. 
+    /// This class encapsulates the default data associated with build events.
     /// It is intended to be extended/sub-classed.
     /// </summary>
     // WARNING: marking a type [Serializable] without implementing
@@ -124,7 +124,7 @@ protected internal DateTime RawTimestamp
         }
 
         /// <summary>
-        /// The thread that raised event.  
+        /// The thread that raised event.
         /// </summary>
         public int ThreadId => threadId;
 
@@ -260,7 +260,7 @@ internal virtual void CreateFromStream(BinaryReader reader, int version)
         [OnDeserializing]
         private void SetBuildEventContextDefaultBeforeSerialization(StreamingContext sc)
         {
-            // Don't want to create a new one here as default all the time as that would be a lot of 
+            // Don't want to create a new one here as default all the time as that would be a lot of
             // possibly useless allocations
             buildEventContext = null;
         }
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index e27b37f3f67..0622bf45896 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// Will provide location information for an event, this is especially 
+    /// Will provide location information for an event, this is especially
     /// needed in a multi processor environment
     /// </summary>
     [Serializable]
@@ -15,7 +15,7 @@ public class BuildEventContext
         #region Data
 
         /// <summary>
-        /// Node event was in 
+        /// Node event was in
         /// </summary>
         private readonly int _nodeId;
 
@@ -219,9 +219,9 @@ public override int GetHashCode()
         }
 
         /// <summary>
-        /// Compare a BuildEventContext with this BuildEventContext. 
+        /// Compare a BuildEventContext with this BuildEventContext.
         /// A build event context is compared in the following way.
-        /// 
+        ///
         /// 1. If the object references are the same the contexts are equivalent
         /// 2. If the object type is the same and the Id values in the context are the same, the contexts are equivalent
         /// </summary>
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index 23083d8cd6a..ca01f781d2f 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -304,7 +304,7 @@ public MessageImportance Importance
         public string Subcategory => subcategory;
 
         /// <summary>
-        /// Code associated with event. 
+        /// Code associated with event.
         /// </summary>
         public string Code => code;
 
@@ -314,7 +314,7 @@ public MessageImportance Importance
         public string File => file;
 
         /// <summary>
-        /// Line number of interest in associated file. 
+        /// Line number of interest in associated file.
         /// </summary>
         public int LineNumber
         {
@@ -323,7 +323,7 @@ public int LineNumber
         }
 
         /// <summary>
-        /// Column number of interest in associated file. 
+        /// Column number of interest in associated file.
         /// </summary>
         public int ColumnNumber
         {
@@ -332,12 +332,12 @@ public int ColumnNumber
         }
 
         /// <summary>
-        /// Ending line number of interest in associated file. 
+        /// Ending line number of interest in associated file.
         /// </summary>
         public int EndLineNumber => endLineNumber;
 
         /// <summary>
-        /// Ending column number of interest in associated file. 
+        /// Ending column number of interest in associated file.
         /// </summary>
         public int EndColumnNumber => endColumnNumber;
 
diff --git a/src/Framework/BuildStatusEventArgs.cs b/src/Framework/BuildStatusEventArgs.cs
index c6edef25c8a..a53b971d49b 100644
--- a/src/Framework/BuildStatusEventArgs.cs
+++ b/src/Framework/BuildStatusEventArgs.cs
@@ -5,52 +5,52 @@
 
 namespace Microsoft.Build.Framework
 {
-    /// <summary> 
+    /// <summary>
     /// Base class for build status events.  This class is meant
-    /// to be extended.  
-    /// </summary> 
-    /// <remarks> 
-    /// WARNING: marking a type [Serializable] without implementing 
-    /// ISerializable imposes a serialization contract -- it is a 
-    /// promise to never change the type's fields i.e. the type is 
-    /// immutable; adding new fields in the next version of the type 
-    /// without following certain special FX guidelines, can break both 
-    /// forward and backward compatibility 
-    /// </remarks> 
+    /// to be extended.
+    /// </summary>
+    /// <remarks>
+    /// WARNING: marking a type [Serializable] without implementing
+    /// ISerializable imposes a serialization contract -- it is a
+    /// promise to never change the type's fields i.e. the type is
+    /// immutable; adding new fields in the next version of the type
+    /// without following certain special FX guidelines, can break both
+    /// forward and backward compatibility
+    /// </remarks>
     [Serializable]
     public abstract class BuildStatusEventArgs : LazyFormattedBuildEventArgs
     {
-        /// <summary> 
-        /// Default constructor 
-        /// </summary> 
+        /// <summary>
+        /// Default constructor
+        /// </summary>
         protected BuildStatusEventArgs()
             : base()
         {
-            // do nothing 
+            // do nothing
         }
 
-        /// <summary> 
-        /// This constructor allows event data to be initialized.  
-        /// </summary> 
-        /// <param name="message">text message</param> 
-        /// <param name="helpKeyword">help keyword </param> 
-        /// <param name="senderName">name of event sender</param> 
+        /// <summary>
+        /// This constructor allows event data to be initialized.
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="senderName">name of event sender</param>
         protected BuildStatusEventArgs(
             string? message,
             string? helpKeyword,
             string? senderName)
             : this(message, helpKeyword, senderName, DateTime.UtcNow)
         {
-            // do nothing 
+            // do nothing
         }
 
 
-        /// <summary> 
+        /// <summary>
         /// This constructor allows timestamp to be set
-        /// </summary> 
-        /// <param name="message">text message</param> 
-        /// <param name="helpKeyword">help keyword </param> 
-        /// <param name="senderName">name of event sender</param> 
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="senderName">name of event sender</param>
         /// <param name="eventTimestamp">Timestamp when event was created</param>
         protected BuildStatusEventArgs(
             string? message,
@@ -62,12 +62,12 @@ protected BuildStatusEventArgs(
             // do nothing
         }
 
-        /// <summary> 
+        /// <summary>
         /// This constructor allows timestamp to be set
-        /// </summary> 
-        /// <param name="message">text message</param> 
-        /// <param name="helpKeyword">help keyword </param> 
-        /// <param name="senderName">name of event sender</param> 
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="senderName">name of event sender</param>
         /// <param name="eventTimestamp">Timestamp when event was created</param>
         /// <param name="messageArgs">Optional arguments for formatting the message string.</param>
         protected BuildStatusEventArgs(
@@ -78,7 +78,7 @@ protected BuildStatusEventArgs(
             params object[]? messageArgs)
             : base(message, helpKeyword, senderName, eventTimestamp, messageArgs)
         {
-            // do nothing 
+            // do nothing
         }
     }
 }
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 00507237987..b6479c3698e 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Diagnostics;
 using System.Linq;
 
 #nullable disable
@@ -22,18 +23,26 @@ internal enum ChangeWaveConversionState
     /// </summary>
     /// See docs here: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves.md
     /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
-    internal class ChangeWaves
+    internal static class ChangeWaves
     {
         internal static readonly Version Wave17_4 = new Version(17, 4);
         internal static readonly Version Wave17_6 = new Version(17, 6);
         internal static readonly Version Wave17_8 = new Version(17, 8);
-        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8 };
+        internal static readonly Version Wave17_10 = new Version(17, 10);
+        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8, Wave17_10 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
         /// </summary>
         internal static readonly Version EnableAllFeatures = new Version(999, 999);
 
+#if DEBUG
+        /// <summary>
+        /// True if <see cref="ResetStateForTests"/> has been called.
+        /// </summary>
+        private static bool _runningTests = false;
+#endif
+
         /// <summary>
         /// The lowest wave in the current rotation of Change Waves.
         /// </summary>
@@ -161,6 +170,10 @@ internal static bool AreFeaturesEnabled(Version wave)
         {
             ApplyChangeWave();
 
+#if DEBUG
+            Debug.Assert(_runningTests || AllWaves.Contains(wave), $"Change wave version {wave} is invalid");
+#endif
+
             return wave < _cachedWave;
         }
 
@@ -170,6 +183,9 @@ internal static bool AreFeaturesEnabled(Version wave)
         /// </summary>
         internal static void ResetStateForTests()
         {
+#if DEBUG
+            _runningTests = true;
+#endif
             _cachedWave = null;
             _state = ChangeWaveConversionState.NotConvertedYet;
         }
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
index 1c5e56d19a3..2545a39b99a 100644
--- a/src/Framework/CompatibilitySuppressions.xml
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -54,9 +54,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Framework/CriticalBuildMessageEventArgs.cs b/src/Framework/CriticalBuildMessageEventArgs.cs
index 7cac3c342f2..765e05fe857 100644
--- a/src/Framework/CriticalBuildMessageEventArgs.cs
+++ b/src/Framework/CriticalBuildMessageEventArgs.cs
@@ -107,7 +107,7 @@ public CriticalBuildMessageEventArgs(
             string senderName,
             DateTime eventTimestamp,
             params object[] messageArgs)
-            //// Force importance to High. 
+            //// Force importance to High.
             : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, MessageImportance.High, eventTimestamp, messageArgs)
         {
             // do nothing
diff --git a/src/Framework/CustomBuildEventArgs.cs b/src/Framework/CustomBuildEventArgs.cs
index 3310b398844..e85b1efb91e 100644
--- a/src/Framework/CustomBuildEventArgs.cs
+++ b/src/Framework/CustomBuildEventArgs.cs
@@ -10,17 +10,20 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for custom build events.
     /// </summary>
-    // WARNING: marking a type [Serializable] without implementing
-    // ISerializable imposes a serialization contract -- it is a
-    // promise to never change the type's fields i.e. the type is
-    // immutable; adding new fields in the next version of the type
-    // without following certain special FX guidelines, can break both
-    // forward and backward compatibility
+    /// <remarks>
+    /// <format type="text/markdown"><![CDATA[
+    /// ## Remarks
+    /// > [!CAUTION]
+    /// In .NET 8 and later and Visual Studio 17.8 and later, this type is deprecated; instead use <see cref="ExtendedCustomBuildEventArgs"/>.
+    /// For more information, see <see href="https://learn.microsoft.com/dotnet/core/compatibility/sdk/8.0/custombuildeventargs"/>
+    /// For recommended replacement, see <see href="https://learn.microsoft.com/dotnet/core/compatibility/sdk/8.0/custombuildeventargs#recommended-action" />.
+    /// ]]></format>
+    /// </remarks>
     [Serializable]
     public abstract class CustomBuildEventArgs : LazyFormattedBuildEventArgs
     {
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected CustomBuildEventArgs()
             : base()
diff --git a/src/Framework/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
index 298c740da96..1a895022929 100644
--- a/src/Framework/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -272,10 +272,7 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
             CultureInfo? externalLanguageSetting = GetExternalOverriddenUILanguage();
             if (externalLanguageSetting != null)
             {
-                if (
-                    !externalLanguageSetting.TwoLetterISOLanguageName.Equals("en", StringComparison.InvariantCultureIgnoreCase) &&
-                    CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding()
-                    )
+                if (CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
                 {
                     // Setting both encodings causes a change in the CHCP, making it so we don't need to P-Invoke CHCP ourselves.
                     Console.OutputEncoding = Encoding.UTF8;
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 271bc7d33c7..491604c7827 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -21,10 +21,13 @@ public abstract class EngineServices
         public const int Version1 = 1;
 
         /// <summary>
-        /// An explicit version of this class. Must be incremented whenever new members are added. Derived classes should override
-        /// the property to return the version actually being implemented.
+        /// Gets an explicit version of this class.
         /// </summary>
-        public virtual int Version => Version1; // Not updated since we have not shipped 17.0 yet. This comment is meant to bypass RequiredVersionBumps check in build.ps1 for PR #470646. If the changes in the file are cosmetic, change PR# in this comment to silence the build error on CI build.
+        /// <remarks>
+        /// Must be incremented whenever new members are added. Derived classes should override
+        /// the property to return the version actually being implemented.
+        /// </remarks>
+        public virtual int Version => Version1;
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
diff --git a/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs b/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs
new file mode 100644
index 00000000000..3897a1de6e6
--- /dev/null
+++ b/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs
@@ -0,0 +1,148 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Critical message events arguments including extended data for event enriching.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedCriticalBuildMessageEventArgs : CriticalBuildMessageEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event subcategory</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    public ExtendedCriticalBuildMessageEventArgs(
+        string type,
+        string? subcategory,
+        string? code,
+        string? file,
+        int lineNumber,
+        int columnNumber,
+        int endLineNumber,
+        int endColumnNumber,
+        string? message,
+        string? helpKeyword,
+        string? senderName)
+        : this(type, subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, DateTime.UtcNow)
+    {
+        // do nothing
+    }
+
+    /// <summary>
+    /// This constructor allows timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event subcategory</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">custom timestamp for the event</param>
+    public ExtendedCriticalBuildMessageEventArgs(
+        string type,
+        string? subcategory,
+        string? code,
+        string? file,
+        int lineNumber,
+        int columnNumber,
+        int endLineNumber,
+        int endColumnNumber,
+        string? message,
+        string? helpKeyword,
+        string? senderName,
+        DateTime eventTimestamp)
+        : this(type, subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp, null!)
+    {
+        // do nothing
+    }
+
+    /// <summary>
+    /// This constructor allows timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event subcategory</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">custom timestamp for the event</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedCriticalBuildMessageEventArgs(
+        string type,
+        string? subcategory,
+        string? code,
+        string? file,
+        int lineNumber,
+        int columnNumber,
+        int endLineNumber,
+        int endColumnNumber,
+        string? message,
+        string? helpKeyword,
+        string? senderName,
+        DateTime eventTimestamp,
+        params object[]? messageArgs)
+        //// Force importance to High.
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    /// <summary>
+    /// Default constructor. Used for deserialization.
+    /// </summary>
+    internal ExtendedCriticalBuildMessageEventArgs() : this("undefined")
+    {
+        // do nothing
+    }
+
+    /// <summary>
+    /// This constructor specifies only type of extended data.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    public ExtendedCriticalBuildMessageEventArgs(string type) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/IBuildEngine2.cs b/src/Framework/IBuildEngine2.cs
index 7ffd55e9844..85f414766d3 100644
--- a/src/Framework/IBuildEngine2.cs
+++ b/src/Framework/IBuildEngine2.cs
@@ -8,7 +8,7 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This interface extends IBuildEngine to provide a method allowing building 
+    /// This interface extends IBuildEngine to provide a method allowing building
     /// project files in parallel.
     /// </summary>
     public interface IBuildEngine2 : IBuildEngine
@@ -60,14 +60,14 @@ bool BuildProjectFile(
         /// <param name="projectFileNames">The project to build.</param>
         /// <param name="targetNames">The targets in the project to build (can be null).</param>
         /// <param name="globalProperties">An array of hashtables of additional global properties to apply
-        ///     to the child project (array entries can be null). 
+        ///     to the child project (array entries can be null).
         ///     The key and value in the hashtable should both be strings.</param>
         /// <param name="targetOutputsPerProject">The outputs of each specified target (can be null).</param>
         /// <param name="toolsVersion">A tools version recognized by the Engine that will be used during this build (can be null).</param>
         /// <param name="useResultsCache">If true the operation will only be run if the cache doesn't
         ///                               already contain the result. After the operation the result is
         ///                               stored in the cache </param>
-        /// <param name="unloadProjectsOnCompletion">If true the project will be unloaded once the 
+        /// <param name="unloadProjectsOnCompletion">If true the project will be unloaded once the
         ///                                         operation is completed </param>
         /// <returns>true, if build was successful</returns>
         bool BuildProjectFilesInParallel(
diff --git a/src/Framework/IBuildEngine3.cs b/src/Framework/IBuildEngine3.cs
index faa0459699d..591d49ec74e 100644
--- a/src/Framework/IBuildEngine3.cs
+++ b/src/Framework/IBuildEngine3.cs
@@ -9,7 +9,7 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This interface extends IBuildEngine to provide a method allowing building 
+    /// This interface extends IBuildEngine to provide a method allowing building
     /// project files in parallel.
     /// </summary>
     public interface IBuildEngine3 : IBuildEngine2
@@ -22,12 +22,12 @@ public interface IBuildEngine3 : IBuildEngine2
         /// <remarks>
         /// 1) it is acceptable to pass null for both <c>targetNames</c> and <c>targetOutputs</c>
         /// 2) if no targets are specified, the default targets are built
-        /// 
+        ///
         /// </remarks>
         /// <param name="projectFileNames">The project to build.</param>
         /// <param name="targetNames">The targets in the project to build (can be null).</param>
         /// <param name="globalProperties">An array of hashtables of additional global properties to apply
-        ///     to the child project (array entries can be null). 
+        ///     to the child project (array entries can be null).
         ///     The key and value in the hashtable should both be strings.</param>
         /// <param name="removeGlobalProperties">A list of global properties which should be removed.</param>
         /// <param name="toolsVersion">A tools version recognized by the Engine that will be used during this build (can be null).</param>
diff --git a/src/Framework/IBuildEngine4.cs b/src/Framework/IBuildEngine4.cs
index 650c60b9760..4440a139d61 100644
--- a/src/Framework/IBuildEngine4.cs
+++ b/src/Framework/IBuildEngine4.cs
@@ -28,7 +28,7 @@ public enum RegisteredTaskObjectLifetime
     }
 
     /// <summary>
-    /// This interface extends IBuildEngine to provide a mechanism allowing tasks to 
+    /// This interface extends IBuildEngine to provide a mechanism allowing tasks to
     /// share data between task invocations.
     /// </summary>
     public interface IBuildEngine4 : IBuildEngine3
@@ -45,9 +45,9 @@ public interface IBuildEngine4 : IBuildEngine3
         /// <remarks>
         /// <para>
         /// This method may be called by tasks which need to maintain state across task invocations,
-        /// such as to cache data which may be expensive to generate but which is known not to change during the 
+        /// such as to cache data which may be expensive to generate but which is known not to change during the
         /// build.  It is strongly recommended that <paramref name="allowEarlyCollection"/> be set to true if the
-        /// object will retain any significant amount of data, as this gives MSBuild the most flexibility to 
+        /// object will retain any significant amount of data, as this gives MSBuild the most flexibility to
         /// manage limited process memory resources.
         /// </para>
         /// <para>
diff --git a/src/Framework/IEventSource.cs b/src/Framework/IEventSource.cs
index 3c2599fceba..4ba9c258238 100644
--- a/src/Framework/IEventSource.cs
+++ b/src/Framework/IEventSource.cs
@@ -75,7 +75,7 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public delegate void AnyEventHandler(object sender, BuildEventArgs e);
 
-    /// <summary> 
+    /// <summary>
     /// This interface defines the events raised by the build engine.
     /// Loggers use this interface to subscribe to the events they
     /// are interested in receiving.
diff --git a/src/Framework/ILogger.cs b/src/Framework/ILogger.cs
index 5d999b7b08d..30973514607 100644
--- a/src/Framework/ILogger.cs
+++ b/src/Framework/ILogger.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Framework
     /// The level of detail (i.e. verbosity) of an event log is entirely controlled by the logger generating the log -- a logger
     /// will be directed to keep its verbosity at a certain level, based on user preferences, but a logger is free to choose the
     /// events it logs for each verbosity level.
-    /// 
+    ///
     /// LOGGING GUIDELINES FOR EACH VERBOSITY LEVEL:
     /// 1) Quiet -- only display a summary at the end of build
     /// 2) Minimal -- only display errors, warnings, high importance events and a build summary
@@ -22,9 +22,9 @@ namespace Microsoft.Build.Framework
     /// 4) Detailed -- display all errors, warnings, high and normal importance events, all status events, and a build summary
     /// 5) Diagnostic -- display all events, and a build summary
     /// </remarks>
-    // 
+    //
     // WARNING: VS Automation code for the Tools/Options MSBuild build verbosity setting will be broken
-    // by changes to this enum (not to mention existing MSBuild clients and vsproject code). 
+    // by changes to this enum (not to mention existing MSBuild clients and vsproject code).
     // Please make sure to talk to automation devs before changing it.
     [ComVisible(true)]
     public enum LoggerVerbosity
diff --git a/src/Framework/INodeLogger.cs b/src/Framework/INodeLogger.cs
index 4865646daf9..faf807b55cd 100644
--- a/src/Framework/INodeLogger.cs
+++ b/src/Framework/INodeLogger.cs
@@ -8,9 +8,9 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// This interface defines a "parallel aware logger" in the build system. A parallel aware logger 
+    /// This interface defines a "parallel aware logger" in the build system. A parallel aware logger
     /// will accept a cpu count and be aware that any cpu count greater than 1 means the events will
-    /// be received from the logger from each cpu as the events are logged. 
+    /// be received from the logger from each cpu as the events are logged.
     /// </summary>
     [ComVisible(true)]
     public interface INodeLogger : ILogger
diff --git a/src/Framework/IProjectElement.cs b/src/Framework/IProjectElement.cs
index d7f74708af0..1fcbbb2da5e 100644
--- a/src/Framework/IProjectElement.cs
+++ b/src/Framework/IProjectElement.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Framework
     public interface IProjectElement
     {
         /// <summary>
-        /// Gets the name of the associated element. 
+        /// Gets the name of the associated element.
         /// Useful for display in some circumstances.
         /// </summary>
         string ElementName { get; }
diff --git a/src/Framework/ITaskFactory2.cs b/src/Framework/ITaskFactory2.cs
index 14fb266c913..cd2de556f6a 100644
--- a/src/Framework/ITaskFactory2.cs
+++ b/src/Framework/ITaskFactory2.cs
@@ -9,27 +9,27 @@ namespace Microsoft.Build.Framework
 {
     /// <summary>
     /// Interface that a task factory Instance should implement if it wants to be able to
-    /// use new UsingTask parameters such as Runtime and Architecture. 
+    /// use new UsingTask parameters such as Runtime and Architecture.
     /// </summary>
     public interface ITaskFactory2 : ITaskFactory
     {
         /// <summary>
         /// Initializes this factory for instantiating tasks with a particular inline task block and a set of UsingTask parameters.  MSBuild
-        /// provides an implementation of this interface, TaskHostFactory, that uses "Runtime", with values "CLR2", "CLR4", "CurrentRuntime", 
-        /// and "*" (Any); and "Architecture", with values "x86", "x64", "CurrentArchitecture", and "*" (Any).  An implementer of ITaskFactory2 
-        /// can choose to use these pre-defined Runtime and Architecture values, or can specify new values for these parameters.  
+        /// provides an implementation of this interface, TaskHostFactory, that uses "Runtime", with values "CLR2", "CLR4", "CurrentRuntime",
+        /// and "*" (Any); and "Architecture", with values "x86", "x64", "CurrentArchitecture", and "*" (Any).  An implementer of ITaskFactory2
+        /// can choose to use these pre-defined Runtime and Architecture values, or can specify new values for these parameters.
         /// </summary>
         /// <param name="taskName">Name of the task.</param>
-        /// <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks, 
-        /// such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This 
+        /// <param name="factoryIdentityParameters">Special parameters that the task factory can use to modify how it executes tasks,
+        /// such as Runtime and Architecture.  The key is the name of the parameter and the value is the parameter's value. This
         /// is the set of parameters that was set on the UsingTask using e.g. the UsingTask Runtime and Architecture parameters.</param>
         /// <param name="parameterGroup">The parameter group.</param>
         /// <param name="taskBody">The task body.</param>
         /// <param name="taskFactoryLoggingHost">The task factory logging host.</param>
         /// <returns>A value indicating whether initialization was successful.</returns>
         /// <remarks>
-        /// <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the 
-        /// factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2, 
+        /// <para>MSBuild engine will call this to initialize the factory. This should initialize the factory enough so that the
+        /// factory can be asked whether or not task names can be created by the factory.  If a task factory implements ITaskFactory2,
         /// this Initialize method will be called in place of ITaskFactory.Initialize.</para>
         /// <para>
         /// The taskFactoryLoggingHost will log messages in the context of the target where the task is first used.
@@ -38,22 +38,22 @@ public interface ITaskFactory2 : ITaskFactory
         bool Initialize(string taskName, IDictionary<string, string> factoryIdentityParameters, IDictionary<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
 
         /// <summary>
-        /// Create an instance of the task to be used, with an optional set of "special" parameters set on the individual task invocation using 
-        /// the MSBuildRuntime and MSBuildArchitecture default task parameters.  MSBuild provides an implementation of this interface, 
-        /// TaskHostFactory, that uses "MSBuildRuntime", with values "CLR2", "CLR4", "CurrentRuntime", and "*" (Any); and "MSBuildArchitecture", 
-        /// with values "x86", "x64", "CurrentArchitecture", and "*" (Any).  An implementer of ITaskFactory2 can choose to use these pre-defined 
-        /// MSBuildRuntime and MSBuildArchitecture values, or can specify new values for these parameters.  
+        /// Create an instance of the task to be used, with an optional set of "special" parameters set on the individual task invocation using
+        /// the MSBuildRuntime and MSBuildArchitecture default task parameters.  MSBuild provides an implementation of this interface,
+        /// TaskHostFactory, that uses "MSBuildRuntime", with values "CLR2", "CLR4", "CurrentRuntime", and "*" (Any); and "MSBuildArchitecture",
+        /// with values "x86", "x64", "CurrentArchitecture", and "*" (Any).  An implementer of ITaskFactory2 can choose to use these pre-defined
+        /// MSBuildRuntime and MSBuildArchitecture values, or can specify new values for these parameters.
         /// </summary>
         /// <param name="taskFactoryLoggingHost">
         /// The task factory logging host will log messages in the context of the task.
         /// </param>
         /// <param name="taskIdentityParameters">
-        /// Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.  
-        /// The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was 
-        /// set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.  
+        /// Special parameters that the task factory can use to modify how it executes tasks, such as Runtime and Architecture.
+        /// The key is the name of the parameter and the value is the parameter's value.  This is the set of parameters that was
+        /// set to the task invocation itself, via e.g. the special MSBuildRuntime and MSBuildArchitecture parameters.
         /// </param>
         /// <remarks>
-        /// If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.  
+        /// If a task factory implements ITaskFactory2, MSBuild will call this method instead of ITaskFactory.CreateTask.
         /// </remarks>
         /// <returns>
         /// The generated task, or <c>null</c> if the task failed to be created.
diff --git a/src/Framework/ITaskHost.cs b/src/Framework/ITaskHost.cs
index 687d2c3229f..9ea5c140d18 100644
--- a/src/Framework/ITaskHost.cs
+++ b/src/Framework/ITaskHost.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// This empty interface is used to pass host objects from an IDE to individual
     /// tasks.  Depending on the task itself and what kinds parameters and functionality
-    /// it exposes, the task should define its own interface that inherits from this one, 
+    /// it exposes, the task should define its own interface that inherits from this one,
     /// and then use that interface to communicate with the host.
     /// </summary>
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
diff --git a/src/Framework/ITaskItem2.cs b/src/Framework/ITaskItem2.cs
index d9095e42038..f245353a19b 100644
--- a/src/Framework/ITaskItem2.cs
+++ b/src/Framework/ITaskItem2.cs
@@ -40,7 +40,7 @@ string EvaluatedIncludeEscaped
 
         /// <summary>
         /// Allows a piece of custom metadata to be set on the item.  Assumes that the value passed
-        /// in is unescaped, and escapes the value as necessary in order to maintain its value. 
+        /// in is unescaped, and escapes the value as necessary in order to maintain its value.
         /// </summary>
         /// <remarks>
         /// Taking the opportunity to fix the property name, although this doesn't
@@ -50,7 +50,7 @@ string EvaluatedIncludeEscaped
 
         /// <summary>
         /// ITaskItem2 implementation which returns a clone of the metadata on this object.
-        /// Values returned are in their original escaped form. 
+        /// Values returned are in their original escaped form.
         /// </summary>
         /// <returns>The cloned metadata, with values' escaping preserved.</returns>
         IDictionary CloneCustomMetadataEscaped();
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index 930cc45f6b2..edb6e96dfc7 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -48,7 +48,7 @@ internal enum TranslationDirection
     }
 
     /// <summary>
-    /// This interface represents an object which aids objects in serializing and 
+    /// This interface represents an object which aids objects in serializing and
     /// deserializing INodePackets.
     /// </summary>
     /// <remarks>
@@ -78,7 +78,7 @@ TranslationDirection Mode
         /// Returns the binary reader.
         /// </summary>
         /// <remarks>
-        /// This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the 
+        /// This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the
         /// translating object to know the direction of translation.  Use one of the Translate methods instead.
         /// </remarks>
         BinaryReader Reader
@@ -90,7 +90,7 @@ BinaryReader Reader
         /// Returns the binary writer.
         /// </summary>
         /// <remarks>
-        /// This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the 
+        /// This should ONLY be used when absolutely necessary for translation.  It is generally unnecessary for the
         /// translating object to know the direction of translation.  Use one of the Translate methods instead.
         /// </remarks>
         BinaryWriter Writer
@@ -134,6 +134,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref int value);
 
+        /// <summary>
+        /// Translates an unsigned integer.
+        /// </summary>
+        /// <param name="unsignedInteger">The unsigned integer to translate.</param>
+        void Translate(ref uint unsignedInteger);
+
         /// <summary>
         /// Translates an <see langword="int"/> array.
         /// </summary>
@@ -216,11 +222,11 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref TimeSpan value);
 
-        // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext, 
-        // which is what current implementations of this method use.  However, it also does not ever need to translate 
+        // MSBuildTaskHost is based on CLR 3.5, which does not have the 6-parameter constructor for BuildEventContext,
+        // which is what current implementations of this method use.  However, it also does not ever need to translate
         // BuildEventContexts, so it should be perfectly safe to compile this method out of that assembly. I am compiling
         // the method out of the interface as well, instead of just making the method empty, so that if we ever do need
-        // to translate BuildEventContexts from the CLR 3.5 task host, it will become immediately obvious, rather than 
+        // to translate BuildEventContexts from the CLR 3.5 task host, it will become immediately obvious, rather than
         // failing or misbehaving silently.
 #if !CLR2COMPATIBILITY
 
@@ -233,8 +239,7 @@ BinaryWriter Writer
         /// </remarks>
         /// <param name="value">The context to be translated.</param>
         void Translate(ref BuildEventContext value);
-
-#endif 
+#endif
 
         /// <summary>
         /// Translates an enumeration.
@@ -321,7 +326,7 @@ void TranslateArray<T>(ref T[] array)
         void TranslateDictionary<K, V>(ref IDictionary<K, V> dictionary, ObjectTranslator<K> keyTranslator, ObjectTranslator<V> valueTranslator, NodePacketCollectionCreator<IDictionary<K, V>> dictionaryCreator);
 
         /// <summary>
-        /// Translates a dictionary of { string, T }.  
+        /// Translates a dictionary of { string, T }.
         /// </summary>
         /// <typeparam name="T">The reference type for the values, which implements INodePacketTranslatable.</typeparam>
         /// <param name="dictionary">The dictionary to be translated.</param>
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 4b4dc6493a6..06c3b333aff 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -156,7 +156,7 @@ internal override void CreateFromStream(BinaryReader reader, Int32 version)
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -173,12 +173,12 @@ private static string FormatString(string unformatted, params object[] args)
             if ((args?.Length > 0))
             {
 #if DEBUG
-                // If you accidentally pass some random type in that can't be converted to a string, 
+                // If you accidentally pass some random type in that can't be converted to a string,
                 // FormatResourceString calls ToString() which returns the full name of the type!
                 foreach (object param in args)
                 {
                     // Check against a list of types that we know have
-                    // overridden ToString() usefully. If you want to pass 
+                    // overridden ToString() usefully. If you want to pass
                     // another one, add it here.
                     if (param != null && param.ToString() == param.GetType().FullName)
                     {
@@ -198,7 +198,7 @@ private static string FormatString(string unformatted, params object[] args)
                     // We don't have resources in this assembly, and we generally log stack for task failures so they can be fixed by the owner
                     // However, we don't want to crash the logger and stop the build.
                     // Error will look like this (it's OK to not localize subcategory). It's not too bad, although there's no file.
-                    // 
+                    //
                     //       Task "Crash"
                     //          (16,14):  error : "This message logged from a task {1} has too few formatting parameters."
                     //             at System.Text.StringBuilder.AppendFormat(IFormatProvider provider, String format, Object[] args)
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index 05e457d90ee..19d0eab57ac 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Framework
 {
     /// <summary>
     /// Exception that should be thrown by a logger when it cannot continue.
-    /// Allows a logger to force the build to stop in an explicit way, when, for example, it 
+    /// Allows a logger to force the build to stop in an explicit way, when, for example, it
     /// receives invalid parameters, or cannot write to disk.
     /// </summary>
     // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
@@ -77,7 +77,7 @@ public LoggerException(string message, Exception innerException, string errorCod
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info">Serialization info</param>
diff --git a/src/MSBuild/TerminalLogger/AnsiCodes.cs b/src/Framework/Logging/AnsiCodes.cs
similarity index 90%
rename from src/MSBuild/TerminalLogger/AnsiCodes.cs
rename to src/Framework/Logging/AnsiCodes.cs
index 016260d55f8..8466220026b 100644
--- a/src/MSBuild/TerminalLogger/AnsiCodes.cs
+++ b/src/Framework/Logging/AnsiCodes.cs
@@ -141,4 +141,13 @@ public static string MakeBold(string? s)
 
         return $"{CSI}{SetBold}{s}{SetDefaultColor}";
     }
+
+    public static string MoveCursorBackward(int count) => $"{CSI}{count}{MoveBackward}";
+
+    /// <summary>
+    /// Moves cursor to the specified column, or the rightmost column if <paramref name="column"/> is greater than the width of the terminal.
+    /// </summary>
+    /// <param name="column">Column index.</param>
+    /// <returns>Control codes to set the desired position.</returns>
+    public static string SetCursorHorizontal(int column) => $"{CSI}{column}G";
 }
diff --git a/src/MSBuild/TerminalLogger/TerminalColor.cs b/src/Framework/Logging/TerminalColor.cs
similarity index 85%
rename from src/MSBuild/TerminalLogger/TerminalColor.cs
rename to src/Framework/Logging/TerminalColor.cs
index 683b4d683b8..55b63e915ac 100644
--- a/src/MSBuild/TerminalLogger/TerminalColor.cs
+++ b/src/Framework/Logging/TerminalColor.cs
@@ -4,7 +4,7 @@
 namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
-/// Enumerates the text colors supported by <see cref="ITerminal"/>.
+/// Enumerates the text colors supported by VT100 terminal.
 /// </summary>
 internal enum TerminalColor
 {
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 29e9e67abfb..f96d17a98e3 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -3,8 +3,6 @@
 
 using System.Diagnostics.Tracing;
 
-#nullable disable
-
 namespace Microsoft.Build.Eventing
 {
     /// <summary>
@@ -242,7 +240,7 @@ public void RarOverallStart()
             WriteEvent(27);
         }
 
-        [Event(28, Keywords = Keywords.All | Keywords.PerformanceLog)]
+        [Event(28, Keywords = Keywords.All | Keywords.PerformanceLog, Version = 1)]
         public void RarOverallStop(int assembliesCount, int assemblyFilesCount, int resolvedFilesCount, int resolvedDependencyFilesCount, int copyLocalFilesCount, bool findDependencies)
         {
             WriteEvent(28, assembliesCount, assemblyFilesCount, resolvedFilesCount, resolvedDependencyFilesCount, copyLocalFilesCount, findDependencies);
@@ -661,6 +659,18 @@ public void MSBuildServerBuildStop(string commandLine, int countOfConsoleMessage
         {
             WriteEvent(90, commandLine, countOfConsoleMessages, sumSizeOfConsoleMessages, clientExitType, serverExitType);
         }
+
+        [Event(91, Keywords = Keywords.All)]
+        public void ProjectCacheHandleBuildResultStart(string pluginTypeName, string projectPath, string targets)
+        {
+            WriteEvent(91, pluginTypeName, projectPath, targets);
+        }
+
+        [Event(92, Keywords = Keywords.All)]
+        public void ProjectCacheHandleBuildResultStop(string pluginTypeName, string projectPath, string targets)
+        {
+            WriteEvent(92, pluginTypeName, projectPath, targets);
+        }
         #endregion
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 724e1a38496..1abc2b39272 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -15,14 +15,10 @@
     <PackageReference Include="Microsoft.CodeAnalysis.Collections" PrivateAssets="all" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <PackageReference Include="System.Security.Permissions" />
-  </ItemGroup>
-
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- Promote CompilerServices.Unsafe from the old version we get from System.Memory on net472. -->
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
-    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
+    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
     <Reference Include="System.Xaml" />
   </ItemGroup>
 
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index e31b42aa0e4..b1cb2b0d7b2 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -214,7 +214,7 @@ internal enum ProcessorArchitectures
         // 32-bit ARMv6
         ARMV6,
 
-        // PowerPC 64-bit (little-endian) 
+        // PowerPC 64-bit (little-endian)
         PPC64LE,
 
         // Who knows
@@ -1307,7 +1307,7 @@ internal static int GetParentProcessId(int processId)
                 // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
                 // and could be again when FileUtilities moves to Framework
 
-                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, FileAccess.Read);
+                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, System.IO.FileAccess.Read);
                 using StreamReader r = new(fileStream);
 
                 line = r.ReadLine();
@@ -1539,7 +1539,7 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
             // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
             acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
             // It wasn't redirected as tested above so we assume output is screen/console
-            outputIsScreen = true; 
+            outputIsScreen = true;
         }
         return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
     }
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index 9f8f95ee9a6..b4ce0636725 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.Framework.Profiler
     /// Evaluation main phases used by the profiler
     /// </summary>
     /// <remarks>
-    /// Order matters since the profiler pretty printer orders profiled items from top to bottom using 
+    /// Order matters since the profiler pretty printer orders profiled items from top to bottom using
     /// the pass they belong to
     /// </remarks>
     public enum EvaluationPass : byte
diff --git a/src/Framework/ProjectFinishedEventArgs.cs b/src/Framework/ProjectFinishedEventArgs.cs
index 75e3fda981e..9308f830c2f 100644
--- a/src/Framework/ProjectFinishedEventArgs.cs
+++ b/src/Framework/ProjectFinishedEventArgs.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Framework
     public class ProjectFinishedEventArgs : BuildStatusEventArgs
     {
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected ProjectFinishedEventArgs()
             : base()
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index eba6c9ac5ab..cc9d14af45a 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -31,7 +31,7 @@ public class ProjectStartedEventArgs : BuildStatusEventArgs
         #endregion
 
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected ProjectStartedEventArgs()
             : base()
@@ -319,8 +319,8 @@ public IEnumerable? Items
                 // the central logger in the multi-proc case.  No one uses this though, so it's probably no big deal.  In
                 // the new OM, this list of items could come directly from the BuildRequestConfiguration, which has access
                 // to the loaded project.  For distributed loggers in the multi-proc case and all loggers in the single-proc
-                // case, this access is to the live list.  For the central logger in the multi-proc case, the main node 
-                // has likely not loaded this project, and therefore the live items would not be available to them, which is 
+                // case, this access is to the live list.  For the central logger in the multi-proc case, the main node
+                // has likely not loaded this project, and therefore the live items would not be available to them, which is
                 // the same as the current functionality.
                 return items;
             }
@@ -357,9 +357,9 @@ internal override void WriteToStream(BinaryWriter writer)
             // TargetNames cannot be null as per the constructor
             writer.Write(targetNames!);
 
-            // If no properties were added to the property list 
+            // If no properties were added to the property list
             // then we have nothing to create when it is deserialized
-            // This can happen if properties is null or if none of the 
+            // This can happen if properties is null or if none of the
             // five properties were found in the property object.
             if (properties == null)
             {
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 2ed1a2a539d..f0d1f5e83d7 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -13,7 +13,7 @@
 #endif
 
 #if FEATURE_SECURITY_PERMISSIONS
-// A combination of RequestMinimum and RequestOptional causes the permissions granted to 
+// A combination of RequestMinimum and RequestOptional causes the permissions granted to
 // the assembly to only be the permission requested (like a PermitOnly). More generally
 // the equation for the PermissionSet granted at load time is:
 //
@@ -25,7 +25,7 @@
 //        ReqOpt -- the permissions that RequestOptional is specified for.
 //        ReqRefuse -- the permissions that Request refuse is specified for.
 //
-// Note that if ReqOpt is the empty set, then it is consider to be "FullTrust" and this 
+// Note that if ReqOpt is the empty set, then it is consider to be "FullTrust" and this
 // equation becomes:
 //
 //        Granted = MaxGrant - ReqRefuse
@@ -55,15 +55,15 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
-// this assembly.  We should specify this explicitly, as opposed to letting 
+// this assembly.  We should specify this explicitly, as opposed to letting
 // tlbexp just pick whatever it wants.
 [assembly: GuidAttribute("D8A9BA71-4724-481d-9CA7-0DA23A1D615C")]
 
 #if FEATURE_XAML_TYPES
 [assembly: XmlnsDefinition("http://schemas.microsoft.com/build/2009/properties", "Microsoft.Build.Framework.XamlTypes")]
 #endif
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: NeutralResourcesLanguage("en")]
diff --git a/src/Framework/RequiredRuntimeAttribute.cs b/src/Framework/RequiredRuntimeAttribute.cs
index ba6b8000437..6cd509b6cbb 100644
--- a/src/Framework/RequiredRuntimeAttribute.cs
+++ b/src/Framework/RequiredRuntimeAttribute.cs
@@ -8,17 +8,17 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    /// When marked with the RequiredRuntimeAttribute, a task indicates that it has stricter 
-    /// runtime requirements than a regular task - this tells MSBuild that it will need to potentially 
+    /// When marked with the RequiredRuntimeAttribute, a task indicates that it has stricter
+    /// runtime requirements than a regular task - this tells MSBuild that it will need to potentially
     /// launch a separate process for that task if the current runtime does not match the version requirement.
     /// This attribute is currently non-functional since there is only one version of the CLR that is
-    /// capable of running MSBuild v2.0 or v3.5 - the runtime v2.0 
+    /// capable of running MSBuild v2.0 or v3.5 - the runtime v2.0
     /// </summary>
     [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
     public sealed class RequiredRuntimeAttribute : Attribute
     {
         /// <summary>
-        /// Constructor taking a version, such as "v2.0". 
+        /// Constructor taking a version, such as "v2.0".
         /// </summary>
         public RequiredRuntimeAttribute(string runtimeVersion)
         {
diff --git a/src/Framework/ReuseableStringBuilder.cs b/src/Framework/ReuseableStringBuilder.cs
index 264daffacd0..151732773cf 100644
--- a/src/Framework/ReuseableStringBuilder.cs
+++ b/src/Framework/ReuseableStringBuilder.cs
@@ -245,7 +245,7 @@ private static class ReuseableStringBuilderFactory
 
             /// <summary>
             /// Obtains a string builder which may or may not already
-            /// have been used. 
+            /// have been used.
             /// Never returns null.
             /// </summary>
             internal static StringBuilder Get(int capacity)
@@ -310,7 +310,7 @@ internal static void Release(ReuseableStringBuilder returning)
                 //
                 // If some code has a bug and forgets to return their builder
                 // (or we refuse it here because it's too big) the next user will
-                // get given a new one, and then return it soon after. 
+                // get given a new one, and then return it soon after.
                 // So the shared builder will be "replaced".
                 if (returningBuilder.Capacity > MaxBuilderSizeCapacity)
                 {
diff --git a/src/Framework/Sdk/SdkResolver.cs b/src/Framework/Sdk/SdkResolver.cs
index 7c0a662b2fc..939be3a297e 100644
--- a/src/Framework/Sdk/SdkResolver.cs
+++ b/src/Framework/Sdk/SdkResolver.cs
@@ -31,11 +31,11 @@ public abstract class SdkResolver
         /// An <see cref="SdkResult" /> containing the resolved SDKs or associated error / reason
         /// the SDK could not be resolved.  Return <see langword="null"/> if the resolver is not
         /// applicable for a particular <see cref="SdkReference"/>.
-        /// </returns>   
+        /// </returns>
         /// <remarks>
         ///  Note: You must use <see cref="SdkResultFactory"/> to return a result.
         ///  </remarks>
-        /// 
+        ///
         public abstract SdkResult Resolve(SdkReference sdkReference,
                                           SdkResolverContext resolverContext,
                                           SdkResultFactory factory);
diff --git a/src/Framework/Sdk/SdkResolverContext.cs b/src/Framework/Sdk/SdkResolverContext.cs
index 17d39ee584b..1f8c0a92810 100644
--- a/src/Framework/Sdk/SdkResolverContext.cs
+++ b/src/Framework/Sdk/SdkResolverContext.cs
@@ -43,7 +43,7 @@ public abstract class SdkResolverContext
         /// <remarks>
         ///    <format type="text/markdown"><![CDATA[
         /// ## Remarks
-        ///     
+        ///
         /// File version is informational and not equal to the assembly version.
         /// ]]></format>
         /// </remarks>
diff --git a/src/Framework/Sdk/SdkResult.cs b/src/Framework/Sdk/SdkResult.cs
index a3b354827a5..668276efc9f 100644
--- a/src/Framework/Sdk/SdkResult.cs
+++ b/src/Framework/Sdk/SdkResult.cs
@@ -35,7 +35,7 @@ public abstract class SdkResult
 
         /// <summary>
         ///     Resolved path to the SDK.
-        /// 
+        ///
         ///     Null if <see cref="Success"/> == false
         /// </summary>
         public virtual string Path { get => _path; protected set => _path = value; }
@@ -43,7 +43,7 @@ public abstract class SdkResult
         /// <summary>
         ///     Resolved version of the SDK.
         ///     Can be null or empty if the resolver did not provide a version (e.g. a path based resolver)
-        /// 
+        ///
         ///     Null if <see cref="Success"/> == false
         /// </summary>
         public virtual string Version { get => _version; protected set => _version = value; }
diff --git a/src/Framework/TargetFinishedEventArgs.cs b/src/Framework/TargetFinishedEventArgs.cs
index 5909897d5eb..454d2ce24cc 100644
--- a/src/Framework/TargetFinishedEventArgs.cs
+++ b/src/Framework/TargetFinishedEventArgs.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Framework
     public class TargetFinishedEventArgs : BuildStatusEventArgs
     {
         /// <summary>
-        /// Default constructor 
+        /// Default constructor
         /// </summary>
         protected TargetFinishedEventArgs()
             : base()
diff --git a/src/Framework/TargetStartedEventArgs.cs b/src/Framework/TargetStartedEventArgs.cs
index 27275a91205..22f162a6392 100644
--- a/src/Framework/TargetStartedEventArgs.cs
+++ b/src/Framework/TargetStartedEventArgs.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Framework
     // promise to never change the type's fields i.e. the type is
     // immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both
-    // forward and backward compatibility    
+    // forward and backward compatibility
     [Serializable]
     public class TargetStartedEventArgs : BuildStatusEventArgs
     {
@@ -158,7 +158,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         public string ParentTarget => parentTarget;
 
         /// <summary>
-        /// Project file associated with event.   
+        /// Project file associated with event.
         /// </summary>
         public string ProjectFile => projectFile;
 
diff --git a/src/Framework/TaskFinishedEventArgs.cs b/src/Framework/TaskFinishedEventArgs.cs
index f1d88eb301e..4713316748d 100644
--- a/src/Framework/TaskFinishedEventArgs.cs
+++ b/src/Framework/TaskFinishedEventArgs.cs
@@ -38,7 +38,7 @@ protected TaskFinishedEventArgs()
         /// <param name="helpKeyword">help keyword </param>
         /// <param name="projectFile">project file</param>
         /// <param name="taskFile">file in which the task is defined</param>
-        /// <param name="taskName">task name</param> 
+        /// <param name="taskName">task name</param>
         /// <param name="succeeded">true indicates task succeed</param>
         public TaskFinishedEventArgs(
             string message,
@@ -59,7 +59,7 @@ public TaskFinishedEventArgs(
         /// <param name="helpKeyword">help keyword </param>
         /// <param name="projectFile">project file</param>
         /// <param name="taskFile">file in which the task is defined</param>
-        /// <param name="taskName">task name</param> 
+        /// <param name="taskName">task name</param>
         /// <param name="succeeded">true indicates task succeed</param>
         /// <param name="eventTimestamp">Timestamp when event was created</param>
         public TaskFinishedEventArgs(
@@ -127,12 +127,12 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         public bool Succeeded => succeeded;
 
         /// <summary>
-        /// Project file associated with event.   
+        /// Project file associated with event.
         /// </summary>
         public string ProjectFile => projectFile;
 
         /// <summary>
-        /// MSBuild file where this task was defined.   
+        /// MSBuild file where this task was defined.
         /// </summary>
         public string TaskFile => taskFile;
 
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index d8d17ed4534..bdf19fa080a 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -116,12 +116,12 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         public string TaskName => taskName;
 
         /// <summary>
-        /// Project file associated with event.   
+        /// Project file associated with event.
         /// </summary>
         public string ProjectFile => projectFile;
 
         /// <summary>
-        /// MSBuild file where this task was defined.   
+        /// MSBuild file where this task was defined.
         /// </summary>
         public string TaskFile => taskFile;
 
diff --git a/src/Framework/Telemetry/BuildTelemetry.cs b/src/Framework/Telemetry/BuildTelemetry.cs
index 9515a2e185e..7e2e0c6b514 100644
--- a/src/Framework/Telemetry/BuildTelemetry.cs
+++ b/src/Framework/Telemetry/BuildTelemetry.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Globalization;
 
 namespace Microsoft.Build.Framework.Telemetry
@@ -84,62 +85,67 @@ internal class BuildTelemetry : TelemetryBase
         /// </summary>
         public string? FrameworkName { get; set; }
 
-        public override void UpdateEventProperties()
+        public override IDictionary<string, string> GetProperties()
         {
+            var properties = new Dictionary<string, string>();
+
+            // populate property values
             if (DisplayVersion != null)
             {
-                Properties["BuildEngineDisplayVersion"] = DisplayVersion;
+                properties["BuildEngineDisplayVersion"] = DisplayVersion;
             }
 
             if (StartAt.HasValue && FinishedAt.HasValue)
             {
-                Properties["BuildDurationInMilliseconds"] = (FinishedAt.Value - StartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+                properties["BuildDurationInMilliseconds"] = (FinishedAt.Value - StartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
             }
 
             if (InnerStartAt.HasValue && FinishedAt.HasValue)
             {
-                Properties["InnerBuildDurationInMilliseconds"] = (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+                properties["InnerBuildDurationInMilliseconds"] = (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
             }
 
             if (FrameworkName != null)
             {
-                Properties["BuildEngineFrameworkName"] = FrameworkName;
+                properties["BuildEngineFrameworkName"] = FrameworkName;
             }
 
             if (Host != null)
             {
-                Properties["BuildEngineHost"] = Host;
+                properties["BuildEngineHost"] = Host;
             }
 
             if (InitialServerState != null)
             {
-                Properties["InitialMSBuildServerState"] = InitialServerState;
+                properties["InitialMSBuildServerState"] = InitialServerState;
             }
 
             if (Project != null)
             {
-                Properties["ProjectPath"] = Project;
+                properties["ProjectPath"] = Project;
             }
 
             if (ServerFallbackReason != null)
             {
-                Properties["ServerFallbackReason"] = ServerFallbackReason;
+                properties["ServerFallbackReason"] = ServerFallbackReason;
             }
 
             if (Success.HasValue)
             {
-                Properties["BuildSuccess"] = Success.HasValue.ToString(CultureInfo.InvariantCulture);
+                properties["BuildSuccess"] = Success.HasValue.ToString(CultureInfo.InvariantCulture);
             }
 
             if (Target != null)
             {
-                Properties["BuildTarget"] = Target;
+                properties["BuildTarget"] = Target;
             }
 
             if (Version != null)
             {
-                Properties["BuildEngineVersion"] = Version.ToString();
+                properties["BuildEngineVersion"] = Version.ToString();
             }
+
+            return properties;
         }
     }
 }
diff --git a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
index 5281c43b9d2..493a945a526 100644
--- a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
+++ b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Globalization;
 
 namespace Microsoft.Build.Framework.Telemetry;
@@ -97,54 +98,59 @@ internal class LoggingConfigurationTelemetry : TelemetryBase
     /// </summary>
     public bool BinaryLoggerUsedDefaultName { get; set; }
 
-    public override void UpdateEventProperties()
+    public override IDictionary<string, string> GetProperties()
     {
-        Properties["TerminalLogger"] = TerminalLogger.ToString(CultureInfo.InvariantCulture);
+        var properties = new Dictionary<string, string>();
+
+        // populate property values
+        properties["TerminalLogger"] = TerminalLogger.ToString(CultureInfo.InvariantCulture);
 
         if (TerminalLoggerUserIntent != null)
         {
-            Properties["TerminalLoggerUserIntent"] = TerminalLoggerUserIntent;
+            properties["TerminalLoggerUserIntent"] = TerminalLoggerUserIntent;
         }
 
         if (TerminalLoggerUserIntentSource != null)
         {
-            Properties["TerminalLoggerUserIntentSource"] = TerminalLoggerUserIntentSource;
+            properties["TerminalLoggerUserIntentSource"] = TerminalLoggerUserIntentSource;
         }
 
         if (TerminalLoggerDefault != null)
         {
-            Properties["TerminalLoggerDefault"] = TerminalLoggerDefault;
+            properties["TerminalLoggerDefault"] = TerminalLoggerDefault;
         }
 
         if (TerminalLoggerDefaultSource != null)
         {
-            Properties["TerminalLoggerDefaultSource"] = TerminalLoggerDefaultSource;
+            properties["TerminalLoggerDefaultSource"] = TerminalLoggerDefaultSource;
         }
 
-        Properties["ConsoleLogger"] = ConsoleLogger.ToString(CultureInfo.InvariantCulture);
+        properties["ConsoleLogger"] = ConsoleLogger.ToString(CultureInfo.InvariantCulture);
         if (ConsoleLoggerType != null)
         {
-            Properties["ConsoleLoggerType"] = ConsoleLoggerType;
+            properties["ConsoleLoggerType"] = ConsoleLoggerType;
         }
 
         if (ConsoleLoggerVerbosity != null)
         {
-            Properties["ConsoleLoggerVerbosity"] = ConsoleLoggerVerbosity;
+            properties["ConsoleLoggerVerbosity"] = ConsoleLoggerVerbosity;
         }
 
-        Properties["FileLogger"] = FileLogger.ToString(CultureInfo.InvariantCulture);
+        properties["FileLogger"] = FileLogger.ToString(CultureInfo.InvariantCulture);
         if (FileLoggerType != null)
         {
-            Properties["FileLoggerType"] = FileLoggerType;
-            Properties["FileLoggersCount"] = FileLoggersCount.ToString(CultureInfo.InvariantCulture);
+            properties["FileLoggerType"] = FileLoggerType;
+            properties["FileLoggersCount"] = FileLoggersCount.ToString(CultureInfo.InvariantCulture);
         }
 
         if (FileLoggerVerbosity != null)
         {
-            Properties["FileLoggerVerbosity"] = FileLoggerVerbosity;
+            properties["FileLoggerVerbosity"] = FileLoggerVerbosity;
         }
 
-        Properties["BinaryLogger"] = BinaryLogger.ToString(CultureInfo.InvariantCulture);
-        Properties["BinaryLoggerUsedDefaultName"] = BinaryLoggerUsedDefaultName.ToString(CultureInfo.InvariantCulture);
+        properties["BinaryLogger"] = BinaryLogger.ToString(CultureInfo.InvariantCulture);
+        properties["BinaryLoggerUsedDefaultName"] = BinaryLoggerUsedDefaultName.ToString(CultureInfo.InvariantCulture);
+
+        return properties;
     }
 }
diff --git a/src/Framework/Telemetry/TelemetryBase.cs b/src/Framework/Telemetry/TelemetryBase.cs
index d2475146c5b..9084c330488 100644
--- a/src/Framework/Telemetry/TelemetryBase.cs
+++ b/src/Framework/Telemetry/TelemetryBase.cs
@@ -13,12 +13,7 @@ internal abstract class TelemetryBase
     public abstract string EventName { get; }
 
     /// <summary>
-    /// Gets or sets a list of properties associated with the event.
+    /// Fetches all derived type members wrapped in Dictionary which will be used to build <see cref="TelemetryEventArgs"/>.
     /// </summary>
-    public IDictionary<string, string> Properties { get; set; } = new Dictionary<string, string>();
-
-    /// <summary>
-    /// Translate all derived type members into properties which will be used to build <see cref="TelemetryEventArgs"/>.
-    /// </summary>
-    public abstract void UpdateEventProperties();
+    public abstract IDictionary<string, string> GetProperties();
 }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 9be74ea1bc8..daf68c5c7dc 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -188,6 +188,11 @@ internal class EscapeHatches
         /// </summary>
         public readonly bool AlwaysDoImmutableFilesUpToDateCheck = Environment.GetEnvironmentVariable("MSBUILDDONOTCACHEMODIFICATIONTIME") == "1";
 
+        /// <summary>
+        /// When copying over an existing file, copy directly into the existing file rather than deleting and recreating.
+        /// </summary>
+        public readonly bool CopyWithoutDelete = Environment.GetEnvironmentVariable("MSBUILDCOPYWITHOUTDELETE") == "1";
+
         /// <summary>
         /// Emit events for project imports.
         /// </summary>
@@ -387,7 +392,7 @@ public bool EnableWarningOnCustomBuildEvent
 #if RUNTIME_TYPE_NETCORE
                     return true;
 #else
-                    return false;
+                    return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10);
 #endif
                 }
 
@@ -395,6 +400,35 @@ public bool EnableWarningOnCustomBuildEvent
             }
         }
 
+        public bool UnquoteTargetSwitchParameters
+        {
+            get
+            {
+                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10);
+            }
+        }
+
+        private bool? _isBinaryFormatterSerializationAllowed;
+        public bool IsBinaryFormatterSerializationAllowed
+        {
+            get
+            {
+                if (!_isBinaryFormatterSerializationAllowed.HasValue)
+                {
+#if RUNTIME_TYPE_NETCORE
+                    AppContext.TryGetSwitch("System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization",
+                        out bool enabled);
+                    _isBinaryFormatterSerializationAllowed = enabled;
+#else
+                    _isBinaryFormatterSerializationAllowed = true;
+#endif
+                }
+
+                return _isBinaryFormatterSerializationAllowed.Value;
+            }
+        }
+
+
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
             var value = Environment.GetEnvironmentVariable(environmentVariable);
@@ -517,10 +551,10 @@ internal static void ThrowInternalError(string message, params object[] args)
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="unformatted">The string to format.</param>
@@ -537,7 +571,7 @@ internal static string FormatString(string unformatted, params object[] args)
             if ((args?.Length > 0))
             {
 #if DEBUG
-                // If you accidentally pass some random type in that can't be converted to a string, 
+                // If you accidentally pass some random type in that can't be converted to a string,
                 // FormatResourceString calls ToString() which returns the full name of the type!
                 foreach (object param in args)
                 {
diff --git a/src/Framework/XamlTypes/Argument.cs b/src/Framework/XamlTypes/Argument.cs
index d223f4287f7..ea0078c1d15 100644
--- a/src/Framework/XamlTypes/Argument.cs
+++ b/src/Framework/XamlTypes/Argument.cs
@@ -9,10 +9,10 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Represents an argument to a <see cref="BaseProperty"/>. 
+    /// Represents an argument to a <see cref="BaseProperty"/>.
     /// </summary>
-    /// <remarks> 
-    /// Functionally, it is simply a reference to another <see cref="BaseProperty"/>. Those who manually 
+    /// <remarks>
+    /// Functionally, it is simply a reference to another <see cref="BaseProperty"/>. Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
@@ -33,7 +33,7 @@ public Argument()
         #region Properties
 
         /// <summary>
-        /// Name of the <see cref="BaseProperty"/> this argument refers to. 
+        /// Name of the <see cref="BaseProperty"/> this argument refers to.
         /// </summary>
         /// <remarks>
         /// Its value must point to a valid <see cref="BaseProperty"/>. This field is mandatory and culture invariant.
@@ -48,7 +48,7 @@ public string Property
         /// Tells if the <see cref="BaseProperty"/> pointed to by <see cref="Property"/> must be defined for the definition
         /// of the <see cref="BaseProperty"/> owning this argument to make sense.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This field is optional and is set to <c>false</c> by default.
         /// </remarks>
         public bool IsRequired
diff --git a/src/Framework/XamlTypes/BaseProperty.cs b/src/Framework/XamlTypes/BaseProperty.cs
index 258a30747bf..0160d559c8e 100644
--- a/src/Framework/XamlTypes/BaseProperty.cs
+++ b/src/Framework/XamlTypes/BaseProperty.cs
@@ -12,9 +12,9 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Represents a <see cref="Rule"/> property. 
+    /// Represents a <see cref="Rule"/> property.
     /// </summary>
-    /// <remarks> 
+    /// <remarks>
     /// <para>This represents schema information (name, allowed values, etc) of a <see cref="Rule"/> property.
     /// Since this is just schema information, there is no field like "Value" used to get/set the value of this
     /// property.</para>
@@ -71,10 +71,10 @@ protected BaseProperty()
         #region Properties
 
         /// <summary>
-        /// The name of this <see cref="BaseProperty"/>. 
+        /// The name of this <see cref="BaseProperty"/>.
         /// </summary>
         /// <remarks>
-        /// This field is mandatory and culture invariant. The value of this field cannot be set to the empty string. 
+        /// This field is mandatory and culture invariant. The value of this field cannot be set to the empty string.
         /// </remarks>
         public string Name
         {
@@ -83,10 +83,10 @@ public string Name
         }
 
         /// <summary>
-        /// The name that could be used by a prospective UI client to display this <see cref="BaseProperty"/>. 
+        /// The name that could be used by a prospective UI client to display this <see cref="BaseProperty"/>.
         /// </summary>
         /// <remarks>
-        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same 
+        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same
         /// value as the <see cref="Name"/> property (and hence, would not be localized).
         /// </remarks>
         [Localizable(true)]
@@ -104,9 +104,9 @@ public string DisplayName
         }
 
         /// <summary>
-        /// Description of this <see cref="BaseProperty"/> for use by a prospective UI client. 
+        /// Description of this <see cref="BaseProperty"/> for use by a prospective UI client.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This field is optional and is culture sensitive.
         /// </remarks>
         [Localizable(true)]
@@ -135,7 +135,7 @@ public string F1Keyword
         /// The URL of the help page for this property that will be opened when the user hits F1.
         /// </summary>
         /// <remarks>
-        /// This property is higher in priority that <see cref="HelpContext"/> + <see cref="HelpFile"/> 
+        /// This property is higher in priority that <see cref="HelpContext"/> + <see cref="HelpFile"/>
         /// (i.e., these two properties are ignored if <see cref="HelpUrl"/>
         /// is specified), but lower in priority than <see cref="F1Keyword"/>.
         /// This field is optional and is culture insensitive.
@@ -152,7 +152,7 @@ public string HelpUrl
         /// <summary>
         /// The help file to use when the user hits F1. Must specify <see cref="HelpContext"/> along with this.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This property goes along with <see cref="HelpContext"/>. <seealso cref="HelpContext"/>. This
         /// form of specifying the help page for a property takes lower precedence than both <see cref="F1Keyword"/>
         /// and <see cref="HelpUrl"/>.
@@ -169,7 +169,7 @@ public string HelpFile
         /// The help context to use when the user hits F1. Must specify <see cref="HelpFile"/> along with this.
         /// </summary>
         /// <remarks>
-        /// This property uses the <see cref="HelpFile"/> property to display the help context of the specified 
+        /// This property uses the <see cref="HelpFile"/> property to display the help context of the specified
         /// help file. This field is optional. This
         /// form of specifying the help page for a property takes lower precedence than both <see cref="F1Keyword"/>
         /// and <see cref="HelpUrl"/>.
@@ -181,17 +181,17 @@ public int HelpContext
         }
 
         /// <summary>
-        /// The name of the category to which this property belongs to. 
+        /// The name of the category to which this property belongs to.
         /// </summary>
         /// <remarks>
         /// <para>
-        /// If the value of this field  does not correspond to the <c>Name</c> 
+        /// If the value of this field  does not correspond to the <c>Name</c>
         /// property of a <see cref="Category"/> element defined in
         /// the containing <see cref="Rule"/>, a default <see cref="Category"/> with this name
-        /// is auto-generated and added to the containing <see cref="Rule"/> class. 
+        /// is auto-generated and added to the containing <see cref="Rule"/> class.
         /// </para>
         /// <para>
-        /// This field is optional and is culture invariant. 
+        /// This field is optional and is culture invariant.
         /// </para>
         /// <para>
         /// When this field is not specified, this property is added to a
@@ -215,7 +215,7 @@ public string Subcategory
         }
 
         /// <summary>
-        /// Tells if this property is a read-only property. 
+        /// Tells if this property is a read-only property.
         /// </summary>
         /// <remarks>
         /// This field is optional and its default value is "false".
@@ -276,7 +276,7 @@ public string SwitchPrefix
         /// This field is optional and culture invariant.
         /// </remarks>
         /// <example>
-        /// Example: Consider <c>/D:WIN32</c>. In this switch and value representation, ":" is the separator since its separates the switch <c>D</c> 
+        /// Example: Consider <c>/D:WIN32</c>. In this switch and value representation, ":" is the separator since its separates the switch <c>D</c>
         /// from its value <c>WIN32</c>.
         /// </example>
         public string Separator
@@ -321,7 +321,7 @@ public bool IsRequired
         }
 
         /// <summary>
-        /// Specifies the default value for this property. 
+        /// Specifies the default value for this property.
         /// </summary>
         /// <remarks>
         /// This field is optional and whether, for a <see cref="StringProperty"/>,
@@ -335,10 +335,10 @@ public string Default
         }
 
         /// <summary>
-        /// The data source where the current value of this property is stored. 
+        /// The data source where the current value of this property is stored.
         /// </summary>
         /// <remarks>
-        /// If defined, it overrides the 
+        /// If defined, it overrides the
         /// <see cref="Rule.DataSource"/> property on the containing <see cref="Rule"/>. This field is mandatory only if the parent
         /// <see cref="Rule"/> does not have the data source initialized. The getter for this property returns
         /// only the <see cref="DataSource"/> set directly on this <see cref="BaseProperty"/> instance.
@@ -350,7 +350,7 @@ public DataSource DataSource
         }
 
         /// <summary>
-        /// Additional attributes of this <see cref="BaseProperty"/>. 
+        /// Additional attributes of this <see cref="BaseProperty"/>.
         /// </summary>
         /// <remarks>
         /// This can be used as a grab bag of additional metadata of this property that are not
@@ -379,7 +379,7 @@ public List<Argument> Arguments
         }
 
         /// <summary>
-        /// List of value editors for this property. 
+        /// List of value editors for this property.
         /// </summary>
         /// <remarks>
         /// This field is optional.
@@ -395,9 +395,9 @@ public List<ValueEditor> ValueEditors
     }
 
     /// <summary>
-    /// Represents a <see cref="Rule"/> property. 
+    /// Represents a <see cref="Rule"/> property.
     /// </summary>
-    /// <remarks> 
+    /// <remarks>
     /// <para>This represents schema information (name, allowed values, etc) of a <see cref="Rule"/> property.
     /// Since this is just schema information, there is no field like "Value" used to get/set the value of this
     /// property.</para>
diff --git a/src/Framework/XamlTypes/BoolProperty.cs b/src/Framework/XamlTypes/BoolProperty.cs
index 3476db9732a..7d281fcd17e 100644
--- a/src/Framework/XamlTypes/BoolProperty.cs
+++ b/src/Framework/XamlTypes/BoolProperty.cs
@@ -13,9 +13,9 @@ public sealed class BoolProperty : BaseProperty
         #region Properties
 
         /// <summary>
-        /// Represents the logical negation of a boolean switch. 
+        /// Represents the logical negation of a boolean switch.
         /// </summary>
-        /// <example> 
+        /// <example>
         /// <para>
         /// For the VC++ CL task, <c>WholeProgramOptimization</c> is a boolean parameter. It's switch is <c>GL</c>. To
         /// disable whole program optimization, you need to pass the ReverseSwitch, which is <c>GL-</c>.
diff --git a/src/Framework/XamlTypes/Category.cs b/src/Framework/XamlTypes/Category.cs
index 7538572c08e..2a17393915b 100644
--- a/src/Framework/XamlTypes/Category.cs
+++ b/src/Framework/XamlTypes/Category.cs
@@ -10,8 +10,8 @@ namespace Microsoft.Build.Framework.XamlTypes
     /// <summary>
     /// Represents a category to which a <see cref="BaseProperty"/> can belong to.
     /// </summary>
-    /// <remarks> 
-    /// Those who manually 
+    /// <remarks>
+    /// Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
@@ -33,7 +33,7 @@ public sealed partial class Category : CategorySchema, ISupportInitialize
         #region Properties
 
         /// <summary>
-        /// The name of this <see cref="Category"/>. 
+        /// The name of this <see cref="Category"/>.
         /// </summary>
         /// <remarks>
         /// This field is mandatory and culture invariant.
@@ -46,10 +46,10 @@ public string Name
         }
 
         /// <summary>
-        /// The name that could be used by a prospective UI client to display this <see cref="Category"/>. 
+        /// The name that could be used by a prospective UI client to display this <see cref="Category"/>.
         /// </summary>
         /// <remarks>
-        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same 
+        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same
         /// value as the <see cref="Name"/> property (and hence, would not be localized).
         /// </remarks>
         [Localizable(true)]
@@ -67,7 +67,7 @@ public string DisplayName
         }
 
         /// <summary>
-        /// Description of this <see cref="Category"/>. 
+        /// Description of this <see cref="Category"/>.
         /// </summary>
         /// <remarks>
         /// This field is optional and is culture sensitive.
@@ -93,7 +93,7 @@ public string Subtype
         }
 
         /// <summary>
-        /// Help information for this <see cref="Category"/>. 
+        /// Help information for this <see cref="Category"/>.
         /// </summary>
         /// <remarks>
         /// Maybe used to specify a help URL. This field
@@ -112,8 +112,8 @@ public string HelpString
     /// <summary>
     /// Represents a category to which a <see cref="BaseProperty"/> can belong to.
     /// </summary>
-    /// <remarks> 
-    /// Those who manually 
+    /// <remarks>
+    /// Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
diff --git a/src/Framework/XamlTypes/ContentType.cs b/src/Framework/XamlTypes/ContentType.cs
index d8e3f8bb7ee..a3f55e6c143 100644
--- a/src/Framework/XamlTypes/ContentType.cs
+++ b/src/Framework/XamlTypes/ContentType.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Used to deserialize the content type information 
+    /// Used to deserialize the content type information
     /// </summary>
     [ContentProperty("Metadata")]
     public sealed class ContentType : ISupportInitialize, IProjectSchemaNode
diff --git a/src/Framework/XamlTypes/DynamicEnumProperty.cs b/src/Framework/XamlTypes/DynamicEnumProperty.cs
index cb4e230b993..60ff0471a59 100644
--- a/src/Framework/XamlTypes/DynamicEnumProperty.cs
+++ b/src/Framework/XamlTypes/DynamicEnumProperty.cs
@@ -43,6 +43,6 @@ public DynamicEnumProperty()
         [SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Justification = "Concrete collection types required for XAML deserialization")]
         public List<NameValuePair> ProviderSettings { get; set; }
 
-        #endregion 
+        #endregion
     }
 }
diff --git a/src/Framework/XamlTypes/EnumProperty.cs b/src/Framework/XamlTypes/EnumProperty.cs
index 749a26394b6..499881abfc7 100644
--- a/src/Framework/XamlTypes/EnumProperty.cs
+++ b/src/Framework/XamlTypes/EnumProperty.cs
@@ -42,7 +42,7 @@ public List<EnumValue> AdmissibleValues
             set;
         }
 
-        #endregion 
+        #endregion
 
         #region ISupportInitialize Methods
 
diff --git a/src/Framework/XamlTypes/EnumValue.cs b/src/Framework/XamlTypes/EnumValue.cs
index 4c90e0b947d..d2694f6fc52 100644
--- a/src/Framework/XamlTypes/EnumValue.cs
+++ b/src/Framework/XamlTypes/EnumValue.cs
@@ -44,7 +44,7 @@ public EnumValue()
         #region Properties
 
         /// <summary>
-        /// The name of this <see cref="EnumValue"/>. 
+        /// The name of this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
         /// This field is mandatory and culture invariant.
@@ -56,10 +56,10 @@ public string Name
         }
 
         /// <summary>
-        /// The name that could be used by a prospective UI client to display this <see cref="EnumValue"/>. 
+        /// The name that could be used by a prospective UI client to display this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
-        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same 
+        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same
         /// value as the <see cref="Name"/> property (and hence, would not be localized).
         /// </remarks>
         [Localizable(true)]
@@ -77,9 +77,9 @@ public string DisplayName
         }
 
         /// <summary>
-        /// Description of this <see cref="BaseProperty"/> for use by a prospective UI client. 
+        /// Description of this <see cref="BaseProperty"/> for use by a prospective UI client.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This field is optional and is culture sensitive.
         /// </remarks>
         [Localizable(true)]
@@ -90,7 +90,7 @@ public string Description
         }
 
         /// <summary>
-        /// Help information for this <see cref="EnumValue"/>. 
+        /// Help information for this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
         /// Maybe used to specify a help URL. This field
@@ -110,7 +110,7 @@ public string HelpString
         /// This field is optional and culture invariant.
         /// </remarks>
         /// <example> The VC compiler has an <see cref="EnumProperty"/> named <c>Optimization</c>used to specify the desired optimization type. All the
-        /// admissible values for this property have switches, e.g. <c>Disabled</c> (switch = <c>Od</c>), "MinimumSize" (switch = <c>O1</c>), 
+        /// admissible values for this property have switches, e.g. <c>Disabled</c> (switch = <c>Od</c>), "MinimumSize" (switch = <c>O1</c>),
         /// etc. </example>
         public string Switch
         {
@@ -132,7 +132,7 @@ public string SwitchPrefix
 
         /// <summary>
         /// Tells if this <see cref="EnumValue"/> is the default value for the associated
-        /// <see cref="EnumProperty"/>. 
+        /// <see cref="EnumProperty"/>.
         /// </summary>
         /// <remarks>
         /// This field is optional and the default value for this
@@ -145,7 +145,7 @@ public bool IsDefault
         }
 
         /// <summary>
-        /// Additional attributes of this <see cref="EnumValue"/>. 
+        /// Additional attributes of this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
         /// This can be used as a grab bag of additional metadata of this value that are not
@@ -161,7 +161,7 @@ public List<NameValuePair> Metadata
         }
 
         /// <summary>
-        /// List of arguments for this <see cref="EnumValue"/>. 
+        /// List of arguments for this <see cref="EnumValue"/>.
         /// </summary>
         /// <remarks>
         /// This field is optional.
@@ -173,6 +173,6 @@ public List<Argument> Arguments
             set;
         }
 
-        #endregion 
+        #endregion
     }
 }
diff --git a/src/Framework/XamlTypes/FileExtension.cs b/src/Framework/XamlTypes/FileExtension.cs
index 43c421f90de..77d6c3385f0 100644
--- a/src/Framework/XamlTypes/FileExtension.cs
+++ b/src/Framework/XamlTypes/FileExtension.cs
@@ -21,7 +21,7 @@ public FileExtension()
         }
 
         /// <summary>
-        /// file extension 
+        /// file extension
         /// </summary>
         public string Name
         {
diff --git a/src/Framework/XamlTypes/IntProperty.cs b/src/Framework/XamlTypes/IntProperty.cs
index a3bcf704968..8a9566e7561 100644
--- a/src/Framework/XamlTypes/IntProperty.cs
+++ b/src/Framework/XamlTypes/IntProperty.cs
@@ -13,10 +13,10 @@ public sealed class IntProperty : BaseProperty
         #region Properties
 
         /// <summary>
-        /// Minimum allowed value for this property. 
+        /// Minimum allowed value for this property.
         /// </summary>
         /// <remarks>
-        /// This field is optional. 
+        /// This field is optional.
         /// It returns null when this property is not set. The value of this
         /// property must be less than or equal to the <see cref="MaxValue"/>
         /// property (assuming that the latter is defined).
@@ -28,10 +28,10 @@ public int? MinValue
         }
 
         /// <summary>
-        /// Maximum allowed value for this property. 
+        /// Maximum allowed value for this property.
         /// </summary>
         /// <remarks>
-        /// This field is optional. 
+        /// This field is optional.
         /// It returns null when this property is not set. The value of this
         /// property must be greater than or equal to the <see cref="MinValue"/>
         /// property (assuming that the latter is defined).
diff --git a/src/Framework/XamlTypes/ItemType.cs b/src/Framework/XamlTypes/ItemType.cs
index 14a8d89c880..c1fd7f6733f 100644
--- a/src/Framework/XamlTypes/ItemType.cs
+++ b/src/Framework/XamlTypes/ItemType.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Used to deserialize the item type information 
+    /// Used to deserialize the item type information
     /// </summary>
     public sealed class ItemType : ISupportInitialize, IProjectSchemaNode
     {
diff --git a/src/Framework/XamlTypes/NameValuePair.cs b/src/Framework/XamlTypes/NameValuePair.cs
index 7de604d79f6..cdd6300d401 100644
--- a/src/Framework/XamlTypes/NameValuePair.cs
+++ b/src/Framework/XamlTypes/NameValuePair.cs
@@ -15,7 +15,7 @@ public class NameValuePair
         #region Constructor
 
         /// <summary>
-        /// Default constructor needed for 
+        /// Default constructor needed for
         /// </summary>
         public NameValuePair()
         {
diff --git a/src/Framework/XamlTypes/Rule.cs b/src/Framework/XamlTypes/Rule.cs
index b833e7b888e..ae225536085 100644
--- a/src/Framework/XamlTypes/Rule.cs
+++ b/src/Framework/XamlTypes/Rule.cs
@@ -35,9 +35,9 @@ public enum RuleOverrideMode
     }
 
     /// <summary>
-    /// Used to represent the schema information for a Tool, a Custom Build Rule, a PropertyPage, etc. 
-    /// </summary> 
-    /// <remarks> 
+    /// Used to represent the schema information for a Tool, a Custom Build Rule, a PropertyPage, etc.
+    /// </summary>
+    /// <remarks>
     /// <para>
     /// Normally represented on disk as XAML, only one instance of this class is maintained per XAML
     /// file per project engine (solution).
@@ -90,10 +90,10 @@ public Rule()
         #region Properties
 
         /// <summary>
-        /// The name of this <see cref="Rule"/>. 
+        /// The name of this <see cref="Rule"/>.
         /// </summary>
         /// <remarks>
-        /// This field is mandatory and culture invariant. The value of this field cannot be set to the empty string. 
+        /// This field is mandatory and culture invariant. The value of this field cannot be set to the empty string.
         /// </remarks>
         public string Name
         {
@@ -102,10 +102,10 @@ public string Name
         }
 
         /// <summary>
-        /// The name that could be used by a prospective UI client to display this <see cref="BaseProperty"/>. 
+        /// The name that could be used by a prospective UI client to display this <see cref="BaseProperty"/>.
         /// </summary>
         /// <remarks>
-        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same 
+        /// This field is optional and is culture sensitive. When this property is not set, it is assigned the same
         /// value as the <see cref="Name"/> property (and hence, would not be localized).
         /// </remarks>
         [Localizable(true)]
@@ -132,9 +132,9 @@ public string ToolName
         }
 
         /// <summary>
-        /// Description of this <see cref="Rule"/> for use by a prospective UI client. 
+        /// Description of this <see cref="Rule"/> for use by a prospective UI client.
         /// </summary>
-        /// <remarks> 
+        /// <remarks>
         /// This field is optional and is culture sensitive.
         /// </remarks>
         [Localizable(true)]
@@ -145,7 +145,7 @@ public string Description
         }
 
         /// <summary>
-        /// Help information for this <see cref="Rule"/>. 
+        /// Help information for this <see cref="Rule"/>.
         /// </summary>
         /// <remarks>
         /// Maybe used to specify a help URL. This field
@@ -184,7 +184,7 @@ public string SwitchPrefix
         /// This field is optional and culture invariant.
         /// </remarks>
         /// <example>
-        /// Example: Consider <c>/D:WIN32</c>. In this switch and value representation, ":" is the separator since its separates the switch <c>D</c> 
+        /// Example: Consider <c>/D:WIN32</c>. In this switch and value representation, ":" is the separator since its separates the switch <c>D</c>
         /// from its value <c>WIN32</c>.
         /// </example>
         public string Separator
@@ -194,7 +194,7 @@ public string Separator
         }
 
         /// <summary>
-        /// The UI renderer template used to display this Rule. 
+        /// The UI renderer template used to display this Rule.
         /// </summary>
         /// <remarks>
         /// The value used to set
@@ -209,7 +209,7 @@ public string PageTemplate
 
         /// <summary>
         /// The <see cref="DataSource"/> for all the properties in this <see cref="Rule"/>. This is overriden by any
-        /// data source defined locally for a property. 
+        /// data source defined locally for a property.
         /// </summary>
         /// <remarks>
         /// This field need not be specified only if all individual properties have data source defined locally.
@@ -230,7 +230,7 @@ public int Order
         }
 
         /// <summary>
-        /// This is used to specify whether multiple files need to be batched on one command line invocation. 
+        /// This is used to specify whether multiple files need to be batched on one command line invocation.
         /// </summary>
         /// <remarks>
         /// This field is optional.
@@ -337,7 +337,7 @@ public List<BaseProperty> Properties
         }
 
         /// <summary>
-        /// The list of <see cref="Category"/>s that properties in this <see cref="Rule"/> belong to. 
+        /// The list of <see cref="Category"/>s that properties in this <see cref="Rule"/> belong to.
         /// </summary>
         /// <remarks>
         /// This field is optional. Note that this field returns only the categories that were explicitly defined and do
@@ -368,9 +368,9 @@ public List<Category> Categories
     }
 
     /// <summary>
-    /// Used to represent the schema information for a Tool, a Custom Build Rule, a PropertyPage, etc. 
-    /// </summary> 
-    /// <remarks> 
+    /// Used to represent the schema information for a Tool, a Custom Build Rule, a PropertyPage, etc.
+    /// </summary>
+    /// <remarks>
     /// <para>
     /// Normally represented on disk as XAML, only one instance of this class is maintained per XAML
     /// file per project engine (solution).
@@ -413,8 +413,8 @@ public sealed partial class Rule : RuleSchema, ISupportInitialize, IProjectSchem
         #region Properties
 
         /// <summary>
-        /// This property returns the union of XAML specified <see cref="Category"/>s and auto-generated 
-        /// <see cref="Category"/>s. The latter are created from the missing categories that are being referred to by the 
+        /// This property returns the union of XAML specified <see cref="Category"/>s and auto-generated
+        /// <see cref="Category"/>s. The latter are created from the missing categories that are being referred to by the
         /// properties in this Rule. The auto-generated <see cref="Category"/>s only have their name set.
         /// </summary>
         public List<Category> EvaluatedCategories
@@ -440,7 +440,7 @@ public List<Category> EvaluatedCategories
 
         /// <summary>
         /// Returns all properties partitioned into categories. The return value is never
-        /// null. 
+        /// null.
         /// The returned list may contain auto-generated categories. Note that if a <see cref="BaseProperty"/>
         /// (or its derived classes) refer to a property that is not specified, then an new
         /// Category is generated for the same. If not category is specified for the property, then
@@ -448,7 +448,7 @@ public List<Category> EvaluatedCategories
         /// The list of categories is exactly as specified in the Xaml file. The auto-generated
         /// categories come (in no strict order) after the specified categories.
         /// </summary>
-        /// <returns> A dictionary whose keys are the <see cref="Category"/> names and 
+        /// <returns> A dictionary whose keys are the <see cref="Category"/> names and
         /// the value is the list of properties in that category. </returns>
         public OrderedDictionary GetPropertiesByCategory()
         {
diff --git a/src/Framework/XamlTypes/RuleBag.cs b/src/Framework/XamlTypes/RuleBag.cs
index 2263e46d90e..6183a331574 100644
--- a/src/Framework/XamlTypes/RuleBag.cs
+++ b/src/Framework/XamlTypes/RuleBag.cs
@@ -12,12 +12,12 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// This is a simple container for <see cref="Rule"/> instances. 
+    /// This is a simple container for <see cref="Rule"/> instances.
     /// </summary>
     /// <remarks>
     /// Note that we only deal in terms of <see cref="Rule"/>s
-    /// as far as property pages are concerned. The <see cref="RuleBag"/> is only used as a 
-    /// container for more than one <see cref="Rule"/>. The containing <see cref="Rule"/>s are 
+    /// as far as property pages are concerned. The <see cref="RuleBag"/> is only used as a
+    /// container for more than one <see cref="Rule"/>. The containing <see cref="Rule"/>s are
     /// immediately stripped off after loading of the xaml file.
     /// </remarks>
     [ContentProperty("Rules")]
@@ -48,7 +48,7 @@ public List<Rule> Rules
             set;
         }
 
-        #endregion 
+        #endregion
 
         #region ISupportInitialize Members
 
diff --git a/src/Framework/XamlTypes/StringListProperty.cs b/src/Framework/XamlTypes/StringListProperty.cs
index 7aea73e76f8..39e1d9f8f1f 100644
--- a/src/Framework/XamlTypes/StringListProperty.cs
+++ b/src/Framework/XamlTypes/StringListProperty.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Represents the schema of a list-of-strings property. 
+    /// Represents the schema of a list-of-strings property.
     /// </summary>
     /// <remarks>
     /// Note, this represents
@@ -56,7 +56,7 @@ public string RendererValueSeparator
         /// Qualifies this string property to give it a more specific classification.
         /// </summary>
         /// <remarks>
-        /// Similar to the <see cref="StringProperty.Subtype"/> property. 
+        /// Similar to the <see cref="StringProperty.Subtype"/> property.
         /// </remarks>
         public string Subtype
         {
diff --git a/src/Framework/XamlTypes/ValueEditor.cs b/src/Framework/XamlTypes/ValueEditor.cs
index f8aa2923bd7..4cd11a07958 100644
--- a/src/Framework/XamlTypes/ValueEditor.cs
+++ b/src/Framework/XamlTypes/ValueEditor.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
-    /// Represents a value editor 
+    /// Represents a value editor
     /// </summary>
     [ContentProperty("Metadata")]
     public sealed class ValueEditor : ISupportInitialize
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index d151bc71199..735b63da358 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1055,6 +1055,44 @@ public void AppendParameterizedSwitchesTests2()
             Assert.Equal("build", parameters[2]);
         }
 
+        /// <summary>
+        /// Verifies that the Target property is unquoted and parsed properly.
+        /// This will remove the possibility to have the ';' in the target name. 
+        /// </summary>
+        [Theory]
+        [InlineData("/t:Clean;Build", "\"Clean;Build\"")]
+        [InlineData("/t:Clean;Build", "Clean;Build")]
+        public void ParameterizedSwitchTargetQuotedTest(string commandLineArg, string switchParameters)
+        {
+            CommandLineSwitches switches = new CommandLineSwitches();
+            switches.SetParameterizedSwitch(CommandLineSwitches.ParameterizedSwitch.Target, commandLineArg, switchParameters, true, true, false);
+            switches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Target).ShouldBeTrue();
+
+            switches[CommandLineSwitches.ParameterizedSwitch.Target].Length.ShouldBe(2);
+            switches[CommandLineSwitches.ParameterizedSwitch.Target][0].ShouldBe("Clean");
+            switches[CommandLineSwitches.ParameterizedSwitch.Target][1].ShouldBe("Build");
+            switches.GetParameterizedSwitchCommandLineArg(CommandLineSwitches.ParameterizedSwitch.Target).ShouldBe(commandLineArg);
+        }
+
+        /// <summary>
+        /// Verifies that the parsing behavior of quoted target properties is not changed when ChangeWave configured.
+        /// </summary>
+        [Fact]
+        public void ParameterizedSwitchTargetQuotedChangeWaveTest()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", "17.10");
+
+                CommandLineSwitches switches = new CommandLineSwitches();
+                switches.SetParameterizedSwitch(CommandLineSwitches.ParameterizedSwitch.Target, "/t:Clean;Build", "\"Clean;Build\"", true, true, false);
+                switches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Target).ShouldBeTrue();
+
+                switches[CommandLineSwitches.ParameterizedSwitch.Target].Length.ShouldBe(1);
+                switches[CommandLineSwitches.ParameterizedSwitch.Target][0].ShouldBe("Clean;Build");
+            }
+        }
+
         [Fact]
         public void AppendParameterizedSwitchesTests3()
         {
@@ -1131,6 +1169,9 @@ public void InvalidToolsVersionErrors()
                                         outputResultsCache: null,
                                         saveProjectResult: false,
                                         ref buildResult,
+#if FEATURE_REPORTFILEACCESSES
+                                        reportFileAccesses: false,
+#endif
                                         commandLine: null);
                 }
                 finally
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index 1f0489284ab..16fbed5a461 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -315,7 +315,7 @@ public void PropertyMSBuildStartupDirectoryOnServer()
         </ProcessIdTask>
         <Message Text=""Server ID is $(PID)"" Importance=""High"" />
 		<Message Text="":MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
-	</Target> 
+	</Target>
 </Project>";
 
             TransientTestFile project = _env.CreateFile("testProject.proj", reportMSBuildStartupDirectoryProperty);
diff --git a/src/MSBuild.UnitTests/MockStopwatch.cs b/src/MSBuild.UnitTests/MockStopwatch.cs
new file mode 100644
index 00000000000..8c65821140f
--- /dev/null
+++ b/src/MSBuild.UnitTests/MockStopwatch.cs
@@ -0,0 +1,34 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Logging.TerminalLogger;
+
+namespace Microsoft.Build.CommandLine.UnitTests;
+
+internal sealed class MockStopwatch : StopwatchAbstraction
+{
+    public override double ElapsedSeconds
+    {
+        get
+        {
+            return _elapsed;
+        }
+    }
+
+    public override void Start()
+    {
+        IsStarted = true;
+        Tick();
+    }
+
+    public override void Stop() => IsStarted = false;
+
+    public bool IsStarted { get; private set; }
+
+    private double _elapsed = 0d;
+
+    public void Tick(double seconds = 0.1)
+    {
+        _elapsed += seconds;
+    }
+}
diff --git a/src/MSBuild.UnitTests/NodeStatus_Tests.cs b/src/MSBuild.UnitTests/NodeStatus_Tests.cs
new file mode 100644
index 00000000000..42e821c4ae6
--- /dev/null
+++ b/src/MSBuild.UnitTests/NodeStatus_Tests.cs
@@ -0,0 +1,62 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+using Microsoft.Build.Logging.TerminalLogger;
+
+using VerifyTests;
+using VerifyXunit;
+using Xunit;
+
+using static VerifyXunit.Verifier;
+
+
+namespace Microsoft.Build.CommandLine.UnitTests;
+
+[UsesVerify]
+public class NodeStatus_Tests
+{
+    private readonly NodeStatus _status = new("Namespace.Project", "TargetFramework", "Target", new MockStopwatch());
+
+    public NodeStatus_Tests()
+    {
+        UseProjectRelativeDirectory("Snapshots");
+    }
+
+    [Fact]
+    public async Task EverythingFits()
+    {
+        NodesFrame frame = new([_status], width: 80, height: 5);
+
+        await Verify(frame.RenderNodeStatus(0).ToString());
+    }
+
+    [Fact]
+    public async Task TargetIsTruncatedFirst()
+    {
+        NodesFrame frame = new([_status], width: 45, height: 5);
+
+        await Verify(frame.RenderNodeStatus(0).ToString());
+    }
+
+    [Fact]
+    public async Task NamespaceIsTruncatedNext()
+    {
+        NodesFrame frame = new([_status], width: 40, height: 5);
+
+        await Verify(frame.RenderNodeStatus(0).ToString());
+    }
+
+    [Fact]
+    public async Task GoesToProject()
+    {
+        NodesFrame frame = new([_status], width: 10, height: 5);
+
+        await Verify(frame.RenderNodeStatus(0).ToString());
+    }
+}
diff --git a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
index 49c86fc23a8..0466b7025a5 100644
--- a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
+++ b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
@@ -20,12 +20,12 @@ namespace Microsoft.Build.UnitTests
     public class ProjectSchemaValidationHandlerTest
     {
         /***********************************************************************
-         * 
+         *
          * Test:        ProjectSchemaValidationHandlerTest.VerifyProjectSchema
-         *  
+         *
          * This calls VerifyProjectSchema to validate a project file passed, where
          * the project contents are invalid
-         * 
+         *
          **********************************************************************/
         [Fact]
         public void VerifyInvalidProjectSchema()
@@ -175,12 +175,12 @@ public void VerifyInvalidSchemaItself2()
         }
 
         /***********************************************************************
-         * 
+         *
          * Test:        ProjectSchemaValidationHandlerTest.VerifyProjectSchema
-         *  
+         *
          * This calls VerifyProjectSchema to validate a project XML
          * specified in a string, where the project passed is valid
-         * 
+         *
          **********************************************************************/
         [Fact]
         public void VerifyValidProjectSchema()
@@ -207,7 +207,7 @@ public void VerifyValidProjectSchema()
 
                 // ProjectSchemaValidationHandler.VerifyProjectSchema
                 //    (
-                //    projectFilename, 
+                //    projectFilename,
                 //    msbuildTempXsdFilenames[0],
                 //    @"c:\"
                 //    );
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.EverythingFits.verified.txt b/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.EverythingFits.verified.txt
new file mode 100644
index 00000000000..a889f734e14
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.EverythingFits.verified.txt
@@ -0,0 +1 @@
+﻿  Namespace.Project [36;1mTargetFramework[m [120G[13DTarget (0.0s)
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.GoesToProject.verified.txt b/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.GoesToProject.verified.txt
new file mode 100644
index 00000000000..74eb4993b40
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.GoesToProject.verified.txt
@@ -0,0 +1 @@
+﻿Project
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.NamespaceIsTruncatedNext.verified.txt b/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.NamespaceIsTruncatedNext.verified.txt
new file mode 100644
index 00000000000..a06cd82177c
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.NamespaceIsTruncatedNext.verified.txt
@@ -0,0 +1 @@
+﻿  Project [36;1mTargetFramework[m [120G[7D (0.0s)
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.TargetIsTruncatedFirst.verified.txt b/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.TargetIsTruncatedFirst.verified.txt
new file mode 100644
index 00000000000..014bb0cb3be
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/NodeStatus_Tests.TargetIsTruncatedFirst.verified.txt
@@ -0,0 +1 @@
+﻿  Namespace.Project [36;1mTargetFramework[m [120G[7D (0.0s)
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt
new file mode 100644
index 00000000000..2e9f63be66c
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt
@@ -0,0 +1,3 @@
+﻿]9;4;3;\[?25l[1F
+  project [120G[14DBuild (111.2s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt
new file mode 100644
index 00000000000..dc43e217d65
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt
@@ -0,0 +1,3 @@
+﻿[?25l[1F
+  project [120G[14DBuild (111.2s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt
new file mode 100644
index 00000000000..2e9f63be66c
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt
@@ -0,0 +1,3 @@
+﻿]9;4;3;\[?25l[1F
+  project [120G[14DBuild (111.2s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
index 0777ef5cc91..7e605333ed6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
@@ -1,5 +1,5 @@
 ﻿]9;4;3;\[?25l[1F
-  project [36;1mtfName[m Build (0.0s)
+  project [36;1mtfName[m [120G[12DBuild (0.2s)
 [?25h[?25l[2F
-  project [36;1mtf2[m Build (0.0s)[K
+[K  project [36;1mtf2[m [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
index d860724e3ab..5018115c62a 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
@@ -1,5 +1,5 @@
 ﻿[?25l[1F
-  project [36;1mtfName[m Build (0.0s)
+  project [36;1mtfName[m [120G[12DBuild (0.2s)
 [?25h[?25l[2F
-  project [36;1mtf2[m Build (0.0s)[K
+[K  project [36;1mtf2[m [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
index 0777ef5cc91..7e605333ed6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
@@ -1,5 +1,5 @@
 ﻿]9;4;3;\[?25l[1F
-  project [36;1mtfName[m Build (0.0s)
+  project [36;1mtfName[m [120G[12DBuild (0.2s)
 [?25h[?25l[2F
-  project [36;1mtf2[m Build (0.0s)[K
+[K  project [36;1mtf2[m [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
index d0cb5b914e0..ccfb1bac3a5 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
@@ -1,3 +1,3 @@
 ﻿]9;4;3;\[?25l[1F
-  project Build (0.0s)
+  project [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
index edce93c06c4..c671e994c3e 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
@@ -1,3 +1,3 @@
 ﻿[?25l[1F
-  project Build (0.0s)
+  project [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
index d0cb5b914e0..ccfb1bac3a5 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
@@ -1,3 +1,3 @@
 ﻿]9;4;3;\[?25l[1F
-  project Build (0.0s)
+  project [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
index e397b179c6b..b863cb67194 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
@@ -1,4 +1,4 @@
 ﻿]9;4;3;\[?25l[1F
 [?25h
-Build [31;1mfailed[m in 0.0s
+Build [31;1mfailed[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
index 5dac0df45b6..c36142ab71a 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
@@ -1,3 +1,3 @@
 ﻿[?25l[1F
 [?25h
-Build [31;1mfailed[m in 0.0s
+Build [31;1mfailed[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
index e397b179c6b..b863cb67194 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
@@ -1,4 +1,4 @@
 ﻿]9;4;3;\[?25l[1F
 [?25h
-Build [31;1mfailed[m in 0.0s
+Build [31;1mfailed[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
index 0041a7257fe..11e72f94fbf 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
@@ -1,6 +1,6 @@
-﻿]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
+﻿]9;4;3;\  project [31;1mfailed with errors[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
index cf0d8f1d6c9..bc476784fbb 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
@@ -1,5 +1,5 @@
-﻿  project [31;1mfailed with errors[m (0.0s)
+﻿  project [31;1mfailed with errors[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
index 0041a7257fe..11e72f94fbf 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
@@ -1,6 +1,6 @@
-﻿]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
+﻿]9;4;3;\  project [31;1mfailed with errors[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
index 86c02fdb8df..aeec26abf26 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
@@ -1,6 +1,6 @@
-﻿]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
+﻿]9;4;3;\  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
index 43510237153..3b6fcaf238d 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
@@ -1,5 +1,5 @@
-﻿  project [33;1msucceeded with warnings[m (0.0s)
+﻿  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
index 86c02fdb8df..aeec26abf26 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
@@ -1,6 +1,6 @@
-﻿]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
+﻿]9;4;3;\  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt
new file mode 100644
index 00000000000..d5e6b72e894
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt
new file mode 100644
index 00000000000..4d414bf90bf
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt
@@ -0,0 +1,3 @@
+﻿[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt
new file mode 100644
index 00000000000..d5e6b72e894
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt
new file mode 100644
index 00000000000..75842281bfb
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt
@@ -0,0 +1,5 @@
+﻿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
+[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt
new file mode 100644
index 00000000000..1e10e7fc988
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt
@@ -0,0 +1,4 @@
+﻿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
+[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt
new file mode 100644
index 00000000000..75842281bfb
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt
@@ -0,0 +1,5 @@
+﻿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
+[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt
new file mode 100644
index 00000000000..512b5b78d7e
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt
@@ -0,0 +1,9 @@
+﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
+  project [33;1msucceeded with warnings[m (0.2s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt
new file mode 100644
index 00000000000..0b5a2d831c1
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt
@@ -0,0 +1,8 @@
+﻿directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
+  project [33;1msucceeded with warnings[m (0.2s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt
new file mode 100644
index 00000000000..512b5b78d7e
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt
@@ -0,0 +1,9 @@
+﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
+  project [33;1msucceeded with warnings[m (0.2s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt
new file mode 100644
index 00000000000..fde469843b0
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Restore Failed
+
+Build [31;1mfailed with errors[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt
new file mode 100644
index 00000000000..f912378dc48
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt
@@ -0,0 +1,3 @@
+﻿directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Restore Failed
+
+Build [31;1mfailed with errors[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt
new file mode 100644
index 00000000000..fde469843b0
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Restore Failed
+
+Build [31;1mfailed with errors[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt
new file mode 100644
index 00000000000..927084af0f3
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Restore with Warning
+
+Build [33;1msucceeded with warnings[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt
new file mode 100644
index 00000000000..430fce9be26
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt
@@ -0,0 +1,3 @@
+﻿directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Restore with Warning
+
+Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt
new file mode 100644
index 00000000000..927084af0f3
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Restore with Warning
+
+Build [33;1msucceeded with warnings[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
index e6169b4e163..d5e6b72e894 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
@@ -1,4 +1,4 @@
 ﻿]9;4;3;\[?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
index de2ebf4c55e..4d414bf90bf 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
@@ -1,3 +1,3 @@
 ﻿[?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
index e6169b4e163..d5e6b72e894 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
@@ -1,4 +1,4 @@
 ﻿]9;4;3;\[?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index ed9f0458fba..80353d7ab31 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -11,6 +11,7 @@
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.CommandLine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
@@ -41,8 +42,6 @@ public class TerminalLogger_Tests : IEventSource, IDisposable
 
         private VerifySettings _settings = new();
 
-        private static Regex s_elapsedTime = new($@"\d+{Regex.Escape(CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator)}\ds", RegexOptions.Compiled);
-
         public TerminalLogger_Tests()
         {
             _mockTerminal = new Terminal(_outputWriter);
@@ -50,17 +49,9 @@ public TerminalLogger_Tests()
 
             _terminallogger.Initialize(this, _nodeCount);
 
-            UseProjectRelativeDirectory("Snapshots");
+            _terminallogger.CreateStopwatch = () => new MockStopwatch();
 
-            // Scrub timestamps on intermediate execution lines,
-            // which are subject to the vagaries of the test machine
-            // and OS scheduler.
-            _settings.AddScrubber(static lineBuilder =>
-            {
-                string line = lineBuilder.ToString();
-                lineBuilder.Clear();
-                lineBuilder.Append(s_elapsedTime.Replace(line, "0.0s"));
-            });
+            UseProjectRelativeDirectory("Snapshots");
         }
 
         #region IEventSource implementation
@@ -179,6 +170,14 @@ private BuildWarningEventArgs MakeWarningEventArgs(string warning)
             };
         }
 
+        private BuildMessageEventArgs MakeMessageEventArgs(string message)
+        {
+            return new BuildMessageEventArgs(message, "keyword", null, MessageImportance.High)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
         private BuildErrorEventArgs MakeErrorEventArgs(string error)
         {
             return new BuildErrorEventArgs("", "AA0000", "directory/file", 1, 2, 3, 4, error, null, null)
@@ -201,8 +200,6 @@ private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additi
 
             additionalCallbacks();
 
-            Thread.Sleep(1_000);
-
             TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(_projectFile, "Task", succeeded));
             TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(_projectFile, "Build", succeeded));
 
@@ -229,6 +226,75 @@ public Task PrintBuildSummary_SucceededWithWarnings()
             return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
 
+        [Fact]
+        public Task PrintImmediateWarningMessage_Succeeded()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
+            {
+                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("[CredentialProvider]DeviceFlow: https://testfeed/index.json"));
+                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs(
+                    "[CredentialProvider]ATTENTION: User interaction required." +
+                    "**********************************************************************" +
+                    "To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate." +
+                    "**********************************************************************"));
+            });
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public Task PrintImmediateMessage_Success()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
+            {
+                MessageRaised?.Invoke(_eventSender, MakeMessageEventArgs(
+                    "The plugin credential provider could not acquire credentials." +
+                    "Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, " +
+                    "/p:NuGetInteractive=\"true\" for MSBuild or removing the -NonInteractive switch for `NuGet`"));
+            });
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public Task PrintImmediateMessage_Skipped()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
+            {
+                MessageRaised?.Invoke(_eventSender, MakeMessageEventArgs("--anycustomarg"));
+            });
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public Task PrintRestore_Failed()
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+
+            bool succeeded = false;
+            ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Restore Failed"));
+
+            ProjectFinished?.Invoke(_eventSender, MakeProjectFinishedEventArgs(_projectFile, succeeded));
+            BuildFinished?.Invoke(_eventSender, MakeBuildFinishedEventArgs(succeeded));
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public Task PrintRestore_SuccessWithWarnings()
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+
+            bool succeeded = true;
+            WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Restore with Warning"));
+
+            ProjectFinished?.Invoke(_eventSender, MakeProjectFinishedEventArgs(_projectFile, succeeded));
+            BuildFinished?.Invoke(_eventSender, MakeBuildFinishedEventArgs(succeeded));
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
         [Fact]
         public Task PrintBuildSummary_Failed()
         {
@@ -260,6 +326,43 @@ public void DisplayNodesShowsCurrent()
             });
         }
 
+        [Fact]
+        public void DisplayNodesOverwritesTime()
+        {
+            List<MockStopwatch> stopwatches = new();
+
+            Func<StopwatchAbstraction>? createStopwatch = _terminallogger.CreateStopwatch;
+
+            try
+            {
+                _terminallogger.CreateStopwatch = () =>
+                {
+                    MockStopwatch stopwatch = new();
+                    stopwatches.Add(stopwatch);
+                    return stopwatch;
+                };
+
+                InvokeLoggerCallbacksForSimpleProject(succeeded: false, async () =>
+                {
+                    foreach (var stopwatch in stopwatches)
+                    {
+                        // Tick time forward by at least 10 seconds,
+                        // as a regression test for https://github.com/dotnet/msbuild/issues/9562
+                        stopwatch.Tick(111.0);
+                    }
+
+                    _terminallogger.DisplayNodes();
+
+                    await Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+                });
+            }
+            finally
+            {
+                _terminallogger.CreateStopwatch = createStopwatch;
+            }
+        }
+
+
         [Fact]
         public async Task DisplayNodesOverwritesWithNewTargetFramework()
         {
@@ -293,7 +396,7 @@ public async Task DisplayNodesOverwritesWithNewTargetFramework()
         public void TestTerminalLoggerTogetherWithOtherLoggers()
         {
             using (TestEnvironment env = TestEnvironment.Create())
-            { 
+            {
                 string contents = @"
 <Project>
     <ItemGroup>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index d9654d4e38c..c18c5ad2d90 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -523,6 +523,91 @@ public void Help(string indicator)
             .ShouldBe(MSBuildApp.ExitType.Success);
         }
 
+        [Fact]
+        public void VersionSwitch()
+        {
+            using TestEnvironment env = UnitTests.TestEnvironment.Create();
+
+            // Ensure Change Wave 17.10 is enabled.
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", "");
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+            List<string> cmdLine = new()
+            {
+#if !FEATURE_RUN_EXE_IN_TESTS
+                EnvironmentProvider.GetDotnetExePath(),
+#endif
+                FileUtilities.EnsureDoubleQuotes(RunnerUtilities.PathToCurrentlyRunningMsBuildExe),
+                "-nologo",
+                "-version"
+            };
+
+            using Process process = new()
+            {
+                StartInfo =
+                {
+                    FileName = cmdLine[0],
+                    Arguments = string.Join(" ", cmdLine.Skip(1)),
+                    UseShellExecute = false,
+                    RedirectStandardOutput = true,
+                },
+            };
+
+            process.Start();
+            process.WaitForExit();
+            process.ExitCode.ShouldBe(0);
+
+            string output = process.StandardOutput.ReadToEnd();
+            output.EndsWith(Environment.NewLine).ShouldBeTrue();
+
+            process.Close();
+        }
+
+        /// <summary>
+        /// PR: Change Version switch output to finish with a newline https://github.com/dotnet/msbuild/pull/9485
+        /// </summary>
+        [Fact]
+        public void VersionSwitchDisableChangeWave()
+        {
+            using TestEnvironment env = UnitTests.TestEnvironment.Create();
+
+            // Disable Change Wave 17.10
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_10.ToString());
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+            List<string> cmdLine = new()
+            {
+#if !FEATURE_RUN_EXE_IN_TESTS
+                EnvironmentProvider.GetDotnetExePath(),
+#endif
+                FileUtilities.EnsureDoubleQuotes(RunnerUtilities.PathToCurrentlyRunningMsBuildExe),
+                "-nologo",
+                "-version"
+            };
+
+            using Process process = new()
+            {
+                StartInfo =
+                {
+                    FileName = cmdLine[0],
+                    Arguments = string.Join(" ", cmdLine.Skip(1)),
+                    UseShellExecute = false,
+                    RedirectStandardOutput = true,
+                },
+            };
+
+            process.Start();
+            process.WaitForExit();
+            process.ExitCode.ShouldBe(0);
+
+            string output = process.StandardOutput.ReadToEnd();
+            output.EndsWith(Environment.NewLine).ShouldBeFalse();
+
+            process.Close();
+        }
+
         [Fact]
         public void ErrorCommandLine()
         {
@@ -618,23 +703,35 @@ public void InvalidMaxCPUCountSwitch4()
             });
         }
 
+        [Fact]
+        public void GetPropertyWithInvalidProjectThrowsInvalidProjectFileExceptionNotInternalError()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile project = env.CreateFile("testProject.csproj", "Project");
+            string result = RunnerUtilities.ExecMSBuild($" {project.Path} -getProperty:Foo", out bool success);
+            success.ShouldBeFalse();
+            result.ShouldContain("MSB4025");
+            result.ShouldNotContain("MSB1025");
+        }
+
         [Theory]
-        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, true)]
-        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, true)]
-        [InlineData("-getItem:MyItem", false, "", true, false, false, true)]
-        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, true)]
-        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, true)]
-        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, true)]
-        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, true)]
-        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, true)]
-        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, false)]
-        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, false)]
-        [InlineData("-getItem:MyItem", false, "", true, false, false, false)]
-        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, false)]
-        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, false)]
-        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, false)]
-        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, false)]
-        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, true, false)]
+        [InlineData("-getItem:MyItem", false, "", true, false, false, true, false)]
+        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, true, false)]
+        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, true, false)]
+        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, false, false)]
+        [InlineData("-getItem:MyItem", false, "", true, false, false, false, false)]
+        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, false, false)]
+        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, false, false)]
+        [InlineData("-getTargetResult:Restore", false, "", false, false, false, false, true)]
         public void ExecuteAppWithGetPropertyItemAndTargetResult(
             string extraSwitch,
             bool fooPresent,
@@ -642,7 +739,8 @@ public void ExecuteAppWithGetPropertyItemAndTargetResult(
             bool itemIncludesAlwaysThere,
             bool itemIncludesTargetItem,
             bool targetResultPresent,
-            bool isGraphBuild)
+            bool isGraphBuild,
+            bool restoreOnly)
         {
             using TestEnvironment env = TestEnvironment.Create();
             TransientTestFile project = env.CreateFile("testProject.csproj", @"
@@ -670,11 +768,15 @@ public void ExecuteAppWithGetPropertyItemAndTargetResult(
 
   </Target>
 
+  <Target Name=""Restore"">
+
+  </Target>
+
 </Project>
 ");
             string graph = isGraphBuild ? "--graph" : "";
             string results = RunnerUtilities.ExecMSBuild($" {project.Path} {extraSwitch} {graph}", out bool success);
-            success.ShouldBeTrue();
+            success.ShouldBeTrue(results);
             if (fooPresent)
             {
                 results.ShouldContain($"\"Foo\": \"{fooResult}\"");
@@ -687,7 +789,38 @@ public void ExecuteAppWithGetPropertyItemAndTargetResult(
             results.Contains("targetItem").ShouldBe(itemIncludesTargetItem);
 
             results.Contains("MyTarget").ShouldBe(targetResultPresent);
-            results.Contains("\"Result\": \"Success\"").ShouldBe(targetResultPresent);
+            results.Contains("\"Result\": \"Success\"").ShouldBe(targetResultPresent || restoreOnly);
+            results.ShouldNotContain(ResourceUtilities.GetResourceString("BuildFailedWithPropertiesItemsOrTargetResultsRequested"));
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void BuildFailsWithCompileErrorAndRestore(bool isGraphBuild)
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile project = env.CreateFile("testProject.csproj", @"
+<Project>
+  <ItemGroup>
+    <CSFile Include=""Program.cs""/>
+  </ItemGroup>
+
+  <Target Name=""Build"">
+    <Csc Sources=""@(CSFile)"" />
+  </Target>
+</Project>
+        ");
+            TransientTestFile wrongSyntaxFile = env.CreateFile("Program.cs", @"
+            Console.WriteLine(""Hello, World!"")
+            A Line here for this to not compile right");
+
+            string graph = isGraphBuild ? "--graph" : "";
+            string result = RunnerUtilities.ExecMSBuild($" {project.Path} /restore {graph}", out bool success);
+
+            success.ShouldBeFalse();
+            result.ShouldContain("Program.cs(2,47): error CS1002: ; expected");
+            result.ShouldContain("Program.cs(3,20): error CS1003: Syntax error, ','");
+            result.ShouldContain("Program.cs(3,54): error CS1002: ; expected");
         }
 
         /// <summary>
@@ -1472,8 +1605,7 @@ private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params s
 
             string logContents = ExecuteMSBuildExeExpectSuccess(contents, envsToCreate: environmentVars, arguments: aggregateArguments);
 
-            string expected = $@"Task priority is '{expectedPrority}'";
-            logContents.ShouldContain(expected, () => logContents);
+            logContents.ShouldContain($@"Task priority is '{expectedPrority}'", customMessage: logContents);
         }
 
         /// <summary>
@@ -2331,8 +2463,8 @@ public void MultipleTargetsDoesNotCrash()
 
             string logContents = ExecuteMSBuildExeExpectSuccess(projectContents, arguments: "/t:Target1 /t:Target2");
 
-            logContents.ShouldContain("7514CB1641A948D0A3930C5EC2DC1940", () => logContents);
-            logContents.ShouldContain("E2C73B5843F94B63B067D9BEB2C4EC52", () => logContents);
+            logContents.ShouldContain("7514CB1641A948D0A3930C5EC2DC1940", customMessage: logContents);
+            logContents.ShouldContain("E2C73B5843F94B63B067D9BEB2C4EC52", customMessage: logContents);
         }
 
         [Theory]
@@ -2355,8 +2487,8 @@ public void MissingOptionalLoggersAreIgnored(string logger)
 
             var output = RunnerUtilities.ExecMSBuild(parametersLoggerOptional, out bool successfulExit, _output);
             successfulExit.ShouldBe(true);
-            output.ShouldContain("Hello", output);
-            output.ShouldContain("The specified logger could not be created and will not be used.", output);
+            output.ShouldContain("Hello", customMessage: output);
+            output.ShouldContain("The specified logger could not be created and will not be used.", customMessage: output);
         }
 
         [Theory]
@@ -2621,7 +2753,7 @@ private string ExecuteMSBuildExeExpectSuccess(string projectContents, IDictionar
         {
             (bool result, string output) = ExecuteMSBuildExe(projectContents, filesToCreate, envsToCreate, arguments);
 
-            result.ShouldBeTrue(() => output);
+            result.ShouldBeTrue(output);
 
             return output;
         }
@@ -2630,7 +2762,7 @@ private string ExecuteMSBuildExeExpectFailure(string projectContents, IDictionar
         {
             (bool result, string output) = ExecuteMSBuildExe(projectContents, filesToCreate, envsToCreate, arguments);
 
-            result.ShouldBeFalse(() => output);
+            result.ShouldBeFalse(output);
 
             return output;
         }
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index d5d2b08a104..6ac15c07dec 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -106,6 +106,9 @@ internal enum ParameterizedSwitch
             GraphBuild,
             InputResultsCaches,
             OutputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+            ReportFileAccesses,
+#endif
             LowPriority,
             Question,
             DetailedSummary,
@@ -268,6 +271,9 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true),
             new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true),
+#if FEATURE_REPORTFILEACCESSES
+            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false),
+#endif
             new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
@@ -299,12 +305,12 @@ internal static bool IsParameterlessSwitch(
                     {
                         parameterlessSwitch = switchInfo.parameterlessSwitch;
                         duplicateSwitchErrorMessage = switchInfo.duplicateSwitchErrorMessage;
-                        break;
+                        return true;
                     }
                 }
             }
 
-            return parameterlessSwitch != ParameterlessSwitch.Invalid;
+            return false;
         }
 
         /// <summary>
@@ -356,12 +362,12 @@ internal static bool IsParameterizedSwitch(
                         missingParametersErrorMessage = switchInfo.missingParametersErrorMessage;
                         unquoteParameters = switchInfo.unquoteParameters;
                         emptyParametersAllowed = switchInfo.emptyParametersAllowed;
-                        break;
+                        return true;
                     }
                 }
             }
 
-            return parameterizedSwitch != ParameterizedSwitch.Invalid;
+            return false;
         }
 
         /// <summary>
@@ -482,6 +488,11 @@ internal bool SetParameterizedSwitch(
                 }
                 else
                 {
+                    if (IsMultipleAllowedSwitchParameterDueToUnquote(unquoteParameters, parameterizedSwitch))
+                    {
+                        switchParameters = QuotingUtilities.Unquote(switchParameters);
+                    }
+
                     // store all the switch parameters
                     int emptyParameters;
                     _parameterizedSwitches[(int)parameterizedSwitch].parameters.AddRange(QuotingUtilities.SplitUnquoted(switchParameters, int.MaxValue, false /* discard empty parameters */, unquoteParameters, out emptyParameters, s_parameterSeparators));
@@ -645,6 +656,30 @@ internal string[][] GetFileLoggerParameters()
             return groupedFileLoggerParameters;
         }
 
+        /// <summary>
+        /// Checks if the provided multiple valued parametrized switch needs to be unquoted.
+        /// The method will return 'true' in case:
+        ///     The changewave 17.10 is not set and
+        ///     The parametrized switch is 'Target'
+        /// </summary>
+        private bool IsMultipleAllowedSwitchParameterDueToUnquote(bool unquoteParameter, ParameterizedSwitch parameterizedSwitch)
+        {
+            if (!unquoteParameter || !Traits.Instance.EscapeHatches.UnquoteTargetSwitchParameters)
+            {
+                return false;
+            }
+
+            // issue: https://github.com/dotnet/msbuild/issues/9442
+            // In order to align the parsing behaviour of Target property when MSBuild invoked from PowerShell or CMD,
+            // the target property value will be unquoted before processing further
+            if (parameterizedSwitch == ParameterizedSwitch.Target)
+            {
+                return true;
+            }
+
+            return false;
+        }
+
         /// <summary>
         /// If the specified parameterized switch is set, returns the array of parameters.
         /// Otherwise, if the specified parameterless switch is set, returns an empty array.
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 3ca22b8e510..4f7383fa154 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -18,6 +18,7 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -71,41 +72,26 @@
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="..\Shared\FileDelegates.cs">
       <Link>FileDelegates.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>FileUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Build\Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>FileUtilitiesRegex.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
       <Link>IConstrainedEqualityComparer.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\QuotingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\QuotingUtilities.cs" />
     <Compile Include="..\Shared\RegisteredTaskObjectCacheBase.cs">
       <Link>RegisteredTaskObjectCacheBase.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ResourceUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\EscapingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ErrorUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\Modifiers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\XMakeElements.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\ResourceUtilities.cs" />
+    <Compile Include="..\Shared\EscapingUtilities.cs" />
+    <Compile Include="..\Shared\ErrorUtilities.cs" />
+    <Compile Include="..\Shared\Modifiers.cs" />
+    <Compile Include="..\Shared\XMakeElements.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
@@ -114,15 +100,11 @@
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs" />
-    <Compile Include="..\Shared\EventArgsFormatting.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\EventArgsFormatting.cs" />
     <Compile Include="..\Shared\TempFileUtilities.cs">
       <Link>TempFileUtilities.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\XMakeAttributes.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\XMakeAttributes.cs" />
     <Compile Include="..\Shared\INodeEndpoint.cs" />
     <Compile Include="..\Shared\NodeEndpointOutOfProcBase.cs" />
     <Compile Include="..\Shared\INodePacket.cs" />
@@ -140,59 +122,35 @@
     <Compile Include="..\Shared\TaskLoader.cs" />
     <Compile Include="..\Shared\MSBuildLoadContext.cs" Condition="'$(TargetFrameworkIdentifier)'!='.NETFramework'" />
     <Compile Include="..\Shared\TypeLoader.cs" />
-    <Compile Include="..\Shared\LoadedType.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyLoadInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\LoadedType.cs" />
+    <Compile Include="..\Shared\AssemblyLoadInfo.cs" />
     <Compile Include="..\Shared\NodeBuildComplete.cs" />
     <Compile Include="..\Shared\NodeShutdown.cs" />
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs" />
-    <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyNameExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs" />
+    <Compile Include="..\Shared\AssemblyNameExtension.cs" />
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
     <Compile Include="..\Shared\StringExtensions.cs" />
-    <Compile Include="AssemblyInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyResources.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyInfo.cs" />
+    <Compile Include="AssemblyResources.cs" />
     <Compile Include="AutomaticEncodingRestorer.cs" />
-    <Compile Include="CommandLineSwitches.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CommandLineSwitchException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="CommandLineSwitches.cs" />
+    <Compile Include="CommandLineSwitchException.cs" />
     <Compile Include="..\Shared\CoreCLRAssemblyLoader.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
-    <Compile Include="DistributedLoggerRecord.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="DistributedLoggerRecord.cs" />
     <Compile Include="TerminalLogger\*.cs" />
-    <Compile Include="InitializationException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="InitializationException.cs" />
     <Compile Include="MSBuildClientApp.cs" />
     <Compile Include="NodeEndpointOutOfProcTaskHost.cs" />
     <Compile Include="LogMessagePacket.cs" />
-    <Compile Include="ProjectSchemaValidationHandler.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ProjectSchemaValidationHandler.cs" />
     <Compile Include="OutOfProcTaskHostNode.cs" />
     <Compile Include="OutOfProcTaskAppDomainWrapperBase.cs" />
     <Compile Include="OutOfProcTaskAppDomainWrapper.cs" />
     <Compile Include="PerformanceLogEventListener.cs" />
     <Compile Include="JsonOutputFormatter.cs" />
-    <Compile Include="XMake.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="XMake.cs" />
     <!-- This is to enable CodeMarkers in MSBuild.exe -->
     <!-- Win32 RC Files -->
     <RCResourceFile Include="native.rc" />
@@ -218,6 +176,7 @@
     </None>
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
@@ -297,6 +256,7 @@
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.props" TargetFramework="%(_TargetFrameworks.Identity)" Subdirectory="Current\" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.tasks" TargetFramework="%(_TargetFrameworks.Identity)" />
+      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.Test.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.Before.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.After.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 16a70ef7da0..fe39afc0b89 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -214,6 +214,13 @@ elementFormDefault="qualified">
                   </xs:documentation>
                 </xs:annotation>
               </xs:element>
+              <xs:element name="VersionOverride">
+                <xs:annotation>
+                  <xs:documentation>
+                    <!-- _locID_text="PackageReference_VersionOverride" _locComment="" -->When using Central Package Management (CPM), overrides the centrally defined version for this package.  If the project is not using CPM, this element has no effect.
+                  </xs:documentation>
+                </xs:annotation>
+              </xs:element>
             </xs:choice>
           </xs:sequence>
           <xs:attribute name="Include" type="xs:string">
@@ -265,6 +272,13 @@ elementFormDefault="qualified">
               </xs:documentation>
             </xs:annotation>
           </xs:attribute>
+          <xs:attribute name="VersionOverride" type="xs:string" use="optional">
+            <xs:annotation>
+              <xs:documentation>
+                <!-- _locID_text="PackageReference_Attribute_VersionOverride" _locComment="" -->When using Central Package Management (CPM), overrides the centrally defined version for this package.  If the project is not using CPM, this attribute has no effect.
+              </xs:documentation>
+            </xs:annotation>
+          </xs:attribute>
         </xs:extension>
       </xs:complexContent>
     </xs:complexType>
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index de7895a6259..3bc82973b49 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -91,7 +91,7 @@ public static MSBuildApp.ExitType Execute(
                 Enum.TryParse(exitResult.MSBuildAppExitTypeString, out MSBuildApp.ExitType MSBuildAppExitType))
             {
                 // The client successfully set up a build task for MSBuild server and received the result.
-                // (Which could be a failure as well). Return the received exit type. 
+                // (Which could be a failure as well). Return the received exit type.
                 return MSBuildAppExitType;
             }
 
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
index d8520ec4b61..73c84728846 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.CommandLine
     internal class OutOfProcTaskAppDomainWrapper : OutOfProcTaskAppDomainWrapperBase
     {
         /// <summary>
-        /// This is an extension of the OutOfProcTaskAppDomainWrapper that is responsible 
+        /// This is an extension of the OutOfProcTaskAppDomainWrapper that is responsible
         /// for activating and executing the user task.
         /// This extension provides support for ICancellable Out-Of-Proc tasks.
         /// </summary>
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 2290f4aa7c9..2cd1b34f072 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -35,22 +35,22 @@ internal class OutOfProcTaskAppDomainWrapperBase
         /// This is an appDomain instance if any is created for running this task
         /// </summary>
         /// <comments>
-        /// TaskAppDomain's non-serializability should never be an issue since even if we start running the wrapper 
+        /// TaskAppDomain's non-serializability should never be an issue since even if we start running the wrapper
         /// in a separate appdomain, we will not be trying to load the task on one side of the serialization
-        /// boundary and run it on the other.  
+        /// boundary and run it on the other.
         /// </comments>
         [NonSerialized]
         private AppDomain _taskAppDomain;
 #endif
 
         /// <summary>
-        /// Need to keep the build engine around in order to log from the task loader. 
+        /// Need to keep the build engine around in order to log from the task loader.
         /// </summary>
         private IBuildEngine buildEngine;
 
         /// <summary>
         /// Need to keep track of the task name also so that we can log valid information
-        /// from the task loader. 
+        /// from the task loader.
         /// </summary>
         private string taskName;
 
@@ -117,7 +117,7 @@ internal OutOfProcTaskHostTaskResult ExecuteTask(
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                // If it's a TargetInvocationException, we only care about the contents of the inner exception, 
+                // If it's a TargetInvocationException, we only care about the contents of the inner exception,
                 // so just save that instead.
                 Exception exceptionToReturn = e is TargetInvocationException ? e.InnerException : e;
 
@@ -177,11 +177,11 @@ internal void CleanupTask()
 
 #if FEATURE_APARTMENT_STATE
         /// <summary>
-        /// Execute a task on the STA thread. 
+        /// Execute a task on the STA thread.
         /// </summary>
         /// <comment>
-        /// STA thread launching code lifted from XMakeBuildEngine\BackEnd\Components\RequestBuilder\TaskBuilder.cs, ExecuteTaskInSTAThread method.  
-        /// Any bug fixes made to this code, please ensure that you also fix that code.  
+        /// STA thread launching code lifted from XMakeBuildEngine\BackEnd\Components\RequestBuilder\TaskBuilder.cs, ExecuteTaskInSTAThread method.
+        /// Any bug fixes made to this code, please ensure that you also fix that code.
         /// </comment>
         private OutOfProcTaskHostTaskResult InstantiateAndExecuteTaskInSTAThread(
                 IBuildEngine oopTaskHostNode,
@@ -260,7 +260,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTaskInSTAThread(
 #endif
 
         /// <summary>
-        /// Do the work of actually instantiating and running the task. 
+        /// Do the work of actually instantiating and running the task.
         /// </summary>
         private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                 IBuildEngine oopTaskHostNode,
@@ -307,8 +307,8 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
             {
                 Exception exceptionToReturn = e;
 
-                // If it's a TargetInvocationException, we only care about the contents of the inner exception, 
-                // so just save that instead. 
+                // If it's a TargetInvocationException, we only care about the contents of the inner exception,
+                // so just save that instead.
                 if (e is TargetInvocationException)
                 {
                     exceptionToReturn = e.InnerException;
@@ -347,7 +347,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                     return new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure);
                 }
 
-                // If it didn't crash and return before now, we're clear to go ahead and execute here. 
+                // If it didn't crash and return before now, we're clear to go ahead and execute here.
                 success = wrappedTask.Execute();
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
@@ -369,9 +369,9 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                     }
                     catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                     {
-                        // If it's not a critical exception, we assume there's some sort of problem in the parameter getter -- 
-                        // so save the exception, and we'll re-throw once we're back on the main node side of the 
-                        // communications pipe.  
+                        // If it's not a critical exception, we assume there's some sort of problem in the parameter getter --
+                        // so save the exception, and we'll re-throw once we're back on the main node side of the
+                        // communications pipe.
                         finalParameterValues[value.Name] = e;
                     }
                 }
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 1a0c3871a2d..dc6cfcdf7e6 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -5,14 +5,16 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.IO;
 using System.Globalization;
-using System.Threading;
+using System.IO;
 using System.Reflection;
-
+using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Experimental.FileAccess;
+#endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 #if FEATURE_APPDOMAIN
@@ -165,6 +167,13 @@ internal class OutOfProcTaskHostNode :
         private RegisteredTaskObjectCacheBase _registeredTaskObjectCache;
 #endif
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// The file accesses reported by the most recently completed task.
+        /// </summary>
+        private List<FileAccessData> _fileAccessData = new List<FileAccessData>();
+#endif
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -531,11 +540,22 @@ public override bool IsTaskInputLoggingEnabled
                     return _taskHost._currentConfiguration.IsTaskInputLoggingEnabled;
                 }
             }
+
+#if FEATURE_REPORTFILEACCESSES
+            /// <summary>
+            /// Reports a file access from a task.
+            /// </summary>
+            /// <param name="fileAccessData">The file access to report.</param>
+            public void ReportFileAccess(FileAccessData fileAccessData)
+            {
+                _taskHost._fileAccessData.Add(fileAccessData);
+            }
+#endif
         }
 
         public EngineServices EngineServices { get; }
 
-        #endregion
+#endregion
 
 #endif
 
@@ -936,8 +956,11 @@ private void RunTask(object state)
                     lock (_taskCompleteLock)
                     {
                         _taskCompletePacket = new TaskHostTaskComplete(
-                                                        taskResult,
-                                                        currentEnvironment);
+                            taskResult,
+#if FEATURE_REPORTFILEACCESSES
+                            _fileAccessData,
+#endif
+                            currentEnvironment);
                     }
 
 #if FEATURE_APPDOMAIN
@@ -956,11 +979,20 @@ private void RunTask(object state)
                     lock (_taskCompleteLock)
                     {
                         // Create a minimal taskCompletePacket to carry the exception so that the TaskHostTask does not hang while waiting
-                        _taskCompletePacket = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e), null);
+                        _taskCompletePacket = new TaskHostTaskComplete(
+                            new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e),
+#if FEATURE_REPORTFILEACCESSES
+                            _fileAccessData,
+#endif
+                            null);
                     }
                 }
                 finally
                 {
+#if FEATURE_REPORTFILEACCESSES
+                    _fileAccessData = new List<FileAccessData>();
+#endif
+
                     // Call CleanupTask to unload any domains and other necessary cleanup in the taskWrapper
                     _taskWrapper.CleanupTask();
 
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index f23360f892b..73986e71b28 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -25,12 +25,12 @@ internal sealed class ProjectSchemaValidationHandler
         #region Methods
 
         /// <summary>
-        /// Validates a project file against the given schema.  If no schema is given, validates 
+        /// Validates a project file against the given schema.  If no schema is given, validates
         /// against the default schema
         /// </summary>
         /// <param name="projectFile">Path of the file to validate.</param>
         /// <param name="schemaFile">Can be null.</param>
-        /// <param name="binPath">Path to the framework directory where the default schema for 
+        /// <param name="binPath">Path to the framework directory where the default schema for
         /// this ToolsVersion can be found.</param>
         /// <returns>True if the project was successfully validated against the given schema, false otherwise</returns>
         internal static void VerifyProjectSchema(
@@ -48,13 +48,13 @@ internal static void VerifyProjectSchema(
 
             if (FileSystems.Default.FileExists(schemaFile))
             {
-                // Print the schema file we're using, particularly since it can vary 
+                // Print the schema file we're using, particularly since it can vary
                 // according to the toolset being used
                 Console.WriteLine(AssemblyResources.GetString("SchemaFileLocation"), schemaFile);
             }
             else
             {
-                // If we've gotten to this point, there is no schema to validate against -- just exit. 
+                // If we've gotten to this point, there is no schema to validate against -- just exit.
                 InitializationException.Throw(
                     ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SchemaNotFoundErrorWithFile", schemaFile),
                     null); /* No associated command line switch */
@@ -159,8 +159,8 @@ private void VerifyProjectSchema(
         }
 
         /// <summary>
-        /// Given the parameters passed in, if the condition is false, builds an 
-        /// error message and throws an InitializationException with that message. 
+        /// Given the parameters passed in, if the condition is false, builds an
+        /// error message and throws an InitializationException with that message.
         /// </summary>
         private static void VerifyThrowInitializationExceptionWithResource(
                  bool condition,
@@ -186,8 +186,8 @@ private static void VerifyThrowInitializationExceptionWithResource(
         }
 
         /// <summary>
-        /// Given the parameters passed in, builds an error message and throws an 
-        /// InitializationException with that message. 
+        /// Given the parameters passed in, builds an error message and throws an
+        /// InitializationException with that message.
         /// </summary>
         private static void ThrowInitializationExceptionWithResource(
                  string projectFile,
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 328cb2dcdd4..98c41c4823c 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -865,6 +865,18 @@
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </comment>
   </data>
+  <data name="HelpMessage_42_ReportFileAccessesSwitch" Visibility="Public">
+    <value>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </value>
+    <comment>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
   <data name="InvalidConfigurationFile" Visibility="Public">
     <value>MSBUILD : Configuration error MSB1043: The application could not start. {0}</value>
     <comment>
@@ -1336,6 +1348,15 @@
     <value>MSBUILD : error MSB1049: The {0} parameter must be specified</value>
     <comment>{StrBegin="MSBUILD : error MSB1049: "}</comment>
   </data>
+  <data name="InvalidReportFileAccessesValue" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <!-- #################################################################################################-->
   <!-- ######################################## Shared strings #########################################-->
   <!-- ###### These belong in Strings.shared.resx, but have been copied here for performance ###########-->
@@ -1515,26 +1536,11 @@
       {0}: VT100 coded hyperlink to project output directory
     </comment>
   </data>
-  <data name="ProjectBuilding_NoTF" xml:space="preserve">
-    <value>{0}{1} {2} ({3}s)</value>
-    <comment>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </comment>
-  </data>
-  <data name="ProjectBuilding_WithTF" xml:space="preserve">
-    <value>{0}{1} {2} {3} ({4}s)</value>
-    <comment>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </comment>
+  <data name="DurationDisplay">
+      <value>({0:F1}s)</value>
+      <comment>
+        {0}: duration in seconds with 1 decimal point
+      </comment>
   </data>
   <data name="BuildFailedWithPropertiesItemsOrTargetResultsRequested" xml:space="preserve">
     <value>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</value>
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index f2b85eea526..bc757f96072 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Sestavení se nezdařilo. Nelze získat výsledky vlastností, položek a cíle. Viz podrobnosti ve stderr výše.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: Přepínač -noAutoResponse nelze zadat v souboru automatických odpovědí MSBuild.rsp ani v žádném jiném souboru odpovědí, na který se v souboru automatických odpovědí odkazuje.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1} s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -97,6 +104,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Způsobí, že MSBuild bude hlásit přístupy k souborům ve všech konfigurovaných
+                     modulech plug-in pro mezipaměť projektu.
+
+                     Tento příznak je experimentální a nemusí fungovat podle očekávání.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -117,6 +142,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Hodnota přístupů k souborům sestavy není platná. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -540,20 +575,17 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;protok_nást&gt;   Použít daný protokolovací nástroj k protokolování
-                     událostí nástroje MSBuild. Chcete-li zadat více protokolovacích.
-                     nástrojů, musíte je zadat jednotlivě.
-                     Syntaxe hodnoty &lt;protok_nást&gt;:
-                        [&lt;třída_protok_nást&gt;,]&lt;sestavení_protok_nást&gt;
-                        [;&lt;param_protok_nást&gt;]
-                     Syntaxe hodnoty &lt;třída_protok_nást&gt;:
-                        [&lt;část/úpl_obor_názvů&gt;.]&lt;náz_tř_protok_nást&gt;
-                     Syntaxe hodnoty &lt;sestavení_protok_nást&gt;:
-                        {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
+        <target state="translated">  -logger:&lt;logger&gt;   Použít daný protokolovací nástroj k protokolování událostí nástroje MSBuild. Pokud chcete zadat 
+                     více protokolovacích nástrojů, musíte je zadat jednotlivě.
+                     Syntaxe hodnoty &lt;logger&gt; je:
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                     Syntaxe hodnoty &lt;logger class&gt; je:
+                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
+                     Syntaxe hodnoty &lt;logger assembly&gt; je:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
-                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se 
-                     protokolovacímu nástroji přesně v tom tvaru, v jakém
-                     byly zadány. (Krátký tvar: -l)
+                     Parametry &lt;logger parameters&gt; jsou volitelné a předávají se
+                     protokolovacímu nástroji přesně v tom tvaru, v jakém byly zadány. (Krátký tvar: -l)
                      Příklady:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
@@ -822,23 +854,20 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;                     
-                     Použít zadaný protokolovací nástroj pro protokolování událostí
-                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci 
-                     protokolovacího nástroje. Chcete-li zadat více 
-                     protokolovacích nástrojů, uveďte je jednotlivě. 
+        <target state="translated">  -distributedLogger:&lt;central logger&gt;*&lt;forwarding logger&gt;
+                     Použít zadaný protokolovací nástroj pro protokolování událostí z nástroje MSBuild; ke každému uzlu připojit
+                     jinou instanci protokolovacího nástroje. Pokud chcete zadat více
+                     protokolovacích nástrojů, uveďte je jednotlivě.
                      (Krátký tvar: -dl)
-                     Syntaxe hodnoty &lt;protok_nást&gt;:
-                        [&lt;třída_protok_nást&gt;,]&lt;sestav_protok_nást&gt;
-                        [;&lt;param_protok_nást&gt;]
-                     Syntaxe hodnoty &lt;třída_protok_nást&gt;:
-                        [&lt;část/úpl_obor_názvů&gt;.]&lt;náz_tř_protok_nást&gt;
-                     Syntaxe hodnoty &lt;sestav_protok_nást&gt;:
-                        {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
+                     Syntaxe hodnoty &lt;logger&gt; je:
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                     Syntaxe hodnoty &lt;logger class&gt; je:
+                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
+                     Syntaxe hodnoty &lt;logger assembly&gt; je:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
                      Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se
-                     protokolovacímu nástroji přesně v zadaném tvaru.
-                     (Krátký tvar: -l)
+                     protokolovacímu nástroji přesně v zadaném tvaru. (Krátký tvar: -l)
                      Příklady:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
@@ -1026,7 +1055,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                                              Verbosity=diagnostic;Encoding=UTF-8
 
                        -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1301,7 +1330,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: Je nutné zadat název položky pro přepínač getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1310,7 +1339,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: Je nutné zadat název vlastnosti pro přepínač getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1319,7 +1348,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: Je nutné zadat cílový název pro přepínač getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1460,29 +1489,6 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">Proces = {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}s)</target>
@@ -1606,7 +1612,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Při vytváření souborů řešení nebo souborů filtrů řešení nelze získat přístup k vlastnostem nebo položkám. Tato funkce je k dispozici jen při sestavování jednotlivých projektů.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index f29f73bd6ed..11259a0daee 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Fehler beim Buildvorgang. Eigenschaften, Elemente und Zielergebnisse können nicht abgerufen werden. Details finden Sie oben in stderr.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: Der Schalter "-noAutoResponse" kann weder in der automatischen Antwortdatei "MSBuild.rsp" noch in einer anderen Antwortdatei verwendet werden, auf die die automatische Antwortdatei verweist.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="new">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Führt dazu, dass MSBuild Dateizugriffe auf ein beliebiges konfiguriertes
+                     Projektcache-Plug-In meldet.
+
+                     Dieses Flag ist experimentell und funktioniert möglicherweise nicht wie vorgesehen.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Der Wert für den Zugriff auf die Berichtsdatei ist ungültig. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -538,11 +573,11 @@ Dies ist ein restriktiverer Modus von MSBuild, da er erfordert,
         <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax für die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollständiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
-                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
+                        {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
                      Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
@@ -820,11 +855,11 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax für die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollständiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
-                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
                      Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
@@ -1288,7 +1323,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: Es muss ein Elementname für den getItem-Switch angegeben werden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1332,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: Für den getProperty-Switch muss ein Eigenschaftenname angegeben werden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1341,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: Für den GetTargetResult-Switch muss ein Zielname angegeben werden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1447,29 +1482,6 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">Prozess = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}s)</target>
@@ -1593,7 +1605,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Beim Erstellen von Projektmappendateien oder Projektmappenfilterdateien kann nicht auf Eigenschaften oder Elemente zugegriffen werden. Dieses Feature ist nur beim Erstellen einzelner Projekte verfügbar.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 65032455f70..5e02da6973e 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Error de compilación. No se pueden obtener los resultados de propiedades, elementos y destinos. Vea los detalles en stderr anterior.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: El modificador -noAutoResponse no puede especificarse en el archivo de respuesta automática MSBuild.rsp ni en ningún archivo de respuesta al que el archivo de respuesta automática haga referencia.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|Falso]
+                     Hace que MSBuild informe de los accesos a los archivos a cualquier
+                     complemento de caché de proyectos.
+
+                     Esta marca es experimental y puede que no funcione según lo previsto.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: el valor de acceso al archivo de informe no es válido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -536,18 +571,14 @@
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
         <target state="translated">  -logger:&lt;registrador&gt;   Use este registrador para registrar eventos
-                     de MSBuild. Para especificar varios registradores, especifique
-                     cada uno de ellos por separado.
+                     de MSBuild. Para especificar varios registradores, especifique cada uno de ellos por separado.
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;parámetros&gt;]
+                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;parámetros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de
-                       clase del registrador&gt;
-                     La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
-                       de ensamblado&gt;}
-                     Las opciones del registrador especifican cómo crea MSBuild
-                     el registrador.
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de clase del registrador&gt;
+                       La sintaxis de &lt;ensamblado del registrador&gt; es:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Las opciones del registrador especifican cómo crea MSBuild el registrador.
                      Los &lt;parámetros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -824,15 +855,12 @@
                      Para especificar varios registradores, especifique cada uno
                      de ellos por separado. (Forma corta: -dl)
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;parámetros&gt;]
+                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;parámetros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre
-                       de la clase del registrador&gt;
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de la clase del registrador&gt;
                      La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
-                      de ensamblado&gt;}
-                     Las opciones del registrador especifican cómo crea MSBuild
-                     el registrador.
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Las opciones del registrador especifican cómo crea MSBuild el registrador.
                      Los &lt;parámetros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -1295,7 +1323,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: debe proporcionar un nombre de elemento para el modificador getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1304,7 +1332,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: debe proporcionar un nombre de propiedad para el modificador getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1313,7 +1341,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: debe proporcionar un nombre de destino para el modificador getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1454,29 +1482,6 @@
         <target state="translated">Proceso: "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}s)</target>
@@ -1600,7 +1605,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: no se puede tener acceso a propiedades o elementos al compilar archivos de solución o archivos de filtro de soluciones. Esta característica solo está disponible al compilar proyectos individuales.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 80312d77ab5..8e0c9192e96 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Échec de la génération. Impossible d’obtenir les propriétés, les éléments et les résultats cibles. Consultez les détails dans stderr ci-dessus.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: Impossible de spécifier le commutateur -noAutoResponse dans le fichier réponse automatique MSBuild.rsp, ni dans aucun autre fichier réponse référencé par le fichier réponse automatique.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="new">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Entraîne le signalement par MSBuild des accès par fichiers aux plug-ins
+                     de cache de projet configurés.
+
+                     Cet indicateur est expérimental et peut ne pas fonctionner comme prévu.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: la valeur d’accès au fichier de rapport n’est pas valide. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -542,7 +577,7 @@ Cet indicateur est expérimental et peut ne pas fonctionner comme prévu.
                      Syntaxe de &lt;classe de journalisation&gt; :
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt; :
-                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Les options de journalisation spécifient la façon dont MSBuild crée le journaliseur.
                      Les &lt;paramètres de journalisation&gt; sont facultatifs. Ils sont passés
                      au journaliseur tels que vous les avez tapés. (Forme abrégée : -l)
@@ -824,7 +859,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
                      Syntaxe de &lt;classe de journalisation&gt; :
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt; :
-                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Les options de journalisation spécifient la façon dont MSBuild crée le journaliseur.
                      Les &lt;paramètres de journalisation&gt; sont facultatifs. Ils sont passés
                      au journaliseur tels que vous les avez tapés. (Forme abrégée : -l)
@@ -1288,7 +1323,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: Doit fournir un nom d'élément pour le commutateur getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1332,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: Doit fournir un nom de propriété pour le commutateur getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1341,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: Doit fournir un nom de cible pour le commutateur getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1447,29 +1482,6 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">Processus = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}s)</target>
@@ -1593,7 +1605,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Impossible d'accéder aux propriétés ou aux éléments lors de la création de fichiers de solution ou de fichiers de filtre de solution. Cette fonctionnalité est disponible uniquement lors de la génération de projets individuels.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 9a391602b01..03015b156c1 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Compilazione non riuscita. Non è possibile ottenere proprietà, elementi e risultati di destinazione. Vedere i dettagli in stderr sopra.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: non è possibile specificare l'opzione -noAutoResponse nel file di risposta automatica MSBuild.rsp o in file di risposta a cui il file di risposta automatica fa riferimento.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Fa in modo che MSBuild segnali gli accessi ai file a qualsiasi
+                     plug-in della cache del progetto.
+
+                     Questo flag è sperimentale e potrebbe non funzionare come previsto.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: il valore degli accessi al file di report non è valido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -548,8 +583,8 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; è la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;assembly logger&gt; è la seguente:
-                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
+                     La sintassi di &lt;logger assembly&gt; è la seguente:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger così come vengono digitati. Forma breve: -l.
@@ -830,8 +865,8 @@ Nota: livello di dettaglio dei logger di file
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; è la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;assembly logger&gt; è la seguente:
-                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
+                     La sintassi di &lt;logger assembly&gt; è la seguente:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger così come vengono digitati. Forma breve: -l
@@ -950,9 +985,8 @@ Nota: livello di dettaglio dei logger di file
                      è la directory corrente. Per impostazione predefinita, ai
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
-                     essere specificati aggiungendo l'opzione
+                     essere specificati aggiungendo l'opzione "-fileLoggerParameters".
 
-                     "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito userà il nome
                      file come modello e aggiungerà l'ID del nodo per creare un
@@ -1299,7 +1333,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: è necessario specificare un nome elemento per l'opzione getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1308,7 +1342,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: è necessario specificare un nome proprietà per l'opzione getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1317,7 +1351,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: è necessario specificare un nome destinazione per l'opzione getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1458,29 +1492,6 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}s)</target>
@@ -1604,7 +1615,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: non è possibile accedere a proprietà o elementi durante la compilazione di file di soluzione o file di filtro della soluzione. Questa funzionalità è disponibile solo durante la compilazione di singoli progetti.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
@@ -2022,16 +2033,15 @@ Esegue la profilatura della valutazione di MSBuild e scrive
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                      Imposta queste proprietà a livello di progetto o ne esegue
-                      l'override solo durante il ripristino e non usa le
-                      proprietà specificate con l'argomento -property.
-                      &lt;v&gt; rappresenta il nome della proprietà e &lt;v&gt; il
-                      valore della proprietà. Usare il punto e virgola o la
-                      virgola per delimitare più proprietà o specificare ogni
-                      proprietà separatamente.
-                      Forma breve: -rp.
-                      Esempio:
-                        -restoreProperty:IsRestore=true;MyProperty=value
+                     Imposta queste proprietà a livello di progetto o ne esegue
+                     l'override solo durante il ripristino e non usa le
+                     proprietà specificate con l'argomento -property.
+                     &lt;v&gt; rappresenta il nome della proprietà e &lt;v&gt; il
+                     valore della proprietà. Usare il punto e virgola o la
+                     virgola per delimitare più proprietà o specificare ogni proprietà separatamente.
+                     (Forma breve: -rp)
+                     Esempio:
+                       -restoreProperty:IsRestore=true;MyProperty=value
     </target>
         <note>
       LOCALIZATION: "-restoreProperty" and "-rp" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 35aa68724fe..533e64a7478 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">ビルドに失敗しました。プロパティ、項目、ターゲットの結果を取得できません。上の stderr で詳細を参照してください。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 自動応答ファイルや、自動応答ファイルによって参照される応答ファイルに -noAutoResponse スイッチを指定することはできません。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild が、構成されているプロジェクト キャッシュ プラグインへの
+                     ファイル アクセスを報告するようにします。
+
+                     このフラグは実験的なものであり、意図したとおりに動作しない可能性があります。
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -110,12 +135,22 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="translated">MSBUILD : error MSB1065: ターミナル ロガーの値が無効です。'auto'、'true'、または 'false' のいずれかである必要があります。 {0}</target>
+        <target state="translated">MSBUILD : error MSB1065: ターミナル ロガーの値が無効です。'auto'、'true'、または 'false' のいずれかである必要があります。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: レポート ファイルのアクセス値が無効です。 {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1288,7 +1323,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: getItem スイッチに項目名を指定する必要があります。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1332,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: getProperty スイッチにプロパティ名を指定する必要があります。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1341,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult スイッチにターゲット名を指定する必要があります。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1447,29 +1482,6 @@
         <target state="translated">プロセス = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3} 秒)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3} 秒)</target>
@@ -1593,7 +1605,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: ソリューション ファイルまたはソリューション フィルター ファイルを作成するときにプロパティや項目にアクセスすることはできません。この機能は、個々のプロジェクトをビルドする場合にのみ使用できます。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 47d973d6a67..bd9200d5539 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">빌드하지 못했습니다. 속성, 항목 및 대상 결과를 가져올 수 없습니다. 위의 stderr에서 세부 정보를 참조하세요.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 자동 지시 파일과 자동 지시 파일에서 참조하는 모든 지시 파일에는 -noAutoResponse 스위치를 지정할 수 없습니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="new">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild에서 모든 구성된 프로젝트 캐시 플러그 인에 대한
+                     파일 액세스를 보고하도록 합니다.
+
+                     이 플래그는 실험적이며 예상대로 작동하지 않을 수 있습니다.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: 보고서 파일 액세스 값이 잘못되었습니다. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -538,11 +573,11 @@
         <target state="translated">  -logger:&lt;로거&gt;   이 로거를 사용하여 MSBuild의 이벤트를 기록합니다. 여러
                      로거를 지정하려면 각 로거를 개별적으로 지정합니다.
                      &lt;로거&gt; 구문은 다음과 같습니다.
-                       [&lt;클래스&gt;,]&lt;어셈블리&gt;[,&lt;옵션&gt;][;&lt;매개 변수&gt;]
+                       [&lt;클래스&gt;,]&lt;assembly&gt;[,&lt;옵션&gt;][;&lt;매개 변수&gt;]
                      &lt;로거 클래스&gt; 구문은 다음과 같습니다.
                        [&lt;부분 또는 전체 네임스페이스&gt;.]&lt;로거 클래스 이름&gt;
                      &lt;로거 어셈블리&gt; 구문은 다음과 같습니다.
-                       {&lt;어셈블리 이름&gt;[,&lt;strong name&gt;] | &lt;어셈블리 파일&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      로거 옵션은 MSBuild가 로거를 만드는 방법을 지정합니다.
                      &lt;로거 매개 변수&gt;는 선택 사항이고 입력한 대로 정확히
                      로거에 전달됩니다. (약식: -l)
@@ -820,11 +855,11 @@
                      로거를 지정하려면 각 로거를 개별적으로 지정합니다.
                      (약식 -dl)
                      &lt;로거&gt; 구문은 다음과 같습니다.
-                       [&lt;클래스&gt;,]&lt;어셈블리&gt;[,&lt;옵션&gt;][;&lt;매개 변수&gt;]
+                       [&lt;클래스&gt;,]&lt;assembly&gt;[,&lt;옵션&gt;][;&lt;매개 변수&gt;]
                      &lt;로거 클래스&gt; 구문은 다음과 같습니다.
                        [&lt;부분 또는 전체 네임스페이스&gt;.]&lt;로거 클래스 이름&gt;
                      &lt;로거 어셈블리&gt; 구문은 다음과 같습니다.
-                       {&lt;어셈블리 이름&gt;[,&lt;strong name&gt;] | &lt;어셈블리 파일&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      로거 옵션은 MSBuild가 로거를 만드는 방법을 지정합니다.
                       &lt;로거 매개 변수&gt;는 선택 사항이고
                      입력한 대로 정확히 로거에 전달됩니다. (약식: -l)
@@ -1288,7 +1323,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: getItem 스위치의 항목 이름을 제공해야 합니다.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1332,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: getProperty 스위치의 속성 이름을 제공해야 합니다.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1341,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult 스위치의 대상 이름을 제공해야 합니다.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1447,29 +1482,6 @@
         <target state="translated">프로세스 = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}초)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}초)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}초)</target>
@@ -1593,7 +1605,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: 솔루션 파일 또는 솔루션 필터 파일을 빌드할 때 속성 또는 항목에 액세스할 수 없습니다. 이 기능은 개별 프로젝트를 빌드할 때만 사용할 수 있습니다.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 9d9bfb601d7..f4caceb0acc 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Kompilacja nie powiodła się. Nie można uzyskać wyników właściwości, elementów i celu. Zobacz szczegóły w sekcji stderr powyżej.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: przełącznika -noAutoResponse nie można określić w pliku autoodpowiedzi MSBuild.rsp ani w żadnym pliku odpowiedzi, do którego odwołuje się plik autoodpowiedzi.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Powoduje, że platforma MSBuild zgłasza dostępy do wszystkich skonfigurowanych
+                     wtyczek pamięci podręcznej projektu.
+
+                     Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: wartość dostępów do pliku raportu jest nieprawidłowa. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -540,17 +575,14 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;rejestrator&gt;  Umożliwia użycie podanego rejestratora do rejestrowania
-                         zdarzeń pochodzących z programu MSBuild. Aby określić
-                     wiele rejestratorów, określ każdy z nich osobno.
+        <target state="translated">  -logger:&lt;rejestrator&gt;  Umożliwia użycie podanego rejestratora do rejestrowania zdarzeń pochodzących
+                     z programu MSBuild. Aby określić wiele rejestratorów, określ każdy z nich osobno.
                      Składnia elementu &lt;rejestrator&gt;:
-                        [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
-                        [;&lt;parametry rejestratora&gt;]
+                      [&lt;klasa rejestratora&gt;,]&lt;assembly&gt; [;&lt;parametry rejestratora&gt;]
                      Składnia elementu &lt;klasa rejestratora&gt;:
-                        [&lt;częściowa lub pełna przestrzeń nazw&gt;.]
-                        &lt;nazwa klasy rejestratora&gt;
+                       [&lt;częściowa lub pełna przestrzeń nazw&gt;.] &lt;nazwa klasy rejestratora&gt;
                      Składnia elementu &lt;zestaw rejestratora&gt;:
-                        {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Wartości &lt;parametry rejestratora&gt; są opcjonalne i są
                      przekazywane do rejestratora dokładnie tak, jak zostały
                      wpisane. (Krótka wersja: -l)
@@ -829,11 +861,11 @@
                      wiele rejestratorów, określ każdy z nich osobno.
                      (Krótka wersja: -dl)
                      Składnia elementu &lt;rejestrator&gt;:
-                       [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;[;&lt;parametry rejestratora&gt;]
+                       [&lt;klasa rejestratora&gt;,]&lt;assembly&gt;[;&lt;parametry rejestratora&gt;]
                      Składnia elementu &lt;klasa rejestratora&gt;:
                        [&lt;częściowa lub pełna przestrzeń nazw&gt;.]&lt;nazwa klasy rejestratora&gt;
                      Składnia elementu &lt;zestaw rejestratora&gt;:
-                       {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Wartości &lt;parametry rejestratora&gt; są opcjonalne i są
                      przekazywane do rejestratora dokładnie tak, jak zostały
                      wpisane. (Krótka wersja: -l)
@@ -945,13 +977,11 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     Rejestruje dane wyjściowe kompilacji w wielu plikach
-                     dziennika, po jednym pliku na węzeł programu MSBuild.
-                     Początkową lokalizacją tych plików jest bieżący katalog.
-                     Domyślnie pliki mają nazwę
+                     Rejestruje dane wyjściowe kompilacji w wielu plikach dziennika,po jednym pliku
+                     na węzeł programu MSBuild. Początkową lokalizacją tych plików
+                     jest bieżący katalog. Domyślnie pliki mają nazwę
                      „MSBuild&lt;identyfikator węzła&gt;.log”. Lokalizację plików
                      i inne parametry rejestratora plików można określić
-
                      przez dodanie przełącznika „-fileLoggerParameters”.
 
                      Jeśli nazwa pliku zostanie ustawiona za pomocą przełącznika
@@ -1299,7 +1329,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: Musi podać nazwę elementu dla przełącznika getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1308,7 +1338,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: Musi podać nazwę właściwości dla przełącznika getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1317,7 +1347,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: Musi podać nazwę celu dla przełącznika getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1458,29 +1488,6 @@
         <target state="translated">Proces = „{0}”</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}s)</target>
@@ -1604,7 +1611,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Nie można uzyskać dostępu do właściwości lub elementów podczas tworzenia plików rozwiązań lub plików filtrów rozwiązań. Ta funkcja jest dostępna tylko podczas tworzenia pojedynczych projektów.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 4c60b3fbda2..f84a9fbf2fa 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Falha na compilação. Não foi possível obter os resultados de Propriedades, Itens e Destino. Veja os detalhes no stderr acima.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: A opção /noAutoResponse não pode ser especificada no arquivo de resposta automática MSBuild.rsp nem em qualquer arquivo de resposta usado como referência para o arquivo de resposta automática.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,25 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Faz com que o MSBuild relate acessos a arquivos a qualquer
+ configurado
+                     plug-ins de cache do projeto.
+
+                     Este sinalizador é experimental e pode não funcionar conforme o esperado.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +142,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: o valor de acesso ao arquivo de relatório não é válido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1289,7 +1325,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: É preciso fornecer um nome de item para a chave getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1298,7 +1334,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: É preciso fornecer um nome de propriedade para a chave getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1307,7 +1343,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: É preciso fornecer um nome de destino para a chave getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1448,29 +1484,6 @@ arquivo de resposta.
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}s)</target>
@@ -1594,7 +1607,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Não foi possível acessar propriedades ou itens ao compilar arquivos de solução ou arquivos de filtro de solução. Esse recurso só está disponível para a compilação de projetos individuais.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index e94db7008c0..f47e63ce4c4 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Сборка не удалась. Не удается получить свойства, элементы и целевые результаты. См. подробности в stderr выше.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: ключ noAutoResponse не может быть указан в файле автоответа MSBuild.rsp или в любом другом файле ответа, на который файл автоответа ссылается.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="new">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Включение отчетов MSBuild о доступе к файлам для всех настроенных
+                     подключаемых модулей кэша проекта.
+
+                     Этот флаг является экспериментальным и может работать неправильно.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -110,12 +135,22 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="new">MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</target>
+        <target state="translated">MSBUILD : error MSB1065: Недопустимое значение средства ведения журнала терминала. Это должно быть одно из следующих значений: "auto", "ИСТИНА" или "ЛОЖЬ". {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: переданное значение отчета о доступе к файлам является недопустимым. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1287,7 +1322,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: необходимо указать имя элемента для переключателя getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1296,7 +1331,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: необходимо указать имя свойства для переключателя getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1305,7 +1340,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: необходимо указать целевое имя для переключателя getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1446,29 +1481,6 @@
         <target state="translated">Процесс = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3} с)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4} с)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3} с)</target>
@@ -1592,7 +1604,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: не удается получить доступ к свойствам или элементам при создании файлов решений или файлов фильтров решений. Эта функция доступна только при создании отдельных проектов.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index f2ee8ee03a4..762af4f5778 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Derleme başarısız oldu. Özellikler, Öğeler ve Hedef sonuçları alınamıyor. Yukarıda stderr'de ayrıntılara bakın.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse anahtarı, MSBuild.rsp otomatik yanıt dosyasında ve bu dosyanın başvuruda bulunduğu herhangi bir yanıt dosyasında belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="new">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild’in yapılandırılmış proje önbelleği eklentilerine dosya
+                     erişimlerini bildirmesine neden olur.
+
+                     Bu bayrak deneme amaçlıdır ve istendiği gibi çalışmayabilir.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Dosya erişimleri değerinin geçerli olmadığını bildirir. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -538,13 +573,13 @@
         <target state="translated">  -logger:&lt;günlükçü&gt;   MSBuild'deki olayları günlüğe almak için bu günlükçüyü kullanın. Birden fazla
                      günlükçü belirtmek için her günlükçüyü ayrı ayrı belirtin.
                      &lt;günlükçü&gt; söz dizimi şöyledir:
-                       [&lt;sınıf&gt;,]&lt;derleme&gt;[,&lt;seçenekler&gt;][;&lt;parametreler&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;günlükçü sınıfı &gt; söz dizimi şöyledir:
                        [&lt;kısmi veya tam ad alanı &gt;.]&lt;günlükçü sınıfı adı&gt;
                      &lt;günlükçü derlemesi&gt; söz dizimi şöyledir:
-                       {&lt;derleme adı&gt;[,&lt;strong name&gt;] | &lt;derleme dosyası&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Günlükçü seçenekleri, MSBuild'in günlükçüyü oluşturma biçimini belirtir.
-                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak 
+                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak
                      yazdığınız şekliyle günlükçüye geçirilir. (Kısa biçim: -l)
                      Örnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -820,11 +855,11 @@
                      günlükçü belirtmek için her günlükçüyü ayrı ayrı belirtin.
                      (Kısa biçim -dl)
                      &lt;günlükçü&gt; söz dizimi şöyledir:
-                       [&lt;sınıf&gt;,]&lt;derleme&gt;[,&lt;seçenekler&gt;][;&lt;parametreler&gt;]
+                       [&lt;sınıf&gt;,]&lt;assembly&gt;[,&lt;seçenekler&gt;][;&lt;parametreler&gt;]
                      &lt;günlükçü sınıfı&gt; söz dizimi şöyledir:
                        [&lt;kısmi veya tam ad alanı&gt;.]&lt;günlükçü sınıfı adı&gt;
                      &lt;günlükçü derlemesi&gt; söz dizimi şöyledir:
-                       {&lt;derleme adı&gt;[,&lt;strong name&gt;] | &lt;derleme dosyası&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Günlükçü seçenekleri, MSBuild'in günlükçüyü oluşturma biçimini belirtir.
                      &lt;günlükçü parametreleri&gt; isteğe bağlıdır ve tam olarak
                      yazdığınız şekliyle günlükçüye geçirilir. (Kısa biçim: -l)
@@ -851,10 +886,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantılar&gt;
-                     Hangi proje dosyasının oluşturulacağı belirlenirken 
-                     yoksayılacak uzantıların listesi. Birden çok uzantıyı 
-                     birbirinden ayırmak için noktalı virgül veya 
-                     virgül kullanın.
+                     Hangi proje dosyasının oluşturulacağı belirlenirken
+                     yoksayılacak uzantıların listesi. Birden çok uzantıyı
+                     birbirinden ayırmak için noktalı virgül veya virgül kullanın.
                      (Kısa biçim: -ignore)
                      Örnek:
                        -ignoreProjectExtensions:.sln
@@ -944,7 +978,6 @@
                      Dosyaların konumu ve fileLogger'ın diğer parametreleri 
                      "/fileLoggerParameters" anahtarının eklenmesi yoluyla
                      belirtilebilir.
-
                      Günlük dosyası adı fileLoggerParameters anahtarı
                      aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName 
                      değerini şablon olarak kullanıp her düğümün günlük dosyasını
@@ -991,32 +1024,31 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya günlükçüleri için ek parametreler sağlar.
-                     Bu anahtarın olması karşılık gelen -fileLogger[n] 
+                     Bu anahtarın olması karşılık gelen -fileLogger[n]
                      anahtarının olduğu anlamına gelir.
                      "n" varsa, 1-9 arasında bir rakam olabilir.
-                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters 
-                     bunlar tarafından da kullanılır; -distributedFileLogger 
-                     açıklamasına bakın.
+                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters
+                     bunlar tarafından da kullanılır; -distributedFileLogger açıklamasına bakın.
                      (Kısa biçim: -flp[n])
-                     Konsol günlükçüsü için listelenenlerle aynı parametreler 
+                     Konsol günlükçüsü için listelenenlerle aynı parametreler
                      kullanılabilir. Kullanılabilecek bazı ek parametreler:
-                        LogFile--Oluşturma günlüğünün yazılacağı günlük 
+                        LogFile--Oluşturma günlüğünün yazılacağı günlük
                             dosyasının yolu.
-                        Append--Derleme günlüğünün gün dosyasının sonuna mı 
-                            ekleneceğini yoksa üzerine mi yazılacağını 
-                            belirler. Anahtar ayarlandığında oluşturma günlüğü 
-                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında 
-                            varolan günlük dosyasının üzerine yazılır. 
+                        Append--Derleme günlüğünün gün dosyasının sonuna mı
+                            ekleneceğini yoksa üzerine mi yazılacağını
+                            belirler. Anahtar ayarlandığında oluşturma günlüğü
+                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında
+                            varolan günlük dosyasının üzerine yazılır.
                             Varsayılan: günlük dosyasının sonuna eklenmez.
-                        Encoding--Dosyanın kodlamasını belirtir; örneğin, 
+                        Encoding--Dosyanın kodlamasını belirtir; örneğin,
                             UTF-8, Unicode veya ASCII
                      Varsayılan ayrıntı düzeyi ayarı Detailed'dır.
                      Örnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1040,8 +1072,7 @@
                        -nr:true
     </source>
         <target state="translated">  -nodeReuse:&lt;parametreler&gt;
-                     MSBuild düğümlerinin yeniden kullanımını etkinleştirir
-                     veya devre dışı bırakır.
+                     MSBuild düğümlerinin yeniden kullanımını etkinleştirir veya devre dışı bırakır.
                      Parametreler:
                      True --Derleme tamamlandıktan sonra düğümler kalır ve
                             izleyen derlemelerde yeniden kullanılır (varsayılan)
@@ -1292,7 +1323,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: getItem anahtarı için bir öğe adı sağlanması gerekiyor.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1301,7 +1332,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: getProperty anahtarı için bir özellik adı belirtilmelidir.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1310,7 +1341,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult anahtarı için bir hedef adı sağlanması gerekiyor.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1372,7 +1403,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters anahtarı kullanılıyorsa terminal günlükçüsü için bir veya birden çok parametre belirtin</target>
+        <target state="translated">MSBUILD : error MSB1066: terminalLoggerParameters anahtarı kullanılıyorsa terminal günlükçüsü için bir veya birden çok parametre belirtin</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1451,29 +1482,6 @@
         <target state="translated">İşlem = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}sn)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3}({4}sn)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3}sn)</target>
@@ -1597,7 +1605,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Çözüm dosyaları veya çözüm filtresi dosyaları oluşturulurken özelliklere veya öğelere erişilemiyor. Bu özellik yalnızca tek tek projeler oluşturulurken kullanılabilir.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index d1f839fc7b7..12f6f98c04d 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">生成失败。无法获取属性、项目和目标结果。在上面的 stderr 中查看详细信息。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: 不能在 MSBuild.rsp 自动响应文件中或由该自动响应文件引用的任何响应文件中指定 -noAutoResponse 开关。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="new">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     导致 MSBuild 报告对任何已配置
+                     项目缓存插件的文件访问。
+
+                     此标志是实验性的，可能无法按预期工作。
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: 报表文件访问值无效。{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1288,7 +1323,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: 必须为 getItem 开关提供项名称。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1332,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: 必须为 getProperty 开关提供属性名称。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1341,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: 必须为 getTargetResult 开关提供目标名称。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1447,29 +1482,6 @@
         <target state="translated">进程 = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3})</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4})</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3})</target>
@@ -1593,7 +1605,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: 生成解决方案文件或解决方案筛选器文件时无法访问属性或项。此功能仅在生成单个项目时可用。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 4e6f1da310b..2a4877909af 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">建置失敗。無法取得屬性、項目及目標結果。請參閱上述 stderr 中的詳細資料。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -77,6 +77,13 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse 參數不能在 MSBuild.rsp 自動回應檔中指定，也不能在自動回應檔所參考的任何回應檔中指定。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1} 秒)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+      </note>
+      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -96,6 +103,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     導致 MSBuild 報告任何已設定之專案快取外掛程式的
+                     檔案存取。
+
+                     此旗標為實驗性質，可能無法如預期般運作。
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +141,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: 報告檔案存取值無效。{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -538,11 +573,11 @@
         <target state="translated">  -logger:&lt;記錄器&gt;   使用此記錄器可記錄 MSBuild 的事件。
                      若要指定多個記錄器，請各別指定每個記錄器。
                      &lt;記錄器&gt; 語法為:
-                       [&lt;類別&gt;,]&lt;組件&gt;[,&lt;選項&gt;][;&lt;參數&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;記錄器類別&gt; 語法為:
                        [&lt;一部分或完整的命名空間&gt;.]&lt;記錄器類別名稱&gt;
                      &lt;記錄器組件&gt; 語法為:
-                       {&lt;組件名稱&gt;[,&lt;strong name&gt;] | &lt;組件檔案&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      記錄器選項會指定 MSBuild 建立記錄器的方式。
                      &lt;記錄器參數&gt; 是選擇性參數，其會依您輸入的內容，
                      完全一樣地傳遞到記錄器。(簡短形式: -l)
@@ -820,11 +855,11 @@
                      若要指定多個記錄器，請各別指定每個記錄器。
                      (簡短形式 -dl)
                      &lt;記錄器&gt; 語法為:
-                       [&lt;類別&gt;,]&lt;組件&gt;[,&lt;選項&gt;][;&lt;參數&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;記錄器類別&gt; 語法為:
                        [&lt;一部分或完整的命名空間&gt;.]&lt;記錄器類別名稱&gt;
                      &lt;記錄器組件&gt; 語法為:
-                       {&lt;組件名稱&gt;[,&lt;strong name&gt;] | &lt;組件檔案&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      記錄器選項會指定 MSBuild 建立記錄器的方式。
                      &lt;記錄器參數&gt; 是選擇性參數，其會依您輸入的內容，
                      完全一樣地傳遞到記錄器。(簡短形式: -l)
@@ -1288,7 +1323,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: 必須提供 getItem 切換的項目名稱。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1332,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: 必須提供 getProperty 切換的屬性名稱。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1341,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: 必須提供 getTargetResult 切換的目標名稱。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1447,29 +1482,6 @@
         <target state="translated">流程 = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectBuilding_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3} 秒)</target>
-        <note>
-      Project building.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target
-      {3}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectBuilding_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
-        <note>
-      Project building including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: target
-      {4}: duration in seconds with 1 decimal point
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
         <target state="translated">{0}{1} {2} ({3} 秒)</target>
@@ -1593,7 +1605,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: 建置方案檔案或方案篩選檔案時，無法存取屬性或項目。此功能僅於建置個別專案時可用。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/TerminalLogger/NodeStatus.cs b/src/MSBuild/TerminalLogger/NodeStatus.cs
new file mode 100644
index 00000000000..d199edc461c
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/NodeStatus.cs
@@ -0,0 +1,58 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// Encapsulates the per-node data shown in live node output.
+/// </summary>
+internal class NodeStatus
+{
+    public string Project { get; }
+    public string? TargetFramework { get; }
+    public string Target { get; }
+    public StopwatchAbstraction Stopwatch { get; }
+
+    public NodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)
+    {
+        Project = project;
+        TargetFramework = targetFramework;
+        Target = target;
+        Stopwatch = stopwatch;
+    }
+
+    /// <summary>
+    /// Equality is based on the project, target framework, and target, but NOT the elapsed time.
+    /// </summary>
+    public override bool Equals(object? obj) =>
+        obj is NodeStatus status &&
+        Project == status.Project &&
+        TargetFramework == status.TargetFramework &&
+        Target == status.Target;
+
+    public override string ToString()
+    {
+        string duration = Stopwatch.ElapsedSeconds.ToString("F1");
+
+        return string.IsNullOrEmpty(TargetFramework)
+            ? string.Format("{0}{1} {2} ({3}s)",
+                TerminalLogger.Indentation,
+                Project,
+                Target,
+                duration)
+            : string.Format("{0}{1} {2} {3} ({4}s)",
+                TerminalLogger.Indentation,
+                Project,
+                AnsiCodes.Colorize(TargetFramework, TerminalLogger.TargetFrameworkColor),
+                Target,
+                duration);
+    }
+
+    public override int GetHashCode()
+    {
+        throw new System.NotImplementedException();
+    }
+}
diff --git a/src/MSBuild/TerminalLogger/NodesFrame.cs b/src/MSBuild/TerminalLogger/NodesFrame.cs
new file mode 100644
index 00000000000..33fbf2c8d42
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/NodesFrame.cs
@@ -0,0 +1,139 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+
+using System.Text;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+/// <summary>
+/// Capture states on nodes to be rendered on display.
+/// </summary>
+internal sealed class NodesFrame
+{
+    private const int MaxColumn = 120;
+
+    private readonly (NodeStatus nodeStatus, int durationLength)[] _nodes;
+
+    private readonly StringBuilder _renderBuilder = new();
+
+    public int Width { get; }
+    public int Height { get; }
+    public int NodesCount { get; private set; }
+
+    public NodesFrame(NodeStatus?[] nodes, int width, int height)
+    {
+        Width = Math.Min(width, MaxColumn);
+        Height = height;
+
+        _nodes = new (NodeStatus, int)[nodes.Length];
+
+        foreach (NodeStatus? status in nodes)
+        {
+            if (status is not null)
+            {
+                _nodes[NodesCount++].nodeStatus = status;
+            }
+        }
+    }
+
+    internal ReadOnlySpan<char> RenderNodeStatus(int i)
+    {
+        NodeStatus status = _nodes[i].nodeStatus;
+
+        string durationString = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+            "DurationDisplay",
+            status.Stopwatch.ElapsedSeconds);
+
+        _nodes[i].durationLength = durationString.Length;
+
+        string project = status.Project;
+        string? targetFramework = status.TargetFramework;
+        string target = status.Target;
+
+        int renderedWidth = Length(durationString, project, targetFramework, target);
+
+        if (renderedWidth > Width)
+        {
+            renderedWidth -= target.Length;
+            target = string.Empty;
+
+            if (renderedWidth > Width)
+            {
+                int lastDotInProject = project.LastIndexOf('.');
+                renderedWidth -= lastDotInProject;
+                project = project.Substring(lastDotInProject + 1);
+
+                if (renderedWidth > Width)
+                {
+                    return project.AsSpan();
+                }
+            }
+        }
+
+        return $"{TerminalLogger.Indentation}{project}{(targetFramework is null ? string.Empty : " ")}{AnsiCodes.Colorize(targetFramework, TerminalLogger.TargetFrameworkColor)} {AnsiCodes.SetCursorHorizontal(MaxColumn)}{AnsiCodes.MoveCursorBackward(target.Length + durationString.Length + 1)}{target} {durationString}".AsSpan();
+
+        static int Length(string durationString, string project, string? targetFramework, string target) =>
+                TerminalLogger.Indentation.Length +
+                project.Length + 1 +
+                (targetFramework?.Length ?? -1) + 1 +
+                target.Length + 1 +
+                durationString.Length;
+    }
+
+    /// <summary>
+    /// Render VT100 string to update from current to next frame.
+    /// </summary>
+    public string Render(NodesFrame previousFrame)
+    {
+        StringBuilder sb = _renderBuilder;
+        sb.Clear();
+
+        int i = 0;
+        for (; i < NodesCount; i++)
+        {
+            ReadOnlySpan<char> needed = RenderNodeStatus(i);
+
+            // Do we have previous node string to compare with?
+            if (previousFrame.NodesCount > i)
+            {
+                if (previousFrame._nodes[i] == _nodes[i])
+                {
+                    // Same everything except time, AND same number of digits in time
+                    string durationString = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DurationDisplay", _nodes[i].nodeStatus.Stopwatch.ElapsedSeconds);
+                    sb.Append($"{AnsiCodes.SetCursorHorizontal(MaxColumn)}{AnsiCodes.MoveCursorBackward(durationString.Length)}{durationString}");
+                }
+                else
+                {
+                    // TODO: check components to figure out skips and optimize this
+                    sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
+                    sb.Append(needed);
+                }
+            }
+            else
+            {
+                // From now on we have to simply WriteLine
+                sb.Append(needed);
+            }
+
+            // Next line
+            sb.AppendLine();
+        }
+
+        // clear no longer used lines
+        if (i < previousFrame.NodesCount)
+        {
+            sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInDisplay}");
+        }
+
+        return sb.ToString();
+    }
+
+    public void Clear()
+    {
+        NodesCount = 0;
+    }
+}
diff --git a/src/MSBuild/TerminalLogger/Project.cs b/src/MSBuild/TerminalLogger/Project.cs
index 5ed03039bcc..3f027249782 100644
--- a/src/MSBuild/TerminalLogger/Project.cs
+++ b/src/MSBuild/TerminalLogger/Project.cs
@@ -16,15 +16,25 @@ internal sealed class Project
     /// Initialized a new <see cref="Project"/> with the given <paramref name="targetFramework"/>.
     /// </summary>
     /// <param name="targetFramework">The target framework of the project or null if not multi-targeting.</param>
-    public Project(string? targetFramework)
+    public Project(string? targetFramework, StopwatchAbstraction? stopwatch)
     {
         TargetFramework = targetFramework;
+
+        if (stopwatch is not null)
+        {
+            stopwatch.Start();
+            Stopwatch = stopwatch;
+        }
+        else
+        {
+            Stopwatch = SystemStopwatch.StartNew();
+        }
     }
 
     /// <summary>
     /// A stopwatch to time the build of the project.
     /// </summary>
-    public Stopwatch Stopwatch { get; } = Stopwatch.StartNew();
+    public StopwatchAbstraction Stopwatch { get; }
 
     /// <summary>
     /// Full path to the primary output of the project, if known.
diff --git a/src/MSBuild/TerminalLogger/StopwatchAbstraction.cs b/src/MSBuild/TerminalLogger/StopwatchAbstraction.cs
new file mode 100644
index 00000000000..8b365517a6a
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/StopwatchAbstraction.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+internal abstract class StopwatchAbstraction
+{
+    public abstract void Start();
+    public abstract void Stop();
+
+    public abstract double ElapsedSeconds { get; }
+}
diff --git a/src/MSBuild/TerminalLogger/SystemStopwatch.cs b/src/MSBuild/TerminalLogger/SystemStopwatch.cs
new file mode 100644
index 00000000000..2f03092971c
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/SystemStopwatch.cs
@@ -0,0 +1,24 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics;
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+internal sealed class SystemStopwatch : StopwatchAbstraction
+{
+    private Stopwatch _stopwatch = new ();
+
+    public override double ElapsedSeconds => _stopwatch.Elapsed.TotalSeconds;
+
+    public override void Start() => _stopwatch.Start();
+    public override void Stop() => _stopwatch.Stop();
+
+    public static StopwatchAbstraction StartNew()
+    {
+        SystemStopwatch wallClockStopwatch = new();
+        wallClockStopwatch.Start();
+
+        return wallClockStopwatch;
+    }
+}
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index ffb06c9e550..f317fd6c1b8 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -1,15 +1,16 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
-
-using System.Text;
+using System.Linq;
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Runtime.InteropServices;
+using System.Text.RegularExpressions;
+#if NET7_0_OR_GREATER
+using System.Diagnostics.CodeAnalysis;
+#endif
 #if NETFRAMEWORK
 using Microsoft.IO;
 #else
@@ -24,8 +25,21 @@ namespace Microsoft.Build.Logging.TerminalLogger;
 /// <remarks>
 /// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.
 /// </remarks>
-internal sealed class TerminalLogger : INodeLogger
+internal sealed partial class TerminalLogger : INodeLogger
 {
+    private const string FilePathPattern = " -> ";
+
+#if NET7_0_OR_GREATER
+    [StringSyntax(StringSyntaxAttribute.Regex)]
+    private const string ImmediateMessagePattern = @"\[CredentialProvider\]|--interactive";
+    private const RegexOptions Options = RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.ExplicitCapture;
+
+    [GeneratedRegex(ImmediateMessagePattern, Options)]
+    private static partial Regex ImmediateMessageRegex();
+#else
+    private static readonly string[] _immediateMessageKeywords = { "[CredentialProvider]", "--interactive" };
+#endif
+
     /// <summary>
     /// A wrapper over the project context ID passed to us in <see cref="IEventSource"/> logger events.
     /// </summary>
@@ -36,36 +50,14 @@ public ProjectContext(BuildEventContext context)
         { }
     }
 
-    /// <summary>
-    /// Encapsulates the per-node data shown in live node output.
-    /// </summary>
-    internal record NodeStatus(string Project, string? TargetFramework, string Target, Stopwatch Stopwatch)
-    {
-        public override string ToString()
-        {
-            string duration = Stopwatch.Elapsed.TotalSeconds.ToString("F1");
-
-            return string.IsNullOrEmpty(TargetFramework)
-                ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectBuilding_NoTF",
-                    Indentation,
-                    Project,
-                    Target,
-                    duration)
-                : ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectBuilding_WithTF",
-                    Indentation,
-                    Project,
-                    AnsiCodes.Colorize(TargetFramework, TargetFrameworkColor),
-                    Target,
-                    duration);
-        }
-    }
-
     /// <summary>
     /// The indentation to use for all build output.
     /// </summary>
-    private const string Indentation = "  ";
+    internal const string Indentation = "  ";
 
-    private const TerminalColor TargetFrameworkColor = TerminalColor.Cyan;
+    internal const TerminalColor TargetFrameworkColor = TerminalColor.Cyan;
+
+    internal Func<StopwatchAbstraction>? CreateStopwatch = null;
 
     /// <summary>
     /// Protects access to state shared between the logger callbacks and the rendering thread.
@@ -115,9 +107,14 @@ public override string ToString()
     /// </summary>
     private bool _restoreFailed;
 
+    /// <summary>
+    /// True if restore happened and finished.
+    /// </summary>
+    private bool _restoreFinished = false;
+
     /// <summary>
     /// The project build context corresponding to the <c>Restore</c> initial target, or null if the build is currently
-    /// bot restoring.
+    /// not restoring.
     /// </summary>
     private ProjectContext? _restoreContext;
 
@@ -192,12 +189,16 @@ internal TerminalLogger(ITerminal terminal)
     public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }
 
     /// <inheritdoc/>
-    public string Parameters { get => ""; set { } }
+    public string Parameters
+    {
+        get => ""; set { }
+    }
 
     /// <inheritdoc/>
     public void Initialize(IEventSource eventSource, int nodeCount)
     {
-        _nodes = new NodeStatus[nodeCount];
+        // When MSBUILDNOINPROCNODE enabled, NodeId's reported by build start with 2. We need to reserve an extra spot for this case.
+        _nodes = new NodeStatus[nodeCount + 1];
 
         Initialize(eventSource);
     }
@@ -226,7 +227,10 @@ public void Initialize(IEventSource eventSource)
     /// <inheritdoc/>
     public void Shutdown()
     {
+        _cts.Cancel();
+        _refresher?.Join();
         Terminal.Dispose();
+        _cts.Dispose();
     }
 
     #endregion
@@ -316,13 +320,15 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)
             {
                 targetFramework = null;
             }
-            _projects[c] = new(targetFramework);
-        }
+            _projects[c] = new(targetFramework, CreateStopwatch?.Invoke());
 
-        if (e.TargetNames == "Restore")
-        {
-            _restoreContext = c;
-            _nodes[0] = new NodeStatus(e.ProjectFile!, null, "Restore", _projects[c].Stopwatch);
+            // First ever restore in the build is starting.
+            if (e.TargetNames == "Restore" && !_restoreFinished)
+            {
+                _restoreContext = c;
+                int nodeIndex = NodeIndexForContext(buildEventContext);
+                _nodes[nodeIndex] = new NodeStatus(e.ProjectFile!, null, "Restore", _projects[c].Stopwatch);
+            }
         }
     }
 
@@ -340,10 +346,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
         // Mark node idle until something uses it again
         if (_restoreContext is null)
         {
-            lock (_lock)
-            {
-                _nodes[NodeIndexForContext(buildEventContext)] = null;
-            }
+            UpdateNodeStatus(buildEventContext, null);
         }
 
         ProjectContext c = new(buildEventContext);
@@ -357,7 +360,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                 {
                     EraseNodes();
 
-                    string duration = project.Stopwatch.Elapsed.TotalSeconds.ToString("F1");
+                    string duration = project.Stopwatch.ElapsedSeconds.ToString("F1");
                     ReadOnlyMemory<char>? outputPath = project.OutputPath;
 
                     string projectFile = e.ProjectFile is not null ?
@@ -395,6 +398,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                         }
 
                         _restoreContext = null;
+                        _restoreFinished = true;
                     }
                     // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.
                     else if (project.OutputPath is not null || project.BuildMessages is not null)
@@ -495,10 +499,16 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)
 
             string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);
             NodeStatus nodeStatus = new(projectFile, project.TargetFramework, e.TargetName, project.Stopwatch);
-            lock (_lock)
-            {
-                _nodes[NodeIndexForContext(buildEventContext)] = nodeStatus;
-            }
+            UpdateNodeStatus(buildEventContext, nodeStatus);
+        }
+    }
+
+    private void UpdateNodeStatus(BuildEventContext buildEventContext, NodeStatus? nodeStatus)
+    {
+        lock (_lock)
+        {
+            int nodeIndex = NodeIndexForContext(buildEventContext);
+            _nodes[nodeIndex] = nodeStatus;
         }
     }
 
@@ -518,10 +528,7 @@ private void TaskStarted(object sender, TaskStartedEventArgs e)
         if (_restoreContext is null && buildEventContext is not null && e.TaskName == "MSBuild")
         {
             // This will yield the node, so preemptively mark it idle
-            lock (_lock)
-            {
-                _nodes[NodeIndexForContext(buildEventContext)] = null;
-            }
+            UpdateNodeStatus(buildEventContext, null);
 
             if (_projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
             {
@@ -546,7 +553,7 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
         {
             // Detect project output path by matching high-importance messages against the "$(MSBuildProjectName) -> ..."
             // pattern used by the CopyFilesToOutputDirectory target.
-            int index = message.IndexOf(" -> ", StringComparison.Ordinal);
+            int index = message.IndexOf(FilePathPattern, StringComparison.Ordinal);
             if (index > 0)
             {
                 var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());
@@ -558,6 +565,11 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
                     project.OutputPath = outputPath;
                 }
             }
+
+            if (IsImmediateMessage(message))
+            {
+                RenderImmediateMessage(message);
+            }
         }
     }
 
@@ -566,16 +578,14 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
     /// </summary>
     private void WarningRaised(object sender, BuildWarningEventArgs e)
     {
-        var buildEventContext = e.BuildEventContext;
-        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
-        {
-            string message = EventArgsFormatting.FormatEventMessage(
+        BuildEventContext? buildEventContext = e.BuildEventContext;
+        string message = EventArgsFormatting.FormatEventMessage(
                 category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
                 subcategory: e.Subcategory,
                 message: e.Message,
                 code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
                 file: HighlightFileName(e.File),
-                projectFile: null,
+                projectFile: e.ProjectFile ?? null,
                 lineNumber: e.LineNumber,
                 endLineNumber: e.EndLineNumber,
                 columnNumber: e.ColumnNumber,
@@ -583,25 +593,48 @@ private void WarningRaised(object sender, BuildWarningEventArgs e)
                 threadId: e.ThreadId,
                 logOutputProperties: null);
 
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        {
+            if (IsImmediateMessage(message))
+            {
+                RenderImmediateMessage(message);
+            }
+
             project.AddBuildMessage(MessageSeverity.Warning, message);
         }
+        else
+        {
+            // It is necessary to display warning messages reported by MSBuild, even if it's not tracked in _projects collection.
+            RenderImmediateMessage(message);
+            _buildHasWarnings = true;
+        }
     }
 
+    /// <summary>
+    /// Detect markers that require special attention from a customer.
+    /// </summary>
+    /// <param name="message">Raised event.</param>
+    /// <returns>true if marker is detected.</returns>
+    private bool IsImmediateMessage(string message) =>
+#if NET7_0_OR_GREATER
+        ImmediateMessageRegex().IsMatch(message);
+#else
+        _immediateMessageKeywords.Any(imk => message.IndexOf(imk, StringComparison.OrdinalIgnoreCase) >= 0);
+#endif
+
     /// <summary>
     /// The <see cref="IEventSource.ErrorRaised"/> callback.
     /// </summary>
     private void ErrorRaised(object sender, BuildErrorEventArgs e)
     {
-        var buildEventContext = e.BuildEventContext;
-        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
-        {
-            string message = EventArgsFormatting.FormatEventMessage(
+        BuildEventContext? buildEventContext = e.BuildEventContext;
+        string message = EventArgsFormatting.FormatEventMessage(
                 category: AnsiCodes.Colorize("error", TerminalColor.Red),
                 subcategory: e.Subcategory,
                 message: e.Message,
                 code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
                 file: HighlightFileName(e.File),
-                projectFile: null,
+                projectFile: e.ProjectFile ?? null,
                 lineNumber: e.LineNumber,
                 endLineNumber: e.EndLineNumber,
                 columnNumber: e.ColumnNumber,
@@ -609,8 +642,16 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
                 threadId: e.ThreadId,
                 logOutputProperties: null);
 
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        {
             project.AddBuildMessage(MessageSeverity.Error, message);
         }
+        else
+        {
+            // It is necessary to display error messages reported by MSBuild, even if it's not tracked in _projects collection.
+            RenderImmediateMessage(message);
+            _buildHasErrors = true;
+        }
     }
 
     #endregion
@@ -622,10 +663,9 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
     /// </summary>
     private void ThreadProc()
     {
-        while (!_cts.IsCancellationRequested)
+        // 1_000 / 30 is a poor approx of 30Hz
+        while (!_cts.Token.WaitHandle.WaitOne(1_000 / 30))
         {
-            Thread.Sleep(1_000 / 30); // poor approx of 30Hz
-
             lock (_lock)
             {
                 DisplayNodes();
@@ -681,137 +721,6 @@ private void EraseNodes()
         _currentFrame.Clear();
     }
 
-    /// <summary>
-    /// Capture states on nodes to be rendered on display.
-    /// </summary>
-    private sealed class NodesFrame
-    {
-        private readonly List<string> _nodeStrings = new();
-        private readonly StringBuilder _renderBuilder = new();
-
-        public int Width { get; }
-        public int Height { get; }
-        public int NodesCount { get; private set; }
-
-        public NodesFrame(NodeStatus?[] nodes, int width, int height)
-        {
-            Width = width;
-            Height = height;
-            Init(nodes);
-        }
-
-        public string NodeString(int index)
-        {
-            if (index >= NodesCount)
-            {
-                throw new ArgumentOutOfRangeException(nameof(index));
-            }
-
-            return _nodeStrings[index];
-        }
-
-        private void Init(NodeStatus?[] nodes)
-        {
-            int i = 0;
-            foreach (NodeStatus? n in nodes)
-            {
-                if (n is null)
-                {
-                    continue;
-                }
-                string str = n.ToString();
-
-                if (i < _nodeStrings.Count)
-                {
-                    _nodeStrings[i] = str;
-                }
-                else
-                {
-                    _nodeStrings.Add(str);
-                }
-                i++;
-
-                // We cant output more than what fits on screen
-                // -2 because cursor command F cant reach, in Windows Terminal, very 1st line, and last line is empty caused by very last WriteLine
-                if (i >= Height - 2)
-                {
-                    break;
-                }
-            }
-
-            NodesCount = i;
-        }
-
-        private ReadOnlySpan<char> FitToWidth(ReadOnlySpan<char> input)
-        {
-            return input.Slice(0, Math.Min(input.Length, Width - 1));
-        }
-
-        /// <summary>
-        /// Render VT100 string to update from current to next frame.
-        /// </summary>
-        public string Render(NodesFrame previousFrame)
-        {
-            StringBuilder sb = _renderBuilder;
-            sb.Clear();
-
-            int i = 0;
-            for (; i < NodesCount; i++)
-            {
-                var needed = FitToWidth(NodeString(i).AsSpan());
-
-                // Do we have previous node string to compare with?
-                if (previousFrame.NodesCount > i)
-                {
-                    var previous = FitToWidth(previousFrame.NodeString(i).AsSpan());
-
-                    if (!previous.SequenceEqual(needed))
-                    {
-                        int commonPrefixLen = previous.CommonPrefixLength(needed);
-
-                        if (commonPrefixLen != 0 && needed.Slice(0, commonPrefixLen).IndexOf('\x1b') == -1)
-                        {
-                            // no escape codes, so can trivially skip substrings
-                            sb.Append($"{AnsiCodes.CSI}{commonPrefixLen}{AnsiCodes.MoveForward}");
-                            sb.Append(needed.Slice(commonPrefixLen));
-                        }
-                        else
-                        {
-                            sb.Append(needed);
-                        }
-
-                        // Shall we clear rest of line
-                        if (needed.Length < previous.Length)
-                        {
-                            sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
-                        }
-                    }
-                }
-                else
-                {
-                    // From now on we have to simply WriteLine
-                    sb.Append(needed);
-                }
-
-                // Next line
-                sb.AppendLine();
-            }
-
-            // clear no longer used lines
-            if (i < previousFrame.NodesCount)
-            {
-                sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInDisplay}");
-            }
-
-            return sb.ToString();
-        }
-
-        public void Clear()
-        {
-            NodesCount = 0;
-        }
-    }
-
     #endregion
 
     #region Helpers
@@ -845,6 +754,21 @@ private string RenderBuildResult(bool succeeded, bool hasError, bool hasWarning)
         }
     }
 
+    /// <summary>
+    /// Print a build messages to the output that require special customer's attention.
+    /// </summary>
+    /// <param name="message">Build message needed to be shown immediately.</param>
+    private void RenderImmediateMessage(string message)
+    {
+        lock (_lock)
+        {
+            // Calling erase helps to clear the screen before printing the message
+            // The immediate output will not overlap with node status reporting
+            EraseNodes();
+            Terminal.WriteLine(message);
+        }
+    }
+
     /// <summary>
     /// Returns the <see cref="_nodes"/> index corresponding to the given <see cref="BuildEventContext"/>.
     /// </summary>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index d57971461d4..68fed6e926f 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -211,9 +211,15 @@ private static void HandleConfigurationException(Exception ex)
         /// MSBuild no longer runs any arbitrary code (tasks or loggers) on the main thread, so it never needs the
         /// main thread to be in an STA. Accordingly, to avoid ambiguity, we explicitly use the [MTAThread] attribute.
         /// This doesn't actually do any work unless COM interop occurs for some reason.
+        /// We use the MultiDomainHost loader policy because we may create secondary AppDomains and need NGEN images
+        /// for Framework / GACed assemblies to be loaded domain neutral so their native images can be used.
+        /// See <see cref="NuGetFrameworkWrapper"/>.
         /// </remarks>
         /// <returns>0 on success, 1 on failure</returns>
         [MTAThread]
+#if FEATURE_APPDOMAIN
+        [LoaderOptimization(LoaderOptimization.MultiDomainHost)]
+#endif
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
         public static int Main(
 #if !FEATURE_GET_COMMANDLINE
@@ -713,6 +719,9 @@ public static ExitType Execute(
                 string[] getItem = Array.Empty<string>();
                 string[] getTargetResult = Array.Empty<string>();
                 BuildResult result = null;
+#if FEATURE_REPORTFILEACCESSES
+                bool reportFileAccesses = false;
+#endif
 
                 GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
@@ -747,6 +756,9 @@ public static ExitType Execute(
                                             ref graphBuildOptions,
                                             ref inputResultsCaches,
                                             ref outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+                                            ref reportFileAccesses,
+#endif
                                             ref lowPriority,
                                             ref question,
                                             ref getProperty,
@@ -803,11 +815,18 @@ public static ExitType Execute(
                     }
                     else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))
                     {
-                        using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
+                        try
                         {
-                            Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
-                            exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project);
-                            collection.LogBuildFinishedEvent(exitType == ExitType.Success);
+                            using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
+                            {
+                                Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
+                                exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project);
+                                collection.LogBuildFinishedEvent(exitType == ExitType.Success);
+                            }
+                        }
+                        catch (InvalidProjectFileException)
+                        {
+                            exitType = ExitType.BuildError;
                         }
                     }
                     else // regular build
@@ -846,6 +865,9 @@ public static ExitType Execute(
                                     outputResultsCache,
                                     saveProjectResult: outputPropertiesItemsOrTargetResults,
                                     ref result,
+#if FEATURE_REPORTFILEACCESSES
+                                    reportFileAccesses,
+#endif
                                     commandLine))
                         {
                             exitType = ExitType.BuildError;
@@ -1022,28 +1044,20 @@ public static ExitType Execute(
 
         private static ExitType OutputPropertiesAfterEvaluation(string[] getProperty, string[] getItem, Project project)
         {
-            try
+            // Special case if the user requests exactly one property: skip json formatting
+            if (getProperty.Length == 1 && getItem.Length == 0)
             {
-                // Special case if the user requests exactly one property: skip json formatting
-                if (getProperty.Length == 1 && getItem.Length == 0)
-                {
-                    Console.WriteLine(project.GetPropertyValue(getProperty[0]));
-                }
-                else
-                {
-                    JsonOutputFormatter jsonOutputFormatter = new();
-                    jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => project.GetPropertyValue(property));
-                    jsonOutputFormatter.AddItemsInJsonFormat(getItem, project);
-                    Console.WriteLine(jsonOutputFormatter.ToString());
-                }
-
-                return ExitType.Success;
+                Console.WriteLine(project.GetPropertyValue(getProperty[0]));
             }
-            catch (InvalidProjectFileException e)
+            else
             {
-                Console.Error.WriteLine(e.Message);
-                return ExitType.BuildError;
+                JsonOutputFormatter jsonOutputFormatter = new();
+                jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => project.GetPropertyValue(property));
+                jsonOutputFormatter.AddItemsInJsonFormat(getItem, project);
+                Console.WriteLine(jsonOutputFormatter.ToString());
             }
+
+            return ExitType.Success;
         }
 
         private static ExitType OutputBuildInformationInJson(BuildResult result, string[] getProperty, string[] getItem, string[] getTargetResult, ILogger[] loggers, ExitType exitType)
@@ -1232,6 +1246,9 @@ internal static bool BuildProject(
             string outputResultsCache,
             bool saveProjectResult,
             ref BuildResult result,
+#if FEATURE_REPORTFILEACCESSES
+            bool reportFileAccesses,
+#endif
 #if FEATURE_GET_COMMANDLINE
             string commandLine)
 #else
@@ -1243,7 +1260,7 @@ internal static bool BuildProject(
                 InitializationException.Throw(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectUpgradeNeededToVcxProj", projectFile), null);
             }
 
-            bool success = false;
+            bool success = true;
 
             ProjectCollection projectCollection = null;
             bool onlyLogCriticalEvents = false;
@@ -1359,11 +1376,12 @@ internal static bool BuildProject(
 
                 if (isPreprocess)
                 {
+                    success = false;
+
                     // TODO: Support /preprocess for solution files. https://github.com/dotnet/msbuild/issues/7697
                     if (isSolution)
                     {
                         Console.WriteLine(ResourceUtilities.GetResourceString("UnsupportedSwitchForSolutionFiles"), CommandLineSwitches.ParameterizedSwitch.Preprocess);
-                        success = false;
                     }
                     else
                     {
@@ -1377,13 +1395,14 @@ internal static bool BuildProject(
                     }
                 }
 
-                if (isTargets)
+                if (isTargets && success)
                 {
+                    success = false;
+
                     // TODO: Support /targets for solution files. https://github.com/dotnet/msbuild/issues/7697
                     if (isSolution)
                     {
                         Console.WriteLine(ResourceUtilities.GetResourceString("UnsupportedSwitchForSolutionFiles"), CommandLineSwitches.ParameterizedSwitch.Targets);
-                        success = false;
                     }
                     else
                     {
@@ -1393,6 +1412,7 @@ internal static bool BuildProject(
 
                 if (!isPreprocess && !isTargets)
                 {
+                    success = false;
                     BuildParameters parameters = new BuildParameters(projectCollection);
 
                     // By default we log synchronously to the console for compatibility with previous versions,
@@ -1423,6 +1443,9 @@ internal static bool BuildProject(
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
                     parameters.Question = question;
+#if FEATURE_REPORTFILEACCESSES
+                    parameters.ReportFileAccesses = reportFileAccesses;
+#endif
 
                     // Propagate the profiler flag into the project load settings so the evaluator
                     // can pick it up
@@ -1520,12 +1543,16 @@ internal static bool BuildProject(
 
                             if (enableRestore || restoreOnly)
                             {
-                                result = ExecuteRestore(projectFile, toolsVersion, buildManager, restoreProperties.Count > 0 ? restoreProperties : globalProperties);
+                                result = ExecuteRestore(projectFile, toolsVersion, buildManager, restoreProperties.Count > 0 ? restoreProperties : globalProperties, saveProjectResult: saveProjectResult);
 
                                 if (result.OverallResult != BuildResultCode.Success)
                                 {
                                     return false;
                                 }
+                                else
+                                {
+                                    success = result.OverallResult == BuildResultCode.Success;
+                                }
                             }
 
                             if (!restoreOnly)
@@ -1550,21 +1577,14 @@ internal static bool BuildProject(
                                                                                                                                         entryValue.Equals(propertyKvp.Value)))
                                             .Value;
                                     }
-                                    else
-                                    {
-                                        success = graphResult.OverallResult == BuildResultCode.Success;
-                                    }
+                                    success = graphResult.OverallResult == BuildResultCode.Success;
                                 }
                                 else
                                 {
                                     result = ExecuteBuild(buildManager, buildRequest);
+                                    success = result.OverallResult == BuildResultCode.Success;
                                 }
                             }
-
-                            if (result != null && result.Exception == null)
-                            {
-                                success = result.OverallResult == BuildResultCode.Success;
-                            }
                         }
                         finally
                         {
@@ -1744,7 +1764,7 @@ private static GraphBuildResult ExecuteGraphBuild(BuildManager buildManager, Gra
             return submission.Execute();
         }
 
-        private static BuildResult ExecuteRestore(string projectFile, string toolsVersion, BuildManager buildManager, Dictionary<string, string> globalProperties)
+        private static BuildResult ExecuteRestore(string projectFile, string toolsVersion, BuildManager buildManager, Dictionary<string, string> globalProperties, bool saveProjectResult = false)
         {
             // Make a copy of the global properties
             Dictionary<string, string> restoreGlobalProperties = new Dictionary<string, string>(globalProperties);
@@ -1761,13 +1781,19 @@ private static BuildResult ExecuteRestore(string projectFile, string toolsVersio
             //     make available an import that doesn't exist yet and the <Import /> might be missing a condition.
             //  - BuildRequestDataFlags.FailOnUnresolvedSdk to still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
             //     fail the build.
+            BuildRequestDataFlags flags = BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk;
+            if (saveProjectResult)
+            {
+                flags |= BuildRequestDataFlags.ProvideProjectStateAfterBuild;
+            }
+
             BuildRequestData restoreRequest = new BuildRequestData(
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
                 targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
                 hostServices: null,
-                flags: BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk);
+                flags: flags);
 
             return ExecuteBuild(buildManager, restoreRequest);
         }
@@ -2383,6 +2409,9 @@ private static bool ProcessCommandLineSwitches(
             ref GraphBuildOptions graphBuild,
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+            ref bool reportFileAccesses,
+#endif
             ref bool lowPriority,
             ref bool question,
             ref string[] getProperty,
@@ -2446,6 +2475,13 @@ private static bool ProcessCommandLineSwitches(
             // leave priority where it was.
             catch (Win32Exception) { }
 
+#if FEATURE_REPORTFILEACCESSES
+            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.ReportFileAccesses))
+            {
+                reportFileAccesses = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ReportFileAccesses], defaultValue: true, resourceName: "");
+            }
+#endif
+
             // if help switch is set (regardless of switch errors), show the help message and ignore the other switches
             if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Help])
             {
@@ -2508,6 +2544,9 @@ private static bool ProcessCommandLineSwitches(
                                                            ref graphBuild,
                                                            ref inputResultsCaches,
                                                            ref outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+                                                           ref reportFileAccesses,
+#endif
                                                            ref lowPriority,
                                                            ref question,
                                                            ref getProperty,
@@ -4426,6 +4465,9 @@ private static void ShowHelpMessage()
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_InputCachesFiles"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_OutputCacheFile"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_36_GraphBuildSwitch"));
+#if FEATURE_REPORTFILEACCESSES
+            Console.WriteLine(AssemblyResources.GetString("HelpMessage_42_ReportFileAccessesSwitch"));
+#endif
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_39_LowPrioritySwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_41_QuestionSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_7_ResponseFile"));
@@ -4450,7 +4492,15 @@ private static void ShowHelpPrompt()
         /// </summary>
         private static void ShowVersion()
         {
-            Console.Write(ProjectCollection.Version.ToString());
+            // Change Version switch output to finish with a newline https://github.com/dotnet/msbuild/pull/9485
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
+            {
+                Console.WriteLine(ProjectCollection.Version.ToString());
+            }
+            else
+            {
+                Console.Write(ProjectCollection.Version.ToString());
+            }
         }
     }
 }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 91009eec184..d21ec8b5294 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -54,10 +54,22 @@
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Native" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Native.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Processes" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Processes.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Utilities.Core" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Utilities.Core.dll"/>
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -69,6 +81,10 @@
           <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
           <codeBase version="1.0.0.0" href="..\Microsoft.NET.StringTools.net35.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="RuntimeContracts" publicKeyToken="3d487639874b2199" culture="neutral" />
+          <codeBase version="0.5.0.0" href="..\RuntimeContracts.dll" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
@@ -78,8 +94,8 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Collections.Immutable.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Collections.Immutable.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -93,18 +109,18 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Reflection.Metadata.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Reflection.Metadata.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Resources.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Resources.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -113,18 +129,23 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.3" newVersion="7.0.0.3" />
-          <codeBase version="7.0.0.3" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Text.Json.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Threading.Channels.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -163,6 +184,21 @@
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
+
+        <!-- Redirects for SDK resolver components -->
+        <qualifyAssembly partialName="Microsoft.DotNet.MSBuildSdkResolver" fullName="Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60" />
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.DotNet.MSBuildSdkResolver" culture="neutral" publicKeyToken="adb9793829ddae60" />
+          <codeBase version="8.0.100.0" href="..\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.DotNet.MSBuildSdkResolver.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Deployment.DotNet.Releases" culture="neutral" publicKeyToken="31bf3856ad364e35" />
+          <codeBase version="2.0.0.0" href="..\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.Deployment.DotNet.Releases.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
+          <codeBase version="13.0.0.0" href="..\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Newtonsoft.Json.dll" />
+        </dependentAssembly>
       </assemblyBinding>
     </runtime>
     <!-- To define one or more new toolsets, add an 'msbuildToolsets' element in this file. -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 51d2a26861e..a372f0c4760 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -41,7 +41,7 @@
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -58,7 +58,7 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -70,15 +70,15 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -86,15 +86,15 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.3" newVersion="7.0.0.3" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -133,6 +133,21 @@
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
+
+        <!-- Redirects for SDK resolver components -->
+        <qualifyAssembly partialName="Microsoft.DotNet.MSBuildSdkResolver" fullName="Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60" />
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.DotNet.MSBuildSdkResolver" culture="neutral" publicKeyToken="adb9793829ddae60" />
+          <codeBase version="8.0.100.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.DotNet.MSBuildSdkResolver.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Deployment.DotNet.Releases" culture="neutral" publicKeyToken="31bf3856ad364e35" />
+          <codeBase version="2.0.0.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.Deployment.DotNet.Releases.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
+          <codeBase version="13.0.0.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Newtonsoft.Json.dll" />
+        </dependentAssembly>
       </assemblyBinding>
     </runtime>
     <!-- To define one or more new toolsets, add an 'msbuildToolsets' element in this file. -->
diff --git a/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs b/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
index 44c553bef6c..b1b05998bda 100644
--- a/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
+++ b/src/MSBuildTaskHost/Concurrent/ConcurrentQueue.cs
@@ -261,7 +261,7 @@ private bool TryPeek(out T result, bool resultUsed)
         /// <summary>
         /// Provides a multi-producer, multi-consumer thread-safe bounded segment.  When the queue is full,
         /// enqueues fail and return false.  When the queue is empty, dequeues fail and return null.
-        /// These segments are linked together to form the unbounded <see cref="ConcurrentQueue{T}"/>. 
+        /// These segments are linked together to form the unbounded <see cref="ConcurrentQueue{T}"/>.
         /// </summary>
         [DebuggerDisplay("Capacity = {Capacity}")]
         private sealed class Segment
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 463795025c0..aa4ce2eac58 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -14,6 +14,7 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
     <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST;NO_FRAMEWORK_IVT</DefineConstants>
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 148cc6b1210..7873c23f9d9 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -157,7 +157,7 @@ internal LoadedType ReflectionOnlyLoad(
         /// </summary>
         private LoadedType GetLoadedType(Concurrent.ConcurrentDictionary<TypeFilter, Concurrent.ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly)
         {
-            // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which 
+            // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which
             // will map a specific AssemblyLoadInfo to a AssemblyInfoToLoadedTypes class which knows how to find a typeName in a given assembly.
             Concurrent.ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes> loadInfoToType =
                 cache.GetOrAdd(_isDesiredType, (_) => new Concurrent.ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>());
@@ -172,14 +172,14 @@ private LoadedType GetLoadedType(Concurrent.ConcurrentDictionary<TypeFilter, Con
         /// <summary>
         /// Given a type filter and an asssemblyInfo object keep track of what types in a given assembly which match the typefilter.
         /// Also, use this information to determine if a given TypeName is in the assembly which is pointed to by the AssemblyLoadInfo object.
-        /// 
+        ///
         /// This type represents a combination of a type filter and an assemblyInfo object.
         /// </summary>
         private class AssemblyInfoToLoadedTypes
         {
             /// <summary>
             /// Lock to prevent two threads from using this object at the same time.
-            /// Since we fill up internal structures with what is in the assembly 
+            /// Since we fill up internal structures with what is in the assembly
             /// </summary>
             private readonly Object _lockObject = new Object();
 
@@ -287,7 +287,7 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)
             }
 
             /// <summary>
-            /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on 
+            /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on
             /// to find tasks, loggers, and task factories.
             /// </summary>
             private void ScanAssemblyForPublicTypes()
diff --git a/src/Package/GetBinPaths.Arm64.targets b/src/Package/GetBinPaths.Arm64.targets
index c5ad5e64b8f..21a6684a86f 100644
--- a/src/Package/GetBinPaths.Arm64.targets
+++ b/src/Package/GetBinPaths.Arm64.targets
@@ -25,7 +25,7 @@
 
       <Output TaskParameter="TargetOutputs" ItemName="%(Arm64ProjectReference.OutputItemType)" />
     </MSBuild>
-    
+
     <PropertyGroup>
       <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
       <Arm64BinPath>@(MSBuildArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</Arm64BinPath>
diff --git a/src/Package/GetBinPaths.targets b/src/Package/GetBinPaths.targets
index dc99cabb70d..961b4bf13d3 100644
--- a/src/Package/GetBinPaths.targets
+++ b/src/Package/GetBinPaths.targets
@@ -47,7 +47,7 @@
 
       <Output TaskParameter="TargetOutputs" ItemName="%(X64ProjectReference.OutputItemType)" />
     </MSBuild>
-    
+
     <PropertyGroup>
       <X86BinPath>@(MSBuildResolvedProjectReferencePath->'%(RootDir)%(Directory)')</X86BinPath>
       <X64BinPath>@(MSBuildX64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</X64BinPath>
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 3780b51c588..211d1307c6f 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -36,13 +36,18 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe vs.file.ngenArchitecture=x86 vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe.config
-  file source=$(TaskHostBinPath)MSBuildTaskHost.exe 
+  file source=$(TaskHostBinPath)MSBuildTaskHost.exe
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
+  file source=$(X86BinPath)BuildXL.Native.dll
+  file source=$(X86BinPath)BuildXL.Processes.dll
+  file source=$(X86BinPath)BuildXL.Utilities.Core.dll
+  file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Threading.Channels.dll
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -59,6 +64,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.Common.overridetasks
   file source=$(X86BinPath)Microsoft.Common.targets
   file source=$(X86BinPath)Microsoft.Common.tasks
+  file source=$(X86BinPath)Microsoft.Common.Test.targets
   file source=$(X86BinPath)Microsoft.Managed.targets
   file source=$(X86BinPath)Microsoft.Managed.Before.targets
   file source=$(X86BinPath)Microsoft.Managed.After.targets
@@ -207,6 +213,7 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Common.overridetasks
   file source=$(X86BinPath)Microsoft.Common.targets
   file source=$(X86BinPath)Microsoft.Common.tasks
+  file source=$(X86BinPath)Microsoft.Common.Test.targets
   file source=$(X86BinPath)Microsoft.Managed.targets
   file source=$(X86BinPath)Microsoft.Managed.Before.targets
   file source=$(X86BinPath)Microsoft.Managed.After.targets
@@ -313,6 +320,13 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
   file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll
   file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
 
+folder InstallDir:\MSBuild\Current\Bin\x86
+  file source=$(X86BinPath)x86\DetoursServices.dll
+
+folder InstallDir:\MSBuild\Current\Bin\x64
+  file source=$(X86BinPath)x64\DetoursServices.dll
+  file source=$(X86BinPath)x64\BuildXLNatives.dll
+
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
   file source=$(SourceDir)Framework\Microsoft.Build.Framework.pkgdef
diff --git a/src/Package/Microsoft.Build.UnGAC/exe.swr b/src/Package/Microsoft.Build.UnGAC/exe.swr
index 9a717021a50..03ae220174d 100644
--- a/src/Package/Microsoft.Build.UnGAC/exe.swr
+++ b/src/Package/Microsoft.Build.UnGAC/exe.swr
@@ -17,3 +17,8 @@ vs.installSize
 
 vs.payloads
     vs.payload source=$(BinDir)Microsoft.Build.UnGAC.exe
+
+vs.returnCodes
+  vs.returnCode type=success
+    exitCode=259
+    details="Suppress return-code 259 since this is a best-effort ."
diff --git a/src/Package/NuspecProject.targets b/src/Package/NuspecProject.targets
index 157e501538d..e9b94503322 100644
--- a/src/Package/NuspecProject.targets
+++ b/src/Package/NuspecProject.targets
@@ -1,7 +1,7 @@
 ﻿<Project>
 
   <!-- Common logic for projects which create a NuGet package from a .nuspec -->
-  
+
   <PropertyGroup>
     <BeforePack>$(BeforePack);SetNuspecProperties</BeforePack>
 
diff --git a/src/Samples/PortableTask/Properties/AssemblyInfo.cs b/src/Samples/PortableTask/Properties/AssemblyInfo.cs
index 574e376635c..26be3980f3c 100644
--- a/src/Samples/PortableTask/Properties/AssemblyInfo.cs
+++ b/src/Samples/PortableTask/Properties/AssemblyInfo.cs
@@ -4,7 +4,7 @@
 using System.Reflection;
 using System.Resources;
 
-// General Information about an assembly is controlled through the following 
+// General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 [assembly: AssemblyTitle("PortableTask")]
@@ -20,11 +20,11 @@
 // Version information for an assembly consists of the following four values:
 //
 //      Major Version
-//      Minor Version 
+//      Minor Version
 //      Build Number
 //      Revision
 //
-// You can specify all the values or you can default the Build and Revision Numbers 
+// You can specify all the values or you can default the Build and Revision Numbers
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("1.0.*")]
 //[assembly: AssemblyVersion("1.0.0.0")]
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index 3c6a05caadc..30b51c5f35e 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -13,7 +13,7 @@
     <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
   </ItemGroup>
   <ItemGroup>
-    <PackageReference Include="Shouldly" Version="3.0.0" />
+    <PackageReference Include="Shouldly" Version="4.2.1" />
     <PackageReference Include="System.Net.Http" Version="4.3.4" />
   </ItemGroup>
 </Project>
diff --git a/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs b/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
index c4f85f1ed07..f0cbe537b62 100644
--- a/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
+++ b/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
@@ -4,7 +4,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 
-// General Information about an assembly is controlled through the following 
+// General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 [assembly: AssemblyTitle("TaskUsageLogger")]
@@ -16,8 +16,8 @@
 [assembly: AssemblyTrademark("")]
 [assembly: AssemblyCulture("")]
 
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
 // COM, set the ComVisible attribute to true on that type.
 [assembly: ComVisible(false)]
 
@@ -27,11 +27,11 @@
 // Version information for an assembly consists of the following four values:
 //
 //      Major Version
-//      Minor Version 
+//      Minor Version
 //      Build Number
 //      Revision
 //
-// You can specify all the values or you can default the Build and Revision Numbers 
+// You can specify all the values or you can default the Build and Revision Numbers
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("1.0.*")]
 //[assembly: AssemblyVersion("1.0.0.0")]
diff --git a/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs b/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
index ab5fb3ba759..134bbc75c97 100644
--- a/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
+++ b/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
@@ -4,7 +4,7 @@
 using System.Reflection;
 using System.Resources;
 
-// General Information about an assembly is controlled through the following 
+// General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 [assembly: AssemblyTitle("TaskWithDependency")]
@@ -20,11 +20,11 @@
 // Version information for an assembly consists of the following four values:
 //
 //      Major Version
-//      Minor Version 
+//      Minor Version
 //      Build Number
 //      Revision
 //
-// You can specify all the values or you can default the Build and Revision Numbers 
+// You can specify all the values or you can default the Build and Revision Numbers
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("1.0.*")]
 //[assembly: AssemblyVersion("1.0.0.0")]
diff --git a/src/Samples/XmlFileLogger/LogProcessNode.cs b/src/Samples/XmlFileLogger/LogProcessNode.cs
index b561addd604..5dbfe143f36 100644
--- a/src/Samples/XmlFileLogger/LogProcessNode.cs
+++ b/src/Samples/XmlFileLogger/LogProcessNode.cs
@@ -11,7 +11,7 @@
 namespace Microsoft.Build.Logging.StructuredLogger
 {
     /// <summary>
-    /// Base class to represent a log node (e.g. Project, or Target) that can contain child node sub nodes 
+    /// Base class to represent a log node (e.g. Project, or Target) that can contain child node sub nodes
     /// and properties defined at that scope. Properties defined will be inherited from the parent if possible.
     /// </summary>
     internal abstract class LogProcessNode : ILogNode
@@ -153,7 +153,7 @@ protected void WriteChildren<T>(XElement parentElement) where T : ILogNode
         /// </summary>
         /// <typeparam name="T">Generic ILogNode type</typeparam>
         /// <param name="parentElement">The parent element.</param>
-        /// <param name="subNodeFactory">Delegate to create a new element to contain children. Will not be called if 
+        /// <param name="subNodeFactory">Delegate to create a new element to contain children. Will not be called if
         /// there are no children of the specified type.</param>
         protected void WriteChildren<T>(XElement parentElement, Func<XElement> subNodeFactory) where T : ILogNode
         {
diff --git a/src/Samples/XmlFileLogger/ObjectModel/Build.cs b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
index 2646251675a..58687182ffb 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/Build.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Logging.StructuredLogger
     internal sealed class Build : LogProcessNode
     {
         /// <summary>
-        /// A lookup table mapping of project identifiers to project nodes (which can be nested multiple layers). 
+        /// A lookup table mapping of project identifiers to project nodes (which can be nested multiple layers).
         /// </summary>
         private readonly ConcurrentDictionary<int, Project> _projectIdToProjectMap = new ConcurrentDictionary<int, Project>();
 
@@ -93,7 +93,7 @@ public void AddTaskParameter(BuildMessageEventArgs buildMessageEventArgs, string
         }
 
         /// <summary>
-        /// Handler for a TaskCommandLine log event. Sets the command line arguments on the appropriate task. 
+        /// Handler for a TaskCommandLine log event. Sets the command line arguments on the appropriate task.
         /// </summary>
         /// <param name="taskCommandLineEventArgs">The <see cref="TaskCommandLineEventArgs"/> instance containing the event data.</param>
         public void AddCommandLine(TaskCommandLineEventArgs taskCommandLineEventArgs)
diff --git a/src/Samples/XmlFileLogger/ObjectModel/Project.cs b/src/Samples/XmlFileLogger/ObjectModel/Project.cs
index 19081d2c14b..1f419723378 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/Project.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/Project.cs
@@ -23,7 +23,7 @@ internal sealed class Project : LogProcessNode
         private string _projectFile;
 
         /// <summary>
-        /// A lookup table mapping of target names to targets. 
+        /// A lookup table mapping of target names to targets.
         /// Target names are unique to a project and the id is not always specified in the log.
         /// </summary>
         private readonly ConcurrentDictionary<string, Target> _targetNameToTargetMap = new ConcurrentDictionary<string, Target>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs b/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
index 72ac1de6314..8d4c6f085d6 100644
--- a/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
+++ b/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
@@ -4,7 +4,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 
-// General Information about an assembly is controlled through the following 
+// General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 [assembly: AssemblyTitle("XmlFileLogger")]
@@ -16,8 +16,8 @@
 [assembly: AssemblyTrademark("")]
 [assembly: AssemblyCulture("")]
 
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM components.  If you need to access a type in this assembly from 
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
 // COM, set the ComVisible attribute to true on that type.
 [assembly: ComVisible(false)]
 
@@ -27,11 +27,11 @@
 // Version information for an assembly consists of the following four values:
 //
 //      Major Version
-//      Minor Version 
+//      Minor Version
 //      Build Number
 //      Revision
 //
-// You can specify all the values or you can default the Build and Revision Numbers 
+// You can specify all the values or you can default the Build and Revision Numbers
 // by using the '*' as shown below:
 // [assembly: AssemblyVersion("1.0.*")]
 //[assembly: AssemblyVersion("1.0.0.0")]
diff --git a/src/Samples/XmlFileLogger/PropertyBag.cs b/src/Samples/XmlFileLogger/PropertyBag.cs
index 8a99fe50b7a..8ec88b0bdcc 100644
--- a/src/Samples/XmlFileLogger/PropertyBag.cs
+++ b/src/Samples/XmlFileLogger/PropertyBag.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.Logging.StructuredLogger
     /// <summary>
     /// This class encapsulates functionality for a collection of properties (name value pairs) in a
     /// hierarchical way. (e.g. if the parameter is defined and identical in the parent, it is not
-    /// stored in this instance). 
+    /// stored in this instance).
     /// </summary>
     internal sealed class PropertyBag
     {
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 11e6f4bef30..6820a134454 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -18,17 +18,17 @@ namespace Microsoft.Build.Shared
     ///
     /// This is the normal schema:
     ///
-    ///  [HKLM | HKCU]\SOFTWARE\MICROSOFT\.NetFramework\ 
-    ///    v1.0.3705 
-    ///      AssemblyFoldersEx 
-    ///          Infragistics.GridControl.1.0:  
-    ///              @Default = c:\program files\infragistics\grid control\1.0\bin 
-    ///              @Description = Infragistics Grid Control for .NET version 1.0 
-    ///              9466 
-    ///                  @Default = c:\program files\infragistics\grid control\1.0sp1\bin 
-    ///                  @Description = SP1 for Infragistics Grid Control for .NET version 1.0 
+    ///  [HKLM | HKCU]\SOFTWARE\MICROSOFT\.NetFramework\
+    ///    v1.0.3705
+    ///      AssemblyFoldersEx
+    ///          Infragistics.GridControl.1.0:
+    ///              @Default = c:\program files\infragistics\grid control\1.0\bin
+    ///              @Description = Infragistics Grid Control for .NET version 1.0
+    ///              9466
+    ///                  @Default = c:\program files\infragistics\grid control\1.0sp1\bin
+    ///                  @Description = SP1 for Infragistics Grid Control for .NET version 1.0
+    ///
     ///
-    /// 
     /// The root registry path is the following:
     ///
     ///     [HKLM | HKCU]\{AssemblyFoldersBase}\{RuntimeVersion}\{AssemblyFoldersSuffix}
@@ -91,10 +91,10 @@ internal AssemblyFoldersEx(
             *                First, look in 64 bit registry location
             *                Second, look in 32 bit registry location
             *            Targeting X86 or MSIL:
-            *                First,  look in the 32 bit hive 
+            *                First,  look in the 32 bit hive
             *                Second, look in 64 bit hive
             *
-            *  32 bit OS:           
+            *  32 bit OS:
             *        32 bit process:
             *            Targeting 64 bit, or X86, or MSIL:
             *                Look in the default registry which is the 32 bit hive
@@ -317,29 +317,29 @@ private bool IsVersionInsideRange(Version v, RegistryKey keyPlatform)
         /// <summary>
         ///  The algorithm for gathering versions from the registry is as follows:
         ///     1) targetRuntimeVersion is the target framework version you are targeting
-        ///     2) versions is a string list from reading the registry, this list is in what ever order the registry returns 
+        ///     2) versions is a string list from reading the registry, this list is in what ever order the registry returns
         ///        the keys to us in, this is usually alphabetical.
-        ///     
+        ///
         ///     We will go through each version string and do the following:
         ///         1) Check to see if the string is a version
         ///             If the string is not a version we will check to see if the string starts with the framework we are targeting,
-        ///             if it does we will add it to a list which will be added at the end 
+        ///             if it does we will add it to a list which will be added at the end
         ///             of the versions list, if not it gets ignored. We do this to stay compatible to what we have been doing since whidbey.
-        ///             
+        ///
         ///             If the string is a version
-        ///                 We check to see if the version is a valid target framework version. Meaning.  It has a Maj.Minor version and may have 
+        ///                 We check to see if the version is a valid target framework version. Meaning.  It has a Maj.Minor version and may have
         ///                 build, Build is less than or equal to 255 and there is no revision. The reason the build number needs to be less than 255 is because
-        ///                 255 is the largest build number for a target framework version that visual studio 2010 supports. The build number is supposed to 
+        ///                 255 is the largest build number for a target framework version that visual studio 2010 supports. The build number is supposed to
         ///                 represent a service pack on the 4.0 framework.
-        ///                 
-        ///                 If the string is a valid target framework version we check to see we already have a dictionary entry and if not we 
-        ///                 add one. 
+        ///
+        ///                 If the string is a valid target framework version we check to see we already have a dictionary entry and if not we
+        ///                 add one.
         ///                 If the string is not a valid target framework then we will ignore the part of the version which makes it invalid
         ///                 (either the build or the revision, or both) and see where that version would fit in the dictionary as a key and
         ///                 then put the original version string into the list for that entry.
-        ///                 
+        ///
         ///         Since the dictionary is sorted in reverse order to generate the list to return we do the following:
-        ///         Go through the list of dictionary entries 
+        ///         Go through the list of dictionary entries
         ///             For each entry sort the list in reverse alphabetical order and add the entries in their internal list to the listToreturn.
         ///
         ///         This way we have a reverse sorted list of all of the version keys.
@@ -350,17 +350,17 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
             Version targetVersion = VersionUtilities.ConvertToVersion(targetRuntimeVersion);
             List<ExtensionFoldersRegistryKey> versionStrings = new List<ExtensionFoldersRegistryKey>();
 
-            // This dictionary will contain a set of target framework versions and a list of strings read from the registry which are supposed to be treated like the 
-            // target framework version stored as the key. 
+            // This dictionary will contain a set of target framework versions and a list of strings read from the registry which are supposed to be treated like the
+            // target framework version stored as the key.
             // For example:
-            //  If the target framework version is 4.0  but the registry string is v4.0.2116 then we want to treat v4.0.2116 as if it was v4.0 during the sort, 
+            //  If the target framework version is 4.0  but the registry string is v4.0.2116 then we want to treat v4.0.2116 as if it was v4.0 during the sort,
             // but when reading out of the registry
             //  we need to know the original value so we can open the correct key.
             //
-            //  The reason there needs to be a list for each target framework version is that there could be multiple keys in the registry which should be treated 
+            //  The reason there needs to be a list for each target framework version is that there could be multiple keys in the registry which should be treated
             // like v4.0 for sorting.
             //  for example lets say we had the following entries in the registry:
-            //       4.0.2116  and 4.0.2116.87  both of these are supposed to be treated like v4.0 because they are not valid target framework versions but 
+            //       4.0.2116  and 4.0.2116.87  both of these are supposed to be treated like v4.0 because they are not valid target framework versions but
             // are valid version numbers and should be searched when we are targeting 4.0.
             SortedDictionary<Version, List<string>> targetFrameworkVersionToRegistryVersions = new SortedDictionary<Version, List<string>>(ReverseVersionGenericComparer.Comparer);
 
@@ -382,7 +382,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
                     }
                     else
                     {
-                        // To be added to our dictionary our candidate version from the registry must be a valid target framework version which is less than or equal 
+                        // To be added to our dictionary our candidate version from the registry must be a valid target framework version which is less than or equal
                         // to the target version. Therefore if the candidate version is not a valid target framework version we will pretend it is and sort it in its correct form.
 
                         Version replacementVersion;
@@ -402,7 +402,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
                             replacementVersion = candidateVersion;
                         }
 
-                        // If the target version is null then we need to do a partial version match 
+                        // If the target version is null then we need to do a partial version match
                         bool addToListDueToPartialNameMatch = false;
                         if (targetVersion == null)
                         {
@@ -439,7 +439,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
                 }
             }
 
-            // The additional tolerated keys are added onto the end of the versions list in what ever order they came from the 
+            // The additional tolerated keys are added onto the end of the versions list in what ever order they came from the
             // registry in.
             foreach (string key in additionalToleratedKeys)
             {
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index c63b0ff90a1..f29b9e8e443 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -193,7 +193,7 @@ internal static AssemblyNameExtension GetAssemblyNameEx(string path)
             {
                 // Its pretty hard to get here, you need an assembly that contains a valid reference
                 // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
-                // Still it happened once, with an older version of the CLR. 
+                // Still it happened once, with an older version of the CLR.
             }
             catch (FileNotFoundException)
             {
@@ -483,7 +483,7 @@ internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag
         /// <returns></returns>
         internal new int GetHashCode()
         {
-            // Ok, so this isn't a great hashing algorithm. However, basenames with different 
+            // Ok, so this isn't a great hashing algorithm. However, basenames with different
             // versions or PKTs are relatively uncommon and so collisions should be low.
             // Hashing on FullName is wrong because the order of tuple fields is undefined.
             int hash = StringComparer.OrdinalIgnoreCase.GetHashCode(this.Name);
diff --git a/src/Shared/AssemblyNameReverseVersionComparer.cs b/src/Shared/AssemblyNameReverseVersionComparer.cs
index 4d4ad07c589..3265413e089 100644
--- a/src/Shared/AssemblyNameReverseVersionComparer.cs
+++ b/src/Shared/AssemblyNameReverseVersionComparer.cs
@@ -19,10 +19,10 @@ internal sealed class AssemblyNameReverseVersionComparer : IComparer<AssemblyNam
 
         /// <summary>
         /// Compare x and y by version only.
-        /// 
+        ///
         /// Change the return value to sort the values in reverse order.
-        /// 
-        /// If x is greater than y  return -1 indicating x is less than y. 
+        ///
+        /// If x is greater than y  return -1 indicating x is less than y.
         /// If x is less than y  return 1 indicating x is greater than  y.
         /// If x and y are equal return 0.
         /// </summary>
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index c6280524b0a..72e14fda550 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -147,7 +147,7 @@ internal static Task<int> ToTask(this WaitHandle[] handles, int timeout = Timeou
         }
 
         /// <summary>
-        /// A class which acts as a task scheduler and ensures each scheduled task gets its 
+        /// A class which acts as a task scheduler and ensures each scheduled task gets its
         /// own STA thread.
         /// </summary>
         private class OneSTAThreadPerTaskScheduler : TaskScheduler
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index 994c24341bd..822af5c1a96 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
@@ -108,7 +109,7 @@ public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtende
             bool haveMetadata = reader.ReadBoolean();
             if (haveMetadata)
             {
-                data.ExtendedMetadata = new();
+                data.ExtendedMetadata = new Dictionary<string, string?>();
 
                 int count = reader.Read7BitEncodedInt();
                 for (int i = 0; i < count; i++)
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index b2f5106d38d..2f3dce9f66b 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -120,6 +120,7 @@ private static BuildEnvironment Initialize()
                 BuildEnvironmentMode.None,
                 msbuildExePath,
                 runningTests: s_runningTests(),
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: null);
         }
@@ -153,6 +154,7 @@ private static BuildEnvironment TryFromVisualStudioProcess()
                 BuildEnvironmentMode.VisualStudio,
                 msBuildExe,
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: true,
                 visualStudioPath: vsRoot);
         }
@@ -173,6 +175,7 @@ private static BuildEnvironment TryFromMSBuildProcess()
                     BuildEnvironmentMode.VisualStudio,
                     msBuildExe,
                     runningTests: false,
+                    runningInMSBuildExe: true,
                     runningInVisualStudio: false,
                     visualStudioPath: GetVsRootFromMSBuildAssembly(msBuildExe));
             }
@@ -182,6 +185,7 @@ private static BuildEnvironment TryFromMSBuildProcess()
                 BuildEnvironmentMode.Standalone,
                 msBuildExe,
                 runningTests: false,
+                runningInMSBuildExe: true,
                 runningInVisualStudio: false,
                 visualStudioPath: null);
         }
@@ -223,6 +227,7 @@ private static BuildEnvironment TryFromMSBuildAssembly()
                     BuildEnvironmentMode.Standalone,
                     msBuildPath,
                     runningTests: s_runningTests(),
+                    runningInMSBuildExe: false,
                     runningInVisualStudio: false,
                     visualStudioPath: null);
             }
@@ -244,6 +249,7 @@ private static BuildEnvironment TryFromMSBuildExeUnderVisualStudio(string msbuil
                         BuildEnvironmentMode.VisualStudio,
                         GetMSBuildExeFromVsRoot(visualStudioRoot),
                         runningTests: s_runningTests(),
+                        runningInMSBuildExe: false,
                         runningInVisualStudio: false,
                         visualStudioPath: visualStudioRoot);
             }
@@ -274,6 +280,7 @@ private static BuildEnvironment TryFromDevConsole()
                 BuildEnvironmentMode.VisualStudio,
                 GetMSBuildExeFromVsRoot(vsInstallDir),
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: vsInstallDir);
         }
@@ -306,6 +313,7 @@ private static BuildEnvironment TryFromSetupApi()
                 BuildEnvironmentMode.VisualStudio,
                 GetMSBuildExeFromVsRoot(instances[0].Path),
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: instances[0].Path);
         }
@@ -338,6 +346,7 @@ private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePat
                     BuildEnvironmentMode.Standalone,
                     msBuildExePath,
                     runningTests: s_runningTests(),
+                    runningInMSBuildExe: false,
                     runningInVisualStudio: false,
                     visualStudioPath: null);
             }
@@ -527,13 +536,15 @@ internal enum BuildEnvironmentMode
     /// </summary>
     internal sealed class BuildEnvironment
     {
-        public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInVisualStudio, string visualStudioPath)
+        public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInMSBuildExe, bool runningInVisualStudio,
+                string visualStudioPath)
         {
             FileInfo currentMSBuildExeFile = null;
             DirectoryInfo currentToolsDirectory = null;
 
             Mode = mode;
             RunningTests = runningTests;
+            RunningInMSBuildExe = runningInMSBuildExe;
             RunningInVisualStudio = runningInVisualStudio;
             CurrentMSBuildExePath = currentMSBuildExePath;
             VisualStudioInstallRootDirectory = visualStudioPath;
@@ -620,6 +631,11 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
         /// </summary>
         internal bool RunningTests { get; }
 
+        /// <summary>
+        /// Returns true when the entry point application is MSBuild.exe.
+        /// </summary>
+        internal bool RunningInMSBuildExe { get; }
+
         /// <summary>
         /// Returns true when the entry point application is Visual Studio.
         /// </summary>
diff --git a/src/Shared/BuildEventFileInfo.cs b/src/Shared/BuildEventFileInfo.cs
index 33cb0d694cc..050a48d88c5 100644
--- a/src/Shared/BuildEventFileInfo.cs
+++ b/src/Shared/BuildEventFileInfo.cs
@@ -23,7 +23,7 @@ internal sealed class BuildEventFileInfo
         /// Filename may be an empty string, if there is truly no file associated.
         /// This overload may also be used if there is a file but truly no line/column,
         /// for example when failing to load a project file.
-        /// 
+        ///
         /// IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
         /// </summary>
         /// <param name="file"></param>
@@ -46,7 +46,7 @@ internal BuildEventFileInfo(IElementLocation location)
 
         /// <summary>
         /// Creates an instance of this class using the given filename/path and a line/column of interest in the file.
-        /// 
+        ///
         /// IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
         /// </summary>
         /// <param name="file"></param>
@@ -60,7 +60,7 @@ internal BuildEventFileInfo(string file, int line, int column)
 
         /// <summary>
         /// Creates an instance of this class using the given filename/path and a range of lines/columns of interest in the file.
-        /// 
+        ///
         /// IF AN IELEMENTLOCATION IS AVAILABLE, USE THE OVERLOAD ACCEPTING THAT INSTEAD.
         /// </summary>
         /// <param name="file"></param>
diff --git a/src/Shared/CollectionHelpers.cs b/src/Shared/CollectionHelpers.cs
index e88ef106fc6..17265682d2a 100644
--- a/src/Shared/CollectionHelpers.cs
+++ b/src/Shared/CollectionHelpers.cs
@@ -36,7 +36,7 @@ internal static List<T> RemoveNulls<T>(List<T> inputs)
         }
 
         /// <summary>
-        /// Extension method -- combines a TryGet with a check to see that the value is equal. 
+        /// Extension method -- combines a TryGet with a check to see that the value is equal.
         /// </summary>
         internal static bool ContainsValueAndIsEqual(this Dictionary<string, string> dictionary, string key, string value, StringComparison comparer)
         {
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 73d009c2f01..10bdc82790e 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -12,12 +12,12 @@ namespace Microsoft.Build.Shared
 {
     /// <summary>
     /// This class contains only static methods, which are useful throughout many
-    /// of the MSBuild classes and don't really belong in any specific class.   
+    /// of the MSBuild classes and don't really belong in any specific class.
     /// </summary>
     internal static class ConversionUtilities
     {
         /// <summary>
-        /// Converts a string to a bool.  We consider "true/false", "on/off", and 
+        /// Converts a string to a bool.  We consider "true/false", "on/off", and
         /// "yes/no" to be valid boolean representations in the XML.
         /// </summary>
         /// <param name="parameterValue">The string to convert.</param>
diff --git a/src/Shared/EnvironmentUtilities.cs b/src/Shared/EnvironmentUtilities.cs
index 71e7b576389..3b275ef40b5 100644
--- a/src/Shared/EnvironmentUtilities.cs
+++ b/src/Shared/EnvironmentUtilities.cs
@@ -15,9 +15,9 @@ internal static partial class EnvironmentUtilities
 
         public static bool IsWellKnownEnvironmentDerivedProperty(string propertyName)
         {
-            return propertyName.StartsWith("MSBUILD") ||
-                propertyName.StartsWith("COMPLUS_") ||
-                propertyName.StartsWith("DOTNET_");
+            return propertyName.StartsWith("MSBUILD", StringComparison.OrdinalIgnoreCase) ||
+                propertyName.StartsWith("COMPLUS_", StringComparison.OrdinalIgnoreCase) ||
+                propertyName.StartsWith("DOTNET_", StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index a7ef74e8737..eca284ecb64 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -167,7 +167,9 @@ internal static bool IsIoRelatedException(Exception e)
         internal static bool IsXmlException(Exception e)
         {
             return e is XmlException
-                || e is XmlSyntaxException
+#if FEATURE_SECURITY_PERMISSIONS
+                || e is System.Security.XmlSyntaxException
+#endif
                 || e is XmlSchemaException
                 || e is UriFormatException; // XmlTextReader for example uses this under the covers
         }
diff --git a/src/Shared/FileSystem/WindowsNative.cs b/src/Shared/FileSystem/WindowsNative.cs
index 8df4a0b2a2c..5bf3f713c17 100644
--- a/src/Shared/FileSystem/WindowsNative.cs
+++ b/src/Shared/FileSystem/WindowsNative.cs
@@ -71,7 +71,7 @@ public static class DwFlags
             public const int PmsfMultiple = 0x1;
 
             /// <summary>
-            /// If PMSF_NORMAL is used, ignore leading spaces in the string pointed to by pszSpec. If PMSF_MULTIPLE is used, 
+            /// If PMSF_NORMAL is used, ignore leading spaces in the string pointed to by pszSpec. If PMSF_MULTIPLE is used,
             /// ignore leading spaces in each file type contained in the string pointed to by pszSpec. This flag can be combined with PMSF_NORMAL and PMSF_MULTIPLE.
             /// </summary>
             public const int PmsfDontStripSpaces = 0x00010000;
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index 650942be1e5..76e283a1a2a 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.Shared
     /// <summary>
     /// This class contains utility methods for file IO.
     /// Separate from FileUtilities because some assemblies may only need the patterns.
-    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in 
+    /// PERF\COVERAGE NOTE: Try to keep classes in 'shared' as granular as possible. All the methods in
     /// each class get pulled into the resulting assembly.
     /// </summary>
     internal static class FileUtilitiesRegex
diff --git a/src/Shared/INodeEndpoint.cs b/src/Shared/INodeEndpoint.cs
index 024dee437dc..373250acce2 100644
--- a/src/Shared/INodeEndpoint.cs
+++ b/src/Shared/INodeEndpoint.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BackEnd
     internal delegate void LinkStatusChangedDelegate(INodeEndpoint endpoint, LinkStatus status);
 
     /// <summary>
-    /// Used to receive data from a node 
+    /// Used to receive data from a node
     /// </summary>
     /// <param name="endpoint">The endpoint invoking the delegate.</param>
     /// <param name="packet">The packet received.</param>
@@ -34,7 +34,7 @@ internal enum LinkStatus
         Inactive,
 
         /// <summary>
-        /// The connection is active, the most recent data has been successfully sent, and the 
+        /// The connection is active, the most recent data has been successfully sent, and the
         /// node is responding to pings.
         /// </summary>
         Active,
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index cb89889c3ac..42b6a8d6ab6 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -15,7 +15,7 @@ internal enum NodePacketType : byte
         /// Notifies the Node to set a configuration for a particular build.  This is sent before
         /// any BuildRequests are made and will not be sent again for a particular build.  This instructs
         /// the node to prepare to receive build requests.
-        /// 
+        ///
         /// Contains:
         /// Build ID
         /// Environment variables
@@ -30,11 +30,11 @@ internal enum NodePacketType : byte
         NodeConfiguration,
 
         /// <summary>
-        /// A BuildRequestConfiguration object.  
+        /// A BuildRequestConfiguration object.
         /// When sent TO a node, this informs the node of a build configuration.
         /// When sent FROM a node, this requests a BuildRequestConfigurationResponse to map the configuration to the
         /// appropriate global configuration ID.
-        /// 
+        ///
         /// Contents:
         /// Configuration ID
         /// Project Filename
@@ -45,7 +45,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// A response to a request to map a build configuration
-        /// 
+        ///
         /// Contents:
         /// Node Configuration ID
         /// Global Configuration ID
@@ -54,7 +54,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// Information about a project that has been loaded by a node.
-        /// 
+        ///
         /// Contents:
         /// Global Configuration ID
         /// Initial Targets
@@ -64,7 +64,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// Packet used to inform the scheduler that a node's active build request is blocked.
-        /// 
+        ///
         /// Contents:
         /// Build Request ID
         /// Active Targets
@@ -75,7 +75,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// Packet used to unblocked a blocked request on a node.
-        /// 
+        ///
         /// Contents:
         /// Build Request ID
         /// Build Results for child requests, if any.
@@ -84,7 +84,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// A BuildRequest object
-        /// 
+        ///
         /// Contents:
         /// Build Request ID
         /// Configuration ID
@@ -95,7 +95,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// A BuildResult object
-        /// 
+        ///
         /// Contents:
         /// Build ID
         /// Project Instance ID
@@ -107,7 +107,7 @@ internal enum NodePacketType : byte
 
         /// <summary>
         /// A logging message.
-        /// 
+        ///
         /// Contents:
         /// Build Event Type
         /// Build Event Args
@@ -115,8 +115,8 @@ internal enum NodePacketType : byte
         LogMessage,
 
         /// <summary>
-        /// Informs the node that the build is complete.  
-        /// 
+        /// Informs the node that the build is complete.
+        ///
         /// Contents:
         /// Prepare For Reuse
         /// </summary>
@@ -125,21 +125,21 @@ internal enum NodePacketType : byte
         /// <summary>
         /// Reported by the node (or node provider) when a node has terminated.  This is the final packet that will be received
         /// from a node.
-        /// 
+        ///
         /// Contents:
         /// Reason
         /// </summary>
         NodeShutdown,
 
         /// <summary>
-        /// Notifies the task host to set the task-specific configuration for a particular task execution. 
+        /// Notifies the task host to set the task-specific configuration for a particular task execution.
         /// This is sent in place of NodeConfiguration and gives the task host all the information it needs
-        /// to set itself up and execute the task that matches this particular configuration. 
-        /// 
+        /// to set itself up and execute the task that matches this particular configuration.
+        ///
         /// Contains:
-        /// Node ID (of parent MSBuild node, to make the logging work out) 
+        /// Node ID (of parent MSBuild node, to make the logging work out)
         /// Startup directory
-        /// Environment variables 
+        /// Environment variables
         /// UI Culture information
         /// App Domain Configuration XML
         /// Task name
@@ -149,12 +149,12 @@ internal enum NodePacketType : byte
         TaskHostConfiguration,
 
         /// <summary>
-        /// Informs the parent node that the task host has finished executing a 
-        /// particular task.  Does not need to contain identifying information 
-        /// about the task, because the task host will only ever be connected to 
-        /// one parent node at a a time, and will only ever be executing one task 
-        /// for that node at any one time.  
-        /// 
+        /// Informs the parent node that the task host has finished executing a
+        /// particular task.  Does not need to contain identifying information
+        /// about the task, because the task host will only ever be connected to
+        /// one parent node at a a time, and will only ever be executing one task
+        /// for that node at any one time.
+        ///
         /// Contents:
         /// Task result (success / failure)
         /// Resultant parameter values (for output gathering)
@@ -162,11 +162,11 @@ internal enum NodePacketType : byte
         TaskHostTaskComplete,
 
         /// <summary>
-        /// Message sent from the node to its paired task host when a task that 
-        /// supports ICancellableTask is cancelled.  
-        /// 
+        /// Message sent from the node to its paired task host when a task that
+        /// supports ICancellableTask is cancelled.
+        ///
         /// Contents:
-        /// (nothing) 
+        /// (nothing)
         /// </summary>
         TaskHostTaskCancelled,
 
@@ -190,6 +190,16 @@ internal enum NodePacketType : byte
         /// </summary>
         ResourceResponse,
 
+        /// <summary>
+        /// Message sent from a node reporting a file access.
+        /// </summary>
+        FileAccessReport,
+
+        /// <summary>
+        /// Message sent from a node reporting process data.
+        /// </summary>
+        ProcessReport,
+
         /// <summary>
         /// Command in form of MSBuild command line for server node - MSBuild Server.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
@@ -203,13 +213,13 @@ internal enum NodePacketType : byte
         ServerNodeBuildResult = 0xF1,
 
         /// <summary>
-        /// Info about server console activity. 
+        /// Info about server console activity.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
         /// </summary>
         ServerNodeConsoleWrite = 0xF2,
 
         /// <summary>
-        /// Command to cancel ongoing build. 
+        /// Command to cancel ongoing build.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
         /// </summary>
         ServerNodeBuildCancel = 0xF3,
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index 493c4f68490..fd8293d841d 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -199,7 +199,7 @@ private static class FileTrackerDllStub
             #region Initialization code
 
             /// <summary>
-            /// Loads FileTracker.dll into a handle that we can use subsequently to grab the exported methods we're interested in. 
+            /// Loads FileTracker.dll into a handle that we can use subsequently to grab the exported methods we're interested in.
             /// </summary>
             private static void LoadFileTrackerDll()
             {
@@ -227,8 +227,8 @@ private static void LoadFileTrackerDll()
             }
 
             /// <summary>
-            /// Generic code to grab the function pointer for a function exported by FileTracker.dll, given 
-            /// that function's name, and transform that function pointer into a callable delegate. 
+            /// Generic code to grab the function pointer for a function exported by FileTracker.dll, given
+            /// that function's name, and transform that function pointer into a callable delegate.
             /// </summary>
             [SecurityCritical]
             private static DT CreateDelegate<DT>(String entryPointName)
@@ -244,7 +244,7 @@ private static DT CreateDelegate<DT>(String entryPointName)
             }
 
             /// <summary>
-            /// Actually generate all of the delegates that will be called by our public (or rather, internal) surface area methods.  
+            /// Actually generate all of the delegates that will be called by our public (or rather, internal) surface area methods.
             /// </summary>
             private static void InitDelegates()
             {
@@ -264,7 +264,7 @@ private static void InitDelegates()
 
             /// <summary>
             /// Static constructor -- generates the delegates for all of the export methods from
-            /// FileTracker.dll that we care about. 
+            /// FileTracker.dll that we care about.
             /// </summary>
             [SecuritySafeCritical]
             static FileTrackerDllStub()
@@ -275,7 +275,7 @@ static FileTrackerDllStub()
 
             #endregion  // Initialization code
 #pragma warning restore format
-            // Specialized handle to make sure we free FileTracker.dll 
+            // Specialized handle to make sure we free FileTracker.dll
             [SecurityCritical]
             private class SafeLibraryHandle : SafeHandle
             {
@@ -296,8 +296,8 @@ public override bool IsInvalid
                 [SecurityCritical]
                 protected override bool ReleaseHandle()
                 {
-                    // FileTracker expects to continue to exist even through ExitProcess -- if we forcibly unload it now, 
-                    // bad things can happen when the CLR attempts to call the (still detoured?) ExitProcess.  
+                    // FileTracker expects to continue to exist even through ExitProcess -- if we forcibly unload it now,
+                    // bad things can happen when the CLR attempts to call the (still detoured?) ExitProcess.
                     return true;
                 }
             }  // private class SafeLibraryHandle
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 8513d60cee5..307cc68bdc9 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -117,10 +117,10 @@ public override String ReadString()
                         int length = (int)memoryStream.Length;
                         n = (rawPosition + readLength) < length ? readLength : length - rawPosition;
 
-                        // Attempt to track down an intermittent failure -- n should not ever be negative, but 
-                        // we're occasionally seeing it when we do the decoder.GetChars below -- by providing 
+                        // Attempt to track down an intermittent failure -- n should not ever be negative, but
+                        // we're occasionally seeing it when we do the decoder.GetChars below -- by providing
                         // a bit more information when we do hit the error, in the place where (by code inspection)
-                        // the actual error seems most likely to be occurring. 
+                        // the actual error seems most likely to be occurring.
                         if (n < 0)
                         {
                             ErrorUtilities.ThrowInternalError("From calculating based on the memorystream, about to read n = {0}. length = {1}, rawPosition = {2}, readLength = {3}, stringLength = {4}, currPos = {5}.", n, length, rawPosition, readLength, stringLength, currPos);
@@ -201,7 +201,7 @@ internal static BinaryReaderFactory CreateSharedBuffer()
         /// </summary>
         /// <remarks>
         /// Lifetime of the pooled buffer is managed by InterningBinaryReader (tied to BinaryReader lifetime wrapping the buffer)
-        /// </remarks> 
+        /// </remarks>
         internal static BinaryReaderFactory PoolingBuffer => NullBuffer.Instance;
 
         /// <summary>
@@ -251,7 +251,7 @@ private static BinaryReader Create(Stream stream, BinaryReaderFactory sharedBuff
         }
 
         /// <summary>
-        /// Holds thepreallocated buffer. 
+        /// Holds thepreallocated buffer.
         /// </summary>
         private class Buffer : BinaryReaderFactory
         {
diff --git a/src/Shared/LanguageParser/CSharptokenCharReader.cs b/src/Shared/LanguageParser/CSharptokenCharReader.cs
index 9b3d77a6525..ebbb6163b29 100644
--- a/src/Shared/LanguageParser/CSharptokenCharReader.cs
+++ b/src/Shared/LanguageParser/CSharptokenCharReader.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Shared.LanguageParser
     /*
      * Class:   CSharpTokenCharReader
      *
-     * Reads over the contents of a C# source file (in the form of a string). 
+     * Reads over the contents of a C# source file (in the form of a string).
      * Provides utility functions for dealing with C#-specific tokens.
      *
      */
@@ -19,7 +19,7 @@ internal sealed class CSharpTokenCharReader : TokenCharReader
     {
         /*
          * Method:  CSharpTokenCharReader
-         * 
+         *
          * Construct
          */
         internal CSharpTokenCharReader(Stream binaryStream, bool forceANSI)
@@ -29,8 +29,8 @@ internal CSharpTokenCharReader(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  SinkLongIntegerSuffix
-         * 
-         * Skip C# integer literal long suffix: L, U, l, u, ul, etc.                    
+         *
+         * Skip C# integer literal long suffix: L, U, l, u, ul, etc.
          */
         internal bool SinkLongIntegerSuffix()
         {
@@ -57,7 +57,7 @@ internal bool SinkLongIntegerSuffix()
 
         /*
          * Method:  SinkOperatorOrPunctuator
-         * 
+         *
          * Determine whether this is a C# operator or punctuator
          */
         internal bool SinkOperatorOrPunctuator()
@@ -73,7 +73,7 @@ internal bool SinkOperatorOrPunctuator()
 
         /*
          * Method:  SinkStringEscape
-         * 
+         *
          * Determine whether this is a valid escape character for strings?
          */
         internal bool SinkStringEscape()
@@ -102,7 +102,7 @@ internal bool SinkStringEscape()
 
         /*
          * Method:  MatchRegularStringLiteral
-         * 
+         *
          * Determine whether this is a regular C# string literal character
          */
         internal bool MatchRegularStringLiteral()
@@ -117,7 +117,7 @@ internal bool MatchRegularStringLiteral()
 
         /*
          * Method:  SinkMultipleWhiteSpace
-         * 
+         *
          * Sink some C# whitespace
          */
         internal bool SinkMultipleWhiteSpace()
diff --git a/src/Shared/LanguageParser/CSharptokenEnumerator.cs b/src/Shared/LanguageParser/CSharptokenEnumerator.cs
index 1e3e70f5c03..c9937439716 100644
--- a/src/Shared/LanguageParser/CSharptokenEnumerator.cs
+++ b/src/Shared/LanguageParser/CSharptokenEnumerator.cs
@@ -22,7 +22,7 @@ internal sealed class CSharpTokenEnumerator : TokenEnumerator
 
         /*
         * Method:  TokenEnumerator
-        * 
+        *
         * Construct
         */
         internal CSharpTokenEnumerator(Stream binaryStream, bool forceANSI)
@@ -32,7 +32,7 @@ internal CSharpTokenEnumerator(Stream binaryStream, bool forceANSI)
 
         /*
         * Method:  FindNextToken
-        * 
+        *
         * Find the next token. Return 'true' if one was found. False, otherwise.
         */
         internal override bool FindNextToken()
@@ -77,14 +77,14 @@ internal override bool FindNextToken()
                 {
                     if (_reader.Sink("\\"))
                     {
-                        /* reader.Skip the escape sequence. 
+                        /* reader.Skip the escape sequence.
                             This isn't exactly right. We should detect:
-                            
-                            simple-escape-sequence: one of 
-                            \' \" \\ \0 \a \b \f \n \r \t \v 
-                            
-                            hexadecimal-escape-sequence: 
-                            \x   hex-digit   hex-digit[opt]   hex-digit[opt]  hex-digit[opt]                                
+
+                            simple-escape-sequence: one of
+                            \' \" \\ \0 \a \b \f \n \r \t \v
+
+                            hexadecimal-escape-sequence:
+                            \x   hex-digit   hex-digit[opt]   hex-digit[opt]  hex-digit[opt]
                         */
                     }
 
@@ -110,7 +110,7 @@ internal override bool FindNextToken()
                 }
                 while (!_reader.EndOfLines && _reader.SinkCharacter() != '\"');
 
-                // Can't end a file inside a string 
+                // Can't end a file inside a string
                 if (_reader.EndOfLines)
                 {
                     current = new EndOfFileInsideStringToken();
@@ -134,12 +134,12 @@ internal override bool FindNextToken()
                         if (_reader.SinkStringEscape())
                         {
                             // This isn't nearly right. We just do barely enough to make a string
-                            // with an embedded escape sequence return _some_ string whose start and 
+                            // with an embedded escape sequence return _some_ string whose start and
                             // end match the real bounds of the string.
                         }
                         else
                         {
-                            // This is a compiler error. 
+                            // This is a compiler error.
                             _reader.SinkCharacter();
                             current = new CSharpTokenizer.UnrecognizedStringEscapeToken();
                             return true;
@@ -181,7 +181,7 @@ internal override bool FindNextToken()
                     return true;
                 }
 
-                // Sink the rest of the identifier.                     
+                // Sink the rest of the identifier.
                 while (_reader.SinkIdentifierPart())
                 {
                 }
@@ -241,7 +241,7 @@ internal override bool FindNextToken()
                     return true;
                 }
 
-                // Skip the L, U, l, u, ul, etc.                    
+                // Skip the L, U, l, u, ul, etc.
                 _reader.SinkLongIntegerSuffix();
 
                 current = new HexIntegerLiteralToken();
@@ -250,7 +250,7 @@ internal override bool FindNextToken()
             // Decimal integer literal
             else if (_reader.SinkMultipleDecimalDigits())
             {
-                // reader.Skip the L, U, l, u, ul, etc.                    
+                // reader.Skip the L, U, l, u, ul, etc.
                 _reader.SinkLongIntegerSuffix();
 
                 current = new DecimalIntegerLiteralToken();
@@ -283,7 +283,7 @@ internal override bool FindNextToken()
                 return true;
             }
 
-            // We didn't recognize the token, so this is a syntax error. 
+            // We didn't recognize the token, so this is a syntax error.
             _reader.SinkCharacter();
             current = new UnrecognizedToken();
             return true;
@@ -310,7 +310,7 @@ internal override bool FindNextToken()
 
         /*
         * Method:  Reader
-        * 
+        *
         * Return the token char reader.
         */
         internal override TokenCharReader Reader
diff --git a/src/Shared/LanguageParser/CSharptokenizer.cs b/src/Shared/LanguageParser/CSharptokenizer.cs
index 06519da0616..c3a00a698ef 100644
--- a/src/Shared/LanguageParser/CSharptokenizer.cs
+++ b/src/Shared/LanguageParser/CSharptokenizer.cs
@@ -51,7 +51,7 @@ internal CSharpTokenizer(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  GetEnumerator
-         * 
+         *
          * Return a new token enumerator.
          */
         public IEnumerator GetEnumerator()
diff --git a/src/Shared/LanguageParser/StreamMappedString.cs b/src/Shared/LanguageParser/StreamMappedString.cs
index c4cfd631df9..8b41bba6e84 100644
--- a/src/Shared/LanguageParser/StreamMappedString.cs
+++ b/src/Shared/LanguageParser/StreamMappedString.cs
@@ -25,7 +25,7 @@ internal sealed class StreamMappedString
         private StreamReader _reader;
 
         /// <summary>
-        /// When false, try to guess the encoding of binaryStream. When true, force the 
+        /// When false, try to guess the encoding of binaryStream. When true, force the
         /// encoding to ANSI.
         /// </summary>
         private bool _forceANSI;
@@ -110,7 +110,7 @@ private void RestartReader()
                 _reader = new StreamReader( // HIGHCHAR: Falling back to ANSI for VB source files.
                     _binaryStream,
 #if FEATURE_ENCODING_DEFAULT
-                    Encoding.Default,    // Default means ANSI. 
+                    Encoding.Default,    // Default means ANSI.
 #else
                     Encoding.ASCII,
 #endif
diff --git a/src/Shared/LanguageParser/VisualBasictokenCharReader.cs b/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
index 63d10a29c91..e493c4c32ed 100644
--- a/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Shared.LanguageParser
     /*
      * Class:   VisualBasicTokenCharReader
      *
-     * Reads over the contents of a vb source file (in the form of a string). 
+     * Reads over the contents of a vb source file (in the form of a string).
      * Provides utility functions for dealing with VB-specific tokens.
      *
      */
@@ -19,7 +19,7 @@ internal sealed class VisualBasicTokenCharReader : TokenCharReader
     {
         /*
          * Method:  VisualBasicTokenCharReader
-         * 
+         *
          * Construct
          */
         internal VisualBasicTokenCharReader(Stream binaryStream, bool forceANSI)
@@ -29,7 +29,7 @@ internal VisualBasicTokenCharReader(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  SinkSeparatorCharacter
-         * 
+         *
          * Matches a vb separator character.
          */
         internal bool SinkSeparatorCharacter()
@@ -55,7 +55,7 @@ internal bool SinkSeparatorCharacter()
 
         /*
          * Method:  SinkLineContinuationCharacter
-         * 
+         *
          * Matches a vb line continuation character.
          */
         internal bool SinkLineContinuationCharacter()
@@ -73,7 +73,7 @@ internal bool SinkLineContinuationCharacter()
 
         /*
          * Method:  SinkLineCommentStart
-         * 
+         *
          * Matches a vb start of comment indicator
          */
         internal bool SinkLineCommentStart()
@@ -103,7 +103,7 @@ internal bool SinkLineCommentStart()
 
         /*
          * Method:  SinkHexIntegerPrefix
-         * 
+         *
          * Matches a vb hex integer prefix
          */
         internal bool SinkHexIntegerPrefix()
@@ -118,7 +118,7 @@ internal bool SinkHexIntegerPrefix()
 
         /*
          * Method:  SinkOctalIntegerPrefix
-         * 
+         *
          * Matches a vb octal integer prefix
          */
         internal bool SinkOctalIntegerPrefix()
@@ -133,7 +133,7 @@ internal bool SinkOctalIntegerPrefix()
 
         /*
          * Method:  SinkWhiteSpace
-         * 
+         *
          * Sink a single whitespace character.
          * In vb, newlines are not considered whitespace.
          */
@@ -149,7 +149,7 @@ internal bool SinkWhiteSpace()
 
         /*
          * Method:  SinkIntegerSuffix
-         * 
+         *
          * Sink a vb integer suffix.
          */
         internal bool SinkIntegerSuffix()
@@ -170,7 +170,7 @@ internal bool SinkIntegerSuffix()
 
         /*
          * Method:  SinkDecimalIntegerSuffix
-         * 
+         *
          * Sink a vb decimal integer suffix.
          * Couldn't find this documented anywhere, but a decimal (as opposed to hex or octal)
          * is also allowed a trailing '@', '!', '#' or '&'
@@ -200,7 +200,7 @@ internal bool SinkDecimalIntegerSuffix()
 
         /*
          * Method:  SinkOctalDigits
-         * 
+         *
          * Sink multiple octal digits.
          */
         internal bool SinkMultipleOctalDigits()
@@ -211,12 +211,12 @@ internal bool SinkMultipleOctalDigits()
                 ++count;
                 Skip();
             }
-            return count > 0;     // Must match at least one  
+            return count > 0;     // Must match at least one
         }
 
         /*
          * Method:  SinkOperator
-         * 
+         *
          * Determine whether this is a vb operator.
          */
         internal bool SinkOperator()
@@ -232,7 +232,7 @@ internal bool SinkOperator()
 
         /*
          * Method:  SinkTypeCharacter
-         * 
+         *
          * Identifiers in vb can end with a special character to indicate type:
          *   IntegerTypeCharacter ::= %
          *   LongTypeCharacter ::= &
diff --git a/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs b/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
index 589f4ae3707..0752bb5549f 100644
--- a/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
@@ -21,7 +21,7 @@ internal sealed class VisualBasicTokenEnumerator : TokenEnumerator
 
         /*
         * Method:  TokenEnumerator
-        * 
+        *
         * Construct
         */
         internal VisualBasicTokenEnumerator(Stream binaryStream, bool forceANSI)
@@ -31,7 +31,7 @@ internal VisualBasicTokenEnumerator(Stream binaryStream, bool forceANSI)
 
         /*
         * Method:  FindNextToken
-        * 
+        *
         * Find the next token. Return 'true' if one was found. False, otherwise.
         */
         internal override bool FindNextToken()
@@ -185,7 +185,7 @@ internal override bool FindNextToken()
                     return true;
                 }
 
-                // Sink a suffix if there is one.                    
+                // Sink a suffix if there is one.
                 _reader.SinkIntegerSuffix();
 
                 current = new HexIntegerLiteralToken();
@@ -200,7 +200,7 @@ internal override bool FindNextToken()
                     return true;
                 }
 
-                // Sink a suffix if there is one.                    
+                // Sink a suffix if there is one.
                 _reader.SinkIntegerSuffix();
 
                 current = new VisualBasicTokenizer.OctalIntegerLiteralToken();
@@ -209,7 +209,7 @@ internal override bool FindNextToken()
             // Is it a decimal integer?
             else if (_reader.SinkMultipleDecimalDigits())
             {
-                // Sink a suffix if there is one.                    
+                // Sink a suffix if there is one.
                 _reader.SinkDecimalIntegerSuffix();
 
                 current = new DecimalIntegerLiteralToken();
@@ -259,7 +259,7 @@ internal override bool FindNextToken()
                 }
                 while (!_reader.EndOfLines && _reader.SinkCharacter() != '\"');
 
-                // Can't end a file inside a string 
+                // Can't end a file inside a string
                 if (_reader.EndOfLines)
                 {
                     current = new EndOfFileInsideStringToken();
@@ -271,7 +271,7 @@ internal override bool FindNextToken()
             }
 
 
-            // We didn't recognize the token, so this is a syntax error. 
+            // We didn't recognize the token, so this is a syntax error.
             _reader.SinkCharacter();
             current = new UnrecognizedToken();
             return true;
@@ -317,7 +317,7 @@ internal override bool FindNextToken()
 
         /*
         * Method:  Reader
-        * 
+        *
         * Return the token char reader.
         */
         internal override TokenCharReader Reader
diff --git a/src/Shared/LanguageParser/VisualBasictokenizer.cs b/src/Shared/LanguageParser/VisualBasictokenizer.cs
index 59b51bbb49b..eb58148a2c6 100644
--- a/src/Shared/LanguageParser/VisualBasictokenizer.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenizer.cs
@@ -38,7 +38,7 @@ internal class ExpectedValidOctalDigitToken : SyntaxErrorToken { }
 
         /*
          * Method:  VisualBasicTokenizer
-         * 
+         *
          * Construct
          */
         internal VisualBasicTokenizer(Stream binaryStream, bool forceANSI)
@@ -49,7 +49,7 @@ internal VisualBasicTokenizer(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  GetEnumerator
-         * 
+         *
          * Return a new token enumerator.
          */
         public IEnumerator GetEnumerator()
diff --git a/src/Shared/LanguageParser/token.cs b/src/Shared/LanguageParser/token.cs
index 2ce67719e5c..62f089b34bf 100644
--- a/src/Shared/LanguageParser/token.cs
+++ b/src/Shared/LanguageParser/token.cs
@@ -22,7 +22,7 @@ internal abstract class Token
 
         /*
          * Method:  InnerText
-         * 
+         *
          * Get or set the InnerText for this token
          */
         internal string InnerText
@@ -33,7 +33,7 @@ internal string InnerText
 
         /*
          * Method:  Line
-         * 
+         *
          * Get or set the Line for this token
          */
         internal int Line
@@ -50,7 +50,7 @@ internal int Line
 
         /*
          * Method:  EqualsIgnoreCase
-         * 
+         *
          * Return true if the given string equals the content of this token
          */
         internal bool EqualsIgnoreCase(string compareTo)
diff --git a/src/Shared/LanguageParser/tokenChar.cs b/src/Shared/LanguageParser/tokenChar.cs
index 9d9e99eb67e..0cd62ff96e9 100644
--- a/src/Shared/LanguageParser/tokenChar.cs
+++ b/src/Shared/LanguageParser/tokenChar.cs
@@ -23,7 +23,7 @@ internal static bool IsNewLine(char c)
             return c == 0x000d        // Carriage return
                     || c == 0x000a        // Linefeed
                     || c == 0x2028        // Line separator
-                    || c == 0x2029        // Paragraph separator                       
+                    || c == 0x2029        // Paragraph separator
                         ;
         }
 
@@ -103,7 +103,7 @@ internal static bool IsCombining(char c)
             // combining-character:
             if (
                     cat == UnicodeCategory.NonSpacingMark // Mn
-                    || cat == UnicodeCategory.SpacingCombiningMark)  // Mc 
+                    || cat == UnicodeCategory.SpacingCombiningMark)  // Mc
             {
                 return true;
             }
diff --git a/src/Shared/LanguageParser/tokenCharReader.cs b/src/Shared/LanguageParser/tokenCharReader.cs
index 2d23ec90339..51a6978d0b8 100644
--- a/src/Shared/LanguageParser/tokenCharReader.cs
+++ b/src/Shared/LanguageParser/tokenCharReader.cs
@@ -11,13 +11,13 @@ namespace Microsoft.Build.Shared.LanguageParser
     /*
      * Class:   TokenCharReader
      *
-     * Reads over the contents of a source file (in the form of a string). 
+     * Reads over the contents of a source file (in the form of a string).
      * Provides utility functions for skipping and checking the value of characters.
      *
      */
     internal class TokenCharReader
     {
-        // The sources 
+        // The sources
         private StreamMappedString _sources;
         // Current character offset within sources.
         private int _position;
@@ -26,7 +26,7 @@ internal class TokenCharReader
 
         /*
          * Method:  TokenCharReader
-         * 
+         *
          * Construct
          */
         internal TokenCharReader(Stream binaryStream, bool forceANSI)
@@ -37,7 +37,7 @@ internal TokenCharReader(Stream binaryStream, bool forceANSI)
 
         /*
          * Method:  Reset
-         * 
+         *
          * Reset to the top of the sources.
          */
         internal void Reset()
@@ -48,8 +48,8 @@ internal void Reset()
 
         /*
          * Method:  CurrentLine
-         * 
-         * The current line number   
+         *
+         * The current line number
          */
         internal int CurrentLine
         {
@@ -58,7 +58,7 @@ internal int CurrentLine
 
         /*
          * Method:  Position
-         * 
+         *
          * The character offset within the sources.
          */
         internal int Position
@@ -74,7 +74,7 @@ internal int Position
 
         /*
          * Method:  Skip
-         * 
+         *
          * Skip to the next character.
          */
         protected void Skip()
@@ -86,9 +86,9 @@ protected void Skip()
             ++_position;
         }
 
-        /* 
+        /*
          * Method:  Skip (overload)
-         * 
+         *
          * Skip the next n characters.
          */
         protected void Skip(int n)
@@ -101,7 +101,7 @@ protected void Skip(int n)
 
         /*
          * Method:  CurrentCharacter
-         * 
+         *
          * Get the current character.
          */
         internal char CurrentCharacter
@@ -111,7 +111,7 @@ internal char CurrentCharacter
 
         /*
          * Method:  EndOfLines
-         * 
+         *
          * Return true if we've reached the end of sources.
          */
         internal bool EndOfLines
@@ -121,7 +121,7 @@ internal bool EndOfLines
 
         /*
          * Method:  GetCurrentMatchedString
-         * 
+         *
          * Get the string that starts with the given start position and ends with this.position.
          */
         internal string GetCurrentMatchedString(int startPosition)
@@ -131,7 +131,7 @@ internal string GetCurrentMatchedString(int startPosition)
 
         /*
          * Method:  Sink
-         * 
+         *
          * See if the next characters match the given string. If they do,
          * sink this string.
          */
@@ -172,7 +172,7 @@ private bool Sink(string match, bool ignoreCase)
 
         /*
          * Method:  SinkCharacter
-         * 
+         *
          * Sink and return one character.
          */
         internal char SinkCharacter()
@@ -184,7 +184,7 @@ internal char SinkCharacter()
 
         /*
          * Method:  SinkIgnoreCase
-         * 
+         *
          * See if the next characters match the given string without case.
          */
         internal bool SinkIgnoreCase(string match)
@@ -194,7 +194,7 @@ internal bool SinkIgnoreCase(string match)
 
         /*
          * Method:  MatchNextIdentifierStart
-         * 
+         *
          * Determine whether a given character is a C# or VB identifier start character.
          * Both languages agree on this format.
          */
@@ -211,7 +211,7 @@ internal bool MatchNextIdentifierStart()
 
         /*
          * Method:  SinkIdentifierStart
-         * 
+         *
          * Determine whether a given character is a C# or VB identifier start character.
          * Both languages agree on this format.
          */
@@ -227,7 +227,7 @@ internal bool SinkIdentifierStart()
 
         /*
          * Method:  SinkIdentifierPart
-         * 
+         *
          * Determine whether a given character is a C# or VB identifier part character
          * Both languages agree on this format.
          */
@@ -250,7 +250,7 @@ internal bool SinkIdentifierPart()
 
         /*
          * Method:  SinkNewLine
-         * 
+         *
          * Sink a newline.
          */
         internal bool SinkNewLine()
@@ -281,7 +281,7 @@ internal bool SinkNewLine()
 
         /*
          * Method:  SinkToEndOfLine
-         * 
+         *
          * Sink from the current position to the first end-of-line.
          */
         internal bool SinkToEndOfLine()
@@ -290,12 +290,12 @@ internal bool SinkToEndOfLine()
             {
                 Skip();
             }
-            return true;    // Matching zero characters is ok.        
+            return true;    // Matching zero characters is ok.
         }
 
         /*
          * Method:  SinkUntil
-         * 
+         *
          * Sink until the given string is found. Match including the given string.
          */
         internal bool SinkUntil(string find)
@@ -318,7 +318,7 @@ internal bool SinkUntil(string find)
 
         /*
          * Method:  SinkMultipleHexDigits
-         * 
+         *
          * Sink multiple hex digits.
          */
         internal bool SinkMultipleHexDigits()
@@ -329,12 +329,12 @@ internal bool SinkMultipleHexDigits()
                 ++count;
                 Skip();
             }
-            return count > 0;     // Must match at least one  
+            return count > 0;     // Must match at least one
         }
 
         /*
          * Method:  SinkMultipleDecimalDigits
-         * 
+         *
          * Sink multiple decimal digits.
          */
         internal bool SinkMultipleDecimalDigits()
@@ -345,7 +345,7 @@ internal bool SinkMultipleDecimalDigits()
                 ++count;
                 Skip();
             }
-            return count > 0;     // Must match at least one 
+            return count > 0;     // Must match at least one
         }
     }
 }
diff --git a/src/Shared/LanguageParser/tokenEnumerator.cs b/src/Shared/LanguageParser/tokenEnumerator.cs
index 673b5a8a933..3ae025d91b4 100644
--- a/src/Shared/LanguageParser/tokenEnumerator.cs
+++ b/src/Shared/LanguageParser/tokenEnumerator.cs
@@ -27,7 +27,7 @@ internal abstract class TokenEnumerator : IEnumerator
 
         /*
         * Method:  MoveNext
-        * 
+        *
         * Declare the MoveNext method required by IEnumerator
         */
         public bool MoveNext()
@@ -59,7 +59,7 @@ public bool MoveNext()
 
         /*
         * Method:  Reset
-        * 
+        *
         * Declare the Reset method required by IEnumerator
         */
         public void Reset()
@@ -70,7 +70,7 @@ public void Reset()
 
         /*
         * Method:  Current
-        * 
+        *
         * Declare the Current property required by IEnumerator
         */
         public object Current
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 4cfbf546ce0..92cc46106f0 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -199,7 +199,12 @@ internal enum LoggingEventType : int
         /// <summary>
         /// Event is <see cref="UninitializedPropertyReadEventArgs"/>
         /// </summary>
-        UninitializedPropertyRead = 32
+        UninitializedPropertyRead = 32,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedCriticalBuildMessageEventArgs"/>
+        /// </summary>
+        ExtendedCriticalBuildMessageEvent = 33,
     }
     #endregion
 
@@ -244,14 +249,14 @@ internal abstract class LogMessagePacketBase : INodePacket
         private static object s_lockObject = new Object();
 
         /// <summary>
-        /// Delegate for translating targetfinished events. 
+        /// Delegate for translating targetfinished events.
         /// </summary>
         private TargetFinishedTranslator _targetFinishedTranslator = null;
 
         #region Data
 
         /// <summary>
-        /// The event type of the buildEventArg based on the 
+        /// The event type of the buildEventArg based on the
         /// LoggingEventType enumeration
         /// </summary>
         private LoggingEventType _eventType = LoggingEventType.Invalid;
@@ -334,8 +339,8 @@ internal KeyValuePair<int, BuildEventArgs>? NodeBuildEvent
         }
 
         /// <summary>
-        /// The event type of the wrapped buildEventArg 
-        /// based on the LoggingEventType enumeration 
+        /// The event type of the wrapped buildEventArg
+        /// based on the LoggingEventType enumeration
         /// </summary>
         internal LoggingEventType EventType
         {
@@ -408,7 +413,7 @@ or EnvironmentVariableReadEventArgs
 
                 if (eventCanSerializeItself)
                 {
-                    // 3.5 or later -- we have custom serialization methods, so let's use them.  
+                    // 3.5 or later -- we have custom serialization methods, so let's use them.
                     ArgsWriterDelegate writerMethod = (ArgsWriterDelegate)CreateDelegateRobust(typeof(ArgsWriterDelegate), _buildEvent, methodInfo);
                     writerMethod(translator.Writer);
 
@@ -444,8 +449,8 @@ internal void ReadFromStream(ITranslator translator)
             {
                 _buildEvent = GetBuildEventArgFromId();
 
-                // The other side is telling us whether the event knows how to log itself, or whether we're going to have 
-                // to do it manually 
+                // The other side is telling us whether the event knows how to log itself, or whether we're going to have
+                // to do it manually
                 int packetVersion = s_defaultPacketVersion;
                 translator.Translate(ref packetVersion);
 
@@ -533,9 +538,9 @@ internal void ReadFromStream(ITranslator translator)
         /// Wrapper for Delegate.CreateDelegate with retries.
         /// </summary>
         /// <comment>
-        /// TODO:  Investigate if it would be possible to use one of the overrides of CreateDelegate 
-        /// that doesn't force the delegate to be closed over its first argument, so that we can 
-        /// only create the delegate once per event type and cache it.  
+        /// TODO:  Investigate if it would be possible to use one of the overrides of CreateDelegate
+        /// that doesn't force the delegate to be closed over its first argument, so that we can
+        /// only create the delegate once per event type and cache it.
         /// </comment>
         private static Delegate CreateDelegateRobust(Type type, Object firstArgument, MethodInfo methodInfo)
         {
@@ -597,6 +602,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.ExtendedBuildErrorEvent => new ExtendedBuildErrorEventArgs(),
                 LoggingEventType.ExtendedBuildWarningEvent => new ExtendedBuildWarningEventArgs(),
                 LoggingEventType.ExtendedBuildMessageEvent => new ExtendedBuildMessageEventArgs(),
+                LoggingEventType.ExtendedCriticalBuildMessageEvent => new ExtendedCriticalBuildMessageEventArgs(),
                 LoggingEventType.ExternalProjectStartedEvent => new ExternalProjectStartedEventArgs(null, null, null, null, null),
                 LoggingEventType.ExternalProjectFinishedEvent => new ExternalProjectFinishedEventArgs(null, null, null, null, false),
                 LoggingEventType.CriticalBuildMessage => new CriticalBuildMessageEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
@@ -695,6 +701,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.CriticalBuildMessage;
             }
+            else if (eventType == typeof(ExtendedCriticalBuildMessageEventArgs))
+            {
+                return LoggingEventType.ExtendedCriticalBuildMessageEvent;
+            }
             else if (eventType == typeof(MetaprojectGeneratedEventArgs))
             {
                 return LoggingEventType.MetaprojectGenerated;
@@ -759,8 +769,8 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
         }
 
         /// <summary>
-        /// Given a build event that is presumed to be 2.0 (due to its lack of a "WriteToStream" method) and its 
-        /// LoggingEventType, serialize that event to the stream. 
+        /// Given a build event that is presumed to be 2.0 (due to its lack of a "WriteToStream" method) and its
+        /// LoggingEventType, serialize that event to the stream.
         /// </summary>
         private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType eventType, ITranslator translator)
         {
@@ -905,7 +915,7 @@ private void WriteTaskCommandLineEventToStream(TaskCommandLineEventArgs taskComm
         }
 
         /// <summary>
-        /// Write a "standard" Message Log the translator 
+        /// Write a "standard" Message Log the translator
         /// </summary>
         private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEventArgs, ITranslator translator)
         {
@@ -1134,8 +1144,8 @@ private void WriteMetadata(object metadataContainer, BinaryWriter writer)
         #region Reads from Stream
 
         /// <summary>
-        /// Given a build event that is presumed to be 2.0 (due to its lack of a "ReadFromStream" method) and its 
-        /// LoggingEventType, read that event from the stream. 
+        /// Given a build event that is presumed to be 2.0 (due to its lack of a "ReadFromStream" method) and its
+        /// LoggingEventType, read that event from the stream.
         /// </summary>
         private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslator translator)
         {
@@ -1297,7 +1307,7 @@ private TaskCommandLineEventArgs ReadTaskCommandLineEventFromStream(ITranslator
         }
 
         /// <summary>
-        /// Read and reconstruct a BuildMessageEventArgs from the stream 
+        /// Read and reconstruct a BuildMessageEventArgs from the stream
         /// </summary>
         private BuildMessageEventArgs ReadBuildMessageEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
         {
diff --git a/src/Shared/MetadataConversionUtilities.cs b/src/Shared/MetadataConversionUtilities.cs
index a6c121a1f52..a932217e7bc 100644
--- a/src/Shared/MetadataConversionUtilities.cs
+++ b/src/Shared/MetadataConversionUtilities.cs
@@ -10,14 +10,14 @@ namespace Microsoft.Build.Shared
 {
     /// <summary>
     /// This class contains only static methods, which are useful throughout many
-    /// of the XMake classes and don't really belong in any specific class.   
+    /// of the XMake classes and don't really belong in any specific class.
     /// </summary>
     internal static class MetadataConversionUtilities
     {
         /// <summary>
         /// Convert a task item metadata to bool. Throw an exception if the string is badly formed and can't
         /// be converted.
-        /// 
+        ///
         /// If the metadata is not found, then set metadataFound to false and then return false.
         /// </summary>
         /// <param name="item">The item that contains the metadata.</param>
@@ -50,7 +50,7 @@ internal static bool TryConvertItemMetadataToBool(
         /// <summary>
         /// Convert a task item metadata to bool. Throw an exception if the string is badly formed and can't
         /// be converted.
-        /// 
+        ///
         /// If the attribute is not found, then return false.
         /// </summary>
         /// <param name="item">The item that contains the metadata.</param>
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index 785e7c42ce1..a6c203525d2 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -27,11 +27,11 @@ internal static class ItemSpecModifiers
 #if DEBUG
             /// <summary>
             /// Whether to dump when a modifier is in the "wrong" (slow) casing
-            /// </summary>       
+            /// </summary>
             private static readonly bool s_traceModifierCasing = (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDTRACEMODIFIERCASING")));
 #endif
 
-            // NOTE: If you add an item here that starts with a new letter, you need to update the case 
+            // NOTE: If you add an item here that starts with a new letter, you need to update the case
             // statements in IsItemSpecModifier and IsDerivableItemSpecModifier.
             internal const string FullPath = "FullPath";
             internal const string RootDir = "RootDir";
@@ -83,21 +83,21 @@ internal static bool IsItemSpecModifier(string name)
                 }
 
 
-                /* 
+                /*
                  * What follows requires some explanation.
-                 * 
-                 * This function is called many times and slowness here will be amplified 
+                 *
+                 * This function is called many times and slowness here will be amplified
                  * in critical performance scenarios.
-                 * 
+                 *
                  * The following switch statement attempts to identify item spec modifiers that
-                 * have the exact case that our constants in ItemSpecModifiers have. This is the 
+                 * have the exact case that our constants in ItemSpecModifiers have. This is the
                  * 99% case.
-                 * 
+                 *
                  * Further, the switch statement can identify certain cases in which there is
                  * definitely no chance that 'name' is an item spec modifier. For example, a
                  * 7 letter 'name' that doesn't start with 'r' or 'R' can't be RootDir and
                  * therefore is not an item spec modifier.
-                 * 
+                 *
                  */
                 switch (name.Length)
                 {
@@ -245,8 +245,8 @@ internal static bool IsItemSpecModifier(string name)
             }
 
             /// <summary>
-            /// Indicates if the given name is reserved for one of the specific subset of itemspec 
-            /// modifiers to do with the defining project of the item. 
+            /// Indicates if the given name is reserved for one of the specific subset of itemspec
+            /// modifiers to do with the defining project of the item.
             /// </summary>
             internal static bool IsDefiningProjectModifier(string name)
             {
@@ -321,7 +321,7 @@ internal static bool IsDerivableItemSpecModifier(string name)
                     {
                         if (name[0] == 'R' || name[0] == 'r')
                         {
-                            // The only 12 letter ItemSpecModifier that starts with 'R' is 'RecursiveDir' 
+                            // The only 12 letter ItemSpecModifier that starts with 'R' is 'RecursiveDir'
                             return false;
                         }
                     }
@@ -342,7 +342,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
             /// <summary>
             /// Performs path manipulations on the given item-spec as directed.
-            /// 
+            ///
             /// Supported modifiers:
             ///     %(FullPath)         = full path of item
             ///     %(RootDir)          = root directory of item
@@ -355,7 +355,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
             ///     %(ModifiedTime)     = last write time of item
             ///     %(CreatedTime)      = creation time of item
             ///     %(AccessedTime)     = last access time of item
-            /// 
+            ///
             /// NOTES:
             /// 1) This method always returns an empty string for the %(RecursiveDir) modifier because it does not have enough
             ///    information to compute it -- only the BuildItem class can compute this modifier.
@@ -366,10 +366,10 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
             /// 1) successive slashes are combined into 1 slash
             /// 2) trailing periods are discarded
             /// 3) forward slashes are changed to back-slashes
-            /// 
+            ///
             /// As a result, we cannot rely on any file-spec that has passed through a Path method to remain the same. We will
             /// therefore not bother preserving slashes and periods when file-specs are transformed.
-            /// 
+            ///
             /// Never returns null.
             /// </remarks>
             /// <param name="currentDirectory">The root directory for relative item-specs. When called on the Engine thread, this is the project directory. When called as part of building a task, it is null, indicating that the current directory should be used.</param>
@@ -531,7 +531,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            // File does not exist, or path is a directory                        
+                            // File does not exist, or path is a directory
                             modifiedItemSpec = String.Empty;
                         }
                     }
@@ -547,7 +547,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         }
                         else
                         {
-                            // File does not exist, or path is a directory                        
+                            // File does not exist, or path is a directory
                             modifiedItemSpec = String.Empty;
                         }
                     }
diff --git a/src/Shared/NGen.cs b/src/Shared/NGen.cs
deleted file mode 100644
index f37252e7049..00000000000
--- a/src/Shared/NGen.cs
+++ /dev/null
@@ -1,50 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-#nullable disable
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// To avoid CA908 warnings (types that in ngen images that will JIT)
-    /// wrap each problematic value type in the collection in 
-    /// one of these objects.
-    /// </summary>
-    /// <comment>
-    /// This trick is based on advice from 
-    /// http://sharepoint/sites/codeanalysis/Wiki%20Pages/Rule%20-%20Avoid%20Types%20That%20Require%20JIT%20Compilation%20In%20Precompiled%20Assemblies.aspx.
-    /// It works because although this is a value type, it is not defined in mscorlib.
-    /// </comment>
-    /// <typeparam name="T">Wrapped type</typeparam>
-    internal struct NGen<T> where T : struct
-    {
-        /// <summary>
-        /// Wrapped value
-        /// </summary>
-        private T _value;
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public NGen(T value)
-        {
-            _value = value;
-        }
-
-        /// <summary>
-        /// Exposes the value
-        /// </summary>
-        public static implicit operator T(NGen<T> value)
-        {
-            return value._value;
-        }
-
-        /// <summary>
-        /// Consumes the value
-        /// </summary>
-        public static implicit operator NGen<T>(T value)
-        {
-            return new NGen<T>(value);
-        }
-    }
-}
diff --git a/src/Shared/NodeBuildComplete.cs b/src/Shared/NodeBuildComplete.cs
index 50c62b7cfd0..25aa30675f7 100644
--- a/src/Shared/NodeBuildComplete.cs
+++ b/src/Shared/NodeBuildComplete.cs
@@ -8,7 +8,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// The NodeBuildComplete packet is used to indicate to a node that it should clean up its current build and 
+    /// The NodeBuildComplete packet is used to indicate to a node that it should clean up its current build and
     /// possibly prepare for node reuse.
     /// </summary>
     internal class NodeBuildComplete : INodePacket
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index f9abb54236e..76705f4a6cb 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -220,7 +220,7 @@ internal void InternalConstruct(string pipeName = null)
                 // Restrict access to just this account.  We set the owner specifically here, and on the
                 // pipe client side they will check the owner against this one - they must have identical
                 // SIDs or the client will reject this server.  This is used to avoid attacks where a
-                // hacked server creates a less restricted pipe in an attempt to lure us into using it and 
+                // hacked server creates a less restricted pipe in an attempt to lure us into using it and
                 // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
                 PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite, AccessControlType.Allow);
                 security.AddAccessRule(rule);
@@ -516,7 +516,7 @@ private void PacketPumpProc()
         private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
             ConcurrentQueue<INodePacket> localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacketPump)
         {
-            // Ordering of the wait handles is important.  The first signalled wait handle in the array 
+            // Ordering of the wait handles is important.  The first signalled wait handle in the array
             // will be returned by WaitAny if multiple wait handles are signalled.  We prefer to have the
             // terminate event triggered so that we cannot get into a situation where packets are being
             // spammed to the endpoint and it never gets an opportunity to shutdown.
diff --git a/src/Shared/OutOfProcTaskHostTaskResult.cs b/src/Shared/OutOfProcTaskHostTaskResult.cs
index f1f86a48ac6..87d40fbdce1 100644
--- a/src/Shared/OutOfProcTaskHostTaskResult.cs
+++ b/src/Shared/OutOfProcTaskHostTaskResult.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Shared
     internal class OutOfProcTaskHostTaskResult
     {
         /// <summary>
-        /// Constructor 
+        /// Constructor
         /// </summary>
         internal OutOfProcTaskHostTaskResult(TaskCompleteType result)
             : this(result, null /* no final parameters */, null /* no exception */, null /* no exception message */, null /* and no args to go with it */)
@@ -56,8 +56,8 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, Exception taskExce
         /// </summary>
         internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string, Object> finalParams, Exception taskException, string exceptionMessage, string[] exceptionMessageArgs)
         {
-            // If we're returning a crashing result, we should always also be returning the exception that caused the crash, although 
-            // we may not always be returning an accompanying message. 
+            // If we're returning a crashing result, we should always also be returning the exception that caused the crash, although
+            // we may not always be returning an accompanying message.
             if (result == TaskCompleteType.CrashedDuringInitialization ||
                 result == TaskCompleteType.CrashedDuringExecution ||
                 result == TaskCompleteType.CrashedAfterExecution)
@@ -87,7 +87,7 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string
         }
 
         /// <summary>
-        /// The overall result of the task execution. 
+        /// The overall result of the task execution.
         /// </summary>
         public TaskCompleteType Result
         {
@@ -105,8 +105,8 @@ public IDictionary<string, Object> FinalParameterValues
         }
 
         /// <summary>
-        /// The exception thrown by the task during initialization or execution, 
-        /// if any. 
+        /// The exception thrown by the task during initialization or execution,
+        /// if any.
         /// </summary>
         public Exception TaskException
         {
@@ -115,8 +115,8 @@ public Exception TaskException
         }
 
         /// <summary>
-        /// The name of the resource representing the message to be logged along with the 
-        /// above exception. 
+        /// The name of the resource representing the message to be logged along with the
+        /// above exception.
         /// </summary>
         public string ExceptionMessage
         {
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
deleted file mode 100644
index ef5073b4835..00000000000
--- a/src/Shared/Pair.cs
+++ /dev/null
@@ -1,60 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Diagnostics.CodeAnalysis;
-
-#nullable disable
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// This struct is functionally identical to KeyValuePair, but avoids
-    /// CA908 warnings (types that in ngen images that will JIT).
-    /// Instead of generic collections of KeyValuePair, use Pair.
-    /// </summary>
-    /// <comment>
-    /// This trick is based on advice from 
-    /// http://sharepoint/sites/codeanalysis/Wiki%20Pages/Rule%20-%20Avoid%20Types%20That%20Require%20JIT%20Compilation%20In%20Precompiled%20Assemblies.aspx.
-    /// It works because although this is a value type, it is not defined in mscorlib.
-    /// </comment>
-    /// <typeparam name="TKey">Key</typeparam>
-    /// <typeparam name="TValue">Value</typeparam>
-    [SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes", Justification = "Not possible as Equals cannot be implemented on the struct members")]
-    internal struct Pair<TKey, TValue>
-    {
-        /// <summary>
-        /// Key
-        /// </summary>
-        private TKey _key;
-
-        /// <summary>
-        /// Value
-        /// </summary>
-        private TValue _value;
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public Pair(TKey key, TValue value)
-        {
-            _key = key;
-            _value = value;
-        }
-
-        /// <summary>
-        /// Key
-        /// </summary>
-        internal readonly TKey Key
-        {
-            get { return _key; }
-        }
-
-        /// <summary>
-        /// Value
-        /// </summary>
-        internal readonly TValue Value
-        {
-            get { return _value; }
-        }
-    }
-}
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index 226a7780017..18b9b361e3b 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -13,7 +13,7 @@
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-    /// This class contains only static methods, which are used in both the 
+    /// This class contains only static methods, which are used in both the
     /// tasks and graph projects in order for two projects to negotiate which platform a projectreference
     /// should be built as.
     /// </summary>
@@ -83,7 +83,7 @@ internal static string GetNearestPlatform(string overridePlatformValue, string r
             }
             else
             {
-                // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
+                // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine
                 // Platform/PlatformTarget when this is the case.
                 log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
             }
diff --git a/src/Shared/ProcessExtensions.cs b/src/Shared/ProcessExtensions.cs
index d384a07e32b..362a8b0a8c1 100644
--- a/src/Shared/ProcessExtensions.cs
+++ b/src/Shared/ProcessExtensions.cs
@@ -32,7 +32,7 @@ public static void KillTree(this Process process, int timeoutMilliseconds)
                 throw new System.NotSupportedException();
             }
 #endif
-            // wait until the process finishes exiting/getting killed. 
+            // wait until the process finishes exiting/getting killed.
             // We don't want to wait forever here because the task is already supposed to be dieing, we just want to give it long enough
             // to try and flush what it can and stop. If it cannot do that in a reasonable time frame then we will just ignore it.
             process.WaitForExit(timeoutMilliseconds);
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index cfcb32e793a..a7c9fce240a 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -239,11 +239,11 @@ internal static void VerifyThrowInvalidProject<T1, T2, T3, T4>(bool condition, s
 
         /// <summary>
         /// Throws an InvalidProjectFileException using the given data.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
-        /// 
+        ///
         /// </summary>
         /// <param name="errorSubCategoryResourceName">The resource string for the
         /// error sub-category (can be null).</param>
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index c6875603ce0..ddb67234b5b 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -17,7 +17,7 @@ internal static class ProjectFileErrorUtilities
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -35,7 +35,7 @@ internal static void ThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -55,7 +55,7 @@ internal static void ThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -75,7 +75,7 @@ internal static void VerifyThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -95,7 +95,7 @@ internal static void ThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -117,7 +117,7 @@ internal static void VerifyThrowInvalidProjectFile(
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
diff --git a/src/Shared/PropertyParser.cs b/src/Shared/PropertyParser.cs
index 8144cc22191..a9e1c29d72c 100644
--- a/src/Shared/PropertyParser.cs
+++ b/src/Shared/PropertyParser.cs
@@ -20,8 +20,8 @@ namespace Microsoft.Build.Tasks
     internal static class PropertyParser
     {
         /// <summary>
-        /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
-        /// a hash table containing the property names as keys and the property values as values.  
+        /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates
+        /// a hash table containing the property names as keys and the property values as values.
         /// </summary>
         /// <returns>true on success, false on failure.</returns>
         internal static bool GetTable(TaskLoggingHelper log, string parameterName, string[] propertyList, out Dictionary<string, string> propertiesTable)
@@ -43,9 +43,9 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
                     int indexOfEqualsSign = propertyNameValuePair.IndexOf('=');
 
                     // If we found one, then grab the stuff before it and put it into "propertyName",
-                    // and grab the stuff after it and put it into "propertyValue".  But trim the 
-                    // whitespace from beginning and end of both name and value.  (When authoring a 
-                    // project/targets file, people like to use whitespace and newlines to pretty up 
+                    // and grab the stuff after it and put it into "propertyValue".  But trim the
+                    // whitespace from beginning and end of both name and value.  (When authoring a
+                    // project/targets file, people like to use whitespace and newlines to pretty up
                     // the file format.)
                     if (indexOfEqualsSign != -1)
                     {
@@ -63,7 +63,7 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
                     }
 
                     // Bag the property and its value.  Trim whitespace from beginning and end of
-                    // both name and value.  (When authoring a project/targets file, people like to 
+                    // both name and value.  (When authoring a project/targets file, people like to
                     // use whitespace and newlines to pretty up the file format.)
                     propertiesTable[propertyName] = propertyValue;
                 }
@@ -73,9 +73,9 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
         }
 
         /// <summary>
-        /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates 
-        /// a hash table containing the property names as keys and the property values as values.  
-        /// This method escapes any special characters found in the property values, in case they 
+        /// Given a string of semi-colon delimited name=value pairs, this method parses it and creates
+        /// a hash table containing the property names as keys and the property values as values.
+        /// This method escapes any special characters found in the property values, in case they
         /// are going to be passed to a method (such as that expects the appropriate escaping to have happened
         /// already.
         /// </summary>
@@ -99,9 +99,9 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
                     if (indexOfEqualsSign != -1)
                     {
                         // If we found one, then grab the stuff before it and put it into "propertyName",
-                        // and grab the stuff after it and put it into "propertyValue".  But trim the 
-                        // whitespace from beginning and end of both name and value.  (When authoring a 
-                        // project/targets file, people like to use whitespace and newlines to pretty up 
+                        // and grab the stuff after it and put it into "propertyValue".  But trim the
+                        // whitespace from beginning and end of both name and value.  (When authoring a
+                        // project/targets file, people like to use whitespace and newlines to pretty up
                         // the file format.)
                         string propertyName = propertyNameValueString.Substring(0, indexOfEqualsSign).Trim();
                         string propertyValue = EscapingUtilities.Escape(propertyNameValueString.Substring(indexOfEqualsSign + 1).Trim());
diff --git a/src/Shared/QuotingUtilities.cs b/src/Shared/QuotingUtilities.cs
index eb25b416f0a..17ca8a419db 100644
--- a/src/Shared/QuotingUtilities.cs
+++ b/src/Shared/QuotingUtilities.cs
@@ -11,34 +11,34 @@
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-    /// This class implements some static methods to assist with command-line parsing of 
+    /// This class implements some static methods to assist with command-line parsing of
     /// parameters that could be quoted, and thus could contain nested escaped quotes.
     /// </summary>
     internal static class QuotingUtilities
     {
         /*
          * Quoting Rules:
-         * 
+         *
          * A string is considered quoted if it is enclosed in double-quotes. A double-quote can be escaped with a backslash, or it
          * is automatically escaped if it is the last character in an explicitly terminated quoted string. A backslash itself can
          * be escaped with another backslash IFF it precedes a double-quote, otherwise it is interpreted literally.
-         * 
+         *
          * e.g.
          *      abc"cde"xyz         --> "cde" is quoted
          *      abc"xyz             --> "xyz" is quoted (the terminal double-quote is assumed)
          *      abc"xyz"            --> "xyz" is quoted (the terminal double-quote is explicit)
-         * 
+         *
          *      abc\"cde"xyz        --> "xyz" is quoted (the terminal double-quote is assumed)
          *      abc\\"cde"xyz       --> "cde" is quoted
          *      abc\\\"cde"xyz      --> "xyz" is quoted (the terminal double-quote is assumed)
-         * 
+         *
          *      abc"""xyz           --> """ is quoted
          *      abc""""xyz          --> """ and "xyz" are quoted (the terminal double-quote is assumed)
          *      abc"""""xyz         --> """ is quoted
          *      abc""""""xyz        --> """ and """ are quoted
          *      abc"cde""xyz        --> "cde"" is quoted
          *      abc"xyz""           --> "xyz"" is quoted (the terminal double-quote is explicit)
-         * 
+         *
          *      abc""xyz            --> nothing is quoted
          *      abc""cde""xyz       --> nothing is quoted
          */
diff --git a/src/Shared/ReadOnlyCollection.cs b/src/Shared/ReadOnlyCollection.cs
index d7e5c12ce5a..c3a13f5e58a 100644
--- a/src/Shared/ReadOnlyCollection.cs
+++ b/src/Shared/ReadOnlyCollection.cs
@@ -29,9 +29,9 @@ internal sealed class ReadOnlyCollection<T> : ICollection<T>, ICollection
         private IEnumerable<T> _backing;
 
         /// <summary>
-        /// Construct a read only wrapper around the current contents 
-        /// of the IEnumerable, or around the backing collection if the 
-        /// IEnumerable is in fact a collection. 
+        /// Construct a read only wrapper around the current contents
+        /// of the IEnumerable, or around the backing collection if the
+        /// IEnumerable is in fact a collection.
         /// </summary>
         internal ReadOnlyCollection(IEnumerable<T> backing)
         {
@@ -114,8 +114,8 @@ public void Clear()
         /// </summary>
         public bool Contains(T item)
         {
-            // UNDONE: IEnumerable.Contains<T>() does the ICollection check, 
-            // so we could just use IEnumerable.Contains<T>() here.  
+            // UNDONE: IEnumerable.Contains<T>() does the ICollection check,
+            // so we could just use IEnumerable.Contains<T>() here.
             if (!(_backing is ICollection<T>))
             {
                 return _backing.Contains<T>(item);
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index 7677de76590..d7d25b7d962 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -44,7 +44,7 @@ static RegisteredTaskObjectCacheBase()
 
         #region IRegisteredTaskObjectCache
 
-        /// <summary> 
+        /// <summary>
         /// Disposes of all of the cached objects registered with the specified lifetime.
         /// </summary>
         public void DisposeCacheObjects(RegisteredTaskObjectLifetime lifetime)
diff --git a/src/Shared/RegistryHelper.cs b/src/Shared/RegistryHelper.cs
index 43b846f2478..c86163701ac 100644
--- a/src/Shared/RegistryHelper.cs
+++ b/src/Shared/RegistryHelper.cs
@@ -18,7 +18,7 @@ internal static class RegistryHelper
         /// </summary>
         /// <param name="baseKey">The base registry key.</param>
         /// <param name="subkey">The subkey</param>
-        /// <returns>An enumeration of strings.</returns>        
+        /// <returns>An enumeration of strings.</returns>
         internal static IEnumerable<string>? GetSubKeyNames(RegistryKey baseKey, string subkey)
         {
             IEnumerable<string>? subKeys = null;
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index 2e2fec9ad0f..deaf884e4d5 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -24,7 +24,7 @@ namespace Microsoft.Build.Shared
     internal static class ResourceUtilities
     {
         /// <summary>
-        /// Extracts the message code (if any) prefixed to the given string. 
+        /// Extracts the message code (if any) prefixed to the given string.
         /// <![CDATA[
         /// MSBuild codes match "^\s*(?<CODE>MSB\d\d\d\d):\s*(?<MESSAGE>.*)$"
         /// Arbitrary codes match "^\s*(?<CODE>[A-Za-z]+\d+):\s*(?<MESSAGE>.*)$"
@@ -154,7 +154,7 @@ internal static string GetResourceString(string resourceName)
         /// <summary>
         /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they too are returned.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -182,7 +182,7 @@ internal static string FormatResourceString(string resourceName)
         /// <summary>
         /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they are discarded.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
@@ -213,10 +213,10 @@ internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceN
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="unformatted">The string to format.</param>
@@ -230,7 +230,7 @@ internal static string FormatString(string unformatted, params object[] args)
             if ((args?.Length > 0))
             {
 #if DEBUG
-                // If you accidentally pass some random type in that can't be converted to a string, 
+                // If you accidentally pass some random type in that can't be converted to a string,
                 // FormatResourceString calls ToString() which returns the full name of the type!
                 foreach (object param in args)
                 {
diff --git a/src/Shared/SolutionConfiguration.cs b/src/Shared/SolutionConfiguration.cs
index a271f2645f4..78ed1652105 100644
--- a/src/Shared/SolutionConfiguration.cs
+++ b/src/Shared/SolutionConfiguration.cs
@@ -52,11 +52,11 @@ public SolutionConfiguration(string xmlString)
                     string projectGuid = xmlElement.GetAttribute(ProjectAttribute);
                     string projectAbsolutePath = xmlElement.GetAttribute(AbsolutePathAttribute);
 
-                    // What we really want here is the normalized path, like we'd get with an item's "FullPath" metadata.  However, 
-                    // if there's some bogus full path in the solution configuration (e.g. a website with a "full path" of c:\solutiondirectory\http://localhost) 
-                    // we do NOT want to throw -- chances are extremely high that that's information that will never actually be used.  So resolve the full path 
-                    // but just swallow any IO-related exceptions that result.  If the path is bogus, the method will return null, so we'll just quietly fail 
-                    // to cache it below. 
+                    // What we really want here is the normalized path, like we'd get with an item's "FullPath" metadata.  However,
+                    // if there's some bogus full path in the solution configuration (e.g. a website with a "full path" of c:\solutiondirectory\http://localhost)
+                    // we do NOT want to throw -- chances are extremely high that that's information that will never actually be used.  So resolve the full path
+                    // but just swallow any IO-related exceptions that result.  If the path is bogus, the method will return null, so we'll just quietly fail
+                    // to cache it below.
                     projectAbsolutePath = FileUtilities.GetFullPathNoThrow(projectAbsolutePath);
 
                     if (!string.IsNullOrEmpty(projectGuid))
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index 102681f6050..ac9476181eb 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -521,12 +521,12 @@ int StrongNameTokenFromPublicKey(
 
     /// <summary>
     /// This is a managed wrapper for the IClrStrongName interface defined in metahost.idl
-    /// This is very similar to the standard RCWs provided in 
+    /// This is very similar to the standard RCWs provided in
     /// ndp/fx/src/hosting/interop/microsoft/runtime/hosting/interop, but we don't want to
     /// reference that assembly (part of the SDK only, not .NET redist).  Also, our version
     /// is designed specifically for easy migration from the old mscoree APIs, for example
     /// all APIs return HResults rather than throw exceptions.
-    /// </summary> 
+    /// </summary>
     [System.Security.SecurityCritical]
     [ComImport]
     [ComConversionLoss]
diff --git a/src/Shared/TaskEngineAssemblyResolver.cs b/src/Shared/TaskEngineAssemblyResolver.cs
index 6f8cf5157d8..44b243ab0f0 100644
--- a/src/Shared/TaskEngineAssemblyResolver.cs
+++ b/src/Shared/TaskEngineAssemblyResolver.cs
@@ -42,10 +42,10 @@ internal void Initialize(string taskAssemblyFileToResolve)
         }
 
         /// <summary>
-        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain, 
+        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain,
         /// so it's possible to create an AppDomain, create an instance of this class in it and use this method to install
         /// an event handler in that AppDomain. Since the event handler instance is stored internally, this method
-        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do 
+        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do
         /// anything else).
         /// </summary>
         internal void InstallHandler()
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 822495b0179..9a9c199f732 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -5,7 +5,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
-
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -13,7 +13,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// TaskHostConfiguration contains information needed for the task host to 
+    /// TaskHostConfiguration contains information needed for the task host to
     /// configure itself for to execute a particular task.
     /// </summary>
     internal class TaskHostConfiguration : INodePacket
@@ -45,23 +45,23 @@ internal class TaskHostConfiguration : INodePacket
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// The AppDomainSetup that we may want to use on AppDomainIsolated tasks. 
+        /// The AppDomainSetup that we may want to use on AppDomainIsolated tasks.
         /// </summary>
         private AppDomainSetup _appDomainSetup;
 #endif
 
         /// <summary>
-        /// Line number where the instance of this task is defined. 
+        /// Line number where the instance of this task is defined.
         /// </summary>
         private int _lineNumberOfTask;
 
         /// <summary>
-        /// Column number where the instance of this task is defined. 
+        /// Column number where the instance of this task is defined.
         /// </summary>
         private int _columnNumberOfTask;
 
         /// <summary>
-        /// Project file where the instance of this task is defined. 
+        /// Project file where the instance of this task is defined.
         /// </summary>
         private string _projectFileOfTask;
 
@@ -71,12 +71,12 @@ internal class TaskHostConfiguration : INodePacket
         private bool _continueOnError;
 
         /// <summary>
-        /// Name of the task to be executed on the task host. 
+        /// Name of the task to be executed on the task host.
         /// </summary>
         private string _taskName;
 
         /// <summary>
-        /// Location of the assembly containing the task to be executed. 
+        /// Location of the assembly containing the task to be executed.
         /// </summary>
         private string _taskLocation;
 
@@ -86,7 +86,7 @@ internal class TaskHostConfiguration : INodePacket
         private bool _isTaskInputLoggingEnabled;
 
         /// <summary>
-        /// The set of parameters to apply to the task prior to execution.  
+        /// The set of parameters to apply to the task prior to execution.
         /// </summary>
         private Dictionary<string, TaskParameter> _taskParameters;
 
@@ -209,7 +209,7 @@ public TaskHostConfiguration(
         }
 
         /// <summary>
-        /// Constructor for deserialization. 
+        /// Constructor for deserialization.
         /// </summary>
         private TaskHostConfiguration()
         {
@@ -268,7 +268,7 @@ public CultureInfo UICulture
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// The AppDomain configuration bytes that we may want to use to initialize
-        /// AppDomainIsolated tasks. 
+        /// AppDomainIsolated tasks.
         /// </summary>
         public AppDomainSetup AppDomainSetup
         {
@@ -279,7 +279,7 @@ public AppDomainSetup AppDomainSetup
 #endif
 
         /// <summary>
-        /// Line number where the instance of this task is defined. 
+        /// Line number where the instance of this task is defined.
         /// </summary>
         public int LineNumberOfTask
         {
@@ -289,7 +289,7 @@ public int LineNumberOfTask
         }
 
         /// <summary>
-        /// Column number where the instance of this task is defined. 
+        /// Column number where the instance of this task is defined.
         /// </summary>
         public int ColumnNumberOfTask
         {
@@ -309,7 +309,7 @@ public bool ContinueOnError
         }
 
         /// <summary>
-        /// Project file where the instance of this task is defined. 
+        /// Project file where the instance of this task is defined.
         /// </summary>
         public string ProjectFileOfTask
         {
@@ -319,7 +319,7 @@ public string ProjectFileOfTask
         }
 
         /// <summary>
-        /// Name of the task to execute. 
+        /// Name of the task to execute.
         /// </summary>
         public string TaskName
         {
@@ -329,7 +329,7 @@ public string TaskName
         }
 
         /// <summary>
-        /// Path to the assembly to load the task from. 
+        /// Path to the assembly to load the task from.
         /// </summary>
         public string TaskLocation
         {
@@ -349,7 +349,7 @@ public bool IsTaskInputLoggingEnabled
         }
 
         /// <summary>
-        /// Parameters to set on the instantiated task prior to execution. 
+        /// Parameters to set on the instantiated task prior to execution.
         /// </summary>
         public Dictionary<string, TaskParameter> TaskParameters
         {
@@ -417,7 +417,28 @@ public void Translate(ITranslator translator)
             translator.TranslateCulture(ref _culture);
             translator.TranslateCulture(ref _uiCulture);
 #if FEATURE_APPDOMAIN
-            translator.TranslateDotNet(ref _appDomainSetup);
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
+            {
+                byte[] appDomainConfigBytes = null;
+
+                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+                if (translator.Mode == TranslationDirection.WriteToStream)
+                {
+                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+                }
+
+                translator.Translate(ref appDomainConfigBytes);
+
+                if (translator.Mode == TranslationDirection.ReadFromStream)
+                {
+                    _appDomainSetup = new AppDomainSetup();
+                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
+                }
+            }
+            else
+            {
+                translator.TranslateDotNet(ref _appDomainSetup);
+            }
 #endif
             translator.Translate(ref _lineNumberOfTask);
             translator.Translate(ref _columnNumberOfTask);
@@ -458,6 +479,7 @@ internal static INodePacket FactoryForDeserialization(ITranslator translator)
         {
             TaskHostConfiguration configuration = new TaskHostConfiguration();
             configuration.Translate(translator);
+
             return configuration;
         }
     }
diff --git a/src/Shared/TaskHostTaskCancelled.cs b/src/Shared/TaskHostTaskCancelled.cs
index d357e55b94a..f56e61a34d9 100644
--- a/src/Shared/TaskHostTaskCancelled.cs
+++ b/src/Shared/TaskHostTaskCancelled.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// TaskHostTaskCancelled informs the task host that the task it is 
+    /// TaskHostTaskCancelled informs the task host that the task it is
     /// currently executing has been canceled.
     /// </summary>
     internal class TaskHostTaskCancelled : INodePacket
@@ -32,7 +32,7 @@ public NodePacketType Type
         /// <param name="translator">The translator to use.</param>
         public void Translate(ITranslator translator)
         {
-            // Do nothing -- this packet doesn't contain any parameters. 
+            // Do nothing -- this packet doesn't contain any parameters.
         }
 
         /// <summary>
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index faad07dd31e..4979b8da24a 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -1,9 +1,12 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Experimental.FileAccess;
+#endif
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -26,8 +29,8 @@ internal enum TaskCompleteType
         Failure,
 
         /// <summary>
-        /// Task crashed during initialization steps -- loading the task, 
-        /// validating or setting the parameters, etc. 
+        /// Task crashed during initialization steps -- loading the task,
+        /// validating or setting the parameters, etc.
         /// </summary>
         CrashedDuringInitialization,
 
@@ -44,36 +47,40 @@ internal enum TaskCompleteType
     }
 
     /// <summary>
-    /// TaskHostTaskComplete contains all the information the parent node 
+    /// TaskHostTaskComplete contains all the information the parent node
     /// needs from the task host on completion of task execution.
     /// </summary>
     internal class TaskHostTaskComplete : INodePacket
     {
+#if FEATURE_REPORTFILEACCESSES
+        private List<FileAccessData> _fileAccessData;
+#endif
+
         /// <summary>
-        /// Result of the task's execution. 
+        /// Result of the task's execution.
         /// </summary>
         private TaskCompleteType _taskResult;
 
         /// <summary>
-        /// If the task threw an exception during its initialization or execution, 
-        /// save it here. 
+        /// If the task threw an exception during its initialization or execution,
+        /// save it here.
         /// </summary>
         private Exception _taskException;
 
         /// <summary>
-        /// If there's an additional message that should be attached to the error 
-        /// logged beyond "task X failed unexpectedly", save it here.  May be null. 
+        /// If there's an additional message that should be attached to the error
+        /// logged beyond "task X failed unexpectedly", save it here.  May be null.
         /// </summary>
         private string _taskExceptionMessage;
 
         /// <summary>
-        /// If the message saved in taskExceptionMessage requires arguments, save 
-        /// them here. May be null. 
+        /// If the message saved in taskExceptionMessage requires arguments, save
+        /// them here. May be null.
         /// </summary>
         private string[] _taskExceptionMessageArgs;
 
         /// <summary>
-        /// The set of parameters / values from the task after it finishes execution. 
+        /// The set of parameters / values from the task after it finishes execution.
         /// </summary>
         private Dictionary<string, TaskParameter> _taskOutputParameters = null;
 
@@ -82,12 +89,21 @@ internal class TaskHostTaskComplete : INodePacket
         /// </summary>
         private Dictionary<string, string> _buildProcessEnvironment = null;
 
+
+#pragma warning disable CS1572 // XML comment has a param tag, but there is no parameter by that name. Justification: xmldoc doesn't seem to interact well with #ifdef of params.
         /// <summary>
-        /// Constructor
+        /// Initializes a new instance of the <see cref="TaskHostTaskComplete"/> class.
         /// </summary>
-        /// <param name="result">Result of the task's execution.</param>
+        /// <param name="result">The result of the task's execution.</param>
+        /// <param name="fileAccessData">The file accesses reported by the task.</param>
         /// <param name="buildProcessEnvironment">The build process environment as it was at the end of the task's execution.</param>
-        public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<string, string> buildProcessEnvironment)
+#pragma warning restore CS1572 // XML comment has a param tag, but there is no parameter by that name
+        public TaskHostTaskComplete(
+            OutOfProcTaskHostTaskResult result,
+#if FEATURE_REPORTFILEACCESSES
+            List<FileAccessData> fileAccessData,
+#endif
+            IDictionary<string, string> buildProcessEnvironment)
         {
             ErrorUtilities.VerifyThrowInternalNull(result, nameof(result));
 
@@ -95,6 +111,9 @@ public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<stri
             _taskException = result.TaskException;
             _taskExceptionMessage = result.ExceptionMessage;
             _taskExceptionMessageArgs = result.ExceptionMessageArgs;
+#if FEATURE_REPORTFILEACCESSES
+            _fileAccessData = fileAccessData;
+#endif
 
             if (result.FinalParameterValues != null)
             {
@@ -134,8 +153,8 @@ public TaskCompleteType TaskResult
         }
 
         /// <summary>
-        /// If the task threw an exception during its initialization or execution, 
-        /// save it here. 
+        /// If the task threw an exception during its initialization or execution,
+        /// save it here.
         /// </summary>
         public Exception TaskException
         {
@@ -145,8 +164,8 @@ public Exception TaskException
         }
 
         /// <summary>
-        /// If there's an additional message that should be attached to the error 
-        /// logged beyond "task X failed unexpectedly", put it here.  May be null. 
+        /// If there's an additional message that should be attached to the error
+        /// logged beyond "task X failed unexpectedly", put it here.  May be null.
         /// </summary>
         public string TaskExceptionMessage
         {
@@ -156,8 +175,8 @@ public string TaskExceptionMessage
         }
 
         /// <summary>
-        /// If there are arguments that need to be formatted into the message being 
-        /// sent, set them here.  May be null. 
+        /// If there are arguments that need to be formatted into the message being
+        /// sent, set them here.  May be null.
         /// </summary>
         public string[] TaskExceptionMessageArgs
         {
@@ -201,6 +220,17 @@ public NodePacketType Type
             get { return NodePacketType.TaskHostTaskComplete; }
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Gets the file accesses reported by the task.
+        /// </summary>
+        public List<FileAccessData> FileAccessData
+        {
+            [DebuggerStepThrough]
+            get => _fileAccessData;
+        }
+#endif
+
         /// <summary>
         /// Translates the packet to/from binary form.
         /// </summary>
@@ -213,6 +243,13 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _taskExceptionMessageArgs);
             translator.TranslateDictionary(ref _taskOutputParameters, StringComparer.OrdinalIgnoreCase, TaskParameter.FactoryForDeserialization);
             translator.TranslateDictionary(ref _buildProcessEnvironment, StringComparer.OrdinalIgnoreCase);
+#if FEATURE_REPORTFILEACCESSES
+            translator.Translate(ref _fileAccessData,
+                (ITranslator translator, ref FileAccessData data) => ((ITranslatable)data).Translate(translator));
+#else
+            bool hasFileAccessData = false;
+            translator.Translate(ref hasFileAccessData);
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index b74e7ce01d8..ea170a16a08 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -23,7 +23,7 @@ internal static class TaskLoader
 #endif
 
         /// <summary>
-        /// Delegate for logging task loading errors. 
+        /// Delegate for logging task loading errors.
         /// </summary>
         internal delegate void LogError(string taskLocation, int taskLine, int taskColumn, string message, params object[] messageArgs);
 
@@ -39,7 +39,7 @@ internal static bool IsTaskClass(Type type, object unused)
         }
 
         /// <summary>
-        /// Creates an ITask instance and returns it.  
+        /// Creates an ITask instance and returns it.
         /// </summary>
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
         internal static ITask CreateTask(
@@ -116,7 +116,7 @@ bool isOutOfProc
                             taskAppDomain.Load(loadedType.LoadedAssemblyName);
                         }
 
-                        // Hook up last minute dumping of any exceptions 
+                        // Hook up last minute dumping of any exceptions
                         taskAppDomain.UnhandledException += ExceptionHandling.UnhandledExceptionHandler;
                         appDomainCreated?.Invoke(taskAppDomain);
                     }
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 4e0c4548bd7..da848678ded 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -127,7 +127,7 @@ protected IBuildEngine BuildEngine
         {
             get
             {
-                // If the task instance does not equal null then use its build engine because 
+                // If the task instance does not equal null then use its build engine because
                 // the task instances build engine can be changed for example during tests. This changing of the engine on the same task object is not expected to happen
                 // during normal operation.
                 if (_taskInstance != null)
@@ -187,10 +187,10 @@ public string ExtractMessageCode(string message, out string messageWithoutCodePr
         /// <summary>
         /// Loads the specified resource string and optionally formats it using the given arguments. The current thread's culture
         /// is used for formatting.
-        /// 
+        ///
         /// Requires the owner task to have registered its resources either via the Task (or TaskMarshalByRef) base
         /// class constructor, or the Task.TaskResources (or AppDomainIsolatedTask.TaskResources) property.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="resourceName">The name of the string resource to load.</param>
@@ -792,14 +792,14 @@ public void LogErrorFromResources(
         }
 
         /// <summary>
-        /// Logs an error using the specified resource string. 
+        /// Logs an error using the specified resource string.
         /// If the message has an error code prefixed to it, the code is extracted and logged with the message. If a help keyword
         /// prefix has been provided, a help keyword for the host IDE is also logged with the message. The help keyword is
         /// composed by appending the string resource name to the prefix.
-        /// 
+        ///
         /// A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
         /// Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="messageResourceName">The name of the string resource to load.</param>
@@ -811,14 +811,14 @@ public void LogErrorWithCodeFromResources(string messageResourceName, params obj
         }
 
         /// <summary>
-        /// Logs an error using the specified resource string and other error details. 
+        /// Logs an error using the specified resource string and other error details.
         /// If the message has an error code prefixed, the code is extracted and logged with the message. If a
         /// help keyword prefix has been provided, a help keyword for the host IDE is also logged with the message. The help
         /// keyword is composed by appending the error message resource string name to the prefix.
-        /// 
+        ///
         /// A task can provide a help keyword prefix either via the Task (or TaskMarshalByRef) base class constructor, or the
         /// Task.HelpKeywordPrefix (or AppDomainIsolatedTask.HelpKeywordPrefix) property.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <param name="subcategoryResourceName">The name of the string resource that describes the error type (can be null).</param>
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index c73af5ba444..190f0dddf2b 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -20,6 +20,8 @@ internal static partial class FileUtilities
         // Lower order bits correspond to the same for "group" or "other" users.
         private const int userRWX = 0x100 | 0x80 | 0x40;
         private static string tempFileDirectory = null;
+        private const string msbuildTempFolderPrefix = "MSBuildTemp";
+
         internal static string TempFileDirectory
         {
             get
@@ -36,7 +38,12 @@ internal static void ClearTempFileDirectory()
         // For all native calls, directly check their return values to prevent bad actors from getting in between checking if a directory exists and returning it.
         private static string CreateFolderUnderTemp()
         {
-            string basePath = Path.Combine(Path.GetTempPath(), $"MSBuildTemp{Environment.UserName}");
+            // On windows Username with Unicode chars can give issues, so we dont append username to the temp folder name.
+            string msbuildTempFolder = NativeMethodsShared.IsWindows ?
+                msbuildTempFolderPrefix :
+                msbuildTempFolderPrefix + Environment.UserName;
+
+            string basePath = Path.Combine(Path.GetTempPath(), msbuildTempFolder);
 
             if (NativeMethodsShared.IsLinux && NativeMethodsShared.mkdir(basePath, userRWX) != 0)
             {
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index d26f7127305..87b3a3b7e67 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Internal
     /// </summary>
     internal static class Tracing
     {
-        // Disabling warning about unused fields -- this is effectively a 
+        // Disabling warning about unused fields -- this is effectively a
         // debug-only class, so these fields cause a build break in RET
 #pragma warning disable 649
         /// <summary>
@@ -44,7 +44,7 @@ internal static class Tracing
 
         /// <summary>
         /// Short name of the current assembly - to distinguish statics when this type is shared into different assemblies
-        /// </summary> 
+        /// </summary>
         private static string s_currentAssemblyName;
 #pragma warning restore 649
 
@@ -141,7 +141,6 @@ internal static void List<T>(IEnumerable<T> items)
         /// Dump all the named counters, if any
         /// </summary>
         [Conditional("DEBUG")]
-        [SuppressMessage("Microsoft.MSInternal", "CA908:AvoidTypesThatRequireJitCompilationInPrecompiledAssemblies", Justification = "Debug only")]
         internal static void Dump()
         {
             if (s_counts.Count > 0)
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 37150f3f85a..f9426436f8d 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -191,7 +191,7 @@ private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo as
             string path = assemblyLoadInfo.AssemblyFile;
             string[] localAssemblies = Directory.GetFiles(Path.GetDirectoryName(path), "*.dll");
 
-            // Deduplicate between MSBuild assemblies and task dependencies. 
+            // Deduplicate between MSBuild assemblies and task dependencies.
             Dictionary<string, string> assembliesDictionary = new(localAssemblies.Length + runtimeAssemblies.Length);
             foreach (string localPath in localAssemblies)
             {
@@ -240,7 +240,7 @@ internal LoadedType ReflectionOnlyLoad(
         /// </summary>
         private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly, bool useTaskHost)
         {
-            // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which 
+            // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which
             // will map a specific AssemblyLoadInfo to a AssemblyInfoToLoadedTypes class which knows how to find a typeName in a given assembly.
             ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes> loadInfoToType =
                 cache.GetOrAdd(_isDesiredType, (_) => new ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>());
@@ -255,7 +255,7 @@ private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>,
         /// <summary>
         /// Given a type filter and an asssemblyInfo object keep track of what types in a given assembly which match the type filter.
         /// Also, use this information to determine if a given TypeName is in the assembly which is pointed to by the AssemblyLoadInfo object.
-        /// 
+        ///
         /// This type represents a combination of a type filter and an assemblyInfo object.
         /// </summary>
         [DebuggerDisplay("Types in {_assemblyLoadInfo} matching {_isDesiredType}")]
@@ -263,7 +263,7 @@ private class AssemblyInfoToLoadedTypes
         {
             /// <summary>
             /// Lock to prevent two threads from using this object at the same time.
-            /// Since we fill up internal structures with what is in the assembly 
+            /// Since we fill up internal structures with what is in the assembly
             /// </summary>
             private readonly Object _lockObject = new Object();
 
@@ -405,7 +405,7 @@ private LoadedType GetLoadedTypeFromTypeNameUsingMetadataLoadContext(string type
             }
 
             /// <summary>
-            /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on 
+            /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on
             /// to find tasks, loggers, and task factories.
             /// </summary>
             private void ScanAssemblyForPublicTypes()
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 5efa28ce676..1114e941ff9 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -319,7 +319,7 @@ public void CompareBaseNameRealCase1()
 
         /// <summary>
         /// Verify an exception is thrown when the simple name is not in the itemspec.
-        /// 
+        ///
         /// </summary>
         [Fact]
         public void CreateAssemblyNameExtensionWithNoSimpleName()
@@ -648,7 +648,7 @@ public void VerifyAssemblyNameComparers()
 
 
         /// <summary>
-        /// Make sure the reverse version comparer will compare the version in a way that would sort them in reverse order. 
+        /// Make sure the reverse version comparer will compare the version in a way that would sort them in reverse order.
         /// </summary>
         [Fact]
         public void VerifyReverseVersionComparer()
diff --git a/src/Shared/UnitTests/BuildEventArgsExtension.cs b/src/Shared/UnitTests/BuildEventArgsExtension.cs
index eb492bbecd7..4ccf2f47b5c 100644
--- a/src/Shared/UnitTests/BuildEventArgsExtension.cs
+++ b/src/Shared/UnitTests/BuildEventArgsExtension.cs
@@ -17,7 +17,7 @@ internal static class BuildEventArgsExtension
     {
         /// <summary>
         /// Extension method to help our tests without adding shipping code.
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="args">The 'this' object</param>
@@ -82,7 +82,7 @@ public static bool IsEquivalent(this BuildEventArgs args, BuildEventArgs other)
 
         /// <summary>
         /// Extension method to help our tests without adding shipping code.
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="args">The 'this' object</param>
@@ -114,7 +114,7 @@ public static bool IsEquivalent(this BuildMessageEventArgs args, BuildMessageEve
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -160,7 +160,7 @@ public static bool IsEquivalent(this BuildErrorEventArgs args, BuildErrorEventAr
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -206,7 +206,7 @@ public static bool IsEquivalent(this BuildWarningEventArgs args, BuildWarningEve
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -227,7 +227,7 @@ public static bool IsEquivalent(ProjectStartedEventArgs args, ProjectStartedEven
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -248,7 +248,7 @@ public static bool IsEquivalent(ExternalProjectStartedEventArgs args, ExternalPr
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -269,7 +269,7 @@ public static bool IsEquivalent(ProjectFinishedEventArgs args, ProjectFinishedEv
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -290,7 +290,7 @@ public static bool IsEquivalent(ExternalProjectFinishedEventArgs args, ExternalP
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -320,7 +320,7 @@ public static bool IsEquivalent(TargetStartedEventArgs args, TargetStartedEventA
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -385,7 +385,7 @@ public static bool IsEquivalent(TargetFinishedEventArgs args, TargetFinishedEven
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
@@ -411,7 +411,7 @@ public static bool IsEquivalent(TaskStartedEventArgs args, TaskStartedEventArgs
         }
 
         /// <summary>
-        /// Compare this build event context with another object to determine 
+        /// Compare this build event context with another object to determine
         /// equality. This means the values inside the object are identical.
         /// </summary>
         /// <param name="obj">Object to compare to this object</param>
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 8beef1b543f..32101d5d60e 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.UnitTests.OM.Collections
 {
     /// <summary>
-    /// Tests for the CopyOnWriteDictionary 
+    /// Tests for the CopyOnWriteDictionary
     /// </summary>
     public class CopyOnWriteDictionary_Tests
     {
@@ -109,7 +109,7 @@ public void EqualityComparer()
         }
 
         /// <summary>
-        /// Cloning sees the same values 
+        /// Cloning sees the same values
         /// </summary>
         [Fact]
         public void CloneVisibility()
@@ -125,7 +125,7 @@ public void CloneVisibility()
         }
 
         /// <summary>
-        /// Clone uses same comparer 
+        /// Clone uses same comparer
         /// </summary>
         [Fact]
         public void CloneComparer()
diff --git a/src/Shared/UnitTests/EngineTestEnvironment.cs b/src/Shared/UnitTests/EngineTestEnvironment.cs
index c06703a4a66..87be4933bc4 100644
--- a/src/Shared/UnitTests/EngineTestEnvironment.cs
+++ b/src/Shared/UnitTests/EngineTestEnvironment.cs
@@ -88,7 +88,7 @@ public TransientProjectCollection CreateProjectCollection()
         /// <param name="projectFileName">Name of the project file with extension to be created.</param>
         /// <param name="projectContents">Contents of the project file to be created.</param>
         /// <param name="files">Files to be created.</param>
-        /// <param name="relativePathFromRootToProject">Path for the specified files to be created in relative to 
+        /// <param name="relativePathFromRootToProject">Path for the specified files to be created in relative to
         /// the root of the project directory.</param>
         public TransientTestProjectWithFiles CreateTestProjectWithFiles(string projectFileName, string projectContents, string[] files = null, string relativePathFromRootToProject = ".")
             => WithTransientTestState(new TransientTestProjectWithFiles(projectFileName, projectContents, files, relativePathFromRootToProject));
@@ -99,7 +99,7 @@ public TransientTestProjectWithFiles CreateTestProjectWithFiles(string projectFi
         /// </summary>
         /// <param name="projectContents">Contents of the project file to be created.</param>
         /// <param name="files">Files to be created.</param>
-        /// <param name="relativePathFromRootToProject">Path for the specified files to be created in relative to 
+        /// <param name="relativePathFromRootToProject">Path for the specified files to be created in relative to
         /// the root of the project directory.</param>
         public TransientTestProjectWithFiles CreateTestProjectWithFiles(string projectContents, string[] files = null, string relativePathFromRootToProject = ".")
             => CreateTestProjectWithFiles("build.proj", projectContents, files, relativePathFromRootToProject);
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 26e8d9bd848..5e5c6aca707 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -22,6 +23,7 @@ namespace Microsoft.Build.UnitTests
     public class FileMatcherTest : IDisposable
     {
         private readonly TestEnvironment _env;
+        private Lazy<DummyMappedDrive> _mappedDrive = DummyMappedDriveUtils.GetLazyDummyMappedDrive();
 
         public FileMatcherTest(ITestOutputHelper output)
         {
@@ -31,6 +33,7 @@ public FileMatcherTest(ITestOutputHelper output)
         public void Dispose()
         {
             _env.Dispose();
+            _mappedDrive.Value?.Dispose();
         }
 
         [Theory]
@@ -1377,18 +1380,19 @@ private void DriveEnumeratingWildcardFailsAndReturns(string directoryPart, strin
             }
         }
 
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
         [WindowsOnlyTheory]
-        [InlineData(@"z:\**")]
-        [InlineData(@"z:\\**")]
-        [InlineData(@"z:\\\\\\\\**")]
-        [InlineData(@"z:\**\*.cs")]
+        [InlineData(@"%DRIVE%:\**")]
+        [InlineData(@"%DRIVE%:\\**")]
+        [InlineData(@"%DRIVE%:\\\\\\\\**")]
+        [InlineData(@"%DRIVE%:\**\*.cs")]
         public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWildcard)
         {
             using (var env = TestEnvironment.Create())
             {
                 try
                 {
+                    driveEnumeratingWildcard = DummyMappedDriveUtils.UpdatePathToMappedDrive(driveEnumeratingWildcard, _mappedDrive.Value.MappedDriveLetter);
+
                     // Set env var to log on drive enumerating wildcard detection
                     Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
 
diff --git a/src/Shared/UnitTests/MockEngine.cs b/src/Shared/UnitTests/MockEngine.cs
index 7797ba2dadf..a0dfb0c644e 100644
--- a/src/Shared/UnitTests/MockEngine.cs
+++ b/src/Shared/UnitTests/MockEngine.cs
@@ -19,18 +19,18 @@
 namespace Microsoft.Build.UnitTests
 {
     /***************************************************************************
-     * 
+     *
      * Class:       MockEngine
-     * 
+     *
      * In order to execute tasks, we have to pass in an Engine object, so the
      * task can log events.  It doesn't have to be the real Engine object, just
      * something that implements the IBuildEngine4 interface.  So, we mock up
      * a fake engine object here, so we're able to execute tasks from the unit tests.
-     * 
+     *
      * The unit tests could have instantiated the real Engine object, but then
      * we would have had to take a reference onto the Microsoft.Build.Engine assembly, which
      * is somewhat of a no-no for task assemblies.
-     * 
+     *
      **************************************************************************/
     internal sealed class MockEngine : IBuildEngine7
     {
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index df21aa2f2e6..38ac661d845 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -176,9 +176,9 @@ internal string FullLog
 
         /*
          * Property:    Parameters
-         * 
+         *
          * The mock logger does not take parameters.
-         * 
+         *
          */
         public string Parameters { get; set; }
 
@@ -223,9 +223,9 @@ public void ClearLog()
 
         /*
          * Method:  Shutdown
-         * 
+         *
          * The mock logger does not need to release any resources.
-         * 
+         *
          */
         public void Shutdown()
         {
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index fc4c92ed88b..fefbe339983 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -110,7 +110,7 @@ public void GetLastWriteDirectoryUtcTimeReturnsMinValueForFile()
 
         /// <summary>
         /// Verifies that NativeMethodsShared.SetCurrentDirectory(), when called on a nonexistent
-        /// directory, will not set the current directory to that location. 
+        /// directory, will not set the current directory to that location.
         /// </summary>
         [Fact]
         public void SetCurrentDirectoryDoesNotSetNonexistentFolder()
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 659aea6dab9..5b6f8b43cec 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -303,7 +303,7 @@ public static void AssertItems(string[] expectedItems, IList<ITestItem> items, D
             }
 
             items.Count.ShouldBe(expectedItems.Length,
-                () => $"got items \"{string.Join(", ", items)}\", expected \"{string.Join(", ", expectedItems)}\"");
+                customMessage: $"got items \"{string.Join(", ", items)}\", expected \"{string.Join(", ", expectedItems)}\"");
 
             expectedItems.Length.ShouldBe(expectedDirectMetadataPerItem.Length);
         }
@@ -461,7 +461,7 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
 
         internal static void AssertItemHasMetadata(string key, string value, ProjectItem item)
         {
-            item.DirectMetadataCount.ShouldBe(1, () => $"Expected 1 metadata, ({key}), got {item.DirectMetadataCount}");
+            item.DirectMetadataCount.ShouldBe(1, customMessage: $"Expected 1 metadata, ({key}), got {item.DirectMetadataCount}");
             item.GetMetadataValue(key).ShouldBe(value);
         }
 
@@ -469,7 +469,7 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
         {
             expected ??= new Dictionary<string, string>();
 
-            item.DirectMetadataCount.ShouldBe(expected.Keys.Count, () => $"Expected {expected.Keys.Count} metadata, ({string.Join(", ", expected.Keys)}), got {item.DirectMetadataCount}");
+            item.DirectMetadataCount.ShouldBe(expected.Keys.Count, customMessage: $"Expected {expected.Keys.Count} metadata, ({string.Join(", ", expected.Keys)}), got {item.DirectMetadataCount}");
 
             foreach (var key in expected.Keys)
             {
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index ad715d6c44b..42341719c1d 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -735,7 +735,7 @@ public override void Revert()
             Path.ShouldNotBe(@"\");
             Path.ShouldNotBe(@"/");
             System.IO.Path.GetFullPath(Path).ShouldNotBe(System.IO.Path.GetFullPath(System.IO.Path.GetTempPath()));
-            System.IO.Path.IsPathRooted(Path).ShouldBeTrue(() => $"{Path} is not rooted");
+            System.IO.Path.IsPathRooted(Path).ShouldBeTrue($"{Path} is not rooted");
 
             FileUtilities.DeleteDirectoryNoThrow(Path, true);
         }
diff --git a/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs b/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
index d1387eeb0b4..191642f2806 100644
--- a/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
@@ -33,6 +33,7 @@ public void LoadAssemblyAndDependency_InsideProjectFolder()
                 string dllPath = Path.Combine(dir.Path, TaskDllFileName);
 
                 CheckIfCorrectAssemblyLoaded(output, dllPath);
+                CheckIfCorrectAssemblyLoadedMessageLogged(output);
             }
         }
 
@@ -51,6 +52,7 @@ public void LoadAssemblyAndDependency_OutsideProjectFolder()
                 successfulExit.ShouldBeTrue(output);
 
                 CheckIfCorrectAssemblyLoaded(output, newTaskDllPath);
+                CheckIfCorrectAssemblyLoadedMessageLogged(output);
             }
         }
 
@@ -107,5 +109,19 @@ private void CheckIfCorrectAssemblyLoaded(string scriptOutput, string expectedAs
                 scriptOutput.ShouldNotContain(successfulMessage, Case.Insensitive);
             }
         }
+
+        private void CheckIfCorrectAssemblyLoadedMessageLogged(string scriptOutput)
+        {
+            var assemblyLoadedTaskRun = "Assembly loaded during TaskRun";
+
+#if FEATURE_ASSEMBLYLOADCONTEXT
+            var message = "AssemblyLoadContext: MSBuild plugin";
+#else
+            var message = "AppDomain: [Default]";
+#endif
+
+            scriptOutput.ShouldContain(assemblyLoadedTaskRun);
+            scriptOutput.ShouldContain(message);
+        }
     }
 }
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index 4f206d425b9..a63894695da 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -225,7 +225,7 @@ private void CheckIfCorrectAssemblyLoaded(string scriptOutput, string expectedAs
 
 #if FEATURE_ASSEMBLY_LOCATION
         /// <summary>
-        /// Make sure that when we load multiple types out of the same assembly with different type filters that both the fullyqualified name matching and the 
+        /// Make sure that when we load multiple types out of the same assembly with different type filters that both the fullyqualified name matching and the
         /// partial name matching still work.
         /// </summary>
         [Fact]
@@ -245,7 +245,7 @@ public void Regress640476PartialName()
         }
 
         /// <summary>
-        /// Make sure that when we load multiple types out of the same assembly with different type filters that both the fullyqualified name matching and the 
+        /// Make sure that when we load multiple types out of the same assembly with different type filters that both the fullyqualified name matching and the
         /// partial name matching still work.
         /// </summary>
         [Fact]
diff --git a/src/Shared/UnitTests/XmlUtilities_Tests.cs b/src/Shared/UnitTests/XmlUtilities_Tests.cs
index c8dd9ccdac6..5860d3ae110 100644
--- a/src/Shared/UnitTests/XmlUtilities_Tests.cs
+++ b/src/Shared/UnitTests/XmlUtilities_Tests.cs
@@ -40,7 +40,7 @@ public void InvalidNameErrorLocation()
         }
 
         /// <summary>
-        /// Helper for invalid name error location test 
+        /// Helper for invalid name error location test
         /// </summary>
         /// <param name="name"></param>
         /// <param name="badChar"></param>
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index 399f1871b85..91c4721f00c 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -25,7 +25,7 @@ internal static Version ConvertToVersion(string version)
         }
 
         /// <summary>
-        /// Go though an enumeration and create a sorted list of strings which can be parsed as versions. Keep around the original 
+        /// Go though an enumeration and create a sorted list of strings which can be parsed as versions. Keep around the original
         /// string because it may contain a v and this would be required to create the correct path on disk if the string was part of a path.
         /// </summary>
         internal static SortedDictionary<Version, List<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions)
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index cf101e49ced..a188590d6fa 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -163,7 +163,7 @@ internal static bool IsValidMSBuildArchitectureValue(string architecture)
         }
 
         /// <summary>
-        /// Compares two members of MSBuildRuntimeValues, returning true if they count as a match, and false otherwise.  
+        /// Compares two members of MSBuildRuntimeValues, returning true if they count as a match, and false otherwise.
         /// </summary>
         internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
         {
@@ -171,7 +171,7 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
 
             if (runtimeA == null || runtimeB == null)
             {
-                // neither one cares, or only one cares, so they match by default. 
+                // neither one cares, or only one cares, so they match by default.
                 return true;
             }
 
@@ -183,7 +183,7 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
 
             if (runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase) || runtimeB.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))
             {
-                // one or both explicitly don't care -- still a match. 
+                // one or both explicitly don't care -- still a match.
                 return true;
             }
 
@@ -199,14 +199,14 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
         }
 
         /// <summary>
-        /// Given two MSBuildRuntime values, returns the concrete result of merging the two.  If the merge fails, the merged runtime 
-        /// string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns 
-        /// true with the merged runtime value.  E.g.: 
+        /// Given two MSBuildRuntime values, returns the concrete result of merging the two.  If the merge fails, the merged runtime
+        /// string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns
+        /// true with the merged runtime value.  E.g.:
         /// "CLR4" + "CLR2" = null (false)
         /// "CLR2" + "don't care" = "CLR2" (true)
-        /// "current runtime" + "CLR4" = "CLR4" (true) 
+        /// "current runtime" + "CLR4" = "CLR4" (true)
         /// "current runtime" + "don't care" = "CLR4" (true)
-        /// If both specify "don't care", then defaults to the current runtime -- CLR4. 
+        /// If both specify "don't care", then defaults to the current runtime -- CLR4.
         /// A null or empty string is interpreted as "don't care".
         /// </summary>
         internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out string mergedRuntime)
@@ -226,7 +226,7 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
 
             string actualCurrentRuntime = GetCurrentMSBuildRuntime();
 
-            // if they're equal, then there's no problem -- just return the equivalent runtime.  
+            // if they're equal, then there's no problem -- just return the equivalent runtime.
             if (runtimeA.Equals(runtimeB, StringComparison.OrdinalIgnoreCase))
             {
                 if (runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
@@ -243,7 +243,7 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
             }
 
             // if both A and B are one of actual-current-runtime, don't care or current,
-            // then the end result will be current-runtime no matter what.  
+            // then the end result will be current-runtime no matter what.
             if (
                 (
                  runtimeA.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
@@ -258,9 +258,9 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 return true;
             }
 
-            // If A doesn't care, then it's B -- and we can say B straight out, because if B were one of the 
-            // special cases (current runtime or don't care) then it would already have been caught in the 
-            // previous clause. 
+            // If A doesn't care, then it's B -- and we can say B straight out, because if B were one of the
+            // special cases (current runtime or don't care) then it would already have been caught in the
+            // previous clause.
             if (runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))
             {
                 mergedRuntime = runtimeB;
@@ -274,13 +274,13 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 return true;
             }
 
-            // and now we've run out of things that it could be -- all the remaining options are non-matches.  
+            // and now we've run out of things that it could be -- all the remaining options are non-matches.
             mergedRuntime = null;
             return false;
         }
 
         /// <summary>
-        /// Compares two members of MSBuildArchitectureValues, returning true if they count as a match, and false otherwise.  
+        /// Compares two members of MSBuildArchitectureValues, returning true if they count as a match, and false otherwise.
         /// </summary>
         internal static bool ArchitectureValuesMatch(string architectureA, string architectureB)
         {
@@ -288,7 +288,7 @@ internal static bool ArchitectureValuesMatch(string architectureA, string archit
 
             if (architectureA == null || architectureB == null)
             {
-                // neither one cares, or only one cares, so they match by default. 
+                // neither one cares, or only one cares, so they match by default.
                 return true;
             }
 
@@ -300,7 +300,7 @@ internal static bool ArchitectureValuesMatch(string architectureA, string archit
 
             if (architectureA.Equals(MSBuildArchitectureValues.any, StringComparison.OrdinalIgnoreCase) || architectureB.Equals(MSBuildArchitectureValues.any, StringComparison.OrdinalIgnoreCase))
             {
-                // one or both explicitly don't care -- still a match. 
+                // one or both explicitly don't care -- still a match.
                 return true;
             }
 
@@ -318,9 +318,9 @@ internal static bool ArchitectureValuesMatch(string architectureA, string archit
 
         /// <summary>
         /// Given an MSBuildRuntime value that may be non-explicit -- e.g. "CurrentRuntime" or "Any" --
-        /// return the specific MSBuildRuntime value that it would map to in this case. If it does not map 
-        /// to any known runtime, just return it as is -- maybe someone else knows what to do with it; if 
-        /// not, they'll certainly have more context on logging or throwing the error. 
+        /// return the specific MSBuildRuntime value that it would map to in this case. If it does not map
+        /// to any known runtime, just return it as is -- maybe someone else knows what to do with it; if
+        /// not, they'll certainly have more context on logging or throwing the error.
         /// </summary>
         internal static string GetExplicitMSBuildRuntime(string runtime)
         {
@@ -333,21 +333,21 @@ internal static string GetExplicitMSBuildRuntime(string runtime)
             }
             else
             {
-                // either it's already a valid, specific runtime, or we don't know what to do with it.  Either way, return. 
+                // either it's already a valid, specific runtime, or we don't know what to do with it.  Either way, return.
                 return runtime;
             }
         }
 
         /// <summary>
-        /// Given two MSBuildArchitecture values, returns the concrete result of merging the two.  If the merge fails, the merged architecture 
-        /// string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns 
-        /// true with the merged architecture value.  E.g.: 
+        /// Given two MSBuildArchitecture values, returns the concrete result of merging the two.  If the merge fails, the merged architecture
+        /// string is returned null, and the return value of the method is false.  Otherwise, if the merge succeeds, the method returns
+        /// true with the merged architecture value.  E.g.:
         /// "x86" + "x64" = null (false)
         /// "x86" + "don't care" = "x86" (true)
         /// "current architecture" + "x86" = "x86" (true) on a 32-bit process, and null (false) on a 64-bit process
         /// "current architecture" + "don't care" = "x86" (true) on a 32-bit process, and "x64" (true) on a 64-bit process
         /// A null or empty string is interpreted as "don't care".
-        /// If both specify "don't care", then defaults to whatever the current process architecture is.  
+        /// If both specify "don't care", then defaults to whatever the current process architecture is.
         /// </summary>
         internal static bool TryMergeArchitectureValues(string architectureA, string architectureB, out string mergedArchitecture)
         {
@@ -366,7 +366,7 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
 
             string currentArchitecture = GetCurrentMSBuildArchitecture();
 
-            // if they're equal, then there's no problem -- just return the equivalent runtime.  
+            // if they're equal, then there's no problem -- just return the equivalent runtime.
             if (architectureA.Equals(architectureB, StringComparison.OrdinalIgnoreCase))
             {
                 if (architectureA.Equals(MSBuildArchitectureValues.currentArchitecture, StringComparison.OrdinalIgnoreCase) ||
@@ -382,7 +382,7 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
                 return true;
             }
 
-            // if both A and B are one of CLR4, don't care, or current, then the end result will be CLR4 no matter what.  
+            // if both A and B are one of CLR4, don't care, or current, then the end result will be CLR4 no matter what.
             if (
                 (
                  architectureA.Equals(currentArchitecture, StringComparison.OrdinalIgnoreCase) ||
@@ -397,9 +397,9 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
                 return true;
             }
 
-            // If A doesn't care, then it's B -- and we can say B straight out, because if B were one of the 
-            // special cases (current runtime or don't care) then it would already have been caught in the 
-            // previous clause. 
+            // If A doesn't care, then it's B -- and we can say B straight out, because if B were one of the
+            // special cases (current runtime or don't care) then it would already have been caught in the
+            // previous clause.
             if (architectureA.Equals(MSBuildArchitectureValues.any, StringComparison.OrdinalIgnoreCase))
             {
                 mergedArchitecture = architectureB;
@@ -413,16 +413,16 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
                 return true;
             }
 
-            // and now we've run out of things that it could be -- all the remaining options are non-matches.  
+            // and now we've run out of things that it could be -- all the remaining options are non-matches.
             mergedArchitecture = null;
             return false;
         }
 
         /// <summary>
-        /// Returns the MSBuildArchitecture value corresponding to the current process' architecture. 
+        /// Returns the MSBuildArchitecture value corresponding to the current process' architecture.
         /// </summary>
         /// <comments>
-        /// Revisit if we ever run on something other than Intel.  
+        /// Revisit if we ever run on something other than Intel.
         /// </comments>
         internal static string GetCurrentMSBuildArchitecture()
         {
@@ -453,7 +453,7 @@ internal static string GetCurrentMSBuildArchitecture()
         }
 
         /// <summary>
-        /// Returns the MSBuildRuntime value corresponding to the current process' runtime. 
+        /// Returns the MSBuildRuntime value corresponding to the current process' runtime.
         /// </summary>
         internal static string GetCurrentMSBuildRuntime()
         {
@@ -466,9 +466,9 @@ internal static string GetCurrentMSBuildRuntime()
 
         /// <summary>
         /// Given an MSBuildArchitecture value that may be non-explicit -- e.g. "CurrentArchitecture" or "Any" --
-        /// return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map 
-        /// to any known architecture, just return it as is -- maybe someone else knows what to do with it; if 
-        /// not, they'll certainly have more context on logging or throwing the error. 
+        /// return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map
+        /// to any known architecture, just return it as is -- maybe someone else knows what to do with it; if
+        /// not, they'll certainly have more context on logging or throwing the error.
         /// </summary>
         internal static string GetExplicitMSBuildArchitecture(string architecture)
         {
@@ -481,7 +481,7 @@ internal static string GetExplicitMSBuildArchitecture(string architecture)
             }
             else
             {
-                // either it's already a valid, specific architecture, or we don't know what to do with it.  Either way, return. 
+                // either it's already a valid, specific architecture, or we don't know what to do with it.  Either way, return.
                 return architecture;
             }
         }
diff --git a/src/Shared/XamlUtilities.cs b/src/Shared/XamlUtilities.cs
index aad30eaa8b7..ffdecbf00e8 100644
--- a/src/Shared/XamlUtilities.cs
+++ b/src/Shared/XamlUtilities.cs
@@ -362,7 +362,7 @@ internal void Validate(this Rule type)
                 category.Validate();
             }
 
-            // If the DataSource property is not defined on this Rule, check that a DataSource is 
+            // If the DataSource property is not defined on this Rule, check that a DataSource is
             // specified locally on every property.
             if (null == type.DataSource)
             {
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index 27e32d603cb..35a48f18c71 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -129,8 +129,8 @@ internal static bool IsValidElementName(string name)
         }
 
         /// <summary>
-        /// Finds the location of the first invalid character, if any, in the name of an 
-        /// item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none. 
+        /// Finds the location of the first invalid character, if any, in the name of an
+        /// item, property, or piece of metadata. Returns the location of the first invalid character, or -1 if there are none.
         /// Valid names must match this pattern:  [A-Za-z_][A-Za-z_0-9\-.]*
         /// Note, this is a subset of all possible valid XmlElement names: we use a subset because we also
         /// have to match this same set in our regular expressions, and allowing all valid XmlElement name
diff --git a/src/StringTools/WeakStringCacheInterner.cs b/src/StringTools/WeakStringCacheInterner.cs
index dbf21b00b33..2eb3fd23231 100644
--- a/src/StringTools/WeakStringCacheInterner.cs
+++ b/src/StringTools/WeakStringCacheInterner.cs
@@ -119,7 +119,7 @@ public string InternableToString(ref InternableString candidate)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         public void EnableStatistics()
         {
diff --git a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
index d0bbb4b1df0..bcc0f7c464b 100644
--- a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
+++ b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
@@ -239,7 +239,7 @@ public void AllParameters()
         }
 
         /// <summary>
-        /// Make sure AspNetCompiler sends ExternalProjectStarted/Finished events properly. The tasks will fail since 
+        /// Make sure AspNetCompiler sends ExternalProjectStarted/Finished events properly. The tasks will fail since
         /// the project files don't exist, but we only care about the events anyway.
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
index 49a843cbd54..5f0d4ad6f1a 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
@@ -32,7 +32,7 @@ public FilePrimary(ITestOutputHelper output) : base(output)
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -261,7 +261,7 @@ public void ExistsPromotedDependencyInTheDenyList()
         /// <summary>
         /// In this case,
         /// - A single primary file reference to assembly version 1.0.0.0 was passed in.
-        /// - An app.config was passed in that promotes a *different* assembly version name from 
+        /// - An app.config was passed in that promotes a *different* assembly version name from
         ///   1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of the file exists.
         /// - Version 2.0.0.0 of the file exists.
@@ -318,7 +318,7 @@ public void ExistsDifferentName()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -369,7 +369,7 @@ public void ExistsOldVersionRange()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -419,7 +419,7 @@ public void HighVersionDoesntExist()
         /// -- The resulting assembly returned should be 2.0.0.0.
         /// Rationale:
         /// There's no way for the resolve algorithm to determine that the file reference corresponds
-        /// to a particular AssemblyName. Because of this, there's no way to determine that we want to 
+        /// to a particular AssemblyName. Because of this, there's no way to determine that we want to
         /// promote from 0.5.0.0 to 2.0.0.0. In this case, just use the assembly name that was passed in.
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 9caae9580dd..43d8b0b2016 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3563,7 +3563,7 @@ public void ConflictBetweenCopyLocalDependenciesRegress444809()
             ResourceManager resources = new ResourceManager("Microsoft.Build.Tasks.Strings", Assembly.GetExecutingAssembly());
 
             // Unresolved primary reference with itemspec "A, Version=20.0.0.0, Culture=Neutral, PublicKeyToken=null".
-            engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_ADllPath);
+            engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.UnifiedReferenceDependsOn", "A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_ADllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_V2_ADllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_CDllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_BDllPath);
@@ -3609,7 +3609,7 @@ public void ConflictBetweenCopyLocalDependenciesRegress444809UnResolvedPrimaryRe
             bool result = Execute(t);
 
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=20.0.0.0, Culture=Neutral, PublicKeyToken=null", String.Empty);
-            engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_V2_ADllPath);
+            engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.UnifiedReferenceDependsOn", "A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_V2_ADllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.UnResolvedPrimaryItemSpec", "A, Version=20.0.0.0, Culture=Neutral, PublicKeyToken=null");
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_DDllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_BDllPath);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
index 33ab353147d..230080b2f31 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/NonSpecificVersionStrictPrimary.cs
@@ -40,7 +40,7 @@ public NonSpecificVersionStrictPrimary(ITestOutputHelper output) : base(output)
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -87,7 +87,7 @@ public void Exists()
         /// <summary>
         /// In this case,
         /// - A single primary non-version-strict reference was passed in to assembly version 1.0.0.0
-        /// - An app.config was passed in that promotes a *different* assembly version name from 
+        /// - An app.config was passed in that promotes a *different* assembly version name from
         ///   1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of the file exists.
         /// - Version 2.0.0.0 of the file exists.
@@ -146,7 +146,7 @@ public void ExistsDifferentName()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -198,7 +198,7 @@ public void ExistsOldVersionRange()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -250,7 +250,7 @@ public void HighVersionDoesntExist()
         /// Rationale:
         /// Primary references are never unified--even those that don't exist on disk. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
index 1f29749f3b3..a27434df16c 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
@@ -32,7 +32,7 @@ public SpecificVersionPrimary(ITestOutputHelper output) : base(output)
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -84,7 +84,7 @@ public void Exists()
         /// <list type="bullet">
         /// <item>A single primary version-strict reference was passed in to assembly version 1.0.0.0</item>
         /// <item>
-        /// An app.config was passed in that promotes a *different* assembly version name from 
+        /// An app.config was passed in that promotes a *different* assembly version name from
         /// 1.0.0.0 to 2.0.0.0
         /// </item>
         /// <item>Version 1.0.0.0 of the file exists.</item>
@@ -99,7 +99,7 @@ public void Exists()
         /// <list type="number">
         /// <item>
         /// The user expects that a primary reference will be respected.</item>
-        /// <item>When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// <item>When FindDependencies is false and AutoUnify is true, we'd have to find all
         /// dependencies anyway to make things work consistently. This would be a significant
         /// perf hit when loading large solutions.
         /// </item>
@@ -153,7 +153,7 @@ public void ExistsDifferentName()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -205,7 +205,7 @@ public void ExistsOldVersionRange()
         /// Rationale:
         /// Primary references are never unified. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
@@ -257,7 +257,7 @@ public void HighVersionDoesntExist()
         /// Rationale:
         /// Primary references are never unified--even those that don't exist on disk. This is because:
         /// (a) The user expects that a primary reference will be respected.
-        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all 
+        /// (b) When FindDependencies is false and AutoUnify is true, we'd have to find all
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
index 1960dba7a0b..1ef6412f355 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
@@ -95,7 +95,7 @@ public void Exists()
         /// - This should be an unresolved reference, we shouldn't fallback to the old version.
         /// Rationale:
         /// The fusion loader is going to want to respect the unified-to assembly. There's no point in
-        /// feeding it the wrong version, and the drawback is that builds would be different from 
+        /// feeding it the wrong version, and the drawback is that builds would be different from
         /// machine-to-machine.
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
index d971ece54a5..eff546bcd3d 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
@@ -42,7 +42,7 @@ public StronglyNamedDependencyAutoUnify(ITestOutputHelper output) : base(output)
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 2.0.0.0.
         /// Rationale:
-        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
+        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly
         /// dependency seen.
         /// </summary>
         /// <param name="rarSimulationMode"></param>
@@ -100,11 +100,11 @@ internal void ExistsImpl(RARSimulationMode rarSimulationMode = RARSimulationMode
         /// - The AutoUnify flag is set to 'true'.
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        ///   - DependsOnUnified 2.0.0.0 is on the deny list. 
+        ///   - DependsOnUnified 2.0.0.0 is on the deny list.
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 1.0.0.0.
         /// Rationale:
-        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
+        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly
         /// dependency seen. However if the higher assembly is a dependency of an assembly in the deny list it should not be considered during unification.
         /// </summary>
         [Fact]
@@ -183,7 +183,7 @@ public void ExistsWithPrimaryReferenceOnDenyList()
         /// - There should be exactly one UnifyMe dependency returned and it should be version 1.0.0.0.
         ///  Also there should be a warning about the primary reference DependsOnUnified 2.0.0.0 having a dependency which was in the deny list.
         /// Rationale:
-        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
+        /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly
         /// dependency seen. However if the higher assembly is a dependency of an assembly in the deny list it should not be considered during unification.
         /// </summary>
         [Fact]
@@ -260,7 +260,7 @@ public void ExistsPromotedDependencyInTheDenyList()
         /// - Version 2.0.0.0 of UnifyMe exists.
         ///   - UnifyMe 2.0.0.0 is on the deny list because it is higher than what is in the redist list, 1.0.0.0 is also in a deny list because it is not in the subset but is in the redist list.
         /// Expected:
-        /// - There should be no UnifyMe dependency returned 
+        /// - There should be no UnifyMe dependency returned
         /// There should be a warning indicating the primary reference DependsOnUnified 1.0.0.0 has a dependency that in the deny list
         /// There should be a warning indicating the primary reference DependsOnUnified 2.0.0.0 has a dependency that in the deny list
         /// </summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
index e7219ac8973..9ab178efbb5 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
@@ -19,7 +19,7 @@
 namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
     /// <summary>
-    /// Unit tests for the ResolveAssemblyReference task that involve, among other things, checking suggested redirects 
+    /// Unit tests for the ResolveAssemblyReference task that involve, among other things, checking suggested redirects
     /// </summary>
     public sealed class SuggestedRedirects : ResolveAssemblyReferenceTestFixture
     {
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index 915bf102943..e26e33a7668 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -175,7 +175,7 @@ public void DoubleDot()
 
         /// <summary>
         /// If an item has a "DependentUpon" who's base name matches exactly, then just assume this
-        /// is a resource and form that happen to have an embedded culture. That is, don't assign a 
+        /// is a resource and form that happen to have an embedded culture. That is, don't assign a
         /// culture to these.
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
index f4fa9b32284..21d76883bf3 100644
--- a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
@@ -37,7 +37,7 @@ public void NoItems()
         }
 
         /// <summary>
-        /// AssignLinkMetadata should behave nicely when there is an item with an 
+        /// AssignLinkMetadata should behave nicely when there is an item with an
         /// itemspec that contains invalid path characters.
         /// </summary>
         [Fact]
@@ -76,14 +76,14 @@ public void Basic()
             Assert.Single(t.OutputItems);
             Assert.Equal(item.ItemSpec, t.OutputItems[0].ItemSpec);
 
-            // Link metadata should have been added by the task, and OriginalItemSpec was added by the copy 
+            // Link metadata should have been added by the task, and OriginalItemSpec was added by the copy
             Assert.Equal(item.MetadataCount + 2, t.OutputItems[0].MetadataCount);
             Assert.Equal(Path.Combine("SubFolder", "a.cs"), t.OutputItems[0].GetMetadata("Link"));
         }
 
         /// <summary>
-        /// AssignLinkMetadata should behave nicely when there is an item with an 
-        /// itemspec that contains invalid path characters, and still successfully 
+        /// AssignLinkMetadata should behave nicely when there is an item with an
+        /// itemspec that contains invalid path characters, and still successfully
         /// output any items that aren't problematic.
         /// </summary>
         [Fact]
@@ -103,7 +103,7 @@ public void InvalidItemPathWithOtherValidItem()
             Assert.Single(t.OutputItems);
             Assert.Equal(item2.ItemSpec, t.OutputItems[0].ItemSpec);
 
-            // Link metadata should have been added by the task, and OriginalItemSpec was added by the copy 
+            // Link metadata should have been added by the task, and OriginalItemSpec was added by the copy
             Assert.Equal(item2.MetadataCount + 2, t.OutputItems[0].MetadataCount);
             Assert.Equal(Path.Combine("SubFolder", "a.cs"), t.OutputItems[0].GetMetadata("Link"));
         }
@@ -128,7 +128,7 @@ public void DontOverrideLink()
         }
 
         /// <summary>
-        /// AssignLinkMetadata should not set Link if the item is outside the 
+        /// AssignLinkMetadata should not set Link if the item is outside the
         /// defining project's cone
         /// </summary>
         [Fact]
diff --git a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
index 9965648369b..4b0c881cead 100644
--- a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
+++ b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
@@ -192,7 +192,7 @@ public void KeyFileWithSpaces()
         }
 
         /// <summary>
-        /// Tests the SdkToolsPath property:  Should log an error if it's null or a bad path.  
+        /// Tests the SdkToolsPath property:  Should log an error if it's null or a bad path.
         /// </summary>
         [Fact]
         public void SdkToolsPath()
@@ -226,7 +226,7 @@ public void SdkToolsPath()
         }
 
         /// <summary>
-        /// Tests the ToolPath property:  Should log an error if it's null or a bad path.  
+        /// Tests the ToolPath property:  Should log an error if it's null or a bad path.
         /// </summary>
         [Fact]
         public void ToolPath()
@@ -286,13 +286,13 @@ public void TaskFailsWhenImproperlySigned()
                 t.KeyFile = tempKeyFile;
                 Utilities.ExecuteTaskAndVerifyLogContainsErrorFromResource(t, "AxTlbBaseTask.CannotSpecifyBothKeyFileAndKeyContainer");
 
-                // All the inputs are correct, but the KeyContainer passed in is bad            
+                // All the inputs are correct, but the KeyContainer passed in is bad
                 t.DelaySign = false;
                 t.KeyContainer = tempKeyContainer;
                 t.KeyFile = null;
                 Utilities.ExecuteTaskAndVerifyLogContainsErrorFromResource(t, "AxTlbBaseTask.StrongNameUtils.NoKeyPairInContainer", t.KeyContainer);
 
-                // All the inputs are correct, but the KeyFile passed in is bad            
+                // All the inputs are correct, but the KeyFile passed in is bad
                 t.KeyContainer = null;
                 t.KeyFile = tempKeyFile;
                 Utilities.ExecuteTaskAndVerifyLogContainsErrorFromResource(t, "AxTlbBaseTask.StrongNameUtils.NoKeyPairInFile", t.KeyFile);
@@ -316,7 +316,7 @@ internal sealed class Utilities
         /// <summary>
         /// Given an instance of an AxImp task, executes that task (assuming all necessary parameters
         /// have been set ahead of time) and verifies that the execution log contains the error
-        /// corresponding to the resource name passed in. 
+        /// corresponding to the resource name passed in.
         /// </summary>
         /// <param name="t">The task to execute and check</param>
         /// <param name="errorResource">The name of the resource string to check the log for</param>
@@ -349,7 +349,7 @@ internal static void VerifyLogContainsErrorFromResource(MockEngine e, TaskLoggin
         /// <summary>
         /// Given an instance of an AxImp task, executes that task (assuming all necessary parameters
         /// have been set ahead of time) and verifies that the execution log does not contain the error
-        /// corresponding to the resource name passed in. 
+        /// corresponding to the resource name passed in.
         /// </summary>
         /// <param name="t">The task to execute and check</param>
         /// <param name="errorResource">The name of the resource string to check the log for</param>
diff --git a/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs b/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
index abcd1bfa727..ffcc07f3f19 100644
--- a/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
@@ -289,7 +289,7 @@ public void PreprocessorControllingTwoNamespaces()
 namespace n1
 #else
 namespace n2
-#endif    
+#endif
 { class c {} }
                 ", "n2.c");
         }
@@ -328,7 +328,7 @@ namespace n1
 #else
 using a=b;
 namespace n2
-#endif    
+#endif
 { class c {} }", "n2.c")]
         [InlineData(@"
 #if (false)
@@ -336,7 +336,7 @@ namespace n1;
 #else
 using a=b;
 namespace n2;
-#endif    
+#endif
 { class c {} }", "n1.n2.c")]
         public void PreprocessorControllingTwoNamespacesWithInterveningKeyword(string fileContents, string expected)
         {
@@ -345,23 +345,23 @@ public void PreprocessorControllingTwoNamespacesWithInterveningKeyword(string fi
 
         [Theory]
         [InlineData(@"
-#if MY_CONSTANT                
-namespace i 
+#if MY_CONSTANT
+namespace i
 {
     #region Put the class in a region
-    class a 
+    class a
     {
-    }     
+    }
     #endregion
 }
 #endif // MY_CONSTANT ")]
         [InlineData(@"
-#if MY_CONSTANT                
+#if MY_CONSTANT
 namespace i;
     #region Put the class in a region
-    class a 
+    class a
     {
-    }     
+    }
     #endregion
 #endif // MY_CONSTANT")]
         public void Preprocessor(string fileContents)
@@ -374,15 +374,15 @@ public void PreprocessorNamespaceInFalsePreprocessorBlock()
         {
             AssertParse(
                 @"
-#if (false)             
-namespace i 
+#if (false)
+namespace i
 {
 #endif
-    class a 
+    class a
     {
-    }     
-#if (false)             
-namespace i 
+    }
+#if (false)
+namespace i
 }
 #endif
                 ", "a");
diff --git a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
index f9613d173c6..23adb6a34b1 100644
--- a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
@@ -40,7 +40,7 @@ public sealed class CSharpTokenizerTests
             Special whitespace handling.
                 Horizontal tab character (U+0009)
                 Vertical tab character (U+000B)
-                Form feed character (U+000C)  
+                Form feed character (U+000C)
         */
         [Fact]
         public void SpecialWhitespace() { AssertTokenize("\x09\x0b\x0c\x0d", ".Whitespace"); }
@@ -75,15 +75,15 @@ Form feed character (U+000C)
         [Fact]
         public void LeftHalfOfUnbalanceMultilineCommentWithStuff() { AssertTokenize("/* unbalanced\x0d", ".EndOfFileInsideComment"); }
 
-        // If the last character of the source file is a Control-Z character (U+001A), this character is deleted. 
+        // If the last character of the source file is a Control-Z character (U+001A), this character is deleted.
         [Fact]
         public void NothingPlustControlZatEOF() { AssertTokenize("\x1A", "", "", 0); }
         [Fact]
         public void SomethingPlusControlZatEOF() { AssertTokenize("// My comment\x1A", "// My comment\x0d", ".Comment.Whitespace"); }
 
-        // A carriage-return character (U+000D) is added to the end of the source file if that source file is non-empty and if the last character 
-        // of the source file is not a carriage return (U+000D), a line feed (U+000A), a line separator (U+2028), or a paragraph separator 
-        // (U+2029). 
+        // A carriage-return character (U+000D) is added to the end of the source file if that source file is non-empty and if the last character
+        // of the source file is not a carriage return (U+000D), a line feed (U+000A), a line separator (U+2028), or a paragraph separator
+        // (U+2029).
         [Fact]
         public void NoEOLatEOF() { AssertTokenize("// My comment", "// My comment\x0d", ".Comment.Whitespace"); }
         [Fact]
@@ -110,7 +110,7 @@ public void NamespacePlusClass()
              ".Keyword.Whitespace.Identifier.Whitespace.OpenScope.Whitespace.Keyword.Whitespace.Identifier.Whitespace.OpenScope.CloseScope.Whitespace.CloseScope.Whitespace");
         }
 
-        // If a keyword has '@' in front, then its treated as an identifier. 
+        // If a keyword has '@' in front, then its treated as an identifier.
         [Fact]
         public void EscapedKeywordMakesIdentifier()
         {
@@ -138,7 +138,7 @@ public void EscapedKeywordMakesIdentifier()
         [Fact]
         public void InvalidHexIntegerWithNoneValid() { AssertTokenize("0xG\x0d", ".ExpectedValidHexDigit"); }
 
-        // Hex literal long suffix: U u L l UL Ul uL ul LU Lu lU lu 
+        // Hex literal long suffix: U u L l UL Ul uL ul LU Lu lU lu
         [Fact]
         public void HexIntegerLiteralUpperU() { AssertTokenize("0x123FU\x0d", ".HexIntegerLiteral.Whitespace"); }
         [Fact]
@@ -162,7 +162,7 @@ public void EscapedKeywordMakesIdentifier()
         [Fact]
         public void HexIntegerLiteralLowerLLowerU() { AssertTokenize("0x123Flu\x0d", ".HexIntegerLiteral.Whitespace"); }
 
-        // Decimal literal long suffix: U u L l UL Ul uL ul LU Lu lU lu 
+        // Decimal literal long suffix: U u L l UL Ul uL ul LU Lu lU lu
         [Fact]
         public void DecimalIntegerLiteralUpperU() { AssertTokenize("1234U\x0d", ".DecimalIntegerLiteral.Whitespace"); }
         [Fact]
@@ -241,9 +241,9 @@ public void EscapedKeywordMakesIdentifier()
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenize(string source, string expectedTokenKey)
@@ -254,9 +254,9 @@ private static void AssertTokenize(string source, string expectedTokenKey)
 
         /*
         * Method:  AssertTokenizeUnicode
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenizeUnicode(string source, string expectedTokenKey)
@@ -267,9 +267,9 @@ private static void AssertTokenizeUnicode(string source, string expectedTokenKey
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenize(
@@ -283,9 +283,9 @@ private static void AssertTokenize(
 
         /*
         * Method:  AssertTokenizeUnicode
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenizeUnicode(
@@ -299,7 +299,7 @@ private static void AssertTokenizeUnicode(
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
@@ -315,7 +315,7 @@ private static void AssertTokenize(
 
         /*
         * Method:  AssertTokenizeUnicode
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
@@ -331,7 +331,7 @@ private static void AssertTokenizeUnicode(
 
         /*
         * Method:  AssertTokenizeUnicode
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
@@ -351,7 +351,7 @@ private static void AssertTokenizeUnicode(
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
@@ -363,7 +363,7 @@ private static void AssertTokenize(
            int expectedLastLineNumber)
         {
             // This version of AssertTokenize tests several different encodings.
-            // The reason is that we want to be sure each of these works in the 
+            // The reason is that we want to be sure each of these works in the
             // various encoding formats supported by C#
             AssertTokenizeStream(StreamHelpers.StringToStream(source), expectedSource, expectedTokenKey, expectedLastLineNumber);
             AssertTokenizeStream(StreamHelpers.StringToStream(source, System.Text.Encoding.Unicode), expectedSource, expectedTokenKey, expectedLastLineNumber);
@@ -375,7 +375,7 @@ private static void AssertTokenize(
 
         /*
          * Method:  AssertTokenizeStream
-         * 
+         *
          * Tokenize a string ('source') and compare it to the expected set of tokens.
          * Also compare the source that is regenerated by concatenating all of the tokens
          * to 'expectedSource'.
diff --git a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
index 689a15dbb70..8630c8025fb 100644
--- a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
+++ b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
@@ -186,7 +186,7 @@ public void IgnoreKnownOleTypes()
 
             // We don't check for this type in the ComDependencyWalker, so it doesn't get counted as a known OLE type.
             // It's too late in the Dev10 cycle to add it to shipping code without phenomenally good reason, but we should
-            // re-examine this in Dev11.  
+            // re-examine this in Dev11.
             // oleTypeLib.AddTypeInfo(new MockTypeInfo(TYPEKIND.TKIND_ENUM));
 
             foreach (MockTypeInfo typeInfo in oleTypeLib.ContainedTypeInfos)
@@ -296,7 +296,7 @@ private void RunDependencyWalkerFaultInjection(MockTypeLibrariesFailurePoints fa
             walker.AnalyzeTypeLibrary(mainTypeLib);
 
             // Did the current failure point get hit for this test? If not then no point in checking anything
-            // The previous test (FaultInjectionMainLib) ensures that all defined failure points actually 
+            // The previous test (FaultInjectionMainLib) ensures that all defined failure points actually
             // cause some sort of trouble
             if (walker.EncounteredProblems.Count > 0)
             {
diff --git a/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs b/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
index 97b019804eb..e60d67c1f9e 100644
--- a/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
+++ b/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
@@ -18,7 +18,7 @@ public sealed class CommandLineBuilderExtensionTest
         /*
         * Method:   AppendItemWithInvalidBooleanAttribute
         *
-        * When appending an ITaskItem[] where some of the flags are 'bool', it's possible that 
+        * When appending an ITaskItem[] where some of the flags are 'bool', it's possible that
         * the boolean flag has a string value that cannot be converted to a boolean. In this
         * case we expect an exception.
         */
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index 36ca55794f3..97a7d57f2ec 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -102,7 +102,7 @@ internal static int ValidateHasParameter(ToolTaskExtension t, string parameter,
         }
 
         /// <summary>
-        /// Validates that the given ToolTaskExtension's command line does not contain 
+        /// Validates that the given ToolTaskExtension's command line does not contain
         /// any parameter starting with the given string.
         /// </summary>
         /// <param name="t">task to get the command line from</param>
@@ -114,7 +114,7 @@ internal static void ValidateNoParameterStartsWith(ToolTaskExtension t, string s
         }
 
         /// <summary>
-        /// Validates that the given ToolTaskExtension's command line does not contain 
+        /// Validates that the given ToolTaskExtension's command line does not contain
         /// any parameter starting with the given string.
         /// </summary>
         /// <param name="t">task to get the command line from</param>
@@ -125,7 +125,7 @@ internal static void ValidateNoParameterStartsWith(ToolTaskExtension t, string s
         }
 
         /// <summary>
-        /// Validates that the given ToolTaskExtension's command line does not contain 
+        /// Validates that the given ToolTaskExtension's command line does not contain
         /// any parameter starting with the given string.
         /// </summary>
         /// <param name="t">task to get the command line from</param>
@@ -137,7 +137,7 @@ internal static void ValidateNoParameterStartsWith(ToolTaskExtension t, string s
         }
 
         /// <summary>
-        /// Validates that the given ToolTaskExtension's command line does not contain 
+        /// Validates that the given ToolTaskExtension's command line does not contain
         /// any parameter starting with the given string.
         /// </summary>
         /// <param name="t">task to get the command line from</param>
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 1792dad790f..3c15516a43f 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -16,10 +16,11 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+
 using Shouldly;
+
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -27,6 +28,20 @@ namespace Microsoft.Build.UnitTests
 {
     public class Copy_Tests : IDisposable
     {
+        public static IEnumerable<object[]> GetDestinationExists() =>
+            new List<object[]>
+            {
+                new object[] { true },
+                new object[] { false },
+            };
+
+        public static IEnumerable<object[]> GetNullAndEmptyArrays() =>
+            new List<object[]>
+            {
+                new object[] { null },
+                new object[] { Array.Empty<ITaskItem>() },
+            };
+
         /// <summary>
         /// Gets data for testing with combinations of isUseHardLinks and isUseSymbolicLinks.
         /// Index 0 is the value for isUseHardLinks.
@@ -112,6 +127,356 @@ public void Dispose()
             Copy.RefreshInternalEnvironmentValues();
         }
 
+        [Fact]
+        public void CopyWithNoInput()
+        {
+            var task = new Copy { BuildEngine = new MockEngine(true), };
+            task.Execute().ShouldBeTrue();
+            (task.CopiedFiles == null || task.CopiedFiles.Length == 0).ShouldBeTrue();
+            (task.DestinationFiles == null || task.DestinationFiles.Length == 0).ShouldBeTrue();
+            task.WroteAtLeastOneFile.ShouldBeFalse();
+        }
+
+        [Fact]
+        public void CopyWithMatchingSourceFilesToDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(1);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(1);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithSourceFilesToDestinationFolder(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var sourceFile = env.CreateFile("source.txt");
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(1);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(1);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithSourceFoldersToDestinationFolder(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var s0Folder = env.DefaultTestDirectory.CreateDirectory("source0");
+                s0Folder.CreateFile("00.txt");
+                s0Folder.CreateFile("01.txt");
+                var s0AFolder = s0Folder.CreateDirectory("a");
+                s0AFolder.CreateFile("a0.txt");
+                s0AFolder.CreateFile("a1.txt");
+                _ = s0Folder.CreateDirectory("b");
+                var s0CFolder = s0Folder.CreateDirectory("c");
+                s0CFolder.CreateFile("c0.txt");
+
+                var s1Folder = env.DefaultTestDirectory.CreateDirectory("source1");
+                s1Folder.CreateFile("10.txt");
+                s1Folder.CreateFile("11.txt");
+                var s1AFolder = s1Folder.CreateDirectory("a");
+                s1AFolder.CreateFile("a0.txt");
+                s1AFolder.CreateFile("a1.txt");
+                var s1BFolder = s1Folder.CreateDirectory("b");
+                s1BFolder.CreateFile("b0.txt");
+
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFolders = new ITaskItem[] { new TaskItem(s0Folder.Path), new TaskItem(s1Folder.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(10);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(10);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+                Directory.Exists(Path.Combine(destinationFolder.Path, "source0")).ShouldBeTrue();
+                Directory.Exists(Path.Combine(destinationFolder.Path, "source1")).ShouldBeTrue();
+            }
+        }
+
+        [Fact]
+        public void CopyWithNoSource()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithMultipleSourceTypes(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var sourceFolder = env.DefaultTestDirectory.CreateDirectory("source");
+                sourceFolder.CreateFile("source.txt");
+                var aDirectory = sourceFolder.CreateDirectory("a");
+                aDirectory.CreateFile("a.txt");
+                sourceFolder.CreateDirectory("b");
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    SourceFolders = new ITaskItem[] { new TaskItem(sourceFolder.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(3);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(3);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithEmptySourceFiles(ITaskItem[] sourceFiles)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithEmptySourceFolders(ITaskItem[] sourceFolders)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFolders = sourceFolders,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithNoDestination(ITaskItem[] destinationFiles)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = destinationFiles,
+                };
+                task.Execute().ShouldBeFalse();
+                // Copy.NeedsDestination (MSB3023) or General.TwoVectorsMustHaveSameLength (MSB3094)
+                engine.AssertLogContains(destinationFiles == null ? "MSB3023" : "MSB3094");
+                task.CopiedFiles.ShouldBeNull();
+                (task.DestinationFiles == null || task.DestinationFiles.Length == 0).ShouldBeTrue();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithMultipleDestinationTypes()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3022"); // Copy.ExactlyOneTypeOfDestination
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithSourceFoldersAndDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var sourceFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    SourceFolders = new ITaskItem[] { new TaskItem(sourceFolder.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination0.txt"), new TaskItem("destination1.txt") },
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3896"); // Copy.IncompatibleParameters
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithDifferentLengthSourceFilesToDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination0.txt"), new TaskItem("destination1.txt") },
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3094"); // General.TwoVectorsMustHaveSameLength
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        /// <summary>
+        /// Verifies that we error for retries less than 0
+        /// </summary>
+        [Fact]
+        public void CopyWithInvalidRetryCount()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    Retries = -1,
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3028"); // Copy.InvalidRetryCount
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        /// <summary>
+        /// Verifies that we error for retry delay less than 0
+        /// </summary>
+        [Fact]
+        public void CopyWithInvalidRetryDelay()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    RetryDelayMilliseconds = -1,
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3029"); // Copy.InvalidRetryDelay
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
         /// <summary>
         /// If OnlyCopyIfDifferent is set to "true" then we shouldn't copy over files that
         /// have the same date and time.
@@ -1898,6 +2263,30 @@ public void ExitGracefullyOnInvalidPathCharacters(bool isUseHardLinks, bool isUs
             ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
         }
 
+        /// <summary>
+        /// If the DestinationFolder parameter is given invalid path characters, make sure the task exits gracefully.
+        /// </summary>
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void ExitGracefullyOnInvalidPathCharactersInDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
+        {
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1,  // speed up tests!
+                BuildEngine = new MockEngine(_testOutputHelper),
+                SourceFiles = new ITaskItem[] { new TaskItem("foo") },
+                DestinationFolder = new TaskItem("here | there"),
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
+            };
+
+            bool result = t.Execute();
+
+            // Expect for there to have been no copies.
+            Assert.False(result);
+            ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+        }
+
         /// <summary>
         /// Verifies that we error for retries less than 0
         /// </summary>
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index ab9c9fbc182..fd10c03db4b 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -756,7 +756,7 @@ namespace ClassLibrary2
 namespace ClassLibrary3
 #endif
 {
-    class MyForm 
+    class MyForm
     {
     }
 }"),
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 69f481a1cf7..de09dcbc85e 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Definition;
@@ -9,6 +10,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
@@ -19,7 +21,7 @@
 
 namespace Microsoft.Build.UnitTests
 {
-    public sealed class CreateItem_Tests
+    public sealed class CreateItem_Tests : IDisposable
     {
         internal const string CreateItemWithInclude = @"
             <Project>
@@ -32,6 +34,12 @@ public sealed class CreateItem_Tests
             ";
 
         private readonly ITestOutputHelper _testOutput;
+        private Lazy<DummyMappedDrive> _mappedDrive = DummyMappedDriveUtils.GetLazyDummyMappedDrive();
+
+        public void Dispose()
+        {
+            _mappedDrive.Value?.Dispose();
+        }
 
         public CreateItem_Tests(ITestOutputHelper output)
         {
@@ -146,7 +154,7 @@ public void CaseDoesntMatter()
         }
 
         /// <summary>
-        /// Using the CreateItem task to expand wildcards, and then try accessing the RecursiveDir 
+        /// Using the CreateItem task to expand wildcards, and then try accessing the RecursiveDir
         /// metadata to force batching.
         /// </summary>
         [Fact]
@@ -313,20 +321,20 @@ public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
         /// <summary>
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Windows platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
         [WindowsOnlyTheory]
-        [InlineData(@"z:\**")]
-        [InlineData(@"z:\**\*.log")]
-        [InlineData(@"z:\\\\**\*.log")]
+        [InlineData(@"%DRIVE%:\**")]
+        [InlineData(@"%DRIVE%:\**\*.log")]
+        [InlineData(@"%DRIVE%:\\\\**\*.log")]
         public void LogWindowsWarningUponCreateItemExecution(string itemSpec)
         {
+            itemSpec = DummyMappedDriveUtils.UpdatePathToMappedDrive(itemSpec, _mappedDrive.Value.MappedDriveLetter);
             VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(itemSpec);
         }
 
         /// <summary>
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Unix platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/8373")]
         [UnixOnlyTheory]
         [InlineData(@"\**")]
         [InlineData(@"\**\*.log")]
@@ -391,21 +399,21 @@ public void ThrowExceptionUponItemCreationWithDriveEnumeration(string content, s
         /// <summary>
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Windows platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
         [WindowsOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
-            @"z:\**")]
+            @"%DRIVE%:\**")]
 
         [InlineData(
             CreateItemWithInclude,
-            @"z:\**\*.txt")]
+            @"%DRIVE%:\**\*.txt")]
 
         [InlineData(
             CreateItemWithInclude,
-            @"z:$(empty)\**\*.cs")]
+            @"%DRIVE%:$(empty)\**\*.cs")]
         public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content, string include)
         {
+            include = DummyMappedDriveUtils.UpdatePathToMappedDrive(include, _mappedDrive.Value.MappedDriveLetter);
             content = string.Format(content, include);
             Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
                 content,
@@ -418,7 +426,7 @@ public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content
         /// <summary>
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Unix platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/8373")]
         [UnixOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index 884509b1b86..d22cd676005 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -41,8 +41,8 @@ public void Basic()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -67,8 +67,8 @@ public void RelativeDependentUpon()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace TestNamespace 
-    Class TestClass 
+Namespace TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -93,8 +93,8 @@ public void AbsoluteDependentUpon()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -119,8 +119,8 @@ public void DependentWithCulture()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -146,8 +146,8 @@ public void DependentWithCultureMetadata()
                     culture: "en-GB",
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -172,8 +172,8 @@ public void DependentWithCultureAndRootNamespace()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -198,8 +198,8 @@ public void DependentWithEmbeddedCulture()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 "),
@@ -417,8 +417,8 @@ private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
             {
                 return StreamHelpers.StringToStream(
 @"
-Namespace Nested.TestNamespace 
-    Class TestClass 
+Namespace Nested.TestNamespace
+    Class TestClass
     End Class
 End Namespace
 ");
@@ -454,7 +454,7 @@ public void Regress419591()
                     culture: null,
                     binaryStream: StreamHelpers.StringToStream(
 @"
-    Class MyForm 
+    Class MyForm
     End Class
 "),
                     log: null);
@@ -492,8 +492,8 @@ Namespace ClassLibrary1
 Namespace ClassLibrary2
 #else
 Namespace ClassLibrary3
-#end if 
-    Class MyForm 
+#end if
+    Class MyForm
     End Class
 End Namespace
 "),
diff --git a/src/Tasks.UnitTests/DownloadFile_Tests.cs b/src/Tasks.UnitTests/DownloadFile_Tests.cs
index b2115398091..6074c0a7b95 100644
--- a/src/Tasks.UnitTests/DownloadFile_Tests.cs
+++ b/src/Tasks.UnitTests/DownloadFile_Tests.cs
@@ -76,7 +76,7 @@ public void CanDownloadToFolder()
 
                 FileInfo file = new FileInfo(Path.Combine(folder.Path, "foo.txt"));
 
-                file.Exists.ShouldBeTrue(() => file.FullName);
+                file.Exists.ShouldBeTrue(file.FullName);
 
                 File.ReadAllText(file.FullName).ShouldBe("Success!");
 
@@ -121,7 +121,7 @@ public void CanGetFileNameFromResponseHeader()
 
                 FileInfo file = new FileInfo(Path.Combine(folder.Path, filename));
 
-                file.Exists.ShouldBeTrue(() => file.FullName);
+                file.Exists.ShouldBeTrue(file.FullName);
 
                 File.ReadAllText(file.FullName).ShouldBe("Success!");
 
@@ -155,7 +155,7 @@ public void CanSpecifyFileName()
 
                 FileInfo file = new FileInfo(Path.Combine(folder.Path, filename));
 
-                file.Exists.ShouldBeTrue(() => file.FullName);
+                file.Exists.ShouldBeTrue(file.FullName);
 
                 File.ReadAllText(file.FullName).ShouldBe("Success!");
 
@@ -172,7 +172,7 @@ public void InvalidUrlLogsError()
                 SourceUrl = "&&&&&"
             };
 
-            downloadFile.Execute().ShouldBeFalse(() => _mockEngine.Log);
+            downloadFile.Execute().ShouldBeFalse(_mockEngine.Log);
 
             _mockEngine.Log.ShouldContain("MSB3921");
         }
@@ -187,7 +187,7 @@ public void NotFoundLogsError()
                 SourceUrl = "http://notfound/foo.txt"
             };
 
-            downloadFile.Execute().ShouldBeFalse(() => _mockEngine.Log);
+            downloadFile.Execute().ShouldBeFalse(_mockEngine.Log);
 
             _mockEngine.Log.ShouldContain("Response status code does not indicate success: 404 (Not Found).");
         }
@@ -226,9 +226,9 @@ public void RetryOnDownloadError()
                     SourceUrl = "http://success/foo.txt"
                 };
 
-                downloadFile.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                downloadFile.Execute().ShouldBeTrue(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("MSB3924", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("MSB3924", customMessage: _mockEngine.Log);
             }
         }
 
@@ -244,9 +244,9 @@ public void RetryOnResponseError()
                 SourceUrl = "http://notfound/foo.txt"
             };
 
-            downloadFile.Execute().ShouldBeFalse(() => _mockEngine.Log);
+            downloadFile.Execute().ShouldBeFalse(_mockEngine.Log);
 
-            _mockEngine.Log.ShouldContain("MSB3924", () => _mockEngine.Log);
+            _mockEngine.Log.ShouldContain("MSB3924", customMessage: _mockEngine.Log);
         }
 
         [Fact]
@@ -267,9 +267,9 @@ public void AbortOnTimeout()
                 SourceUrl = "http://notfound/foo.txt"
             };
 
-            downloadFile.Execute().ShouldBeFalse(() => _mockEngine.Log);
+            downloadFile.Execute().ShouldBeFalse(_mockEngine.Log);
 
-            _mockEngine.Log.ShouldContain("MSB3923", () => _mockEngine.Log);
+            _mockEngine.Log.ShouldContain("MSB3923", customMessage: _mockEngine.Log);
         }
 
         [Fact]
@@ -306,7 +306,7 @@ public async Task NoRunawayLoop()
             runaway.IsCompleted.ShouldBeTrue("Task did not cancel");
 
             var result = await runaway;
-            result.ShouldBeFalse(() => _mockEngine.Log);
+            result.ShouldBeFalse(_mockEngine.Log);
         }
 
         [Fact]
@@ -339,7 +339,7 @@ public void SkipUnchangedFiles()
 
                 downloadFile.Execute().ShouldBeTrue();
 
-                _mockEngine.Log.ShouldContain("Did not download file from \"http://success/foo.txt\"", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("Did not download file from \"http://success/foo.txt\"", customMessage: _mockEngine.Log);
             }
         }
 
@@ -357,9 +357,9 @@ public void UnknownFileNameLogsError()
                 SourceUrl = "http://unknown/"
             };
 
-            downloadFile.Execute().ShouldBeFalse(() => _mockEngine.Log);
+            downloadFile.Execute().ShouldBeFalse(_mockEngine.Log);
 
-            _mockEngine.Log.ShouldContain("MSB3922", () => _mockEngine.Log);
+            _mockEngine.Log.ShouldContain("MSB3922", customMessage: _mockEngine.Log);
         }
 
         private sealed class MockHttpContent : HttpContent
diff --git a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
index 569192d3c57..acf917a4483 100644
--- a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
+++ b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
@@ -253,8 +253,8 @@ public void ErrorFromResources()
         }
 
         /// <summary>
-        /// If a "Code" is passed to the task, use it to override the code 
-        /// (if any) defined in the error message. 
+        /// If a "Code" is passed to the task, use it to override the code
+        /// (if any) defined in the error message.
         /// </summary>
         [Fact]
         public void ErrorFromResourcesWithOverriddenCode()
@@ -281,7 +281,7 @@ public void ErrorFromResourcesWithOverriddenCode()
         }
 
         /// <summary>
-        /// Simple case of logging a resource-based error that takes 
+        /// Simple case of logging a resource-based error that takes
         /// arguments
         /// </summary>
         [Fact]
@@ -308,8 +308,8 @@ public void ErrorFromResourcesWithArguments()
         }
 
         /// <summary>
-        /// If invalid arguments are passed to the task, it should still 
-        /// log an error informing the user of that. 
+        /// If invalid arguments are passed to the task, it should still
+        /// log an error informing the user of that.
         /// </summary>
         [Fact]
         public void ErrorFromResourcesWithInvalidArguments()
@@ -335,8 +335,8 @@ public void ErrorFromResourcesWithInvalidArguments()
         }
 
         /// <summary>
-        /// If no resource string is passed to ErrorFromResources, we should error 
-        /// because a required parameter is missing. 
+        /// If no resource string is passed to ErrorFromResources, we should error
+        /// because a required parameter is missing.
         /// </summary>
         [Fact]
         public void ErrorFromResourcesNoResources()
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index cb468a6ccea..088e68c81b0 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -69,6 +69,42 @@ public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile()
             }
         }
 
+        [UnixOnlyTheory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ExecSetsLocaleOnUnix(bool enableChangeWave)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("LANG", null);
+                env.SetEnvironmentVariable("LC_ALL", null);
+
+                if (enableChangeWave)
+                {
+                    ChangeWaves.ResetStateForTests();
+                    // Important: use the version here
+                    env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_10.ToString());
+                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                }
+
+                Exec exec = PrepareExec("echo LANG=$LANG; echo LC_ALL=$LC_ALL;");
+                bool result = exec.Execute();
+                Assert.True(result);
+
+                MockEngine engine = (MockEngine)exec.BuildEngine;
+                if (enableChangeWave)
+                {
+                    engine.AssertLogContains("LANG=en_US.UTF-8");
+                    engine.AssertLogContains("LC_ALL=en_US.UTF-8");
+                }
+                else
+                {
+                    engine.AssertLogDoesntContain("LANG=en_US.UTF-8");
+                    engine.AssertLogDoesntContain("LC_ALL=en_US.UTF-8");
+                }
+            }
+        }
+
         /// <summary>
         /// Ensures that calling the Exec task does not leave any extra TEMP files
         /// lying around.
@@ -895,22 +931,6 @@ public void ConsoleToMSBuild()
             Assert.Equal(2, exec.ConsoleOutput.Length);
         }
 
-        /// <summary>
-        /// Test the CanEncode method with and without ANSI characters to determine if they can be encoded 
-        /// in the current system encoding.
-        /// </summary>
-        [WindowsOnlyFact]
-        public void CanEncodeTest()
-        {
-            var defaultEncoding = EncodingUtilities.CurrentSystemOemEncoding;
-
-            string nonAnsiCharacters = "\u521B\u5EFA";
-            string pathWithAnsiCharacters = @"c:\windows\system32\cmd.exe";
-
-            Assert.False(EncodingUtilities.CanEncodeString(defaultEncoding.CodePage, nonAnsiCharacters));
-            Assert.True(EncodingUtilities.CanEncodeString(defaultEncoding.CodePage, pathWithAnsiCharacters));
-        }
-
         [Fact]
         public void EndToEndMultilineExec()
         {
diff --git a/src/Tasks.UnitTests/FormatUrl_Tests.cs b/src/Tasks.UnitTests/FormatUrl_Tests.cs
index 5260d22e642..26fabaf9db5 100644
--- a/src/Tasks.UnitTests/FormatUrl_Tests.cs
+++ b/src/Tasks.UnitTests/FormatUrl_Tests.cs
@@ -107,7 +107,7 @@ public void UncPathTest()
 
         /// <summary>
         /// The URL to format is a local absolute file path.
-        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem. 
+        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem.
         /// </summary>
         [Fact]
         public void LocalAbsolutePathTest()
@@ -122,7 +122,7 @@ public void LocalAbsolutePathTest()
 
         /// <summary>
         /// The URL to format is a local relative file path.
-        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem. 
+        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem.
         /// </summary>
         [Fact]
         public void LocalRelativePathTest()
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index f80107870cf..a417cabd783 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -151,7 +151,7 @@ public void GenerateBindingRedirectsFromTwoDependentAssemblySections()
 
         /// <summary>
         /// In this case,
-        /// - An app.config is passed in that has dependentAssembly section with probing element but without 
+        /// - An app.config is passed in that has dependentAssembly section with probing element but without
         ///   assemblyIdentity or bindingRedirect elements.
         /// Expected:
         /// - No warning
@@ -165,7 +165,7 @@ public void AppConfigWithProbingPathAndWithoutDependentAssemblyShouldNotProduceW
             // Arrange
             string appConfigFile = WriteAppConfigRuntimeSection(
 @"<assemblyBinding xmlns=""urn:schemas-microsoft-com:asm.v1"">
-   <probing privatePath = 'bin;bin2\subbin;bin3'/>  
+   <probing privatePath = 'bin;bin2\subbin;bin3'/>
 </assemblyBinding>");
             TaskItemMock redirect = new TaskItemMock("System, Version=10.0.0.0, Culture=Neutral, PublicKeyToken='b77a5c561934e089'", "40.0.0.0");
 
@@ -191,7 +191,7 @@ public void AppConfigWithEmptyAssemblyBindingShouldNotProduceWarnings()
         {
             // Arrange
             string appConfigFile = WriteAppConfigRuntimeSection(
-@"<assemblyBinding xmlns=""urn:schemas-microsoft-com:asm.v1"" appliesTo=""v1.0.3705""> 
+@"<assemblyBinding xmlns=""urn:schemas-microsoft-com:asm.v1"" appliesTo=""v1.0.3705"">
 </assemblyBinding>");
             TaskItemMock redirect = new TaskItemMock("System, Version=10.0.0.0, Culture=Neutral, PublicKeyToken='b77a5c561934e089'", "40.0.0.0");
 
@@ -291,7 +291,8 @@ public void AppConfigFileNotSavedWhenIdentical()
             redirectResults2.TargetAppConfigContent.ShouldContain("<assemblyIdentity name=\"System\" publicKeyToken=\"b77a5c561934e089\" culture=\"neutral\" />");
             redirectResults2.TargetAppConfigContent.ShouldContain("newVersion=\"40.0.0.0\"");
 
-            File.GetLastWriteTime(outputAppConfigFile).ShouldBeGreaterThan(oldTimestamp);
+            File.GetCreationTime(outputAppConfigFile).ShouldBe(oldTimestamp, TimeSpan.FromSeconds(5));
+            File.GetLastWriteTime(outputAppConfigFile).ShouldBe(oldTimestamp, TimeSpan.FromSeconds(5));
         }
 
         private BindingRedirectsExecutionResult GenerateBindingRedirects(string appConfigFile, string targetAppConfigFile,
diff --git a/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs b/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs
new file mode 100644
index 00000000000..8d50571656d
--- /dev/null
+++ b/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs
@@ -0,0 +1,89 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if NETFRAMEWORK
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Sdk;
+using Microsoft.Build.UnitTests.Shared;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class GetAssembliesMetadata_Tests
+    {
+        private static string TestAssembliesPaths { get; } = Path.Combine(AppContext.BaseDirectory, "TestResources", "Projects");
+
+        private readonly ITestOutputHelper _testOutput;
+
+        public GetAssembliesMetadata_Tests(ITestOutputHelper testOutput)
+        {
+            _testOutput = testOutput;
+        }
+
+        [Fact]
+        public void CheckPresenceOfCustomCOMAssemblyAttributes()
+        {
+            string testSolutionPath = Path.Combine(TestAssembliesPaths, "Custom_COM");
+            RunnerUtilities.ExecMSBuild(testSolutionPath, out bool success, _testOutput);
+            string assemblyPath = Path.Combine(testSolutionPath, "Custom_COM", "bin", "Debug", "Custom_COM.dll");
+            GetAssembliesMetadata t = new() { AssemblyPaths = new[] { assemblyPath } };
+
+            bool isSuccess = t.Execute();
+
+            success.ShouldBeTrue();
+            isSuccess.ShouldBeTrue();
+            t.AssembliesMetadata[0].ItemSpec.ShouldBe(assemblyPath);
+            t.AssembliesMetadata[0].GetMetadata("AssemblyName").ShouldBe("Custom_COM");
+            t.AssembliesMetadata[0].GetMetadata("IsImportedFromTypeLib").ShouldBe("False");
+            t.AssembliesMetadata[0].GetMetadata("RevisionNumber").ShouldBe("4");
+            t.AssembliesMetadata[0].GetMetadata("IsAssembly").ShouldBe("True");
+            t.AssembliesMetadata[0].GetMetadata("RuntimeVersion").ShouldBe("v4.0.30319");
+            t.AssembliesMetadata[0].GetMetadata("MajorVersion").ShouldBe("1");
+            t.AssembliesMetadata[0].GetMetadata("MinorVersion").ShouldBe("2");
+            t.AssembliesMetadata[0].GetMetadata("PeKind").ShouldBe("1");
+            t.AssembliesMetadata[0].GetMetadata("BuildNumber").ShouldBe("3");
+            t.AssembliesMetadata[0].GetMetadata("Description").ShouldBe("description for com");
+            t.AssembliesMetadata[0].GetMetadata("Culture").ShouldBeEmpty();
+            t.AssembliesMetadata[0].GetMetadata("TargetFrameworkMoniker").ShouldBe(".NETFramework,Version=v4.7.2");
+            t.AssembliesMetadata[0].GetMetadata("DefaultAlias").ShouldBe("Custom_COM");
+            t.AssembliesMetadata[0].GetMetadata("PublicHexKey").ShouldBeEmpty();
+        }
+
+        [Fact]
+        public void CheckPresenceOfCOMAssemblyAttributes()
+        {
+            string pathToWinFolder = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
+            string assemblyPath = Path.Combine(pathToWinFolder, "Microsoft.NET", "Framework", "v4.0.30319", "mscorlib.dll");
+            GetAssembliesMetadata t = new() { AssemblyPaths = new[] { assemblyPath } };
+
+            bool isSuccess = t.Execute();
+
+            isSuccess.ShouldBeTrue();
+            t.AssembliesMetadata[0].ItemSpec.ShouldBe(assemblyPath);
+            t.AssembliesMetadata[0].GetMetadata("AssemblyName").ShouldBe("mscorlib");
+            t.AssembliesMetadata[0].GetMetadata("IsImportedFromTypeLib").ShouldBe("False");
+            t.AssembliesMetadata[0].GetMetadata("RevisionNumber").ShouldBe("0");
+            t.AssembliesMetadata[0].GetMetadata("IsAssembly").ShouldBe("True");
+            t.AssembliesMetadata[0].GetMetadata("RuntimeVersion").ShouldBe("v4.0.30319");
+            t.AssembliesMetadata[0].GetMetadata("MajorVersion").ShouldBe("4");
+            t.AssembliesMetadata[0].GetMetadata("MinorVersion").ShouldBe("0");
+            t.AssembliesMetadata[0].GetMetadata("PeKind").ShouldBe("3");
+            t.AssembliesMetadata[0].GetMetadata("BuildNumber").ShouldBe("0");
+            t.AssembliesMetadata[0].GetMetadata("Description").ShouldBe("mscorlib.dll");
+            t.AssembliesMetadata[0].GetMetadata("Culture").ShouldBeEmpty();
+            t.AssembliesMetadata[0].GetMetadata("TargetFrameworkMoniker").ShouldBeEmpty();
+            t.AssembliesMetadata[0].GetMetadata("DefaultAlias").ShouldBe("mscorlib");
+            t.AssembliesMetadata[0].GetMetadata("PublicHexKey").ShouldBe("00000000000000000400000000000000");
+        }
+    }
+}
+#endif
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index ad5535b8991..040199f9fb9 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -84,7 +84,7 @@ private static string MakeFakeSDKStructure()
                     Path.Combine(
                         new[] { tempPath, "Windows", "NotAVersion", "ExtensionSDKs", "Assembly", "1.0" }));
 
-                // Good but are in a different target platform 
+                // Good but are in a different target platform
                 // Doors does not have an sdk manifest but does have extensionsdks under it so they should be found
                 // when we are targeting doors
                 Directory.CreateDirectory(
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index a69b7fa2ea3..6b3d539cacf 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -4,6 +4,7 @@
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
     <IsPackable>false</IsPackable>
+    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
 
     <AssemblyName>Microsoft.Build.Tasks.UnitTests</AssemblyName>
     <IsTestProject>true</IsTestProject>
@@ -16,6 +17,8 @@
 
   <ItemGroup>
     <PackageReference Include="Shouldly" />
+    <PackageReference Include="Verify.Xunit" />
+
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
@@ -58,6 +61,9 @@
     <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
+    <Compile Include="..\UnitTests.Shared\DriveMapping.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDrive.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDriveUtils.cs" />
     <Compile Include="..\Shared\UnitTests\LongPathSupportDisabledFactAttribute.cs">
       <Link>Shared\LongPathSupportDisabledFactAttribute.cs</Link>
     </Compile>
@@ -73,6 +79,18 @@
     <None Include="..\Shared\UnitTests\xunit.runner.json">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <None Include="TestResources\Projects\Custom_COM\Custom_COM\Class1.cs">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+    <None Include="TestResources\Projects\Custom_COM\Custom_COM.sln">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+    <None Include="TestResources\Projects\Custom_COM\Custom_COM\Custom_COM.csproj">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+    <None Include="TestResources\Projects\Custom_COM\Custom_COM\Properties\AssemblyInfo.cs">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
   </ItemGroup>
 
   <ItemGroup>
@@ -145,8 +163,17 @@
 
   <ItemGroup>
     <None Update="ResourceHandling\*.txt" CopyToOutputDirectory="PreserveNewest" />
+    <None Update="TestResources\Projects\Custom_COM\*">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+    <None Update="TestResources\ClickOnceProfile.pubxml">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
     <None Update="TestResources\lorem.bin">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <None Update="TestResources\mycert.pfx">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
   </ItemGroup>
 </Project>
diff --git a/src/Tasks.UnitTests/MockTypeInfo.cs b/src/Tasks.UnitTests/MockTypeInfo.cs
index aabf7050f11..140e6f596ca 100644
--- a/src/Tasks.UnitTests/MockTypeInfo.cs
+++ b/src/Tasks.UnitTests/MockTypeInfo.cs
@@ -47,7 +47,7 @@ public TYPEDESC CreateTypeDesc(IntPtr finalTypeHRef, MockUnmanagedMemoryHelper m
         }
 
         /// <summary>
-        /// Defer to the base element to get the final type info - this will eventually terminate at a MockTypeInfo node 
+        /// Defer to the base element to get the final type info - this will eventually terminate at a MockTypeInfo node
         /// which returns itself
         /// </summary>
         /// <returns></returns>
@@ -282,7 +282,7 @@ void IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out IFixedTypeInfo ppTI)
             }
         }
 
-        #endregion 
+        #endregion
 
         #region Implemented ITypeInfo members
 
diff --git a/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs b/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
index 5adffb71e6e..4d561e798b0 100644
--- a/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
+++ b/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
@@ -17,7 +17,7 @@ public class MockUnmanagedMemoryHelper
     {
         private List<IntPtr> _allocatedHandles;
 
-        // Zero if we're allocating independent chunks of memory; 
+        // Zero if we're allocating independent chunks of memory;
         // Something else if we're allocating connected chunks of memory that we'll want to release with one ReleaseHandle
         private IntPtr _mainAllocationHandle = IntPtr.Zero;
 
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index 5c14b9ad86a..ca8bee21b50 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -302,8 +302,8 @@ public void MoveOverExistingFileDestinationWriteable()
         /// <summary>
         /// Move should overwrite any destination file even if it's not r/o
         /// if OverwriteReadOnlyFiles is set.
-        /// 
-        /// This is a regression test for bug 814744 where a move operation with OverwriteReadonlyFiles = true on a destination file with the readonly 
+        ///
+        /// This is a regression test for bug 814744 where a move operation with OverwriteReadonlyFiles = true on a destination file with the readonly
         /// flag not set caused the readonly flag to be set before the move which caused the move to fail.
         /// </summary>
         [Fact]
@@ -411,7 +411,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
         }
 
         /// <summary>
-        /// MovedFiles should only include files that were successfully moved 
+        /// MovedFiles should only include files that were successfully moved
         /// (or skipped), not files for which there was an error.
         /// </summary>
         [WindowsOnlyFact(additionalMessage: "Under Unix all filenames are valid and this test is not useful.")]
@@ -777,7 +777,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
 
         /// <summary>
         /// If the destination path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
@@ -813,7 +813,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
 
         /// <summary>
         /// If the source path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
diff --git a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
index f7b76379327..689c4f7f1aa 100644
--- a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
+++ b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
@@ -64,9 +64,9 @@ public void Basic()
         }
 
         /// <summary>
-        /// Write one line, read one line, where the line contains MSBuild-escapable characters.  
-        /// The file should contain the *unescaped* lines, but no escaping information should be 
-        /// lost when read. 
+        /// Write one line, read one line, where the line contains MSBuild-escapable characters.
+        /// The file should contain the *unescaped* lines, but no escaping information should be
+        /// lost when read.
         /// </summary>
         [Fact]
         public void Escaping()
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 2bce4b5064f..47fb7e3c853 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -85,7 +85,7 @@ public void TestSerializationAndDeserialization()
 
         /*
          * Method:  CheckComReferenceAttributeVerificationForNameItems
-         * 
+         *
          * Checks if verification of Com reference item metadata works properly
          */
         [Fact]
@@ -148,7 +148,7 @@ public void CheckComReferenceMetadataVerificationForNameItems()
 
         /*
          * Method:  CheckComReferenceAttributeInitializationForNameItems
-         * 
+         *
          * Checks if missing optional attributes for COM name references get initialized correctly
          */
         [Fact]
@@ -181,7 +181,7 @@ public void CheckComReferenceMetadataInitializationForNameItems()
 
         /*
          * Method:  CheckComReferenceAttributeInitializationForFileItems
-         * 
+         *
          * Checks if missing optional attributes for COM file references get initialized correctly
          */
         [Fact]
@@ -395,7 +395,7 @@ public void CheckIsExistingDependencyReference()
             retValue = rcr.IsExistingDependencyReference(notInProjectAttr, out referenceInfo);
             Assert.True(!retValue && referenceInfo == null); // "not in project ref should not be found"
 
-            // Now, try to resolve a non-existent ComAssemblyReference. 
+            // Now, try to resolve a non-existent ComAssemblyReference.
             string path;
             IComReferenceResolver resolver = (IComReferenceResolver)rcr;
             Assert.False(resolver.ResolveComAssemblyReference("MyAssembly", out path));
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index fd2d6460e19..f0733ffb15c 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -3733,7 +3733,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists()
                 APPX ='AppxLocation'
                 SDKType ='External'
                 DisplayName = 'AnotherSDkWithManifest 2.0'
-                CopyRedistToSubDirectory='SomeOtherRedistDirectory'> 
+                CopyRedistToSubDirectory='SomeOtherRedistDirectory'>
                 <File WinMD = 'AnotherSDkWithManifest.Sprint, Version=8.0' />
                 <File AssemblyName = 'Assembly1, Version=8.0' />
                 <DependsOn Identity='Windows SDK, Version 8.0'/>
@@ -3755,7 +3755,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists()
                  <PropertyGroup>
                      <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
@@ -3896,7 +3896,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists2()
                  <PropertyGroup>
                      <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
@@ -4018,7 +4018,7 @@ public void GatherSDKOutputGroupsTargetArchitectureDoesNotExists()
                  <PropertyGroup>
                       <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
@@ -4123,7 +4123,7 @@ public void CheckDefaultingOfTargetConfigAndArchitecture()
                  <PropertyGroup>
                     <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
@@ -4262,7 +4262,7 @@ public void CheckAttributesFromManifestArePassedToResolvedAssemblies()
                  <PropertyGroup>
                     <Configuration>CAT</Configuration>" +
                     @"<OutputPath>" + testDirectoryRoot + "</OutputPath>" +
-                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier> 
+                    @"<TargetPlatformIdentifier>MyPlatform</TargetPlatformIdentifier>
                     <TargetPlatformVersion>8.0</TargetPlatformVersion>
                  </PropertyGroup>
                  <Import Project=""$(MSBuildBinPath)\Microsoft.Common.targets""/>
diff --git a/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
index 4364e17ff36..cad5a044c90 100644
--- a/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveVCProjectOutput_Tests.cs
@@ -32,9 +32,9 @@ internal void VerifyVCProjectOutputs(string vcProjectContents, bool useOverride,
             if (useOverride)
             {
                 string overrideContents = @"<?xml version=`1.0`?>
-                <VisualStudioPropertySheet 
-	                ProjectType=`Visual C++` 
-	                Version=`8.00` 
+                <VisualStudioPropertySheet
+	                ProjectType=`Visual C++`
+	                Version=`8.00`
 	                Name=`VCOverride` OutputDirectory=`Outputs\$(ConfigurationName)`
 	                >
                 </VisualStudioPropertySheet>";
@@ -79,7 +79,7 @@ internal void VerifyVCProjectOutputs(string vcProjectContents, bool useOverride,
         [Test]
         public void OverrideOutputDirectory()
         {
-            string vcProjectContents =  
+            string vcProjectContents =
             #region VC project contents
             @"<?xml version=`1.0` encoding=`Windows-1252`?>
                 <VisualStudioProject
@@ -345,7 +345,7 @@ public void OverrideOutputDirectory()
                 </VisualStudioProject>";
             #endregion
 
-            VerifyVCProjectOutputs(vcProjectContents, true, "Debug|Win32", 
+            VerifyVCProjectOutputs(vcProjectContents, true, "Debug|Win32",
                 @"Outputs\Debug\CppProj.dll", null);
         }
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index f704ef169a1..a38fd0f4bbd 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
@@ -338,7 +339,7 @@ public void ForceOutOfDate()
             /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
             Before:
             Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
-            
+
             Utilities.AssertStateFileWasWritten(t);
             After:
             Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
@@ -447,6 +448,59 @@ public void ForceOutOfDateLinked(bool usePreserialized)
             }
         }
 
+        [Fact]
+        public void QuestionOutOfDateByDeletion()
+        {
+            var folder = _env.CreateFolder();
+            string resxFileInput = Utilities.WriteTestResX(false, null, null, _env.CreateFile(folder, ".resx").Path);
+            TaskItem stateFile = new TaskItem(_env.GetTempFile(".cache").Path);
+            ITaskItem[] sources = new ITaskItem[] { new TaskItem(resxFileInput) };
+            ITaskItem[] output;
+
+            GenerateResource t1 = Utilities.CreateTask(_output);
+            t1.Sources = sources;
+            t1.StateFile = stateFile;
+            Utilities.ExecuteTask(t1);
+
+            Utilities.AssertLogContainsResource(t1, "GenerateResource.OutputDoesntExist", t1.OutputResources[0].ItemSpec);
+
+            output = t1.OutputResources;
+
+            // Run again to ensure all files are up to date.
+            GenerateResource t2 = Utilities.CreateTask(_output);
+            t2.Sources = sources;
+            t2.StateFile = stateFile;
+            t2.FailIfNotIncremental = true;
+            Utilities.ExecuteTask(t2);
+
+            // Delete the file and verify that FailIfNotIncremental will print the missing file
+            GenerateResource t3 = Utilities.CreateTask(_output);
+            t3.StateFile = stateFile;
+            t3.Sources = sources;
+            t3.FailIfNotIncremental = true;
+
+            // Delete the output
+            File.Delete(output[0].ItemSpec);
+
+            t3.Execute().ShouldBeFalse();
+
+            Utilities.AssertLogContainsResource(t3, "GenerateResource.ProcessingFile", sources[0].ItemSpec, output[0].ItemSpec);
+
+            GenerateResource t4 = Utilities.CreateTask(_output);
+            t4.Sources = sources;
+            t4.StateFile = stateFile;
+            Utilities.ExecuteTask(t4);
+
+            Utilities.AssertLogContainsResource(t4, "GenerateResource.OutputDoesntExist", t4.OutputResources[0].ItemSpec);
+
+            // Run again to ensure all files are up to date.
+            GenerateResource t5 = Utilities.CreateTask(_output);
+            t5.Sources = sources;
+            t5.StateFile = stateFile;
+            t5.FailIfNotIncremental = true;
+            Utilities.ExecuteTask(t5);
+        }
+
         [Theory]
         [InlineData(false, false)]
         [InlineData(false, true)]
@@ -1557,10 +1611,10 @@ public void StronglyTypedResourcesEmitTypeIntoClass()
 
                 string generatedSource = File.ReadAllText(t.StronglyTypedFileName);
 
-                generatedSource.ShouldNotContain("object Image1", "Strongly-typed resource accessor is returning type `object` instead of `System.Drawing.Bitmap`");
+                generatedSource.ShouldNotContain("object Image1", customMessage: "Strongly-typed resource accessor is returning type `object` instead of `System.Drawing.Bitmap`");
                 generatedSource.ShouldContain("Bitmap Image1");
 
-                generatedSource.ShouldNotContain("object MyString", "Strongly-typed resource accessor is returning type `object` instead of `string`");
+                generatedSource.ShouldNotContain("object MyString", customMessage: "Strongly-typed resource accessor is returning type `object` instead of `string`");
                 generatedSource.ShouldContain("static string MyString");
                 generatedSource.ShouldMatch("//.*Looks up a localized string similar to MyValue", "Couldn't find a comment in the usual format for a string resource.");
             }
@@ -1718,7 +1772,7 @@ public void FailedResXReader()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.False(success);
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.False(success);
@@ -1797,7 +1851,7 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.False(success);
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.False(success);
@@ -2317,7 +2371,7 @@ public void OutputFilesPartialInputs()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
@@ -3653,6 +3707,20 @@ GenerateResource ExecuteTask()
                 Utilities.FileUpdated(resourcesFile, initialWriteTime).ShouldBeFalse();
             }
         }
+
+        /// <summary>
+        /// https://github.com/dotnet/msbuild/issues/9199
+        /// </summary>
+        [Fact]
+        public void NotValidSources()
+        {
+            GenerateResource t = new GenerateResource { BuildEngine = new MockEngine(_output) };
+            t.Sources = new ITaskItem[] { new TaskItem("non-existent") };
+            t.OutputResources = new ITaskItem[] { new TaskItem("out") };
+            Assert.False(t.Execute());
+            ((MockEngine)t.BuildEngine).AssertLogContains("MSB3552");
+            Assert.Equal(1, ((MockEngine)t.BuildEngine).Errors);
+        }
     }
 }
 
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 5f9f39e9220..967dfe65a42 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -17,16 +17,31 @@
 using System.IO;
 #endif
 using Shouldly;
+using VerifyTests;
+using VerifyXunit;
 using Xunit;
 
+using static VerifyXunit.Verifier;
+
 #nullable disable
 
 namespace Microsoft.Build.Tasks.UnitTests
 {
+    [UsesVerify]
     public class RoslynCodeTaskFactory_Tests
     {
         private const string TaskName = "MyInlineTask";
 
+        private readonly VerifySettings _verifySettings;
+
+        public RoslynCodeTaskFactory_Tests()
+        {
+            UseProjectRelativeDirectory("TaskFactorySource");
+            
+            _verifySettings = new();
+            _verifySettings.ScrubLinesContaining("Runtime Version:");
+        }
+
         [Fact]
         public void InlineTaskWithAssemblyPlatformAgnostic()
         {
@@ -204,60 +219,11 @@ public void RoslynCodeTaskFactory_ReuseCompilation()
         public void VisualBasicFragment()
         {
             const string fragment = "Dim x = 0";
-            string expectedSourceCode = $@"'------------------------------------------------------------------------------
-' <auto-generated>
-'     This code was generated by a tool." +
-#if NETFRAMEWORK
-@"
-'     Runtime Version:4.0.30319.42000" +
-#endif
-@$"
-'
-'     Changes to this file may cause incorrect behavior and will be lost if
-'     the code is regenerated.
-' </auto-generated>
-'------------------------------------------------------------------------------
-
-Option Strict Off
-Option Explicit On
-
-Imports Microsoft.Build.Framework
-Imports Microsoft.Build.Utilities
-Imports System
-Imports System.Collections
-Imports System.Collections.Generic
-Imports System.IO
-Imports System.Linq
-Imports System.Text
-
-Namespace InlineCode
-    
-    Public Class {TaskName}
-        Inherits Microsoft.Build.Utilities.Task
-        
-        Private _Success As Boolean = true
-        
-        Public Overridable Property Success() As Boolean
-            Get
-                Return _Success
-            End Get
-            Set
-                _Success = value
-            End Set
-        End Property
-        
-        Public Overrides Function Execute() As Boolean
-{fragment}
-            Return Success
-        End Function
-    End Class
-End Namespace
-";
 
             TryLoadTaskBodyAndExpectSuccess(
                 taskBody: $"<Code Language=\"VB\">{fragment}</Code>",
                 expectedCodeLanguage: "VB",
-                expectedSourceCode: expectedSourceCode,
+                verifySource: true,
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Fragment);
         }
 
@@ -275,115 +241,10 @@ public void VisualBasicFragmentWithProperties()
 
             const string fragment = @"Dim x = 0";
 
-            string expectedSourceCode = $@"'------------------------------------------------------------------------------
-' <auto-generated>
-'     This code was generated by a tool.
-" +
-#if NETFRAMEWORK
-@"'     Runtime Version:4.0.30319.42000
-" +
-#endif
-@$"'
-'     Changes to this file may cause incorrect behavior and will be lost if
-'     the code is regenerated.
-' </auto-generated>
-'------------------------------------------------------------------------------
-
-Option Strict Off
-Option Explicit On
-
-Imports Microsoft.Build.Framework
-Imports Microsoft.Build.Utilities
-Imports System
-Imports System.Collections
-Imports System.Collections.Generic
-Imports System.IO
-Imports System.Linq
-Imports System.Text
-
-Namespace InlineCode
-    
-    Public Class {TaskName}
-        Inherits Microsoft.Build.Utilities.Task
-        
-        Private _Parameter1 As String
-        
-        Public Overridable Property Parameter1() As String
-            Get
-                Return _Parameter1
-            End Get
-            Set
-                _Parameter1 = value
-            End Set
-        End Property
-        
-        Private _Parameter2 As String
-        
-        Public Overridable Property Parameter2() As String
-            Get
-                Return _Parameter2
-            End Get
-            Set
-                _Parameter2 = value
-            End Set
-        End Property
-        
-        Private _Parameter3 As String
-        
-        Public Overridable Property Parameter3() As String
-            Get
-                Return _Parameter3
-            End Get
-            Set
-                _Parameter3 = value
-            End Set
-        End Property
-        
-        Private _Parameter4 As Microsoft.Build.Framework.ITaskItem
-        
-        Public Overridable Property Parameter4() As Microsoft.Build.Framework.ITaskItem
-            Get
-                Return _Parameter4
-            End Get
-            Set
-                _Parameter4 = value
-            End Set
-        End Property
-        
-        Private _Parameter5() As Microsoft.Build.Framework.ITaskItem
-        
-        Public Overridable Property Parameter5() As Microsoft.Build.Framework.ITaskItem()
-            Get
-                Return _Parameter5
-            End Get
-            Set
-                _Parameter5 = value
-            End Set
-        End Property
-        
-        Private _Success As Boolean = true
-        
-        Public Overridable Property Success() As Boolean
-            Get
-                Return _Success
-            End Get
-            Set
-                _Success = value
-            End Set
-        End Property
-        
-        Public Overrides Function Execute() As Boolean
-{fragment}
-            Return Success
-        End Function
-    End Class
-End Namespace
-";
-
             TryLoadTaskBodyAndExpectSuccess(
                 taskBody: $"<Code Language=\"VB\">{fragment}</Code>",
                 expectedCodeLanguage: "VB",
-                expectedSourceCode: expectedSourceCode,
+                verifySource: true,
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Fragment,
                 parameters: parameters);
         }
@@ -396,45 +257,10 @@ public void VisualBasicMethod()
             Return True
         End Function";
 
-            string expectedSourceCode = $@"'------------------------------------------------------------------------------
-' <auto-generated>
-'     This code was generated by a tool.
-" +
-#if NETFRAMEWORK
-@"'     Runtime Version:4.0.30319.42000
-" +
-#endif
-@$"'
-'     Changes to this file may cause incorrect behavior and will be lost if
-'     the code is regenerated.
-' </auto-generated>
-'------------------------------------------------------------------------------
-
-Option Strict Off
-Option Explicit On
-
-Imports Microsoft.Build.Framework
-Imports Microsoft.Build.Utilities
-Imports System
-Imports System.Collections
-Imports System.Collections.Generic
-Imports System.IO
-Imports System.Linq
-Imports System.Text
-
-Namespace InlineCode
-    
-    Public Class {TaskName}
-        Inherits Microsoft.Build.Utilities.Task
-        
-{method}
-    End Class
-End Namespace
-";
             TryLoadTaskBodyAndExpectSuccess(
                 taskBody: $"<Code Language=\"VB\" Type=\"Method\">{method}</Code>",
                 expectedCodeLanguage: "VB",
-                expectedSourceCode: expectedSourceCode,
+                verifySource: true,
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
         }
 
@@ -497,7 +323,7 @@ public override bool Execute()
 
             TryLoadTaskBodyAndExpectSuccess(
                 $"<Code Type=\"Class\">{taskClassSourceCode}</Code>",
-                expectedSourceCode: taskClassSourceCode,
+                verifySource: true,
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Class,
                 expectedCodeLanguage: "CS");
         }
@@ -506,52 +332,8 @@ public override bool Execute()
         public void CSharpFragment()
         {
             const string fragment = "int x = 0;";
-            string expectedSourceCode = $@"//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-" +
-#if NETFRAMEWORK
-@"//     Runtime Version:4.0.30319.42000
-" +
-#endif
-$@"//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace InlineCode {{
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Utilities;
-    using System;
-    using System.Collections;
-    using System.Collections.Generic;
-    using System.IO;
-    using System.Linq;
-    using System.Text;
-    
-    
-    public class {TaskName} : Microsoft.Build.Utilities.Task {{
-        
-        private bool _Success = true;
-        
-        public virtual bool Success {{
-            get {{
-                return _Success;
-            }}
-            set {{
-                _Success = value;
-            }}
-        }}
-        
-        public override bool Execute() {{
-{fragment}
-            return Success;
-        }}
-    }}
-}}
-";
-            TryLoadTaskBodyAndExpectSuccess(taskBody: $"<Code>{fragment}</Code>", expectedSourceCode: expectedSourceCode);
+
+            TryLoadTaskBodyAndExpectSuccess(taskBody: $"<Code>{fragment}</Code>", verifySource: true);
         }
 
         [Fact]
@@ -568,110 +350,9 @@ public void CSharpFragmentWithProperties()
 
             const string fragment = @"int x = 0;";
 
-            string expectedSourceCode = $@"//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-" +
-#if NETFRAMEWORK
-@"//     Runtime Version:4.0.30319.42000
-" +
-#endif
-$@"//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace InlineCode {{
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Utilities;
-    using System;
-    using System.Collections;
-    using System.Collections.Generic;
-    using System.IO;
-    using System.Linq;
-    using System.Text;
-    
-    
-    public class {TaskName} : Microsoft.Build.Utilities.Task {{
-        
-        private string _Parameter1;
-        
-        public virtual string Parameter1 {{
-            get {{
-                return _Parameter1;
-            }}
-            set {{
-                _Parameter1 = value;
-            }}
-        }}
-        
-        private string _Parameter2;
-        
-        public virtual string Parameter2 {{
-            get {{
-                return _Parameter2;
-            }}
-            set {{
-                _Parameter2 = value;
-            }}
-        }}
-        
-        private string _Parameter3;
-        
-        public virtual string Parameter3 {{
-            get {{
-                return _Parameter3;
-            }}
-            set {{
-                _Parameter3 = value;
-            }}
-        }}
-        
-        private Microsoft.Build.Framework.ITaskItem _Parameter4;
-        
-        public virtual Microsoft.Build.Framework.ITaskItem Parameter4 {{
-            get {{
-                return _Parameter4;
-            }}
-            set {{
-                _Parameter4 = value;
-            }}
-        }}
-        
-        private Microsoft.Build.Framework.ITaskItem[] _Parameter5;
-        
-        public virtual Microsoft.Build.Framework.ITaskItem[] Parameter5 {{
-            get {{
-                return _Parameter5;
-            }}
-            set {{
-                _Parameter5 = value;
-            }}
-        }}
-        
-        private bool _Success = true;
-        
-        public virtual bool Success {{
-            get {{
-                return _Success;
-            }}
-            set {{
-                _Success = value;
-            }}
-        }}
-        
-        public override bool Execute() {{
-{fragment}
-            return Success;
-        }}
-    }}
-}}
-";
-
             TryLoadTaskBodyAndExpectSuccess(
                 taskBody: $"<Code>{fragment}</Code>",
-                expectedSourceCode: expectedSourceCode,
+                verifySource: true,
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Fragment,
                 parameters: parameters);
         }
@@ -681,40 +362,9 @@ public void CSharpMethod()
         {
             const string method = @"public override bool Execute() { int x = 0; return true; }";
 
-            string expectedSourceCode = $@"//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-" +
-#if NETFRAMEWORK
-@"//     Runtime Version:4.0.30319.42000
-" +
-#endif
-@$"//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace InlineCode {{
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Utilities;
-    using System;
-    using System.Collections;
-    using System.Collections.Generic;
-    using System.IO;
-    using System.Linq;
-    using System.Text;
-    
-    
-    public class MyInlineTask : Microsoft.Build.Utilities.Task {{
-        
-{method}
-    }}
-}}
-";
             TryLoadTaskBodyAndExpectSuccess(
                 taskBody: $"<Code Type=\"Method\">{method}</Code>",
-                expectedSourceCode: expectedSourceCode,
+                verifySource: true,
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
         }
 
@@ -742,7 +392,7 @@ public override bool Execute()
 
                 TryLoadTaskBodyAndExpectSuccess(
                     $"<Code Source=\"{file.Path}\" />",
-                    expectedSourceCode: taskClassSourceCode,
+                    verifySource: true,
                     expectedCodeType: RoslynCodeTaskFactoryCodeType.Class,
                     expectedCodeLanguage: "CS");
             }
@@ -752,58 +402,14 @@ public override bool Execute()
         public void CSharpFragmentSourceCodeFromFile()
         {
             const string sourceCodeFileContents = "int x = 0;";
-            const string expectedSourceCode = @"//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-" +
-#if NETFRAMEWORK
-@"//     Runtime Version:4.0.30319.42000
-" +
-#endif
-                                              $@"//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace InlineCode {{
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Utilities;
-    using System;
-    using System.Collections;
-    using System.Collections.Generic;
-    using System.IO;
-    using System.Linq;
-    using System.Text;
-    
-    
-    public class {TaskName} : Microsoft.Build.Utilities.Task {{
-        
-        private bool _Success = true;
-        
-        public virtual bool Success {{
-            get {{
-                return _Success;
-            }}
-            set {{
-                _Success = value;
-            }}
-        }}
-        
-        public override bool Execute() {{
-{sourceCodeFileContents}
-            return Success;
-        }}
-    }}
-}}
-";
+
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
                 TransientTestFile file = testEnvironment.CreateFile(fileName: "CSharpFragmentSourceCodeFromFile.tmp", contents: sourceCodeFileContents);
 
                 TryLoadTaskBodyAndExpectSuccess(
                     $"<Code Source=\"{file.Path}\" Type=\"Fragment\"/>",
-                    expectedSourceCode: expectedSourceCode,
+                    verifySource: true,
                     expectedCodeType: RoslynCodeTaskFactoryCodeType.Fragment);
             }
         }
@@ -812,44 +418,14 @@ public override bool Execute() {{
         public void CSharpMethodSourceCodeFromFile()
         {
             const string sourceCodeFileContents = @"public override bool Execute() { int x = 0; return true; }";
-            const string expectedSourceCode = @"//------------------------------------------------------------------------------
-// <auto-generated>
-//     This code was generated by a tool.
-" +
-#if NETFRAMEWORK
-@"//     Runtime Version:4.0.30319.42000
-" +
-#endif
-                                              @$"//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace InlineCode {{
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Utilities;
-    using System;
-    using System.Collections;
-    using System.Collections.Generic;
-    using System.IO;
-    using System.Linq;
-    using System.Text;
-    
-    
-    public class MyInlineTask : Microsoft.Build.Utilities.Task {{
-        
-{sourceCodeFileContents}
-    }}
-}}
-";
+
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
                 TransientTestFile file = testEnvironment.CreateFile(fileName: "CSharpMethodSourceCodeFromFile.tmp", contents: sourceCodeFileContents);
 
                 TryLoadTaskBodyAndExpectSuccess(
                     $"<Code Source=\"{file.Path}\" Type=\"Method\"/>",
-                    expectedSourceCode: expectedSourceCode,
+                    verifySource: true,
                     expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
             }
         }
@@ -1022,7 +598,7 @@ public void SourceCodeFromFile()
 
                 TryLoadTaskBodyAndExpectSuccess(
                     $"<Code Source=\"{file.Path}\"/>",
-                    expectedSourceCode: sourceCodeFileContents,
+                    verifySource: true,
                     expectedCodeType: RoslynCodeTaskFactoryCodeType.Class);
             }
         }
@@ -1068,6 +644,48 @@ public override bool Execute()
             }
         }
 
+#if !FEATURE_RUN_EXE_IN_TESTS
+        [Fact]
+        public void RoslynCodeTaskFactory_UsingAPI()
+        {
+            string text = $@"
+<Project>
+
+  <UsingTask
+    TaskName=""Custom1""
+    TaskFactory=""RoslynCodeTaskFactory""
+    AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"" >
+    <ParameterGroup>
+      <SayHi ParameterType=""System.String"" Required=""true"" />
+    </ParameterGroup>
+    <Task>
+      <Code Type=""Fragment"" Language=""cs"">
+        <![CDATA[
+        string sayHi = ""Hello "" + SayHi;
+        Log.LogMessage(sayHi);
+        ]]>
+      </Code>
+    </Task>
+  </UsingTask>
+
+    <Target Name=""Build"">
+        <Custom1 SayHi=""World"" />
+    </Target>
+
+</Project>";
+
+            using var env = TestEnvironment.Create();
+            RunnerUtilities.ApplyDotnetHostPathEnvironmentVariable(env);
+            var dotnetPath = Environment.GetEnvironmentVariable("DOTNET_HOST_PATH");
+
+            var project = env.CreateTestProjectWithFiles("p1.proj", text);
+            var logger = project.BuildProjectExpectSuccess();
+            var logLines = logger.AllBuildEvents.Select(a => a.Message);
+            var log = string.Join("\n", logLines);
+            logLines.Where(l => l.Contains(dotnetPath)).Count().ShouldBe(1, log);
+        }
+#endif
+
         private void TryLoadTaskBodyAndExpectFailure(string taskBody, string expectedErrorMessage)
         {
             if (expectedErrorMessage == null)
@@ -1088,7 +706,7 @@ private void TryLoadTaskBodyAndExpectFailure(string taskBody, string expectedErr
 
             buildEngine.Errors.ShouldBe(1);
 
-            buildEngine.Log.ShouldContain(expectedErrorMessage, () => buildEngine.Log);
+            buildEngine.Log.ShouldContain(expectedErrorMessage, customMessage: buildEngine.Log);
         }
 
         private void TryLoadTaskBodyAndExpectSuccess(
@@ -1098,7 +716,7 @@ private void TryLoadTaskBodyAndExpectSuccess(
             ISet<string> expectedNamespaces = null,
             string expectedCodeLanguage = null,
             RoslynCodeTaskFactoryCodeType? expectedCodeType = null,
-            string expectedSourceCode = null,
+            bool verifySource = false,
             IReadOnlyList<string> expectedWarningMessages = null)
         {
             MockEngine buildEngine = new MockEngine();
@@ -1122,7 +740,7 @@ private void TryLoadTaskBodyAndExpectSuccess(
 
                 foreach (string expectedWarningMessage in expectedWarningMessages)
                 {
-                    output.ShouldContain(expectedWarningMessage, () => output);
+                    output.ShouldContain(expectedWarningMessage, customMessage: output);
                 }
             }
 
@@ -1148,18 +766,10 @@ private void TryLoadTaskBodyAndExpectSuccess(
                 taskInfo.CodeType.ShouldBe(expectedCodeType.Value);
             }
 
-            if (expectedSourceCode != null)
+            if (verifySource)
             {
-                NormalizeRuntime(taskInfo.SourceCode)
-                    .ShouldBe(NormalizeRuntime(expectedSourceCode), StringCompareShould.IgnoreLineEndings);
+                Verify(taskInfo.SourceCode, _verifySettings).GetAwaiter().GetResult();
             }
         }
-
-        private static readonly Regex RuntimeVersionLine = new Regex("Runtime Version:.*");
-
-        private static string NormalizeRuntime(string input)
-        {
-            return RuntimeVersionLine.Replace(input, "Runtime Version:SOMETHING");
-        }
     }
 }
diff --git a/src/Tasks.UnitTests/SecurityUtil_Tests.cs b/src/Tasks.UnitTests/SecurityUtil_Tests.cs
new file mode 100644
index 00000000000..92bcfaf08c8
--- /dev/null
+++ b/src/Tasks.UnitTests/SecurityUtil_Tests.cs
@@ -0,0 +1,81 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Runtime.ConstrainedExecution;
+using System.Runtime.Versioning;
+using System.Security.Cryptography;
+using System.Security.Cryptography.X509Certificates;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class SecurityUtil_Tests
+    {
+        private static string TestAssembliesPaths { get; } = Path.Combine(AppContext.BaseDirectory, "TestResources");
+
+        [WindowsOnlyTheory]
+        [InlineData("v4.5", Constants.DotNetFrameworkIdentifier)]
+        [InlineData("v4.5", Constants.DotNetCoreAppIdentifier)]
+        [SupportedOSPlatform("windows")]
+        public void SignFile_Success(string tfVersion, string tfIdentifier)
+        {
+            Uri timestampUrl = new("http://timestamp.comodoca.com/rfc3161");
+            string clickOnceManifest = Path.Combine(TestAssembliesPaths, "ClickOnceProfile.pubxml");
+            string targetFrameworkVersion = tfVersion;
+            string targetFrameworkIdentifier = tfIdentifier;
+            bool disallowMansignTimestampFallback = false;
+
+            // the certificate was generated locally and does not contain any sensitive information
+            string pathToCertificate = Path.Combine(TestAssembliesPaths, "mycert.pfx");
+            X509Certificate2 certificate = TestCertHelper.MockCertificate(pathToCertificate);
+
+            void SignAction() => SecurityUtilities.SignFile(
+                certificate?.Thumbprint,
+                timestampUrl,
+                clickOnceManifest,
+                targetFrameworkVersion,
+                targetFrameworkIdentifier,
+                disallowMansignTimestampFallback);
+
+            Should.NotThrow(SignAction);
+
+            TestCertHelper.RemoveCertificate(certificate);
+        }
+
+        internal static class TestCertHelper
+        {
+            private static readonly X509Store s_personalStore = new(StoreName.My, StoreLocation.CurrentUser);
+
+            internal static X509Certificate2 MockCertificate(string pathToCertificate)
+            {
+                var certificate = new X509Certificate2(pathToCertificate);
+                UpdateCertificateState(certificate, s_personalStore.Add);
+
+                return certificate;
+            }
+
+            internal static void RemoveCertificate(X509Certificate2 certificate) => UpdateCertificateState(certificate, s_personalStore.Remove);
+
+            private static void UpdateCertificateState(X509Certificate2 certificate, Action<X509Certificate2> updateAction)
+            {
+                try
+                {
+                    s_personalStore.Open(OpenFlags.ReadWrite);
+                    updateAction(certificate);
+                }
+                finally
+                {
+                    s_personalStore.Close();
+                }
+            }
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/StreamHelpers.cs b/src/Tasks.UnitTests/StreamHelpers.cs
index ca3b5410d1a..b28c8a5c319 100644
--- a/src/Tasks.UnitTests/StreamHelpers.cs
+++ b/src/Tasks.UnitTests/StreamHelpers.cs
@@ -11,7 +11,7 @@ internal sealed class StreamHelpers
     {
         /*
          * Method:  StringToStream (overload)
-         * 
+         *
          * Take a string and convert it into a Stream.
          * Use the default encoding which means this machine's ANSI codepage.
          */
@@ -26,7 +26,7 @@ internal static Stream StringToStream(string value)
 
         /*
          * Method:  StringToStream (overload)
-         * 
+         *
          * Take a string and convert it into a Stream.
          * Takes an alternate encoding type
          */
diff --git a/src/Tasks.UnitTests/StreamMappedString_Tests.cs b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
index c91b7901458..2830548cab6 100644
--- a/src/Tasks.UnitTests/StreamMappedString_Tests.cs
+++ b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
@@ -24,7 +24,7 @@ public void Regress_Mutation_ForceANSIWorks_RelatedTo172107()
 
             // Instead, directly write the ANSI character into the memory buffer.
             sourcesStream.Seek(11, SeekOrigin.Begin);
-            sourcesStream.WriteByte(0xc3);    // Plug the 'Ã' in 
+            sourcesStream.WriteByte(0xc3);    // Plug the 'Ã' in
             sourcesStream.Seek(0, SeekOrigin.Begin);
 
             // Should not throw an exception because we force ANSI.
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpClass.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpClass.verified.txt
new file mode 100644
index 00000000000..ba355ca9bee
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpClass.verified.txt
@@ -0,0 +1,13 @@
+﻿namespace InlineTask
+{
+    using Microsoft.Build.Utilities;
+
+    public class HelloWorld : Task
+    {
+        public override bool Execute()
+        {
+            Log.LogMessage("Hello, world!");
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpClassSourceCodeFromFile.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpClassSourceCodeFromFile.verified.txt
new file mode 100644
index 00000000000..ba355ca9bee
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpClassSourceCodeFromFile.verified.txt
@@ -0,0 +1,13 @@
+﻿namespace InlineTask
+{
+    using Microsoft.Build.Utilities;
+
+    public class HelloWorld : Task
+    {
+        public override bool Execute()
+        {
+            Log.LogMessage("Hello, world!");
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragment.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragment.verified.txt
new file mode 100644
index 00000000000..7e93fa00ffe
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragment.verified.txt
@@ -0,0 +1,39 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class MyInlineTask : Microsoft.Build.Utilities.Task {
+        
+        private bool _Success = true;
+        
+        public virtual bool Success {
+            get {
+                return _Success;
+            }
+            set {
+                _Success = value;
+            }
+        }
+        
+        public override bool Execute() {
+int x = 0;
+            return Success;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragmentSourceCodeFromFile.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragmentSourceCodeFromFile.verified.txt
new file mode 100644
index 00000000000..7e93fa00ffe
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragmentSourceCodeFromFile.verified.txt
@@ -0,0 +1,39 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class MyInlineTask : Microsoft.Build.Utilities.Task {
+        
+        private bool _Success = true;
+        
+        public virtual bool Success {
+            get {
+                return _Success;
+            }
+            set {
+                _Success = value;
+            }
+        }
+        
+        public override bool Execute() {
+int x = 0;
+            return Success;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragmentWithProperties.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragmentWithProperties.verified.txt
new file mode 100644
index 00000000000..7918a5a0a17
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpFragmentWithProperties.verified.txt
@@ -0,0 +1,94 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class MyInlineTask : Microsoft.Build.Utilities.Task {
+        
+        private string _Parameter1;
+        
+        public virtual string Parameter1 {
+            get {
+                return _Parameter1;
+            }
+            set {
+                _Parameter1 = value;
+            }
+        }
+        
+        private string _Parameter2;
+        
+        public virtual string Parameter2 {
+            get {
+                return _Parameter2;
+            }
+            set {
+                _Parameter2 = value;
+            }
+        }
+        
+        private string _Parameter3;
+        
+        public virtual string Parameter3 {
+            get {
+                return _Parameter3;
+            }
+            set {
+                _Parameter3 = value;
+            }
+        }
+        
+        private Microsoft.Build.Framework.ITaskItem _Parameter4;
+        
+        public virtual Microsoft.Build.Framework.ITaskItem Parameter4 {
+            get {
+                return _Parameter4;
+            }
+            set {
+                _Parameter4 = value;
+            }
+        }
+        
+        private Microsoft.Build.Framework.ITaskItem[] _Parameter5;
+        
+        public virtual Microsoft.Build.Framework.ITaskItem[] Parameter5 {
+            get {
+                return _Parameter5;
+            }
+            set {
+                _Parameter5 = value;
+            }
+        }
+        
+        private bool _Success = true;
+        
+        public virtual bool Success {
+            get {
+                return _Success;
+            }
+            set {
+                _Success = value;
+            }
+        }
+        
+        public override bool Execute() {
+int x = 0;
+            return Success;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpMethod.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpMethod.verified.txt
new file mode 100644
index 00000000000..ba1ea298db4
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpMethod.verified.txt
@@ -0,0 +1,25 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class MyInlineTask : Microsoft.Build.Utilities.Task {
+        
+public override bool Execute() { int x = 0; return true; }
+    }
+}
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpMethodSourceCodeFromFile.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpMethodSourceCodeFromFile.verified.txt
new file mode 100644
index 00000000000..ba1ea298db4
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.CSharpMethodSourceCodeFromFile.verified.txt
@@ -0,0 +1,25 @@
+﻿//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a tool.
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+
+namespace InlineCode {
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.IO;
+    using System.Linq;
+    using System.Text;
+    
+    
+    public class MyInlineTask : Microsoft.Build.Utilities.Task {
+        
+public override bool Execute() { int x = 0; return true; }
+    }
+}
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.SourceCodeFromFile.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.SourceCodeFromFile.verified.txt
new file mode 100644
index 00000000000..4358c4b04fb
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.SourceCodeFromFile.verified.txt
@@ -0,0 +1,3 @@
+﻿
+1F214E27A13F432B9397F1733BC55929
+9111DC29B0064E6994A68CFE465404D4
\ No newline at end of file
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicFragment.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicFragment.verified.txt
new file mode 100644
index 00000000000..bf543b2ca95
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicFragment.verified.txt
@@ -0,0 +1,43 @@
+﻿'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict Off
+Option Explicit On
+
+Imports Microsoft.Build.Framework
+Imports Microsoft.Build.Utilities
+Imports System
+Imports System.Collections
+Imports System.Collections.Generic
+Imports System.IO
+Imports System.Linq
+Imports System.Text
+
+Namespace InlineCode
+    
+    Public Class MyInlineTask
+        Inherits Microsoft.Build.Utilities.Task
+        
+        Private _Success As Boolean = true
+        
+        Public Overridable Property Success() As Boolean
+            Get
+                Return _Success
+            End Get
+            Set
+                _Success = value
+            End Set
+        End Property
+        
+        Public Overrides Function Execute() As Boolean
+Dim x = 0
+            Return Success
+        End Function
+    End Class
+End Namespace
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicFragmentWithProperties.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicFragmentWithProperties.verified.txt
new file mode 100644
index 00000000000..c5506e9fb3e
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicFragmentWithProperties.verified.txt
@@ -0,0 +1,98 @@
+﻿'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict Off
+Option Explicit On
+
+Imports Microsoft.Build.Framework
+Imports Microsoft.Build.Utilities
+Imports System
+Imports System.Collections
+Imports System.Collections.Generic
+Imports System.IO
+Imports System.Linq
+Imports System.Text
+
+Namespace InlineCode
+    
+    Public Class MyInlineTask
+        Inherits Microsoft.Build.Utilities.Task
+        
+        Private _Parameter1 As String
+        
+        Public Overridable Property Parameter1() As String
+            Get
+                Return _Parameter1
+            End Get
+            Set
+                _Parameter1 = value
+            End Set
+        End Property
+        
+        Private _Parameter2 As String
+        
+        Public Overridable Property Parameter2() As String
+            Get
+                Return _Parameter2
+            End Get
+            Set
+                _Parameter2 = value
+            End Set
+        End Property
+        
+        Private _Parameter3 As String
+        
+        Public Overridable Property Parameter3() As String
+            Get
+                Return _Parameter3
+            End Get
+            Set
+                _Parameter3 = value
+            End Set
+        End Property
+        
+        Private _Parameter4 As Microsoft.Build.Framework.ITaskItem
+        
+        Public Overridable Property Parameter4() As Microsoft.Build.Framework.ITaskItem
+            Get
+                Return _Parameter4
+            End Get
+            Set
+                _Parameter4 = value
+            End Set
+        End Property
+        
+        Private _Parameter5() As Microsoft.Build.Framework.ITaskItem
+        
+        Public Overridable Property Parameter5() As Microsoft.Build.Framework.ITaskItem()
+            Get
+                Return _Parameter5
+            End Get
+            Set
+                _Parameter5 = value
+            End Set
+        End Property
+        
+        Private _Success As Boolean = true
+        
+        Public Overridable Property Success() As Boolean
+            Get
+                Return _Success
+            End Get
+            Set
+                _Success = value
+            End Set
+        End Property
+        
+        Public Overrides Function Execute() As Boolean
+Dim x = 0
+            Return Success
+        End Function
+    End Class
+End Namespace
diff --git a/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicMethod.verified.txt b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicMethod.verified.txt
new file mode 100644
index 00000000000..47677c28919
--- /dev/null
+++ b/src/Tasks.UnitTests/TaskFactorySource/RoslynCodeTaskFactory_Tests.VisualBasicMethod.verified.txt
@@ -0,0 +1,32 @@
+﻿'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict Off
+Option Explicit On
+
+Imports Microsoft.Build.Framework
+Imports Microsoft.Build.Utilities
+Imports System
+Imports System.Collections
+Imports System.Collections.Generic
+Imports System.IO
+Imports System.Linq
+Imports System.Text
+
+Namespace InlineCode
+    
+    Public Class MyInlineTask
+        Inherits Microsoft.Build.Utilities.Task
+        
+Public Overrides Function Execute() As Boolean
+            Dim x = 0
+            Return True
+        End Function
+    End Class
+End Namespace
diff --git a/src/Tasks.UnitTests/TestResources/ClickOnceProfile.pubxml b/src/Tasks.UnitTests/TestResources/ClickOnceProfile.pubxml
new file mode 100644
index 00000000000..0f18e1617e4
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/ClickOnceProfile.pubxml
@@ -0,0 +1,11 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<asmv1:assembly manifestVersion="1.0" xsi:schemaLocation="urn:schemas-microsoft-com:asm.v1 assembly.adaptive.xsd" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:co.v2="urn:schemas-microsoft-com:clickonce.v2" xmlns="urn:schemas-microsoft-com:asm.v2" xmlns:asmv1="urn:schemas-microsoft-com:asm.v1" xmlns:asmv2="urn:schemas-microsoft-com:asm.v2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:co.v1="urn:schemas-microsoft-com:clickonce.v1">
+  <asmv1:assemblyIdentity version="1.0.0.0" name="Test.exe" publicKeyToken="17076c97a9b91555" language="neutral" processorArchitecture="x86" type="win32" />
+  <description asmv2:iconFile="osd.ico" xmlns="urn:schemas-microsoft-com:asm.v1" />
+  <application />
+  <entryPoint>
+    <assemblyIdentity name="Test" version="2.4.1.6" publicKeyToken="02E7DCADB6D14547" language="neutral" processorArchitecture="x86" />
+    <commandLine file="Test.exe" parameters="" />
+  </entryPoint>
+
+<publisherIdentity name="CN=YourCertificateName" issuerKeyHash="56226b54236ba71b5f6a9719277818a8cce711cf" /><Signature Id="StrongNameSignature" xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#" /><SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha256" /><Reference URI=""><Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature" /><Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#" /></Transforms><DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha256" /><DigestValue>GFyhRWlbyN1COOyGVz+n59ISTl8HTCRRaL7OE/wqoqc=</DigestValue></Reference></SignedInfo><SignatureValue>fzzu/EybaQbpsDnYtyMLpWpaihS9qwnFwsp+01OrSOv9FD6scw5hDE6Y7f0vfpCq7oTCrlFpGBA2MtPOUfsC3/YOUSI0rzFgZ4zKvYp13cqtpdLEBKrhxmtNWIxZfZr8ByCkxTMjQWUD8LV9/oB561ofOPSkVmrgVrPi6ciUbac9njyaxNXY1EWjplXAHF0Mf8hhsAmM8lZypRJBfZ4tjSmN1nBXkHzKX3X2BrkUTcFxoBiyEE/P6cVPdqAA/fAGtBm4rn8Kpm/ivMXZevR/Y1DkPrnOyHs0VjJacc/G66oTG8BrN7YKj9R/eAtxVQyMQNzpNVb9RxlfL6OIY6lLmQ==</SignatureValue><KeyInfo Id="StrongNameKeyInfo"><KeyValue><RSAKeyValue><Modulus>6tvmrtrrG1VZfNmU2Bl3UNKJA5MYqNwsb/AgeqqIywgsJAep3pu5D5hA2dFFiMLIC+d+K0PxNgUQpVxkTIX+4aYn6uo+alTek/i1EM0AMZm1pFxmN4WSbSTSrwduuXQLX4hDMP0Sl3TVJL8truWBvGHrtU8/I6dLYrqemEMyOh8C7v802VDLWZW5yq6MSt+KqtnHfILMZzitv7fh2qo+RJ4zvGL+4ZI+S7lwl2ltt9p8nvHDiFSodVwQHEXkPULx7IZfDVNXs6MzgN5NwFGaZtCyktzrcecLRh3UujeViikMZTSQq/DurOuUyzy89QfBPWg+d56EaI4pt/DX5zJ0KQ==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue><msrel:RelData xmlns:msrel="http://schemas.microsoft.com/windows/rel/2005/reldata"><r:license xmlns:r="urn:mpeg:mpeg21:2003:01-REL-R-NS" xmlns:as="http://schemas.microsoft.com/windows/pki/2005/Authenticode"><r:grant><as:ManifestInformation Hash="a7a22afc13cebe6851244c075f4e12d2e7a73f5786ec3842ddc85b6945a15c18" Description="" Url=""><as:assemblyIdentity version="1.0.0.0" name="OSD_Config.exe" publicKeyToken="17076c97a9b91555" language="neutral" processorArchitecture="x86" type="win32" /></as:ManifestInformation><as:SignedBy /><as:AuthenticodePublisher><as:X509SubjectName>CN=YourCertificateName</as:X509SubjectName></as:AuthenticodePublisher></r:grant><r:issuer><Signature Id="AuthenticodeSignature" xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#" /><SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha256" /><Reference URI=""><Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature" /><Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#" /></Transforms><DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha256" /><DigestValue>7L0K32UM0IBLmCQiodjr1C77qlV0vD3GTM34xo5nm94=</DigestValue></Reference></SignedInfo><SignatureValue>oRPs44JALU/JhGZasau4cn17arKsvShbmTPfkk9NWJV3YEdcvuzzO7l0yaXt29INLFVh9dc7n5mpJhuk4GaydFGY2xQAR/CIHSF7S79iPxKUxtWvYws4Bp7q7kSFDrloW4s3RwWIVksgWWnvhlk21AVDTXhAYEU8IfQX9jmafB0SejBxD9KkQOiAwtV/OWWSWNpGcI84AITMiFvDZDQDER566tGqNHZLeEYunmUqcoQry7X/BFsl2jvzIkAdSAnXJWx3dsYYTl9bngazfrDbZR8f40VicEGvUY9HzL0Ei8IalP6Vwqx9G91m+hH8oVcKSEbi+cRKm6NWLVe5Tgql7w==</SignatureValue><KeyInfo><KeyValue><RSAKeyValue><Modulus>6tvmrtrrG1VZfNmU2Bl3UNKJA5MYqNwsb/AgeqqIywgsJAep3pu5D5hA2dFFiMLIC+d+K0PxNgUQpVxkTIX+4aYn6uo+alTek/i1EM0AMZm1pFxmN4WSbSTSrwduuXQLX4hDMP0Sl3TVJL8truWBvGHrtU8/I6dLYrqemEMyOh8C7v802VDLWZW5yq6MSt+KqtnHfILMZzitv7fh2qo+RJ4zvGL+4ZI+S7lwl2ltt9p8nvHDiFSodVwQHEXkPULx7IZfDVNXs6MzgN5NwFGaZtCyktzrcecLRh3UujeViikMZTSQq/DurOuUyzy89QfBPWg+d56EaI4pt/DX5zJ0KQ==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue><X509Data><X509Certificate>MIIDGTCCAgGgAwIBAgIQ4HSIXz7yH49M25eRQpRFGjANBgkqhkiG9w0BAQsFADAeMRwwGgYDVQQDExNZb3VyQ2VydGlmaWNhdGVOYW1lMB4XDTIzMTExNjEzNTQyMVoXDTM5MTIzMTIzNTk1OVowHjEcMBoGA1UEAxMTWW91ckNlcnRpZmljYXRlTmFtZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOrb5q7a6xtVWXzZlNgZd1DSiQOTGKjcLG/wIHqqiMsILCQHqd6buQ+YQNnRRYjCyAvnfitD8TYFEKVcZEyF/uGmJ+rqPmpU3pP4tRDNADGZtaRcZjeFkm0k0q8Hbrl0C1+IQzD9Epd01SS/La7lgbxh67VPPyOnS2K6nphDMjofAu7/NNlQy1mVucqujErfiqrZx3yCzGc4rb+34dqqPkSeM7xi/uGSPku5cJdpbbfafJ7xw4hUqHVcEBxF5D1C8eyGXw1TV7OjM4DeTcBRmmbQspLc63HnC0Yd1Lo3lYopDGU0kKvw7qzrlMs8vPUHwT1oPneehGiOKbfw1+cydCkCAwEAAaNTMFEwTwYDVR0BBEgwRoAQKuOh/UZkiI1MMUdwVlT6KaEgMB4xHDAaBgNVBAMTE1lvdXJDZXJ0aWZpY2F0ZU5hbWWCEOB0iF8+8h+PTNuXkUKURRowDQYJKoZIhvcNAQELBQADggEBAAybLoyi46eGUAwqJOORCgbkJMrQQOE/C8reSrBByJbL7g1QLPkaEULfGf8oex8cRYI2/uToZMf+uoyGqu+aGquoYSCBviRXerSnjHvpW1PB8RnpyMN/346F4dVtPWWMVHMKD4Pl0rlFRBVl/trbE9fUP15eE1hySsQxoGzazhrptvogUyjjz+7boh+W1knjwfvLt+aPN/x3o6JNGMa0gmmqICAbOHFKstTSa2DAucrUVbm9oWhTK/27AmTq++GFEdr/YpQU4RY5XRLviT3dAW0LamAFSrrInXX0RBea6/E9pIWxfdcnMt5yZ2FnnrDEVFLiXYI3ZSCjRurZfsROU1M=</X509Certificate></X509Data></KeyInfo><Object><as:Timestamp>MIITUQYJKoZIhvcNAQcCoIITQjCCEz4CAQMxDzANBglghkgBZQMEAgIFADCCAQkGCyqGSIb3DQEJEAEEoIH5BIH2MIHzAgEBBgorBgEEAbIxAgEBMDEwDQYJYIZIAWUDBAIBBQAEIH1etI3E4tO6qCW4uM/wT+Ki+ZjNbBOTitUKiB7eq+pqAhRGF9wNi9pmL/MUJr9yxH3kR6TBYBgPMjAyMzExMTYxNDMzNDlaAhin99vUc2MG10YLzph4LfRGAtothPvkYsugbqRsMGoxCzAJBgNVBAYTAkdCMRMwEQYDVQQIEwpNYW5jaGVzdGVyMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0ZWQxLDAqBgNVBAMMI1NlY3RpZ28gUlNBIFRpbWUgU3RhbXBpbmcgU2lnbmVyICM0oIIN6TCCBvUwggTdoAMCAQICEDlMJeF8oG0nqGXiO9kdItQwDQYJKoZIhvcNAQEMBQAwfTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMSUwIwYDVQQDExxTZWN0aWdvIFJTQSBUaW1lIFN0YW1waW5nIENBMB4XDTIzMDUwMzAwMDAwMFoXDTM0MDgwMjIzNTk1OVowajELMAkGA1UEBhMCR0IxEzARBgNVBAgTCk1hbmNoZXN0ZXIxGDAWBgNVBAoTD1NlY3RpZ28gTGltaXRlZDEsMCoGA1UEAwwjU2VjdGlnbyBSU0EgVGltZSBTdGFtcGluZyBTaWduZXIgIzQwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCkkyhSS88nh3akKRyZOMDnDtTRHOxoywFk5IrNd7BxZYK8n/yLu7uVmPslEY5aiAlmERRYsroiW+b2MvFdLcB6og7g4FZk7aHlgSByIGRBbMfDCPrzfV3vIZrCftcsw7oRmB780yAIQrNfv3+IWDKrMLPYjHqWShkTXKz856vpHBYusLA4lUrPhVCrZwMlobs46Q9vqVqakSgTNbkf8z3hJMhrsZnoDe+7TeU9jFQDkdD8Lc9VMzh6CRwH0SLgY4anvv3Sg3MSFJuaTAlGvTS84UtQe3LgW/0Zux88ahl7brstRCq+PEzMrIoEk8ZXhqBzNiuBl/obm36Ih9hSeYn+bnc317tQn/oYJU8T8l58qbEgWimro0KHd+D0TAJI3VilU6ajoO0ZlmUVKcXtMzAl5paDgZr2YGaQWAeAzUJ1rPu0kdDF3QFAaraoEO72jXq3nnWv06VLGKEMn1ewXiVHkXTNdRLRnG/kXg2b7HUm7v7T9ZIvUoXo2kRRKqLMAMqHZkOjGwDvorWWnWKtJwvyG0rJw5RCN4gghKiHrsO6I3J7+FTv+GsnsIX1p0OF2Cs5dNtadwLRpPr1zZw9zB+uUdB7bNgdLRFCU3F0wuU1qi1SEtklz/DT0JFDEtcyfZhs43dByP8fJFTvbq3GPlV78VyHOmTxYEsFT++5L+wJEwIDAQABo4IBgjCCAX4wHwYDVR0jBBgwFoAUGqH4YRkgD8NBd0UojtE1XwYSBFUwHQYDVR0OBBYEFAMPMciRKpO9Y/PRXU2kNA/SlQEYMA4GA1UdDwEB/wQEAwIGwDAMBgNVHRMBAf8EAjAAMBYGA1UdJQEB/wQMMAoGCCsGAQUFBwMIMEoGA1UdIARDMEEwNQYMKwYBBAGyMQECAQMIMCUwIwYIKwYBBQUHAgEWF2h0dHBzOi8vc2VjdGlnby5jb20vQ1BTMAgGBmeBDAEEAjBEBgNVHR8EPTA7MDmgN6A1hjNodHRwOi8vY3JsLnNlY3RpZ28uY29tL1NlY3RpZ29SU0FUaW1lU3RhbXBpbmdDQS5jcmwwdAYIKwYBBQUHAQEEaDBmMD8GCCsGAQUFBzAChjNodHRwOi8vY3J0LnNlY3RpZ28uY29tL1NlY3RpZ29SU0FUaW1lU3RhbXBpbmdDQS5jcnQwIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLnNlY3RpZ28uY29tMA0GCSqGSIb3DQEBDAUAA4ICAQBMm2VY+uB5z+8VwzJt3jOR63dY4uu9y0o8dd5+lG3DIscEld9laWETDPYMnvWJIF7Bh8cDJMrHpfAm3/j4MWUN4OttUVemjIRSCEYcKsLe8tqKRfO+9/YuxH7t+O1ov3pWSOlh5Zo5d7y+upFkiHX/XYUWNCfSKcv/7S3a/76TDOxtog3Mw/FuvSGRGiMAUq2X1GJ4KoR5qNc9rCGPcMMkeTqX8Q2jo1tT2KsAulj7NYBPXyhxbBlewoNykK7gxtjymfvqtJJlfAd8NUQdrVgYa2L73mzECqls0yFGcNwvjXVMI8JB0HqWO8NL3c2SJnR2XDegmiSeTl9O048P5RNPWURlS0Nkz0j4Z2e5Tb/MDbE6MNChPUitemXk7N/gAfCzKko5rMGk+al9NdAyQKCxGSoYIbLIfQVxGksnNqrgmByDdefHfkuEQ81D+5CXdioSrEDBcFuZCkD6gG2UYXvIbrnIZ2ckXFCNASDeB/cB1PguEc2dg+X4yiUcRD0n5bCGRyoLG4R2fXtoT4239xO07aAt7nMP2RC6nZksfNd1H48QxJTmfiTllUqIjCfWhWYd+a5kdpHoSP7IVQrtKcMf3jimwBT7Mj34qYNiNsjDvgCHHKv6SkIciQPc9Vx8cNldeE7un14g5glqfCsIo0j1FfwET9/NIRx65fWOGtS5QDCCBuwwggTUoAMCAQICEDAPb6zdZph0fKlGNqd4LbkwDQYJKoZIhvcNAQEMBQAwgYgxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpOZXcgSmVyc2V5MRQwEgYDVQQHEwtKZXJzZXkgQ2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMS4wLAYDVQQDEyVVU0VSVHJ1c3QgUlNBIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTE5MDUwMjAwMDAwMFoXDTM4MDExODIzNTk1OVowfTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMSUwIwYDVQQDExxTZWN0aWdvIFJTQSBUaW1lIFN0YW1waW5nIENBMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAyBsBr9ksfoiZfQGYPyCQvZyAIVSTuc+gPlPvs1rAdtYaBKXOR4O168TMSTTL80VlufmnZBYmCfvVMlJ5LsljwhObtoY/AQWSZm8hq9VxEHmH9EYqzcRaydvXXUlNclYP3MnjU5g6Kh78zlhJ07/zObu5pCNCrNAVw3+eolzXOPEWsnDTo8Tfs8VyrC4Kd/wNlFK3/B+VcyQ9ASi8Dw1Ps5EBjm6dJ3VV0Rc7NCF7lwGUr3+Az9ERCleEyX9W4L1GnIK+lJ2/tCCwYH64TfUNP9vQ6oWMilZx0S2UTMiMPNMUopy9Jv/TUyDHYGmbWApU9AXn/TGs+ciFF8e4KRmkKS9G493bkV+fPzY+DjBnK0a3Na+WvtpMYMyou58NFNQYxDCYdIIhz2JWtSFzEh79qsoIWId3pBXrGVX/0DlULSbuRRo6b83XhPDX8CjFT2SDAtT74t7xvAIo9G3aJ4oG0paH3uhrDvBbfel2aZMgHEqXLHcZK5OVmJyXnuuOwXhWxkQl3wYSmgYtnwNe/YOiU2fKsfqNoWTJiJJZy6hGwMnypv99V9sSdvqKQSTUG/xypRSi1K1DHKRJi0E5FAMeKfobpSKupcNNgtCN2mu32/cYQFdz8HGj+0p9RTbB942C+rnJDVOAffq2OVgy728YUInXT50zvRq1naHelUF6p4MCAwEAAaOCAVowggFWMB8GA1UdIwQYMBaAFFN5v1qqK0rPVIDh2JvAnfKyA2bLMB0GA1UdDgQWBBQaofhhGSAPw0F3RSiO0TVfBhIEVTAOBgNVHQ8BAf8EBAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADATBgNVHSUEDDAKBggrBgEFBQcDCDARBgNVHSAECjAIMAYGBFUdIAAwUAYDVR0fBEkwRzBFoEOgQYY/aHR0cDovL2NybC51c2VydHJ1c3QuY29tL1VTRVJUcnVzdFJTQUNlcnRpZmljYXRpb25BdXRob3JpdHkuY3JsMHYGCCsGAQUFBwEBBGowaDA/BggrBgEFBQcwAoYzaHR0cDovL2NydC51c2VydHJ1c3QuY29tL1VTRVJUcnVzdFJTQUFkZFRydXN0Q0EuY3J0MCUGCCsGAQUFBzABhhlodHRwOi8vb2NzcC51c2VydHJ1c3QuY29tMA0GCSqGSIb3DQEBDAUAA4ICAQBtVIGlM10W4bVTgZF13wN6MgstJYQRsrDbKn0qBfW8Oyf0WqC5SVmQKWxhy7VQ2+J9+Z8A70DDrdPi5Fb5WEHP8ULlEH3/sHQfj8ZcCfkzXuqgHCZYXPO0EQ/V1cPivNVYeL9IduFEZ22PsEMQD43k+ThivxMBxYWjTMXMslMwlaTW9JZWCLjNXH8Blr5yUmo7Qjd8Fng5k5OUm7Hcsm1BbWfNyW+QPX9FcsEbI9bCVYRm5LPFZgb289ZLXq2jK0KKIZL+qG9aJXBigXNjXqC72NzXStM9r4MGOBIdJIct5PwC1j53BLwENrXnd8ucLo0jGLmjwkcd8F3WoXNXBWiap8k3ZR2+6rzYQoNDBaWLpgn/0aGUpk6qPQn1BWy30mRa2Coiwkud8TleTN5IPZs0lpoJX47997FSkc4/ifYcobWpdR9xv1tDXWU9UIFuq/DQ0/yysx+2mZYm9Dx5i1xkzM3uJ5rloMAMcofBbk1a0x7q8ETmMm8c6xdOlMN4ZSA7D0GqH+mhQZ3+sbigZSo04N6o+TzmwTC7wKBjLPxcFgCo0MR/6hGdHgbGpm0yXbQ4CStJB6r97DDa8acvz7f9+tCjhNknnvsBZne5VhDhIG7GrrH5trrINV0zdo7xfCAMKneutaIChrop7rRaALGMq+P5CslUXdS5anSevUiumDGCBCwwggQoAgEBMIGRMH0xCzAJBgNVBAYTAkdCMRswGQYDVQQIExJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAOBgNVBAcTB1NhbGZvcmQxGDAWBgNVBAoTD1NlY3RpZ28gTGltaXRlZDElMCMGA1UEAxMcU2VjdGlnbyBSU0EgVGltZSBTdGFtcGluZyBDQQIQOUwl4XygbSeoZeI72R0i1DANBglghkgBZQMEAgIFAKCCAWswGgYJKoZIhvcNAQkDMQ0GCyqGSIb3DQEJEAEEMBwGCSqGSIb3DQEJBTEPFw0yMzExMTYxNDMzNDlaMD8GCSqGSIb3DQEJBDEyBDAu3oi8LlFMRGDjEVyF781xrOKeZb3AvTNZRROCDd1/VcKu3FEkFYXbokVJI3+pjZowge0GCyqGSIb3DQEJEAIMMYHdMIHaMIHXMBYEFK5ir3UKDL1H1kYfdWjivIznyk+UMIG8BBQC1luV4oNwwVcAlfqI+SPdk3+tjzCBozCBjqSBizCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkCEDAPb6zdZph0fKlGNqd4LbkwDQYJKoZIhvcNAQEBBQAEggIAawwSvCbzGun4UluNVdjYS+WhD+U1EfxTYQhKc/2qJlzo+OmyLWrPo3B3WzXb1rQMP+JgJUzaxZqfWW6gQm5+i82UkfZhBYTZ+6gJ8Elt0W54EWouDoORWkBZEai+fB5NOx/3Vt6Ku8GrGV3DMXxUPxKNLFtecruLJ9c5Yduw3lRKTCEppajog8VJ73XglXZLu82WgHNyVDn+xCperyOILWkcTo3xheCVvlYgDCrJqrWGY0sg/NOwrKaCBN8ZY9vLGMifvQ3Cltvmw4SKOxaRjdiKr6mTP7uC/DDLJLwkBujaESnnwsgM9DptdVyZqSi5FlNH5nmzyFD3z7wBeMdstGX/m7Ag2jeyr2cX5TGfC3GrMiz3spG8Lsl8CZW6JriYuH3EWSA2cEaZAnxB22nLNar3kP8rknIdReMZybBrfDu/cQre+1PtYNaunJvZXlQQGI96qfdLhQTWaTQfWwLq2A39p7dBWS+4/qzxG0H80MKaSCfT+TNKxORvj8tqEbxAo7YBGdPOQzui7OEmaOoe+ecFFBN9cnEzSHn54CAwJodo6bPoo1lXmBcasJqFO5XrDXFUX7Q6VCwJF/l1AxvS5wl8jN0rs/QIy69QIjGVUaghnSZsBcypUM3IZXFvPN85TSUlIw9WgWq3vnK/4YHDAnBd8FlacjexruIUc0hB7KM=</as:Timestamp></Object></Signature></r:issuer></r:license></msrel:RelData></KeyInfo></Signature></asmv1:assembly>
diff --git a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM.sln b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM.sln
new file mode 100644
index 00000000000..b87b98a6c68
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM.sln
@@ -0,0 +1,25 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 17
+VisualStudioVersion = 17.8.34119.44
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Custom_COM", "Custom_COM\Custom_COM.csproj", "{A48EFB66-2596-4C6A-87AB-C8A765E54429}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{A48EFB66-2596-4C6A-87AB-C8A765E54429}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{A48EFB66-2596-4C6A-87AB-C8A765E54429}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{A48EFB66-2596-4C6A-87AB-C8A765E54429}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{A48EFB66-2596-4C6A-87AB-C8A765E54429}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {3A8E37B3-7F2C-491C-9742-92319262C651}
+	EndGlobalSection
+EndGlobal
diff --git a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Class1.cs b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Class1.cs
new file mode 100644
index 00000000000..891e68b690d
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Class1.cs
@@ -0,0 +1,22 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Reflection;
+using System.Runtime.InteropServices;
+
+namespace Custom_COM
+{
+    [Guid("D6F88E95-8A27-4ae6-B6DE-0542A0FC7039")]
+    [InterfaceType(ComInterfaceType.InterfaceIsIDispatch)]
+    public interface ITest
+    {
+    }
+
+    [Guid("13FE32AD-4BF8-495f-AB4D-6C61BD463EA4")]
+    [ClassInterface(ClassInterfaceType.None)]
+    [ProgId("Tester.Numbers")]
+    public class Test : ITest
+    {
+    }
+}
diff --git a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Custom_COM.csproj b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Custom_COM.csproj
new file mode 100644
index 00000000000..8c582aa7f52
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Custom_COM.csproj
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProjectGuid>{A48EFB66-2596-4C6A-87AB-C8A765E54429}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Custom_COM</RootNamespace>
+    <AssemblyName>Custom_COM</AssemblyName>
+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <Deterministic>true</Deterministic>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core" />
+    <Reference Include="System.Xml.Linq" />
+    <Reference Include="System.Data.DataSetExtensions" />
+    <Reference Include="Microsoft.CSharp" />
+    <Reference Include="System.Data" />
+    <Reference Include="System.Net.Http" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Class1.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+</Project>
diff --git a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs
new file mode 100644
index 00000000000..233af2b505c
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs
@@ -0,0 +1,41 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Resources;
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("Custom_COM")]
+[assembly: AssemblyDescription("description for com")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("MSFT")]
+[assembly: AssemblyProduct("Custom_COM")]
+[assembly: AssemblyCopyright("Copyright ©  2023")]
+[assembly: AssemblyTrademark("Mark")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(true)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("a48efb66-2596-4c6a-87ab-c8a765e54429")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.2.3.4")]
+[assembly: AssemblyFileVersion("1.2.3.4")]
+[assembly: NeutralResourcesLanguage("cs")]
diff --git a/src/Tasks.UnitTests/TestResources/mycert.pfx b/src/Tasks.UnitTests/TestResources/mycert.pfx
new file mode 100644
index 00000000000..2809e31eb9b
Binary files /dev/null and b/src/Tasks.UnitTests/TestResources/mycert.pfx differ
diff --git a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
index ced85ee1368..e904909c4b0 100644
--- a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
+++ b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
@@ -27,7 +27,7 @@ public void TestResourceAccess()
 
             t.BuildEngine = engine;
 
-            // No need to actually check the outputted strings. We only care that this doesn't throw, which means that 
+            // No need to actually check the outputted strings. We only care that this doesn't throw, which means that
             // the resource strings were reachable.
 
             // Normal CSC messages first, from private XMakeTasks resources. They should be accessible with t.Log
diff --git a/src/Tasks.UnitTests/Touch_Tests.cs b/src/Tasks.UnitTests/Touch_Tests.cs
index 72117637d4a..a6759421bad 100644
--- a/src/Tasks.UnitTests/Touch_Tests.cs
+++ b/src/Tasks.UnitTests/Touch_Tests.cs
@@ -377,7 +377,7 @@ public void QuestionTouchNonExistingAlwaysCreate()
 
             bool success = Execute(t);
 
-            Assert.False(success);
+            Assert.True(success);
 
             Assert.Contains(
                 String.Format(AssemblyResources.GetString("Touch.CreatingFile"), mynonexisting_txt, "AlwaysCreate"),
@@ -401,7 +401,7 @@ public void QuestionTouchExisting()
 
             bool success = Execute(t);
 
-            Assert.False(success);
+            Assert.True(success);
 
             Assert.Contains(
                 String.Format(AssemblyResources.GetString("Touch.Touching"), myexisting_txt),
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index eb2dc83d338..0f862db51ee 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -42,9 +42,9 @@ public void CanOverwriteReadOnlyFile()
                     SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) }
                 };
 
-                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeTrue(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("638AF4AE88A146E09CB69FE1CA7083DC", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("638AF4AE88A146E09CB69FE1CA7083DC", customMessage: _mockEngine.Log);
             }
         }
 
@@ -70,7 +70,7 @@ public void CanUnzip()
                     SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
                     FailIfNotIncremental = true,
                 };
-                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeFalse(_mockEngine.Log);
                 _mockEngine.Log = string.Empty;
 
                 // Run the task.
@@ -83,10 +83,10 @@ public void CanUnzip()
                     SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
                     FailIfNotIncremental = false,
                 };
-                unzip2.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                unzip2.Execute().ShouldBeTrue(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), customMessage: _mockEngine.Log);
 
                 // Question ran task, should be true
                 Unzip unzip3 = new Unzip
@@ -98,7 +98,7 @@ public void CanUnzip()
                     SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
                     FailIfNotIncremental = true,
                 };
-                unzip3.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                unzip3.Execute().ShouldBeTrue(_mockEngine.Log);
             }
         }
 
@@ -127,12 +127,12 @@ public void CanUnzip_ExplicitDirectoryEntries()
                     SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) }
                 };
 
-                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeTrue(customMessage: _mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "subdir", "F83E9633685494E53BEF3794EDEEE6A6.txt"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "subdir", "21D6D4596067723B3AC5DF9A8B3CBFE7.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "subdir", "F83E9633685494E53BEF3794EDEEE6A6.txt"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "subdir", "21D6D4596067723B3AC5DF9A8B3CBFE7.txt"), customMessage: _mockEngine.Log);
                 Directory.Exists(Path.Combine(destination.Path, "emptyDir"));
             }
         }
@@ -146,9 +146,9 @@ public void LogsErrorIfDirectoryCannotBeCreated()
                 DestinationFolder = new TaskItem(String.Empty)
             };
 
-            unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+            unzip.Execute().ShouldBeFalse(_mockEngine.Log);
 
-            _mockEngine.Log.ShouldContain("MSB3931", () => _mockEngine.Log);
+            _mockEngine.Log.ShouldContain("MSB3931", customMessage: _mockEngine.Log);
         }
 
         public static bool NotRunningAsRoot()
@@ -195,9 +195,9 @@ public void LogsErrorIfReadOnlyFileCannotBeOverwitten()
                     SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) }
                 };
 
-                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeFalse(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain($"D6DFD219DACE48F8B86EFCDF98433333.txt{(NativeMethodsShared.IsMono ? "\"" : "'")} is denied", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain($"D6DFD219DACE48F8B86EFCDF98433333.txt{(NativeMethodsShared.IsMono ? "\"" : "'")} is denied", customMessage: _mockEngine.Log);
             }
         }
 
@@ -217,9 +217,9 @@ public void LogsErrorIfSourceFileCannotBeOpened()
                     SourceFiles = new ITaskItem[] { new TaskItem(file.Path), }
                 };
 
-                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeFalse(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("MSB3933", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("MSB3933", customMessage: _mockEngine.Log);
             }
         }
 
@@ -237,9 +237,9 @@ public void LogsErrorIfSourceFileDoesNotExist()
                     SourceFiles = new ITaskItem[] { new TaskItem(Path.Combine(testEnvironment.DefaultTestDirectory.Path, "foo.zip")), }
                 };
 
-                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeFalse(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("MSB3932", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("MSB3932", customMessage: _mockEngine.Log);
             }
         }
 
@@ -265,10 +265,10 @@ public void CanUnzip_WithIncludeFilter()
                     Include = "BE78A17D30144B549D21F71D5C633F7D.txt"
                 };
 
-                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeTrue(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), customMessage: _mockEngine.Log);
             }
         }
 
@@ -294,10 +294,10 @@ public void CanUnzip_WithExcludeFilter()
                     Exclude = "BE78A17D30144B549D21F71D5C633F7D.txt"
                 };
 
-                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeTrue(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), customMessage: _mockEngine.Log);
             }
         }
 
@@ -328,13 +328,13 @@ public void CanUnzip_WithIncludeAndExcludeFilter()
                     Exclude = "*.js.map;sub\\*.js"
                 };
 
-                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeTrue(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "file1.js"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "file1.js.map"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "file2.js"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "readme.txt"), () => _mockEngine.Log);
-                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "sub", "subfile.js"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "file1.js"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "file1.js.map"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "file2.js"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "readme.txt"), customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "sub", "subfile.js"), customMessage: _mockEngine.Log);
             }
         }
 
@@ -360,9 +360,9 @@ public void LogsErrorIfIncludeContainsInvalidPathCharacters()
                     Include = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
                 };
 
-                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeFalse(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("MSB3937", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("MSB3937", customMessage: _mockEngine.Log);
             }
         }
 
@@ -388,9 +388,9 @@ public void LogsErrorIfIncludeContainsPropertyReferences()
                     Include = "$(Include)"
                 };
 
-                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeFalse(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("MSB3938", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("MSB3938", customMessage: _mockEngine.Log);
             }
         }
 
@@ -416,9 +416,9 @@ public void LogsErrorIfExcludeContainsInvalidPathCharacters()
                     Exclude = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
                 };
 
-                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeFalse(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("MSB3937", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("MSB3937", customMessage: _mockEngine.Log);
             }
         }
 
@@ -444,9 +444,9 @@ public void LogsErrorIfExcludeContainsPropertyReferences()
                     Exclude = "$(Include)"
                 };
 
-                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                unzip.Execute().ShouldBeFalse(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("MSB3938", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("MSB3938", customMessage: _mockEngine.Log);
             }
         }
     }
diff --git a/src/Tasks.UnitTests/VerifyFileHash_Tests.cs b/src/Tasks.UnitTests/VerifyFileHash_Tests.cs
index 47ce06858a0..4abf6590304 100644
--- a/src/Tasks.UnitTests/VerifyFileHash_Tests.cs
+++ b/src/Tasks.UnitTests/VerifyFileHash_Tests.cs
@@ -90,7 +90,7 @@ public void VerifyFileChecksum_FailsForMismatch(string algoritm, string hash)
                 Hash = hash,
             };
 
-            task.Execute().ShouldBeFalse(() => _mockEngine.Log);
+            task.Execute().ShouldBeFalse(_mockEngine.Log);
 
             var errorEvent = _mockEngine.ErrorEvents.ShouldHaveSingleItem();
 
diff --git a/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs b/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
index e87890fb8ff..2d16e27f677 100644
--- a/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
+++ b/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
@@ -54,7 +54,7 @@ public void NestedNamespace()
                 @"
     Namespace Goofy
         Namespace Mickey
-            <DefaultInstanceProperty(&qtGetInstance&qt)> Public Class Form1      
+            <DefaultInstanceProperty(&qtGetInstance&qt)> Public Class Form1
                 ",
                 "Goofy.Mickey.Form1");
         }
@@ -68,7 +68,7 @@ public void NestedAndEndedNamespace()
     Namespace Goofy
         Namespace Mickey
         End Namespace ' Just finished with the namespace, about to make a class
-        <DefaultInstanceProperty(&qtthis propert is a class name&qt)> PuBlic Class Form1      
+        <DefaultInstanceProperty(&qtthis propert is a class name&qt)> PuBlic Class Form1
                 ",
                 "Goofy.Form1");
         }
diff --git a/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs b/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
index 31bd707bd57..2629109eef0 100644
--- a/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
@@ -207,9 +207,9 @@ public void Regress_Mutation_x0dx0aIsASingleLine()
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated 
+        * Also, the source must be regenerated exactly when the tokens are concatenated
         * back together,
         */
         private static void AssertTokenize(string source, string expectedTokenKey)
@@ -220,7 +220,7 @@ private static void AssertTokenize(string source, string expectedTokenKey)
 
         /*
         * Method:  AssertTokenize
-        * 
+        *
         * Tokenize a string ('source') and compare it to the expected set of tokens.
         * Also compare the source that is regenerated by concatenating all of the tokens
         * to 'expectedSource'.
diff --git a/src/Tasks.UnitTests/WinMDExp_Tests.cs b/src/Tasks.UnitTests/WinMDExp_Tests.cs
index 5a86a08b22b..7e7106554af 100644
--- a/src/Tasks.UnitTests/WinMDExp_Tests.cs
+++ b/src/Tasks.UnitTests/WinMDExp_Tests.cs
@@ -16,7 +16,7 @@ public sealed class WinMDExpTests
     {
         /// <summary>
         /// Tests the "References" parameter on the winmdexp task, and confirms that it sets
-        /// the /reference switch on the command-line correctly.  
+        /// the /reference switch on the command-line correctly.
         /// </summary>
         [Fact]
         public void References()
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index d5495b9dfab..633d6ef0435 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -71,7 +71,7 @@ public void Encoding()
 
                 File.Delete(file);
 
-                // Write ANSI .. that won't work! 
+                // Write ANSI .. that won't work!
                 a = new WriteLinesToFile
                 {
                     BuildEngine = new MockEngine(_output),
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index c298b8c75f2..7c9e56fd374 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -43,7 +43,7 @@ public void TestLoadXml()
         }
 
         /// <summary>
-        /// Tests the TaskName property. 
+        /// Tests the TaskName property.
         /// Should get "CL" back for this specific case.
         /// </summary>
         [Fact]
@@ -235,7 +235,7 @@ public void TestBasicNonReversibleBooleanSwitch()
         }
 
         /// <summary>
-        /// Tests a basic non-reversible booleans switch that has a default value set. 
+        /// Tests a basic non-reversible booleans switch that has a default value set.
         /// </summary>
         [Fact]
         public void TestBasicNonReversibleBooleanSwitch_WithDefault()
@@ -286,8 +286,8 @@ public void TestBasicEnumProperty()
         }
 
         /// <summary>
-        /// Tests XamlTaskFactory support for DynamicEnumProperties.  These are primarily of use as a visualization in the property pages; as far as the 
-        /// XamlTaskFactory and XamlDataDrivenToolTask are concerned, they are treated as StringProperties.  
+        /// Tests XamlTaskFactory support for DynamicEnumProperties.  These are primarily of use as a visualization in the property pages; as far as the
+        /// XamlTaskFactory and XamlDataDrivenToolTask are concerned, they are treated as StringProperties.
         /// </summary>
         [Fact]
         public void TestDynamicEnumProperty()
@@ -308,7 +308,7 @@ public void TestDynamicEnumProperty()
         }
 
         /// <summary>
-        /// Tests a simple string property. 
+        /// Tests a simple string property.
         /// </summary>
         [Fact]
         public void TestBasicStringProperty()
@@ -361,7 +361,7 @@ public void TestLoadAndParseFromAbsoluteFilePath()
         }
 
         /// <summary>
-        /// Tests a simple string array property. 
+        /// Tests a simple string array property.
         /// </summary>
         [Fact]
         public void TestBasicStringArrayProperty()
@@ -384,7 +384,7 @@ public void TestBasicStringArrayProperty()
         }
 
         /// <summary>
-        /// Tests a simple string array property. 
+        /// Tests a simple string array property.
         /// </summary>
         [Fact]
         public void TestStringArrayPropertyWithDataSource()
@@ -411,7 +411,7 @@ public void TestStringArrayPropertyWithDataSource()
         }
 
         /// <summary>
-        /// Tests a simple string array property. 
+        /// Tests a simple string array property.
         /// </summary>
         [Fact]
         public void TestStringArrayPropertyWithDataSource_DataSourceIsItem()
@@ -485,7 +485,7 @@ public void TestGenerateCodeToStream()
                 cp.ReferencedAssemblies.Add(Path.Combine(XamlTestHelpers.PathToMSBuildBinaries, "Microsoft.Build.Framework.dll"));
                 cp.ReferencedAssemblies.Add("System.Data.dll");
 
-                // Generate an executable instead of 
+                // Generate an executable instead of
                 // a class library.
                 cp.GenerateExecutable = false;
                 // Set the assembly file name to generate.
@@ -541,7 +541,7 @@ public void TestGenerateToFile()
                 cp.ReferencedAssemblies.Add(Path.Combine(XamlTestHelpers.PathToMSBuildBinaries, "Microsoft.Build.Framework.dll"));
                 cp.ReferencedAssemblies.Add("System.Data.dll");
 
-                // Generate an executable instead of 
+                // Generate an executable instead of
                 // a class library.
                 cp.GenerateExecutable = false;
                 // Set the assembly file name to generate.
diff --git a/src/Tasks.UnitTests/XamlTestHelpers.cs b/src/Tasks.UnitTests/XamlTestHelpers.cs
index 15e4609b432..8ce7aaddc48 100644
--- a/src/Tasks.UnitTests/XamlTestHelpers.cs
+++ b/src/Tasks.UnitTests/XamlTestHelpers.cs
@@ -38,7 +38,7 @@ internal static class XamlTestHelpers
                                               <StringProperty Name=`BasicFileWOSwitch` />
                                               <StringProperty Name=`BasicDirectory` />
                                               <DynamicEnumProperty Name=`BasicDynamicEnum` />
-                                              
+
                                               <!-- More Complex types -->
                                               <BoolProperty Name=`ComplexReversible` Switch=`/Cr:CT` ReverseSwitch=`/Cr:CF` Separator=`:` />
                                               <BoolProperty Name=`ComplexNonreversibleWArgument` Switch=`/Cnrwa`>
@@ -54,7 +54,7 @@ internal static class XamlTestHelpers
                                               <IntProperty Name=`ComplexInteger` Switch=`/Ci` MinValue=`64` MaxValue=`255` />
 
                                               <!-- Dependencies, fallbacks, and so on -->
-                                              <BoolProperty Name=`OtherNonreversible` Switch=`/Onr`> 
+                                              <BoolProperty Name=`OtherNonreversible` Switch=`/Onr`>
                                                 <Argument IsRequired=`true` Property=`ComplexFileNoDefault` />
                                               </BoolProperty>
                                               <StringProperty Name=`ComplexDirectory` />
@@ -89,7 +89,7 @@ internal static class XamlTestHelpers
         private static string s_pathToMSBuildBinaries = null;
 
         /// <summary>
-        /// Returns the path to the MSBuild binaries 
+        /// Returns the path to the MSBuild binaries
         /// </summary>
         public static string PathToMSBuildBinaries
         {
@@ -147,7 +147,7 @@ public static Assembly SetupGeneratedCode(string xml)
                 cp.ReferencedAssemblies.Add(Path.Combine(PathToMSBuildBinaries, "Microsoft.Build.Utilities.Core.dll"));
                 cp.ReferencedAssemblies.Add(Path.Combine(PathToMSBuildBinaries, "Microsoft.Build.Tasks.Core.dll"));
 
-                // Generate an executable instead of 
+                // Generate an executable instead of
                 // a class library.
                 cp.GenerateExecutable = false;
                 // Set the assembly file name to generate.
diff --git a/src/Tasks.UnitTests/XmlPeek_Tests.cs b/src/Tasks.UnitTests/XmlPeek_Tests.cs
index 0367f6c78bc..d7435d0a714 100644
--- a/src/Tasks.UnitTests/XmlPeek_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPeek_Tests.cs
@@ -3,8 +3,13 @@
 
 using System;
 using System.IO;
+
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+
+using Shouldly;
+
 using Xunit;
 
 #nullable disable
@@ -316,6 +321,17 @@ public void PeekWithoutUsingTask()
             logger.AssertLogDoesntContain("MSB4036");
         }
 
+        [Fact]
+        public void PeekWithNoParameters()
+        {
+            MockLogger log = new();
+            Project project = ObjectModelHelpers.CreateInMemoryProject(@"<Project><Target Name=""Test""><XmlPeek /></Target></Project>", log);
+
+            project.Build().ShouldBeFalse();
+            log.AssertLogContains("MSB4044");
+            log.AssertLogContains("\"Query\"");
+        }
+
         private void Prepare(string xmlFile, out string xmlInputPath)
         {
             string dir = Path.Combine(Path.GetTempPath(), DateTime.Now.Ticks.ToString());
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index d78bbcad622..f0978f95c48 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -6,9 +6,13 @@
 using System.IO;
 using System.Linq;
 using System.Xml;
+
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+
 using Shouldly;
+
 using Xunit;
 
 #nullable disable
@@ -135,37 +139,55 @@ public void PokeAttributeWithCondition()
         }
 
         [Fact]
-        public void PokeMissingParams()
+        public void PokeWithNoParameters()
         {
-            MockEngine engine = new MockEngine(true);
-            string xmlInputPath;
-            Prepare(_xmlFileNoNs, out xmlInputPath);
+            MockLogger log = new();
+            Project project = ObjectModelHelpers.CreateInMemoryProject(@"<Project><Target Name=""Test""><XmlPoke /></Target></Project>", log);
 
-            for (int i = 0; i < 4; i++)
-            {
-                XmlPoke p = new XmlPoke();
-                p.BuildEngine = engine;
+            project.Build().ShouldBeFalse();
+            log.AssertLogContains("MSB4044");
+        }
 
-                if ((i & 1) == 1)
-                {
-                    p.XmlInputPath = new TaskItem(xmlInputPath);
-                }
+        [Fact]
+        public void PokeWithMissingRequiredQuery()
+        {
+            const string projectContent = @"<Project><Target Name=""Test""><XmlPoke XmlInputPath=""nonesuch"" /></Target></Project>";
 
-                if ((i & 2) == 2)
-                {
-                    p.Query = "//variable/@Name";
-                }
+            MockLogger log = new();
+            Project project = ObjectModelHelpers.CreateInMemoryProject(projectContent, log);
 
-                // "Expecting argumentnullexception for the first 3 tests"
-                if (i < 3)
-                {
-                    Should.Throw<ArgumentNullException>(() => p.Execute());
-                }
-                else
-                {
-                    Should.NotThrow(() => p.Execute());
-                }
-            }
+            project.Build().ShouldBeFalse();
+            log.AssertLogContains("MSB4044");
+            log.AssertLogContains("\"Query\"");
+        }
+
+        [Fact]
+        public void PokeWithMissingRequiredXmlInputPath()
+        {
+            const string projectContent = @"<Project><Target Name=""Test""><XmlPoke Query=""nonesuch"" /></Target></Project>";
+
+            MockLogger log = new();
+            Project project = ObjectModelHelpers.CreateInMemoryProject(projectContent, log);
+
+            project.Build().ShouldBeFalse();
+            log.AssertLogContains("MSB4044");
+            log.AssertLogContains("\"XmlInputPath\"");
+        }
+
+        [Fact]
+        public void PokeWithRequiredParameters()
+        {
+            MockEngine engine = new(true);
+            Prepare(_xmlFileNoNs, out string xmlInputPath);
+
+            XmlPoke task = new()
+            {
+                BuildEngine = engine,
+                XmlInputPath = new TaskItem(xmlInputPath),
+                Query = "//variable/@Name",
+            };
+
+            task.Execute().ShouldBeTrue();
         }
 
         [Fact]
diff --git a/src/Tasks.UnitTests/ZipDirectory_Tests.cs b/src/Tasks.UnitTests/ZipDirectory_Tests.cs
index 88d9d50224a..33fdbf57661 100644
--- a/src/Tasks.UnitTests/ZipDirectory_Tests.cs
+++ b/src/Tasks.UnitTests/ZipDirectory_Tests.cs
@@ -38,10 +38,10 @@ public void CanZipDirectory()
                     SourceDirectory = new TaskItem(sourceFolder.Path)
                 };
 
-                zipDirectory.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                zipDirectory.Execute().ShouldBeTrue(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain(sourceFolder.Path, () => _mockEngine.Log);
-                _mockEngine.Log.ShouldContain(zipFilePath, () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(sourceFolder.Path, customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(zipFilePath, customMessage: _mockEngine.Log);
 
                 using (FileStream stream = new FileStream(zipFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                 using (ZipArchive archive = new ZipArchive(stream, ZipArchiveMode.Read))
@@ -80,10 +80,10 @@ public void CanOvewriteExistingFile()
                     SourceDirectory = new TaskItem(sourceFolder.Path)
                 };
 
-                zipDirectory.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                zipDirectory.Execute().ShouldBeTrue(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain(sourceFolder.Path, () => _mockEngine.Log);
-                _mockEngine.Log.ShouldContain(file.Path, () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(sourceFolder.Path, customMessage: _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(file.Path, customMessage: _mockEngine.Log);
 
                 using (FileStream stream = new FileStream(file.Path, FileMode.Open, FileAccess.Read, FileShare.Read))
                 using (ZipArchive archive = new ZipArchive(stream, ZipArchiveMode.Read))
@@ -118,9 +118,9 @@ public void LogsErrorIfDestinationExists()
                     SourceDirectory = new TaskItem(folder.Path)
                 };
 
-                zipDirectory.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                zipDirectory.Execute().ShouldBeFalse(_mockEngine.Log);
 
-                _mockEngine.Log.ShouldContain("MSB3942", () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain("MSB3942", customMessage: _mockEngine.Log);
             }
         }
 
@@ -133,9 +133,9 @@ public void LogsErrorIfDirectoryDoesNotExist()
                 SourceDirectory = new TaskItem(Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N")))
             };
 
-            zipDirectory.Execute().ShouldBeFalse(() => _mockEngine.Log);
+            zipDirectory.Execute().ShouldBeFalse(_mockEngine.Log);
 
-            _mockEngine.Log.ShouldContain("MSB3941", () => _mockEngine.Log);
+            _mockEngine.Log.ShouldContain("MSB3941", customMessage: _mockEngine.Log);
         }
     }
 }
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 7d9ad8fa1a8..0b587df5b74 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -1,21 +1,26 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// This class defines the "AL" XMake task, which enables using al.exe to link
     /// modules and resource files into assemblies.
     /// </summary>
-    public class AL : ToolTaskExtension
+    public class AL : ToolTaskExtension, IALTaskContract
     {
         #region Properties
         /*
@@ -387,6 +392,130 @@ public override bool Execute()
             return base.Execute();
         }
 
+        #endregion
+    }
+
+#else
+
+    /// <summary>
+    /// Stub AL task for .NET Core.
+    /// </summary>
+    public sealed class AL : TaskRequiresFramework, IALTaskContract
+    {
+        public AL()
+            : base(nameof(AL))
+        {
+        }
+
+        #region Properties
+
+        public string AlgorithmId { get; set; }
+
+        public string BaseAddress { get; set; }
+
+        public string CompanyName { get; set; }
+
+        public string Configuration { get; set; }
+
+        public string Copyright { get; set; }
+
+        public string Culture { get; set; }
+
+        public bool DelaySign { get; set; }
+
+        public string Description { get; set; }
+
+        public string EvidenceFile { get; set; }
+
+        public string FileVersion { get; set; }
+
+        public string Flags { get; set; }
+
+        public bool GenerateFullPaths { get; set; }
+
+        public string KeyFile { get; set; }
+
+        public string KeyContainer { get; set; }
+
+        public string MainEntryPoint { get; set; }
+
+        [Output]
+        public ITaskItem OutputAssembly { get; set; }
+
+        public string Platform { get; set; }
+
+        public bool Prefer32Bit { get; set; }
+
+        public string ProductName { get; set; }
+
+        public string ProductVersion { get; set; }
+
+        public string[] ResponseFiles { get; set; }
+
+        public string TargetType { get; set; }
+
+        public string TemplateFile { get; set; }
+
+        public string Title { get; set; }
+
+        public string Trademark { get; set; }
+
+        public string Version { get; set; }
+
+        public string Win32Icon { get; set; }
+
+        public string Win32Resource { get; set; }
+
+        public ITaskItem[] SourceModules { get; set; }
+
+        public ITaskItem[] EmbedResources { get; set; }
+
+        public ITaskItem[] LinkResources { get; set; }
+
+        public string SdkToolsPath { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IALTaskContract
+    {
+        #region Properties
+
+        string AlgorithmId { get; set; }
+        string BaseAddress { get; set; }
+        string CompanyName { get; set; }
+        string Configuration { get; set; }
+        string Copyright { get; set; }
+        string Culture { get; set; }
+        bool DelaySign { get; set; }
+        string Description { get; set; }
+        string EvidenceFile { get; set; }
+        string FileVersion { get; set; }
+        string Flags { get; set; }
+        bool GenerateFullPaths { get; set; }
+        string KeyFile { get; set; }
+        string KeyContainer { get; set; }
+        string MainEntryPoint { get; set; }
+        ITaskItem OutputAssembly { get; set; }
+        string Platform { get; set; }
+        bool Prefer32Bit { get; set; }
+        string ProductName { get; set; }
+        string ProductVersion { get; set; }
+        string[] ResponseFiles { get; set; }
+        string TargetType { get; set; }
+        string TemplateFile { get; set; }
+        string Title { get; set; }
+        string Trademark { get; set; }
+        string Version { get; set; }
+        string Win32Icon { get; set; }
+        string Win32Resource { get; set; }
+        ITaskItem[] SourceModules { get; set; }
+        ITaskItem[] EmbedResources { get; set; }
+        ITaskItem[] LinkResources { get; set; }
+        string SdkToolsPath { get; set; }
+
         #endregion
     }
 }
diff --git a/src/Tasks/AspNetCompiler.cs b/src/Tasks/AspNetCompiler.cs
index 1e1d3b4b2be..8beb3fc3a9f 100644
--- a/src/Tasks/AspNetCompiler.cs
+++ b/src/Tasks/AspNetCompiler.cs
@@ -1,16 +1,20 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using Microsoft.Build.Utilities;
+#endif
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// The AspNetCompiler task, which is a wrapper around aspnet_compiler.exe
     /// </summary>
-    public class AspNetCompiler : ToolTaskExtension
+    public class AspNetCompiler : ToolTaskExtension, IAspNetCompilerTaskContract
     {
         /*
             C:\WINDOWS\Microsoft.NET\Framework\v2.0.x86dbg>aspnet_compiler /?
@@ -48,7 +52,7 @@ is always enabled when targetDir is specified.
             -keycontainer Specifies a strong name key container.
             -aptca        If specified, the strong-name assembly will allow partially
                           trusted callers.
-            -delaysign    If specified, the assemblly is not fully signed when created. 
+            -delaysign    If specified, the assemblly is not fully signed when created.
             -fixednames   If specified, the compiled assemblies will be given fixed names.
             -nologo       Suppress compiler copyright message.
 
@@ -75,7 +79,7 @@ The following command compiles the application /MyApp in-place. The effect is
         public bool AllowPartiallyTrustedCallers { get; set; }
 
         /// <summary>
-        /// If specified, the assemblly is not fully signed when created. 
+        /// If specified, the assemblly is not fully signed when created.
         /// </summary>
         public bool DelaySign { get; set; }
 
@@ -103,7 +107,7 @@ public string KeyFile
         }
 
         /// <summary>
-        /// The full IIS metabase path of the application. This switch 
+        /// The full IIS metabase path of the application. This switch
         /// cannot be combined with the virtualPath or PhysicalDir option.
         /// </summary>
         public string MetabasePath
@@ -124,7 +128,7 @@ public string PhysicalPath
 
         /// <summary>
         /// The physical path to which the application is compiled. If not
-        /// specified, the application is precompiled in-place. 
+        /// specified, the application is precompiled in-place.
         /// </summary>
         public string TargetPath
         {
@@ -169,8 +173,8 @@ public string VirtualPath
         public bool Clean { get; set; }
 
         /// <summary>
-        /// The TargetFrameworkMoniker indicating which .NET Framework version of 
-        /// aspnet_compiler.exe should be used.  Only accepts .NET Framework monikers. 
+        /// The TargetFrameworkMoniker indicating which .NET Framework version of
+        /// aspnet_compiler.exe should be used.  Only accepts .NET Framework monikers.
         /// </summary>
         public string TargetFrameworkMoniker
         {
@@ -338,4 +342,70 @@ protected override bool ValidateParameters()
             return true;
         }
     }
+
+#else
+
+    public sealed class AspNetCompiler : TaskRequiresFramework, IAspNetCompilerTaskContract
+    {
+        public AspNetCompiler()
+            : base(nameof(AspNetCompiler))
+        {
+        }
+
+        #region Properties
+
+        public bool AllowPartiallyTrustedCallers { get; set; }
+
+        public bool DelaySign { get; set; }
+
+        public bool FixedNames { get; set; }
+
+        public string KeyContainer { get; set; }
+
+        public string KeyFile { get; set; }
+
+        public string MetabasePath { get; set; }
+
+        public string PhysicalPath { get; set; }
+
+        public string TargetPath { get; set; }
+
+        public string VirtualPath { get; set; }
+
+        public bool Updateable { get; set; }
+
+        public bool Force { get; set; }
+
+        public bool Debug { get; set; }
+
+        public bool Clean { get; set; }
+
+        public string TargetFrameworkMoniker { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IAspNetCompilerTaskContract
+    {
+        #region Properties
+
+        bool AllowPartiallyTrustedCallers { get; set; }
+        bool DelaySign { get; set; }
+        bool FixedNames { get; set; }
+        string KeyContainer { get; set; }
+        string KeyFile { get; set; }
+        string MetabasePath { get; set; }
+        string PhysicalPath { get; set; }
+        string TargetPath { get; set; }
+        string VirtualPath { get; set; }
+        bool Updateable { get; set; }
+        bool Force { get; set; }
+        bool Debug { get; set; }
+        bool Clean { get; set; }
+        string TargetFrameworkMoniker { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/AssemblyDependency/AssemblyAttributes.cs b/src/Tasks/AssemblyDependency/AssemblyAttributes.cs
new file mode 100644
index 00000000000..4e6fd111a27
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/AssemblyAttributes.cs
@@ -0,0 +1,48 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Collection of assembly attributes.
+    /// </summary>
+    internal sealed class AssemblyAttributes
+    {
+        public string AssemblyFullPath { get; set; } = string.Empty;
+
+        public string AssemblyName { get; set; } = string.Empty;
+
+        public string DefaultAlias { get; set; } = string.Empty;
+
+        public string Description { get; set; } = string.Empty;
+
+        public string Culture { get; set; } = string.Empty;
+
+        public string RuntimeVersion { get; set; } = string.Empty;
+
+        public ushort MajorVersion { get; set; }
+
+        public ushort MinorVersion { get; set; }
+
+        public ushort BuildNumber { get; set; }
+
+        public ushort RevisionNumber { get; set; }
+
+        // it is a byte[] converted to string
+        public string PublicHexKey { get; set; } = string.Empty;
+
+        public bool IsAssembly { get; set; }
+
+        public uint PeKind { get; set; }
+
+        public bool IsImportedFromTypeLib { get; set; }
+
+        public string TargetFrameworkMoniker { get; set; } = string.Empty;
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index 51df4d81cad..49ba2302654 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -214,7 +214,7 @@ public override bool Resolve(
                         {
                             string candidatePath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, assemblyFolder.DirectoryPath, assembliesConsideredAndRejected);
 
-                            // We have a full path returned 
+                            // We have a full path returned
                             if (candidatePath != null)
                             {
                                 if (resolvedPath == null)
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index 2268765cfbf..4208cf4c72e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -182,7 +182,7 @@ public override bool Resolve(
                         {
                             string candidatePath = ResolveFromDirectory(assemblyName, isPrimaryProjectReference, wantSpecificVersion, executableExtensions, assemblyFolder.DirectoryPath, assembliesConsideredAndRejected);
 
-                            // We have a full path returned 
+                            // We have a full path returned
                             if (candidatePath != null)
                             {
                                 if (resolvedPath == null)
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 2a247374d79..91785df5c86 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -10,12 +10,14 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 #endif
-using System.Runtime.Versioning;
 using System.Reflection;
+using System.Runtime.Versioning;
+using System.Security.Cryptography;
+using System.Security.Cryptography.X509Certificates;
 using System.Text;
-
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using static Microsoft.Build.Shared.FileSystem.WindowsNative;
 #if FEATURE_ASSEMBLYLOADCONTEXT || MONO
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
@@ -149,7 +151,7 @@ public AssemblyNameExtension[] Dependencies
         }
 
         /// <summary>
-        /// Get the scatter files from the assembly metadata. 
+        /// Get the scatter files from the assembly metadata.
         /// </summary>
         public string[] Files
         {
@@ -193,7 +195,7 @@ public FrameworkName FrameworkNameAttribute
         }
 
         /// <summary>
-        /// Given an assembly name, crack it open and retrieve the list of dependent 
+        /// Given an assembly name, crack it open and retrieve the list of dependent
         /// assemblies and  the list of scatter files.
         /// </summary>
         /// <param name="path">Path to the assembly.</param>
@@ -267,6 +269,112 @@ internal static bool IsWinMDFile(
             return false;
         }
 
+#if !FEATURE_ASSEMBLYLOADCONTEXT
+        /// <summary>
+        /// Collects the metadata and attributes for specified assembly.
+        /// The requested properties are used by legacy project system.
+        /// </summary>
+        internal AssemblyAttributes GetAssemblyMetadata()
+        {
+            IntPtr asmMetaPtr = IntPtr.Zero;
+            ASSEMBLYMETADATA asmMeta = new();
+            try
+            {
+                IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;
+                _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);
+
+                // get the assembly, if there is no assembly, it is a module reference
+                if (assemblyScope == 0)
+                {
+                    return null;
+                }
+
+                AssemblyAttributes assemblyAttributes = new()
+                {
+                    AssemblyFullPath = _sourceFile,
+                    IsAssembly = true,
+                };
+
+                // will be populated with the assembly name
+                char[] defaultCharArray = new char[GENMAN_STRING_BUF_SIZE];
+                asmMetaPtr = AllocAsmMeta();
+                _assemblyImport.GetAssemblyProps(
+                    assemblyScope,
+                    out IntPtr publicKeyPtr,
+                    out uint publicKeyLength,
+                    out uint hashAlgorithmId,
+                    defaultCharArray,
+
+                    // the default buffer size is taken from csproj call
+                    GENMAN_STRING_BUF_SIZE,
+                    out uint nameLength,
+                    asmMetaPtr,
+                    out uint flags);
+
+                assemblyAttributes.AssemblyName = new string(defaultCharArray, 0, (int)nameLength - 1);
+                assemblyAttributes.DefaultAlias = assemblyAttributes.AssemblyName;
+
+                asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
+                assemblyAttributes.MajorVersion = asmMeta.usMajorVersion;
+                assemblyAttributes.MinorVersion = asmMeta.usMinorVersion;
+                assemblyAttributes.RevisionNumber = asmMeta.usRevisionNumber;
+                assemblyAttributes.BuildNumber = asmMeta.usBuildNumber;
+                assemblyAttributes.Culture = Marshal.PtrToStringUni(asmMeta.rpLocale);
+
+                byte[] publicKey = new byte[publicKeyLength];
+                Marshal.Copy(publicKeyPtr, publicKey, 0, (int)publicKeyLength);
+                assemblyAttributes.PublicHexKey = BitConverter.ToString(publicKey).Replace("-", string.Empty);
+
+                if (import2 != null)
+                {
+                    assemblyAttributes.Description = GetStringCustomAttribute(import2, assemblyScope, "System.Reflection.AssemblyDescriptionAttribute");
+                    assemblyAttributes.TargetFrameworkMoniker = GetStringCustomAttribute(import2, assemblyScope, "System.Runtime.Versioning.TargetFrameworkAttribute");
+                    var guid = GetStringCustomAttribute(import2, assemblyScope, "System.Runtime.InteropServices.GuidAttribute");
+                    if (!string.IsNullOrEmpty(guid))
+                    {
+                        string importedFromTypeLibString = GetStringCustomAttribute(import2, assemblyScope, "System.Runtime.InteropServices.ImportedFromTypeLibAttribute");
+                        if (!string.IsNullOrEmpty(importedFromTypeLibString))
+                        {
+                            assemblyAttributes.IsImportedFromTypeLib = true;
+                        }
+                        else
+                        {
+                            string primaryInteropAssemblyString = GetStringCustomAttribute(import2, assemblyScope, "System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute");
+                            assemblyAttributes.IsImportedFromTypeLib = !string.IsNullOrEmpty(primaryInteropAssemblyString);
+                        }
+                    }
+                }
+
+                assemblyAttributes.RuntimeVersion = GetRuntimeVersion(_sourceFile);
+
+                import2.GetPEKind(out uint peKind, out _);
+                assemblyAttributes.PeKind = peKind;
+
+                return assemblyAttributes;
+            }
+            finally
+            {
+                FreeAsmMeta(asmMetaPtr, ref asmMeta);
+            }
+        }
+
+        private string GetStringCustomAttribute(IMetaDataImport2 import2, uint assemblyScope, string attributeName)
+        {
+            int hr = import2.GetCustomAttributeByName(assemblyScope, attributeName, out IntPtr data, out uint valueLen);
+
+            if (hr == NativeMethodsShared.S_OK)
+            {
+                // if an custom attribute exists, parse the contents of the blob
+                if (NativeMethods.TryReadMetadataString(_sourceFile, data, valueLen, out string propertyValue))
+                {
+                    return propertyValue;
+                }
+            }
+
+            return string.Empty;
+        }
+#endif
+
         /// <summary>
         /// Get the framework name from the assembly.
         /// </summary>
@@ -315,21 +423,12 @@ private FrameworkName GetFrameworkName()
             try
             {
                 var import2 = (IMetaDataImport2)_assemblyImport;
-
                 _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);
-                int hr = import2.GetCustomAttributeByName(assemblyScope, s_targetFrameworkAttribute, out IntPtr data, out uint valueLen);
 
-                // get the AssemblyTitle
-                if (hr == NativeMethodsShared.S_OK)
+                string frameworkNameAttribute = GetStringCustomAttribute(import2, assemblyScope, s_targetFrameworkAttribute);
+                if (!string.IsNullOrEmpty(frameworkNameAttribute))
                 {
-                    // if an AssemblyTitle exists, parse the contents of the blob
-                    if (NativeMethods.TryReadMetadataString(_sourceFile, data, valueLen, out string frameworkNameAttribute))
-                    {
-                        if (!String.IsNullOrEmpty(frameworkNameAttribute))
-                        {
-                            frameworkAttribute = new FrameworkName(frameworkNameAttribute);
-                        }
-                    }
+                    frameworkAttribute = new FrameworkName(frameworkNameAttribute);
                 }
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
@@ -544,7 +643,7 @@ private static List<string> GetFixedStringArguments(MetadataReader reader, Custo
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
-        /// Release interface pointers on Dispose(). 
+        /// Release interface pointers on Dispose().
         /// </summary>
         protected override void DisposeUnmanagedResources()
         {
@@ -583,7 +682,7 @@ internal static string GetRuntimeVersion(string path)
 
                 unsafe
                 {
-                    // Allocate an initial buffer 
+                    // Allocate an initial buffer
                     char* runtimeVersion = stackalloc char[bufferLength];
 
                     // Run GetFileVersion, this should succeed using the initial buffer.
@@ -782,7 +881,7 @@ private static IntPtr AllocAsmMeta()
         }
 
         /// <summary>
-        /// Construct assembly name. 
+        /// Construct assembly name.
         /// </summary>
         /// <param name="asmMetaPtr">Assembly metadata structure</param>
         /// <param name="asmNameBuf">Buffer containing the name</param>
@@ -844,8 +943,22 @@ private static void FreeAsmMeta(IntPtr asmMetaPtr)
             {
                 // Marshal the assembly metadata back to a managed type.
                 var asmMeta = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
+                FreeAsmMeta(asmMetaPtr, ref asmMeta);
+            }
+        }
+
+        /// <summary>
+        /// Free the assembly metadata structure.
+        /// </summary>
+        /// <param name="asmMetaPtr">The pointer.</param>
+        /// <param name="asmMeta">Marshaled assembly metadata to the managed type.</param>
+        private static void FreeAsmMeta(IntPtr asmMetaPtr, ref ASSEMBLYMETADATA asmMeta)
+        {
+            if (asmMetaPtr != IntPtr.Zero)
+            {
                 // Free unmanaged memory.
                 Marshal.FreeCoTaskMem(asmMeta.rpLocale);
+                asmMeta.rpLocale = IntPtr.Zero;
                 Marshal.DestroyStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
                 Marshal.FreeCoTaskMem(asmMetaPtr);
             }
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index 0d6ba23d997..74488931e7a 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Tasks
     ///
     ///     [path-to-frameworks]\System.Xml.dll
     ///
-    /// 
+    ///
     /// </summary>
     internal static class AssemblyResolution
     {
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs b/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
index 08b6e6f6df5..0ba5dff6661 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolutionConstants.cs
@@ -11,27 +11,27 @@ namespace Microsoft.Build.Tasks
     internal static class AssemblyResolutionConstants
     {
         /// <summary>
-        /// Special hintpath indicator. May be passed in where SearchPaths are taken. 
+        /// Special hintpath indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string hintPathSentinel = "{hintpathfromitem}";
 
         /// <summary>
-        /// Special AssemblyFolders indicator. May be passed in where SearchPaths are taken. 
+        /// Special AssemblyFolders indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string assemblyFoldersSentinel = "{assemblyfolders}";
 
         /// <summary>
-        /// Special CandidateAssemblyFiles indicator. May be passed in where SearchPaths are taken. 
+        /// Special CandidateAssemblyFiles indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string candidateAssemblyFilesSentinel = "{candidateassemblyfiles}";
 
         /// <summary>
-        /// Special GAC indicator. May be passed in where SearchPaths are taken. 
+        /// Special GAC indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string gacSentinel = "{gac}";
 
         /// <summary>
-        /// Special Framework directory indicator. May be passed in where SearchPaths are taken. 
+        /// Special Framework directory indicator. May be passed in where SearchPaths are taken.
         /// </summary>
         public const string frameworkPathSentinel = "{targetframeworkdirectory}";
 
@@ -42,12 +42,12 @@ internal static class AssemblyResolutionConstants
         public const string rawFileNameSentinel = "{rawfilename}";
 
         /// <summary>
-        /// Special AssemblyFoldersEx indicator.  May be passed in where SearchPaths are taken. 
+        /// Special AssemblyFoldersEx indicator.  May be passed in where SearchPaths are taken.
         /// </summary>
         public const string assemblyFoldersExSentinel = "{registry:";
 
         /// <summary>
-        /// Special AssemblyFoldersFromConfig indicator.  May be passed in where SearchPaths are taken. 
+        /// Special AssemblyFoldersFromConfig indicator.  May be passed in where SearchPaths are taken.
         /// </summary>
         public const string assemblyFoldersFromConfigSentinel = "{assemblyfoldersfromconfig:";
     }
diff --git a/src/Tasks/AssemblyDependency/ConflictLossReason.cs b/src/Tasks/AssemblyDependency/ConflictLossReason.cs
index b54e87f56de..e47cdf801c4 100644
--- a/src/Tasks/AssemblyDependency/ConflictLossReason.cs
+++ b/src/Tasks/AssemblyDependency/ConflictLossReason.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// If this reference lost in a conflict with another reference, this reason explains 
+    /// If this reference lost in a conflict with another reference, this reason explains
     /// why.
     /// </summary>
     internal enum ConflictLossReason
@@ -27,8 +27,8 @@ internal enum ConflictLossReason
         InsolubleConflict,
 
         /// <summary>
-        /// In this case, this reference was a dependency and the other reference was 
-        /// primary (specified in the project file). 
+        /// In this case, this reference was a dependency and the other reference was
+        /// primary (specified in the project file).
         /// </summary>
         WasNotPrimary,
 
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index 1a4670806eb..c5d26772cfe 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -110,7 +110,7 @@ internal static bool IsCopyLocal(CopyLocalState state)
                     //
                     //   ErrorUtilities.VerifyThrow(false, "Unexpected CopyLocal flag.");
                     //
-                    // but this popped up constantly when debugging because its call 
+                    // but this popped up constantly when debugging because its call
                     // directly by a property accessor in Reference.
             }
         }
diff --git a/src/Tasks/AssemblyDependency/DisposableBase.cs b/src/Tasks/AssemblyDependency/DisposableBase.cs
index 264ebe75d59..6568d1122aa 100644
--- a/src/Tasks/AssemblyDependency/DisposableBase.cs
+++ b/src/Tasks/AssemblyDependency/DisposableBase.cs
@@ -21,7 +21,7 @@ protected DisposableBase()
         }
 
         // Use C# destructor syntax for finalization code.
-        // This destructor will run only if the Dispose method 
+        // This destructor will run only if the Dispose method
         // does not get called.
         // It gives your base class the opportunity to finalize.
         // Do not provide destructors in types derived from this class.
@@ -40,7 +40,7 @@ public void Dispose()
         {
             // This object will be cleaned up by the Dispose method.
             // Therefore, you should call GC.SupressFinalize to
-            // take this object off the finalization queue 
+            // take this object off the finalization queue
             // and prevent finalization code for this object
             // from executing a second time.
             Dispose(true);
@@ -51,15 +51,15 @@ public void Dispose()
         // If disposing equals true, the method has been called directly
         // or indirectly by a user's code. Managed and unmanaged resources
         // can be disposed.
-        // If disposing equals false, the method has been called by the 
-        // runtime from inside the finalizer and you should not reference 
+        // If disposing equals false, the method has been called by the
+        // runtime from inside the finalizer and you should not reference
         // other objects. Only unmanaged resources can be disposed.
         private void Dispose(bool disposing)
         {
             // Check to see if Dispose has already been called.
             if (!_disposed)
             {
-                // If disposing equals true, dispose all managed 
+                // If disposing equals true, dispose all managed
                 // and unmanaged resources.
                 if (disposing)
                 {
@@ -67,9 +67,9 @@ private void Dispose(bool disposing)
                     DisposeManagedResources();
                 }
 
-                // Call the appropriate methods to clean up 
+                // Call the appropriate methods to clean up
                 // unmanaged resources here.
-                // If disposing is false, 
+                // If disposing is false,
                 // only the following code is executed.
                 DisposeUnmanagedResources();
             }
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 19aab4b83e6..c108bb142f0 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -139,13 +139,6 @@ public override bool Execute()
                     doc.Save(stream);
                 }
             }
-            else if (outputExists)
-            {
-                // if the file exists and the content is up to date, then touch the output file.
-                var now = DateTime.Now;
-                File.SetLastAccessTime(OutputAppConfigFile.ItemSpec, now);
-                File.SetLastWriteTime(OutputAppConfigFile.ItemSpec, now);
-            }
 
             return !Log.HasLoggedErrors;
         }
@@ -171,7 +164,7 @@ private static bool IsMatch(AssemblyName suggestedRedirect, string name, string
             var cultureString = suggestedRedirect.CultureName;
             if (String.IsNullOrEmpty(cultureString))
             {
-                // We use "neutral" for "Invariant Language (Invariant Country)" in assembly names.
+                // We use "neutral" for "Invariant Language (Invariant Country/Region)" in assembly names.
                 cultureString = "neutral";
             }
 
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index 3ac6302c964..330b6b50d49 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -138,7 +138,7 @@ private static SortedDictionary<Version, SortedDictionary<AssemblyNameExtension,
                         // Get the runtime version from the found assembly.
                         string runtimeVersionRaw = getRuntimeVersion(assemblyPath);
 
-                        // Convert the runtime string to a version so we can properly compare them as per version object comparison rules. 
+                        // Convert the runtime string to a version so we can properly compare them as per version object comparison rules.
                         // We will accept version which are less than or equal to the targeted runtime.
                         Version runtimeVersion = VersionUtilities.ConvertToVersion(runtimeVersionRaw);
 
@@ -212,7 +212,7 @@ internal static string RetrievePathFromFusionName(string strongName)
         }
 
         /// <summary>
-        /// If we know we have a full fusion name we can skip enumerating the gac and just query for the path. This will 
+        /// If we know we have a full fusion name we can skip enumerating the gac and just query for the path. This will
         /// not check the runtime version of the assembly.
         /// </summary>
         private static string CheckForFullFusionNameInGac(AssemblyNameExtension assemblyName, string targetProcessorArchitecture, GetPathFromFusionName getPathFromFusionName)
diff --git a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
index 0ab3a0a47f3..d9803997df2 100644
--- a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
+++ b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
@@ -66,7 +66,7 @@ internal void GetInfo(
                 return;
             }
 
-            // Dont allow downgrading of reference version due to redist unification because this is automatic rather than something like an appconfig which 
+            // Dont allow downgrading of reference version due to redist unification because this is automatic rather than something like an appconfig which
             // has to be manually set. However if the major version is 255 then we do want to unify down the version number.
             if (assemblyName.Version <= highestVersionFromRedistList.AssemblyNameExtension.Version || assemblyName.Version.Major == 255)
             {
@@ -94,7 +94,7 @@ internal AssemblyNameExtension RemapAssemblyExtension(AssemblyNameExtension asse
         /// <returns>Key value pair, K: Assembly entry of highest value in the redist list. V: AssemblyNameExtension with the version information or null if the name could not be found</returns>
         internal AssemblyEntry FindHighestVersionInRedistList(AssemblyNameExtension assemblyName)
         {
-            // The assembly we are looking for is not listed in a redist list which contains framework assemblies. We do not want to find 
+            // The assembly we are looking for is not listed in a redist list which contains framework assemblies. We do not want to find
             // find non framework assembly entries.
             if (!FrameworkAssemblyEntryInRedist(assemblyName))
             {
diff --git a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
index 55287a96840..be987ee1335 100644
--- a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
+++ b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
@@ -9,7 +9,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// There reference is not a well-formed fusion name *and* its not a file 
+    /// There reference is not a well-formed fusion name *and* its not a file
     /// that exists on disk.
     /// </summary>
     [Serializable]
diff --git a/src/Tasks/AssemblyDependency/NoMatchReason.cs b/src/Tasks/AssemblyDependency/NoMatchReason.cs
index 3ac36b9b12e..7041fba1223 100644
--- a/src/Tasks/AssemblyDependency/NoMatchReason.cs
+++ b/src/Tasks/AssemblyDependency/NoMatchReason.cs
@@ -26,7 +26,7 @@ internal enum NoMatchReason
         FusionNamesDidNotMatch,
 
         /// <summary>
-        /// The file was found, but it didn't have a fusion name. 
+        /// The file was found, but it didn't have a fusion name.
         /// </summary>
         TargetHadNoFusionName,
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index d6636913a1f..e023707d985 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -318,7 +318,7 @@ internal ReferenceTable(
             _ignoreFrameworkAttributeVersionMismatch = ignoreFrameworkAttributeVersionMismatch;
             _assemblyMetadataCache = assemblyMetadataCache;
 
-            // Set condition for when to check assembly version against the target framework version 
+            // Set condition for when to check assembly version against the target framework version
             _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? ReferenceTable.s_targetFrameworkVersion_40) <= ReferenceTable.s_targetFrameworkVersion_40);
 
             // Convert the list of installed SDK's to a dictionary for faster lookup
@@ -577,7 +577,7 @@ private Exception SetPrimaryAssemblyReferenceItem(
             reference.MakePrimaryAssemblyReference(referenceAssemblyName, wantSpecificVersion, executableExtension);
 
             // Escape simple names.
-            // 1) If the itemSpec for the task is already a simple name 
+            // 1) If the itemSpec for the task is already a simple name
             // 2) We have found the metadata and it is specifically set to false
             if (assemblyName != null && (isSimpleName || (foundSpecificVersionMetadata && !wantSpecificVersion)))
             {
@@ -907,7 +907,7 @@ private void FindRelatedFiles(
         {
             string baseName = reference.FullPathWithoutExtension;
 
-            // Look for companion files like pdbs and xmls that ride along with 
+            // Look for companion files like pdbs and xmls that ride along with
             // assemblies.
             foreach (string companionExtension in _relatedFileExtensions)
             {
@@ -976,7 +976,7 @@ private void FindSatellites(
                         string satelliteAssembly = Path.Combine(subDirectory, sateliteFilename);
                         if (_fileExists(satelliteAssembly))
                         {
-                            // This is valid satellite assembly. 
+                            // This is valid satellite assembly.
                             reference.AddSatelliteFile(Path.Combine(cultureName, sateliteFilename));
                         }
                     }
@@ -999,7 +999,7 @@ private void FindSerializationAssemblies(
             string serializationAssemblyPath = Path.Combine(reference.DirectoryName, serializationAssemblyFilename);
             if (_fileExists(serializationAssemblyPath))
             {
-                // This is valid serialization assembly. 
+                // This is valid serialization assembly.
                 reference.AddSerializationAssemblyFile(serializationAssemblyFilename);
             }
         }
@@ -1101,7 +1101,7 @@ private void FindDependenciesAndScatterFiles(
             Reference reference,
             List<KeyValuePair<AssemblyNameExtension, Reference>> newEntries)
         {
-            // Before checking for dependencies check to see if the reference itself exists. 
+            // Before checking for dependencies check to see if the reference itself exists.
             // Even though to get to this point the reference must be resolved
             // the reference may not exist on disk if the reference is a project to project reference.
             if (!_fileExists(reference.FullPath))
@@ -1276,7 +1276,7 @@ private void ResolveReference(
             // A list of assemblies that might have been matches but weren't
             var assembliesConsideredAndRejected = new List<ResolutionSearchLocation>();
 
-            // First, look for the dependency in the parents' directories. Unless they are resolved from the GAC or assemblyFoldersEx then 
+            // First, look for the dependency in the parents' directories. Unless they are resolved from the GAC or assemblyFoldersEx then
             // we should make sure we use the GAC and assemblyFolders resolvers themserves rather than a directory resolver to find the reference.
             // This way we dont get assemblies pulled from the GAC or AssemblyFolders but dont have the marking that they were pulled form there.
             var parentReferenceFolders = new List<string>();
@@ -1410,7 +1410,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                         }
                     }
 
-                    // A Primary reference can also be dependency of other references. This means there may be other primary reference which depend on 
+                    // A Primary reference can also be dependency of other references. This means there may be other primary reference which depend on
                     // the current primary reference and they need to be removed.
                     ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
 
@@ -1419,7 +1419,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     {
                         // Does the assembly have specific version true, or does any of its primary parent references have specific version true.
                         // This is checked because, if an assembly is in the deny list, the only way it can possibly be allowed is if
-                        // ANY of the primary references which caused it have specific version set to true. To see if any primary references have the metadata we pass true to the method indicating 
+                        // ANY of the primary references which caused it have specific version set to true. To see if any primary references have the metadata we pass true to the method indicating
                         // we want to know if any primary references have specific version set to true.
                         bool hasSpecificVersionTrue = assemblyReference.CheckForSpecificVersionMetadataOnParentsReference(true);
 
@@ -1443,7 +1443,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     }
                 }
 
-                // Go through each of the reference which were removed from the reference list and make sure that we get rid of all of the assemblies which were 
+                // Go through each of the reference which were removed from the reference list and make sure that we get rid of all of the assemblies which were
                 // dependencies of them.
                 foreach (Reference reference in removedReferences)
                 {
@@ -1463,7 +1463,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
         /// </summary>
         private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAssemblyExtensionPair>> dependencyGraph, AssemblyNameExtension assemblyName, Reference assemblyReference)
         {
-            // Find the references who the current reference is a dependency for 
+            // Find the references who the current reference is a dependency for
             foreach (Reference dependee in assemblyReference.GetDependees())
             {
                 // For a dependee see if we already have a list started
@@ -1484,7 +1484,7 @@ private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAss
         private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, Dictionary<AssemblyNameExtension, Reference> goodReferences, List<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference)
         {
             // For a dependency we would like to remove the primary references which caused this dependency to be found.
-            // Source Items is the list of primary itemspecs which lead to the current reference being discovered. 
+            // Source Items is the list of primary itemspecs which lead to the current reference being discovered.
             ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
             foreach (ITaskItem dependee in dependees)
             {
@@ -1573,13 +1573,13 @@ private static void RemoveDependencies(Reference removedReference, Dictionary<As
                 return;
             }
 
-            // Go through each of the dependency assemblies and remove the removedReference from the 
+            // Go through each of the dependency assemblies and remove the removedReference from the
             // dependee list.
             foreach (ReferenceAssemblyExtensionPair dependency in dependencies)
             {
                 Reference reference = dependency.Key;
 
-                // Remove the referenceToRemove from the dependee list, this will "unlink" them, in that the dependency reference will no longer know that 
+                // Remove the referenceToRemove from the dependee list, this will "unlink" them, in that the dependency reference will no longer know that
                 // referenceToRemove had a dependency on it
                 reference.RemoveDependee(removedReference);
 
@@ -1704,7 +1704,7 @@ private bool FindAssociatedFiles()
 
                         foreach (string frameworkPath in _frameworkPaths)
                         {
-                            // frameworkPath is guaranteed to have a trailing slash, because 
+                            // frameworkPath is guaranteed to have a trailing slash, because
                             // ResolveAssemblyReference.Execute takes care of adding it.
 
                             if (string.Equals(referenceDirectoryName, frameworkPath, StringComparison.OrdinalIgnoreCase))
@@ -1718,7 +1718,7 @@ private bool FindAssociatedFiles()
                         {
                             if (!reference.ExternallyResolved)
                             {
-                                // Look for companion files like pdbs and xmls that ride along with 
+                                // Look for companion files like pdbs and xmls that ride along with
                                 // assemblies.
                                 if (_findRelatedFiles)
                                 {
@@ -1943,14 +1943,14 @@ internal void ResolveConflicts(
         /// <summary>
         /// If a reference is a higher version than what exists in the redist list of the target framework then
         /// this reference needs to be marked as excluded so that it is not allowed to be referenced.
-        /// 
+        ///
         /// If the user needs this reference then they need to set specific version to true.
         /// </summary>
         internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension assemblyName, Reference reference)
         {
             bool haveMarkedReference = false;
 
-            // If the reference was not resolved from the GAC or AssemblyFolders then 
+            // If the reference was not resolved from the GAC or AssemblyFolders then
             // we do not need to check it if came from another framework
             string resolvedSearchPath = reference.ResolvedSearchPath;
             bool resolvedFromGAC = resolvedSearchPath.Equals(AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase);
@@ -1964,7 +1964,7 @@ internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension as
             // Check against target framework version if projectTargetFramework is null or less than 4.5, also when flag to force check is set to true
             if (_checkAssemblyVersionAgainstTargetFrameworkVersion)
             {
-                // Did the assembly name get resolved from a GlobalLocation, GAC or AssemblyFolders and is it in the frameworkList.xml for the 
+                // Did the assembly name get resolved from a GlobalLocation, GAC or AssemblyFolders and is it in the frameworkList.xml for the
                 // highest version of the currently targeted framework identifier.
                 bool inLaterRedistListAndFromGlobalLocation = InLatestRedistList(assemblyName);
 
@@ -2021,7 +2021,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
 
                         string otherFrameworkName = null;
 
-                        // The latestTargetFrameworkDirectories can be passed into RAR, if they are then use those directories rather than 
+                        // The latestTargetFrameworkDirectories can be passed into RAR, if they are then use those directories rather than
                         // getting a list by looking at the file system.
                         if (_latestTargetFrameworkDirectories?.Length > 0)
                         {
@@ -2122,7 +2122,7 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyN
             {
                 // Check assemblies versions when target framework version is less than 4.5
 
-                // Make sure the version is higher than the version in the redist. 
+                // Make sure the version is higher than the version in the redist.
                 bool higherThanCurrentRedistList = reference.ReferenceVersion != null && reference.ExclusionListLoggingProperties.HighestVersionInRedist != null
                                                    && reference.ReferenceVersion.CompareTo(reference.ExclusionListLoggingProperties.HighestVersionInRedist) > 0;
 
@@ -2151,7 +2151,7 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(
                 return false;
             }
 
-            // Make sure the version is higher than the version in the redist. 
+            // Make sure the version is higher than the version in the redist.
             // If the identifier are not equal we do not check since we are not trying to catch cross framework incompatibilities.
             bool higherThanCurrentFramework = reference.FrameworkNameAttribute != null
                                               && _targetFrameworkMoniker != null
@@ -2185,7 +2185,7 @@ private Dictionary<string, List<AssemblyNameReference>> BuildSimpleNameTable()
                 AssemblyNameReference assemblyReference = AssemblyNameReference.Create(assemblyName, reference);
 
                 // Notice that unresolved assemblies are still added to the table.
-                // This is because an unresolved assembly may have a different version 
+                // This is because an unresolved assembly may have a different version
                 // which would influence unification. We want to report this to the user.
                 string baseName = assemblyName.Name;
 
@@ -2366,8 +2366,8 @@ private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyRef
                 string leftConflictFusionName = assemblyReference0.assemblyName.FullName;
                 string rightConflictFusionName = assemblyReference1.assemblyName.FullName;
 
-                // If both assemblies being compared are primary references, the caller should pass in a zero-flag 
-                // (non-unified) for both. (This conforms to the C# assumption that two direct references are meant to be 
+                // If both assemblies being compared are primary references, the caller should pass in a zero-flag
+                // (non-unified) for both. (This conforms to the C# assumption that two direct references are meant to be
                 // SxS.)
                 bool isNonUnified = leftConflictReference.IsPrimary && rightConflictReference.IsPrimary;
                 bool leftConflictLegacyUnified = !isNonUnified && assemblyReference0.reference.IsPrimary;
@@ -2683,7 +2683,7 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
             // If there was a primary source item, then forward metadata from it.
             // It's important that the metadata from the primary source item
             // win over the same metadata from other source items, so that's
-            // why we put this first.  (CopyMetadataTo will never override an 
+            // why we put this first.  (CopyMetadataTo will never override an
             // already existing metadata.)  For example, if this reference actually
             // came directly from an item declared in the project file, we'd
             // want to use the metadata from it, not some other random item in
@@ -3070,11 +3070,11 @@ internal void LogHigherVersionUnresolve(bool displayPrimaryReferenceMessage, Ass
         {
             if (displayPrimaryReferenceMessage)
             {
-                _log.LogWarningWithCodeFromResources("ResolveAssemblyReference.PrimaryReferenceOutsideOfFramework", reference.PrimarySourceItem.ItemSpec /* primary item spec*/, reference.ReferenceVersion /*Version of dependent assemby*/, reference.ExclusionListLoggingProperties.HighestVersionInRedist /*Version found in redist*/);
+                _log.LogWarningWithCodeFromResources("ResolveAssemblyReference.PrimaryReferenceOutsideOfFramework", reference.PrimarySourceItem.ItemSpec /* primary item spec*/, reference.ReferenceVersion /*Version of dependent assembly*/, reference.ExclusionListLoggingProperties.HighestVersionInRedist /*Version found in redist*/);
             }
             else
             {
-                _log.LogWarningWithCodeFromResources("ResolveAssemblyReference.DependencyReferenceOutsideOfFramework", referenceItem.ItemSpec /* primary item spec*/, assemblyName.FullName /*Dependent assemblyName*/, reference.ReferenceVersion /*Version of dependent assemby*/, reference.ExclusionListLoggingProperties.HighestVersionInRedist /*Version found in redist*/);
+                _log.LogWarningWithCodeFromResources("ResolveAssemblyReference.DependencyReferenceOutsideOfFramework", referenceItem.ItemSpec /* primary item spec*/, assemblyName.FullName /*Dependent assemblyName*/, reference.ReferenceVersion /*Version of dependent assembly*/, reference.ExclusionListLoggingProperties.HighestVersionInRedist /*Version found in redist*/);
             }
         }
 
@@ -3085,7 +3085,7 @@ internal void LogHigherVersionUnresolveDueToAttribute(bool displayPrimaryReferen
         {
             if (displayPrimaryReferenceMessage)
             {
-                _log.LogWarningWithCodeFromResources("ResolveAssemblyReference.PrimaryReferenceOutsideOfFrameworkUsingAttribute", reference.PrimarySourceItem.ItemSpec /* primary item spec*/, reference.FrameworkNameAttribute /*Version of dependent assemby*/, targetedFramework);
+                _log.LogWarningWithCodeFromResources("ResolveAssemblyReference.PrimaryReferenceOutsideOfFrameworkUsingAttribute", reference.PrimarySourceItem.ItemSpec /* primary item spec*/, reference.FrameworkNameAttribute /*Version of dependent assembly*/, targetedFramework);
             }
             else
             {
@@ -3163,8 +3163,8 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
 
                 MarkReferenceWithHighestVersionInCurrentRedistList(assemblyName, reference);
 
-                // If CheckForSpecificVersionMetadataOnParentsReference is passed true then we will return true if any parent primary reference has the specific 
-                // version metadata set to true, 
+                // If CheckForSpecificVersionMetadataOnParentsReference is passed true then we will return true if any parent primary reference has the specific
+                // version metadata set to true,
                 // If false is passed in we will return true ONLY if all parent primary references have the metadata set to true.
                 if (!reference.CheckForSpecificVersionMetadataOnParentsReference(false))
                 {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 45d87afb04c..381fa520766 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1123,7 +1123,7 @@ quiet at the engine level.
                             LogReferenceDependenciesAndSourceItemsToStringBuilder(conflictCandidate.ConflictVictorName.FullName, victor, logDependencies);
 
                             // Log the reference which lost the conflict and the dependencies and source items which caused it.
-                            LogReferenceDependenciesAndSourceItemsToStringBuilder(fusionName, conflictCandidate, logDependencies.AppendLine());
+                            LogReferenceDependenciesAndSourceItemsToStringBuilder(fusionName, conflictCandidate, logDependencies.AppendLine(), referenceIsUnified: true);
 
                             string output = StringBuilderCache.GetStringAndRelease(logConflict);
                             string details = string.Empty;
@@ -1207,7 +1207,7 @@ quiet at the engine level.
 
                                         assemblyIdentityAttributes.Add(new XAttribute("name", idealRemappingPartialAssemblyName.Name));
 
-                                        // We use "neutral" for "Invariant Language (Invariant Country)" in assembly names.
+                                        // We use "neutral" for "Invariant Language (Invariant Country/Region)" in assembly names.
                                         var cultureString = idealRemappingPartialAssemblyName.CultureName;
                                         assemblyIdentityAttributes.Add(new XAttribute("culture", String.IsNullOrEmpty(idealRemappingPartialAssemblyName.CultureName) ? "neutral" : idealRemappingPartialAssemblyName.CultureName));
 
@@ -1320,11 +1320,14 @@ internal static string ByteArrayToString(byte[] a)
         /// <summary>
         /// Log the source items and dependencies which lead to a given item.
         /// </summary>
-        private void LogReferenceDependenciesAndSourceItemsToStringBuilder(string fusionName, Reference conflictCandidate, StringBuilder log)
+        private void LogReferenceDependenciesAndSourceItemsToStringBuilder(string fusionName, Reference conflictCandidate, StringBuilder log, bool referenceIsUnified = false)
         {
             ErrorUtilities.VerifyThrowInternalNull(conflictCandidate, nameof(conflictCandidate));
             log.Append(Strings.FourSpaces);
-            log.Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", fusionName, conflictCandidate.FullPath));
+
+            string resource = referenceIsUnified ? "ResolveAssemblyReference.UnifiedReferenceDependsOn" : "ResolveAssemblyReference.ReferenceDependsOn";
+
+            log.Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(resource, fusionName, conflictCandidate.FullPath));
 
             if (conflictCandidate.IsPrimary)
             {
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index 667493a611d..5cebad377ce 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -208,7 +208,7 @@ protected bool FileMatchesAssemblyName(
                 {
                     // Its pretty hard to get here, you need an assembly that contains a valid reference
                     // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
-                    // Still it happened once, with an older version of the CLR. 
+                    // Still it happened once, with an older version of the CLR.
 
                     // ...falling through and relying on the targetAssemblyName==null behavior below...
                 }
@@ -233,7 +233,7 @@ protected bool FileMatchesAssemblyName(
                     // If we are targeting a given processor architecture check to see if they match, if we are targeting MSIL then any architecture will do.
                     if (compareProcessorArchitecture)
                     {
-                        // Only reject the assembly if the target processor architecture does not match the assemby processor architecture and the assembly processor architecture is not NONE or MSIL.
+                        // Only reject the assembly if the target processor architecture does not match the assembly processor architecture and the assembly processor architecture is not NONE or MSIL.
                         if (
                               targetAssemblyName.AssemblyName.ProcessorArchitecture != targetProcessorArchitecture &&  /* The target and assembly architectures do not match*/
                               (targetProcessorArchitecture != ProcessorArchitecture.None && targetAssemblyName.AssemblyName.ProcessorArchitecture != ProcessorArchitecture.None)  /*The assembly is not none*/
@@ -330,7 +330,7 @@ protected string ResolveFromDirectory(
                         throw new InvalidParameterValueException("SearchPaths", directory + (directory.EndsWith("\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : "\\") + baseName, e.Message);
                     }
 
-                    // We have a full path returned 
+                    // We have a full path returned
                     if (ResolveAsFile(fullPath, assemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected))
                     {
                         if (candidateFullPath == null)
@@ -340,10 +340,10 @@ protected string ResolveFromDirectory(
 
                         /*
                          * After finding a file we now will check to see if it matches the type of processor architecture we want to return. The rules are as follows
-                         * 
+                         *
                          * If targeting AMD64 / X86 / IA64 / ARM /NONE we will return the first assembly which has a matching processor architecture OR is an assembly with a processor architecture of MSIL or NONE
-                         * 
-                         * If targeting MSIL we will first look through all of the assemblies, if an MSIL assembly is found we will return that. If no MSIL assembly is found we will return 
+                         *
+                         * If targeting MSIL we will first look through all of the assemblies, if an MSIL assembly is found we will return that. If no MSIL assembly is found we will return
                          * the first assembly which matches reguardless of its processor architecture.
                          */
 
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index 3d9bf146499..3258cfe21fc 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -91,7 +91,7 @@ private static void AddFoldersFromRegistryKey(
                 key,
                 directories);
 
-            // Then add the local machine.            
+            // Then add the local machine.
             AddFoldersFromRegistryKey(
                 Registry.LocalMachine,
                 key,
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 2ff7b10261f..f55d2fd6268 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -16,18 +16,18 @@ namespace Microsoft.Build.Tasks
 {
     /// <summary>
     /// Class: AssignCulture
-    /// 
+    ///
     /// This task takes a list of resource file names and sets an attribute that
     /// contains the culture name embedded in the file name:
-    /// 
+    ///
     ///      MyResources.fr.resx     ==> Culture='fr'
-    /// 
+    ///
     /// The task can also return a list of "Culture-neutral" file names, like:
-    /// 
+    ///
     ///      MyGlyph.fr.bmp          ==> MyGlyph.bmp [Culture='fr']
-    /// 
+    ///
     /// This is because embedded resources are referred to this way.
-    /// 
+    ///
     /// There are plenty of corner cases with this task. See the unit test for
     /// more details.
     /// </summary>
@@ -43,13 +43,13 @@ public class AssignCulture : TaskExtension
 
         /// <summary>
         /// This outgoing list of files is exactly the same as the incoming Files
-        /// list except that an attribute name "Culture" will have been added if 
+        /// list except that an attribute name "Culture" will have been added if
         /// the particular file name is in the form:
-        /// 
+        ///
         ///      MyResource.&lt;any-valid-culture-id&gt;.resx
-        /// 
+        ///
         /// The value of Culture will be "&lt;any-valid-culture-id&gt;".
-        /// 
+        ///
         /// If the incoming item from Files already has a Culture attribute then
         /// that original attribute is used instead.
         /// </summary>
@@ -62,9 +62,9 @@ public class AssignCulture : TaskExtension
         /// already had a Culture in the incoming Files list as well as items
         /// that were assigned a Culture because they had a valid culture ID
         /// embedded in their file name.
-        /// 
+        ///
         /// The following is always true:
-        /// 
+        ///
         ///      AssignedFiles = AssignedFilesWithCulture + AssignedFilesWithNoCulture
         /// </summary>
         [Output]
@@ -72,10 +72,10 @@ public class AssignCulture : TaskExtension
 
         /// <summary>
         /// This is a subset of AssignedFiles that has all of the items that
-        /// ended up with no Culture assigned to them. 
-        /// 
+        /// ended up with no Culture assigned to them.
+        ///
         /// The following is always true:
-        /// 
+        ///
         ///      AssignedFiles = AssignedFilesWithCulture + AssignedFilesWithNoCulture
         /// </summary>
         [Output]
@@ -84,27 +84,27 @@ public class AssignCulture : TaskExtension
         /// <summary>
         /// This list has the same number of items as the Files list or the
         /// AssignedFiles list.
-        /// 
+        ///
         /// Items in this list have the file name from Files or AssignedFiles
         /// but with the culture stripped if it was embedded in the file name.
-        /// 
+        ///
         /// So for example, if the incoming item in Files was:
-        /// 
+        ///
         ///      MyBitmap.fr.bmp
-        /// 
+        ///
         /// then the corresponding file in CultureNeutralAssignedFiles will be:
-        /// 
+        ///
         ///      MyBitmap.bmp
-        /// 
+        ///
         /// The culture will only be stripped if it is a valid culture identifier.
         /// So for example,
-        /// 
+        ///
         ///      MyDifferentFile.XX.txt
-        /// 
+        ///
         /// will result in exactly the same file name:
-        /// 
+        ///
         ///      MyDifferentFile.XX.txt
-        /// 
+        ///
         /// because 'XX' is not a valid culture identifier.
         /// </summary>
         [Output]
diff --git a/src/Tasks/AssignLinkMetadata.cs b/src/Tasks/AssignLinkMetadata.cs
index 55a043eefc7..717a2fb1eae 100644
--- a/src/Tasks/AssignLinkMetadata.cs
+++ b/src/Tasks/AssignLinkMetadata.cs
@@ -28,11 +28,11 @@ public class AssignLinkMetadata : TaskExtension
         public ITaskItem[] OutputItems { get; set; }
 
         /// <summary>
-        /// Sets "Link" metadata on any item where the project file in which they 
-        /// were defined is different from the parent project file to a sane default: 
-        /// the relative directory compared to the defining file.  
-        /// 
-        /// Does NOT overwrite Link metadata if it's already defined. 
+        /// Sets "Link" metadata on any item where the project file in which they
+        /// were defined is different from the parent project file to a sane default:
+        /// the relative directory compared to the defining file.
+        ///
+        /// Does NOT overwrite Link metadata if it's already defined.
         /// </summary>
         public override bool Execute()
         {
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 74894b3aa5e..ba5062c1ce5 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -18,7 +18,7 @@ public class AssignProjectConfiguration : ResolveProjectBase
         #region Properties
 
         /// <summary>
-        /// A special XML string containing a project configuration for each project - we need to simply 
+        /// A special XML string containing a project configuration for each project - we need to simply
         /// match the projects and assign the appropriate configuration names to them
         /// </summary>
         public string SolutionConfigurationContents { get; set; }
@@ -31,7 +31,7 @@ public class AssignProjectConfiguration : ResolveProjectBase
 
         /// <summary>
         /// String containing a semicolon-delimited list of mappings from the platform names used
-        /// by most VS types to those used by .vcxprojs.  
+        /// by most VS types to those used by .vcxprojs.
         /// </summary>
         /// <remarks>
         /// E.g.  "AnyCPU=Win32"
@@ -56,7 +56,7 @@ public string DefaultToVcxPlatformMapping
 
         /// <summary>
         /// String containing a semicolon-delimited list of mappings from .vcxproj platform names
-        /// to the platform names use by most other VS project types.  
+        /// to the platform names use by most other VS project types.
         /// </summary>
         /// <remarks>
         /// E.g.  "Win32=AnyCPU"
@@ -115,12 +115,12 @@ public string VcxToDefaultPlatformMapping
         public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get; set; } = false;
 
         // Whether to set the project reference's GlobalPropertiesToRemove metadata to contain
-        // Configuration and Platform. 
+        // Configuration and Platform.
 
         /// <summary>
         /// Whether to set the GlobalPropertiesToRemove metadata on the project reference such that
-        /// on an MSBuild call, the Configuration and Platform metadata will be unset, allowing the 
-        /// child project to build in its default configuration / platform. 
+        /// on an MSBuild call, the Configuration and Platform metadata will be unset, allowing the
+        /// child project to build in its default configuration / platform.
         /// </summary>
         public bool ShouldUnsetParentConfigurationAndPlatform { get; set; } = false;
 
@@ -205,9 +205,9 @@ public override bool Execute()
                     }
                     else
                     {
-                        // If the reference was unresolved, we want to undefine the Configuration and Platform 
+                        // If the reference was unresolved, we want to undefine the Configuration and Platform
                         // global properties, so that the project will build using its default Configuration and
-                        // Platform rather than that of its parent. 
+                        // Platform rather than that of its parent.
                         if (ShouldUnsetParentConfigurationAndPlatform)
                         {
                             string globalPropertiesToRemove = projectRef.GetMetadata("GlobalPropertiesToRemove");
@@ -253,7 +253,7 @@ public override bool Execute()
         #region Methods
 
         /// <summary>
-        /// Given a project reference task item and an XML document containing project configurations, 
+        /// Given a project reference task item and an XML document containing project configurations,
         /// find the configuration for that task item.
         /// </summary>
         /// <returns>true if resolved successfully</returns>
@@ -333,14 +333,14 @@ internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool on
         {
             if (projectConfigurationElement != null && resolvedProjectWithConfiguration != null && onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)
             {
-                // The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value. 
+                // The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value.
                 string buildProjectInSolution = projectConfigurationElement.GetAttribute(SolutionConfiguration.BuildProjectInSolutionAttribute);
 
-                // We could not parse out what was in the attribute, act as if it was not set in the first place. 
+                // We could not parse out what was in the attribute, act as if it was not set in the first place.
                 if (bool.TryParse(buildProjectInSolution, out bool buildProject))
                 {
-                    // If we do not want to build references disabled in the solution configuration blob   
-                    // and the solution configuration indicates the build for this project is disabled 
+                    // If we do not want to build references disabled in the solution configuration blob
+                    // and the solution configuration indicates the build for this project is disabled
                     // We need to set the BuildReferenceMetadata to false and the ReferenceOutputAssembly to false (if they are not already set to anything)
                     if (!buildProject)
                     {
@@ -362,8 +362,8 @@ internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool on
         }
 
         /// <summary>
-        /// Given the contents of VcxToDefaultPlatformMapping and DefaultToVcxPlatformMapping properties, 
-        /// fill out the maps that will be used to translate between the two.  
+        /// Given the contents of VcxToDefaultPlatformMapping and DefaultToVcxPlatformMapping properties,
+        /// fill out the maps that will be used to translate between the two.
         /// </summary>
         private void SetupDefaultPlatformMappings()
         {
@@ -384,7 +384,7 @@ private void SetupDefaultPlatformMappings()
         }
 
         /// <summary>
-        /// Given a dictionary to populate and a string of the format "a=b;c=d", populate the 
+        /// Given a dictionary to populate and a string of the format "a=b;c=d", populate the
         /// dictionary with the given pairs.
         /// </summary>
         private void PopulateMappingDictionary(IDictionary<string, string> map, string mappingList)
diff --git a/src/Tasks/AxImp.cs b/src/Tasks/AxImp.cs
index fd0b6ccd2ae..14eeb123d8c 100644
--- a/src/Tasks/AxImp.cs
+++ b/src/Tasks/AxImp.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Tasks
     public sealed partial class ResolveComReference
     {
         /// <summary>
-        /// Defines the "AxImp" MSBuild task, which enables using AxImp.exe 
+        /// Defines the "AxImp" MSBuild task, which enables using AxImp.exe
         /// to generate Windows Forms wrappers for ActiveX controls.
         /// </summary>
         internal class AxImp : AxTlbBaseTask
diff --git a/src/Tasks/AxReference.cs b/src/Tasks/AxReference.cs
index 81a24df2d8e..d159d9f9fd7 100644
--- a/src/Tasks/AxReference.cs
+++ b/src/Tasks/AxReference.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Tasks
 {
     /*
      * Class:   AxReference
-     * 
+     *
      * COM reference wrapper class for the ActiveX controls.
      *
      */
diff --git a/src/Tasks/AxTlbBaseReference.cs b/src/Tasks/AxTlbBaseReference.cs
index 6ac34233207..60a81c310e8 100644
--- a/src/Tasks/AxTlbBaseReference.cs
+++ b/src/Tasks/AxTlbBaseReference.cs
@@ -16,12 +16,12 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Common abstract base for aximp and tlbimp COM reference wrapper classes. 
+    /// Common abstract base for aximp and tlbimp COM reference wrapper classes.
     /// They share the resolution method and only differ in constructing the wrapper file name.
     /// </summary>
     internal abstract class AxTlbBaseReference : ComReference
     {
-        #region Constructors	
+        #region Constructors
         /// <summary>
         /// internal constructor
         /// </summary>
@@ -85,9 +85,9 @@ internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IC
         protected bool DelaySign { get; set; }
 
         /// <summary>
-        /// Property to allow multitargeting of ResolveComReferences:  If true, tlbimp.exe and 
+        /// Property to allow multitargeting of ResolveComReferences:  If true, tlbimp.exe and
         /// aximp.exe from the appropriate target framework will be run out-of-proc to generate
-        /// the necessary wrapper assemblies.  
+        /// the necessary wrapper assemblies.
         /// </summary>
         protected bool ExecuteAsTool { get; set; }
 
@@ -100,12 +100,12 @@ internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IC
 
         /// <summary>
         /// Environment variables to pass to the tool.
-        /// </summary>        
+        /// </summary>
         protected string[] EnvironmentVariables { get; set; }
 
         /// <summary>
-        /// If ExecuteAsTool is true, this must be set to the SDK 
-        /// tools path for the framework version being targeted. 
+        /// If ExecuteAsTool is true, this must be set to the SDK
+        /// tools path for the framework version being targeted.
         /// </summary>
         protected string ToolPath { get; set; }
 
@@ -119,7 +119,7 @@ internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IC
         #region Methods
 
         /// <summary>
-        /// Checks if there's a preexisting wrapper for this reference. 
+        /// Checks if there's a preexisting wrapper for this reference.
         /// </summary>
         internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp)
         {
@@ -164,7 +164,7 @@ protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, Da
                 return false;
             }
 
-            // Compare our the existing wrapper's strong name state to the one we are requesting. 
+            // Compare our the existing wrapper's strong name state to the one we are requesting.
             if (!SigningRequirementsMatchExistingWrapper(wrapperInfo))
             {
                 return false;
@@ -185,7 +185,7 @@ protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, Da
         }
 
         /// <summary>
-        /// Constructs the wrapper file path. 
+        /// Constructs the wrapper file path.
         /// </summary>
         internal string GetWrapperPath()
         {
@@ -203,11 +203,11 @@ internal string GetWrapperFileName()
 
         /*
          * Method:  GetWrapperFileName
-         * 
-         * 
+         *
+         *
          */
         /// <summary>
-        /// Constructs the wrapper file name from a type library name. Specialized wrappers must override it if 
+        /// Constructs the wrapper file name from a type library name. Specialized wrappers must override it if
         /// they want to use the Resolve method from this class.
         /// </summary>
         protected abstract string GetWrapperFileNameInternal(string typeLibName);
@@ -245,8 +245,8 @@ internal static string GetWrapperFileName(string interopDllHeader, string typeLi
         }
 
         /// <summary>
-        /// Given our KeyFile, KeyContainer, and DelaySign parameters, generate the public / private 
-        /// key pair and validate that it exists to the extent needed.  
+        /// Given our KeyFile, KeyContainer, and DelaySign parameters, generate the public / private
+        /// key pair and validate that it exists to the extent needed.
         /// </summary>
         internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byte[] publicKey)
         {
@@ -254,7 +254,7 @@ internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byt
             // get key pair/public key
             StrongNameUtils.GetStrongNameKey(Log, KeyFile, KeyContainer, out keyPair, out publicKey);
 
-            // make sure we give as much data to the typelib converter as necessary but not more, or we might end up 
+            // make sure we give as much data to the typelib converter as necessary but not more, or we might end up
             // with something we didn't want
             if (DelaySign)
             {
@@ -290,7 +290,7 @@ internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byt
         }
 
         /// <summary>
-        /// Compare the strong name signing state of the existing wrapper to the signing 
+        /// Compare the strong name signing state of the existing wrapper to the signing
         /// state we are requesting in this run of the task. Return true if they match (e.g.
         /// from a signing perspective, the wrapper is up-to-date) or false otherwise.
         /// </summary>
diff --git a/src/Tasks/AxTlbBaseTask.cs b/src/Tasks/AxTlbBaseTask.cs
index 227a4efc86e..e058cd21a99 100644
--- a/src/Tasks/AxTlbBaseTask.cs
+++ b/src/Tasks/AxTlbBaseTask.cs
@@ -17,9 +17,9 @@ internal abstract class AxTlbBaseTask : ToolTaskExtension
         #region Private Data
 
         /// <summary>
-        /// True if the keyfile only contains the public key data, and thus 
+        /// True if the keyfile only contains the public key data, and thus
         /// we should pass the file using the /publickey: parameter instead of
-        /// /keyfile. 
+        /// /keyfile.
         /// </summary>
         private bool _delaySigningAndKeyFileOnlyContainsPublicKey;
 
@@ -68,7 +68,7 @@ public string SdkToolsPath
 
         /// <summary>
         /// Returns the name of the tool to execute.  AxTlbBaseTask is not
-        /// executable, so return null for the ToolName -- And make sure that 
+        /// executable, so return null for the ToolName -- And make sure that
         /// Execute() logs an error!
         /// </summary>
         protected override string ToolName { get; } = null;
@@ -91,7 +91,7 @@ public override bool Execute()
         }
 
         /// <summary>
-        /// Adds commands for the tool being executed, that cannot be put in a response file.  
+        /// Adds commands for the tool being executed, that cannot be put in a response file.
         /// </summary>
         /// <param name="commandLine">The CommandLineBuilderExtension to add the commands to</param>
         protected internal override void AddCommandLineCommands(CommandLineBuilderExtension commandLine)
@@ -123,7 +123,7 @@ protected override string GenerateFullPathToTool()
         /// <returns>True if parameters are valid</returns>
         protected override bool ValidateParameters()
         {
-            // Verify that a path for the tool exists -- if the tool doesn't exist in it 
+            // Verify that a path for the tool exists -- if the tool doesn't exist in it
             // we'll worry about that later
             if ((String.IsNullOrEmpty(ToolPath) || !FileSystems.Default.DirectoryExists(ToolPath)) &&
                 (String.IsNullOrEmpty(SdkToolsPath) || !FileSystems.Default.DirectoryExists(SdkToolsPath)))
@@ -134,7 +134,7 @@ protected override bool ValidateParameters()
 
             if (ValidateStrongNameParameters())
             {
-                // Allow the base class to do any validation it thinks necessary -- as far 
+                // Allow the base class to do any validation it thinks necessary -- as far
                 // as we're concerned, parameters check out properly
                 return base.ValidateParameters();
             }
@@ -142,7 +142,7 @@ protected override bool ValidateParameters()
         }
 
         /// <summary>
-        /// Adds options involving strong name signing -- syntax is the same between 
+        /// Adds options involving strong name signing -- syntax is the same between
         /// AxImp and TlbImp
         /// </summary>
         /// <param name="commandLine">The command line to add options to</param>
@@ -151,10 +151,10 @@ private void AddStrongNameOptions(CommandLineBuilderExtension commandLine)
             commandLine.AppendWhenTrue("/delaysign", Bag, "DelaySign");
 
             // If we're delay-signing, we only need the public key, but if we use the /publickey
-            // switch, it will consume the entire key file, assume that's just the public key, and 
+            // switch, it will consume the entire key file, assume that's just the public key, and
             // throw an error.
-            // 
-            // So use /publickey if that's all our KeyFile contains, but KeyFile otherwise. 
+            //
+            // So use /publickey if that's all our KeyFile contains, but KeyFile otherwise.
             if (_delaySigningAndKeyFileOnlyContainsPublicKey)
             {
                 commandLine.AppendSwitchIfNotNull("/publickey:", KeyFile);
@@ -207,7 +207,7 @@ private bool ValidateStrongNameParameters()
                 return false;
             }
 
-            // If KeyFile or KeyContainer is specified, verify that a key pair exists (or if delay-signed, 
+            // If KeyFile or KeyContainer is specified, verify that a key pair exists (or if delay-signed,
             // even just a public key)
             if (keyFileExists || keyContainerSpecified)
             {
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index b60f7b01d4a..0b296e958ca 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -52,7 +52,7 @@ public class BootstrapperBuilder : IBootstrapperBuilder
 
         private const string ENGINE_PATH = "Engine"; // relative to bootstrapper path
         private const string SCHEMA_PATH = "Schemas"; // relative to bootstrapper path
-        private const string PACKAGE_PATH = "Packages"; // relative to bootstrapper path 
+        private const string PACKAGE_PATH = "Packages"; // relative to bootstrapper path
         private const string RESOURCES_PATH = "";
 
         private const string BOOTSTRAPPER_NAMESPACE = "http://schemas.microsoft.com/developer/2004/01/bootstrapper";
@@ -202,7 +202,7 @@ public BuildResults Build(BuildSettings settings)
                     configElement.AppendChild(applicationElement);
                 }
 
-                // Key: File hash, Value: A DictionaryEntry whose Key is "EULAx" and value is a 
+                // Key: File hash, Value: A DictionaryEntry whose Key is "EULAx" and value is a
                 // fully qualified path to a eula. It can be any eula that matches the hash.
                 var eulas = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.Ordinal);
 
@@ -760,7 +760,7 @@ private void OrderProducts(Dictionary<string, Product> availableProducts, Dictio
                 }
 
                 // If we could not remove any products and there are still products in the queue
-                // there must be a loop in it. We'll break the loop by removing the dependencies 
+                // there must be a loop in it. We'll break the loop by removing the dependencies
                 // of the first project in the queue;
                 if (buildQueue.Count > 0 && productsToRemove.Count == 0)
                 {
@@ -1018,7 +1018,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement, st
                                             ReplacePackageFileAttributes(langElement, EULA_ATTRIBUTE, packageFilesNode, "PackageFile", "OldName", "SourcePath");
                                         }
 
-                                        // in general, we prefer the attributes of the language document over the 
+                                        // in general, we prefer the attributes of the language document over the
                                         //  attributes of the base document.  Copy attributes from the lang to the merged,
                                         //  and then merge all unique elements into merge
                                         foreach (XmlAttribute attribute in langElement.Attributes)
@@ -1240,12 +1240,12 @@ private void CombineElements(XmlElement langElement, XmlElement baseElement, str
             XmlNode baseNode = baseElement.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":" + strNodeName, _xmlNamespaceManager);
 
             // There are 4 basic cases to be dealt with:
-            // Case #    1       2       3       4      
+            // Case #    1       2       3       4
             // base      null    null    present present
             // lang      null    present null    present
             // Result    null    lang    base    combine
             //
-            // Cases 1 - 3 are pretty trivial.  
+            // Cases 1 - 3 are pretty trivial.
             if (baseNode == null)
             {
                 if (langNode != null)
@@ -2038,27 +2038,27 @@ private static void DumpXmlToFile(XmlNode node, string fileName)
                 }
                 catch (IOException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (UnauthorizedAccessException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (ArgumentException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (NotSupportedException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (XmlException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
             }
@@ -2077,22 +2077,22 @@ private static void DumpStringToFile(string text, string fileName, bool append)
                 }
                 catch (IOException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (UnauthorizedAccessException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (ArgumentException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
                 catch (NotSupportedException)
                 {
-                    // can't write info to a log file?  This is a trouble-shooting helper only, and 
+                    // can't write info to a log file?  This is a trouble-shooting helper only, and
                     // this exception can be ignored
                 }
             }
@@ -2242,12 +2242,12 @@ private static Dictionary<string, Product> GetIncludedProducts(Product product)
         {
             var includedProducts = new Dictionary<string, Product>(StringComparer.OrdinalIgnoreCase)
             {
-                // Add in this product in case there is a circular includes: 
+                // Add in this product in case there is a circular includes:
                 // we won't continue to explore this product.  It will be removed later.
                 { product.ProductCode, product }
             };
 
-            // Recursively add included products 
+            // Recursively add included products
             foreach (Product p in product.Includes)
             {
                 AddIncludedProducts(p, includedProducts);
diff --git a/src/Tasks/BootstrapperUtil/Interfaces.cs b/src/Tasks/BootstrapperUtil/Interfaces.cs
index 33f04d5c548..2214a9f69c4 100644
--- a/src/Tasks/BootstrapperUtil/Interfaces.cs
+++ b/src/Tasks/BootstrapperUtil/Interfaces.cs
@@ -316,7 +316,7 @@ public enum BuildMessageSeverity
     public enum ComponentsLocation
     {
         /// <summary>
-        /// Products will be found according to the redist vendor's designated URL 
+        /// Products will be found according to the redist vendor's designated URL
         /// </summary>
         HomeSite,
         /// <summary>
diff --git a/src/Tasks/CallTarget.cs b/src/Tasks/CallTarget.cs
index 0b64787bf00..74acb20e7c3 100644
--- a/src/Tasks/CallTarget.cs
+++ b/src/Tasks/CallTarget.cs
@@ -27,7 +27,7 @@ public class CallTarget : TaskExtension
         /// </summary>
         /// <value>Array of target names.</value>
         /// <remarks>
-        /// This is a required parameter. If you want to build the 
+        /// This is a required parameter. If you want to build the
         /// default targets, use the &lt;MSBuild&gt; task and pass in Projects=$(MSBuildProjectFile).
         /// </remarks>
         public string[] Targets { get; set; }
@@ -68,8 +68,8 @@ public override bool Execute()
             }
 
             // This is a list of string[].  That is, each element in the list is a string[].  Each
-            // string[] represents a set of target names to build.  Depending on the value 
-            // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
+            // string[] represents a set of target names to build.  Depending on the value
+            // of the RunEachTargetSeparately parameter, we each just call the engine to run all
             // the targets together, or we call the engine separately for each target.
             List<string[]> targetLists = MSBuild.CreateTargetLists(Targets, RunEachTargetSeparately);
 
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 522b4de5c81..4c076939d98 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -855,17 +855,17 @@ private List<string> CombineReferencedAssemblies()
 
             // Set some default references:
 
-            // Loading with the partial name is fine for framework assemblies -- we'll always get the correct one 
+            // Loading with the partial name is fine for framework assemblies -- we'll always get the correct one
             // through the magic of unification
             foreach (string defaultReference in s_defaultReferencedFrameworkAssemblyNames)
             {
                 AddReferenceAssemblyToReferenceList(finalReferenceList, defaultReference);
             }
 
-            // We also want to add references to two MSBuild assemblies: Microsoft.Build.Framework.dll and 
-            // Microsoft.Build.Utilities.Core.dll.  If we just let the CLR unify the simple name, it will 
-            // pick the highest version on the machine, which means that in hosts with restrictive binding 
-            // redirects, or no binding redirects, we'd end up creating an inline task that could not be 
+            // We also want to add references to two MSBuild assemblies: Microsoft.Build.Framework.dll and
+            // Microsoft.Build.Utilities.Core.dll.  If we just let the CLR unify the simple name, it will
+            // pick the highest version on the machine, which means that in hosts with restrictive binding
+            // redirects, or no binding redirects, we'd end up creating an inline task that could not be
             // run.  Instead, to make sure that we can actually use what we're building, just use the Framework
             // and Utilities currently loaded into this process -- Since we're in Microsoft.Build.Tasks.Core.dll
             // right now, by definition both of them are always already loaded.
diff --git a/src/Tasks/ComDependencyWalker.cs b/src/Tasks/ComDependencyWalker.cs
index f998d3be668..a0cdd95b2cd 100644
--- a/src/Tasks/ComDependencyWalker.cs
+++ b/src/Tasks/ComDependencyWalker.cs
@@ -13,7 +13,7 @@
 
 namespace Microsoft.Build.Tasks
 {
-    // Abstract the method for releasing COM objects for unit testing. 
+    // Abstract the method for releasing COM objects for unit testing.
     // Our mocks are not actually COM objects and they would blow up if passed to the real Marshal.ReleaseComObject.
     internal delegate int MarshalReleaseComObject(object o);
 
@@ -217,7 +217,7 @@ private static bool CanSkipType(ITypeInfo typeInfo, ITypeLib typeLib, TYPEATTR t
                 return true;
             }
 
-            // Is this the Guid type? If so we should be using the corresponding .NET type. 
+            // Is this the Guid type? If so we should be using the corresponding .NET type.
             if (typeLibAttributes.guid == NativeMethods.IID_StdOle)
             {
                 typeInfo.GetDocumentation(-1, out string typeName, out _, out _, out _);
@@ -399,7 +399,7 @@ internal ICollection<string> GetAnalyzedTypeNames()
         }
 
         /// <summary>
-        /// Clear the dependency list so we can read dependencies incrementally but still have the advantage of 
+        /// Clear the dependency list so we can read dependencies incrementally but still have the advantage of
         /// not scanning previously seen types
         /// </summary>
         internal void ClearDependencyList()
@@ -408,8 +408,8 @@ internal void ClearDependencyList()
         }
 
         /// <summary>
-        /// Clear the analyzed type cache.  This is necessary if we have to resolve dependencies that are also 
-        /// COM references in the project, or we may get an inaccurate view of what their dependencies are. 
+        /// Clear the analyzed type cache.  This is necessary if we have to resolve dependencies that are also
+        /// COM references in the project, or we may get an inaccurate view of what their dependencies are.
         /// </summary>
         internal void ClearAnalyzedTypeCache()
         {
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index 95d63adb880..340be0e84b1 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -13,7 +13,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Abstract base class for COM reference wrappers providing common functionality. 
+    /// Abstract base class for COM reference wrappers providing common functionality.
     /// This class hierarchy is used by the ResolveComReference task.Every class deriving from ComReference
     /// provides functionality for wrapping Com type libraries in a given way(for example AxReference, or PiaReference).
     /// </summary>
@@ -57,7 +57,7 @@ internal ComReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComRefer
         protected internal TaskLoggingHelper Log { get; }
 
         /// <summary>
-        /// True if this class should only log errors, but no messages or warnings.  
+        /// True if this class should only log errors, but no messages or warnings.
         /// </summary>
         protected internal bool Silent { get; }
 
@@ -87,7 +87,7 @@ internal static bool Ado27Installed
                 }
                 catch (COMException ex)
                 {
-                    // it's not registered. 
+                    // it's not registered.
                     ado27Installed = false;
                     ado27ErrorMessage = ex.Message;
                 }
@@ -231,7 +231,7 @@ internal static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex,
         }
 
         /// <summary>
-        /// Gets the name of given type library. 
+        /// Gets the name of given type library.
         /// </summary>
         internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silent, ITypeLib typeLib, string typeLibId, out string typeLibName)
         {
@@ -245,12 +245,12 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
             }
 
             // Get the custom attribute.  If anything fails then just return the
-            // type library name.  
+            // type library name.
             try
             {
                 typeLib2.GetCustData(ref NativeMethods.GUID_TYPELIB_NAMESPACE, out object data);
 
-                // if returned namespace is null or its type is not System.String, fall back to the default 
+                // if returned namespace is null or its type is not System.String, fall back to the default
                 // way of getting the type lib name (just to be safe)
                 if (data == null || !string.Equals(data.GetType().ToString(), "system.string", StringComparison.OrdinalIgnoreCase))
                 {
@@ -439,13 +439,13 @@ private static string GetModuleFileName(IntPtr handle)
         internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, ref TYPELIBATTR typeLibAttr, out string typeLibPath)
         {
             // Get which file the type library resides in.  If the appropriate
-            // file cannot be found then a blank string is returned.  
+            // file cannot be found then a blank string is returned.
             typeLibPath = "";
 
             try
             {
                 // Get the path from the registry
-                // This call has known issues. See http://msdn.microsoft.com/en-us/library/ms221436.aspx for the method and 
+                // This call has known issues. See http://msdn.microsoft.com/en-us/library/ms221436.aspx for the method and
                 // here for the fix http://support.microsoft.com/kb/982110. Most users from Win7 or Win2008R2 should have already received this post Win7SP1.
                 // In Summary: The issue is about calls to The QueryPathOfRegTypeLib function not returning the correct path for a 32-bit version of a
                 // registered type library in a 64-bit edition of Windows 7 or in Windows Server 2008 R2. It either returns the 64bit path or null.
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index 7ba6eff1a9f..c813f7a2e0b 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -23,7 +23,7 @@ internal class ComReferenceInfo
         #region Properties
 
         /// <summary>
-        /// ITypeLib pointer 
+        /// ITypeLib pointer
         /// </summary>
         internal ITypeLib typeLibPointer;
 
@@ -40,14 +40,14 @@ internal class ComReferenceInfo
 
         /// <summary>
         /// path to the reference, with typelibrary number stripped, if any (so ref1.dll\2 becomes ref1.dll).
-        /// The full path is only used for loading the type library, and it's not necessary 
+        /// The full path is only used for loading the type library, and it's not necessary
         /// to do it after the interface pointer is cached in this object.
         /// </summary>
         internal string strippedTypeLibPath;
 
         /// <summary>
-        /// When using TlbImp.exe, we need to make sure that we keep track of the non-stripped typelib path, 
-        /// because that's what we need to pass to TlbImp.  
+        /// When using TlbImp.exe, we need to make sure that we keep track of the non-stripped typelib path,
+        /// because that's what we need to pass to TlbImp.
         /// </summary>
         internal string fullTypeLibPath;
 
@@ -67,12 +67,12 @@ internal class ComReferenceInfo
         internal ComReferenceWrapperInfo resolvedWrapper;
 
         /// <summary>
-        /// List of the paths to COM wrapper assemblies that this reference is dependent upon. 
+        /// List of the paths to COM wrapper assemblies that this reference is dependent upon.
         /// </summary>
         internal List<string> dependentWrapperPaths;
 
         /// <summary>
-        /// Reference to the ITaskItem generated from the resolved reference, if any. 
+        /// Reference to the ITaskItem generated from the resolved reference, if any.
         /// </summary>
         internal ITaskItem referencePathItem;
 
@@ -125,12 +125,12 @@ internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYP
             }
 
             // Now that we have the path, we can call InitializeWithPath to get the correct TYPELIBATTR set up
-            // and the correct ITypeLib pointer. 
+            // and the correct ITypeLib pointer.
             return InitializeWithPath(log, silent, this.fullTypeLibPath, originalTaskItem, targetProcessorArchitecture);
         }
 
         /// <summary>
-        /// Initialize the object with a type library path 
+        /// Initialize the object with a type library path
         /// </summary>
         internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path, ITaskItem originalTaskItem, string targetProcessorArchitecture)
         {
@@ -139,12 +139,12 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
             this.taskItem = originalTaskItem;
 
             // Note that currently we DO NOT remap file ADO references. This is because when pointing to a file on disk,
-            // it seems unnatural to remap it to something else - a file reference means "use THIS component". 
+            // it seems unnatural to remap it to something else - a file reference means "use THIS component".
             // This is still under debate though, and may be revised later.
 
             // save both the stripped and full path in our object -- for the most part we just need the stripped path, but if
-            // we're using tlbimp.exe, we need to pass the full path w/ type lib number to it, or it won't generate the interop 
-            // assembly correctly. 
+            // we're using tlbimp.exe, we need to pass the full path w/ type lib number to it, or it won't generate the interop
+            // assembly correctly.
             this.fullTypeLibPath = path;
             this.strippedTypeLibPath = ComReference.StripTypeLibNumberFromPath(path, File.Exists);
 
diff --git a/src/Tasks/ComReferenceResolutionException.cs b/src/Tasks/ComReferenceResolutionException.cs
index 60839797eea..6f8e13d8c66 100644
--- a/src/Tasks/ComReferenceResolutionException.cs
+++ b/src/Tasks/ComReferenceResolutionException.cs
@@ -9,7 +9,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Internal exception thrown when there's an unrecoverable failure resolving a COM reference and we should 
+    /// Internal exception thrown when there's an unrecoverable failure resolving a COM reference and we should
     /// move on to the next one, if it makes sense.
     /// </summary>
     // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
diff --git a/src/Tasks/CommandLineBuilderExtension.cs b/src/Tasks/CommandLineBuilderExtension.cs
index b5ab47e0073..02f5ec2f8ef 100644
--- a/src/Tasks/CommandLineBuilderExtension.cs
+++ b/src/Tasks/CommandLineBuilderExtension.cs
@@ -195,7 +195,7 @@ internal void AppendSwitchWithSplitting(string switchName, string parameter, str
         }
 
         /// <summary>
-        /// Returns true if the parameter is empty in spirits, 
+        /// Returns true if the parameter is empty in spirits,
         /// even if it contains the separators and white space only
         /// Split on the characters provided.
         /// </summary>
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index 498513b70bc..9647c21c161 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -1,24 +1,75 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <Suppression>
-<!-- For ease of logging the "not supported on Core" message, this task is a
-         TaskExtension on netstandard/netcore. Since the type is sealed there,
+<!-- For ease of logging the "not supported on Core" message, these tasks are a
+         TaskRequiresFramework on netstandard/netcore. Since the type is sealed there,
          that shouldn't cause any implementation problems since no one can derive
          from it and try to call TaskExtension.Log. -->
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.AL</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.AspNetCompiler</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GenerateBootstrapper</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GenerateTrustInfo</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GetFrameworkSdkPath</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.RegisterAssembly</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
     <DiagnosticId>CP0007</DiagnosticId>
     <Target>T:Microsoft.Build.Tasks.ResolveComReference</Target>
     <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
     <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
-
-  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
   <Suppression>
-    <DiagnosticId>CP1002</DiagnosticId>
-    <Target>System.Security.Cryptography, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
-    <Left>ref/net7.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.ResolveNativeReference</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.UnregisterAssembly</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.UpdateManifest</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.WinMDExp</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
 
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
@@ -74,9 +125,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Tasks/ConvertToAbsolutePath.cs b/src/Tasks/ConvertToAbsolutePath.cs
index 099f6560c31..985dd77a979 100644
--- a/src/Tasks/ConvertToAbsolutePath.cs
+++ b/src/Tasks/ConvertToAbsolutePath.cs
@@ -51,7 +51,7 @@ public override bool Execute()
             {
                 try
                 {
-                    // Only call Path.GetFullPath if the path is not rooted to avoid 
+                    // Only call Path.GetFullPath if the path is not rooted to avoid
                     // going to disk when it is not necessary
                     if (!Path.IsPathRooted(path.ItemSpec))
                     {
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 68d7f27ddba..8d8b081a208 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -8,6 +8,7 @@
 using System.Runtime.InteropServices;
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
+
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -81,9 +82,9 @@ public Copy()
         private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
-        /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since 
-        /// normally there's no point, but occasionally things get into a bad state temporarily, and retrying does actually 
-        /// succeed.  So keeping around a secret environment variable to allow forcing that behavior if necessary.  
+        /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since
+        /// normally there's no point, but occasionally things get into a bad state temporarily, and retrying does actually
+        /// succeed.  So keeping around a secret environment variable to allow forcing that behavior if necessary.
         /// </summary>
         private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable(AlwaysRetryEnvVar) != null;
 
@@ -99,9 +100,10 @@ public Copy()
         /// </summary>
         private const int RetryDelayMillisecondsDefault = 1000;
 
-        [Required]
         public ITaskItem[] SourceFiles { get; set; }
 
+        public ITaskItem[] SourceFolders { get; set; }
+
         public ITaskItem DestinationFolder { get; set; }
 
         /// <summary>
@@ -197,7 +199,7 @@ private static bool IsMatchingSizeAndTimeStamp(
 
         /// <summary>
         /// INTERNAL FOR UNIT-TESTING ONLY
-        /// 
+        ///
         /// We've got several environment variables that we read into statics since we don't expect them to ever
         /// reasonably change, but we need some way of refreshing their values so that we can modify them for
         /// unit testing purposes.
@@ -208,19 +210,19 @@ internal static void RefreshInternalEnvironmentValues()
         }
 
         /// <summary>
-        /// If MSBUILDALWAYSRETRY is set, also log useful diagnostic information -- as 
-        /// a warning, so it's easily visible. 
+        /// If MSBUILDALWAYSRETRY is set, also log useful diagnostic information -- as
+        /// a warning, so it's easily visible.
         /// </summary>
-        private void LogDiagnostic(string message, params object[] messageArgs)
+        private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, params object[] messageArgs)
         {
             if (s_alwaysRetryCopy)
             {
-                Log.LogWarning(message, messageArgs);
+                Log.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
             }
         }
 
         /// <summary>
-        /// Copy one file from source to destination. Create the target directory if necessary and 
+        /// Copy one file from source to destination. Create the target directory if necessary and
         /// leave the file read-write.
         /// </summary>
         /// <returns>Return true to indicate success, return false to indicate failure and NO retry, return NULL to indicate retry.</returns>
@@ -268,7 +270,7 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                     }
                 }
 
-                // It's very common for a lot of files to be copied to the same folder. 
+                // It's very common for a lot of files to be copied to the same folder.
                 // Eg., "c:\foo\a"->"c:\bar\a", "c:\foo\b"->"c:\bar\b" and so forth.
                 // We don't want to check whether this folder exists for every single file we copy. So store which we've checked.
                 _directoriesKnownToExist.TryAdd(destinationFolder, true);
@@ -285,7 +287,10 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                 MakeFileWriteable(destinationFileState, true);
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) && destinationFileState.FileExists && !destinationFileState.IsReadOnly)
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) &&
+                Traits.Instance.EscapeHatches.CopyWithoutDelete != true &&
+                destinationFileState.FileExists &&
+                !destinationFileState.IsReadOnly)
             {
                 FileUtilities.DeleteNoThrow(destinationFileState.Name);
             }
@@ -399,7 +404,7 @@ internal bool Execute(
             int parallelism)
         {
             // If there are no source files then just return success.
-            if (SourceFiles == null || SourceFiles.Length == 0)
+            if (IsSourceSetEmpty())
             {
                 DestinationFiles = Array.Empty<ITaskItem>();
                 CopiedFiles = Array.Empty<ITaskItem>();
@@ -411,7 +416,7 @@ internal bool Execute(
                 return false;
             }
 
-            // Environment variable stomps on user-requested value if it's set. 
+            // Environment variable stomps on user-requested value if it's set.
             if (Environment.GetEnvironmentVariable(AlwaysOverwriteReadOnlyFilesEnvVar) != null)
             {
                 OverwriteReadOnlyFiles = true;
@@ -453,7 +458,7 @@ private bool CopySingleThreaded(
             destinationFilesSuccessfullyCopied = new List<ITaskItem>(DestinationFiles.Length);
 
             // Set of files we actually copied and the location from which they were originally copied.  The purpose
-            // of this collection is to let us skip copying duplicate files.  We will only copy the file if it 
+            // of this collection is to let us skip copying duplicate files.  We will only copy the file if it
             // either has never been copied to this destination before (key doesn't exist) or if we have copied it but
             // from a different location (value is different.)
             // { dest -> source }
@@ -640,6 +645,11 @@ private bool CopyParallel(
             return success;
         }
 
+        private bool IsSourceSetEmpty()
+        {
+            return (SourceFiles == null || SourceFiles.Length == 0) && (SourceFolders == null || SourceFolders.Length == 0);
+        }
+
         /// <summary>
         /// Verify that the inputs are correct.
         /// </summary>
@@ -658,7 +668,7 @@ private bool ValidateInputs()
                 return false;
             }
 
-            // There must be a destinationFolder (either files or directory).
+            // There must be a destination (either files or directory).
             if (DestinationFiles == null && DestinationFolder == null)
             {
                 Log.LogErrorWithCodeFromResources("Copy.NeedsDestination", "DestinationFiles", "DestinationFolder");
@@ -672,6 +682,13 @@ private bool ValidateInputs()
                 return false;
             }
 
+            // SourceFolders and DestinationFiles can't be used together.
+            if (SourceFolders != null && DestinationFiles != null)
+            {
+                Log.LogErrorWithCodeFromResources("Copy.IncompatibleParameters", "SourceFolders", "DestinationFiles");
+                return false;
+            }
+
             // If the caller passed in DestinationFiles, then its length must match SourceFiles.
             if (DestinationFiles != null && DestinationFiles.Length != SourceFiles.Length)
             {
@@ -679,7 +696,6 @@ private bool ValidateInputs()
                 return false;
             }
 
-
             if (ErrorIfLinkFails && !UseHardlinksIfPossible && !UseSymboliclinksIfPossible)
             {
                 Log.LogErrorWithCodeFromResources("Copy.ErrorIfLinkFailsSetWithoutLinkOption");
@@ -691,41 +707,127 @@ private bool ValidateInputs()
 
         /// <summary>
         /// Set up our list of destination files.
+        /// For SourceFiles: Apply DestinationFolder to each SourceFiles item to create a DestinationFiles item.
+        /// For SourceFolders: With each SourceFolders item, get the files in the represented directory. Create both SourceFiles and DestinationFiles items.
         /// </summary>
         /// <returns>False if an error occurred, implying aborting the overall copy operation.</returns>
         private bool InitializeDestinationFiles()
         {
-            if (DestinationFiles == null)
+            bool isSuccess = true;
+
+            try
             {
                 // If the caller passed in DestinationFolder, convert it to DestinationFiles
-                DestinationFiles = new ITaskItem[SourceFiles.Length];
-
-                for (int i = 0; i < SourceFiles.Length; ++i)
+                if (DestinationFiles == null && SourceFiles != null)
                 {
-                    // Build the correct path.
-                    string destinationFile;
-                    try
+                    DestinationFiles = new ITaskItem[SourceFiles.Length];
+
+                    for (int i = 0; i < SourceFiles.Length; ++i)
                     {
-                        destinationFile = Path.Combine(DestinationFolder.ItemSpec, Path.GetFileName(SourceFiles[i].ItemSpec));
+                        // Build the correct path.
+                        if (!TryPathOperation(
+                                () => Path.Combine(DestinationFolder.ItemSpec, Path.GetFileName(SourceFiles[i].ItemSpec)),
+                                SourceFiles[i].ItemSpec,
+                                DestinationFolder.ItemSpec,
+                                out string destinationFile))
+                        {
+                            isSuccess = false;
+                            break;
+                        }
+
+                        // Initialize the destinationFolder item.
+                        // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to
+                        // make sure to re-escape it here.
+                        DestinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
+
+                        // Copy meta-data from source to destinationFolder.
+                        SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
                     }
-                    catch (ArgumentException e)
+                }
+
+                if (isSuccess && SourceFolders != null && SourceFolders.Length > 0)
+                {
+                    var sourceFiles = SourceFiles != null ? new List<ITaskItem>(SourceFiles) : new List<ITaskItem>();
+                    var destinationFiles = DestinationFiles != null ? new List<ITaskItem>(DestinationFiles) : new List<ITaskItem>();
+
+                    foreach (ITaskItem sourceFolder in SourceFolders)
                     {
-                        Log.LogErrorWithCodeFromResources("Copy.Error", SourceFiles[i].ItemSpec, DestinationFolder.ItemSpec, e.Message);
-                        // Clear the outputs.
-                        DestinationFiles = Array.Empty<ITaskItem>();
-                        return false;
-                    }
+                        string src = FileUtilities.NormalizePath(sourceFolder.ItemSpec);
+                        string srcName = Path.GetFileName(src);
 
-                    // Initialize the destinationFolder item.
-                    // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to 
-                    // make sure to re-escape it here. 
-                    DestinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
+                        (string[] filesInFolder, _, _) = FileMatcher.Default.GetFiles(src, "**");
 
-                    // Copy meta-data from source to destinationFolder.
-                    SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
+                        foreach (string file in filesInFolder)
+                        {
+                            if (!TryPathOperation(
+                                    () => Path.Combine(src, file),
+                                    sourceFolder.ItemSpec,
+                                    DestinationFolder.ItemSpec,
+                                    out string sourceFile))
+                            {
+                                isSuccess = false;
+                                break;
+                            }
+
+                            if (!TryPathOperation(
+                                    () => Path.Combine(DestinationFolder.ItemSpec, srcName, file),
+                                    sourceFolder.ItemSpec,
+                                    DestinationFolder.ItemSpec,
+                                    out string destinationFile))
+                            {
+                                isSuccess = false;
+                                break;
+                            }
+
+
+                            var item = new TaskItem(EscapingUtilities.Escape(sourceFile));
+                            sourceFolder.CopyMetadataTo(item);
+                            sourceFiles.Add(item);
+
+                            item = new TaskItem(EscapingUtilities.Escape(destinationFile));
+                            sourceFolder.CopyMetadataTo(item);
+                            destinationFiles.Add(item);
+                        }
+                    }
+
+                    SourceFiles = sourceFiles.ToArray();
+                    DestinationFiles = destinationFiles.ToArray();
+                }
+            }
+            finally
+            {
+                if (!isSuccess)
+                {
+                    // Clear the outputs.
+                    DestinationFiles = Array.Empty<ITaskItem>();
                 }
             }
 
+            return isSuccess;
+        }
+
+        /// <summary>
+        /// Tries the path operation. Logs a 'Copy.Error' if an exception is thrown.
+        /// </summary>
+        /// <param name="operation">The operation.</param>
+        /// <param name="src">The source to use for the log message.</param>
+        /// <param name="dest">The destination to use for the log message.</param>
+        /// <param name="resultPathOperation">The result of the path operation.</param>
+        /// <returns></returns>
+        private bool TryPathOperation(Func<string> operation, string src, string dest, out string resultPathOperation)
+        {
+            resultPathOperation = string.Empty;
+
+            try
+            {
+                resultPathOperation = operation();
+            }
+            catch (ArgumentException e)
+            {
+                Log.LogErrorWithCodeFromResources("Copy.Error", src, dest, e.Message);
+                return false;
+            }
+
             return true;
         }
 
@@ -823,23 +925,23 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                         case IOException: // Not clear why we can get one and not the other
                             int code = Marshal.GetHRForException(e);
 
-                            LogDiagnostic("Got {0} copying {1} to {2} and HR is {3}", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
+                            LogAlwaysRetryDiagnosticFromResources("Copy.IOException", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
                             if (code == NativeMethods.ERROR_ACCESS_DENIED)
                             {
                                 // ERROR_ACCESS_DENIED can either mean there's an ACL preventing us, or the file has the readonly bit set.
                                 // In either case, that's likely not a race, and retrying won't help.
                                 // Retrying is mainly for ERROR_SHARING_VIOLATION, where someone else is using the file right now.
-                                // However, there is a limited set of circumstances where a copy failure will show up as access denied due 
-                                // to a failure to reset the readonly bit properly, in which case retrying will succeed.  This seems to be 
+                                // However, there is a limited set of circumstances where a copy failure will show up as access denied due
+                                // to a failure to reset the readonly bit properly, in which case retrying will succeed.  This seems to be
                                 // a pretty edge scenario, but since some of our internal builds appear to be hitting it, provide a secret
-                                // environment variable to allow overriding the default behavior and forcing retries in this circumstance as well. 
+                                // environment variable to allow overriding the default behavior and forcing retries in this circumstance as well.
                                 if (!s_alwaysRetryCopy)
                                 {
                                     throw;
                                 }
                                 else
                                 {
-                                    LogDiagnostic("Retrying on ERROR_ACCESS_DENIED because MSBUILDALWAYSRETRY = 1");
+                                    LogAlwaysRetryDiagnosticFromResources("Copy.RetryingOnAccessDenied");
                                 }
                             }
                             else if (code == NativeMethods.ERROR_INVALID_FILENAME)
@@ -870,7 +972,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                             destinationFileState.Name, retries, RetryDelayMilliseconds, e.Message,
                             GetLockedFileMessage(destinationFileState.Name));
 
-                        // if we have to retry for some reason, wipe the state -- it may not be correct anymore. 
+                        // if we have to retry for some reason, wipe the state -- it may not be correct anymore.
                         destinationFileState.Reset();
 
                         Thread.Sleep(RetryDelayMilliseconds);
@@ -896,7 +998,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                         destinationFileState.Name, retries, RetryDelayMilliseconds, String.Empty /* no details */,
                         GetLockedFileMessage(destinationFileState.Name));
 
-                    // if we have to retry for some reason, wipe the state -- it may not be correct anymore. 
+                    // if we have to retry for some reason, wipe the state -- it may not be correct anymore.
                     destinationFileState.Reset();
 
                     Thread.Sleep(RetryDelayMilliseconds);
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index f45169c4d12..7af1e8d5105 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -49,8 +49,8 @@ protected override string CreateManifestName(
 
             /*
                 Actual implementation is in a static method called CreateManifestNameImpl.
-                The reason is that CreateManifestName can't be static because it is an 
-                override of a method declared in the base class, but its convenient 
+                The reason is that CreateManifestName can't be static because it is an
+                override of a method declared in the base class, but its convenient
                 to expose a static version anyway for unittesting purposes.
             */
             return CreateManifestNameImpl(
@@ -88,7 +88,7 @@ internal static string CreateManifestNameImpl(
             bool prependCultureAsDirectory, // true by default
             string rootNamespace, // May be null
             string dependentUponFileName, // May be null
-            string culture, // may be null 
+            string culture, // may be null
             Stream binaryStream, // File contents binary stream, may be null
             TaskLoggingHelper log,
             bool treatAsCultureNeutral = false)
@@ -103,7 +103,7 @@ internal static string CreateManifestNameImpl(
             dependentUponFileName = FileUtilities.FixFilePath(dependentUponFileName);
             Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName, treatAsCultureNeutral);
 
-            // If the item has a culture override, respect that. 
+            // If the item has a culture override, respect that.
             if (!string.IsNullOrEmpty(culture))
             {
                 info.culture = culture;
@@ -112,7 +112,7 @@ internal static string CreateManifestNameImpl(
             var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
-                // Resource depends on a form. Now, get the form's class name fully 
+                // Resource depends on a form. Now, get the form's class name fully
                 // qualified with a namespace.
                 ExtractedClassName result = CSharpParserUtilities.GetFirstClassNameFullyQualified(binaryStream);
 
@@ -125,7 +125,7 @@ internal static string CreateManifestNameImpl(
                 {
                     manifestName.Append(result.Name);
 
-                    // Append the culture if there is one.        
+                    // Append the culture if there is one.
                     if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append('.').Append(info.culture);
@@ -134,7 +134,7 @@ internal static string CreateManifestNameImpl(
             }
 
             // If there's no manifest name at this point, then fall back to using the
-            // RootNamespace+Filename_with_slashes_converted_to_dots         
+            // RootNamespace+Filename_with_slashes_converted_to_dots
             if (manifestName.Length == 0)
             {
                 // If Rootnamespace was null, then it wasn't set from the project resourceFile.
@@ -169,7 +169,7 @@ internal static string CreateManifestNameImpl(
                     manifestName.Replace(Path.DirectorySeparatorChar, '.');
                     manifestName.Replace(Path.AltDirectorySeparatorChar, '.');
 
-                    // Append the culture if there is one.        
+                    // Append the culture if there is one.
                     if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append('.').Append(info.culture);
@@ -196,7 +196,7 @@ internal static string CreateManifestNameImpl(
 
                     if (prependCultureAsDirectory)
                     {
-                        // Prepend the culture as a subdirectory if there is one.        
+                        // Prepend the culture as a subdirectory if there is one.
                         if (!string.IsNullOrEmpty(info.culture))
                         {
                             manifestName.Insert(0, Path.DirectorySeparatorChar);
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index 78f30146616..46c8bd99c20 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -29,7 +29,7 @@ public class CreateItem : TaskExtension
         public bool PreserveExistingMetadata { get; set; } = false;
 
         /// <summary>
-        /// A list of metadata name/value pairs to apply to the output items.  
+        /// A list of metadata name/value pairs to apply to the output items.
         /// A typical input: "metadataname1=metadatavalue1", "metadataname2=metadatavalue2", ...
         /// </summary>
         /// <remarks>
@@ -38,7 +38,7 @@ public class CreateItem : TaskExtension
         ///     The fact that this is a `string[]` makes the following illegal:
         ///         `<CreateItem AdditionalMetadata="TargetPath=@(OutputPathItem)" />`
         ///     The engine fails on this because it doesn't like item lists being concatenated with string
-        ///     constants when the data is being passed into an array parameter.  So the workaround is to 
+        ///     constants when the data is being passed into an array parameter.  So the workaround is to
         ///     write this in the project file:
         ///         `<CreateItem AdditionalMetadata="@(OutputPathItem-&gt;'TargetPath=%(Identity)')" />`
         ///     ]]>
@@ -118,7 +118,7 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
                             {
                                 if (FileUtilities.ItemSpecModifiers.IsItemSpecModifier(nameAndValue.Key))
                                 {
-                                    // Explicitly setting built-in metadata, is not allowed. 
+                                    // Explicitly setting built-in metadata, is not allowed.
                                     Log.LogErrorWithCodeFromResources("CreateItem.AdditionalMetadataError", nameAndValue.Key);
                                     break;
                                 }
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index 4d67448ef78..818e984b1fb 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Base class for task that determines the appropriate manifest resource name to 
+    /// Base class for task that determines the appropriate manifest resource name to
     /// assign to a given resx or other resource.
     /// </summary>
     public abstract class CreateManifestResourceName : TaskExtension
@@ -229,8 +229,8 @@ internal bool Execute(
                     ResourceFilesWithManifestResourceNames[i].SetMetadata("ManifestResourceName", manifestName);
 
                     // Add a LogicalName metadata to Non-Resx resources
-                    // LogicalName isn't used for Resx resources because the ManifestResourceName metadata determines the filename of the 
-                    // .resources file which then is used as the embedded resource manifest name                    
+                    // LogicalName isn't used for Resx resources because the ManifestResourceName metadata determines the filename of the
+                    // .resources file which then is used as the embedded resource manifest name
                     if (string.IsNullOrEmpty(ResourceFilesWithManifestResourceNames[i].GetMetadata("LogicalName")) &&
                         string.Equals(ResourceFilesWithManifestResourceNames[i].GetMetadata("Type"), "Non-Resx", StringComparison.OrdinalIgnoreCase))
                     {
@@ -291,7 +291,7 @@ private static bool IsValidEverettIdChar(char c)
         }
 
         /// <summary>
-        /// Make a folder subname into an Everett-compatible identifier 
+        /// Make a folder subname into an Everett-compatible identifier
         /// </summary>
         private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName)
         {
diff --git a/src/Tasks/CreateProperty.cs b/src/Tasks/CreateProperty.cs
index a06e4b5a384..7980feb2d14 100644
--- a/src/Tasks/CreateProperty.cs
+++ b/src/Tasks/CreateProperty.cs
@@ -19,19 +19,19 @@ public class CreateProperty : TaskExtension
         /// <remarks>
         /// So ... why is this a string[] instead of a string?
         /// Basically if the project author passed in:
-        /// 
+        ///
         ///         CreateProperty Value="Clean;Build"
         ///             Output TaskParameter="Value" PropertyName="MyTargetsToBuild"
         ///         /CreateProperty
-        /// 
+        ///
         /// We need to respect the semicolon that they put in the value, and need to treat
         /// this exactly as if they had done:
-        /// 
+        ///
         ///         PropertyGroup
         ///             MyTargetsToBuild="Clean;Build"
         ///         /PropertyGroup
-        /// 
-        /// If we make this parameter a "string", then the engine will escape the 
+        ///
+        /// If we make this parameter a "string", then the engine will escape the
         /// value on the way out from the task back to the engine, creating a property
         /// that is set to "Clean%3BBuild", which is not what the user wanted.
         /// </remarks>
@@ -39,7 +39,7 @@ public class CreateProperty : TaskExtension
         public string[] Value { get; set; }
 
         /// <summary>
-        /// This is to fool MSBuild into not doing its little TLDA trick whereby even if 
+        /// This is to fool MSBuild into not doing its little TLDA trick whereby even if
         /// a target is up-to-date, it will still set the properties that were meant to
         /// be set using the CreateProperty task.  This is because MSBuild is smart enough
         /// to figure out the value of the output property without running the task.
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 9b02e0109bc..b73a9a9f41d 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -48,8 +48,8 @@ protected override string CreateManifestName(
 
             /*
                 Actual implementation is in a static method called CreateManifestNameImpl.
-                The reason is that CreateManifestName can't be static because it is an 
-                override of a method declared in the base class, but its convenient 
+                The reason is that CreateManifestName can't be static because it is an
+                override of a method declared in the base class, but its convenient
                 to expose a static version anyway for unittesting purposes.
             */
             return CreateManifestNameImpl(
@@ -101,7 +101,7 @@ internal static string CreateManifestNameImpl(
 
             Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName, treatAsCultureNeutral);
 
-            // If the item has a culture override, respect that. 
+            // If the item has a culture override, respect that.
             if (!string.IsNullOrEmpty(culture))
             {
                 info.culture = culture;
@@ -110,7 +110,7 @@ internal static string CreateManifestNameImpl(
             var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
-                // Resource depends on a form. Now, get the form's class name fully 
+                // Resource depends on a form. Now, get the form's class name fully
                 // qualified with a namespace.
                 ExtractedClassName result = VisualBasicParserUtilities.GetFirstClassNameFullyQualified(binaryStream);
 
@@ -129,7 +129,7 @@ internal static string CreateManifestNameImpl(
                     manifestName.Append(result.Name);
 
 
-                    // Append the culture if there is one.        
+                    // Append the culture if there is one.
                     if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append('.').Append(info.culture);
@@ -159,7 +159,7 @@ internal static string CreateManifestNameImpl(
                 {
                     manifestName.Append(Path.GetFileNameWithoutExtension(info.cultureNeutralFilename));
 
-                    // Append the culture if there is one.        
+                    // Append the culture if there is one.
                     if (!string.IsNullOrEmpty(info.culture))
                     {
                         manifestName.Append('.').Append(info.culture);
@@ -177,7 +177,7 @@ internal static string CreateManifestNameImpl(
 
                     if (prependCultureAsDirectory)
                     {
-                        // Prepend the culture as a subdirectory if there is one.        
+                        // Prepend the culture as a subdirectory if there is one.
                         if (!string.IsNullOrEmpty(info.culture))
                         {
                             manifestName.Insert(0, Path.DirectorySeparatorChar);
diff --git a/src/Tasks/DataDriven/DataDrivenToolTask.cs b/src/Tasks/DataDriven/DataDrivenToolTask.cs
index 49e1f88988a..444f2f6dba0 100644
--- a/src/Tasks/DataDriven/DataDrivenToolTask.cs
+++ b/src/Tasks/DataDriven/DataDrivenToolTask.cs
@@ -80,7 +80,7 @@ protected Dictionary<string, ToolSwitch> ActiveToolSwitches
                 return activeToolSwitches;
             }
         }
-        
+
         /// <summary>
         /// The additional options that have been set. These are raw switches that
         /// go last on the command line.
@@ -98,13 +98,13 @@ public string AdditionalOptions
         }
 
         /// <summary>
-        /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc. 
+        /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc.
         /// </summary>
         protected override Encoding ResponseFileEncoding
         {
-            get 
-            { 
-                return Encoding.Unicode; 
+            get
+            {
+                return Encoding.Unicode;
             }
         }
 
@@ -155,7 +155,7 @@ protected override string GenerateFullPathToTool()
         /// <returns></returns>
         override protected bool ValidateParameters()
         {
-            return !logPrivate.HasLoggedErrors && !Log.HasLoggedErrors; 
+            return !logPrivate.HasLoggedErrors && !Log.HasLoggedErrors;
         }
 
 #if WHIDBEY_BUILD
@@ -174,7 +174,7 @@ protected void DeleteTempFile(string fileName)
             {
                 if (ExceptionHandling.NotExpectedException(e))
                     throw;
-                // Warn only -- occasionally temp files fail to delete because of virus checkers; we 
+                // Warn only -- occasionally temp files fail to delete because of virus checkers; we
                 // don't want the build to fail in such cases
                 Log.LogWarningWithCodeFromResources("Shared.FailedDeletingTempFile", fileName, e.Message);
             }
@@ -187,7 +187,7 @@ protected void DeleteTempFile(string fileName)
         /// Returns the generated command line
         /// </summary>
         /// <returns></returns>
-        internal string GetCommandLine_ForUnitTestsOnly() 
+        internal string GetCommandLine_ForUnitTestsOnly()
         {
             return GenerateResponseFileCommands();
         }
@@ -209,7 +209,7 @@ protected override string GenerateCommandLineCommands()
         /// Creates the command line and returns it as a string by:
         /// 1. Adding all switches with the default set to the active switch list
         /// 2. Customizing the active switch list (overridden in derived classes)
-        /// 3. Iterating through the list and appending switches 
+        /// 3. Iterating through the list and appending switches
         /// </summary>
         /// <returns></returns>
         protected override string GenerateResponseFileCommands()
@@ -242,7 +242,7 @@ protected virtual bool VerifyRequiredArgumentsArePresent(ToolSwitch property, bo
         /// <returns></returns>
         protected virtual bool VerifyDependenciesArePresent(ToolSwitch property)
         {
-            // check the dependency 
+            // check the dependency
             if (property.Parents.Count > 0)
             {
                 // has a dependency, now check to see whether at least one parent is set
@@ -435,11 +435,11 @@ private string GenerateCommands()
         }
 
         /// <summary>
-        /// Checks to see if the argument is required and whether an argument exists, and returns the 
+        /// Checks to see if the argument is required and whether an argument exists, and returns the
         /// argument or else fallback argument if it exists.
-        /// 
+        ///
         /// These are the conditions to look at:
-        /// 
+        ///
         /// ArgumentRequired    ArgumentParameter   FallbackArgumentParameter   Result
         /// true                isSet               NA                          The value in ArgumentParameter gets returned
         /// true                isNotSet            isSet                       The value in FallbackArgumentParamter gets returned
@@ -452,7 +452,7 @@ private string GenerateCommands()
         /// <returns></returns>
         protected virtual string GetEffectiveArgumentsValues(ToolSwitch toolSwitch)
         {
-            //if (!toolSwitch.ArgumentRequired && !IsPropertySet(toolSwitch.ArgumentParameter) && 
+            //if (!toolSwitch.ArgumentRequired && !IsPropertySet(toolSwitch.ArgumentParameter) &&
             //    !IsPropertySet(toolSwitch.FallbackArgumentParameter))
             //{
             //    return String.Empty;
@@ -519,7 +519,7 @@ private static void EmitFileSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch
                         str += "\"";
                 }
 
-                //we want quotes always, AppendSwitchIfNotNull will add them on as needed bases 
+                //we want quotes always, AppendSwitchIfNotNull will add them on as needed bases
                 clb.AppendSwitchUnquotedIfNotNull(toolSwitch.SwitchValue + toolSwitch.Separator, str);
             }
         }
@@ -552,10 +552,10 @@ private void EmitIntegerSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch)
         /// The switch may be empty.
         /// </summary>
         /// <remarks>For stringarray switches (e.g., Sources), the toolSwitchName (if it exists) is emitted
-        /// along with each and every one of the file names separately (if no separator is included), or with all of the 
+        /// along with each and every one of the file names separately (if no separator is included), or with all of the
         /// file names separated by the separator.
         /// e.g., AdditionalIncludeDirectores = "@(Files)" where Files has File1, File2, and File3, the switch
-        /// /IFile1 /IFile2 /IFile3 or the switch /IFile1;File2;File3 is emitted (the latter case has a separator 
+        /// /IFile1 /IFile2 /IFile3 or the switch /IFile1;File2;File3 is emitted (the latter case has a separator
         /// ";" specified)</remarks>
         /// <param name="clb"></param>
         /// <param name="toolSwitch"></param>
@@ -564,7 +564,7 @@ private static void EmitStringArraySwitch(CommandLineBuilder clb, ToolSwitch too
             string[] ArrTrimStringList = new string [toolSwitch.StringList.Length];
             for (int i=0; i<toolSwitch.StringList.Length; ++i)
             {
-                //Make sure the file doesn't contain escaped " (\") 
+                //Make sure the file doesn't contain escaped " (\")
                 if (toolSwitch.StringList[i].StartsWith("\"") && toolSwitch.StringList[i].EndsWith("\""))
                 {
                     ArrTrimStringList[i] = toolSwitch.StringList[i].Substring(1, toolSwitch.StringList[i].Length - 2);
@@ -589,7 +589,7 @@ private static void EmitStringArraySwitch(CommandLineBuilder clb, ToolSwitch too
         }
 
         /// <summary>
-        /// Generates the switches for switches that either have literal strings appended, or have 
+        /// Generates the switches for switches that either have literal strings appended, or have
         /// different switches based on what the property is set to.
         /// </summary>
         /// <remarks>The string switch emits a switch that depends on what the parameter is set to, with and
@@ -601,7 +601,7 @@ private void EmitStringSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch)
         {
             String strSwitch = String.Empty;
             strSwitch += toolSwitch.SwitchValue + toolSwitch.Separator;
-            
+
             StringBuilder val = new StringBuilder(GetEffectiveArgumentsValues(toolSwitch));
             String str = toolSwitch.Value;
 
@@ -625,7 +625,7 @@ private void EmitStringSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch)
                 return;
 
             clb.AppendSwitchUnquotedIfNotNull(strSwitch, val.ToString());
-            
+
         }
 
         /// <summary>
@@ -655,7 +655,7 @@ private void EmitBooleanSwitch(CommandLineBuilder clb, ToolSwitch toolSwitch)
         /// <summary>
         /// Generates the command line for switches that are reversible
         /// </summary>
-        /// <remarks>A reversible boolean switch will emit a certain switch if set to true, but emit that 
+        /// <remarks>A reversible boolean switch will emit a certain switch if set to true, but emit that
         /// exact same switch with a flag appended on the end if set to false.
         /// e.g., GlobalOptimizations = "true" will emit /Og, and GlobalOptimizations = "false" will emit /Og-</remarks>
         /// <param name="clb"></param>
@@ -710,9 +710,9 @@ protected bool ValidateInteger(string switchName, int min, int max, int value)
                 logPrivate.LogErrorFromResources("ArgumentOutOfRange", switchName, value);
                 return false;
             }
-           
+
             return true;
-            
+
         }
 
         /// <summary>
@@ -785,7 +785,7 @@ protected bool IsExplicitlySetToFalse(string propertyName)
                 return false;
             }
         }
-        
+
         /// <summary>
         /// Checks to see if the switch name is empty
         /// </summary>
diff --git a/src/Tasks/Delegate.cs b/src/Tasks/Delegate.cs
index f3c37bd0023..b315d29426b 100644
--- a/src/Tasks/Delegate.cs
+++ b/src/Tasks/Delegate.cs
@@ -80,7 +80,7 @@ namespace Microsoft.Build.Tasks
     internal delegate string GetPathFromFusionName(string strongName);
 
     /// <summary>
-    /// Delegate. Given an assembly name, crack it open and retrieve the list of dependent 
+    /// Delegate. Given an assembly name, crack it open and retrieve the list of dependent
     /// assemblies and  the list of scatter files.
     /// </summary>
     /// <param name="path">Path to the assembly.</param>
@@ -106,7 +106,7 @@ internal delegate void GetAssemblyMetadata(
     internal delegate string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, System.Reflection.ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion);
 
     /// <summary>
-    /// Determines if a assembly is an winmd file 
+    /// Determines if a assembly is an winmd file
     /// </summary>
     internal delegate bool IsWinMDFile(string fullpath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, out string imageRuntimeVersion, out bool isManagedWinmd);
 
diff --git a/src/Tasks/Delete.cs b/src/Tasks/Delete.cs
index 0dbe2f78609..55e935ee475 100644
--- a/src/Tasks/Delete.cs
+++ b/src/Tasks/Delete.cs
@@ -123,15 +123,15 @@ public override bool Execute()
                         {
                             if (FailIfNotIncremental)
                             {
-                                Log.LogErrorFromResources("Delete.DeletingFile", file.ItemSpec);
+                                Log.LogWarningFromResources("Delete.DeletingFile", file.ItemSpec);
                             }
                             else
                             {
                                 // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                                 Log.LogMessageFromResources(MessageImportance.Normal, "Delete.DeletingFile", file.ItemSpec);
-
-                                File.Delete(file.ItemSpec);
                             }
+
+                            File.Delete(file.ItemSpec);
                         }
                         else
                         {
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index 9908267c4a8..a5a2c3ec528 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -25,7 +25,7 @@ internal class DependencyFile
         // Filename
         internal string filename;
 
-        // Date and time the file was last modified           
+        // Date and time the file was last modified
         internal DateTime lastModified;
 
         // Whether the file exists or not.
diff --git a/src/Tasks/ErrorFromResources.cs b/src/Tasks/ErrorFromResources.cs
index b143db2d35e..a95a8ca2fd6 100644
--- a/src/Tasks/ErrorFromResources.cs
+++ b/src/Tasks/ErrorFromResources.cs
@@ -33,7 +33,7 @@ public sealed class ErrorFromResources : TaskExtension
 
         /// <summary>
         /// Relevant file if any.
-        /// If none is provided, the file containing the Error 
+        /// If none is provided, the file containing the Error
         /// task will be used.
         /// </summary>
         public string File { get; set; }
@@ -52,7 +52,7 @@ public override bool Execute()
             {
                 string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, Log.FormatResourceString(Resource, Arguments), out string errorCode);
 
-                // If the user specifies a code, that should override. 
+                // If the user specifies a code, that should override.
                 Code ??= errorCode;
 
                 Log.LogError(null, Code, HelpKeyword, File, 0, 0, 0, 0, message);
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index dbf4be1fc51..9faaa688874 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -591,7 +591,12 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
             {
                 commandLine.AppendSwitch("-c");
                 commandLine.AppendTextUnquoted(" \"");
-                commandLine.AppendTextUnquoted("export LANG=en_US.UTF-8; export LC_ALL=en_US.UTF-8; . ");
+                bool setLocale = !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10);
+                if (setLocale)
+                {
+                    commandLine.AppendTextUnquoted("export LANG=en_US.UTF-8; export LC_ALL=en_US.UTF-8; ");
+                }
+                commandLine.AppendTextUnquoted(". ");
                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);
                 commandLine.AppendTextUnquoted("\"");
             }
diff --git a/src/Tasks/FileIO/ReadLinesFromFile.cs b/src/Tasks/FileIO/ReadLinesFromFile.cs
index ead4981ecfe..86b5ca17068 100644
--- a/src/Tasks/FileIO/ReadLinesFromFile.cs
+++ b/src/Tasks/FileIO/ReadLinesFromFile.cs
@@ -57,7 +57,7 @@ public override bool Execute()
                             if (trimmedTextLine.Length > 0)
                             {
                                 // The lines were written to the file in unescaped form, so we need to escape them
-                                // before passing them to the TaskItem. 
+                                // before passing them to the TaskItem.
                                 nonEmptyLines.Add(new TaskItem(EscapingUtilities.Escape(trimmedTextLine)));
                             }
                         }
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index 9b94858fc12..33c272c6987 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -51,9 +51,11 @@ public class WriteLinesToFile : TaskExtension, IIncrementalTask
         /// <summary>
         /// Question whether this task is incremental.
         /// </summary>
-        /// <remarks>When question is true, then this task would not write to disk.  If CanBeIncremental is true, then error out.</remarks>
+        /// <remarks>When question is true, then error out if WriteOnlyWhenDifferent would have
+        /// written to the file.</remarks>
         public bool FailIfNotIncremental { get; set; }
 
+        [Obsolete]
         public bool CanBeIncremental => WriteOnlyWhenDifferent;
 
         /// <summary>
@@ -69,7 +71,7 @@ public override bool Execute()
                 // do not return if Lines is null, because we may
                 // want to delete the file in that case
                 StringBuilder buffer = new StringBuilder();
-                if (Lines != null && (!FailIfNotIncremental || WriteOnlyWhenDifferent))
+                if (Lines != null)
                 {
                     foreach (ITaskItem line in Lines)
                     {
@@ -131,36 +133,17 @@ public override bool Execute()
                             MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, false);
                         }
 
-                        if (FailIfNotIncremental)
-                        {
-                            if (Lines?.Length > 0)
-                            {
-                                Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
-                                return false;
-                            }
-                        }
-                        else
-                        {
-                            System.IO.File.WriteAllText(File.ItemSpec, contentsAsString, encoding);
-                        }
+                        System.IO.File.WriteAllText(File.ItemSpec, contentsAsString, encoding);
                     }
                     else
                     {
-                        if (FailIfNotIncremental && Lines?.Length > 0)
+                        if (WriteOnlyWhenDifferent)
                         {
-                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorOrWarning", File.ItemSpec, string.Empty);
-                            return false;
+                            Log.LogMessageFromResources(MessageImportance.Normal, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
                         }
-                        else
-                        {
-                            if (WriteOnlyWhenDifferent)
-                            {
-                                Log.LogMessageFromResources(MessageImportance.Normal, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
-                            }
 
-                            Directory.CreateDirectory(directoryPath);
-                            System.IO.File.AppendAllText(File.ItemSpec, buffer.ToString(), encoding);
-                        }
+                        Directory.CreateDirectory(directoryPath);
+                        System.IO.File.AppendAllText(File.ItemSpec, buffer.ToString(), encoding);
                     }
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index 4e00e4af725..17cb7ca702c 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.Tasks
 {
     /// <summary>
     /// CopyFile delegate
-    /// 
+    ///
     /// returns  Success = true, Failure = false; Retry = null
     /// </summary>
     /// <param name="source">Source file</param>
@@ -26,7 +26,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     /// <remarks>
     /// Uses PInvoke rather than FileInfo because the latter does all kinds of expensive checks.
-    /// 
+    ///
     /// Deficiency: some of the properties eat some or all exceptions. If they are called first, they will
     /// trigger the population and eat. Subsequent calls will then not throw, but instead eg return zero.
     /// This could be fixed by storing the exception from the population, and throwing no matter who does
@@ -92,7 +92,7 @@ public FileDirInfo(string filename)
                     // THIS COPIED FROM THE BCL:
                     //
                     // For floppy drives, normally the OS will pop up a dialog saying
-                    // there is no disk in drive A:, please insert one.  We don't want that. 
+                    // there is no disk in drive A:, please insert one.  We don't want that.
                     // SetErrorMode will let us disable this, but we should set the error
                     // mode back, since this may have wide-ranging effects.
                     NativeMethodsShared.SetThreadErrorMode(1 /* ErrorModes.SEM_FAILCRITICALERRORS */, out oldMode);
diff --git a/src/Tasks/FindInList.cs b/src/Tasks/FindInList.cs
index 6ce91dcfd3b..214d4dccebc 100644
--- a/src/Tasks/FindInList.cs
+++ b/src/Tasks/FindInList.cs
@@ -57,7 +57,7 @@ public ITaskItem[] List
         public bool CaseSensitive { get; set; }
 
         /// <summary>
-        /// Whether or not to return the last match, instead of 
+        /// Whether or not to return the last match, instead of
         /// the first one
         /// </summary>
         public bool FindLastMatch { get; set; }
diff --git a/src/Tasks/FindInvalidProjectReferences.cs b/src/Tasks/FindInvalidProjectReferences.cs
index 7342f60e6f4..791ac147af6 100644
--- a/src/Tasks/FindInvalidProjectReferences.cs
+++ b/src/Tasks/FindInvalidProjectReferences.cs
@@ -62,7 +62,7 @@ public class FindInvalidProjectReferences : TaskExtension
         public string TargetPlatformIdentifier { get; set; }
 
         /// <summary>
-        /// Invalid references to be unresolved 
+        /// Invalid references to be unresolved
         /// </summary>
         [Output]
         public ITaskItem[] InvalidReferences { get; private set; }
@@ -87,7 +87,7 @@ public override bool Execute()
                     string referenceIdentity = item.ItemSpec;
                     string referencePlatformMoniker = item.GetMetadata(ReferencePlatformMonikerMetadata);
 
-                    // For each moniker, compare version, issue localized message if the referenced project targets 
+                    // For each moniker, compare version, issue localized message if the referenced project targets
                     // a platform with version higher than the current project and make the reference invalid by adding it to
                     // an invalid reference list output
                     if (ParseMoniker(referencePlatformMoniker, out _, out Version version))
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index 56424601861..1c32b6feb36 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -383,7 +383,7 @@ protected internal override bool ValidateInputs()
 
         private bool BuildResolvedSettings(ApplicationManifest manifest)
         {
-            // Note: if changing the logic in this function, please update the logic in 
+            // Note: if changing the logic in this function, please update the logic in
             //  GenerateDeploymentManifest.BuildResolvedSettings as well.
             if (Product != null)
             {
diff --git a/src/Tasks/GenerateBootstrapper.cs b/src/Tasks/GenerateBootstrapper.cs
index 7eb63e1e8e0..28c019d7ef9 100644
--- a/src/Tasks/GenerateBootstrapper.cs
+++ b/src/Tasks/GenerateBootstrapper.cs
@@ -1,20 +1,25 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.Deployment.Bootstrapper;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Generates a bootstrapper for ClickOnce deployment projects.
     /// </summary>
-    public sealed class GenerateBootstrapper : TaskExtension
+    public sealed class GenerateBootstrapper : TaskExtension, IGenerateBootstrapperTaskContract
     {
         public string ApplicationName { get; set; }
 
@@ -93,12 +98,12 @@ public override bool Execute()
 
             if (BootstrapperItems != null)
             {
-                // The bootstrapper items may not be in the correct order, because XMake saves 
-                // items in alphabetical order.  So we will attempt to put items into the correct 
-                // order, according to the Products order in the search.  To do this, we add all 
-                // the items we are told to build into a hashtable, then go through our products 
-                // in order, looking to see if the item is built.  If it is, remove the item from 
-                // the hashtable.  All remaining items in the table can not be built, so errors 
+                // The bootstrapper items may not be in the correct order, because XMake saves
+                // items in alphabetical order.  So we will attempt to put items into the correct
+                // order, according to the Products order in the search.  To do this, we add all
+                // the items we are told to build into a hashtable, then go through our products
+                // in order, looking to see if the item is built.  If it is, remove the item from
+                // the hashtable.  All remaining items in the table can not be built, so errors
                 // will be issued.
                 var items = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
 
@@ -174,4 +179,81 @@ private ComponentsLocation ConvertStringToComponentsLocation(string parameterVal
             }
         }
     }
+
+#else
+
+    public sealed class GenerateBootstrapper : TaskRequiresFramework, IGenerateBootstrapperTaskContract
+    {
+        public GenerateBootstrapper()
+            : base(nameof(GenerateBootstrapper))
+        {
+        }
+
+        #region Properties
+
+        public string ApplicationName { get; set; }
+
+        public string ApplicationFile { get; set; }
+
+        public bool ApplicationRequiresElevation { get; set; }
+
+        public string ApplicationUrl { get; set; }
+
+        public ITaskItem[] BootstrapperItems { get; set; }
+
+        public string ComponentsLocation { get; set; }
+
+        public string ComponentsUrl { get; set; }
+
+        public bool CopyComponents { get; set; }
+
+        public string Culture { get; set; }
+
+        public string FallbackCulture { get; set; }
+
+        public string OutputPath { get; set; }
+
+        public string Path { get; set; }
+
+        public string SupportUrl { get; set; }
+
+        public string VisualStudioVersion { get; set; }
+
+        public bool Validate { get; set; }
+
+        [Output]
+        public string BootstrapperKeyFile { get; set; }
+
+        [Output]
+        public string[] BootstrapperComponentFiles { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IGenerateBootstrapperTaskContract
+    {
+        #region Properties
+
+        string ApplicationName { get; set; }
+        string ApplicationFile { get; set; }
+        bool ApplicationRequiresElevation { get; set; }
+        string ApplicationUrl { get; set; }
+        ITaskItem[] BootstrapperItems { get; set; }
+        string ComponentsLocation { get; set; }
+        string ComponentsUrl { get; set; }
+        bool CopyComponents { get; set; }
+        string Culture { get; set; }
+        string FallbackCulture { get; set; }
+        string OutputPath { get; set; }
+        string Path { get; set; }
+        string SupportUrl { get; set; }
+        string VisualStudioVersion { get; set; }
+        bool Validate { get; set; }
+        string BootstrapperKeyFile { get; set; }
+        string[] BootstrapperComponentFiles { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/GenerateDeploymentManifest.cs b/src/Tasks/GenerateDeploymentManifest.cs
index 729deffab5c..897ba49d15f 100644
--- a/src/Tasks/GenerateDeploymentManifest.cs
+++ b/src/Tasks/GenerateDeploymentManifest.cs
@@ -125,7 +125,7 @@ public int UpdateInterval
 
         private bool BuildResolvedSettings(DeployManifest manifest)
         {
-            // Note: if changing the logic in this function, please update the logic in 
+            // Note: if changing the logic in this function, please update the logic in
             //  GenerateApplicationManifest.BuildResolvedSettings as well.
             if (Product != null)
             {
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 3c198c1d512..572a19ea3bb 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -714,18 +714,34 @@ public override bool Execute()
 
                 GetResourcesToProcess(out inputsToProcess, out outputsToProcess, out cachedOutputFiles);
 
-                if (inputsToProcess.Count == 0 && !Log.HasLoggedErrors)
+                if (inputsToProcess.Count == 0)
                 {
-                    if (cachedOutputFiles.Count > 0)
+                    if (!Log.HasLoggedErrors)
                     {
-                        OutputResources = cachedOutputFiles.ToArray();
-                    }
+                        if (cachedOutputFiles.Count > 0)
+                        {
+                            OutputResources = cachedOutputFiles.ToArray();
+                        }
 
-                    Log.LogMessageFromResources("GenerateResource.NothingOutOfDate");
+                        Log.LogMessageFromResources("GenerateResource.NothingOutOfDate");
+                    }
+                    else
+                    {
+                        // No valid sources found--failures should have been logged in GetResourcesToProcess
+                        return false;
+                    }
                 }
                 else if (FailIfNotIncremental)
                 {
-                    Log.LogErrorFromResources("GenerateResource.OutOfDate");
+                    int maxCount = Math.Min(inputsToProcess.Count, outputsToProcess.Count);
+                    maxCount = Math.Min(maxCount, 5);  // Limit to just 5
+
+                    for (int index = 0; index < maxCount; index++)
+                    {
+                        Log.LogErrorFromResources("GenerateResource.ProcessingFile", inputsToProcess[index], outputsToProcess[index]);
+                    }
+
+                    return false;
                 }
                 else
                 {
@@ -3605,6 +3621,7 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                         name.Length--;
                     }
                     ch = sr.Read(); // move past =
+
                     // If it exists, move past the first space after the equals sign.
                     if (ch == ' ')
                     {
@@ -3746,10 +3763,11 @@ private void WriteResources(ReaderInfo reader,
                     // In that case, the first time we catch an exception indicating that the XML written to disk is malformed,
                     // specifically an InvalidOperationException: "Token EndElement in state Error would result in an invalid XML document."
                     try { writer.Dispose(); }
-                    catch (Exception) { } // We agressively catch all exception types since we already have one we will throw.
+                    catch (Exception) { } // We aggressively catch all exception types since we already have one we will throw.
+
                     // The second time we catch the out of disk space exception.
                     try { writer.Dispose(); }
-                    catch (Exception) { } // We agressively catch all exception types since we already have one we will throw.
+                    catch (Exception) { } // We aggressively catch all exception types since we already have one we will throw.
                     throw capturedException; // In the event of a full disk, this is an out of disk space IOException.
                 }
             }
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index e6a6a1d43cc..7d76056879b 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -1,21 +1,27 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// This task generates the application trust from the base manifest
     /// and the TargetZone and ExcludedPermissions properties.
     /// </summary>
-    public sealed class GenerateTrustInfo : TaskExtension
+    public sealed class GenerateTrustInfo : TaskExtension, IGenerateTrustInfoTaskContract
     {
         private const string Custom = "Custom";
 
@@ -98,4 +104,47 @@ public override bool Execute()
             return true;
         }
     }
+
+#else
+
+    public sealed class GenerateTrustInfo : TaskRequiresFramework, IGenerateTrustInfoTaskContract
+    {
+        public GenerateTrustInfo()
+            : base(nameof(GenerateTrustInfo))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem BaseManifest { get; set; }
+
+        public string ExcludedPermissions { get; set; }
+
+        public string TargetFrameworkMoniker { get; set; }
+
+        public string TargetZone { get; set; }
+
+        public ITaskItem[] ApplicationDependencies { get; set; }
+
+        [Output]
+        public ITaskItem TrustInfoFile { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IGenerateTrustInfoTaskContract
+    {
+        #region Properties
+
+        ITaskItem BaseManifest { get; set; }
+        string ExcludedPermissions { get; set; }
+        string TargetFrameworkMoniker { get; set; }
+        string TargetZone { get; set; }
+        ITaskItem[] ApplicationDependencies { get; set; }
+        ITaskItem TrustInfoFile { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/GetAssembliesMetadata.cs b/src/Tasks/GetAssembliesMetadata.cs
new file mode 100644
index 00000000000..d5f67c62f36
--- /dev/null
+++ b/src/Tasks/GetAssembliesMetadata.cs
@@ -0,0 +1,123 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using System.Globalization;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.Versioning;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Tasks.AssemblyDependency;
+using Microsoft.Build.Utilities;
+
+#nullable enable
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Resolves metadata for the specified set of assemblies.
+    /// </summary>
+    [SupportedOSPlatform("windows")]
+    public class GetAssembliesMetadata : TaskExtension
+    {
+        /// <summary>
+        /// Assembly paths.
+        /// </summary>
+        private string[] _assemblyPaths = Array.Empty<string>();
+
+        /// <summary>
+        /// Set of resolved assembly metadata.
+        /// </summary>
+        private ITaskItem[] _assembliesMetadata = Array.Empty<ITaskItem>();
+
+        /// <summary>
+        /// Execute the task.
+        /// </summary>
+        public override bool Execute()
+        {
+            var assembliesMetadata = new List<ITaskItem>();
+            foreach (string assemblyPath in AssemblyPaths)
+            {
+                // During DTB the referenced project may not has been built yet, so we need to check if the assembly already exists.
+                if (File.Exists(assemblyPath))
+                {
+                    AssemblyInformation assemblyInformation = new(assemblyPath);
+                    AssemblyAttributes attributes = assemblyInformation.GetAssemblyMetadata();
+
+                    if (attributes != null)
+                    {
+                        assembliesMetadata.Add(CreateItemWithMetadata(attributes));
+                    }
+                }
+            }
+
+            _assembliesMetadata = assembliesMetadata.ToArray();
+
+            return true;
+        }
+
+        /// <summary>
+        /// List of assembly paths.
+        /// </summary>
+        [Required]
+        public string[] AssemblyPaths
+        {
+            get => _assemblyPaths;
+
+            set
+            {
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(AssemblyPaths));
+                _assemblyPaths = value;
+            }
+        }
+
+        /// <summary>
+        /// Gets a list of resolved assembly metadata.
+        /// </summary>
+        [Output]
+        public ITaskItem[] AssembliesMetadata => _assembliesMetadata;
+
+        /// <summary>
+        /// Creates a TaskItem and populates it with the given assembly attributes.
+        /// </summary>
+        private TaskItem CreateItemWithMetadata(AssemblyAttributes attributes)
+        {
+            TaskItem referenceItem = new()
+            {
+                ItemSpec = attributes.AssemblyFullPath,
+            };
+
+            IMetadataContainer referenceItemAsMetadataContainer = referenceItem;
+            referenceItemAsMetadataContainer.ImportMetadata(EnumerateCommonMetadata());
+
+            return referenceItem;
+
+            IEnumerable<KeyValuePair<string, string>> EnumerateCommonMetadata()
+            {
+                yield return new KeyValuePair<string, string>(nameof(attributes.AssemblyName), attributes.AssemblyName);
+                yield return new KeyValuePair<string, string>(nameof(attributes.RuntimeVersion), attributes.RuntimeVersion);
+                yield return new KeyValuePair<string, string>(nameof(attributes.RevisionNumber), attributes.RevisionNumber.ToString());
+                yield return new KeyValuePair<string, string>(nameof(attributes.BuildNumber), attributes.BuildNumber.ToString());
+                yield return new KeyValuePair<string, string>(nameof(attributes.Culture), attributes.Culture);
+                yield return new KeyValuePair<string, string>(nameof(attributes.DefaultAlias), attributes.DefaultAlias);
+                yield return new KeyValuePair<string, string>(nameof(attributes.Description), attributes.Description);
+                yield return new KeyValuePair<string, string>(nameof(attributes.MajorVersion), attributes.MajorVersion.ToString());
+                yield return new KeyValuePair<string, string>(nameof(attributes.MinorVersion), attributes.MinorVersion.ToString());
+                yield return new KeyValuePair<string, string>(nameof(attributes.PeKind), attributes.PeKind.ToString());
+                yield return new KeyValuePair<string, string>(nameof(attributes.PublicHexKey), attributes.PublicHexKey);
+                yield return new KeyValuePair<string, string>(nameof(attributes.IsAssembly), attributes.IsAssembly.ToString());
+                yield return new KeyValuePair<string, string>(nameof(attributes.TargetFrameworkMoniker), attributes.TargetFrameworkMoniker);
+                yield return new KeyValuePair<string, string>(nameof(attributes.IsImportedFromTypeLib), attributes.IsImportedFromTypeLib.ToString());
+            }
+        }
+    }
+}
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index daec24f865d..c66e8542878 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Performs SetPlatform negotiation for all project references when opted
     /// in via the EnableDynamicPlatformResolution property.
-    /// 
+    ///
     /// See ProjectReference-Protocol.md for details.
     /// </summary>
     public class GetCompatiblePlatform : TaskExtension
@@ -23,7 +23,7 @@ public class GetCompatiblePlatform : TaskExtension
         public ITaskItem[] AnnotatedProjects { get; set; }
 
         /// <summary>
-        /// The platform the current project is building as. 
+        /// The platform the current project is building as.
         /// </summary>
         [Required]
         public string CurrentProjectPlatform { get; set; }
diff --git a/src/Tasks/GetFrameworkSDKPath.cs b/src/Tasks/GetFrameworkSDKPath.cs
index 5d10aaf2817..fb90e032392 100644
--- a/src/Tasks/GetFrameworkSDKPath.cs
+++ b/src/Tasks/GetFrameworkSDKPath.cs
@@ -1,19 +1,25 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Returns paths to the frameworks SDK.
     /// </summary>
-    public class GetFrameworkSdkPath : TaskExtension
+    public class GetFrameworkSdkPath : TaskExtension, IGetFrameworkSdkPathTaskContract
     {
         #region Properties
 
@@ -311,4 +317,61 @@ public override bool Execute()
 
         #endregion
     }
+#else
+
+    public sealed class GetFrameworkSdkPath : TaskRequiresFramework, IGetFrameworkSdkPathTaskContract
+    {
+        public GetFrameworkSdkPath()
+            : base(nameof(GetFrameworkSdkPath))
+        {
+        }
+
+        #region Properties
+
+        [Output]
+        public string Path { get; set; }
+
+        [Output]
+        public string FrameworkSdkVersion20Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion35Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion40Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion45Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion451Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion46Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion461Path { get; }
+
+        #endregion
+    }
+
+#endif
+
+#pragma warning disable SA1201 // Elements should appear in the correct order
+    internal interface IGetFrameworkSdkPathTaskContract
+    {
+        #region Properties
+
+        string Path { get; set; }
+        string FrameworkSdkVersion20Path { get; }
+        string FrameworkSdkVersion35Path { get; }
+        string FrameworkSdkVersion40Path { get; }
+        string FrameworkSdkVersion45Path { get; }
+        string FrameworkSdkVersion451Path { get; }
+        string FrameworkSdkVersion46Path { get; }
+        string FrameworkSdkVersion461Path { get; }
+
+        #endregion
+    }
+#pragma warning restore SA1201 // Elements should appear in the correct order
 }
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index 08f3821f66c..621291acdac 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -107,7 +107,7 @@ public string[] FullFrameworkReferenceAssemblyPaths
         /// to ensure that certain runtime frameworks are installed depending on the
         /// target framework.
         /// set BypassFrameworkInstallChecks to true in order to bypass those checks.
-        /// </summary>        
+        /// </summary>
         public bool BypassFrameworkInstallChecks { get; set; }
 
         /// <summary>
@@ -146,7 +146,7 @@ public override bool Execute()
             FrameworkNameVersioning moniker;
             FrameworkNameVersioning monikerWithNoProfile = null;
 
-            // Are we targeting a profile. 
+            // Are we targeting a profile.
             bool targetingProfile;
 
             try
@@ -154,7 +154,7 @@ public override bool Execute()
                 moniker = new FrameworkNameVersioning(TargetFrameworkMoniker);
                 targetingProfile = !String.IsNullOrEmpty(moniker.Profile);
 
-                // If we are targeting a profile we need to generate a set of reference assembly paths which describe where the full framework 
+                // If we are targeting a profile we need to generate a set of reference assembly paths which describe where the full framework
                 //  exists, to do so we need to get the reference assembly location without the profile as part of the moniker.
                 if (targetingProfile)
                 {
@@ -216,7 +216,7 @@ public override bool Execute()
             }
             catch (Exception e)
             {
-                // The reason we need to do exception E here is because we are in a task and have the ability to log the message and give the user 
+                // The reason we need to do exception E here is because we are in a task and have the ability to log the message and give the user
                 // feedback as to its cause, tasks if at all possible should not have exception leave them.
                 Log.LogErrorWithCodeFromResources("GetReferenceAssemblyPaths.ProblemGeneratingReferencePaths", TargetFrameworkMoniker, e.Message);
 
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index c5bc3724e33..2af5faaf3b8 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -247,7 +247,7 @@ internal bool Execute(GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion
 
             try
             {
-                // Filter out all references tagged as RuntimeReferenceOnly 
+                // Filter out all references tagged as RuntimeReferenceOnly
                 IEnumerable<ITaskItem> filteredResolvedSDKReferences = ResolvedSDKReferences.Where(
                     sdkReference => !MetadataConversionUtilities.TryConvertItemMetadataToBool(sdkReference, "RuntimeReferenceOnly"));
 
@@ -791,7 +791,7 @@ public bool Equals(ResolvedReferenceAssembly other)
                 }
 
                 // We only care about the file name and not the path because if they have the same file name but different paths then they will likely contain
-                // the same namespaces and the compiler does not like to have two references with the same namespace passed at once without aliasing and 
+                // the same namespaces and the compiler does not like to have two references with the same namespace passed at once without aliasing and
                 // we have no way to do aliasing per assembly since we are grabbing a bunch of files at once.)
                 return String.Equals(FileName, other.FileName, StringComparison.OrdinalIgnoreCase);
             }
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index 23615f93af7..ea271573fd0 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -121,8 +121,8 @@ public override bool Execute()
 
         private HashAlgorithm CreateHashAlgorithm()
         {
-            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) ? 
-                SHA256.Create() : 
+            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) ?
+                SHA256.Create() :
 #pragma warning disable CA5350
                 // Kept for back compatibility reasons when chnange wave is opted-out
                 SHA1.Create();
diff --git a/src/Tasks/IComReferenceResolver.cs b/src/Tasks/IComReferenceResolver.cs
index b8682a8eb22..579dc330f9b 100644
--- a/src/Tasks/IComReferenceResolver.cs
+++ b/src/Tasks/IComReferenceResolver.cs
@@ -31,8 +31,8 @@ internal interface IComReferenceResolver
 
         /*
          * Method:  ResolveComAssemblyReference
-         * 
-         * 
+         *
+         *
          */
         /// <summary>
         /// Resolves a COM wrapper assembly reference based on the COM references resolved so far. This method is necessary
diff --git a/src/Tasks/IVbcHostObjectFreeThreaded.cs b/src/Tasks/IVbcHostObjectFreeThreaded.cs
index c6a763f3224..994bac7ea92 100644
--- a/src/Tasks/IVbcHostObjectFreeThreaded.cs
+++ b/src/Tasks/IVbcHostObjectFreeThreaded.cs
@@ -10,10 +10,10 @@ namespace Microsoft.Build.Tasks.Hosting
     /// <summary>
     /// Defines a free threaded interface for the Vbc task to communicate with the IDE.  In particular,
     /// the Vbc task will delegate the actual compilation to the IDE, rather than shelling
-    /// out to the command-line compilers. 
+    /// out to the command-line compilers.
     /// This particular version of Compile (unlike the IVbcHostObject::Compile) is not marshalled back to the UI
     /// thread. The implementor of the interface is responsible for any marshalling.
-    /// This was added to allow some of the implementors code to run on the BG thread from which VBC Task is being 
+    /// This was added to allow some of the implementors code to run on the BG thread from which VBC Task is being
     /// called from.
     /// </summary>
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
diff --git a/src/Tasks/ListOperators/FindUnderPath.cs b/src/Tasks/ListOperators/FindUnderPath.cs
index b4e08b145e8..836ec12b0f0 100644
--- a/src/Tasks/ListOperators/FindUnderPath.cs
+++ b/src/Tasks/ListOperators/FindUnderPath.cs
@@ -94,7 +94,7 @@ public override bool Execute()
                 {
                     // If we should use the absolute path, update the item contents
                     // Since ItemSpec, which fullPath comes from, is unescaped, re-escape when setting
-                    // item.ItemSpec, since the setter for ItemSpec expects an escaped value. 
+                    // item.ItemSpec, since the setter for ItemSpec expects an escaped value.
                     if (UpdateToAbsolutePaths)
                     {
                         item.ItemSpec = EscapingUtilities.Escape(fullPath);
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index e158a09f092..3def6381e12 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -279,17 +279,17 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                 //
                 // Obtain the list of affected applications/services.
                 //
-                // NOTE: Restart Manager returns the results into the buffer allocated by the caller. The first call to 
-                // RmGetList() will return the size of the buffer (i.e. nProcInfoNeeded) the caller needs to allocate. 
-                // The caller then needs to allocate the buffer (i.e. rgAffectedApps) and make another RmGetList() 
-                // call to ask Restart Manager to write the results into the buffer. However, since Restart Manager 
-                // refreshes the list every time RmGetList()is called, it is possible that the size returned by the first 
-                // RmGetList()call is not sufficient to hold the results discovered by the second RmGetList() call. Therefore, 
+                // NOTE: Restart Manager returns the results into the buffer allocated by the caller. The first call to
+                // RmGetList() will return the size of the buffer (i.e. nProcInfoNeeded) the caller needs to allocate.
+                // The caller then needs to allocate the buffer (i.e. rgAffectedApps) and make another RmGetList()
+                // call to ask Restart Manager to write the results into the buffer. However, since Restart Manager
+                // refreshes the list every time RmGetList()is called, it is possible that the size returned by the first
+                // RmGetList()call is not sufficient to hold the results discovered by the second RmGetList() call. Therefore,
                 // it is recommended that the caller follows the following practice to handle this race condition:
                 //
-                //    Use a loop to call RmGetList() in case the buffer allocated according to the size returned in previous 
+                //    Use a loop to call RmGetList() in case the buffer allocated according to the size returned in previous
                 //    call is not enough.
-                // 
+                //
                 uint pnProcInfo = 0;
                 RM_PROCESS_INFO[] rgAffectedApps = null;
                 int retry = 0;
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 228d7f70fe4..081762e8b84 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -267,7 +267,7 @@ public string OSSupportUrl
         /// Gets or sets the minimum OS version required by the application.
         /// </summary>
         /// <remarks>
-        /// An example value is "5.1.2600.0" for Windows XP.        
+        /// An example value is "5.1.2600.0" for Windows XP.
         /// If you don't specify a value, a default value is used.
         /// The default value is the minimum supported OS of the .NET Framework, which is "4.10.0.0" for Windows 98 Second Edition.
         /// However, if the application contains any native or Reg-Free COM references, then the default is the Windows XP version, which is "5.1.2600.0".
@@ -640,7 +640,7 @@ private void ValidateReferencesForClickOnceApplication()
         {
             int t1 = Environment.TickCount;
             bool isPartialTrust = !TrustInfo.IsFullTrust;
-            var targetPathList = new Dictionary<string, NGen<bool>>();
+            var targetPathList = new Dictionary<string, bool>();
 
             foreach (AssemblyReference assembly in AssemblyReferences)
             {
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index bd2716e8f49..64af947c9d1 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -276,7 +276,7 @@ public static AssemblyIdentity FromManagedAssembly(string path)
                     }
                     catch (ArgumentException e) when (e.HResult == unchecked((int)0x80070057))
                     {
-                        // 0x80070057 - "Value does not fall within the expected range." is returned from 
+                        // 0x80070057 - "Value does not fall within the expected range." is returned from
                         // GetAssemblyIdentityFromFile for WinMD components
                     }
                 }
diff --git a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
index 45fcf658329..500731b2ac1 100644
--- a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
@@ -108,12 +108,12 @@ public AssemblyReference Find(AssemblyIdentity identity)
             {
                 AssemblyIdentity listItemIdentity = a.AssemblyIdentity;
 
-                // if the item in our list doesn't have an identity but is a managed assembly, 
+                // if the item in our list doesn't have an identity but is a managed assembly,
                 //  we calculate it by reading the file from disk to find its identity.
                 //
                 // note that this is here specifically to deal with the scenario when we are being
-                //  asked to find a reference to one of our sentinel assemblies which are known to 
-                //  be managed assemblies. doing this ensures that our sentinel assemblies do not 
+                //  asked to find a reference to one of our sentinel assemblies which are known to
+                //  be managed assemblies. doing this ensures that our sentinel assemblies do not
                 //  show up twice in the manifest.
                 //
                 // we are assuming the incoming identity for the sentinel assembly really is the
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 2dc0e2cb4b1..3ccb3de31b9 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -8,9 +8,9 @@
 //     * The assembly must be built with <GenerateAssemblyRefs>true</GenerateAssemblyRefs>
 //     * The ECDSA methods are not available
 
-// There are cases where we have multiple assemblies that are going to import this file and 
+// There are cases where we have multiple assemblies that are going to import this file and
 // if they are going to also have InternalsVisibleTo between them, there will be a compiler warning
-// that the type is found both in the source and in a referenced assembly. The compiler will prefer 
+// that the type is found both in the source and in a referenced assembly. The compiler will prefer
 // the version of the type defined in the source
 //
 // In order to disable the warning for this type we are disabling this warning for this entire file.
@@ -523,7 +523,7 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
         {
             Debug.Assert(typeof(T).Name == algorithmName);
 
-            // Load System.Core.dll and load the appropriate extension class 
+            // Load System.Core.dll and load the appropriate extension class
             // (one of
             //    System.Security.Cryptography.X509Certificates.RSACertificateExtensions
             //    System.Security.Cryptography.X509Certificates.DSACertificateExtensions
@@ -543,7 +543,7 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
             }
 
             // Now, find the api we want to call:
-            //   
+            //
             // (one of
             //     GetRSAPublicKey(this X509Certificate2 c)
             //     GetRSAPrivateKey(this X509Certificate2 c)
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index be7ce4a1d6c..50eb4971144 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -129,7 +129,7 @@ private void DiscoverCompatibleFrameworks(FrameworkNameVersioning frameworkName)
         }
 
         /// <summary>
-        /// codes from GetInstallableFrameworkForTargetFxInternal in 
+        /// codes from GetInstallableFrameworkForTargetFxInternal in
         /// env/vscore/package/FxMultiTargeting/FrameworkMultiTargetingInternal.cs
         /// </summary>
         private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkNameVersioning frameworkName)
@@ -153,7 +153,7 @@ private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkName
                 }
             }
 
-            // If the installable framework value is not in the redist, there was no redist, or no matching FX we return the sent TFM,  
+            // If the installable framework value is not in the redist, there was no redist, or no matching FX we return the sent TFM,
             // this means frameworks that are installable themselves don't need to specify this property
             // and that all unknown frameworks are assumed to be installable.
             if (installableFramework == null)
@@ -276,7 +276,7 @@ private static string PatchCLRVersion(string version)
             }
             catch (OverflowException)
             {
-                // continue 
+                // continue
             }
 
             return version;
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 629fcb877e0..938c839fd47 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -385,7 +385,7 @@ internal static void UpdateEntryPoint(string inputPath, string outputPath, strin
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(document.NameTable);
             AssemblyIdentity appManifest = AssemblyIdentity.FromManifest(applicationManifestPath);
 
-            // update path to application manifest            
+            // update path to application manifest
             XmlNode codeBaseNode = null;
             foreach (string xpath in XPaths.codebasePaths)
             {
@@ -611,7 +611,7 @@ private void ValidateReferences()
                 return;
             }
 
-            var identityList = new Dictionary<string, NGen<bool>>();
+            var identityList = new Dictionary<string, bool>();
             foreach (AssemblyReference assembly in AssemblyReferences)
             {
                 if (assembly.AssemblyIdentity != null)
@@ -695,7 +695,7 @@ private bool IsMismatchedPlatform(AssemblyReference assembly)
                     }
                 }
 
-                // Either we are looking at the entry point assembly or the assembly is not platform neutral. 
+                // Either we are looking at the entry point assembly or the assembly is not platform neutral.
                 // We need to compare the application's platform to the component's platform,
                 // if they don't match then flag component as a mismatch...
                 return !String.Equals(AssemblyIdentity.ProcessorArchitecture, assembly.AssemblyIdentity.ProcessorArchitecture, StringComparison.OrdinalIgnoreCase);
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 23c43ee0e02..562cc1f1c0f 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -84,7 +84,7 @@ public static void WriteManifest(Manifest manifest, Stream output)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="manifest"></param>
         /// <param name="output"></param>
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 3ff93e72a18..9951399b793 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -617,7 +617,7 @@ public static void SignFile(string certPath, SecureString certPassword, Uri time
         private static bool UseSha256Algorithm(X509Certificate2 cert)
         {
             Oid oid = cert.SignatureAlgorithm;
-            // Issue 6732: Clickonce does not support sha384/sha512 file hash so we default to sha256 
+            // Issue 6732: Clickonce does not support sha384/sha512 file hash so we default to sha256
             // for certs with that signature algorithm.
             return string.Equals(oid.FriendlyName, "sha256RSA", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(oid.FriendlyName, "sha384RSA", StringComparison.OrdinalIgnoreCase) ||
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index d3e38a5fd5d..ecc02c975a7 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -203,7 +203,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
             // <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
             //      <!--
             //          UAC Manifest Options
-            //          If you want to change the Windows User Account Control level replace the 
+            //          If you want to change the Windows User Account Control level replace the
             //          requestedExecutionLevel node with one of the following .
             //          <requestedExecutionLevel  level="asInvoker" />
             //          <requestedExecutionLevel  level="requireAdministrator" />
@@ -234,8 +234,8 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
             //
             if (inputRequestedPrivilegeElement == null)
             {
-                // If UAC requestedPrivilege node is missing (possibly due to upgraded project) then automatically 
-                //  add a default UAC requestedPrivilege node with a default requestedExecutionLevel node set to 
+                // If UAC requestedPrivilege node is missing (possibly due to upgraded project) then automatically
+                //  add a default UAC requestedPrivilege node with a default requestedExecutionLevel node set to
                 //  the expected ClickOnce level (asInvoker) with uiAccess as false
                 //
                 executionLevelString = Constants.UACAsInvoker;
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 5e96abc3314..4d6b6ca09ea 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -599,7 +599,7 @@ public static string WriteTempFile(string s)
             return path;
         }
 
-        #region ItemComparer 
+        #region ItemComparer
         private static readonly ItemComparer s_itemComparer = new ItemComparer();
         private class ItemComparer : IComparer
         {
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 3b19aee2b1e..da2308866d1 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -270,10 +270,14 @@ private void init()
                                Sha256SignatureMethodUri);
 
 #if RUNTIME_TYPE_NETCORE
-            CryptoConfig.AddAlgorithm(typeof(SHA256),
+#pragma warning disable SYSLIB0021 // Type or member is obsolete
+            // SHA256 can not be used since it is an abstract class.
+            // CalculateHashValue internally calls CryptoConfig.CreateFromName and it causes instantiation problems.
+            CryptoConfig.AddAlgorithm(typeof(SHA256Managed),
                                Sha256DigestMethod);
+#pragma warning restore SYSLIB0021 // Type or member is obsolete
 #else
-            CryptoConfig.AddAlgorithm(typeof(System.Security.Cryptography.SHA256Cng),
+            CryptoConfig.AddAlgorithm(typeof(SHA256Cng),
                                Sha256DigestMethod);
 #endif
         }
@@ -758,7 +762,7 @@ private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManife
             // Add an enveloped and an Exc-C14N transform.
             reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());
 #if (false) // BUGBUG: LTA transform complaining about issuer node not found.
-            reference.AddTransform(new XmlLicenseTransform()); 
+            reference.AddTransform(new XmlLicenseTransform());
 #endif
             reference.AddTransform(new XmlDsigExcC14NTransform());
 
diff --git a/src/Tasks/Message.cs b/src/Tasks/Message.cs
index 2b16f5bcd27..befd8c9883d 100644
--- a/src/Tasks/Message.cs
+++ b/src/Tasks/Message.cs
@@ -57,7 +57,7 @@ public override bool Execute()
             {
                 try
                 {
-                    // Parse the raw importance string into a strongly typed enumeration.  
+                    // Parse the raw importance string into a strongly typed enumeration.
                     messageImportance = (MessageImportance)Enum.Parse(typeof(MessageImportance), Importance, true /* case-insensitive */);
                 }
                 catch (ArgumentException)
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 72ea1091d20..d51513a7139 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -61,40 +61,31 @@
     </Compile>
     <Compile Include="..\Shared\CanonicalError.cs">
       <Link>CanonicalError.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="AssemblyDependency\AssemblyAttributes.cs" />
     <Compile Include="AssemblyDependency\AssemblyMetadata.cs" />
     <Compile Include="CombineTargetFrameworkInfoProperties.cs" />
     <Compile Include="CombineXmlElements.cs" />
-    <Compile Include="ConvertToAbsolutePath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ConvertToAbsolutePath.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\ExtensionFoldersRegistryKey.cs">
       <Link>ExtensionFoldersRegistryKey.cs</Link>
     </Compile>
     <Compile Include="..\Shared\FileDelegates.cs">
       <Link>FileDelegates.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\NGen.cs">
-      <Link>NGen.cs</Link>
     </Compile>
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs" />
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>PropertyParser.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>ReadOnlyEmptyCollection.cs</Link>
     </Compile>
     <Compile Include="..\Shared\RegistryDelegates.cs">
       <Link>RegistryDelegates.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\RegistryHelper.cs">
       <Link>RegistryHelper.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\StrongNameHelpers.cs">
       <Link>StrongNameHelpers.cs</Link>
@@ -104,34 +95,26 @@
     </Compile>
     <Compile Include="..\Shared\TaskLoggingHelperExtension.cs">
       <Link>TaskLoggingHelperExtension.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs" />
     <Compile Include="..\Shared\MetadataConversionUtilities.cs">
       <Link>MetadataConversionUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\LanguageParser\StreamMappedString.cs">
       <Link>StreamMappedString.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <Link>ExceptionHandling.cs</Link>
     </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>FileUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\EscapingUtilities.cs">
       <Link>EscapingUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\FileMatcher.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\FileMatcher.cs" />
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
@@ -139,370 +122,149 @@
     <Compile Include="..\Shared\Tracing.cs" />
     <Compile Include="..\Shared\VersionUtilities.cs">
       <Link>VersionUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\VisualStudioConstants.cs">
       <Link>VisualStudioConstants.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\AssemblyNameExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ErrorUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ConversionUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\FileUtilitiesRegex.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ResourceUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\token.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\tokenChar.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\tokenCharReader.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\tokenEnumerator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\CSharptokenCharReader.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\CSharptokenEnumerator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\CSharptokenizer.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\VisualBasictokenCharReader.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\VisualBasictokenEnumerator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\AssemblyNameExtension.cs" />
+    <Compile Include="..\Shared\ErrorUtilities.cs" />
+    <Compile Include="..\Shared\ConversionUtilities.cs" />
+    <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
+    <Compile Include="..\Shared\ResourceUtilities.cs" />
+    <Compile Include="..\Shared\LanguageParser\token.cs" />
+    <Compile Include="..\Shared\LanguageParser\tokenChar.cs" />
+    <Compile Include="..\Shared\LanguageParser\tokenCharReader.cs" />
+    <Compile Include="..\Shared\LanguageParser\tokenEnumerator.cs" />
+    <Compile Include="..\Shared\LanguageParser\CSharptokenCharReader.cs" />
+    <Compile Include="..\Shared\LanguageParser\CSharptokenEnumerator.cs" />
+    <Compile Include="..\Shared\LanguageParser\CSharptokenizer.cs" />
+    <Compile Include="..\Shared\LanguageParser\VisualBasictokenCharReader.cs" />
+    <Compile Include="..\Shared\LanguageParser\VisualBasictokenEnumerator.cs" />
+    <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs" />
     <Compile Include="..\Shared\PlatformNegotiation.cs">
       <Link>PlatformNegotiation.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\XMakeAttributes.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\XMakeElements.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AppConfig\*.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyFoldersExResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\XMakeAttributes.cs" />
+    <Compile Include="..\Shared\XMakeElements.cs" />
+    <Compile Include="AppConfig\*.cs" />
+    <Compile Include="AssemblyDependency\AssemblyFoldersExResolver.cs" />
     <Compile Include="AssemblyDependency\AssemblyFoldersFromConfig\AssemblyFoldersFromConfigCache.cs" />
     <Compile Include="AssemblyDependency\AssemblyFoldersFromConfig\AssemblyFoldersFromConfigResolver.cs" />
-    <Compile Include="AssemblyDependency\AssemblyFoldersResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyInformation.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyNameReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyNameReferenceAscendingVersionComparer.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyResolution.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyResolutionConstants.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\BadImageReferenceException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\CandidateAssemblyFilesResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ConflictLossReason.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\CopyLocalState.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\DependencyResolutionException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\DirectoryResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\DisposableBase.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\FrameworkPathResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyDependency\AssemblyFoldersResolver.cs" />
+    <Compile Include="AssemblyDependency\AssemblyInformation.cs" />
+    <Compile Include="AssemblyDependency\AssemblyNameReference.cs" />
+    <Compile Include="AssemblyDependency\AssemblyNameReferenceAscendingVersionComparer.cs" />
+    <Compile Include="AssemblyDependency\AssemblyResolution.cs" />
+    <Compile Include="AssemblyDependency\AssemblyResolutionConstants.cs" />
+    <Compile Include="AssemblyDependency\BadImageReferenceException.cs" />
+    <Compile Include="AssemblyDependency\CandidateAssemblyFilesResolver.cs" />
+    <Compile Include="AssemblyDependency\ConflictLossReason.cs" />
+    <Compile Include="AssemblyDependency\CopyLocalState.cs" />
+    <Compile Include="AssemblyDependency\DependencyResolutionException.cs" />
+    <Compile Include="AssemblyDependency\DirectoryResolver.cs" />
+    <Compile Include="AssemblyDependency\DisposableBase.cs" />
+    <Compile Include="AssemblyDependency\FrameworkPathResolver.cs" />
     <Compile Include="AssemblyDependency\GenerateBindingRedirects.cs" />
-    <Compile Include="AssemblyDependency\HintPathResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\InstalledAssemblies.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\InvalidReferenceAssemblyNameException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\NoMatchReason.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\RawFilenameResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\Reference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ReferenceResolutionException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ReferenceTable.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ResolutionSearchLocation.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\Resolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ResolveAssemblyReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\TaskItemSpecFilenameComparer.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\UnificationReason.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\UnificationVersion.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\UnifiedAssemblyName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyDependency\HintPathResolver.cs" />
+    <Compile Include="AssemblyDependency\InstalledAssemblies.cs" />
+    <Compile Include="AssemblyDependency\InvalidReferenceAssemblyNameException.cs" />
+    <Compile Include="AssemblyDependency\NoMatchReason.cs" />
+    <Compile Include="AssemblyDependency\RawFilenameResolver.cs" />
+    <Compile Include="AssemblyDependency\Reference.cs" />
+    <Compile Include="AssemblyDependency\ReferenceResolutionException.cs" />
+    <Compile Include="AssemblyDependency\ReferenceTable.cs" />
+    <Compile Include="AssemblyDependency\ResolutionSearchLocation.cs" />
+    <Compile Include="AssemblyDependency\Resolver.cs" />
+    <Compile Include="AssemblyDependency\ResolveAssemblyReference.cs" />
+    <Compile Include="AssemblyDependency\TaskItemSpecFilenameComparer.cs" />
+    <Compile Include="AssemblyDependency\UnificationReason.cs" />
+    <Compile Include="AssemblyDependency\UnificationVersion.cs" />
+    <Compile Include="AssemblyDependency\UnifiedAssemblyName.cs" />
     <Compile Include="AssemblyDependency\WarnOrErrorOnTargetArchitectureMismatchBehavior.cs" />
-    <Compile Include="AssemblyFolder.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyFolder.cs" />
+    <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyRemapping.cs" />
-    <Compile Include="AssemblyResources.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyResources.cs" />
     <Compile Include="AssignLinkMetadata.cs" />
-    <Compile Include="AssignProjectConfiguration.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssignTargetPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="BootstrapperUtil\*.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CallTarget.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CombinePath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CommandLineBuilderExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssignProjectConfiguration.cs" />
+    <Compile Include="AssignTargetPath.cs" />
+    <Compile Include="BootstrapperUtil\*.cs" />
+    <Compile Include="CallTarget.cs" />
+    <Compile Include="CombinePath.cs" />
+    <Compile Include="CommandLineBuilderExtension.cs" />
     <Compile Include="ResourceHandling\*.cs" />
     <Compile Include="GetCompatiblePlatform.cs" />
     <Compile Include="SetRidAgnosticValueForProjects.cs" />
-    <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
     <Compile Include="FileIO\GetFileHash.cs" />
     <Compile Include="FileIO\HashEncoding.cs" />
     <Compile Include="FileIO\VerifyFileHash.cs" />
     <Compile Include="FileState.cs" />
-    <Compile Include="Copy.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateCSharpManifestResourceName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateVisualBasicManifestResourceName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateItem.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateManifestResourceName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateProperty.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CSharpParserUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Delegate.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Delete.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Error.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Exec.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FindAppConfigFile.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Copy.cs" />
+    <Compile Include="CreateCSharpManifestResourceName.cs" />
+    <Compile Include="CreateVisualBasicManifestResourceName.cs" />
+    <Compile Include="CreateItem.cs" />
+    <Compile Include="CreateManifestResourceName.cs" />
+    <Compile Include="CreateProperty.cs" />
+    <Compile Include="CSharpParserUtilities.cs" />
+    <Compile Include="Delegate.cs" />
+    <Compile Include="Delete.cs" />
+    <Compile Include="Error.cs" />
+    <Compile Include="Exec.cs" />
+    <Compile Include="FindAppConfigFile.cs" />
     <Compile Include="FindInvalidProjectReferences.cs" />
-    <Compile Include="GetFrameworkPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="GetFrameworkPath.cs" />
     <Compile Include="GetReferenceAssemblyPaths.cs" />
     <Compile Include="Hash.cs" />
     <Compile Include="InstalledSDKResolver.cs" />
     <Compile Include="Interop.cs" />
     <Compile Include="ErrorFromResources.cs" />
-    <Compile Include="ExtractedClassName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FileIO\ReadLinesFromFile.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FileIO\WriteLinesToFile.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FindInList.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FormatVersion.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateLauncher.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateResource.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GetAssemblyIdentity.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ExtractedClassName.cs" />
+    <Compile Include="FileIO\ReadLinesFromFile.cs" />
+    <Compile Include="FileIO\WriteLinesToFile.cs" />
+    <Compile Include="FindInList.cs" />
+    <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="FormatVersion.cs" />
+    <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GenerateLauncher.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GenerateResource.cs" />
+    <Compile Include="GetAssemblyIdentity.cs" />
     <Compile Include="GetInstalledSDKLocations.cs" />
     <Compile Include="GetSDKReferenceFiles.cs" />
-    <Compile Include="IAnalyzerHostObject.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ICscHostObject.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ICscHostObject2.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ICscHostObject3.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ICscHostObject4.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject2.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject3.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject4.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject5.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObjectFreeThreaded.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="InvalidParameterValueException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ListOperators\FindUnderPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ListOperators\RemoveDuplicates.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="IAnalyzerHostObject.cs" />
+    <Compile Include="ICscHostObject.cs" />
+    <Compile Include="ICscHostObject2.cs" />
+    <Compile Include="ICscHostObject3.cs" />
+    <Compile Include="ICscHostObject4.cs" />
+    <Compile Include="IVbcHostObject.cs" />
+    <Compile Include="IVbcHostObject2.cs" />
+    <Compile Include="IVbcHostObject3.cs" />
+    <Compile Include="IVbcHostObject4.cs" />
+    <Compile Include="IVbcHostObject5.cs" />
+    <Compile Include="IVbcHostObjectFreeThreaded.cs" />
+    <Compile Include="InvalidParameterValueException.cs" />
+    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="ListOperators\FindUnderPath.cs" />
+    <Compile Include="ListOperators\RemoveDuplicates.cs" />
     <Compile Include="LockCheck.cs" />
-    <Compile Include="MakeDir.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ManifestUtil\*.cs" Exclude="ManifestUtil\CngLightup.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Message.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="MakeDir.cs" />
+    <Compile Include="ManifestUtil\*.cs" Exclude="ManifestUtil\CngLightup.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="Message.cs" />
     <Compile Include="Move.cs" />
-    <Compile Include="MSBuild.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="NativeMethods.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ParserState.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="RedistList.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="RemoveDir.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="MSBuild.cs" />
+    <Compile Include="NativeMethods.cs" />
+    <Compile Include="ParserState.cs" />
+    <Compile Include="RedistList.cs" />
+    <Compile Include="RemoveDir.cs" />
     <Compile Include="ResGenDependencies.cs" />
     <Compile Include="ResolveCodeAnalysisRuleSet.cs" />
-    <Compile Include="ResolveKeySource.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ResolveManifestFiles.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ResolveNonMSBuildProjectOutput.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ResolveProjectBase.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ResolveKeySource.cs" />
+    <Compile Include="ResolveManifestFiles.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="ResolveNonMSBuildProjectOutput.cs" />
+    <Compile Include="ResolveProjectBase.cs" />
     <Compile Include="ResolveSDKReference.cs" />
     <Compile Include="RequiresFramework35SP1Assembly.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactory.cs" />
@@ -510,32 +272,18 @@
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryCompilers.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryTaskInfo.cs" />
     <Compile Include="SdkToolsPathUtility.cs" />
-    <Compile Include="SGen.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="SignFile.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="SGen.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="SignFile.cs" Condition="'$(MonoBuild)' != 'true'" />
     <Compile Include="System.Design.cs" />
     <Compile Include="system.design\stronglytypedresourcebuilder.cs" />
-    <Compile Include="TaskExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="TaskExtension.cs" />
     <Compile Include="TaskTranslatorHelpers.cs" />
     <Compile Include="Telemetry.cs" />
-    <Compile Include="ToolTaskExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Touch.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ToolTaskExtension.cs" />
+    <Compile Include="Touch.cs" />
     <Compile Include="Unzip.cs" />
-    <Compile Include="VisualBasicParserUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Warning.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="VisualBasicParserUtilities.cs" />
+    <Compile Include="Warning.cs" />
     <Compile Include="XslTransformation.cs" />
     <Compile Include="AssignCulture.cs" />
     <Compile Include="Culture.cs" />
@@ -550,115 +298,57 @@
     <Compile Include="DependencyFile.cs" />
     <Compile Include="ZipDirectory.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <Compile Include="TaskRequiresFramework.cs" />
+    <!-- Tasks with NET/NETSTANDARD stubs -->
+    <Compile Include="Al.cs" />
+    <Compile Include="AspNetCompiler.cs" />
+    <Compile Include="GenerateBootstrapper.cs" />
+    <Compile Include="GenerateTrustInfo.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GetFrameworkSDKPath.cs" />
+    <Compile Include="RegisterAssembly.cs" />
+    <Compile Include="ResolveComReference.cs" />
+    <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="UnregisterAssembly.cs" />
+    <Compile Include="UpdateManifest.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="WinMDExp.cs" />
+  </ItemGroup>
   <ItemGroup Condition="$(TargetFrameworkIdentifier) == '.NETFramework'">
-    <Compile Include="Al.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AppDomainIsolatedTaskExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AspNetCompiler.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\GacResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\GlobalAssemblyCache.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyRegistrationCache.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AppDomainIsolatedTaskExtension.cs" />
+    <Compile Include="AssemblyDependency\GacResolver.cs" />
+    <Compile Include="AssemblyDependency\GlobalAssemblyCache.cs" />
+    <Compile Include="AssemblyRegistrationCache.cs" />
     <Compile Include="AxImp.cs" />
-    <Compile Include="AxReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AxTlbBaseReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AxReference.cs" />
+    <Compile Include="AxTlbBaseReference.cs" />
     <Compile Include="AxTlbBaseTask.cs" />
-    <Compile Include="ComDependencyWalker.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceItemAttributes.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceResolutionException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceTypes.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceWrapperInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateBootstrapper.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateTrustInfo.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GetFrameworkSDKPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IComReferenceResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ManifestUtil\CngLightup.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="GetAssembliesMetadata.cs" />
+    <Compile Include="ComDependencyWalker.cs" />
+    <Compile Include="ComReference.cs" />
+    <Compile Include="ComReferenceInfo.cs" />
+    <Compile Include="ComReferenceItemAttributes.cs" />
+    <Compile Include="ComReferenceResolutionException.cs" />
+    <Compile Include="ComReferenceTypes.cs" />
+    <Compile Include="ComReferenceWrapperInfo.cs" />
+    <Compile Include="IComReferenceResolver.cs" />
+    <Compile Include="ManifestUtil\CngLightup.cs" />
     <Compile Include="RCWForCurrentContext.cs" />
-    <Compile Include="PiaReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="RegisterAssembly.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="PiaReference.cs" />
     <Compile Include="ResGen.cs" />
-    <Compile Include="ResolveComReferenceCache.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="StrongNameException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="StrongNameUtils.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ResolveComReferenceCache.cs" />
+    <Compile Include="StrongNameException.cs" />
+    <Compile Include="StrongNameUtils.cs" />
     <Compile Include="TlbImp.cs" />
-    <Compile Include="TlbReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="UnregisterAssembly.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="UpdateManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="WinMDExp.cs" />
+    <Compile Include="TlbReference.cs" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Compile Include="XamlTaskFactory\CommandLineGenerator.cs" />
     <Compile Include="XamlTaskFactory\CommandLineToolSwitch.cs" />
-    <Compile Include="XamlTaskFactory\RelationsParser.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="XamlTaskFactory\RelationsParser.cs" />
     <Compile Include="XamlTaskFactory\Property.cs" />
-    <Compile Include="XamlTaskFactory\TaskGenerator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="XamlTaskFactory\TaskGenerator.cs" />
     <Compile Include="XamlTaskFactory\TaskParser.cs" />
-    <Compile Include="XamlTaskFactory\XamlDataDrivenToolTask.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="XamlTaskFactory\XamlDataDrivenToolTask.cs" />
   </ItemGroup>
   <ItemGroup Condition="$(TargetFrameworkIdentifier) == '.NETFramework'">
     <!-- Shim targets only work when the destination targets are installed. -->
@@ -748,6 +438,9 @@
     <Content Include="Microsoft.Common.tasks">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
+    <Content Include="Microsoft.Common.Test.targets">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
     <Content Include="Microsoft.NET.props">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
@@ -820,7 +513,6 @@
       <GenerateResource>true</GenerateResource>
       <FullClassName>Microsoft.Build.Tasks.SR</FullClassName>
       <LogicalName>System.Design.resources</LogicalName>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </TextStringResource>
     <!-- Files to copy -->
     <DataFile Include="Microsoft.Common.targets">
@@ -974,11 +666,9 @@
   </ItemGroup>
 
   <!-- Mimics AddRefAssemblies from MSBuild.csproj -->
-  <Target Name="AddRefAssemblies"
-          DependsOnTargets="ResolveAssemblyReferences"
-          BeforeTargets="AssignTargetPaths">
+  <Target Name="AddRefAssemblies" DependsOnTargets="ResolveAssemblyReferences" BeforeTargets="AssignTargetPaths">
     <ItemGroup>
-      <Content Include="@(NetstandardRefAssemblies)" CopyToOutputDirectory="PreserveNewest" Link="ref\%(Filename)%(Extension)"/>
+      <Content Include="@(NetstandardRefAssemblies)" CopyToOutputDirectory="PreserveNewest" Link="ref\%(Filename)%(Extension)" />
     </ItemGroup>
   </Target>
 
@@ -993,7 +683,7 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
-    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
+    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net472\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
@@ -1008,7 +698,6 @@
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Security.Cryptography.Pkcs" />
     <PackageReference Include="System.Security.Cryptography.Xml" />
-    <PackageReference Include="System.Security.Permissions" />
 
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\netcore\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 44bed1b25ba..07dd2aeb869 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -19,6 +19,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportBefore\*.targets"
           Condition="'$(ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportBefore')"/>
 
+  <Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')"/>
+
   <Import Project="$(CustomBeforeMicrosoftCommonCrossTargetingTargets)" Condition="'$(CustomBeforeMicrosoftCommonCrossTargetingTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonCrossTargetingTargets)')"/>
 
   <Target Name="GetTargetFrameworks"
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 6b963c661b5..7ea4d4d06fb 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -323,7 +323,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
     <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
 
-    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and ('$(ProduceReferenceAssemblyInOutDir)' == 'true' or '$([MSBuild]::AreFeaturesEnabled(17.0))' != 'true' ) ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
+    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and '$(ProduceReferenceAssemblyInOutDir)' == 'true' ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
     <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' ">$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(IntermediateOutputPath), 'ref', $(TargetFileName)))</TargetRefPath>
 
     <!-- Example, C:\MyProjects\MyProject\ -->
@@ -385,11 +385,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
   </PropertyGroup>
+  
+  <PropertyGroup Condition="'$(MSBuildCopyMarkerName)' == ''">
+    <MSBuildCopyMarkerName>$(MSBuildProjectFile)</MSBuildCopyMarkerName>
+    <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 chars of the filename and a filename hash. -->
+    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$(MSBuildProjectFile.Substring(0,8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
+    <MSBuildCopyMarkerName>$(MSBuildCopyMarkerName).Up2Date</MSBuildCopyMarkerName>
+  </PropertyGroup>
 
   <ItemGroup>
     <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)"/>
     <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')"/>
-    <CopyUpToDateMarker Include="$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', '$(MSBuildProjectFile).CopyComplete'))" />
+    <CopyUpToDateMarker Include="$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', '$(MSBuildCopyMarkerName)'))" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(ProduceReferenceAssembly)' == 'true'">
@@ -488,8 +495,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
   </PropertyGroup>
 
-  <!-- 
-    ClickOncePublishDir property is the output location used by all ClickOnce publish targets. This should be same as PublishDir except 
+  <!--
+    ClickOncePublishDir property is the output location used by all ClickOnce publish targets. This should be same as PublishDir except
     for a trailing slash. PublishDir when specified as a global property on the command line cannot be changed to add a trailing slash.
   -->
   <PropertyGroup>
@@ -1367,6 +1374,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_Temp Remove="@(_Temp)" />
     </ItemGroup>
 
+    <!-- RESOURCE ITEMS -->
+    <AssignLinkMetadata Items="@(Resource)"
+                        Condition="'@(Resource)' != '' and '%(Resource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)' and $([MSBuild]::AreFeaturesEnabled('17.10'))">
+      <Output TaskParameter="OutputItems" ItemName="_Temp" />
+    </AssignLinkMetadata>
+
+    <ItemGroup Condition="$([MSBuild]::AreFeaturesEnabled('17.10'))">
+      <Resource Remove="@(_Temp)" />
+      <Resource Include="@(_Temp)" />
+      <_Temp Remove="@(_Temp)" />
+    </ItemGroup>
+
   </Target>
 
   <!--
@@ -1512,6 +1531,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
   <Target Name="AfterResolveReferences"/>
 
+  <!--
+    ============================================================
+                                        IgnoreJavaScriptOutputAssembly
+
+    esproj are JavaScript or TypeScript Projects that never produce an assembly.
+    Set ReferenceOutputAssembly to false in any reference to an esproj.
+    ============================================================
+    -->
+  <Target Name="IgnoreJavaScriptOutputAssembly"
+    BeforeTargets="AssignProjectConfiguration"
+    Condition="$([MSBuild]::AreFeaturesEnabled('17.8'))">
+      <ItemGroup>
+        <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
+          <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+        </ProjectReference>
+      </ItemGroup>
+  </Target>
+
   <!--
     ============================================================
                                         AssignProjectConfiguration
@@ -1805,7 +1842,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         SkipNonexistentTargets="true">
       <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
     </MSBuild>
-    
+
     <!--
        SetPlatform negotiation requires the 'GetTargetFrameworks' MSBuild call to NOT pass global properties. This is to verify
        whether or not the referenced project would build as the same platform as the current project by default. The above
@@ -1879,7 +1916,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <SetRidAgnosticValueForProjects Projects="@(AnnotatedProjects)">
       <Output ItemName="UpdatedAnnotatedProjects" TaskParameter="UpdatedProjects" />
     </SetRidAgnosticValueForProjects>
-    
+
     <ItemGroup>
       <AnnotatedProjects Remove="@(AnnotatedProjects)" />
       <AnnotatedProjects Include="@(UpdatedAnnotatedProjects)" />
@@ -1980,7 +2017,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
              SelfContained and RuntimeIdentifier should not flow across project references.  The IsRidAgnostic metadata value is consumed in the
              _GetProjectReferenceTargetFrameworkProperties target, where those properties are added to a project's UndefineProperties if
              IsRidAgnostic is set.
-        
+
              Generally we set the IsRidAgnostic metadata based on the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the
              fallback logic here will be that the project is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->
         <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>
@@ -2507,7 +2544,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_NewGenerateBindingRedirectsIntermediateAppConfig Condition="Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">true</_NewGenerateBindingRedirectsIntermediateAppConfig>
       <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
-    
+
     <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
@@ -3022,6 +3059,40 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <ReferenceComWrappersToCopyLocal Include="@(ComReferenceWrappers)" Condition="'%(ComReferenceWrappers.CopyLocal)'!='false'"/>
     </ItemGroup>
 
+  </Target>
+
+    <!--
+    ============================================================
+                                        _GetAssembliesMetadata
+
+    Resolve Assembly attributes for assemblies
+    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,
+    but this target handles all the assembly references from ResolveAssemblyReferences
+    This target is needed by the Visual Studio legacy project system during design time build only
+
+        [IN]
+        @(ReferencePath) - Paths to COM-referenced wrappers and other types of assembly references.
+
+        [OUT]
+        @(AssembliesMetadata) - Resolved assemblies attributes.
+    ============================================================
+    -->
+
+  <Target
+      Name="_GetAssembliesMetadata"
+      Condition="'@(ReferencePath)'!=''and '$(DesignTimeBuild)' == 'true' "
+      Returns="@(_AssembliesMetadata)"
+      DependsOnTargets="ResolveComReferences"
+        >
+
+    <GetAssembliesMetadata
+          AssemblyPaths="@(ReferencePath)"
+          ContinueOnError="$(ContinueOnError)">
+
+      <Output TaskParameter="AssembliesMetadata" ItemName="_AssembliesMetadata"/>
+
+    </GetAssembliesMetadata>
+
   </Target>
 
   <Target
@@ -4356,14 +4427,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-  <PropertyGroup>
-    <DeploymentComputeClickOnceManifestInfoDependsOn>
-      CleanPublishFolder;
-      _DeploymentGenerateTrustInfo
-      $(DeploymentComputeClickOnceManifestInfoDependsOn)
-    </DeploymentComputeClickOnceManifestInfoDependsOn>
-  </PropertyGroup>
-
   <!--
     ============================================================
                                         _DeploymentComputeClickOnceManifestInfo
@@ -4423,10 +4486,28 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                                       Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
       <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
 
-      <!-- Include items from None itemgroup for publishing -->
-      <_ClickOnceNoneItems Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+      <!--
+        For .NET>=5, we need to check if we need to publish any content items from transitive project references. For such items to be published, they
+        either have the .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
+        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
+      -->
+      <_ClickOnceTransitiveContentItemsTemp Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(TargetPath)')" Condition="'$(PublishProtocol)' == 'ClickOnce'" >
+        <SavedIdentity>%(Identity)</SavedIdentity>
+      </_ClickOnceTransitiveContentItemsTemp>
+      <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
+
+      <!--
+        For .NET>=5, we need to check if we need to publish any copylocal items from None group. For such items to be published, they either
+        have .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
+        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
+      -->
+      <!-- Include items from None group for publishing -->
+      <_ClickOnceNoneItemsTemp Include="@(_NoneWithTargetPath->'%(TargetPath)')" Condition="'$(PublishProtocol)'=='Clickonce' And ('%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest')">
+        <SavedIdentity>%(Identity)</SavedIdentity>
+      </_ClickOnceNoneItemsTemp>
+      <_ClickOnceNoneItems Include="@(_ClickOnceNoneItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
 
-      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems)"/>
+      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems);@(_ClickOnceTransitiveContentItems)"/>
     </ItemGroup>
 
     <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
@@ -4943,7 +5024,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       This target enforces the dependency.
     -->
 
-    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == '' and $([MSBuild]::AreFeaturesEnabled('17.0'))">true</MSBuildCopyContentTransitively>
+    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == ''">true</MSBuildCopyContentTransitively>
 
     <_TargetsThatPrepareProjectReferences Condition=" '$(MSBuildCopyContentTransitively)' == 'true' ">
       AssignProjectConfiguration;
@@ -4982,7 +5063,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Target
     Name="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences"
     DependsOnTargets="_PopulateCommonStateForGetCopyToOutputDirectoryItems;_AddOutputPathToGlobalPropertiesToRemove"
-    Returns="@(_TransitiveItemsToCopyToOutputDirectory)">
+    Returns="@(_CopyToOutputDirectoryTransitiveItems)">
 
     <!-- Get items from child projects first. -->
     <MSBuild
@@ -5001,8 +5082,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Target outputs must be full paths because they will be consumed by a different project. -->
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
-      <_TransitiveItemsToCopyToOutputDirectory   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+      <_CopyToOutputDirectoryTransitiveItems   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
+      <_CopyToOutputDirectoryTransitiveItems   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
     </ItemGroup>
 
     <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
@@ -5012,13 +5093,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Copy paste _GetCopyToOutputDirectoryItemsFromThisProject but keep the items that came from other projects via ProjectReference's OutputItemType metadata -->
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
     <ItemGroup>
@@ -5030,13 +5111,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </AssignTargetPath>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
     </ItemGroup>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
   </Target>
@@ -5112,7 +5193,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <!-- Empty intermediate items to release memory -->
       <_TransitiveItemsToCopyToOutputDirectoryAlways               Remove="@(_TransitiveItemsToCopyToOutputDirectoryAlways)"/>
       <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest       Remove="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest)"/>
-      <_TransitiveItemsToCopyToOutputDirectory                     Remove="@(_TransitiveItemsToCopyToOutputDirectory)"/>
 
       <_ThisProjectItemsToCopyToOutputDirectoryAlways              Remove="@(_ThisProjectItemsToCopyToOutputDirectoryAlways)"/>
       <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest      Remove="@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)"/>
@@ -5791,6 +5871,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ***********************************************************************************************
     -->
 
+  <PropertyGroup>
+    <DeploymentComputeClickOnceManifestInfoDependsOn>
+      CleanPublishFolder;
+      $(_RecursiveTargetForContentCopying);
+      _DeploymentGenerateTrustInfo
+      $(DeploymentComputeClickOnceManifestInfoDependsOn)
+    </DeploymentComputeClickOnceManifestInfoDependsOn>
+  </PropertyGroup>
+
   <!--
     ============================================================
                                         Publish
@@ -6711,7 +6800,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <Import Project="$(MsTestToolsTargets)" Condition="Exists('$(MsTestToolsTargets)')" />
-
+  
+  <PropertyGroup>
+    <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
+  </PropertyGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'"/>
   <!-- App packaging support -->
 
   <!--
@@ -6744,5 +6837,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')"/>
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')"/>
-
 </Project>
diff --git a/src/Tasks/Microsoft.Common.Test.targets b/src/Tasks/Microsoft.Common.Test.targets
new file mode 100644
index 00000000000..39ac95cbfaa
--- /dev/null
+++ b/src/Tasks/Microsoft.Common.Test.targets
@@ -0,0 +1,25 @@
+<!--
+***********************************************************************************************
+Microsoft.Common.Test.targets
+
+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
+          created a backup copy.  Incorrect changes to this file will make it
+          impossible to load or build your projects from the command-line or the IDE.
+
+Copyright (C) Microsoft Corporation. All rights reserved.
+***********************************************************************************************
+-->
+<!--
+    ============================================================
+    This stub `Test` target allows for targets implementing Test execution functionality
+    to run after it.
+    
+    For example:
+    <Target Name="RunVSTest" AfterTargets="Test">
+     (implementation)
+    </Target>
+    ============================================================
+  -->
+<Project>
+    <Target Name="Test"></Target>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.overridetasks b/src/Tasks/Microsoft.Common.overridetasks
index 6032f7ccf9a..a0be9def7c2 100644
--- a/src/Tasks/Microsoft.Common.overridetasks
+++ b/src/Tasks/Microsoft.Common.overridetasks
@@ -9,32 +9,32 @@
 
   <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"       AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5'" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"          AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"          AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"        AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-  <UsingTask TaskName="ResolveComReference"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="ResolveComReference"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0'" />
 
-  <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-  <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="GenerateResource"                                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="GenerateResource"                                AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-  <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-  <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="RegisterAssembly"                                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="RegisterAssembly"                                AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-  <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-  <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="UnregisterAssembly"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="UnregisterAssembly"                              AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-  <UsingTask TaskName="ReadLinesFromFile"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
-  <UsingTask TaskName="FindUnderPath"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
-  <UsingTask TaskName="ConvertToAbsolutePath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
-  <UsingTask TaskName="MSBuild"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
-  <UsingTask TaskName="ResolveAssemblyReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '4.0'" />
+  <UsingTask TaskName="ReadLinesFromFile"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="FindUnderPath"                                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="ConvertToAbsolutePath"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="MSBuild"                                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="ResolveAssemblyReference"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '4.0'" />
 
 </Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index beab1878e60..cf67254502d 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -48,6 +48,7 @@
 
   <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetAssembliesMetadata"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildRuntimeType)' == 'Full'"/>
   <UsingTask TaskName="Microsoft.Build.Tasks.GetCompatiblePlatform"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFileHash"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -63,7 +64,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DisableOutOfProcTaskHost)' != ''" />
   <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
@@ -84,7 +85,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.Telemetry"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DisableOutOfProcTaskHost)' != ''" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index 746ce275be7..e0a628370f8 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -26,7 +26,7 @@ public class Move : TaskExtension, ICancelableTask, IIncrementalTask
     {
         /// <summary>
         /// Flags for MoveFileEx.
-        /// 
+        ///
         /// </summary>
         private const NativeMethods.MoveFileFlags Flags = NativeMethods.MoveFileFlags.MOVEFILE_WRITE_THROUGH |    // Do not return until the Move is complete
                                                           NativeMethods.MoveFileFlags.MOVEFILE_REPLACE_EXISTING | // Replace any existing target
@@ -250,7 +250,7 @@ private bool MoveFileWithLogging(
 
             if (!result)
             {
-                // It failed so we need a nice error message. Unfortunately 
+                // It failed so we need a nice error message. Unfortunately
                 // Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error()); and
                 // throw new IOException((new Win32Exception(error)).Message)
                 // do not produce great error messages (eg., "The operation succeeded" (!)).
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 86faefd4fb7..59e9f6c1ba5 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -108,7 +108,7 @@ internal interface IMetaDataDispenser
     [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
     internal interface IMetaDataImport
     {
-        // PreserveSig because this method is an exception that 
+        // PreserveSig because this method is an exception that
         // actually returns void, not HRESULT.
         [PreserveSig]
         void CloseEnum();
@@ -279,7 +279,7 @@ internal interface IMetaDataAssemblyImport
         void GetAssemblyFromScope(out UInt32 mdAsm);
         void FindExportedTypeByName();
         void FindManifestResourceByName();
-        // PreserveSig because this method is an exception that 
+        // PreserveSig because this method is an exception that
         // actually returns void, not HRESULT.
         [PreserveSig]
         void CloseEnum([In] IntPtr phEnum);
@@ -1028,7 +1028,7 @@ internal static extern int CreateAssemblyNameObject(
         /// <param name="cacheFlags">Value that indicates the source of the cached assembly.</param>
         /// <param name="cachePath">The returned pointer to the path.</param>
         /// <param name="pcchPath">The requested maximum length of CachePath, and upon return, the actual length of CachePath.</param>
-        /// 
+        ///
         [DllImport("fusion.dll", CharSet = CharSet.Unicode)]
         [SupportedOSPlatform("windows")]
         internal static extern unsafe int GetCachePath(AssemblyCacheFlags cacheFlags, [Out] char* cachePath, ref int pcchPath);
@@ -1141,13 +1141,13 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                     IntPtr attrDataPostProlog = attrData + preReadOffset;
 
                     int strLen;
-                    // Get the offset at which the uncompressed data starts, and the 
+                    // Get the offset at which the uncompressed data starts, and the
                     // length of the uncompressed data.
                     attrDataOffset = CorSigUncompressData(attrDataPostProlog, out strLen);
 
                     if (strLen != -1)
                     {
-                        // the full size of the blob we were passed in should be sufficient to 
+                        // the full size of the blob we were passed in should be sufficient to
                         // cover the prolog, compressed string length, and actual string.
                         if (attrDataSize >= preReadOffset + attrDataOffset + strLen)
                         {
@@ -1159,7 +1159,7 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                                 bytes[i] = Marshal.ReadByte(attrDataPostProlog, attrDataOffset + i);
                             }
 
-                            // And convert it to the output string. 
+                            // And convert it to the output string.
                             strValue = new String(Encoding.UTF8.GetChars(bytes));
                         }
                         else
@@ -1175,11 +1175,11 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
             }
             catch (AccessViolationException)
             {
-                // The Marshal.ReadXXXX functions throw AVs when they're fed an invalid pointer, and very occasionally, 
-                // for some reason, on what seem to be otherwise perfectly valid assemblies (it must be 
+                // The Marshal.ReadXXXX functions throw AVs when they're fed an invalid pointer, and very occasionally,
+                // for some reason, on what seem to be otherwise perfectly valid assemblies (it must be
                 // intermittent given that otherwise the user would be completely unable to use the reference
-                // manager), the pointer that we generate to look up the AssemblyTitle is apparently invalid, 
-                // or for some reason Marshal.ReadByte thinks it is.  
+                // manager), the pointer that we generate to look up the AssemblyTitle is apparently invalid,
+                // or for some reason Marshal.ReadByte thinks it is.
                 //
                 return false;
             }
@@ -1209,19 +1209,19 @@ internal static unsafe int CorSigUncompressData(IntPtr data, out int uncompresse
             byte* bytes = (byte*)(data);
             uncompressedDataLength = 0;
 
-            // Smallest.    
-            if ((*bytes & 0x80) == 0x00)       // 0??? ????    
+            // Smallest.
+            if ((*bytes & 0x80) == 0x00)       // 0??? ????
             {
                 uncompressedDataLength = *bytes;
                 count = 1;
             }
-            // Medium.  
-            else if ((*bytes & 0xC0) == 0x80)  // 10?? ????    
+            // Medium.
+            else if ((*bytes & 0xC0) == 0x80)  // 10?? ????
             {
                 uncompressedDataLength = (int)((*bytes & 0x3f) << 8 | *(bytes + 1));
                 count = 2;
             }
-            else if ((*bytes & 0xE0) == 0xC0)      // 110? ????    
+            else if ((*bytes & 0xE0) == 0xC0)      // 110? ????
             {
                 uncompressedDataLength = (int)((*bytes & 0x1f) << 24 | *(bytes + 1) << 16 | *(bytes + 2) << 8 | *(bytes + 3));
                 count = 4;
diff --git a/src/Tasks/PiaReference.cs b/src/Tasks/PiaReference.cs
index f98a07f512d..b16590ab98e 100644
--- a/src/Tasks/PiaReference.cs
+++ b/src/Tasks/PiaReference.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// COM reference wrapper class for the tlbimp tool using a PIA. 
+    /// COM reference wrapper class for the tlbimp tool using a PIA.
     /// </summary>
     internal sealed class PiaReference : ComReference
     {
@@ -62,7 +62,7 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
                         path = uri.LocalPath,
                         assembly = assembly,
 
-                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer 
+                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer
                         // version and other COM components use that name to reference the PIA. assembly.FullName wouldn't
                         // work here since we'd get the redirected assembly name.
                         originalPiaName = new AssemblyNameExtension(AssemblyName.GetAssemblyName(uri.LocalPath))
@@ -78,8 +78,8 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
                         path = assembly.Location,
                         assembly = assembly,
 
-                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer 
-                        // version and other COM components use that name to reference the PIA. 
+                        // We need to remember the original assembly name of this PIA in case it gets redirected to a newer
+                        // version and other COM components use that name to reference the PIA.
                         originalPiaName = new AssemblyNameExtension(asmName, true)
                     };
                 }
@@ -87,12 +87,12 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
             catch (FileNotFoundException)
             {
                 // This means that assembly file cannot be found.
-                // We don't need to do anything here; wrapperInfo is not set 
+                // We don't need to do anything here; wrapperInfo is not set
                 // and we'll assume that the assembly doesn't exist.
             }
             catch (BadImageFormatException)
             {
-                // Similar case as above, except we should additionally warn the user that the assembly file 
+                // Similar case as above, except we should additionally warn the user that the assembly file
                 // is not really a valid assembly file.
                 if (!Silent)
                 {
diff --git a/src/Tasks/RCWForCurrentContext.cs b/src/Tasks/RCWForCurrentContext.cs
index 83e90765226..bc7a4373e35 100644
--- a/src/Tasks/RCWForCurrentContext.cs
+++ b/src/Tasks/RCWForCurrentContext.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Tasks.InteropUtilities
 {
     /// <summary>
-    /// Create an RCW for the current context/apartment. 
+    /// Create an RCW for the current context/apartment.
     /// This improves performance of cross apartment calls as the CLR will only
     /// cache marshalled pointers for an RCW created in the current context.
     /// </summary>
@@ -33,8 +33,8 @@ internal class RCWForCurrentContext<T> : IDisposable where T : class
         /// <param name="rcw">The RCW created in the original context.</param>
         public RCWForCurrentContext(T rcw)
         {
-            // To improve performance we create a new RCW for the current context so we get 
-            // the caching behaviour of the marshaled pointer. 
+            // To improve performance we create a new RCW for the current context so we get
+            // the caching behaviour of the marshaled pointer.
             // See RCW::GetComIPForMethodTableFromCache in ndp\clr\src\VM\RuntimeCallableWrapper.cpp
             IntPtr iunknownPtr = Marshal.GetIUnknownForObject(rcw);
             Object objInCurrentCtx;
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index f439aa4939b..c46d663bbb7 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -48,7 +48,7 @@ internal sealed class RedistList
         /// When we check to see if an assembly is in this redist list we want to cache it so that if we ask again we do not
         /// have to re-scan bits of the redist list and do the assemblynameExtension comparisons.
         /// </summary>
-        private readonly ConcurrentDictionary<AssemblyNameExtension, NGen<bool>> _assemblyNameInRedist = new ConcurrentDictionary<AssemblyNameExtension, NGen<bool>>(AssemblyNameComparer.GenericComparer);
+        private readonly ConcurrentDictionary<AssemblyNameExtension, bool> _assemblyNameInRedist = new ConcurrentDictionary<AssemblyNameExtension, bool>(AssemblyNameComparer.GenericComparer);
 
         /// <summary>
         /// AssemblyName to unified assemblyName. We make this kind of call a lot and also will ask for the same name multiple times.
@@ -271,7 +271,7 @@ private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotN
             string referenceAssembliesPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(version);
 
             // On dogfood build machines, v3.5 is not formally installed, so this returns null.
-            // We don't use redist lists in this case.            
+            // We don't use redist lists in this case.
             string[] redistListPaths = (referenceAssembliesPath == null) ? Array.Empty<string>() : GetRedistListPathsFromDisk(referenceAssembliesPath);
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
@@ -431,7 +431,7 @@ public bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName)
         {
             ErrorUtilities.VerifyThrowArgumentNull(assemblyName, nameof(assemblyName));
 
-            if (!_assemblyNameInRedist.TryGetValue(assemblyName, out NGen<bool> isAssemblyNameInRedist))
+            if (!_assemblyNameInRedist.TryGetValue(assemblyName, out bool isAssemblyNameInRedist))
             {
                 string simpleName = GetSimpleName(assemblyName.Name);
                 if (_simpleNameMap.TryGetValue(simpleName, out int index))
@@ -558,7 +558,7 @@ internal Dictionary<string, string> GenerateDenyList(AssemblyTableInfo[] allowLi
                     // we do not get a "redist name is null or empty" error when in actual fact it was a file not found error.
                     int errorsBeforeReadCall = allowListErrors.Count;
 
-                    // Read in the subset list file. 
+                    // Read in the subset list file.
                     string redistName = ReadFile(info, allowListAssembliesReadIn, allowListErrors, allowListErrorFileNames, null);
 
                     // Get the client subset name which has been read in.
@@ -846,7 +846,7 @@ private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableIn
             attributes.TryGetValue("IsRedistRoot", out string isRedistRoot);
             if (!bool.TryParse(inGAC, out bool inGACFlag))
             {
-                inGACFlag = true;                           // true by default 
+                inGACFlag = true;                           // true by default
             }
 
             // The retargetable flag is Yes or No for some reason
@@ -912,9 +912,9 @@ public int Compare(AssemblyEntry firstEntry, AssemblyEntry secondEntry)
 
                 // We now want to sort based on the version number
                 // The compare method is expected to return the following values:
-                // Less than zero = right instance is less than left. 
-                // Zero  = right instance is equal to left. 
-                // Greater than zero  = right instance is greater than left. 
+                // Less than zero = right instance is less than left.
+                // Zero  = right instance is equal to left.
+                // Greater than zero  = right instance is greater than left.
 
                 // Want the greater version number to be on top in a list so we need to reverse the comparison
                 int returnValue = firstAssemblyName.Version.CompareTo(secondAssemblyName.Version);
@@ -1023,14 +1023,14 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
             {
                 lock (s_subsetListPathCacheLock)
                 {
-                    // We want to cache the paths to the subset files so that we do not have to hit the disk and check for the files 
+                    // We want to cache the paths to the subset files so that we do not have to hit the disk and check for the files
                     // each time RAR is called within the appdomain.
                     if (s_subsetListPathCache == null)
                     {
                         s_subsetListPathCache = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
                     }
 
-                    // TargetFrameworkDirectory is not unique enough because a different invocation could ask for a different 
+                    // TargetFrameworkDirectory is not unique enough because a different invocation could ask for a different
                     // set of subset files from the same TargetFrameworkDirectory
                     string concatenatedSubsetListNames = String.Join(";", _subsetToSearchFor);
 
@@ -1044,7 +1044,7 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
 
                         var subsetFilesForFrameworkDirectory = new List<string>();
 
-                        // Go through each of the subsets and see if it is in the target framework subset directory 
+                        // Go through each of the subsets and see if it is in the target framework subset directory
                         foreach (string subsetName in _subsetToSearchFor)
                         {
                             string subsetFilePath = Path.Combine(subsetDirectory, subsetName + ".xml");
@@ -1054,7 +1054,7 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
                             }
                         }
 
-                        // Note, even if the array is empty we still want to add it to the cache, because some 
+                        // Note, even if the array is empty we still want to add it to the cache, because some
                         // target framework directories may never contain a subset file (for example 2.05727 and 3.0)
                         // for this reason we should not check them everytime if the files are not found.
                         s_subsetListPathCache[key] = subsetFilesForFrameworkDirectory.ToArray();
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 0fb8e616bb3..46999b37715 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if FEATURE_APPDOMAIN
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
 
 using System;
 using System.Diagnostics;
@@ -11,20 +11,25 @@
 using System.Runtime.InteropServices.ComTypes;
 using System.Security;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
+#endif
+
+using Microsoft.Build.Framework;
+
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
+
     /// <summary>
     /// Registers a managed assembly for COM interop (equivalent of regasm.exe functionality, but this code doesn't actually call the exe).
     /// </summary>
     /// <comment>ITypeLibExporterNotifySink is necessary for the ITypeLibConverter.ConvertAssemblyToTypeLib call.</comment>
-    public class RegisterAssembly : AppDomainIsolatedTaskExtension, ITypeLibExporterNotifySink
+    public class RegisterAssembly : AppDomainIsolatedTaskExtension, ITypeLibExporterNotifySink, IRegisterAssemblyTaskContract
     {
         #region Properties
 
@@ -217,7 +222,7 @@ private bool Register(string assemblyPath, string typeLibPath)
 
             try
             {
-                // Load the specified assembly. 
+                // Load the specified assembly.
                 Assembly asm = Assembly.UnsafeLoadFrom(assemblyPath);
 
                 var comRegistrar = new RegistrationServices();
@@ -225,8 +230,8 @@ private bool Register(string assemblyPath, string typeLibPath)
                 // Register the assembly
                 if (!comRegistrar.RegisterAssembly(asm, CreateCodeBase ? AssemblyRegistrationFlags.SetCodeBase : AssemblyRegistrationFlags.None))
                 {
-                    // If the assembly doesn't contain any types that could be registered for COM interop, 
-                    // warn the user about it.  
+                    // If the assembly doesn't contain any types that could be registered for COM interop,
+                    // warn the user about it.
                     Log.LogWarningWithCodeFromResources("RegisterAssembly.NoValidTypes", assemblyPath);
                 }
 
@@ -360,5 +365,41 @@ private bool ExportTypeLib(Assembly asm, string typeLibFileName)
 
         #endregion
     }
-}
+
+#elif !NETFRAMEWORK
+
+    public sealed class RegisterAssembly : TaskRequiresFramework, IRegisterAssemblyTaskContract
+    {
+        public RegisterAssembly()
+            : base(nameof(RegisterAssembly))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] Assemblies { get; set; }
+
+        [Output]
+        public ITaskItem[] TypeLibFiles { get; set; }
+
+        public bool CreateCodeBase { get; set; }
+
+        public ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+
 #endif
+
+    internal interface IRegisterAssemblyTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] Assemblies { get; set; }
+        ITaskItem[] TypeLibFiles { get; set; }
+        bool CreateCodeBase { get; set; }
+        ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+}
diff --git a/src/Tasks/RequiresFramework35SP1Assembly.cs b/src/Tasks/RequiresFramework35SP1Assembly.cs
index 068315c907c..4714f818e73 100644
--- a/src/Tasks/RequiresFramework35SP1Assembly.cs
+++ b/src/Tasks/RequiresFramework35SP1Assembly.cs
@@ -145,7 +145,7 @@ private static bool HasExcludedFileOrSP1File(ITaskItem[] candidateFiles)
         /// <summary>
         /// Is this file's IncludeHash set to false?
         /// Is this file System.Data.Entity.dll?
-        /// Is this file Client Sentinel Assembly? 
+        /// Is this file Client Sentinel Assembly?
         /// </summary>
         private static bool IsExcludedFileOrSP1File(ITaskItem candidateFile)
         {
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 731c376b5e2..5bce63d6e60 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -27,7 +27,7 @@ namespace Microsoft.Build.Tasks
     public sealed partial class GenerateResource : TaskExtension
     {
         /// <summary>
-        /// Defines the "ResGen" MSBuild task, which enables using ResGen.exe 
+        /// Defines the "ResGen" MSBuild task, which enables using ResGen.exe
         /// to generate strongly-typed resource classes and convert resource
         /// files from one format to another.
         /// </summary>
@@ -67,34 +67,34 @@ embedding it into an assembly.
                         version of a type will use the one in this assembly, when set.
         /define:A[,B]   For #ifdef support in .ResText files, pass a comma-separated
                         list of symbols.  ResText files can use "#ifdef A" or "#if !B".
-        
+
         Miscellaneous:
         @<file>         Read response file for more options. At most one response file
                         may be specified, and its entries must be line-separated.
-        
+
         .restext & .txt files have this format:
-        
+
             # Use # at the beginning of a line for a comment character.
             name=value
             more elaborate name=value
-        
+
         Example response file contents:
-        
+
             # Use # at the beginning of a line for a comment character.
             /useSourcePath
             /compile
             file1.resx,file1.resources
             file2.resx,file2.resources
-        
+
 
         Language names valid for the /str:<language> option are:
         c#, cs, csharp, vb, vbs, visualbasic, vbscript, js, jscript, javascript, vj#, vjs, vjsharp, c++, mc, cpp
          */
 
             /// <summary>
-            /// Files being passed to ResGen.exe to be converted to a different resource format.  
-            /// If a strongly typed resource class is being created, only one file may be 
-            /// passed to InputFiles at a time. 
+            /// Files being passed to ResGen.exe to be converted to a different resource format.
+            /// If a strongly typed resource class is being created, only one file may be
+            /// passed to InputFiles at a time.
             /// </summary>
             public ITaskItem[] InputFiles
             {
@@ -104,7 +104,7 @@ public ITaskItem[] InputFiles
 
             /// <summary>
             /// Should be the same length as InputFiles or null.  If null, the files output
-            /// by ResGen.exe will be named "inputFiles[i].resources".  Otherwise, the 
+            /// by ResGen.exe will be named "inputFiles[i].resources".  Otherwise, the
             /// extensions on the output filesnames indicate which format the corresponding
             /// input file will be translated to.
             /// </summary>
@@ -202,11 +202,11 @@ public bool UseSourcePath
             protected override string ToolName => "resgen.exe";
 
             /// <summary>
-            /// Tracker.exe wants Unicode response files, and ResGen.exe doesn't care, 
-            /// so make them Unicode across the board. 
+            /// Tracker.exe wants Unicode response files, and ResGen.exe doesn't care,
+            /// so make them Unicode across the board.
             /// </summary>
             /// <comment>
-            /// We no longer use Tracker.exe in ResGen, but given that as ResGen doesn't care, 
+            /// We no longer use Tracker.exe in ResGen, but given that as ResGen doesn't care,
             /// there doesn't really seem to be a particular reason to change it back, either...
             /// </comment>
             protected override Encoding ResponseFileEncoding => Encoding.Unicode;
@@ -270,7 +270,7 @@ public override bool Execute()
                 {
                     ITaskItem outputFile = OutputFiles[0];
 
-                    // if the resource generation was unsuccessful, check to see that the resource file 
+                    // if the resource generation was unsuccessful, check to see that the resource file
                     // was in fact generated
                     if (!success)
                     {
@@ -296,14 +296,14 @@ public override bool Execute()
                         }
                         catch (System.Configuration.ConfigurationException)
                         {
-                            // If the language can't be found, then ResGen.exe will already have 
-                            // logged an appropriate error.  
+                            // If the language can't be found, then ResGen.exe will already have
+                            // logged an appropriate error.
                             return false;
                         }
                         catch (System.Security.SecurityException)
                         {
-                            // If the language can't be found, then ResGen.exe will already have 
-                            // logged an appropriate error.  
+                            // If the language can't be found, then ResGen.exe will already have
+                            // logged an appropriate error.
                             return false;
                         }
 
@@ -316,7 +316,7 @@ public override bool Execute()
 
             /// <summary>
             /// Fills the provided CommandLineBuilderExtension with all the command line options used when
-            /// executing this tool that can go into a response file.  
+            /// executing this tool that can go into a response file.
             /// </summary>
             /// <comments>
             /// ResGen 3.5 and earlier doesn't support response files, but ResGen 4.0 and later does.
@@ -344,8 +344,8 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
                 }
                 else
                 {
-                    // return nothing -- if it's not 4.0, or if we're building strongly typed resources, we assume that, 
-                    // as far as ToolTask is concerned at least, response files are not supported. 
+                    // return nothing -- if it's not 4.0, or if we're building strongly typed resources, we assume that,
+                    // as far as ToolTask is concerned at least, response files are not supported.
                 }
             }
 
@@ -355,7 +355,7 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
             /// </summary>
             /// <comments>
             /// Has to be command line commands because ResGen 3.5 and earlier don't know about
-            /// response files. 
+            /// response files.
             /// </comments>
             /// <param name="commandLine">Gets filled with command line options</param>
             protected internal override void AddCommandLineCommands(CommandLineBuilderExtension commandLine)
@@ -372,12 +372,12 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
                     !pathToResGen.Equals(NativeMethodsShared.GetLongFilePath(ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", TargetDotNetFrameworkVersion.Version35)), StringComparison.OrdinalIgnoreCase) &&
                     String.IsNullOrEmpty(StronglyTypedLanguage))
                 {
-                    // 4.0 resgen.exe does support response files (at least as long as you're not building an STR), so we can 
+                    // 4.0 resgen.exe does support response files (at least as long as you're not building an STR), so we can
                     // make use of them here by returning nothing!
                 }
                 else
                 {
-                    // otherwise, the toolname is ResGen.exe and we just need the resgen arguments in CommandLineCommands. 
+                    // otherwise, the toolname is ResGen.exe and we just need the resgen arguments in CommandLineCommands.
                     commandLine.AppendTextUnquoted(resGenArguments.ToString());
                 }
             }
@@ -412,7 +412,7 @@ protected override bool ValidateParameters()
                 if (!String.IsNullOrEmpty(StronglyTypedLanguage))
                 {
                     // Only a single Sources is allowed if you are generating STR.
-                    // Otherwise, each STR class overwrites the previous one. In theory we could generate separate 
+                    // Otherwise, each STR class overwrites the previous one. In theory we could generate separate
                     // STR classes for each input, but then the class name and file name parameters would have to be vectors.
                     if (InputFiles.Length != 1)
                     {
@@ -427,14 +427,14 @@ protected override bool ValidateParameters()
                         !String.IsNullOrEmpty(StronglyTypedNamespace) ||
                         !String.IsNullOrEmpty(StronglyTypedFileName))
                     {
-                        // We have no language to generate a STR, but nevertheless the user passed us a class, 
+                        // We have no language to generate a STR, but nevertheless the user passed us a class,
                         // namespace, and/or filename. Let them know that they probably wanted to pass a language too.
                         Log.LogErrorWithCodeFromResources("ResGen.STRClassNamespaceOrFilenameWithoutLanguage");
                         return false;
                     }
                 }
 
-                // Verify that the ToolPath exists -- if the tool doesn't exist in it 
+                // Verify that the ToolPath exists -- if the tool doesn't exist in it
                 // we'll worry about that later
                 if ((String.IsNullOrEmpty(ToolPath) || !FileSystems.Default.DirectoryExists(ToolPath)) &&
                     (String.IsNullOrEmpty(SdkToolsPath) || !FileSystems.Default.DirectoryExists(SdkToolsPath)))
@@ -451,7 +451,7 @@ protected override bool ValidateParameters()
             #region Helper methods
 
             /// <summary>
-            /// Checks a string array for null or length zero.  Does not check if 
+            /// Checks a string array for null or length zero.  Does not check if
             /// individual members are null
             /// </summary>
             /// <param name="value">The string array to check</param>
@@ -490,7 +490,7 @@ private void GenerateOutputFileNames()
             }
 
             /// <summary>
-            /// Generates the full path to ResGen.exe.  
+            /// Generates the full path to ResGen.exe.
             /// </summary>
             /// <returns>The path to ResGen.exe, or null.</returns>
             private string GenerateResGenFullPath()
@@ -510,7 +510,7 @@ private string GenerateResGenFullPath()
                         }
                     }
 
-                    // If it still hasn't been found, try to generate the appropriate path. 
+                    // If it still hasn't been found, try to generate the appropriate path.
                     if (pathToTool == null)
                     {
                         pathToTool = SdkToolsPathUtility.GeneratePathToTool(
@@ -524,8 +524,8 @@ private string GenerateResGenFullPath()
                         pathToTool = NativeMethodsShared.GetLongFilePath(pathToTool);
                     }
 
-                    // And then set it for future reference.  If it's still null, there's nothing else 
-                    // we can do, and we've already logged an appropriate error. 
+                    // And then set it for future reference.  If it's still null, there's nothing else
+                    // we can do, and we've already logged an appropriate error.
                     Bag["ToolPathWithFile"] = pathToTool;
                 }
 
@@ -533,7 +533,7 @@ private string GenerateResGenFullPath()
             }
 
             /// <summary>
-            /// Generate the command line to be passed to resgen.exe, sans the path to the tool. 
+            /// Generate the command line to be passed to resgen.exe, sans the path to the tool.
             /// </summary>
             private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments, bool useForResponseFile)
             {
@@ -555,8 +555,8 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                 {
                     foreach (ITaskItem reference in References)
                     {
-                        // ResGen.exe response files frown on quotes in filenames, even if there are 
-                        // spaces in the names of the files.  
+                        // ResGen.exe response files frown on quotes in filenames, even if there are
+                        // spaces in the names of the files.
                         if (useForResponseFile && reference != null)
                         {
                             resGenArguments.AppendTextUnquoted("/r:");
@@ -585,8 +585,8 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                         {
                             if (useForResponseFile)
                             {
-                                // ResGen.exe response files frown on quotes in filenames, even if there are 
-                                // spaces in the names of the files.  
+                                // ResGen.exe response files frown on quotes in filenames, even if there are
+                                // spaces in the names of the files.
                                 if (inputFiles[i] != null && outputFiles[i] != null)
                                 {
                                     resGenArguments.AppendTextUnquoted(inputFiles[i].ItemSpec);
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 706899188d7..72713bb21ce 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -66,7 +66,7 @@ internal string BaseLinkedFileDirectory
                 {
                     // Ok, this is slightly complicated.  Changing the base directory in any manner may
                     // result in changes to how we find .resx files.  Therefore, we must clear our out
-                    // cache whenever the base directory changes.  
+                    // cache whenever the base directory changes.
                     resXFiles.Clear();
                     _isDirty = true;
                     baseLinkedFileDirectory = value;
@@ -78,7 +78,7 @@ internal bool UseSourcePath
         {
             set
             {
-                // Ensure that the cache is properly initialized with respect to how resgen will 
+                // Ensure that the cache is properly initialized with respect to how resgen will
                 // resolve linked files within .resx files.  ResGen has two different
                 // ways for resolving relative file-paths in linked files. The way
                 // that ResGen resolved relative paths before Whidbey was always to
@@ -126,7 +126,7 @@ internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader, Ta
             // First, try to retrieve the resx information from our hashtable.
             if (!resXFiles.TryGetValue(resxFile, out ResXFile retVal))
             {
-                // Ok, the file wasn't there.  Add it to our cache and return it to the caller.  
+                // Ok, the file wasn't there.  Add it to our cache and return it to the caller.
                 retVal = AddResxFile(resxFile, useMSBuildResXReader, log, logWarningForBinaryFormatter);
             }
             else
@@ -157,7 +157,7 @@ private ResXFile AddResxFile(string file, bool useMSBuildResXReader, TaskLogging
 
         internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
         {
-            // First, try to retrieve the portable library information from our hashtable.  
+            // First, try to retrieve the portable library information from our hashtable.
             portableLibraries.TryGetValue(libraryPath, out PortableLibraryFile retVal);
 
             // The file is in our cache.  Make sure it's up to date.  If not, discard
@@ -198,7 +198,7 @@ internal static ResGenDependencies DeserializeCache(string stateFile, bool useSo
         {
             var retVal = DeserializeCache<ResGenDependencies>(stateFile, log) ?? new ResGenDependencies();
 
-            // Ensure that the cache is properly initialized with respect to how resgen will 
+            // Ensure that the cache is properly initialized with respect to how resgen will
             // resolve linked files within .resx files.  ResGen has two different
             // ways for resolving relative file-paths in linked files. The way
             // that ResGen resolved relative paths before Whidbey was always to
@@ -314,9 +314,9 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
         }
 
         /// <remarks>
-        /// Represents a single assembly in the dependency cache, which may produce 
+        /// Represents a single assembly in the dependency cache, which may produce
         /// 0 to many ResW files.
-        /// 
+        ///
         /// Must be serializable because instances may be marshaled cross-AppDomain, see <see cref="ProcessResourceFiles.PortableLibraryCacheInfo"/>.
         /// </remarks>
 #if FEATURE_APPDOMAIN
diff --git a/src/Tasks/ResolveCodeAnalysisRuleSet.cs b/src/Tasks/ResolveCodeAnalysisRuleSet.cs
index 3bcb41882e1..8c1f481d630 100644
--- a/src/Tasks/ResolveCodeAnalysisRuleSet.cs
+++ b/src/Tasks/ResolveCodeAnalysisRuleSet.cs
@@ -53,7 +53,7 @@ public override bool Execute()
 
         /// <summary>
         /// Computes the resolved rule set path.
-        /// 
+        ///
         /// There are four cases: null, file name, relative path, and full path.
         ///
         /// If we were given no value for the ruleset, simply return null.
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 0a3eb949eef..b3a1bca439a 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -84,12 +84,12 @@ internal interface IResolveComReferenceTaskContract
         bool NoClassMembers { get; set; }
 
         /// <summary>
-        /// If true, do not log messages or warnings.  Default is false. 
+        /// If true, do not log messages or warnings.  Default is false.
         /// </summary>
         bool Silent { get; set; }
 
         /// <summary>
-        /// The preferred target processor architecture. Passed to tlbimp.exe /machine flag after translation. 
+        /// The preferred target processor architecture. Passed to tlbimp.exe /machine flag after translation.
         /// Should be a member of Microsoft.Build.Utilities.ProcessorArchitecture.
         /// </summary>
         string TargetProcessorArchitecture { get; set; }
@@ -139,8 +139,13 @@ internal interface IResolveComReferenceTaskContract
     /// <summary>
     /// Main class for the COM reference resolution task for .NET Core
     /// </summary>
-    public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExtension, IResolveComReferenceTaskContract
+    public sealed partial class ResolveComReference : TaskRequiresFramework, IResolveComReferenceTaskContract
     {
+        public ResolveComReference()
+            : base(nameof(ResolveComReference))
+        {
+        }
+
 #pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Properties
 
@@ -183,21 +188,7 @@ public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExte
         public string TargetFrameworkVersion { get; set; } = String.Empty;
 
         #endregion
-
-        #region ITask members
-
-        /// <summary>
-        /// Task entry point.
-        /// </summary>
-        /// <returns></returns>
-        public override bool Execute()
-        {
-            Log.LogErrorWithCodeFromResources("TaskRequiresFrameworkFailure", nameof(ResolveComReference));
-            return false;
-        }
-
-        #endregion
-#pragma warning restore format 
+#pragma warning restore format
     }
 
 #else
@@ -325,7 +316,7 @@ public override bool Execute()
 
             if (!ComputePathToAxImp() || !ComputePathToTlbImp())
             {
-                // unable to compute the path to tlbimp.exe, aximp.exe, or both and that is necessary to 
+                // unable to compute the path to tlbimp.exe, aximp.exe, or both and that is necessary to
                 // continue forward, so return now.
                 return false;
             }
@@ -365,7 +356,7 @@ public override bool Execute()
 
                 // Process each task item. If one of them fails we still process the rest of them, but
                 // remember that the task should return failure.
-                // DESIGN CHANGE: we no longer fail the task when one or more references fail to resolve. 
+                // DESIGN CHANGE: we no longer fail the task when one or more references fail to resolve.
                 // Unless we experience a catastrophic failure, we'll log warnings for those refs and proceed
                 // (and return success)
                 var moduleList = new List<ITaskItem>();
@@ -405,7 +396,7 @@ public override bool Execute()
                             catch (FileLoadException ex)
                             {
                                 // This exception is thrown when we try to load a delay signed assembly without disabling
-                                // strong name verification first. So print a nice information if we're generating 
+                                // strong name verification first. So print a nice information if we're generating
                                 // delay signed wrappers, otherwise rethrow, since it's an unexpected exception.
                                 if (DelaySign)
                                 {
@@ -424,7 +415,7 @@ public override bool Execute()
                             catch (ArgumentException ex)
                             {
                                 // This exception is thrown when we try to convert some of the Metadata from the project
-                                // file and the conversion fails.  Most likely, the user needs to correct a type in the 
+                                // file and the conversion fails.  Most likely, the user needs to correct a type in the
                                 // project file.
                                 Log.LogErrorWithCodeFromResources("General.InvalidArgument", ex.Message);
                                 return false;
@@ -444,8 +435,8 @@ public override bool Execute()
                 ResolvedModules = moduleList.ToArray();
                 ResolvedFiles = resolvedReferenceList.ToArray();
 
-                // The Logs from AxImp and TlbImp aren't part of our log, but if the task failed, it will return false from 
-                // GenerateWrapper, which should get passed all the way back up here.  
+                // The Logs from AxImp and TlbImp aren't part of our log, but if the task failed, it will return false from
+                // GenerateWrapper, which should get passed all the way back up here.
                 return allReferencesResolvedSuccessfully && !Log.HasLoggedErrors;
             }
             finally
@@ -486,7 +477,7 @@ internal void SetFrameworkVersionFromString(string version)
         }
 
         /// <summary>
-        /// Computes the path to TlbImp.exe for use in logging and for passing to the 
+        /// Computes the path to TlbImp.exe for use in logging and for passing to the
         /// nested TlbImp task.
         /// </summary>
         /// <returns>True if the path is found (or it doesn't matter because we're executing in memory), false otherwise</returns>
@@ -526,7 +517,7 @@ private bool ComputePathToTlbImp()
         }
 
         /// <summary>
-        /// Computes the path to AxImp.exe for use in logging and for passing to the 
+        /// Computes the path to AxImp.exe for use in logging and for passing to the
         /// nested AxImp task.
         /// </summary>
         /// <returns>True if the path is found, false otherwise</returns>
@@ -539,12 +530,12 @@ private bool ComputePathToAxImp()
             {
                 // In certain cases -- such as trying to build a Dev10 project on a machine that only has Dev11 installed --
                 // it's possible to have ExecuteAsTool set to false (e.g. "use the current CLR") but still have SDKToolsPath
-                // be empty (because it's referencing the 7.0A SDK in the registry, which doesn't exist).  In that case, we 
-                // want to look for VersionLatest.  However, if ExecuteAsTool is true (default value) and SDKToolsPath is 
+                // be empty (because it's referencing the 7.0A SDK in the registry, which doesn't exist).  In that case, we
+                // want to look for VersionLatest.  However, if ExecuteAsTool is true (default value) and SDKToolsPath is
                 // empty, then we can safely assume that we want to get the 3.5 version of the tool.
                 TargetDotNetFrameworkVersion targetAxImpVersion = ExecuteAsTool ? TargetDotNetFrameworkVersion.Version35 : TargetDotNetFrameworkVersion.Latest;
 
-                // We want to use the copy of AxImp corresponding to our targeted architecture if possible.  
+                // We want to use the copy of AxImp corresponding to our targeted architecture if possible.
                 _aximpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("AxImp.exe", targetAxImpVersion, VisualStudioVersion.VersionLatest);
 
                 if (_aximpPath == null)
@@ -568,7 +559,7 @@ private bool ComputePathToAxImp()
         }
 
         /// <summary>
-        /// Try to get the path to the tool in the Windows SDK with the given .NET Framework version and 
+        /// Try to get the path to the tool in the Windows SDK with the given .NET Framework version and
         /// of the same architecture as we were currently given for TargetProcessorArchitecture.
         /// </summary>
         private string GetPathToSDKFileWithCurrentlyTargetedArchitecture(string file, TargetDotNetFrameworkVersion targetFrameworkVersion, VisualStudioVersion visualStudioVersion)
@@ -626,7 +617,7 @@ private void Cleanup()
 
         /*
          * Method:  VerifyAndInitializeInputs
-         * 
+         *
          * Helper method. Verifies the input task items have correct metadata and initializes optional ones with
          * default values if they're not present.
          */
@@ -696,7 +687,7 @@ private bool VerifyAndInitializeInputs()
 
         /*
          * Method:  ConvertAttrReferencesToComReferenceInfo
-         * 
+         *
          * Helper method. Converts TypeLibAttr references to ComReferenceInfo objects.
          * This method cannot fail, since we want to proceed with the task even if some references won't load.
          */
@@ -734,7 +725,7 @@ private void ConvertAttrReferencesToComReferenceInfo(List<ComReferenceInfo> proj
 
         /*
          * Method:  ConvertFileReferencesToComReferenceInfo
-         * 
+         *
          * Helper method. Converts TypeLibFiles references to ComReferenceInfo objects
          * This method cannot fail, since we want to proceed with the task even if some references won't load.
          */
@@ -890,8 +881,8 @@ private bool ResolveReferenceAndAddToList(
 
         /*
          * Method:  ResolveReference
-         * 
-         * Helper COM resolution method. Creates an appropriate helper class for the given tool and calls 
+         *
+         * Helper COM resolution method. Creates an appropriate helper class for the given tool and calls
          * the Resolve method on it.
          */
         internal bool ResolveReference(ComDependencyWalker dependencyWalker, ComReferenceInfo referenceInfo, string outputDirectory, out ITaskItem referencePathItem)
@@ -945,7 +936,7 @@ internal bool ResolveReference(ComDependencyWalker dependencyWalker, ComReferenc
 
         /*
          * Method:  IsExistingProjectReference
-         * 
+         *
          * If given typelib attributes are already a project reference, return that reference.
          */
         internal bool IsExistingProjectReference(TYPELIBATTR typeLibAttr, string neededRefType, out ComReferenceInfo referenceInfo)
@@ -986,7 +977,7 @@ internal bool IsExistingProjectReference(TYPELIBATTR typeLibAttr, string neededR
 
         /*
          * Method:  IsExistingDependencyReference
-         * 
+         *
          * If given typelib attributes are already a dependency reference (that is, was already
          * processed) return that reference.
          */
@@ -1008,7 +999,7 @@ internal bool IsExistingDependencyReference(TYPELIBATTR typeLibAttr, out ComRefe
 
         /*
          * Method:  ResolveComClassicReference
-         * 
+         *
          * Resolves a COM classic reference given the type library attributes and the type of wrapper to use.
          * If wrapper type is not specified, this method will first look for an existing reference in the project,
          * fall back to looking for a PIA and finally try to generate a regular tlbimp wrapper.
@@ -1059,7 +1050,7 @@ internal bool ResolveComClassicReference(ComReferenceInfo referenceInfo, string
 
         /*
          * Method:  ResolveComClassicReference
-         * 
+         *
          * Resolves a COM classic reference given the type library attributes and the type of wrapper to use.
          * If wrapper type is not specified, this method will first look for an existing reference in the project,
          * fall back to looking for a PIA and finally try to generate a regular tlbimp wrapper.
@@ -1085,7 +1076,7 @@ bool IComReferenceResolver.ResolveComClassicReference(TYPELIBATTR typeLibAttr, s
             // find an existing ref in the project (taking the desired wrapperType into account, if any)
             if (IsExistingProjectReference(typeLibAttr, wrapperType, out ComReferenceInfo referenceInfo))
             {
-                // IsExistingProjectReference should not return null... 
+                // IsExistingProjectReference should not return null...
                 Debug.Assert(referenceInfo != null, "IsExistingProjectReference should not return null");
                 topLevelRef = true;
                 wrapperType = referenceInfo.taskItem.GetMetadata(ComReferenceItemMetadataNames.wrapperTool);
@@ -1154,7 +1145,7 @@ bool IComReferenceResolver.ResolveComClassicReference(TYPELIBATTR typeLibAttr, s
 
         /*
          * Method:  ResolveNetAssemblyReference
-         * 
+         *
          * Resolves a .NET assembly reference using the list of resolved managed references supplied to the task.
          *
          * This is the method available for references to call back to resolve their dependencies
@@ -1186,9 +1177,9 @@ bool IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, out
 
         /*
          * Method:  ResolveComAssemblyReference
-         * 
+         *
          * Resolves a COM wrapper assembly reference based on the COM references resolved so far. This method is necessary
-         * for Ax wrappers only, so all necessary references will be resolved by then (since we resolve them in 
+         * for Ax wrappers only, so all necessary references will be resolved by then (since we resolve them in
          * the following order: pia, tlbimp, aximp)
          *
          * This is the method available for references to call back to resolve their dependencies
@@ -1301,7 +1292,7 @@ internal bool ResolveComReferencePia(ComReferenceInfo referenceInfo, string refN
         }
 
         /// <summary>
-        /// Return the set of item specs for the resolved assembly references. 
+        /// Return the set of item specs for the resolved assembly references.
         /// </summary>
         /// <returns></returns>
         internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
@@ -1442,7 +1433,7 @@ internal bool ResolveComReferenceAx(ComReferenceInfo referenceInfo, string outpu
 
         /*
          * Method:  VerifyReferenceMetadataForNameItem
-         * 
+         *
          * Verifies that all required metadata on the COM reference item are there.
          */
         internal static bool VerifyReferenceMetadataForNameItem(ITaskItem reference, out string missingOrInvalidMetadata)
@@ -1516,7 +1507,7 @@ internal static bool VerifyReferenceMetadataForNameItem(ITaskItem reference, out
 
         /*
          * Method:  InitializeDefaultMetadataForNameItem
-         * 
+         *
          * Initializes optional metadata on given name item to their default values if they're not present
          */
         internal static void InitializeDefaultMetadataForNameItem(ITaskItem reference)
@@ -1536,7 +1527,7 @@ internal static void InitializeDefaultMetadataForNameItem(ITaskItem reference)
 
         /*
          * Method:  InitializeDefaultMetadataForFileItem
-         * 
+         *
          * Initializes optional metadata on given file item to their default values if they're not present
          */
         internal static void InitializeDefaultMetadataForFileItem(ITaskItem reference)
@@ -1550,7 +1541,7 @@ internal static void InitializeDefaultMetadataForFileItem(ITaskItem reference)
 
         /*
          * Method:  CheckForConflictingReferences
-         * 
+         *
          * Checks if we have any conflicting references.
          */
         internal bool CheckForConflictingReferences()
@@ -1638,7 +1629,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
 
                 string privateMetadata = taskItem.GetMetadata(ItemMetadataNames.privateMetadata);
 
-                // if Private is not set on the original item, we set CopyLocal to false for GAC items 
+                // if Private is not set on the original item, we set CopyLocal to false for GAC items
                 // and true for non-GAC items
                 if (string.IsNullOrEmpty(privateMetadata))
                 {
@@ -1661,7 +1652,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
 
         /// <summary>
         /// Scan all the dependencies of the main project references and preresolve them
-        /// so that when we get asked about a previously unknown dependency in the form of a .NET assembly 
+        /// so that when we get asked about a previously unknown dependency in the form of a .NET assembly
         /// we know what to do with it.
         /// </summary>
         private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependencyWalker, ComReferenceInfo reference)
@@ -1693,13 +1684,13 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
 
             foreach (TYPELIBATTR dependencyTypeLibAttr in dependentAttrs)
             {
-                // We don't need to even try to resolve if the dependency reference is ourselves. 
+                // We don't need to even try to resolve if the dependency reference is ourselves.
                 if (!ComReference.AreTypeLibAttrEqual(dependencyTypeLibAttr, reference.attr))
                 {
                     if (IsExistingProjectReference(dependencyTypeLibAttr, null, out ComReferenceInfo existingReference))
                     {
                         // If we're resolving another project reference, empty out the type cache -- if the dependencies are buried,
-                        // caching the analyzed types can make it so that we don't recognize our dependencies' dependencies. 
+                        // caching the analyzed types can make it so that we don't recognize our dependencies' dependencies.
                         dependencyWalker.ClearAnalyzedTypeCache();
 
                         if (ResolveReference(dependencyWalker, existingReference, WrapperOutputDirectory, out ITaskItem resolvedItem))
@@ -1707,7 +1698,7 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
                             // Add the resolved dependency
                             dependentPaths.Add(resolvedItem.ItemSpec);
 
-                            // and anything it depends on 
+                            // and anything it depends on
                             foreach (string dependentPath in existingReference.dependentWrapperPaths)
                             {
                                 dependentPaths.Add(dependentPath);
@@ -1742,7 +1733,7 @@ private List<string> ScanAndResolveAllDependencies(ComDependencyWalker dependenc
 
         /*
          * Method:  TaskItemToTypeLibAttr
-         * 
+         *
          * Gets the TLIBATTR structure based on the reference we have.
          * Sets guid, versions major & minor, lcid.
          */
@@ -1770,7 +1761,7 @@ internal static TYPELIBATTR TaskItemToTypeLibAttr(ITaskItem taskItem)
         }
 
         #endregion
-#pragma warning restore format 
+#pragma warning restore format
     }
 
 #endif
diff --git a/src/Tasks/ResolveComReferenceCache.cs b/src/Tasks/ResolveComReferenceCache.cs
index 2972c86df93..ee7b4577a9c 100644
--- a/src/Tasks/ResolveComReferenceCache.cs
+++ b/src/Tasks/ResolveComReferenceCache.cs
@@ -14,13 +14,13 @@ namespace Microsoft.Build.Tasks
     /// Stores timestamps of COM components processed in the last run. The problem here is that installing/uninstalling
     /// COM components does not update their timestamps with the current time (for a good reason). So if you revert to
     /// an earlier revision of a COM component, its timestamp can go back in time and we still need to regenerate its
-    /// wrapper. So in ResolveComReference we compare the stored timestamp with the current component timestamp, and if 
+    /// wrapper. So in ResolveComReference we compare the stored timestamp with the current component timestamp, and if
     /// they are different, we regenerate the wrapper.
     /// </remarks>
     internal sealed class ResolveComReferenceCache : StateFileBase, ITranslatable
     {
         /// <summary>
-        /// Component timestamps. 
+        /// Component timestamps.
         /// Key: Component path on disk
         /// Value: DateTime struct
         /// </summary>
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 66a5ac3c70b..f67cab5f410 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -1,6 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 using System.IO;
 using System.Collections;
@@ -9,20 +10,25 @@
 using System.Diagnostics;
 #endif
 using System.Linq;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Main class for the native reference resolution task.
     /// </summary>
-    public class ResolveNativeReference : TaskExtension
+    public class ResolveNativeReference : TaskExtension, IResolveNativeReferenceTaskConract
     {
         #region Constructors
 
@@ -226,7 +232,7 @@ internal bool ExtractFromManifest(
                 }
 
                 bool isClickOnceApp = manifest is ApplicationManifest applicationManifest && applicationManifest.IsClickOnceManifest;
-                // ClickOnce application manifest should not be added as native reference, but we should open and process it.        
+                // ClickOnce application manifest should not be added as native reference, but we should open and process it.
                 if (!containingReferenceFilesTable.ContainsKey(path) && !isClickOnceApp)
                 {
                     ITaskItem itemNativeReferenceFile = new TaskItem();
@@ -340,4 +346,58 @@ internal bool ExtractFromManifest(
         }
         #endregion
     }
+
+#else
+
+    public sealed class ResolveNativeReference : TaskRequiresFramework, IResolveNativeReferenceTaskConract
+    {
+        public ResolveNativeReference()
+            : base(nameof(ResolveNativeReference))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] NativeReferences { get; set; }
+
+        public string[] AdditionalSearchPaths { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainingReferenceFiles { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedPrerequisiteAssemblies { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedComComponents { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedTypeLibraries { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedLooseTlbFiles { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedLooseEtcFiles { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IResolveNativeReferenceTaskConract
+    {
+        #region Properties
+
+        ITaskItem[] NativeReferences { get; set; }
+        string[] AdditionalSearchPaths { get; set; }
+        ITaskItem[] ContainingReferenceFiles { get; set; }
+        ITaskItem[] ContainedPrerequisiteAssemblies { get; set; }
+        ITaskItem[] ContainedComComponents { get; set; }
+        ITaskItem[] ContainedTypeLibraries { get; set; }
+        ITaskItem[] ContainedLooseTlbFiles { get; set; }
+        ITaskItem[] ContainedLooseEtcFiles { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index d279d8fd9e2..0e458a48807 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -202,7 +202,7 @@ public string TargetPlatformVersion
         public ITaskItem[] DisallowedSDKDependencies { get; set; }
 
         /// <summary>
-        /// List of dependencies passed from the targets file that will have the metadata RuntimeReferenceOnly set as true. 
+        /// List of dependencies passed from the targets file that will have the metadata RuntimeReferenceOnly set as true.
         /// For instance "VCLibs 11" should have such a metadata set to true in projects targeting Win 8.1 or higher.
         /// </summary>
         public ITaskItem[] RuntimeReferenceOnlySDKDependencies { get; set; }
@@ -220,7 +220,7 @@ public string TargetPlatformVersion
         public string TargetedSDKArchitecture { get; set; }
 
         /// <summary>
-        /// Enables warning when MaxPlatformVersion is not present in the manifest and the ESDK platform version (from its path) 
+        /// Enables warning when MaxPlatformVersion is not present in the manifest and the ESDK platform version (from its path)
         /// is different than the target platform version (from the project)
         /// </summary>
         public bool WarnOnMissingPlatformVersion { get; set; }
@@ -306,7 +306,7 @@ public override bool Execute()
                 }
             }
 
-            // We need to check to see if there are any SDKNames on any of the reference items in the project. If there are 
+            // We need to check to see if there are any SDKNames on any of the reference items in the project. If there are
             // then we do not want those SDKs to expand their reference assemblies by default because we are going to use RAR to look inside of them for certain reference assemblies only.
             var sdkNamesOnReferenceItems = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
             if (References != null)
@@ -333,14 +333,14 @@ public override bool Execute()
             // Set of sdks which are not compatible with other sdks of the same product famuily or with the same sdk name
             var sdksNotCompatibleWithOtherSDKs = new HashSet<SDKReference>();
 
-            // Go through each reference passed in and determine if it is in the set of installed SDKs. 
+            // Go through each reference passed in and determine if it is in the set of installed SDKs.
             // Also create new output items if the item is in an installed SDK and set the metadata correctly.
             foreach (ITaskItem referenceItem in SDKReferences)
             {
                 // Parse the SDK reference item include. The name could have been added by a user and may have extra spaces or be not well formatted.
                 SDKReference reference = ParseSDKReference(referenceItem);
 
-                // Could not parse the reference, lets skip over this reference item. An error would have been logged in the ParseSDKReference method to tell the 
+                // Could not parse the reference, lets skip over this reference item. An error would have been logged in the ParseSDKReference method to tell the
                 // user why the parsing did not happen.
                 if (reference == null)
                 {
@@ -1002,7 +1002,7 @@ private static string GetItemMetadataTrimmed(ITaskItem item, string metadataName
             /// <summary>
             /// After resolving a reference we need to check to see if there is a SDKManifest file in the root directory and if there is we need to extract the frameworkidentity.
             /// We ignore other attributes to leave room for expansion of the file format.
-            /// 
+            ///
             /// </summary>
             private void GetSDKManifestAttributes()
             {
@@ -1281,7 +1281,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                 }
 
                 // The SDKManifest may have had a number of frameworkidentity entries inside of it. We want to match the one
-                // which has the correct configuration and architecture. If a perfect match cannot be found 
+                // which has the correct configuration and architecture. If a perfect match cannot be found
                 // then we will look for ones that declare only the configuration. If that cannot be found we just try and find an element that only is "FrameworkIdentity".
                 if (String.IsNullOrEmpty(FrameworkIdentity))
                 {
@@ -1385,7 +1385,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                                 bool containsKey = architectureLocations.TryGetValue(architectureComponent, out string architectureLocation);
 
-                                // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it. 
+                                // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it.
                                 // Also, replace the entry if we have already added an entry for a non configuration specific entry and we now have a configuration specific entry that matches what we are targeting.
                                 if ((configurationComponent == null && !containsKey) || (configurationComponent?.Equals(sdkConfiguration, StringComparison.OrdinalIgnoreCase) == true))
                                 {
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 8b337bb2db5..ce39286376c 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1692,6 +1692,10 @@
     <value>References which depend on "{0}" [{1}].</value>
     <comment> This will look like references which depend on "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</comment>
   </data>
+  <data name="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+    <value>References which depend on or have been unified to "{0}" [{1}].</value>
+    <comment> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</comment>
+  </data>
   <data name="ResolveAssemblyReference.UnResolvedPrimaryItemSpec">
     <value>Unresolved primary reference with an item include of "{0}".</value>
     <comment> This messages is for a reference which could not be resolved, however we have its item spec and will display that. {0} will be somethign like  System or A, Version=xxx</comment>
@@ -2781,6 +2785,18 @@
     <value>MSB3893: Could not use a link to copy "{0}" to "{1}".</value>
     <comment>{StrBegin="MSB3893: "} LOCALIZATION: {0} and {1} are paths.</comment>
   </data>
+  <data name="Copy.IOException">
+    <value>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</value>
+    <comment>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</comment>
+  </data>
+  <data name="Copy.RetryingOnAccessDenied">
+    <value>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</value>
+    <comment>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</comment>
+  </data>
+  <data name="Copy.IncompatibleParameters">
+    <value>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</value>
+    <comment>{StrBegin="MSB3896: "}</comment>
+  </data>
 
   <!--
         MSB3901 - MSB3910   Task: Telemetry
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index e911bfc64fe..3d65015a42d 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -191,6 +191,16 @@
         <target state="translated">Vytváří se pevný odkaz pro kopírování {0} do {1}.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Při kopírování „{1}“ do „{2}“ došlo k výjimce {0} a HR je {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Nedá se použít odkaz pro kopírování {0} do {1}.</target>
@@ -221,6 +231,11 @@
         <target state="translated">Nepovedlo se použít pevný odkaz ke zkopírování „{0}“ do „{1}“. Místo toho se soubor kopíruje pomocí symbolického odkazu. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Opakování na ERROR_ACCESS_DENIED, protože proměnná prostředí MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Zdrojový soubor {0} je ve skutečnosti adresář.  Úloha kopírování nepodporuje kopírování adresářů.</target>
@@ -1057,7 +1072,7 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/msbuild/net8-binaryformatter</source>
-        <target state="translated">MSB3825: Prostředek „{0}“ typu „{1}“ je deserializován prostřednictvím BinaryFormatter za běhu. BinaryFormatter je zastaralý kvůli možným bezpečnostním rizikům a odebere se s .NET 9. Pokud ho chcete používat dál, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false. 
+        <target state="translated">MSB3825: Prostředek „{0}“ typu „{1}“ je deserializován prostřednictvím BinaryFormatter za běhu. BinaryFormatter je zastaralý kvůli možným bezpečnostním rizikům a odebere se s .NET 9. Pokud ho chcete používat dál, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false.
            Další informace: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
@@ -1930,6 +1945,11 @@
         <target state="translated">Byla nalezena neplatná PE hlavička. Implementační soubor nebude použit.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Reference, které jsou závislé na nebo byly sjednoceny s „{0}“ [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Neznámá architektura procesoru. V implementačním souboru {0} pro {1} je uvedena hodnota ImageFileMachine 0x{2}. Pokud chcete tento implementační soubor použít, zkontrolujte, zda je vlastnost ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch ve vašem projektu nastavena na hodnotu Warning nebo None.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 1db9a0ed02b..7f47881efba 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -191,6 +191,16 @@
         <target state="translated">Es wird ein fester Link erstellt, um "{0}" in "{1}" zu kopieren.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Erhalt von {0} Kopieren von "{1}" zu "{2}" und HR ist {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Es konnte kein Link verwendet werden, um "{0}" in "{1}" zu kopieren.</target>
@@ -221,6 +231,11 @@
         <target state="translated">Es konnte kein fester Link verwendet werden, um "{0}" in "{1}" zu kopieren. Stattdessen wird die Datei mit einer symbolischen Verknüpfung kopiert. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Wiederholung bei ERROR_ACCESS_DENIED, da Umgebungsvariable MSBUILDALWAYSRETRY=1 festgelegt ist</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Die Quelldatei "{0}" ist keine Datei, sondern ein Verzeichnis.  Mit der Copy-Aufgabe können keine Verzeichnisse kopiert werden.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">Ungültige PE-Kopfzeile gefunden. Die Implementierungsdatei wird nicht verwendet.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Verweise, die von „{0}“ [{1}] abhängen oder damit vereint wurden.</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Unbekannte Prozessorarchitektur. Die Implementierungsdatei "{0}" für "{1}" wies den ImageFileMachine-Wert "0x{2}" auf. Stellen Sie bei der Verwendung dieser Implementierungsdatei sicher, dass die "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch"-Eigenschaft im Projekt auf "Warning" oder "None" festgelegt ist.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 6bf3797e34f..887f8b3e7fe 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -118,7 +118,7 @@
       </trans-unit>
       <trans-unit id="AxTlbBaseTask.StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3654: Delay signing requires that at least a public key be specified.  Please either supply a public key using the KeyFile or KeyContainer properties, or disable delay signing.</source>
-        <target state="translated">MSB3654: La firma retardada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retardada.</target>
+        <target state="translated">MSB3654: La firma retrasada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retrasada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
@@ -191,6 +191,16 @@
         <target state="translated">Creando un vínculo físico para copiar "{0}" en "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Se obtuvo {0} al copiar "{1}" en "{2}" y HR es {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: No se puede usar un vínculo para copiar "{0}" en "{1}".</target>
@@ -221,6 +231,11 @@
         <target state="translated">No se puede usar un vínculo físico para copiar "{0}" en "{1}". Se va a copiar el archivo en un vínculo simbólico su lugar. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Reintentando el ERROR_ACCESS_DENIED porque la variable de entorno MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: El archivo de origen "{0}" es un directorio.  La tarea "Copy" no permite copiar directorios.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">Se encontró un encabezado PE no válido. No se usará el archivo de implementación.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Referencias que dependen o se han unificado para "{0}" [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Arquitectura de procesador desconocida. El archivo de implementación "{0}" para "{1}" tenía un valor ImageFileMachine de "0x{2}". Si desea usar este archivo de implementación, asegúrese de que la propiedad "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" del proyecto esté establecida en "Warning" o "None".</target>
@@ -2287,7 +2307,7 @@
       </trans-unit>
       <trans-unit id="ResolveComReference.LoadingDelaySignedAssemblyWithStrongNameVerificationEnabled">
         <source>MSB3295: Failed to load an assembly. Please make sure you have disabled strong name verification for your public key if you want to generate delay signed wrappers. {0}</source>
-        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Asegúrese de que deshabilitó la comprobación de nombres seguros para su clave pública si desea generar contenedores de firma retardada. {0}</target>
+        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Asegúrese de que deshabilitó la comprobación de nombres seguros para su clave pública si desea generar contenedores de firma con retraso. {0}</target>
         <note>{StrBegin="MSB3295: "}</note>
       </trans-unit>
       <trans-unit id="ResolveComReference.MissingOrUnknownComReferenceAttribute">
@@ -2496,7 +2516,7 @@
       </trans-unit>
       <trans-unit id="StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3353: Public key necessary for delay signing was not specified.</source>
-        <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma retardada.</target>
+        <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma con retraso.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 1c092fd0a8c..c17ecd226fe 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -191,6 +191,16 @@
         <target state="translated">Création d'un lien physique pour copier "{0}" vers "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Nous avons copié {0} «{1}» vers «{2}» et les ressources humaines sont {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: impossible d'utiliser un lien pour copier "{0}" vers "{1}".</target>
@@ -221,6 +231,11 @@
         <target state="translated">Impossible d’utiliser un lien physique pour copier «{0}» vers «{1}». Copie du fichier avec un lien symbolique à la place. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Nouvelle tentative sur ERROR_ACCESS_DENIED, car la variable d'environnement MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Le fichier source "{0}" est en fait un répertoire.  La tâche "Copy" ne prend pas en charge la copie des répertoires.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">En-tête PE non valide détecté. Le fichier d'implémentation ne sera pas utilisé.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Références qui dépendent ou ont été unifiées à «{0}» [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Architecture de processeur inconnue. Le fichier d'implémentation "{0}" pour "{1}" utilise la valeur "0x{2}" pour ImageFileMachine. Si vous voulez utiliser ce fichier d'implémentation, assurez-vous que la propriété "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" de votre projet est définie à la valeur "Warning" ou "None".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index fc2c0670f0a..805c5e45f99 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="translated">MSB3991: '{0}' non è impostato o è vuoto. Quando {1} è false, assicurarsi di impostare un valore non vuoto per '{0}'.</target>
+        <target state="translated">MSB3991: “{0}” non è impostato o è vuoto. Quando {1} è false, assicurarsi di impostare un valore non vuoto per "{0}".</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="translated">MSB3992: '{0}' non è impostato. Quando {1} è true, assicurarsi di impostare un valore per '{0}'.</target>
+        <target state="translated">MSB3992: "{0}" non impostato. Quando {1} è true, assicurarsi di impostare un valore per "{0}".</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
@@ -191,6 +191,16 @@
         <target state="translated">Creazione del collegamento reale per copiare "{0}" in "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Ottenuto {0} copiando "{1}" in "{2}" e HR è {3}"</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: non è stato possibile usare un collegamento per copiare "{0}" in "{1}".</target>
@@ -221,6 +231,11 @@
         <target state="translated">Impossibile utilizzare un collegamento reale per copiare "{0}" in "{1}". Verrà invece copiato il file con collegamento simbolico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Nuovo tentativo in ERROR_ACCESS_DENIED perché la variabile d'ambiente MSBUILDALWAYSRETRY = 1".</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: il file di origine "{0}" è in realtà una directory. L'attività "Copia" non supporta la copia di directory.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">È stata trovata un'intestazione PE non valida. Il file di implementazione non verrà usato.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Riferimenti che dipendono da o sono stati unificati per "{0}" [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: architettura del processore sconosciuta. Il file di implementazione "{0}" per "{1}" ha un valore ImageFileMachine pari a "0x{2}". Per usare questo file di implementazione, verificare che la proprietà "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" del progetto sia impostata su "Avviso" o "Nessuno".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 605cfdf73f4..cb79ec760f1 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -191,6 +191,16 @@
         <target state="translated">ハード リンクを作成して "{0}" を "{1}" にコピーしています。</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: "{1}" を "{2}" にコピー中に {0}が発生しました。HR は {3} です</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: リンクを使用して "{0}" を "{1}" にコピーできませんでした。</target>
@@ -221,6 +231,11 @@
         <target state="translated">ハード リンクを使用して "{0}" を "{1}" にコピーできませんでした。代わりにシンボリック リンクを使用してファイルをコピーしています。 {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: 環境変数 MSBUILDALWAYSRETRY = 1 のため、ERROR_ACCESS_DENIED で再試行しています</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: ソース ファイル "{0}" はディレクトリです。"Copy" タスクはディレクトリのコピーをサポートしません。</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">無効な PE ヘッダーが見つかりました。実装ファイルは使用されません。</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">"{0}" [{1}] に依存しているか、統合されている参照。</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: 不明なプロセッサ アーキテクチャです。"{1}" の実装ファイル "{0}" の ImageFileMachine 値は "0x{2}" でした。この実装ファイルを使用する場合は、プロジェクトの "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" プロパティに "警告" または "なし" を設定してください。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 39b15815f32..ff0c83ddead 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -191,6 +191,16 @@
         <target state="translated">"{0}"을(를) "{1}"(으)로 복사하기 위해 하드 링크를 만듭니다.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: {0}을(를) “{1}”(으)로 복사하는 “{2}”이(가) 있고 HR은 {3}입니다.</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: 링크를 사용하여 "{0}"을(를) "{1}"에 복사할 수 없습니다.</target>
@@ -221,6 +231,11 @@
         <target state="translated">하드 링크를 사용하여 "{0}(를) "{1}"에 복사할 수 없습니다. 대신 바로 가기 링크로 파일을 복사합니다. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: 환경 변수 MSBUILDALWAYSRETRY=1이므로 ERROR_ACCESS_DENIED에서 다시 시도합니다.</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 소스 파일 "{0}"은(는) 실제로 디렉터리입니다.  "Copy" 작업으로는 디렉터리를 복사할 수 없습니다.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">잘못된 PE 헤더를 찾았습니다. 구현 파일이 사용되지 않습니다.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">"{0}" [{1}]에 종속되거나 통합된 참조입니다.</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: 알 수 없는 프로세서 아키텍처입니다. "{1}"에 대한 구현 파일 "{0}"의 ImageFileMachine 값이 "0x{2}"입니다. 이 구현 파일을 사용하려면 프로젝트의 "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" 속성을 "Warning" 또는 "None"으로 지정하세요.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 56153414787..538c003870a 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -191,6 +191,16 @@
         <target state="translated">Tworzenie twardego łącza w celu skopiowania „{0}” do „{1}”.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: „Mam {0} kopiowane z „{1}” do „{2}”, a HR to {3}”</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Nie można użyć linku w celu skopiowania ścieżki „{0}” do ścieżki „{1}”.</target>
@@ -221,6 +231,11 @@
         <target state="translated">Nie można użyć twardego linku do skopiowania „{0}” do „{1}”. Zamiast tego kopiuje plik za pomocą linku symbolicznego. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: ponowienie próby w przypadku ERROR_ACCESS_DENIED, ponieważ zmienną środowiskową jest MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Plik źródłowy „{0}” jest w rzeczywistości katalogiem.  Zadanie „Copy” nie obsługuje kopiowania katalogów.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">Znaleziono nieprawidłowy nagłówek PE. Plik implementacji nie zostanie użyty.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Odwołania, które są zależne lub zostały ujednolicone dla „{0}” [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Nieznana architektura procesora. Plik implementacji {0} dla „{1}” ma wartość ImageFileMachine równą „0x{2}”. Jeśli chcesz użyć tego pliku implementacji, upewnij się, że dla właściwości „ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch” w projekcie jest ustawiona wartość „Warning” lub „None”.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index db84fa88b8a..524b1a5dd3a 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -191,6 +191,16 @@
         <target state="translated">Criando link físico para copiar "{0}" em "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Recebi {0} copiando "{1}" para {2} e o RH é {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Não foi possível usar um link para copiar "{0}" para "{1}".</target>
@@ -221,6 +231,11 @@
         <target state="translated">Não foi possível usar um link físico para copiar "{0}" para "{1}". Em vez disso, copiando o arquivo com link simbólico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Tentando novamente em ERROR_ACCESS_DENIED porque a variável de ambiente MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: O arquivo de origem "{0}" é, na verdade, um diretório.  A tarefa "Copy" não dá suporte à cópia de diretórios.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">Cabeçalho PE inválido encontrado. O arquivo de implementação não será usado.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Referências que dependem de ou foram unificadas para "{0}" [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Arquitetura de processador desconhecida. O arquivo de implementação "{0}" para "{1}" tinha um valor de ImageFileMachine igual a "0x{2}". Se desejar usar esse arquivo de implementação, certifique-se de que a propriedade "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" em seu projeto esteja definida como "Aviso" ou "Nenhum".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index d090d29ef62..92861aefb94 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -191,6 +191,16 @@
         <target state="translated">Создание жесткой связи для копирования "{0}" в "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Выполнено копирование {0} "{1}" в "{2}" и HR — {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: не удалось использовать связь для копирования "{0}" в "{1}".</target>
@@ -221,6 +231,11 @@
         <target state="translated">Не удалось использовать жесткую связь для копирования "{0}" в "{1}". Выполняется копирование файла с символьной ссылкой. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Повторная попытка ERROR_ACCESS_DENIED, поскольку переменная среды MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: исходный файл "{0}" в действительности является каталогом.  Задача Copy не поддерживает копирование каталогов.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">Обнаружен недопустимый PE-заголовок. Файл реализации не будет использован.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Зависимые или унифицированные ссылки для "{0}" [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: неизвестная архитектура процессора. Файл реализации "{0}" для "{1}" содержит перечисление ImageFileMachine со значением "0x{2}". Чтобы использовать этот файл реализации, необходимо задать для свойства ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch в проекте значение Warning или None.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index c5979af8059..6f21bc7686c 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -191,6 +191,16 @@
         <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak için sabit bağlantı oluşturuluyor.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: {0} için {1} yolu {2} yoluna kopyalandı ve HR: {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: "{0}" dosyasını "{1}" yoluna kopyalama bağlantısı kullanılamadı.</target>
@@ -221,6 +231,11 @@
         <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak için sabit bağlantı kullanılamadı. Dosya bunun yerine sembolik bağlantı ile kopyalanıyor. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: MSBUILDALWAYSRETRY ortam değişkeni = 1 olduğundan ERROR_ACCESS_DENIED üzerinde yeniden deneniyor</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: "{0}" kaynak dosyası aslında bir dizindir.  "Kopyala" görevi, dizinleri kopyalamayı desteklemez.</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">Geçersiz PE üst bilgisi bulundu. Uygulama dosyası kullanılmayacak.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">"{0}" [{1}] öğesine bağlı veya öğesi biçiminde birleştirilen başvurular.</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Bilinmeyen işlemci mimarisi. "{1}" için "{0}" uygulama dosyasında ImageFileMachine değeri olarak "0x{2}" vardı. Bu uygulama dosyasını kullanmak istiyorsanız, projenizdeki "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" özelliğinin "Warning" veya "None" olarak ayarlandığından emin olun.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 8b146319e98..5eaa6e5c033 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -191,6 +191,16 @@
         <target state="translated">创建硬链接以将“{0}”复制到“{1}”。</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: 将 "{1}" 复制到 "{2}" 时出现 {0}，HR 为 {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: 无法使用链接将“{0}”复制到“{1}”。</target>
@@ -221,6 +231,11 @@
         <target state="translated">无法使用硬链接将“{0}”复制到“{1}”。改为使用符号链接复制文件。 {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: 重试 ERROR_ACCESS_DENIED，因为环境变量 MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 源文件“{0}”实际上是一个目录。“Copy”任务不支持复制目录。</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">找到的 PE 头无效。将不会使用实现文件。</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">依赖于或已统一到“{0}”[{1}] 的引用。</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: 未知的处理器架构。“{1}”的实现文件“{0}”的 ImageFileMachine 值为“0x{2}”。如果您想要使用此实现文件，请确保项目中的“ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch”属性设置为“警告”或“无”。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index c03fdbd6641..1c84180067e 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -191,6 +191,16 @@
         <target state="translated">正在建立永久連結將 "{0}" 複製到 "{1}"。</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: 擁有 {0} 將 "{1}" 複製至 "{2}"，且 HR 為 {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="new">MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: 無法使用連結將 "{0}" 複製到 "{1}"。</target>
@@ -221,6 +231,11 @@
         <target state="translated">無法使用永久連結將 "{0}" 複製到 "{1}"。請改為使用符號連結複製檔案。{2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: 正在 ERROR_ACCESS_DENIED 上重試，因為環境變數 MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 來源檔案 "{0}" 其實是目錄。"Copy" 工作不支援複製目錄。</target>
@@ -1930,6 +1945,11 @@
         <target state="translated">發現無效的 PE 標頭。將不使用實作檔。</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">依賴或已整合至 "{0}" [{1}] 的參考。</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: 未知的處理器架構。"{1}" 的實作檔 "{0}" 中 ImageFileMachine 值為 "0x{2}"。如果要使用這個實作檔，請確定專案中的 "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" 屬性設為 "Warning" 或 "None"。</target>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
index f65af92cfed..2d97134b43c 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
@@ -4,6 +4,7 @@
 using System;
 using System.IO;
 using System.Linq;
+using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 
@@ -14,7 +15,7 @@ namespace Microsoft.Build.Tasks
     internal abstract class RoslynCodeTaskFactoryCompilerBase : ToolTaskExtension
     {
 #if RUNTIME_TYPE_NETCORE
-        private static readonly string DotnetCliPath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;
+        private readonly string _dotnetCliPath;
 #endif
 
         private readonly Lazy<string> _executablePath;
@@ -43,6 +44,26 @@ protected RoslynCodeTaskFactoryCompilerBase()
             }, isThreadSafe: true);
 
             StandardOutputImportance = MessageImportance.Low.ToString("G");
+
+#if RUNTIME_TYPE_NETCORE
+            // Tools and MSBuild Tasks within the SDK that invoke binaries via the dotnet host are expected
+            // to honor the environment variable DOTNET_HOST_PATH to ensure a consistent experience.
+            _dotnetCliPath = Environment.GetEnvironmentVariable("DOTNET_HOST_PATH");
+            if (string.IsNullOrEmpty(_dotnetCliPath))
+            {
+                // Fallback to get dotnet path from current process which might be dotnet executable.
+                _dotnetCliPath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;
+            }
+
+            // If dotnet path is not found, rely on dotnet via the system's PATH
+            bool runningOnWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
+            string exeSuffix = runningOnWindows ? ".exe" : string.Empty;
+            var dotnetFileName = $"dotnet{exeSuffix}";
+            if (!_dotnetCliPath.EndsWith(dotnetFileName, StringComparison.OrdinalIgnoreCase))
+            {
+                _dotnetCliPath = "dotnet";
+            }
+#endif
         }
 
         public bool? Deterministic { get; set; }
@@ -99,7 +120,7 @@ protected override string GenerateFullPathToTool()
             }
 
 #if RUNTIME_TYPE_NETCORE
-            return DotnetCliPath;
+            return _dotnetCliPath;
 #else
             return _executablePath.Value;
 #endif
diff --git a/src/Tasks/SGen.cs b/src/Tasks/SGen.cs
index 8ed872450f0..743cbf2eaf8 100644
--- a/src/Tasks/SGen.cs
+++ b/src/Tasks/SGen.cs
@@ -305,7 +305,7 @@ protected override string GenerateFullPathToTool()
         {
             string pathToTool = null;
 
-            // If COMPLUS_InstallRoot\COMPLUS_Version are set (the dogfood world), we want to find it there, instead of 
+            // If COMPLUS_InstallRoot\COMPLUS_Version are set (the dogfood world), we want to find it there, instead of
             // the SDK, which may or may not be installed. The following will look there.
             if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("COMPLUS_InstallRoot")) || !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("COMPLUS_Version")))
             {
@@ -401,7 +401,7 @@ protected override string GenerateCommandLineCommands()
                 // The arguments to the "/compiler" switch are themselves switches to be passed to
                 // the compiler when generating the serialization assembly.
 
-                // Add the compiler command switches for strong naming on the serialization assembly          
+                // Add the compiler command switches for strong naming on the serialization assembly
                 if (KeyFile != null)
                 {
                     commandLineBuilder.AppendNestedSwitch("/compiler:", "/keyfile:", KeyFile);
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index 35e2efb656e..bba221c57cb 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -109,7 +109,7 @@ internal static string GeneratePathToTool(FileExists fileExists, string currentA
                 }
             }
 
-            // Fall back and see if we can find it with the toolsLocation helper methods. This is not optimal because 
+            // Fall back and see if we can find it with the toolsLocation helper methods. This is not optimal because
             // the location they are looking at is based on when the Microsoft.Build.Utilities.dll was compiled
             // but it is better than nothing.
             if (pathToTool == null || !fileExists(pathToTool))
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 96a4e7d7ce8..7e1e971b48d 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -116,7 +116,7 @@ internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log) w
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                // The deserialization process seems like it can throw just about 
+                // The deserialization process seems like it can throw just about
                 // any exception imaginable.  Catch them all here.
                 // Not being able to deserialize the cache is not an error, but we let the user know anyway.
                 // Don't want to hold up processing just because we couldn't read the file.
diff --git a/src/Tasks/StrongNameUtils.cs b/src/Tasks/StrongNameUtils.cs
index 7c2fa1a52fd..7e615bbe4b7 100644
--- a/src/Tasks/StrongNameUtils.cs
+++ b/src/Tasks/StrongNameUtils.cs
@@ -79,7 +79,7 @@ internal static void ReadKeyFile(TaskLoggingHelper log, string keyFile, out Stro
                 publicKey = snp.PublicKey;
 
                 // If we didn't throw up to this point then we have a valid public/private key pair,
-                // so assign the object just created above to the out parameter.  
+                // so assign the object just created above to the out parameter.
                 keyPair = snp;
             }
             catch (ArgumentException)
@@ -280,7 +280,7 @@ private static uint GetCor20HeaderRva(IntPtr ntHeadersPtr)
 
             // cor20DataDirectoryLong is really a IMAGE_DATA_DIRECTORY structure which I had to pack into an ulong
             // (see comments for IMAGE_OPTIONAL_HEADER32/64 in NativeMethods.cs)
-            // this code extracts the virtualAddress (uint) and size (uint) fields from the ulong by doing simple 
+            // this code extracts the virtualAddress (uint) and size (uint) fields from the ulong by doing simple
             // bit masking/shifting ops
             uint virtualAddress = (uint)(cor20DataDirectoryLong & 0x00000000ffffffff);
             // uint size = (uint)(cor20DataDirectoryLong >> 32);
diff --git a/src/Tasks/System.Resources.Extensions.pkgdef b/src/Tasks/System.Resources.Extensions.pkgdef
index 9315270511f..62579ad4643 100644
--- a/src/Tasks/System.Resources.Extensions.pkgdef
+++ b/src/Tasks/System.Resources.Extensions.pkgdef
@@ -4,4 +4,4 @@
 "publicKeyToken"="cc7b13ffcd2ddd51"
 "culture"="neutral"
 "oldVersion"="0.0.0.0-99.9.9.9"
-"newVersion"="7.0.0.0"
+"newVersion"="8.0.0.0"
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 8774ba6773b..dd09094f7d1 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -48,21 +48,21 @@ internal sealed class SystemState : StateFileBase, ITranslatable
 
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
-        /// cache this for long periods of time since there's no way (without actually 
+        /// cache this for long periods of time since there's no way (without actually
         /// calling File.GetLastWriteTimeUtc) to tell whether the cache is out-of-date.
         /// </summary>
         private Dictionary<string, DateTime> instanceLocalLastModifiedCache = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// DirectoryExists information is purely instance-local. It doesn't make sense to
-        /// cache this for long periods of time since there's no way (without actually 
+        /// cache this for long periods of time since there's no way (without actually
         /// calling Directory.Exists) to tell whether the cache is out-of-date.
         /// </summary>
         private Dictionary<string, bool> instanceLocalDirectoryExists = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// GetDirectories information is also purely instance-local. This information
-        /// is only considered good for the lifetime of the task (or whatever) that owns 
+        /// is only considered good for the lifetime of the task (or whatever) that owns
         /// this instance.
         /// </summary>
         private Dictionary<string, string[]> instanceLocalDirectories = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
@@ -298,7 +298,7 @@ internal void SetGetLastWriteTime(GetLastWriteTime getLastWriteTimeValue)
         }
 
         /// <summary>
-        /// Cache the results of a GetAssemblyName delegate. 
+        /// Cache the results of a GetAssemblyName delegate.
         /// </summary>
         /// <param name="getAssemblyNameValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
@@ -309,7 +309,7 @@ internal GetAssemblyName CacheDelegate(GetAssemblyName getAssemblyNameValue)
         }
 
         /// <summary>
-        /// Cache the results of a GetAssemblyMetadata delegate. 
+        /// Cache the results of a GetAssemblyMetadata delegate.
         /// </summary>
         /// <param name="getAssemblyMetadataValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
@@ -320,7 +320,7 @@ internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetada
         }
 
         /// <summary>
-        /// Cache the results of a FileExists delegate. 
+        /// Cache the results of a FileExists delegate.
         /// </summary>
         /// <returns>Cached version of the delegate.</returns>
         internal FileExists CacheDelegate()
@@ -335,7 +335,7 @@ public DirectoryExists CacheDelegate(DirectoryExists directoryExistsValue)
         }
 
         /// <summary>
-        /// Cache the results of a GetDirectories delegate. 
+        /// Cache the results of a GetDirectories delegate.
         /// </summary>
         /// <param name="getDirectoriesValue">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
@@ -346,7 +346,7 @@ internal GetDirectories CacheDelegate(GetDirectories getDirectoriesValue)
         }
 
         /// <summary>
-        /// Cache the results of a GetAssemblyRuntimeVersion delegate. 
+        /// Cache the results of a GetAssemblyRuntimeVersion delegate.
         /// </summary>
         /// <param name="getAssemblyRuntimeVersion">The delegate.</param>
         /// <returns>Cached version of the delegate.</returns>
@@ -483,7 +483,7 @@ private AssemblyNameExtension GetAssemblyName(string path)
                 fileState.Assembly = getAssemblyName(path);
 
                 // Certain assemblies, like mscorlib may not have metadata.
-                // Avoid continuously calling getAssemblyName on these files by 
+                // Avoid continuously calling getAssemblyName on these files by
                 // recording these as having an empty name.
                 if (fileState.Assembly == null)
                 {
@@ -523,7 +523,7 @@ private string GetRuntimeVersion(string path)
         }
 
         /// <summary>
-        /// Cached implementation. Given an assembly name, crack it open and retrieve the list of dependent 
+        /// Cached implementation. Given an assembly name, crack it open and retrieve the list of dependent
         /// assemblies and  the list of scatter files.
         /// </summary>
         /// <param name="path">Path to the assembly.</param>
@@ -649,7 +649,7 @@ private string[] GetDirectories(string path, string pattern)
                 return cached;
             }
 
-            // This path is currently uncalled. Use assert to tell the dev that adds a new code-path 
+            // This path is currently uncalled. Use assert to tell the dev that adds a new code-path
             // that this is an unoptimized path.
             Debug.Assert(false, "Using slow-path in SystemState.GetDirectories, was this intentional?");
 
diff --git a/src/Tasks/TaskRequiresFramework.cs b/src/Tasks/TaskRequiresFramework.cs
new file mode 100644
index 00000000000..e681eb903b5
--- /dev/null
+++ b/src/Tasks/TaskRequiresFramework.cs
@@ -0,0 +1,30 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+
+using System;
+
+namespace Microsoft.Build.Tasks
+{
+#if NETFRAMEWORK
+    [Obsolete("The class should not be used in .Net Framework.", true)]
+#endif
+    public abstract class TaskRequiresFramework : TaskExtension
+    {
+        internal TaskRequiresFramework(string taskName) => TaskName = taskName;
+
+        private string TaskName { get; set; }
+
+#if !NETFRAMEWORK
+        /// <summary>
+        /// Task entry point.
+        /// </summary>
+        /// <returns></returns>
+        public override bool Execute()
+        {
+            Log.LogErrorWithCodeFromResources("TaskRequiresFrameworkFailure", TaskName);
+            return false;
+        }
+#endif
+    }
+}
diff --git a/src/Tasks/TlbImp.cs b/src/Tasks/TlbImp.cs
index 1c9bc7c6228..db367d81977 100644
--- a/src/Tasks/TlbImp.cs
+++ b/src/Tasks/TlbImp.cs
@@ -273,7 +273,7 @@ protected override bool ValidateParameters()
                     return false;
                 }
 
-                // Verify that an allowed combination of TlbImpTransformFlags has been 
+                // Verify that an allowed combination of TlbImpTransformFlags has been
                 // passed to the Transform property.
                 if (!ValidateTransformFlags())
                 {
diff --git a/src/Tasks/TlbReference.cs b/src/Tasks/TlbReference.cs
index 12a00027180..9334ab87fbb 100644
--- a/src/Tasks/TlbReference.cs
+++ b/src/Tasks/TlbReference.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Tasks
 {
     /*
      * Class:   TlbReference
-     * 
+     *
      * COM reference wrapper class for the tlbimp tool.
      *
      */
@@ -85,7 +85,7 @@ internal TlbReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComRefe
 
         /*
          * Method:  GetWrapperFileName
-         * 
+         *
          * Constructs the wrapper file name from a type library name.
          */
         protected override string GetWrapperFileNameInternal(string typeLibName)
@@ -122,7 +122,7 @@ internal static string GetWrapperFileName(string typeLibName, bool includeTypeLi
 
         /*
          * Method:  FindExistingWrapper
-         * 
+         *
          * Checks if there's a preexisting wrapper for this reference.
          */
         internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp)
@@ -139,7 +139,7 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
 
         /*
          * Method:  GenerateWrapper
-         * 
+         *
          * Generates a wrapper for this reference.
          */
         internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
@@ -298,7 +298,7 @@ internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
 
         /*
          * Method:  WriteWrapperToDisk
-         * 
+         *
          * Writes the generated wrapper out to disk. Should only be called for permanent wrappers.
          */
         private void WriteWrapperToDisk(AssemblyBuilder assemblyBuilder, string wrapperPath)
@@ -341,12 +341,12 @@ private void WriteWrapperToDisk(AssemblyBuilder assemblyBuilder, string wrapperP
                     case UtilitiesProcessorArchitecture.MSIL:
                     default:
                         // If no target processor architecture was passed, we assume MSIL; calling Save
-                        // with no parameters should be equivalent to saving as ILOnly.  
+                        // with no parameters should be equivalent to saving as ILOnly.
                         assemblyBuilder.Save(wrapperFile.Name);
                         break;
                 }
 
-                // AssemblyBuilder doesn't always throw when it's supposed to write stuff to a non-writable 
+                // AssemblyBuilder doesn't always throw when it's supposed to write stuff to a non-writable
                 // network path. Make sure that the assembly actually got written to where we wanted it to.
                 File.GetLastWriteTime(wrapperPath);
             }
@@ -367,8 +367,8 @@ private void WriteWrapperToDisk(AssemblyBuilder assemblyBuilder, string wrapperP
 
         /*
          * Method:  ITypeLibImporterNotifySink.ResolveRef
-         * 
-         * Implementation of ITypeLibImporterNotifySink.ResolveRef - this method is called by the NDP type lib converter 
+         *
+         * Implementation of ITypeLibImporterNotifySink.ResolveRef - this method is called by the NDP type lib converter
          * to resolve dependencies.
          * We should never return null here - it's not documented as the proper way of failing dependency resolution.
          * Instead, we use an exception to abort the conversion process.
@@ -408,7 +408,7 @@ Assembly ITypeLibImporterNotifySink.ResolveRef(object objTypeLib)
 
         /*
          * Method:  ITypeLibImporterNotifySink.ReportEvent
-         * 
+         *
          * Implementation of ITypeLibImporterNotifySink.ReportEvent - this method gets called by NDP type lib converter
          * to report various messages (like "type blahblah converted" or "failed to convert type blahblah").
          */
diff --git a/src/Tasks/Touch.cs b/src/Tasks/Touch.cs
index 75d00478679..8ab11f27c8f 100644
--- a/src/Tasks/Touch.cs
+++ b/src/Tasks/Touch.cs
@@ -97,8 +97,8 @@ internal bool ExecuteImpl(
                     continue;
                 }
 
-                // Touch the file.  If the file was touched successfully then add it to our array of 
-                // touched items. 
+                // Touch the file.  If the file was touched successfully then add it to our array of
+                // touched items.
                 if
                 (
                     TouchFile(
@@ -123,7 +123,7 @@ internal bool ExecuteImpl(
             }
 
             // Now, set the property that indicates which items we touched.  Note that we
-            // touch all the items 
+            // touch all the items
             TouchedFiles = touchedItems.ToArray();
             return retVal;
         }
@@ -202,8 +202,7 @@ private bool TouchFile(
                 {
                     if (FailIfNotIncremental)
                     {
-                        Log.LogErrorFromResources("Touch.CreatingFile", file, "AlwaysCreate");
-                        return false;
+                        Log.LogWarningFromResources("Touch.CreatingFile", file, "AlwaysCreate");
                     }
                     else
                     {
@@ -222,18 +221,16 @@ private bool TouchFile(
                 }
             }
 
-            // Ignore touching the disk when FailIfNotIncremental.
             if (FailIfNotIncremental)
             {
-                Log.LogErrorFromResources("Touch.Touching", file);
-                return false;
+                Log.LogWarningFromResources("Touch.Touching", file);
             }
             else
             {
                 Log.LogMessageFromResources(messageImportance, "Touch.Touching", file);
             }
 
-            // If the file is read only then we must either issue an error, or, if the user so 
+            // If the file is read only then we must either issue an error, or, if the user so
             // specified, make the file temporarily not read only.
             bool needToRestoreAttributes = false;
             FileAttributes faOriginal = fileGetAttributes(file);
@@ -271,7 +268,7 @@ private bool TouchFile(
             {
                 if (needToRestoreAttributes)
                 {
-                    // Attempt to restore the attributes.  If we fail here, then there is 
+                    // Attempt to restore the attributes.  If we fail here, then there is
                     // not much we can do.
                     try
                     {
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 4c297df27fd..6060fb33b8e 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if FEATURE_APPDOMAIN
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
 
 using System;
 #if DEBUG
@@ -14,19 +14,23 @@
 using System.Threading;
 using System.Runtime.InteropServices.ComTypes;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
+
     /// <summary>
     /// Registers a managed assembly for COM interop (equivalent of regasm.exe functionality, but this code
     /// doesn't actually call the exe).
     /// </summary>
-    public class UnregisterAssembly : AppDomainIsolatedTaskExtension
+    public class UnregisterAssembly : AppDomainIsolatedTaskExtension, IUnregisterAssemblyTaskContract
     {
         #region Properties
 
@@ -154,7 +158,7 @@ private bool Unregister(string assemblyPath, string typeLibPath)
             {
                 try
                 {
-                    // Load the specified assembly. 
+                    // Load the specified assembly.
                     Assembly asm = Assembly.UnsafeLoadFrom(assemblyPath);
 
                     var comRegistrar = new RegistrationServices();
@@ -166,7 +170,7 @@ private bool Unregister(string assemblyPath, string typeLibPath)
                         // Unregister the assembly
                         if (!comRegistrar.UnregisterAssembly(asm))
                         {
-                            // If the assembly doesn't contain any types that could be registered for COM interop, 
+                            // If the assembly doesn't contain any types that could be registered for COM interop,
                             // warn the user about it
                             Log.LogWarningWithCodeFromResources("UnregisterAssembly.NoValidTypes", assemblyPath);
                         }
@@ -289,5 +293,37 @@ private bool Unregister(string assemblyPath, string typeLibPath)
         private const string unregisteringLockName = "MSBUILD_V_3_5_UNREGISTER_LOCK";
         #endregion
     }
-}
+
+#elif !NETFRAMEWORK
+
+    public sealed class UnregisterAssembly : TaskRequiresFramework, IUnregisterAssemblyTaskContract
+    {
+        public UnregisterAssembly()
+            : base(nameof(UnregisterAssembly))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] Assemblies { get; set; }
+
+        public ITaskItem[] TypeLibFiles { get; set; }
+
+        public ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+
 #endif
+
+    public interface IUnregisterAssemblyTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] Assemblies { get; set; }
+        ITaskItem[] TypeLibFiles { get; set; }
+        ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+}
diff --git a/src/Tasks/UpdateManifest.cs b/src/Tasks/UpdateManifest.cs
index 0e9e78bef9c..109f7ee732c 100644
--- a/src/Tasks/UpdateManifest.cs
+++ b/src/Tasks/UpdateManifest.cs
@@ -2,17 +2,22 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Build.Framework;
+
+#if NETFRAMEWORK
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
+#endif
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Updates selected properties in a manifest and resigns.
     /// </summary>
-    public class UpdateManifest : Task
+    public class UpdateManifest : Task, IUpdateManifestTaskContract
     {
         [Required]
         public string ApplicationPath { get; set; }
@@ -35,4 +40,44 @@ public override bool Execute()
             return true;
         }
     }
+
+#else
+
+    public sealed class UpdateManifest : TaskRequiresFramework, IUpdateManifestTaskContract
+    {
+        public UpdateManifest()
+            : base(nameof(UpdateManifest))
+        {
+        }
+
+        #region Properties
+
+        public string ApplicationPath { get; set; }
+
+        public string TargetFrameworkVersion { get; set; }
+
+        public ITaskItem ApplicationManifest { get; set; }
+
+        public ITaskItem InputManifest { get; set; }
+
+        [Output]
+        public ITaskItem OutputManifest { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IUpdateManifestTaskContract
+    {
+        #region Properties
+
+        string ApplicationPath { get; set; }
+        string TargetFrameworkVersion { get; set; }
+        ITaskItem ApplicationManifest { get; set; }
+        ITaskItem InputManifest { get; set; }
+        ITaskItem OutputManifest { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/WinMDExp.cs b/src/Tasks/WinMDExp.cs
index 28e2662c997..24fdc5dbff8 100644
--- a/src/Tasks/WinMDExp.cs
+++ b/src/Tasks/WinMDExp.cs
@@ -1,21 +1,28 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Text;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
+#endif
+
+using System.Diagnostics.CodeAnalysis;
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Exports a managed assembly to a windows runtime metadata.
     /// </summary>
-    public class WinMDExp : ToolTaskExtension
+    public class WinMDExp : ToolTaskExtension, IWinMDExpTaskContract
     {
         #region Properties
 
@@ -262,7 +269,7 @@ protected override bool SkipTaskExecution()
                 var outputWriteTime = NativeMethodsShared.GetLastWriteFileUtcTime(OutputWindowsMetadataFile);
                 var winMDModuleWriteTime = NativeMethodsShared.GetLastWriteFileUtcTime(WinMDModule);
 
-                // If the last write time of the input file is less than the last write time of the output file 
+                // If the last write time of the input file is less than the last write time of the output file
                 // then the output is newer then the input so we do not need to re-run the tool.
                 if (outputWriteTime > winMDModuleWriteTime)
                 {
@@ -274,4 +281,66 @@ protected override bool SkipTaskExecution()
         }
         #endregion
     }
+
+#else
+
+    public sealed class WinMDExp : TaskRequiresFramework, IWinMDExpTaskContract
+    {
+        public WinMDExp()
+            : base(nameof(WinMDExp))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] References { get; set; }
+
+        public string DisabledWarnings { get; set; }
+
+        public string InputDocumentationFile { get; set; }
+
+        public string OutputDocumentationFile { get; set; }
+
+        public string InputPDBFile { get; set; }
+
+        public string OutputPDBFile { get; set; }
+
+        public string WinMDModule { get; set; }
+
+        [Output]
+        public string OutputWindowsMetadataFile { get; set; }
+
+        public string SdkToolsPath { get; set; }
+
+        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "UTF", Justification = "Not worth breaking customers because of case correction")]
+        public bool UTF8Output { get; set; }
+
+        public bool TreatWarningsAsErrors { get; set; }
+
+        public string AssemblyUnificationPolicy { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IWinMDExpTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] References { get; set; }
+        string DisabledWarnings { get; set; }
+        string InputDocumentationFile { get; set; }
+        string OutputDocumentationFile { get; set; }
+        string InputPDBFile { get; set; }
+        string OutputPDBFile { get; set; }
+        string WinMDModule { get; set; }
+        string OutputWindowsMetadataFile { get; set; }
+        string SdkToolsPath { get; set; }
+        bool UTF8Output { get; set; }
+        bool TreatWarningsAsErrors { get; set; }
+        string AssemblyUnificationPolicy { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 19692a2fec9..c97bcb45557 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -642,8 +642,8 @@ private void GenerateStandardCommandLine(CommandLineBuilder builder, bool allOpt
         /// </summary>
         private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
         {
-            // Match all instances of [asdf], where "asdf" can be any combination of any 
-            // characters *except* a [ or an ]. i.e., if "[ [ sdf ]" is passed, then we will 
+            // Match all instances of [asdf], where "asdf" can be any combination of any
+            // characters *except* a [ or an ]. i.e., if "[ [ sdf ]" is passed, then we will
             // match "[ sdf ]"
             string matchString = @"\[[^\[\]]+\]";
             Regex regex = new Regex(matchString, RegexOptions.ECMAScript);
@@ -658,32 +658,32 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
                 }
 
                 // Because we match non-greedily, in the case where we have input such as "[[[[[foo]", the match will
-                // be "[foo]".  However, if there are multiple '[' in a row, we need to do some escaping logic, so we 
-                // want to know what the first *consecutive* square bracket was.  
+                // be "[foo]".  However, if there are multiple '[' in a row, we need to do some escaping logic, so we
+                // want to know what the first *consecutive* square bracket was.
                 int indexOfFirstBracketInMatch = match.Index;
 
-                // Indexing using "indexOfFirstBracketInMatch - 1" is safe here because it will always be 
-                // greater than indexOfEndOfLastSubstitution, which will always be 0 or greater. 
+                // Indexing using "indexOfFirstBracketInMatch - 1" is safe here because it will always be
+                // greater than indexOfEndOfLastSubstitution, which will always be 0 or greater.
                 while (indexOfFirstBracketInMatch > indexOfEndOfLastSubstitution && CommandLineTemplate[indexOfFirstBracketInMatch - 1].Equals('['))
                 {
                     indexOfFirstBracketInMatch--;
                 }
 
-                // Append everything we know we want to add -- everything between where the last substitution ended and 
-                // this match (including previous '[' that were not initially technically part of the match) begins. 
+                // Append everything we know we want to add -- everything between where the last substitution ended and
+                // this match (including previous '[' that were not initially technically part of the match) begins.
                 if (indexOfFirstBracketInMatch != indexOfEndOfLastSubstitution)
                 {
                     builder.AppendTextUnquoted(CommandLineTemplate.Substring(indexOfEndOfLastSubstitution, indexOfFirstBracketInMatch - indexOfEndOfLastSubstitution));
                 }
 
-                // Now replace every "[[" with a literal '['.  We can do this by simply counting the number of '[' between 
-                // the first one and the start of the match, since by definition everything in between is an '['.  
-                // + 1 because match.Index is also a bracket. 
+                // Now replace every "[[" with a literal '['.  We can do this by simply counting the number of '[' between
+                // the first one and the start of the match, since by definition everything in between is an '['.
+                // + 1 because match.Index is also a bracket.
                 int openBracketsInARow = match.Index - indexOfFirstBracketInMatch + 1;
 
                 if (openBracketsInARow % 2 == 0)
                 {
-                    // even number -- they all go away and the rest of the match is appended literally. 
+                    // even number -- they all go away and the rest of the match is appended literally.
                     for (int i = 0; i < openBracketsInARow / 2; i++)
                     {
                         builder.AppendTextUnquoted("[");
@@ -693,7 +693,7 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
                 }
                 else
                 {
-                    // odd number -- all but one get merged two at a time, and the rest of the match is substituted. 
+                    // odd number -- all but one get merged two at a time, and the rest of the match is substituted.
                     for (int i = 0; i < (openBracketsInARow - 1) / 2; i++)
                     {
                         builder.AppendTextUnquoted("[");
@@ -726,8 +726,8 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
                     }
                     else if (!PropertyExists(propertyName))
                     {
-                        // If the thing enclosed in square brackets is not in fact a property, we 
-                        // don't want to replace it. 
+                        // If the thing enclosed in square brackets is not in fact a property, we
+                        // don't want to replace it.
                         builder.AppendTextUnquoted('[' + propertyName + ']');
                     }
                 }
diff --git a/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs b/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
index a1abf73861f..ba932ea9239 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineToolSwitch.cs
@@ -26,7 +26,7 @@ public enum CommandLineToolSwitchType
 
         /// <summary>
         /// The integer switch is used for properties that have several different integer values,
-        /// and depending on the value the property is set to, appends an integer to the end 
+        /// and depending on the value the property is set to, appends an integer to the end
         /// of a certain switch
         /// e.g. WarningLevel = "0" is /W0, WarningLevel = "2" is /W2
         /// </summary>
@@ -42,7 +42,7 @@ public enum CommandLineToolSwitchType
         String = 2,
 
         /// <summary>
-        /// The stringarray switch is used for properties that may have more 
+        /// The stringarray switch is used for properties that may have more
         /// than one string appended to the end of the switch
         /// e.g. InjectPrecompiledHeaderReference = myfile is /Ylmyfile
         /// </summary>
@@ -199,15 +199,15 @@ public CommandLineToolSwitch(CommandLineToolSwitchType toolType)
 
         /// <summary>
         /// The separator indicates the characters that go between the switch and the string
-        /// in the string typed case, the characters that go between each name for the 
-        /// string array case, or the characters that go between the switch and the 
+        /// in the string typed case, the characters that go between each name for the
+        /// string array case, or the characters that go between the switch and the
         /// appendage for the boolean case.
         /// </summary>
         public string Separator { get; set; } = String.Empty;
 
         /// <summary>
         /// The Fallback attribute is used to specify which property to look at in the
-        /// case that the argument property is not set, or if the file that the 
+        /// case that the argument property is not set, or if the file that the
         /// argument property indicates is nonexistent.
         /// </summary>
         public string FallbackArgumentParameter { get; set; } = String.Empty;
diff --git a/src/Tasks/XamlTaskFactory/Property.cs b/src/Tasks/XamlTaskFactory/Property.cs
index e035df86c4c..bd7a04313e3 100644
--- a/src/Tasks/XamlTaskFactory/Property.cs
+++ b/src/Tasks/XamlTaskFactory/Property.cs
@@ -93,22 +93,22 @@ internal class Property
 
         /// <summary>
         /// The max integer value an integer typed switch can have
-        /// An exception should be thrown in the number the user specifies is 
+        /// An exception should be thrown in the number the user specifies is
         /// larger than the max
         /// </summary>
         public string Max { get; set; } = String.Empty;
 
         /// <summary>
         /// The minimum integer value an integer typed switch can have
-        /// An exception should be thrown in the number the user specifies is 
+        /// An exception should be thrown in the number the user specifies is
         /// less than the minimum
         /// </summary>
         public string Min { get; set; } = String.Empty;
 
         /// <summary>
         /// The separator indicates the characters that go between the switch and the string
-        /// in the string typed case, the characters that go between each name for the 
-        /// string array case, or the characters that go between the switch and the 
+        /// in the string typed case, the characters that go between each name for the
+        /// string array case, or the characters that go between the switch and the
         /// appendage for the boolean case.
         /// </summary>
         public string Separator { get; set; } = String.Empty;
@@ -132,7 +132,7 @@ internal class Property
 
         /// <summary>
         /// The Fallback attribute is used to specify which property to look at in the
-        /// case that the argument property is not set, or if the file that the 
+        /// case that the argument property is not set, or if the file that the
         /// argument property indicates is nonexistent.
         /// </summary>
         public string Fallback { get; set; } = String.Empty;
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 8ef3dee1bf3..6a119d563f2 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -529,7 +529,7 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
                 child = child.NextSibling;
             }
 
-            // We've read any enumerated values and any dependencies, so we just 
+            // We've read any enumerated values and any dependencies, so we just
             // have to add the switchRelations
             switchRelationsList.Add(switchRelationsToAdd.SwitchValue, switchRelationsToAdd);
             return true;
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index 394daa631bd..38a2a4562e5 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -396,7 +396,7 @@ internal CodeCompileUnit GenerateCode()
                 // generate the constructor for this class
                 GenerateConstructor(taskClass);
 
-                // generate the property for ToolName 
+                // generate the property for ToolName
                 GenerateToolNameProperty(taskClass);
 
                 // generate all of the properties
@@ -760,7 +760,7 @@ private void GenerateIntegers(Property property, CodeMemberProperty propertyName
             // set statments
             GenerateCommon(property, propertyName, TypeInteger, typeof(Int32), NumberProperty);
 
-            // if a min or max exists, check those boundaries        
+            // if a min or max exists, check those boundaries
             CodeExpression[] parameters;
             string name = property.SwitchName != String.Empty ? property.Prefix + property.SwitchName : property.Name;
             if (!String.IsNullOrEmpty(property.Min) && !String.IsNullOrEmpty(property.Max))
@@ -835,7 +835,7 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
                 {
                     if (ContainsCurrentPlatform(val.SwitchName))
                     {
-                        // Create the array of argument expressions.                        
+                        // Create the array of argument expressions.
                         var argumentInitializers = new List<CodeObjectCreateExpression>(val.Arguments.Count);
                         foreach (Argument arg in val.Arguments)
                         {
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index af2ba073221..bd9f1aa2185 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -401,14 +401,14 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
                 argumentDependencyLookup.Add(propertyToAdd.Name, propertyToAdd);
             }
 
-            // We've read any enumerated values and any dependencies, so we just 
+            // We've read any enumerated values and any dependencies, so we just
             // have to add the property
             propertyList.AddLast(propertyToAdd);
             return true;
         }
 
         /// <summary>
-        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
+        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for
         /// this parameter group
         /// </summary>
         private static Property ObtainAttributes(XamlTypes.BaseProperty baseProperty, Property parameterGroup)
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index 783513727fa..90cc37b5e18 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -31,7 +31,7 @@ public abstract class XamlDataDrivenToolTask : ToolTask
         private TaskLoggingHelper _logPrivate;
 
         /// <summary>
-        /// The command line for this task. 
+        /// The command line for this task.
         /// </summary>
         private string _commandLine;
 
@@ -85,12 +85,12 @@ protected XamlDataDrivenToolTask(string[] switchOrderList, ResourceManager taskR
         protected internal Dictionary<string, CommandLineToolSwitch> ActiveToolSwitches { get; } = new Dictionary<string, CommandLineToolSwitch>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
-        /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc. 
+        /// Overridden to use UTF16, which works better than UTF8 for older versions of CL, LIB, etc.
         /// </summary>
         protected override Encoding ResponseFileEncoding { get; } = Encoding.Unicode;
 
         /// <summary>
-        /// Made a property to abstract out the "if null, call GenerateCommands()" logic. 
+        /// Made a property to abstract out the "if null, call GenerateCommands()" logic.
         /// </summary>
         private string CommandLine
         {
@@ -107,7 +107,7 @@ public bool IsPropertySet(string propertyName)
         }
 
         /// <summary>
-        /// Replace an existing switch with the specifed one of the same name. 
+        /// Replace an existing switch with the specifed one of the same name.
         /// </summary>
         public void ReplaceToolSwitch(CommandLineToolSwitch switchToAdd)
         {
@@ -263,7 +263,7 @@ internal void ValidateOverrides()
         /// Creates the command line and returns it as a string by:
         /// 1. Adding all switches with the default set to the active switch list
         /// 2. Customizing the active switch list (overridden in derived classes)
-        /// 3. Iterating through the list and appending switches 
+        /// 3. Iterating through the list and appending switches
         /// </summary>
         protected override string GenerateResponseFileCommands()
         {
@@ -290,7 +290,7 @@ protected override bool HandleTaskExecutionErrors()
                 return true;
             }
 
-            // We don't want to use ToolTask's implementation because it doesn't report the command line that failed. 
+            // We don't want to use ToolTask's implementation because it doesn't report the command line that failed.
             if (ExitCode == NativeMethods.SE_ERR_ACCESSDENIED)
             {
                 _logPrivate.LogErrorWithCodeFromResources("Xaml.CommandFailedAccessDenied", CommandLine, ExitCode);
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 66e6834174c..4094d25b62e 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -115,7 +115,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             // MSBuildToolsDirectoryRoot is the canonical location for MSBuild dll's.
             string pathToMSBuildBinaries = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
 
-            // create the code generator options    
+            // create the code generator options
             // Since we are running msbuild 12.0 these had better load.
             var compilerParameters = new CompilerParameters(
                 new[]
diff --git a/src/Tasks/XmlPeek.cs b/src/Tasks/XmlPeek.cs
index 9d8c7326a4f..5f9513f5c0c 100644
--- a/src/Tasks/XmlPeek.cs
+++ b/src/Tasks/XmlPeek.cs
@@ -21,19 +21,11 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class XmlPeek : TaskExtension
     {
-        #region Members
+        #region Properties
 
         /// <summary>
         /// The XPath Query.
         /// </summary>
-        private string _query;
-
-        #endregion
-
-        #region Properties
-        /// <summary>
-        /// The XML input as a file path.
-        /// </summary>
         public ITaskItem XmlInputPath { get; set; }
 
         /// <summary>
@@ -44,16 +36,8 @@ public class XmlPeek : TaskExtension
         /// <summary>
         /// The XPath Query.
         /// </summary>
-        public string Query
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(_query, "Query");
-                return _query;
-            }
-
-            set => _query = value;
-        }
+        [Required]
+        public string Query { get; set; }
 
         /// <summary>
         /// The results returned by this task.
@@ -71,6 +55,7 @@ public string Query
         /// if DTD is present. This was a pre-v15 behavior. By default, a DTD clause if any is ignored.
         /// </summary>
         public bool ProhibitDtd { get; set; }
+
         #endregion
 
         /// <summary>
@@ -80,8 +65,6 @@ public string Query
         public override bool Execute()
         {
             XmlInput xmlinput;
-            ErrorUtilities.VerifyThrowArgumentNull(_query, nameof(Query));
-
             try
             {
                 xmlinput = new XmlInput(XmlInputPath, XmlContent);
@@ -99,7 +82,6 @@ public override bool Execute()
                 using (XmlReader xr = xmlinput.CreateReader(ProhibitDtd))
                 {
                     xpathdoc = new XPathDocument(xr);
-                    xr.Dispose();
                 }
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
@@ -117,11 +99,11 @@ public override bool Execute()
             try
             {
                 // Create the expression from query
-                expr = nav.Compile(_query);
+                expr = nav.Compile(Query);
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                Log.LogErrorWithCodeFromResources("XmlPeekPoke.XPathError", _query, e.Message);
+                Log.LogErrorWithCodeFromResources("XmlPeekPoke.XPathError", Query, e.Message);
                 return false;
             }
 
@@ -230,7 +212,7 @@ private static void LoadNamespaces(ref XmlNamespaceManager namespaceManager, str
         /// <summary>
         /// This class prepares XML input from XMLInputPath and XMLContent parameters
         /// </summary>
-        internal class XmlInput
+        private sealed class XmlInput
         {
             /// <summary>
             /// This either contains the raw Xml or the path to Xml file.
@@ -238,7 +220,7 @@ internal class XmlInput
             private readonly string _data;
 
             /// <summary>
-            /// Filestream used to read XML.
+            /// FileStream used to read XML.
             /// </summary>
             private FileStream _fs;
 
@@ -254,7 +236,8 @@ public XmlInput(ITaskItem xmlInputPath, string xmlContent)
                 {
                     throw new ArgumentException(ResourceUtilities.GetResourceString("XmlPeek.XmlInput.TooMany"));
                 }
-                else if (xmlInputPath == null && xmlContent == null)
+
+                if (xmlInputPath == null && xmlContent == null)
                 {
                     throw new ArgumentException(ResourceUtilities.GetResourceString("XmlPeek.XmlInput.TooFew"));
                 }
@@ -274,7 +257,7 @@ public XmlInput(ITaskItem xmlInputPath, string xmlContent)
             /// <summary>
             /// Possible accepted types of XML input.
             /// </summary>
-            public enum XmlModes
+            private enum XmlModes
             {
                 /// <summary>
                 /// If the mode is a XML file.
@@ -290,7 +273,7 @@ public enum XmlModes
             /// <summary>
             /// Returns the current mode of the XmlInput
             /// </summary>
-            public XmlModes XmlMode { get; }
+            private XmlModes XmlMode { get; }
 
             /// <summary>
             /// Creates correct reader based on the input type.
diff --git a/src/Tasks/XmlPoke.cs b/src/Tasks/XmlPoke.cs
index a60147e0cc8..501d0bc9428 100644
--- a/src/Tasks/XmlPoke.cs
+++ b/src/Tasks/XmlPoke.cs
@@ -20,51 +20,23 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class XmlPoke : TaskExtension
     {
-        #region Members
-        /// <summary>
-        /// The XML input as file paths.
-        /// </summary>
-        private ITaskItem _xmlInputPath;
-
-        /// <summary>
-        /// The XPath Query.
-        /// </summary>
-        private string _query;
-
-        #endregion
-
         #region Properties
+
         /// <summary>
         /// The XML input as file path.
         /// </summary>
-        public ITaskItem XmlInputPath
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(_xmlInputPath, nameof(XmlInputPath));
-                return _xmlInputPath;
-            }
-
-            set => _xmlInputPath = value;
-        }
+        [Required]
+        public ITaskItem XmlInputPath { get; set; }
 
         /// <summary>
         /// The XPath Query.
         /// </summary>
-        public string Query
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(_query, nameof(Query));
-                return _query;
-            }
-
-            set => _query = value;
-        }
+        [Required]
+        public string Query { get; set; }
 
         /// <summary>
         /// The value to be inserted into the specified location.
-        /// </summary>        
+        /// </summary>
         public ITaskItem Value { get; set; }
 
         /// <summary>
@@ -77,15 +49,13 @@ public string Query
         /// <summary>
         /// Executes the XMLPoke task.
         /// </summary>
-        /// <returns>true if transformation succeeds.</returns>
+        /// <returns>true if task execution succeeds.</returns>
         public override bool Execute()
         {
-            ErrorUtilities.VerifyThrowArgumentNull(_query, "Query");
-            ErrorUtilities.VerifyThrowArgumentNull(_xmlInputPath, "XmlInputPath");
             if (Value == null)
             {
                 // When Value is null, it means Value is not set or empty. Here we treat them all as empty.
-                Value = new TaskItem(String.Empty);
+                Value = new TaskItem(string.Empty);
             }
 
             // Load the XPath Document
@@ -93,7 +63,7 @@ public override bool Execute()
 
             try
             {
-                using (FileStream fs = new FileStream(_xmlInputPath.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
+                using (FileStream fs = new FileStream(XmlInputPath.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                 {
                     XmlReaderSettings xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                     using (XmlReader sr = XmlReader.Create(fs, xrs))
@@ -104,7 +74,7 @@ public override bool Execute()
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                Log.LogErrorWithCodeFromResources("XmlPeekPoke.InputFileError", _xmlInputPath.ItemSpec, e.Message);
+                Log.LogErrorWithCodeFromResources("XmlPeekPoke.InputFileError", XmlInputPath.ItemSpec, e.Message);
                 return false;
             }
 
@@ -114,11 +84,11 @@ public override bool Execute()
             try
             {
                 // Create the expression from query
-                expr = nav.Compile(_query);
+                expr = nav.Compile(Query);
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                Log.LogErrorWithCodeFromResources("XmlPeekPoke.XPathError", _query, e.Message);
+                Log.LogErrorWithCodeFromResources("XmlPeekPoke.XPathError", Query, e.Message);
                 return false;
             }
 
@@ -169,12 +139,12 @@ public override bool Execute()
             if (count > 0)
             {
 #if RUNTIME_TYPE_NETCORE
-                using (Stream stream = File.Create(_xmlInputPath.ItemSpec))
+                using (Stream stream = File.Create(XmlInputPath.ItemSpec))
                 {
                     xmlDoc.Save(stream);
                 }
 #else
-                xmlDoc.Save(_xmlInputPath.ItemSpec);
+                xmlDoc.Save(XmlInputPath.ItemSpec);
 #endif
             }
 
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index f5e09078922..2f255f143cc 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -350,7 +350,7 @@ internal class XsltInput
             private readonly XslModes _xslMode;
 
             /// <summary>
-            /// Contains the raw XSLT 
+            /// Contains the raw XSLT
             /// or the path to XSLT file
             /// or the path to compiled XSLT dll.
             /// </summary>
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 7b9fbd54b77..6f6bf7f491e 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -40,11 +40,11 @@
   Plan for the future:
   Ideally we will be able to change the property getters here to use a
   resource index calculated at build time, being the x'th resource in the
-  .resources file.  We would then call something like 
+  .resources file.  We would then call something like
   ResourceManager.LookupResourceByIndex().  This would avoid some string
   comparisons during resource lookup.
 
-  This would require work from ResourceReader and/or ResourceWriter (or 
+  This would require work from ResourceReader and/or ResourceWriter (or
   a standalone, separate utility with duplicated code) to calculate the
   id's.  It would also require that all satellite assemblies use the same
   resource ID's as the main assembly.  This would require dummy entries
@@ -172,7 +172,7 @@ private static CodeCompileUnit InternalCreate(Dictionary<String, ResourceData> r
                 throw new ArgumentException(SR.GetString(SR.InvalidIdentifier, className));
             }
 
-            // If we have a namespace, verify the namespace is legal, 
+            // If we have a namespace, verify the namespace is legal,
             // attempting to fix it up if needed.
             if (!String.IsNullOrEmpty(generatedCodeNamespace))
             {
@@ -441,8 +441,8 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
               // try/finally, we'll avoid our double lock pattern here.
               // This will only hurt perf when we get two threads racing through
               // this method the first time.  Unfortunate, but not a big deal.
-              // Also, the .NET Compact Framework doesn't support 
-              // Thread.MemoryBarrier (they only run on processors w/ a strong 
+              // Also, the .NET Compact Framework doesn't support
+              // Thread.MemoryBarrier (they only run on processors w/ a strong
               // memory model, and who knows about IA64...)
               // Once we have Interlocked.CompareExchange<T>, we should use it here.
               if (_resMgr == null) {
@@ -500,7 +500,7 @@ private static string TruncateAndFormatCommentStringForOutput(string commentStri
                     commentString = SR.GetString(SR.StringPropertyTruncatedComment, commentString.Substring(0, DocCommentLengthThreshold));
                 }
 
-                // Encode the comment so it is safe for xml.  SecurityElement.Escape is the only method I've found to do this. 
+                // Encode the comment so it is safe for xml.  SecurityElement.Escape is the only method I've found to do this.
                 commentString = System.Security.SecurityElement.Escape(commentString);
             }
 
@@ -514,7 +514,7 @@ private static string TruncateAndFormatCommentStringForOutput(string commentStri
         //          return (Point) obj; }
         // }
         // Special cases static vs. non-static, as well as internal vs. internal.
-        // Also note the resource name could contain spaces, etc, while the 
+        // Also note the resource name could contain spaces, etc, while the
         // property name has to be a valid language identifier.
         [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
         private static bool DefineResourceFetchingProperty(String propertyName, String resourceName, ResourceData data, CodeTypeDeclaration srClass, bool internalClass, bool useStatic)
@@ -534,14 +534,14 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
 
                 // Ensure type is internalally visible.  This is necessary to ensure
                 // users can access classes via a base type.  Imagine a class like
-                // Image or Stream as a internalally available base class, then an 
-                // internal type like MyBitmap or __UnmanagedMemoryStream as an 
-                // internal implementation for that base class.  For internalally 
-                // available strongly typed resource classes, we must return the 
-                // internal type.  For simplicity, we'll do that for internal strongly 
+                // Image or Stream as a internalally available base class, then an
+                // internal type like MyBitmap or __UnmanagedMemoryStream as an
+                // internal implementation for that base class.  For internalally
+                // available strongly typed resource classes, we must return the
+                // internal type.  For simplicity, we'll do that for internal strongly
                 // typed resource classes as well.  Ideally we'd also like to check
                 // for interfaces like IList, but I don't know how to do that without
-                // special casing collection interfaces & ignoring serialization 
+                // special casing collection interfaces & ignoring serialization
                 // interfaces or IDisposable.
                 while (!type.IsPublic)
                 {
@@ -694,7 +694,7 @@ private static String VerifyResourceName(String key, CodeDomProvider provider, b
                 return key;
             }
 
-            // Now try fixing up keywords like "for".  
+            // Now try fixing up keywords like "for".
             key = provider.CreateValidIdentifier(key);
             if (provider.IsValidIdentifier(key))
             {
@@ -728,7 +728,7 @@ private static SortedList<string, ResourceData> VerifyResourceNames(
             {
                 String key = entry.Key;
 
-                // Disallow a property named ResourceManager or Culture - we add 
+                // Disallow a property named ResourceManager or Culture - we add
                 // those.  (Any other properties we add also must be listed here)
                 // Also disallow resource values of type Void.
                 if (String.Equals(key, ResMgrPropertyName) ||
@@ -758,7 +758,7 @@ private static SortedList<string, ResourceData> VerifyResourceNames(
                         continue;
                     }
 
-                    // Now see if we've already mapped another key to the 
+                    // Now see if we've already mapped another key to the
                     // same name.
                     if (reverseFixupTable.TryGetValue(newKey, out string oldDuplicateKey))
                     {
@@ -783,7 +783,7 @@ private static SortedList<string, ResourceData> VerifyResourceNames(
                 else
                 {
                     // There was a case-insensitive conflict between two keys.
-                    // Or possibly one key was fixed up in a way that conflicts 
+                    // Or possibly one key was fixed up in a way that conflicts
                     // with another key (ie, "A B" and "A_B").
                     if (reverseFixupTable.TryGetValue(key, out string fixedUp))
                     {
diff --git a/src/UnitTests.Shared/DummyMappedDriveUtils.cs b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
new file mode 100644
index 00000000000..c2c28c8f0e5
--- /dev/null
+++ b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
@@ -0,0 +1,28 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable enable
+using System;
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests.Shared;
+
+namespace Microsoft.Build.UnitTests.Shared;
+
+internal static class DummyMappedDriveUtils
+{
+    public static string UpdatePathToMappedDrive(string path, char driveLetter)
+    {
+        const string drivePlaceholder = "%DRIVE%";
+        // if this seems to be rooted path - replace with the dummy mount
+        if (!string.IsNullOrEmpty(path) && path.StartsWith(drivePlaceholder))
+        {
+            path = driveLetter + path.Substring(drivePlaceholder.Length);
+        }
+        return path;
+    }
+
+    public static Lazy<DummyMappedDrive?> GetLazyDummyMappedDrive() => new Lazy<DummyMappedDrive?>(() =>
+        {
+            return NativeMethods.IsWindows ? new DummyMappedDrive() : default;
+        });
+}
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 48dfd777c71..c1e96f7a6cb 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -15,6 +15,12 @@ public static class RunnerUtilities
         public static string PathToCurrentlyRunningMsBuildExe => BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
 #if !FEATURE_RUN_EXE_IN_TESTS
         private static readonly string s_dotnetExePath = EnvironmentProvider.GetDotnetExePath();
+
+        public static void ApplyDotnetHostPathEnvironmentVariable(TestEnvironment testEnvironment)
+        {
+            // Built msbuild.dll executed by dotnet.exe needs this environment variable for msbuild tasks such as RoslynCodeTaskFactory.
+            testEnvironment.SetEnvironmentVariable("DOTNET_HOST_PATH", s_dotnetExePath);
+        }
 #endif
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/EncodingUtilities_Tests.cs b/src/Utilities.UnitTests/EncodingUtilities_Tests.cs
new file mode 100644
index 00000000000..c26000fb4ec
--- /dev/null
+++ b/src/Utilities.UnitTests/EncodingUtilities_Tests.cs
@@ -0,0 +1,57 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Globalization;
+using System.Runtime.InteropServices;
+using System.Threading;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Shouldly;
+using Xunit;
+
+#nullable disable
+
+namespace Microsoft.Build.UnitTests
+{
+    public sealed class EncodingUtilities_Tests
+    {
+        /// <summary>
+        /// Test the CanEncode method with and without ANSI characters to determine if they can be encoded 
+        /// in the current system encoding.
+        /// </summary>
+        [WindowsOnlyFact]
+        public void CanEncodeTest()
+        {
+            var defaultEncoding = EncodingUtilities.CurrentSystemOemEncoding;
+
+            string nonAnsiCharacters = "\u521B\u5EFA";
+            string pathWithAnsiCharacters = @"c:\windows\system32\cmd.exe";
+
+            EncodingUtilities.CanEncodeString(defaultEncoding.CodePage, nonAnsiCharacters).ShouldBeFalse();
+            EncodingUtilities.CanEncodeString(defaultEncoding.CodePage, pathWithAnsiCharacters).ShouldBeTrue();
+        }
+
+        /// <summary>
+        /// Test for bug where the MSBuild does not respect "en" CultureInfo
+        /// </summary>
+        [Theory]
+        [InlineData("en", "en")]
+        [InlineData("jp", "jp")]
+        [InlineData("fr", "fr")]
+        public void GetExternalOverriddenUILanguageIfSupportableWithEncoding_RespectsOverriddenLanguage(string inputLanguage, string expectedLanguage)
+        {
+            if (!EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
+            {
+                return; // Do not run test to replicate the behaviour of the invoking method
+            }
+            const string DOTNET_CLI_UI_LANGUAGE = nameof(DOTNET_CLI_UI_LANGUAGE);
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            
+            // Override the ui language by setting environment variable
+            testEnvironment.SetEnvironmentVariable(DOTNET_CLI_UI_LANGUAGE, inputLanguage);
+
+            EncodingUtilities.GetExternalOverriddenUILanguageIfSupportableWithEncoding().ShouldBeEquivalentTo(new CultureInfo(expectedLanguage));
+        }
+    }
+}
diff --git a/src/Utilities.UnitTests/MockEngine.cs b/src/Utilities.UnitTests/MockEngine.cs
index e5b5986bee8..8b6c48c541e 100644
--- a/src/Utilities.UnitTests/MockEngine.cs
+++ b/src/Utilities.UnitTests/MockEngine.cs
@@ -14,18 +14,18 @@
 namespace Microsoft.Build.UnitTests
 {
     /***************************************************************************
-     * 
+     *
      * Class:       MockEngine
-     * 
+     *
      * In order to execute tasks, we have to pass in an Engine object, so the
      * task can log events.  It doesn't have to be the real Engine object, just
      * something that implements the IBuildEngine2 interface.  So, we mock up
      * a fake engine object here, so we're able to execute tasks from the unit tests.
-     * 
+     *
      * The unit tests could have instantiated the real Engine object, but then
      * we would have had to take a reference onto the Microsoft.Build.Engine assembly, which
      * is somewhat of a no-no for task assemblies.
-     * 
+     *
      **************************************************************************/
     internal sealed class MockEngine : IBuildEngine3
     {
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index ffd146c0d17..c8ed9e9832c 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -299,8 +299,8 @@ public void CreateEmptyNamedMetadata()
             });
         }
         /// <summary>
-        /// Create a TaskItem with a null metadata value -- this is allowed, but 
-        /// internally converted to the empty string. 
+        /// Create a TaskItem with a null metadata value -- this is allowed, but
+        /// internally converted to the empty string.
         /// </summary>
         [Fact]
         public void CreateTaskItemWithNullMetadata()
@@ -313,8 +313,8 @@ public void CreateTaskItemWithNullMetadata()
         }
 
         /// <summary>
-        /// Set metadata value to null value -- this is allowed, but 
-        /// internally converted to the empty string. 
+        /// Set metadata value to null value -- this is allowed, but
+        /// internally converted to the empty string.
         /// </summary>
         [Fact]
         public void SetNullMetadataValue()
@@ -345,7 +345,7 @@ public void ImplementsIMetadataContainer()
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// Test that task items can be successfully constructed based on a task item from another appdomain.  
+        /// Test that task items can be successfully constructed based on a task item from another appdomain.
         /// </summary>
         [Fact]
         public void RemoteTaskItem()
@@ -407,7 +407,7 @@ public void RemoteTaskItem()
         }
 
         /// <summary>
-        /// Miniature class to be remoted to another appdomain that just creates some TaskItems and makes them available for returning. 
+        /// Miniature class to be remoted to another appdomain that just creates some TaskItems and makes them available for returning.
         /// </summary>
         private sealed class TaskItemCreator
 #if FEATURE_APPDOMAIN
@@ -424,7 +424,7 @@ public ITaskItem[] CreatedTaskItems
             }
 
             /// <summary>
-            /// Creates task items 
+            /// Creates task items
             /// </summary>
             public void Run(string[] includes, IDictionary<string, string> metadataToAdd)
             {
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 308a4915321..1c359273b56 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -853,7 +853,7 @@ public void SetsTerminationTimeoutCorrectly(int timeout, bool isInvalidValid)
             task.ValidateParameters().ShouldBe(!isInvalidValid);
             task.TerminationTimeout.ShouldBe(timeout);
         }
-		
+
 		/// <summary>
         /// Verifies that a ToolTask instance can return correct results when executed multiple times with timeout.
         /// </summary>
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index 22a0dae0bf4..d9db9e78b7b 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -79,7 +79,7 @@ public FileTrackerTests()
 
         public void Dispose()
         {
-            // Reset PATH to its original value. 
+            // Reset PATH to its original value.
             if (s_oldPath != null)
             {
                 Environment.SetEnvironmentVariable("PATH", s_oldPath);
@@ -123,8 +123,8 @@ public void FileTrackerNoUIDll()
                     Directory.Delete(testDirectory, true);
                 }
 
-                // create an empty directory and copy Tracker.exe -- BUT NOT TrackerUI.dll -- to 
-                // that directory. 
+                // create an empty directory and copy Tracker.exe -- BUT NOT TrackerUI.dll -- to
+                // that directory.
                 Directory.CreateDirectory(testDirectory);
                 File.Copy(s_defaultTrackerPath, testTrackerPath);
 
@@ -132,14 +132,14 @@ public void FileTrackerNoUIDll()
 
                 Assert.Equal(9, exit);
                 // It's OK to look for the English message since that's all we're capable of printing when we can't find
-                // our resource dll. 
+                // our resource dll.
                 Assert.Contains("FileTracker : ERROR : Could not load UI satellite dll 'TrackerUI.dll'", log);
             }
             finally
             {
-                // Doesn't delete the directory itself, but deletes its contents.  If you try to delete the directory, 
-                // even after calling this method, it sometimes throws IO exceptions due to not recognizing that the 
-                // contents have been deleted yet. 
+                // Doesn't delete the directory itself, but deletes its contents.  If you try to delete the directory,
+                // even after calling this method, it sometimes throws IO exceptions due to not recognizing that the
+                // contents have been deleted yet.
                 ObjectModelHelpers.DeleteDirectory(testDirectory);
             }
         }
@@ -303,11 +303,11 @@ class Program
         static void Main(string[] args)
         {
             File.GetAttributes(Directory.GetCurrentDirectory());
-            GetFileAttributes(Directory.GetCurrentDirectory()); 
+            GetFileAttributes(Directory.GetCurrentDirectory());
         }
 
         [DllImport(""Kernel32.dll"", SetLastError = true, CharSet = CharSet.Unicode)]
-        private extern static uint GetFileAttributes(string FileName); 
+        private extern static uint GetFileAttributes(string FileName);
     }
 }";
 
@@ -344,7 +344,7 @@ static void Main(string[] args)
                 Console.WriteLine("");
                 Assert.Equal(0, exit);
 
-                // With '/a', should *not* track GetFileAttributes on directories, even though we do so on files. 
+                // With '/a', should *not* track GetFileAttributes on directories, even though we do so on files.
                 FileTrackerTestHelper.AssertDidntFindStringInTLog("GetFileAttributesExW:" + FileUtilities.EnsureTrailingSlash(Directory.GetCurrentDirectory()).ToUpperInvariant(), "directoryattributes.read.1.tlog");
                 FileTrackerTestHelper.AssertDidntFindStringInTLog("GetFileAttributesW:" + FileUtilities.EnsureTrailingSlash(Directory.GetCurrentDirectory()).ToUpperInvariant(), "directoryattributes.read.1.tlog");
 
@@ -382,7 +382,7 @@ static void Main(string[] args)
                 Console.WriteLine("");
                 Assert.Equal(0, exit);
 
-                // With '/a', should *not* track GetFileAttributes on directories, even though we do so on files. 
+                // With '/a', should *not* track GetFileAttributes on directories, even though we do so on files.
                 FileTrackerTestHelper.AssertDidntFindStringInTLog(FileUtilities.EnsureTrailingSlash(Directory.GetCurrentDirectory()).ToUpperInvariant(), "directoryattributes.read.1.tlog");
 
                 File.Delete("directoryattributes.read.1.tlog");
@@ -470,12 +470,12 @@ public void FileTrackerDoNotRecordWriteAsRead()
                 writeFile = Path.Combine(testDirectory, "test.out");
                 string codeFile = Path.Combine(testDirectory, "code.cs");
                 string codeContent = @"
-using System.IO; 
+using System.IO;
 using System.Runtime.InteropServices;
-class X 
-{ 
-    static void Main() 
-    { 
+class X
+{
+    static void Main()
+    {
         FileStream f = File.Open(@""" + writeFile + @""", FileMode.CreateNew, FileAccess.ReadWrite, FileShare.ReadWrite);
         f.WriteByte(8);
         f.Close();
@@ -501,9 +501,9 @@ static void Main()
             }
             finally
             {
-                // Doesn't delete the directory itself, but deletes its contents.  If you try to delete the directory, 
-                // even after calling this method, it sometimes throws IO exceptions due to not recognizing that the 
-                // contents have been deleted yet. 
+                // Doesn't delete the directory itself, but deletes its contents.  If you try to delete the directory,
+                // even after calling this method, it sometimes throws IO exceptions due to not recognizing that the
+                // contents have been deleted yet.
                 ObjectModelHelpers.DeleteDirectory(testDirectory);
             }
 
@@ -1381,7 +1381,7 @@ public void InProcTrackingStartProcessFindStrIn()
             }
             Console.WriteLine("");
             Assert.Equal(0, exit);
-            // This line is the problem.  It seems to have been reliable in MSTest 
+            // This line is the problem.  It seems to have been reliable in MSTest
             // but in xunit when run with other tests (NOT by itself), filetracker
             // puts a PID in the path, so this tries to open the wrong file and throws.
             FileTrackerTestHelper.AssertFoundStringInTLog(Path.GetFullPath("test.in").ToUpperInvariant(), "InProcTrackingStartProcessFindStrIn-findstr.read.1.tlog");
@@ -2239,7 +2239,7 @@ public void LaunchMultipleOfSameTool_ToolLaunchesOthers()
 
                 Directory.CreateDirectory(testDir);
 
-                // File to run findstr against. 
+                // File to run findstr against.
                 string tempFilePath = Path.Combine(testDir, "bar.txt");
                 File.WriteAllText(tempFilePath, "");
 
@@ -2430,7 +2430,7 @@ private static void LaunchDuplicateToolsAndVerifyTlogExistsForEach(string tlogPa
 
                 // make sure the disk write gets time for NTFS to recognize its existence.  Estimate time needed to sleep based
                 // roughly on the number of tlogs that we're looking for (presumably roughly proportional to the number of tlogs
-                // being written. 
+                // being written.
                 Thread.Sleep(Math.Max(200, 250 * tlogCount));
 
                 // Item1: The pattern the tlog name should follow
diff --git a/src/Utilities.UnitTests/TrackedDependencies/MockEngine.cs b/src/Utilities.UnitTests/TrackedDependencies/MockEngine.cs
index ffc7f3d824a..43618e32960 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/MockEngine.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/MockEngine.cs
@@ -11,18 +11,18 @@
 namespace Microsoft.Build.UnitTests.TrackedDependencies
 {
     /***************************************************************************
-     * 
+     *
      * Class:       MockEngine
-     * 
+     *
      * In order to execute tasks, we have to pass in an Engine object, so the
      * task can log events.  It doesn't have to be the real Engine object, just
      * something that implements the IBuildEngine2 interface.  So, we mock up
      * a fake engine object here, so we're able to execute tasks from the unit tests.
-     * 
+     *
      * The unit tests could have instantiated the real Engine object, but then
      * we would have had to take a reference onto the Microsoft.Build.Engine assembly, which
      * is somewhat of a no-no for task assemblies.
-     * 
+     *
      **************************************************************************/
     internal sealed class MockEngine : IBuildEngine2
     {
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 913ccfc7098..0ba128f9f33 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -75,9 +75,9 @@ public TrackedDependenciesTests()
         }
 
         /// <summary>
-        /// Tests DependencyTableCache.FormatNormalizedTlogRootingMarker, which should do effectively the same 
+        /// Tests DependencyTableCache.FormatNormalizedTlogRootingMarker, which should do effectively the same
         /// thing as FileTracker.FormatRootingMarker, except with some extra initial normalization to get rid of
-        /// pesky PIDs and TIDs in the tlog names. 
+        /// pesky PIDs and TIDs in the tlog names.
         /// </summary>
         [Fact]
         public void FormatNormalizedRootingMarkerTests()
@@ -2076,7 +2076,7 @@ public void OutputMultipleCanonicalCLSubrootMisMatch()
                                     new TaskItem(Path.GetFullPath(Path.Combine("TestFiles", "eight.cpp"))),
                                     new TaskItem(Path.GetFullPath(Path.Combine("TestFiles", "three.cpp"))) };
 
-            // Do note sources2Match and source2 is missing three.cpp.  It is to test if the RootContainsAllSubRootComponents can handle the case. 
+            // Do note sources2Match and source2 is missing three.cpp.  It is to test if the RootContainsAllSubRootComponents can handle the case.
 
             // Prepare files
             Thread.Sleep(_sleepTimeMilliseconds); // need to wait since the timestamp check needs some time to register
@@ -3431,7 +3431,7 @@ public void FlatTrackingExcludeDirectories()
         {
             Console.WriteLine("Test: FlatTrackingExcludeDirectories");
 
-            // Prepare files 
+            // Prepare files
             if (!Directory.Exists(Path.Combine("TestFiles", "ToBeExcluded")))
             {
                 Directory.CreateDirectory(Path.Combine("TestFiles", "ToBeExcluded"));
diff --git a/src/Utilities/ApiContract.cs b/src/Utilities/ApiContract.cs
index 15213d41e2f..f107dfe5d6a 100644
--- a/src/Utilities/ApiContract.cs
+++ b/src/Utilities/ApiContract.cs
@@ -34,14 +34,14 @@ private ApiContract(string name, string version)
         }
 
         /// <summary>
-        /// Returns true if this element is a "ContainedApiContracts" element. 
+        /// Returns true if this element is a "ContainedApiContracts" element.
         /// </summary>
         internal static bool IsContainedApiContractsElement(string elementName) => string.Equals(elementName, Elements.ContainedApiContracts, StringComparison.Ordinal);
 
         internal static bool IsVersionedContentElement(string elementName) => string.Equals(elementName, Elements.VersionedContent, StringComparison.Ordinal);
 
         /// <summary>
-        /// Given an XML element containing API contracts, read out all contracts within that element. 
+        /// Given an XML element containing API contracts, read out all contracts within that element.
         /// </summary>
         internal static void ReadContractsElement(XmlElement element, ICollection<ApiContract> apiContracts)
         {
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index 7db0be0b667..b777f8b7022 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Utilities
 {
     /// <summary>
     /// (1) Make sure values containing hyphens are quoted (RC at least requires this)
-    /// (2) Escape any embedded quotes. 
+    /// (2) Escape any embedded quotes.
     ///     -- Literal double quotes should be written in the form \" not ""
     ///     -- Backslashes falling just before doublequotes must be doubled.
     ///     -- Literal double quotes can only occur in pairs (you cannot pass a single literal double quote)
@@ -23,38 +23,38 @@ namespace Microsoft.Build.Utilities
     /// 	    in switches like /Dname=value.
     /// </summary>
     /// <remarks>
-    /// 
+    ///
     /// Below are some quoting experiments, using the /D switch with the CL and RC preprocessor.
     /// The /D switch is a little more tricky than most switches, because it has a name=value pair.
     /// The table below contains what the preprocessor actually embeds when passed the switch in the
     /// first column:
-    /// 
+    ///
     ///                      CL via cmd line         CL via response file       RC
-    ///     /DFOO="A"                A                   A   
+    ///     /DFOO="A"                A                   A
     ///     /D"FOO="A""              A                   A                       A
-    ///     /DFOO=A                  A                   A   
-    ///     /D"FOO=A"                A                   A   
+    ///     /DFOO=A                  A                   A
+    ///     /D"FOO=A"                A                   A
     ///     /DFOO=""A""              A                   A                       A
-    ///         
+    ///
     ///     /DFOO=\"A\"             "A"                                         "A"
     ///     /DFOO="""A"""           "A"                broken                   "A"
     ///     /D"FOO=\"A\""           "A"                                         "A"
     ///     /D"FOO=""A"""           "A"                                         "A"
-    ///         
-    ///     /DFOO="A B"             A B                 A B 
-    ///     /D"FOO=A B"             A B                 A B 
-    ///         
-    ///     /D"FOO="A B""          broken      
-    ///     /DFOO=\"A B\"          broken      
+    ///
+    ///     /DFOO="A B"             A B                 A B
+    ///     /D"FOO=A B"             A B                 A B
+    ///
+    ///     /D"FOO="A B""          broken
+    ///     /DFOO=\"A B\"          broken
     ///     /D"FOO=\"A B\""        "A B"               "A B"                   "A B"
     ///     /D"FOO=""A B"""        "A B"               broken                  broken
     ///
-    /// From my experiments (with CL and RC only) it seems that 
+    /// From my experiments (with CL and RC only) it seems that
     ///    -- Literal double quotes are most reliably written in the form \" not ""
     ///    -- Backslashes falling just before doublequotes must be doubled.
     ///    -- Values containing literal double quotes must be quoted.
     ///    -- Literal double quotes can only occur in pairs (you cannot pass a single literal double quote)
-    ///    -- For /Dname=value style switches, functional double quotes (for example to handle spaces) are best put around both 
+    ///    -- For /Dname=value style switches, functional double quotes (for example to handle spaces) are best put around both
     ///           name and value (in other words, these kinds of switches don't need special treatment for their '=' signs).
     ///    -- Values containing hyphens should be quoted; RC requires this, and CL does not mind.
     /// </remarks>
@@ -136,10 +136,10 @@ public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparat
         private readonly bool _useNewLineSeparator;
 
         /// <summary>
-        /// Instead of defining which characters must be quoted, define 
+        /// Instead of defining which characters must be quoted, define
         /// which characters we know its safe to not quote. This way leads
-        /// to more false-positives (which still work, but don't look as 
-        /// nice coming out of the logger), but is less likely to leave a 
+        /// to more false-positives (which still work, but don't look as
+        /// nice coming out of the logger), but is less likely to leave a
         /// security hole.
         /// </summary>
         private Regex _allowedUnquoted;
@@ -311,7 +311,7 @@ public void AppendTextUnquoted(string textToAppend)
         }
 
         /// <summary>
-        /// Appends a file name. Quotes are added if they are needed. 
+        /// Appends a file name. Quotes are added if they are needed.
         /// If the first character of the file name is a dash, ".\" is prepended to avoid confusing the file name with a switch
         /// This method does not append a space to the command line before executing.
         /// </summary>
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
index bb15e1e6c3e..2545a39b99a 100644
--- a/src/Utilities/CompatibilitySuppressions.xml
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -1,14 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
-  <Suppression>
-    <DiagnosticId>CP1002</DiagnosticId>
-    <Target>System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
-    <Left>ref/net7.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
        (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
@@ -62,9 +54,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index b9296ffc4e4..aac2626cb09 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -28,11 +28,10 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETStandard' and '$(DotNetBuildFromSource)' != 'true'">
-    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
+    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
-    <PackageReference Include="System.Security.Permissions" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
   
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 715cbe2d753..2fcc5d9cf02 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -12,44 +12,44 @@
 namespace Microsoft.Build.Utilities
 {
     /// <summary>
-    /// This is a multiplexing logger. The purpose of this logger is to allow the registration and deregistration of 
+    /// This is a multiplexing logger. The purpose of this logger is to allow the registration and deregistration of
     /// multiple loggers during the build. This is to support the VS IDE scenario where loggers are registered and unregistered
     /// for each project system's build request. This means one physical build may have multiple logical builds
-    /// each with their own set of loggers. 
-    /// 
-    /// The Mux logger will register itself with the build manager as a regular central /l style logger. 
+    /// each with their own set of loggers.
+    ///
+    /// The Mux logger will register itself with the build manager as a regular central /l style logger.
     /// It will be responsible for receiving messages from the build manager and route them to the correct
     /// logger based on the logical build the message came from.
-    /// 
+    ///
     /// Requirements:
     ///     1) Multiplexing logger will be registered at the beginning of the build manager's Begin build
     ///         Any loggers registered before the build manager actually started building will get the build started event at the same time as the MUX logger
-    ///         Any loggers registered after the build manager starts the build will get a synthesised build started event. The event cannot be cached because the 
+    ///         Any loggers registered after the build manager starts the build will get a synthesised build started event. The event cannot be cached because the
     ///         timestamp of the build started event is determined when the event is created, caching the event would give incorrect build times in the loggers registered to the MUX.
-    ///         
+    ///
     ///     2) The MUX logger will be initialized by the build manager.
     ///         The mux will listen to all events on the event source from the build manager and will route events correctly to the registered loggers.
-    ///     
+    ///
     ///     3) The MUX logger will be shutdown when the build is finished in end build . At this time it will un-register any loggers attached to it.
-    ///     
+    ///
     ///     4) The MUX logger will log the build finished event when the project finished event for the first project started event is seen for each logger.
-    ///    
+    ///
     /// Registering Loggers:
-    /// 
+    ///
     /// The multiplexing logger will function in the following way:
     ///     A logger will be passed to the MUX Register logger method with a submission ID which will be used to route a the message to the correct logger.
     ///     A new event source will be created so that the logger passed in can be registered to that event source
     ///     If the build started event has already been logged the MUX logger will create a new BuildStartedEvent and send that to the event source.
-    ///     
+    ///
     /// UnregisterLoggers:
     ///     When a build submission is completed the UnregisterLoggers method will be called with the submission ID.
     ///     At this point we will look up the success state of the project finished event for the submission ID and log a build finished event to the logger.
     ///     The event source will be cleaned up.  This may be interesting because the unregister will come from a thread other than what is doing the logging.
     ///     This may create a Synchronization issue, if unregister is called while events are being logged.
     /// </summary>
-    // 
+    //
     // UNDONE: If we can use ErrorUtilities, replace all InvalidOperation and Argument exceptions with the appropriate calls.
-    // 
+    //
     public class MuxLogger : INodeLogger
     {
         /// <summary>
@@ -380,8 +380,8 @@ private class SubmissionRecord :
             private bool _shutdown;
             #endregion
 
-            // Keep instance of event handlers so they can be unregistered at the end of the submissionID. 
-            // If we wait for the entire build to finish we will leak the handlers until we unregister ALL of the handlers from the 
+            // Keep instance of event handlers so they can be unregistered at the end of the submissionID.
+            // If we wait for the entire build to finish we will leak the handlers until we unregister ALL of the handlers from the
             // event source on the build manager.
             #region RegisteredHandlers
             /// <summary>
@@ -536,8 +536,8 @@ internal SubmissionRecord(int submissionId, IEventSource buildEventSource, Build
             public event CustomBuildEventHandler CustomEventRaised;
 
             /// <summary>
-            /// this event is raised to log build status events, such as 
-            /// build/project/target/task started/stopped 
+            /// this event is raised to log build status events, such as
+            /// build/project/target/task started/stopped
             /// </summary>
             public event BuildStatusEventHandler StatusEventRaised;
 
@@ -854,7 +854,7 @@ private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs bui
 
                     if (_firstProjectStartedEventContext == null)
                     {
-                        // Capture the build event context for the first project started event so we can make sure we know when to fire the 
+                        // Capture the build event context for the first project started event so we can make sure we know when to fire the
                         // build finished event (in the case of loggers on the mux logger this is on the last project finished event for the submission
                         _firstProjectStartedEventContext = buildEvent.BuildEventContext;
 
@@ -1250,7 +1250,7 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     }
 
                     // If this project finished event matches our first project started event, then send build finished.
-                    // Because of the way the event source works, we actually have to process this here rather than in project finished because if the 
+                    // Because of the way the event source works, we actually have to process this here rather than in project finished because if the
                     // logger is registered without a ProjectFinished handler, but does have an Any handler (as the mock logger does) then we would end up
                     // sending the BuildFinished event before the ProjectFinished event got processed in the Any handler.
                     ProjectFinishedEventArgs projectFinishedEvent = buildEvent as ProjectFinishedEventArgs;
diff --git a/src/Utilities/PlatformManifest.cs b/src/Utilities/PlatformManifest.cs
index fef6aa41a1b..653fc4c18d8 100644
--- a/src/Utilities/PlatformManifest.cs
+++ b/src/Utilities/PlatformManifest.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Utilities
     internal class PlatformManifest
     {
         /// <summary>
-        /// Location of Platform.xml 
+        /// Location of Platform.xml
         /// </summary>
         private readonly string _pathToManifest;
 
@@ -49,7 +49,7 @@ public PlatformManifest(string pathToManifest)
         public string PlatformVersion { get; private set; }
 
         /// <summary>
-        /// The platforms that this platform depends on.  
+        /// The platforms that this platform depends on.
         /// Item1: Platform name
         /// Item2: Platform version
         /// </summary>
@@ -80,7 +80,7 @@ public PlatformManifest(string pathToManifest)
         private void LoadManifestFile()
         {
             /*
-               Platform.xml format: 
+               Platform.xml format:
 
                <ApplicationPlatform name="UAP" friendlyName="Universal Application Platform" version="1.0.0.0">
                   <DependentPlatform name="UAP" version="1.0.0.0" />
@@ -170,7 +170,7 @@ internal struct DependentPlatform
             internal readonly string Name;
 
             /// <summary>
-            /// Version of the platform on which this platform depends 
+            /// Version of the platform on which this platform depends
             /// </summary>
             internal readonly string Version;
 
@@ -190,7 +190,7 @@ internal DependentPlatform(string name, string version)
         private static class Elements
         {
             /// <summary>
-            /// Root element 
+            /// Root element
             /// </summary>
             public const string ApplicationPlatform = "ApplicationPlatform";
 
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index 40ec557b1b3..472924ca574 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">Zadaný časový limit ukončení ({0}) je neplatný – očekává se hodnota větší nebo rovna -1.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index eda5b70eadc..b5081267c27 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">Le délai d’arrêt spécifié ({0}) n’est pas valide . La valeur attendue est supérieure ou égale à -1.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index cbdd70df0f9..82696e9d9f3 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">指定された終了タイムアウト ({0}) は無効です。-1 以上の値を指定してください。</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index dd22c108316..2de87f94e2b 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">지정한 종료 시간 제한({0})이 잘못되었습니다. -1보다 크거나 같은 값이 필요합니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 75c6c2b9bf9..0be09edd704 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">Określony limit czasu zakończenia ({0}) jest nieprawidłowy — oczekiwano wartości większej lub równej -1.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index 434da205f02..a2d9744fdbc 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">Belirtilen sonlandırma zaman aşımı ({0}) geçersiz; -1'den büyük veya buna eşit bir değer bekleniyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index d417911a7fa..347b5ed842b 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">指定的終止逾時 ({0}) 無效 - 必須是大於或等於 -1 的值。</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/SDKManifest.cs b/src/Utilities/SDKManifest.cs
index e4403e10a83..d5a4322a928 100644
--- a/src/Utilities/SDKManifest.cs
+++ b/src/Utilities/SDKManifest.cs
@@ -257,7 +257,7 @@ private void LoadManifestFile()
                     TargetPlatform="UAP"
                     TargetPlatformMinVersion="1.0.0.0"
                     TargetPlatformVersion="1.0.0.0"
-                    SDKType = "Platform" | "Framework" | "External" 
+                    SDKType = "Platform" | "Framework" | "External"
                     DisplayName = ""My SDK""
                     ProductFamilyName = ""UnitTest SDKs""
                     FrameworkIdentity-Debug = ""Name=MySDK.10.Debug, MinVersion=1.0.0.0""
@@ -273,7 +273,7 @@ private void LoadManifestFile()
                     AppX-Debug-ARM = "".\AppX\Debug\ARM\Microsoft.MySDK.ARM.Debug.1.0.appx""
                     AppX-Retail-x86 = "".\AppX\Retail\x86\Microsoft.MySDK.x86.1.0.appx""
                     AppX-Retail-x64 = "".\AppX\Retail\x64\Microsoft.MySDK.x64.1.0.appx""
-                    AppX-Retail-ARM = "".\AppX\Retail\ARM\Microsoft.MySDK.ARM.1.0.appx"" 
+                    AppX-Retail-ARM = "".\AppX\Retail\ARM\Microsoft.MySDK.ARM.1.0.appx""
                     CopyRedistToSubDirectory = "".""
                     DependsOn = ""SDKB, version=2.0""
                     MoreInfo = ""http://msdn.microsoft.com/MySDK""
@@ -292,7 +292,7 @@ private void LoadManifestFile()
                         <ToolboxItems VSCategory = ""Toolbox.Default"" />
                     </File>
                 </FileList>
-               
+
                Platform SDK Manifest:
                 <FileList
                     DisplayName = ""Windows""
@@ -606,7 +606,7 @@ public static class Attributes
         private static class Elements
         {
             /// <summary>
-            /// Root element 
+            /// Root element
             /// </summary>
             public const string FileList = "FileList";
         }
diff --git a/src/Utilities/TargetPlatformSDK.cs b/src/Utilities/TargetPlatformSDK.cs
index 9db364374cf..be16c5f63a4 100644
--- a/src/Utilities/TargetPlatformSDK.cs
+++ b/src/Utilities/TargetPlatformSDK.cs
@@ -109,23 +109,23 @@ public string Path
         }
 
         /// <summary>
-        /// The SDK's display name, or null if one is not defined. 
+        /// The SDK's display name, or null if one is not defined.
         /// </summary>
         public string DisplayName => Manifest?.DisplayName;
 
         /// <summary>
-        /// Extension sdks within this platform, 
+        /// Extension sdks within this platform,
         /// </summary>
         internal Dictionary<string, string> ExtensionSDKs { get; }
 
         /// <summary>
-        /// Set of platforms supported by this SDK. 
+        /// Set of platforms supported by this SDK.
         /// </summary>
         internal Dictionary<string, string> Platforms { get; }
 
         /// <summary>
         /// Reference to manifest object
-        /// Makes it is instantiated only once 
+        /// Makes it is instantiated only once
         /// </summary>
         private SDKManifest Manifest
         {
@@ -178,7 +178,7 @@ public bool Equals(TargetPlatformSDK other)
         }
 
         /// <summary>
-        /// Returns true if this SDK supports the given platform, or false otherwise. 
+        /// Returns true if this SDK supports the given platform, or false otherwise.
         /// </summary>
         public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion)
         {
@@ -187,7 +187,7 @@ public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatf
         }
 
         /// <summary>
-        /// Given an identifier and version, construct a string to use as a key for that combination. 
+        /// Given an identifier and version, construct a string to use as a key for that combination.
         /// </summary>
         internal static string GetSdkKey(string sdkIdentifier, string sdkVersion) => string.Format(CultureInfo.InvariantCulture, "{0}, Version={1}", sdkIdentifier, sdkVersion);
     }
diff --git a/src/Utilities/Task.cs b/src/Utilities/Task.cs
index 1793515ef44..2c16effe9f1 100644
--- a/src/Utilities/Task.cs
+++ b/src/Utilities/Task.cs
@@ -58,7 +58,7 @@ protected Task(ResourceManager taskResources, string helpKeywordPrefix)
         /// <value>The build engine interface available to tasks.</value>
         public IBuildEngine BuildEngine { get; set; }
 
-        // The casts below are always possible because this class is built against the 
+        // The casts below are always possible because this class is built against the
         // Orcas Framework assembly or later, so the version of MSBuild that does not
         // know about IBuildEngine2 will never load it.
         // No setters needed; the Engine always sets through the BuildEngine setter
@@ -115,7 +115,7 @@ protected Task(ResourceManager taskResources, string helpKeywordPrefix)
         /// <summary>
         /// Gets an instance of a TaskLoggingHelper class containing task logging methods.
         /// The taskLoggingHelper is a MarshallByRef object which needs to have MarkAsInactive called
-        /// if the parent task is making the appdomain and marshaling this object into it. If the appdomain is not unloaded at the end of 
+        /// if the parent task is making the appdomain and marshaling this object into it. If the appdomain is not unloaded at the end of
         /// the task execution and the MarkAsInactive method is not called this will result in a leak of the task instances in the appdomain the task was created within.
         /// </summary>
         /// <value>The logging helper object.</value>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 858b35eb892..f4e818e278e 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -21,9 +21,9 @@ namespace Microsoft.Build.Utilities
     /// This class represents a single item of the project, as it is passed into a task. TaskItems do not exactly correspond to
     /// item elements in project files, because then tasks would have access to data that wasn't explicitly passed into the task
     /// via the project file. It's not a security issue, but more just an issue with project file clarity and transparency.
-    /// 
+    ///
     /// Note: This class has to be sealed.  It has to be sealed because the engine instantiates it's own copy of this type and
-    /// thus if someone were to extend it, they would not get the desired behavior from the engine.  
+    /// thus if someone were to extend it, they would not get the desired behavior from the engine.
     /// </summary>
     /// <comment>
     /// Surprisingly few of these Utilities TaskItems are created: typically several orders of magnitude fewer than the number of engine TaskItems.
@@ -37,7 +37,7 @@ public sealed class TaskItem :
     {
         #region Member Data
 
-        // This is the final evaluated item specification.  Stored in escaped form. 
+        // This is the final evaluated item specification.  Stored in escaped form.
         private string _itemSpec;
 
         // These are the user-defined metadata on the item, specified in the
@@ -50,8 +50,8 @@ public sealed class TaskItem :
         private string _fullPath;
 
         /// <summary>
-        /// May be defined if we're copying this item from a pre-existing one.  Otherwise, 
-        /// we simply don't know enough to set it properly, so it will stay null. 
+        /// May be defined if we're copying this item from a pre-existing one.  Otherwise,
+        /// we simply don't know enough to set it properly, so it will stay null.
         /// </summary>
         private readonly string _definingProject;
 
@@ -144,9 +144,9 @@ public TaskItem(
         /// Gets or sets the item-spec.
         /// </summary>
         /// <comments>
-        /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but 
+        /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but
         /// that the value being returned was unescaped.  Maintain that behaviour here.  To get
-        /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped. 
+        /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped.
         /// </comments>
         /// <value>The item-spec string.</value>
         public string ItemSpec
@@ -212,9 +212,9 @@ public ICollection MetadataNames
 
         /// <summary>
         /// Gets the metadata dictionary
-        /// Property is required so that we can access the metadata dictionary in an item from 
-        /// another appdomain, as the CLR has implemented remoting policies that disallow accessing 
-        /// private fields in remoted items. 
+        /// Property is required so that we can access the metadata dictionary in an item from
+        /// another appdomain, as the CLR has implemented remoting policies that disallow accessing
+        /// private fields in remoted items.
         /// </summary>
         private CopyOnWriteDictionary<string> Metadata
         {
@@ -249,7 +249,7 @@ public void RemoveMetadata(string metadataName)
         /// Sets one of the arbitrary metadata on the item.
         /// </summary>
         /// <comments>
-        /// Assumes that the value being passed in is in its escaped form. 
+        /// Assumes that the value being passed in is in its escaped form.
         /// </comments>
         /// <param name="metadataName">Name of metadata to set or change.</param>
         /// <param name="metadataValue">Value of metadata.</param>
@@ -274,7 +274,7 @@ public void SetMetadata(
         /// If not found, returns empty string.
         /// </summary>
         /// <comments>
-        /// Returns the unescaped value of the metadata requested. 
+        /// Returns the unescaped value of the metadata requested.
         /// </comments>
         /// <param name="metadataName">The name of the metadata to retrieve.</param>
         /// <returns>The metadata value.</returns>
@@ -370,8 +370,8 @@ public void CopyMetadataTo(ITaskItem destinationItem)
         /// 2) writing to this dictionary should not be reflected in the underlying item.
         /// </remarks>
         /// <comments>
-        /// Returns an UNESCAPED version of the custom metadata. For the escaped version (which 
-        /// is how it is stored internally), call ITaskItem2.CloneCustomMetadataEscaped. 
+        /// Returns an UNESCAPED version of the custom metadata. For the escaped version (which
+        /// is how it is stored internally), call ITaskItem2.CloneCustomMetadataEscaped.
         /// </comments>
         public IDictionary CloneCustomMetadata()
         {
@@ -449,13 +449,13 @@ string ITaskItem2.GetMetadataValueEscaped(string metadataName)
         /// Sets the escaped value of the metadata with the specified name.
         /// </summary>
         /// <comments>
-        /// Assumes the value is passed in unescaped. 
+        /// Assumes the value is passed in unescaped.
         /// </comments>
         void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) => SetMetadata(metadataName, EscapingUtilities.Escape(metadataValue));
 
         /// <summary>
         /// ITaskItem2 implementation which returns a clone of the metadata on this object.
-        /// Values returned are in their original escaped form. 
+        /// Values returned are in their original escaped form.
         /// </summary>
         /// <returns>The cloned metadata.</returns>
         IDictionary ITaskItem2.CloneCustomMetadataEscaped() => _metadata == null
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index e419870cbe7..61d80f07220 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -1025,7 +1025,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
 
             try
             {
-                // TODO: Add caching so that we only have to read all this stuff in once. 
+                // TODO: Add caching so that we only have to read all this stuff in once.
                 string sdkRoot = GetPlatformSDKLocation(targetPlatformIdentifier, targetPlatformVersion, diskRoots, registryRoot);
                 string winmdLocation = null;
 
@@ -1839,7 +1839,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
                     return FileUtilities.EnsureNoTrailingSlash(legacyMsCorlib20Path);
                 }
 
-                // If for some reason the 2.0 framework is not installed in its default location then maybe someone is using the ".net 4.0" reference assembly 
+                // If for some reason the 2.0 framework is not installed in its default location then maybe someone is using the ".net 4.0" reference assembly
                 // location, if so then we can just use what ever version they passed in because it should be MSIL now and not bit specific.
             }
 
@@ -2236,7 +2236,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
                 if (string.IsNullOrEmpty(frameworkName.Profile)) // profiles are always in new locations
                 {
                     // If the identifier is ".NET Framework" and the version is a well know legacy version. Manually generate the list of reference assembly paths
-                    // based on the known chaining order. Pass null in for the two delegates so we call the static methods rather than require the creation and calling 
+                    // based on the known chaining order. Pass null in for the two delegates so we call the static methods rather than require the creation and calling
                     // of two delegates
                     dotNetFrameworkReferenceAssemblies = HandleLegacyDotNetFrameworkReferenceAssemblyPaths(
                         null,
@@ -2292,7 +2292,7 @@ public static string GetDisplayNameForTargetFrameworkDirectory(string targetFram
                 }
             }
 
-            // Still don't have one. 
+            // Still don't have one.
             // Probably it's 3.5 or earlier: make something reasonable.
             // VS uses the same algorithm to find something to display
             StringBuilder displayNameBuilder = new StringBuilder();
@@ -2545,7 +2545,7 @@ internal static void GatherExtensionSDKs(DirectoryInfo extensionSdksDirectory, T
                     ErrorUtilities.DebugTraceMessage("GatherExtensionSDKs", "Parsed sdk version folder '{0}' under '{1}'", sdkVersionDirectory.Name, sdkVersionDirectory.FullName);
                     if (Version.TryParse(sdkVersionDirectory.Name, out Version _))
                     {
-                        // Create SDK name based on the folder structure. We could open the manifest here and read the display name, but that would 
+                        // Create SDK name based on the folder structure. We could open the manifest here and read the display name, but that would
                         // add complexity and since things are supposed to be in a certain structure I don't think that is needed at this point.
                         string SDKKey = TargetPlatformSDK.GetSdkKey(sdkNameFolders.Name, sdkVersionDirectory.Name);
 
@@ -2644,7 +2644,7 @@ internal static void GatherSDKListFromDirectory(List<string> diskroots, Dictiona
                                 targetPlatformSDK.Path = platformSDKDirectory;
                             }
 
-                            // Gather the set of platforms supported by this SDK if it's a valid one. 
+                            // Gather the set of platforms supported by this SDK if it's a valid one.
                             if (!string.IsNullOrEmpty(targetPlatformSDK.Path))
                             {
                                 GatherPlatformsForSdk(targetPlatformSDK);
@@ -2686,7 +2686,7 @@ internal static void GatherSDKsFromRegistryImpl(Dictionary<TargetPlatformSDK, Ta
             {
                 ErrorUtilities.DebugTraceMessage("GatherSDKsFromRegistryImpl", "Gathering SDKS from registryRoot '{0}', Hive '{1}', View '{2}'", registryKeyRoot, registryHive, registryView);
 
-                // Attach the target platform to the registry root. This should give us something like 
+                // Attach the target platform to the registry root. This should give us something like
                 // SOFTWARE\MICROSOFT\Microsoft SDKs\Windows
 
                 // Get all of the platform identifiers
@@ -2764,7 +2764,7 @@ internal static void GatherSDKsFromRegistryImpl(Dictionary<TargetPlatformSDK, Ta
                                 targetPlatformSDK.Path = platformSDKDirectory;
                             }
 
-                            // Gather the set of platforms supported by this SDK if it's a valid one. 
+                            // Gather the set of platforms supported by this SDK if it's a valid one.
                             if (!string.IsNullOrEmpty(targetPlatformSDK.Path))
                             {
                                 GatherPlatformsForSdk(targetPlatformSDK);
@@ -2877,7 +2877,7 @@ private static void GatherSDKListFromRegistry(string registryRoot, Dictionary<Ta
             // Under WOW64 the HKEY_CURRENT_USER\SOFTWARE key is shared. This means the values are the same in the 64 bit and 32 bit views. This means we only need to get one view of this key.
             GatherSDKsFromRegistryImpl(platformMonikers, registryRoot, RegistryView.Default, RegistryHive.CurrentUser, getSubkeyNames, getRegistrySubKeyDefaultValue, openBaseKey, fileExists);
 
-            // Since SDKS can contain multiple architecture it makes sense to register both 32 bit and 64 bit in one location, but if for some reason that 
+            // Since SDKS can contain multiple architecture it makes sense to register both 32 bit and 64 bit in one location, but if for some reason that
             // is not possible then we need to look at both hives. Choosing the 32 bit one first because is where we expect to find them usually.
             if (is64bitOS)
             {
@@ -3036,7 +3036,7 @@ private static void GatherPlatformsForSdk(TargetPlatformSDK sdk)
                     DirectoryInfo[] platformIdentifiers = platformsRootInfo.GetDirectories();
                     ErrorUtilities.DebugTraceMessage("GatherPlatformsForSdk", "Found '{0}' platform identifier directories under '{1}'", platformIdentifiers.Length, platformsRoot);
 
-                    // Iterate through all identifiers 
+                    // Iterate through all identifiers
                     foreach (DirectoryInfo platformIdentifier in platformIdentifiers)
                     {
                         DirectoryInfo[] platformVersions = platformIdentifier.GetDirectories();
@@ -3108,7 +3108,7 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
                 }
             }
 
-            // Read in the redist list at the specified path, and return 
+            // Read in the redist list at the specified path, and return
             // the display name and the "include framework" value for chaining.
             // If display name is not available, returns empty string.
             // If include framework is not available, returns null.
@@ -3205,7 +3205,7 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
                 if (!string.IsNullOrEmpty(includeFramework))
                 {
                     // Take the path which should point to something like  c:\ProgramFiles\ReferenceAssemblies\Framework\.NETFramework\v4.1
-                    // We will take the path, to "up" a directory then append the name found in the redist. For example if the redist list had v4.0 
+                    // We will take the path, to "up" a directory then append the name found in the redist. For example if the redist list had v4.0
                     // the path which would be expected would be c:\ProgramFiles\ReferenceAssemblies\Framework\.NETFramework\v4.0
                     pathToReturn = path;
                     pathToReturn = Directory.GetParent(pathToReturn).FullName;
@@ -3407,7 +3407,7 @@ internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture
                         NativeMethodsShared.ProcessorArchitectures.IA64 => ProcessorArchitecture.IA64,
                         NativeMethodsShared.ProcessorArchitectures.ARM64 => ProcessorArchitecture.ARM64,
                         // Error, OK, we're trying to get the 64-bit path on a 32-bit machine.
-                        // That ... doesn't make sense. 
+                        // That ... doesn't make sense.
                         NativeMethodsShared.ProcessorArchitectures.X86 => null,
                         NativeMethodsShared.ProcessorArchitectures.ARM => null,
                         // unknown architecture? return null
@@ -3741,7 +3741,7 @@ private static SharedDotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkA
                     sharedArchitecture = SharedDotNetFrameworkArchitecture.Bitness64;
                     break;
                 default:
-                    // Should never reach here -- If any new values are added to the DotNetFrameworkArchitecture enum, they should be added here as well.  
+                    // Should never reach here -- If any new values are added to the DotNetFrameworkArchitecture enum, they should be added here as well.
                     ErrorUtilities.ThrowInternalErrorUnreachable();
                     break;
             }
@@ -3885,7 +3885,7 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
                 }
             }
 
-            // sort in ascending order of the version numbers, this is important as later when we search for assemblies in other methods 
+            // sort in ascending order of the version numbers, this is important as later when we search for assemblies in other methods
             // we should be looking in ascending order of the framework version folders on disk
             frameworkVersions.Sort(VersionComparer.Instance);
 
@@ -3955,7 +3955,7 @@ private static IList<string> GetFx35AndEarlierVersions(string frameworkReference
 
             if (dotNetFx35Path != null)
             {
-                // .NetFx35 is installed  
+                // .NetFx35 is installed
 
                 // check v20
                 string dotNetFx20Path = GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20);
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index f687076fbfb..c196b0afcc8 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -952,8 +952,8 @@ public void RemoveEntriesForSource(ITaskItem[] source)
         }
 
         /// <summary>
-        /// Remove the entry in the input dependency graph corresponding to the rooting marker 
-        /// passed in. 
+        /// Remove the entry in the input dependency graph corresponding to the rooting marker
+        /// passed in.
         /// </summary>
         /// <param name="rootingMarker">The root to remove</param>
         public void RemoveEntryForSourceRoot(string rootingMarker) => DependencyTable.Remove(rootingMarker);
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index ef1ad5bfa5e..5a94ceeb1ad 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -259,13 +259,13 @@ private void ConstructOutputTable()
 
         /// <summary>
         /// Given a set of sources, removes from the dependency graph any roots that share
-        /// the same outputs as the rooting marker constructed from the given set of sources. 
+        /// the same outputs as the rooting marker constructed from the given set of sources.
         /// </summary>
         /// <comment>
-        /// Used when there's a possibility that more than one set of inputs may produce the 
-        /// same output -- this is a way to invalidate any other roots that produce that same 
-        /// outputs, so that the next time the task is run with that other set of inputs, it 
-        /// won't incorrectly believe that it is up-to-date.  
+        /// Used when there's a possibility that more than one set of inputs may produce the
+        /// same output -- this is a way to invalidate any other roots that produce that same
+        /// outputs, so that the next time the task is run with that other set of inputs, it
+        /// won't incorrectly believe that it is up-to-date.
         /// </comment>
         /// <param name="sources">The set of sources that form the rooting marker whose outputs
         /// should not be shared by any other rooting marker.</param>
@@ -279,15 +279,15 @@ public string[] RemoveRootsWithSharedOutputs(ITaskItem[] sources)
 
             if (DependencyTable.TryGetValue(currentRoot, out Dictionary<string, DateTime> currentOutputs))
             {
-                // This is O(n*m), but in most cases, both n (the number of roots in the file) and m (the number 
-                // of outputs per root) should be fairly small. 
+                // This is O(n*m), but in most cases, both n (the number of roots in the file) and m (the number
+                // of outputs per root) should be fairly small.
                 // UNDONE: Can we make this faster?
                 foreach (KeyValuePair<string, Dictionary<string, DateTime>> root in DependencyTable)
                 {
                     if (!currentRoot.Equals(root.Key, StringComparison.Ordinal))
                     {
-                        // If the current entry contains any of the outputs of the rooting marker we have sources for, 
-                        // then we want to remove it from the dependency table. 
+                        // If the current entry contains any of the outputs of the rooting marker we have sources for,
+                        // then we want to remove it from the dependency table.
                         foreach (string output in currentOutputs.Keys)
                         {
                             if (root.Value.ContainsKey(output))
@@ -299,7 +299,7 @@ public string[] RemoveRootsWithSharedOutputs(ITaskItem[] sources)
                     }
                 }
 
-                // Now actually remove the markers that we intend to remove. 
+                // Now actually remove the markers that we intend to remove.
                 foreach (string removedMarker in removedMarkers)
                 {
                     DependencyTable.Remove(removedMarker);
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index f18ba533556..818d9122a1f 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -79,9 +79,9 @@ internal static DependencyTableCacheEntry GetCachedEntry(string tLogRootingMarke
         }
 
         /// <summary>
-        /// Given a set of TLog names, formats a rooting marker from them, that additionally replaces 
-        /// all PIDs and TIDs with "[ID]" so the cache doesn't get overloaded with entries 
-        /// that should be basically the same but have different PIDs or TIDs in the name. 
+        /// Given a set of TLog names, formats a rooting marker from them, that additionally replaces
+        /// all PIDs and TIDs with "[ID]" so the cache doesn't get overloaded with entries
+        /// that should be basically the same but have different PIDs or TIDs in the name.
         /// </summary>
         /// <param name="tlogFiles">The set of tlogs to format</param>
         /// <returns>The normalized rooting marker based on that set of tlogs</returns>
@@ -101,26 +101,26 @@ internal static string FormatNormalizedTlogRootingMarker(ITaskItem[] tlogFiles)
         }
 
         /// <summary>
-        /// Given a TLog path, replace all PIDs and TIDs with "[ID]" in the filename, where 
+        /// Given a TLog path, replace all PIDs and TIDs with "[ID]" in the filename, where
         /// the typical format of a filename is "tool[.PID][-tool].read/write/command/delete.TID.tlog"
         /// </summary>
         /// <comments>
         /// The algorithm used finds all instances of .\d+. and .\d+- in the filename and translates them
-        /// to .[ID]. and .[ID]- respectively, where "filename" is defined as the part of the path following 
-        /// the final '\' in the path.  
-        /// 
-        /// In the VS 2010 C++ project system, there are artificially constructed tlogs that instead follow the 
-        /// pattern "ProjectName.read/write.1.tlog", which means that one result of this change is that such 
+        /// to .[ID]. and .[ID]- respectively, where "filename" is defined as the part of the path following
+        /// the final '\' in the path.
+        ///
+        /// In the VS 2010 C++ project system, there are artificially constructed tlogs that instead follow the
+        /// pattern "ProjectName.read/write.1.tlog", which means that one result of this change is that such
         /// tlogs, should the project name also contain this pattern (e.g. ClassLibrary.1.csproj), will also end up
-        /// with [ID] being substituted for digits in the project name itself -- so the tlog name would end up being 
-        /// ClassLibrary.[ID].read.[ID].tlog, rather than ClassLibrary.1.read.[ID].tlog.  This could potentially 
-        /// cause issues if there are multiple projects differentiated only by the digits in their names; however 
-        /// we believe this is not an interesting scenario to watch for and support, given that the resultant rooting 
-        /// marker is constructed from full paths, so either: 
-        /// - The project directories are also different, and are never substituted, leading to different full paths (e.g. 
+        /// with [ID] being substituted for digits in the project name itself -- so the tlog name would end up being
+        /// ClassLibrary.[ID].read.[ID].tlog, rather than ClassLibrary.1.read.[ID].tlog.  This could potentially
+        /// cause issues if there are multiple projects differentiated only by the digits in their names; however
+        /// we believe this is not an interesting scenario to watch for and support, given that the resultant rooting
+        /// marker is constructed from full paths, so either:
+        /// - The project directories are also different, and are never substituted, leading to different full paths (e.g.
         ///   C:\ClassLibrary.1\Debug\ClassLibrary.[ID].read.[ID].tlog and C:\ClassLibrary.2\Debug\ClassLibrary.[ID].read.[ID].tlog)
-        /// - The project directories are the same, in which case there are two projects that share the same intermediate 
-        ///   directory, which has a host of other problems and is explicitly NOT a supported scenario.  
+        /// - The project directories are the same, in which case there are two projects that share the same intermediate
+        ///   directory, which has a host of other problems and is explicitly NOT a supported scenario.
         /// </comments>
         /// <param name="tlogPath">The tlog path to normalize</param>
         /// <returns>The normalized path</returns>
@@ -128,8 +128,8 @@ private static string NormalizeTlogPath(string tlogPath)
         {
             if (tlogPath.IndexOfAny(s_numerals) == -1)
             {
-                // no reason to make modifications if there aren't any numerical IDs in the 
-                // log filename to begin with. 
+                // no reason to make modifications if there aren't any numerical IDs in the
+                // log filename to begin with.
                 return tlogPath;
             }
             else
@@ -137,10 +137,10 @@ private static string NormalizeTlogPath(string tlogPath)
                 int i;
                 StringBuilder normalizedTlogFilename = new StringBuilder();
 
-                // We're walking the filename backwards since once we hit the final '\', we know we can stop parsing. 
-                // So as to avoid allocating more memory and/or forcing StringBuilder to do more character copies 
-                // than necessary, we append the reversed filename character by character to its own StringBuilder, 
-                // and then reverse it again when constructing the final normalized path.  
+                // We're walking the filename backwards since once we hit the final '\', we know we can stop parsing.
+                // So as to avoid allocating more memory and/or forcing StringBuilder to do more character copies
+                // than necessary, we append the reversed filename character by character to its own StringBuilder,
+                // and then reverse it again when constructing the final normalized path.
                 for (i = tlogPath.Length - 1; i >= 0 && tlogPath[i] != '\\'; i--)
                 {
                     // final character in the pattern can be either '.' or '-'
@@ -166,7 +166,7 @@ private static string NormalizeTlogPath(string tlogPath)
                     }
                     else
                     {
-                        // append this character -- it's not interesting. 
+                        // append this character -- it's not interesting.
                         normalizedTlogFilename.Append(tlogPath[i]);
                     }
                 }
@@ -199,8 +199,8 @@ private static string NormalizeTlogPath(string tlogPath)
         private class TaskItemItemSpecIgnoreCaseComparer : IEqualityComparer<ITaskItem>
         {
             /// <summary>
-            /// Returns whether the two ITaskItems are equal, where they are judged to be 
-            /// equal as long as the itemspecs, compared case-insensitively, are equal. 
+            /// Returns whether the two ITaskItems are equal, where they are judged to be
+            /// equal as long as the itemspecs, compared case-insensitively, are equal.
             /// </summary>
             public bool Equals(ITaskItem x, ITaskItem y)
             {
@@ -219,8 +219,8 @@ public bool Equals(ITaskItem x, ITaskItem y)
 
             /// <summary>
             /// Returns the hashcode of this ITaskItem.  Given that equality is judged solely based
-            /// on the itemspec, the hash code for this particular comparer also only uses the 
-            /// itemspec to make its determination. 
+            /// on the itemspec, the hash code for this particular comparer also only uses the
+            /// itemspec to make its determination.
             /// </summary>
             public int GetHashCode(ITaskItem obj) => obj == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(obj.ItemSpec);
         }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 8012c69c886..be62498f6ee 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -50,7 +50,7 @@ public enum ExecutableType
         Managed64Bit = 4,
 
         /// <summary>
-        /// Use the same bitness as the currently running executable. 
+        /// Use the same bitness as the currently running executable.
         /// </summary>
         SameAsCurrentProcess = 5,
 
@@ -94,7 +94,7 @@ public static class FileTracker
         // The path to LocalApplicationData (is equal to %USERPROFILE%\Local Settings\Application Data folder in Windows XP and %USERPROFILE%\AppData\Local in Vista and later).
         private static readonly string s_localApplicationDataPath = FileUtilities.EnsureTrailingSlash(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData).ToUpperInvariant());
 
-        // The path to the LocalLow folder. In Vista and later, user application data is organized across %USERPROFILE%\AppData\LocalLow,  %USERPROFILE%\AppData\Local (%LOCALAPPDATA%) 
+        // The path to the LocalLow folder. In Vista and later, user application data is organized across %USERPROFILE%\AppData\LocalLow,  %USERPROFILE%\AppData\Local (%LOCALAPPDATA%)
         // and %USERPROFILE%\AppData\Roaming (%APPDATA%). The LocalLow folder is not present in XP.
         private static readonly string s_localLowApplicationDataPath = FileUtilities.EnsureTrailingSlash(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "AppData\\LocalLow").ToUpperInvariant());
 
@@ -154,64 +154,64 @@ private static List<string> InitializeCommonApplicationDataPaths()
         #region Native method wrappers
 
         /// <summary>
-        /// Stops tracking file accesses.  
+        /// Stops tracking file accesses.
         /// </summary>
         public static void EndTrackingContext() => InprocTrackingNativeMethods.EndTrackingContext();
 
         /// <summary>
-        /// Resume tracking file accesses in the current tracking context. 
+        /// Resume tracking file accesses in the current tracking context.
         /// </summary>
         public static void ResumeTracking() => InprocTrackingNativeMethods.ResumeTracking();
 
         /// <summary>
-        /// Set the global thread count, and assign that count to the current thread. 
+        /// Set the global thread count, and assign that count to the current thread.
         /// </summary>
         public static void SetThreadCount(int threadCount) => InprocTrackingNativeMethods.SetThreadCount(threadCount);
 
         /// <summary>
-        /// Starts tracking file accesses. 
+        /// Starts tracking file accesses.
         /// </summary>
         /// <param name="intermediateDirectory">The directory into which to write the tracking log files</param>
-        /// <param name="taskName">The name of the task calling this function, used to determine the 
+        /// <param name="taskName">The name of the task calling this function, used to determine the
         /// names of the tracking log files</param>
         public static void StartTrackingContext(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.StartTrackingContext(intermediateDirectory, taskName);
 
         /// <summary>
-        /// Starts tracking file accesses, using the rooting marker in the response file provided.  To 
-        /// automatically generate a response file given a rooting marker, call 
-        /// FileTracker.CreateRootingMarkerResponseFile. 
+        /// Starts tracking file accesses, using the rooting marker in the response file provided.  To
+        /// automatically generate a response file given a rooting marker, call
+        /// FileTracker.CreateRootingMarkerResponseFile.
         /// </summary>
         /// <param name="intermediateDirectory">The directory into which to write the tracking log files</param>
-        /// <param name="taskName">The name of the task calling this function, used to determine the 
+        /// <param name="taskName">The name of the task calling this function, used to determine the
         /// names of the tracking log files</param>
         /// <param name="rootMarkerResponseFile">The path to the root marker response file.</param>
         public static void StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarkerResponseFile)
             => InprocTrackingNativeMethods.StartTrackingContextWithRoot(intermediateDirectory, taskName, rootMarkerResponseFile);
 
         /// <summary>
-        /// Stop tracking file accesses and get rid of the current tracking contexts. 
+        /// Stop tracking file accesses and get rid of the current tracking contexts.
         /// </summary>
         public static void StopTrackingAndCleanup() => InprocTrackingNativeMethods.StopTrackingAndCleanup();
 
         /// <summary>
-        /// Temporarily suspend tracking of file accesses in the current tracking context. 
+        /// Temporarily suspend tracking of file accesses in the current tracking context.
         /// </summary>
         public static void SuspendTracking() => InprocTrackingNativeMethods.SuspendTracking();
 
         /// <summary>
-        /// Write tracking logs for all contexts and threads. 
+        /// Write tracking logs for all contexts and threads.
         /// </summary>
         /// <param name="intermediateDirectory">The directory into which to write the tracking log files</param>
-        /// <param name="taskName">The name of the task calling this function, used to determine the 
+        /// <param name="taskName">The name of the task calling this function, used to determine the
         /// names of the tracking log files</param>
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLogs", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public static void WriteAllTLogs(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.WriteAllTLogs(intermediateDirectory, taskName);
 
         /// <summary>
-        /// Write tracking logs corresponding to the current tracking context.  
+        /// Write tracking logs corresponding to the current tracking context.
         /// </summary>
         /// <param name="intermediateDirectory">The directory into which to write the tracking log files</param>
-        /// <param name="taskName">The name of the task calling this function, used to determine the 
+        /// <param name="taskName">The name of the task calling this function, used to determine the
         /// names of the tracking log files</param>
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLogs", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public static void WriteContextTLogs(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.WriteContextTLogs(intermediateDirectory, taskName);
@@ -244,7 +244,7 @@ public static bool FileIsExcludedFromDependencies(string fileName)
             // 3. Files under %USERPROFILE%\AppData\LocalLow in Vista and later.
             // 4. Files that are in the TEMP directory (Since on XP, temp files are not
             //    located under AppData, they would not be compacted out correctly otherwise).
-            // 5. Files under the common ("All Users") Application Data location -- C:\Documents and Settings\All Users\Application Data 
+            // 5. Files under the common ("All Users") Application Data location -- C:\Documents and Settings\All Users\Application Data
             //    on XP and either C:\Users\All Users\Application Data or C:\ProgramData on Vista+
 
             return FileIsUnderPath(fileName, s_applicationDataPath) ||
@@ -334,7 +334,7 @@ public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] output
 
         /// <summary>
         /// Given a set of source files in the form of ITaskItem, creates a temporary response
-        /// file containing the rooting marker that corresponds to those sources. 
+        /// file containing the rooting marker that corresponds to those sources.
         /// </summary>
         /// <param name="sources">
         /// ITaskItem array of primary sources.
@@ -343,7 +343,7 @@ public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] output
         public static string CreateRootingMarkerResponseFile(ITaskItem[] sources) => CreateRootingMarkerResponseFile(FormatRootingMarker(sources));
 
         /// <summary>
-        /// Given a rooting marker, creates a temporary response file with that rooting marker 
+        /// Given a rooting marker, creates a temporary response file with that rooting marker
         /// in it.
         /// </summary>
         /// <param name="rootMarker">The rooting marker to put in the response file.</param>
@@ -358,7 +358,7 @@ public static string CreateRootingMarkerResponseFile(string rootMarker)
 
         /// <summary>
         /// Prepends the path to the appropriate FileTracker assembly to the PATH
-        /// environment variable.  Used for inproc tracking, or when the .NET Framework may 
+        /// environment variable.  Used for inproc tracking, or when the .NET Framework may
         /// not be on the PATH.
         /// </summary>
         /// <returns>The old value of PATH</returns>
@@ -366,7 +366,7 @@ public static string CreateRootingMarkerResponseFile(string rootMarker)
 
         /// <summary>
         /// Prepends the path to the appropriate FileTracker assembly to the PATH
-        /// environment variable.  Used for inproc tracking, or when the .NET Framework may 
+        /// environment variable.  Used for inproc tracking, or when the .NET Framework may
         /// not be on the PATH.
         /// </summary>
         /// <param name="rootPath">The root path for FileTracker.dll.  Overrides the toolType if specified.</param>
@@ -385,8 +385,8 @@ public static string EnsureFileTrackerOnPath(string rootPath)
         }
 
         /// <summary>
-        /// Searches %PATH% for the location of Tracker.exe, and returns the first 
-        /// path that matches. 
+        /// Searches %PATH% for the location of Tracker.exe, and returns the first
+        /// path that matches.
         /// </summary>
         /// <returns>The full path to Tracker.exe, or <see langword="null" /> if a matching path is not found.</returns>
         public static string FindTrackerOnPath()
@@ -410,7 +410,7 @@ public static string FindTrackerOnPath()
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
-                    // ignore this path and move on -- it's just bad for some reason. 
+                    // ignore this path and move on -- it's just bad for some reason.
                 }
             }
 
@@ -419,14 +419,14 @@ public static string FindTrackerOnPath()
         }
 
         /// <summary>
-        /// Determines whether we must track out-of-proc, or whether inproc tracking will work. 
+        /// Determines whether we must track out-of-proc, or whether inproc tracking will work.
         /// </summary>
         /// <param name="toolType">The executable type for the tool being tracked</param>
         /// <returns>True if we need to track out-of-proc, false if inproc tracking is OK</returns>
         public static bool ForceOutOfProcTracking(ExecutableType toolType) => ForceOutOfProcTracking(toolType, null, null);
 
         /// <summary>
-        /// Determines whether we must track out-of-proc, or whether inproc tracking will work. 
+        /// Determines whether we must track out-of-proc, or whether inproc tracking will work.
         /// </summary>
         /// <param name="toolType">The executable type for the tool being tracked</param>
         /// <param name="dllName">An optional assembly name.</param>
@@ -438,7 +438,7 @@ public static bool ForceOutOfProcTracking(ExecutableType toolType, string dllNam
 
             if (cancelEventName != null)
             {
-                // If we have a cancel event, we must track out-of-proc. 
+                // If we have a cancel event, we must track out-of-proc.
                 trackOutOfProc = true;
             }
             else if (dllName != null)
@@ -455,34 +455,34 @@ public static bool ForceOutOfProcTracking(ExecutableType toolType, string dllNam
         }
 
         /// <summary>
-        /// Given the ExecutableType of the tool being wrapped and information that we 
+        /// Given the ExecutableType of the tool being wrapped and information that we
         /// know about our current bitness, figures out and returns the path to the correct
-        /// Tracker.exe. 
+        /// Tracker.exe.
         /// </summary>
         /// <param name="toolType">The <see cref="ExecutableType"/> of the tool being wrapped</param>
         public static string GetTrackerPath(ExecutableType toolType) => GetTrackerPath(toolType, null);
 
         /// <summary>
-        /// Given the ExecutableType of the tool being wrapped and information that we 
+        /// Given the ExecutableType of the tool being wrapped and information that we
         /// know about our current bitness, figures out and returns the path to the correct
-        /// Tracker.exe. 
+        /// Tracker.exe.
         /// </summary>
         /// <param name="toolType">The <see cref="ExecutableType"/> of the tool being wrapped</param>
         /// <param name="rootPath">The root path for Tracker.exe.  Overrides the toolType if specified.</param>
         public static string GetTrackerPath(ExecutableType toolType, string rootPath) => GetPath(s_TrackerFilename, toolType, rootPath);
 
         /// <summary>
-        /// Given the ExecutableType of the tool being wrapped and information that we 
+        /// Given the ExecutableType of the tool being wrapped and information that we
         /// know about our current bitness, figures out and returns the path to the correct
-        /// FileTracker.dll. 
+        /// FileTracker.dll.
         /// </summary>
         /// <param name="toolType">The <see cref="ExecutableType"/> of the tool being wrapped</param>
         public static string GetFileTrackerPath(ExecutableType toolType) => GetFileTrackerPath(toolType, null);
 
         /// <summary>
-        /// Given the ExecutableType of the tool being wrapped and information that we 
+        /// Given the ExecutableType of the tool being wrapped and information that we
         /// know about our current bitness, figures out and returns the path to the correct
-        /// FileTracker.dll. 
+        /// FileTracker.dll.
         /// </summary>
         /// <param name="toolType">The <see cref="ExecutableType"/> of the tool being wrapped</param>
         /// <param name="rootPath">The root path for FileTracker.dll.  Overrides the toolType if specified.</param>
@@ -490,7 +490,7 @@ public static bool ForceOutOfProcTracking(ExecutableType toolType, string dllNam
 
         /// <summary>
         /// Given a filename (only really meant to support either Tracker.exe or FileTracker.dll), returns
-        /// the appropriate path for the appropriate file type. 
+        /// the appropriate path for the appropriate file type.
         /// </summary>
         /// <param name="filename"></param>
         /// <param name="toolType"></param>
@@ -521,16 +521,16 @@ private static string GetPath(string filename, ExecutableType toolType, string r
         }
 
         /// <summary>
-        /// Given a filename (currently only Tracker.exe and FileTracker.dll are supported), return 
-        /// the path to that file. 
+        /// Given a filename (currently only Tracker.exe and FileTracker.dll are supported), return
+        /// the path to that file.
         /// </summary>
         /// <param name="filename"></param>
         /// <param name="bitness"></param>
         /// <returns></returns>
         private static string GetPath(string filename, DotNetFrameworkArchitecture bitness)
         {
-            // Make sure that if someone starts passing the wrong thing to this method we don't silently 
-            // eat it and do something possibly unexpected. 
+            // Make sure that if someone starts passing the wrong thing to this method we don't silently
+            // eat it and do something possibly unexpected.
             ErrorUtilities.VerifyThrow(
                                        s_TrackerFilename.Equals(filename, StringComparison.OrdinalIgnoreCase) ||
                                        s_FileTrackerFilename.Equals(filename, StringComparison.OrdinalIgnoreCase),
@@ -649,7 +649,7 @@ public static string TrackerArguments(string command, string arguments, string d
         #region StartProcess methods
 
         /// <summary>
-        /// Start the process; tracking the command.  
+        /// Start the process; tracking the command.
         /// </summary>
         /// <param name="command">The command to track</param>
         /// <param name="arguments">The command to track's arguments</param>
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index b9c6288db79..e778ff04f3b 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -382,7 +382,7 @@ private void ConstructFileTable()
 
                 // We may have stored the dependency table in the cache, but all the other information
                 // (newest file time, number of missing files, etc.) has been reset to default.  Refresh
-                // the data.  
+                // the data.
                 UpdateFileEntryDetails();
 
                 // Log information about what we're using
@@ -396,8 +396,8 @@ private void ConstructFileTable()
 
             FileTracker.LogMessageFromResources(_log, MessageImportance.Low, "Tracking_TrackingLogs");
             // Now we need to construct the rest of the table from the TLOG files
-            // If there are any errors in the tlogs, we want to warn, stop parsing tlogs, and empty 
-            // out the dependency table, essentially forcing a rebuild.  
+            // If there are any errors in the tlogs, we want to warn, stop parsing tlogs, and empty
+            // out the dependency table, essentially forcing a rebuild.
             bool encounteredInvalidTLogContents = false;
             string invalidTLogName = null;
             foreach (ITaskItem tlogFileName in TlogFiles)
@@ -476,8 +476,8 @@ private void ConstructFileTable()
 
             lock (DependencyTableCache.DependencyTable)
             {
-                // There were problems with the tracking logs -- we've already warned or errored; now we want to make 
-                // sure that we essentially force a rebuild of this particular root. 
+                // There were problems with the tracking logs -- we've already warned or errored; now we want to make
+                // sure that we essentially force a rebuild of this particular root.
                 if (encounteredInvalidTLogContents)
                 {
                     DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
@@ -655,7 +655,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
         }
 
         /// <summary>
-        /// Returns cached value for last write time of file. Update the cache if it is the first 
+        /// Returns cached value for last write time of file. Update the cache if it is the first
         /// time someone asking for that file
         /// </summary>
         public DateTime GetLastWriteTimeUtc(string file)
@@ -734,7 +734,7 @@ public static bool IsUpToDate(TaskLoggingHelper Log, UpToDateCheckType upToDateC
             if (!inputs.TlogsAvailable || !outputs.TlogsAvailable || inputs.DependencyTable.Count == 0)
             {
                 // 1) The TLogs are somehow missing, which means we need to build
-                // 2) Because we are flat tracking, there are no roots which means that all the input file information 
+                // 2) Because we are flat tracking, there are no roots which means that all the input file information
                 //    comes from the input Tlogs, if they are empty then we must build.
                 Log.LogMessageFromResources(MessageImportance.Low, "Tracking_LogFilesNotAvailable");
             }
@@ -878,7 +878,7 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
                 }
                 else
                 {
-                    // Compact the write tlog                        
+                    // Compact the write tlog
                     outputs.SaveTlog();
 
                     // Compact the read tlog
