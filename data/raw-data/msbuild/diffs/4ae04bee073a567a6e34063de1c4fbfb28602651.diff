diff --git a/eng/Common.globalconfig b/eng/Common.globalconfig
index 05172cc7ab3..afb2c4d880f 100644
--- a/eng/Common.globalconfig
+++ b/eng/Common.globalconfig
@@ -1121,9 +1121,6 @@ dotnet_diagnostic.IDE0008.severity = suggestion
 # Populate switch
 dotnet_diagnostic.IDE0010.severity = suggestion
 
-# Add braces to statement
-dotnet_diagnostic.IDE0011.severity = suggestion
-
 # Null check can be simplified
 dotnet_diagnostic.IDE0016.severity = suggestion
 
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index ca3f74502fe..c04a795158a 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -132,7 +132,10 @@ public void AddProjectOnSave_SpecifiedProjectCollection()
             }
             finally
             {
-                if (path != null) File.Delete(path);
+                if (path != null)
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -838,8 +841,15 @@ public void SaveToNewNameAndUnload()
             }
             finally
             {
-                if (file1 != null) File.Delete(file1);
-                if (file2 != null) File.Delete(file2);
+                if (file1 != null)
+                {
+                    File.Delete(file1);
+                }
+
+                if (file2 != null)
+                {
+                    File.Delete(file2);
+                }
             }
         }
 
@@ -874,8 +884,15 @@ public void LoadUnloadReloadSaveToNewName()
             }
             finally
             {
-                if (file1 != null) File.Delete(file1);
-                if (file2 != null) File.Delete(file2);
+                if (file1 != null)
+                {
+                    File.Delete(file1);
+                }
+
+                if (file2 != null)
+                {
+                    File.Delete(file2);
+                }
             }
         }
 
@@ -910,8 +927,15 @@ public void LoadUnloadAllReloadSaveToNewName()
             }
             finally
             {
-                if (file1 != null) File.Delete(file1);
-                if (file2 != null) File.Delete(file2);
+                if (file1 != null)
+                {
+                    File.Delete(file1);
+                }
+
+                if (file2 != null)
+                {
+                    File.Delete(file2);
+                }
             }
         }
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index 83ce92e4d30..8672b476a16 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -253,7 +253,9 @@ private void Clear(ProjectCollectionLinker linker)
                 foreach (var p in linker.Collection.LoadedProjects)
                 {
                     if (!toKeep.Contains(p))
+                    {
                         toUnload.Add(p);
+                    }
                 }
 
                 foreach (var p in toUnload)
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index 100d0b6ae77..88cb25fcb41 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -246,7 +246,10 @@ public static void VerifySameLocationWithException(Func<ElementLocation> expecte
 
         public static void VerifySameLocation(ElementLocation expected, ElementLocation actual, ValidationContext context = null)
         {
-            if (object.ReferenceEquals(expected, actual)) return;
+            if (object.ReferenceEquals(expected, actual))
+            {
+                return;
+            }
 
             if (context?.ValidateLocation != null)
             {
@@ -270,7 +273,11 @@ public static bool IsLinkedObject(object obj)
         private static bool dbgIgnoreLinked = false; 
         public static void VerifyNotLinked(object obj)
         {
-            if (dbgIgnoreLinked) return;
+            if (dbgIgnoreLinked)
+            {
+                return;
+            }
+
             Assert.True(obj == null || !IsLinkedObject(obj));
         }
 
@@ -278,8 +285,15 @@ public static void VerifyNotLinked(object obj)
         public static T GetRealObject<T>(T view)
             where T : class
         {
-            if (view == null) return null;
-            if (!IsLinkedObject(view)) return view;
+            if (view == null)
+            {
+                return null;
+            }
+
+            if (!IsLinkedObject(view))
+            {
+                return view;
+            }
 
             var link = LinkedObjectsFactory.GetLink(view) as ILinkMock;
             Assert.NotNull(link);
@@ -293,7 +307,11 @@ public static T GetRealObject<T>(T view)
 
         public static void VerifyLinked(object obj)
         {
-            if (dbgIgnoreLinked) return;
+            if (dbgIgnoreLinked)
+            {
+                return;
+            }
+
             Assert.True(obj == null || IsLinkedObject(obj));
         }
 
@@ -301,21 +319,33 @@ public static void VerifyLinked(object obj)
         public static void VerifyNotNull(object obj, bool linked)
         {
             Assert.NotNull(obj);
-            if (dbgIgnoreLinked) return;
+            if (dbgIgnoreLinked)
+            {
+                return;
+            }
+
             Assert.Equal(linked, IsLinkedObject(obj));
         }
 
         public static void VerifyNotLinkedNotNull(object obj)
         {
             Assert.NotNull(obj);
-            if (dbgIgnoreLinked) return;
+            if (dbgIgnoreLinked)
+            {
+                return;
+            }
+
             Assert.True(!IsLinkedObject(obj));
         }
 
         public static void VerifyLinkedNotNull(object obj)
         {
             Assert.NotNull(obj);
-            if (dbgIgnoreLinked) return;
+            if (dbgIgnoreLinked)
+            {
+                return;
+            }
+
             Assert.True(IsLinkedObject(obj));
         }
 
@@ -344,7 +374,10 @@ public static void ValidateEqualWithException<T>(Func<T> viewGetter, Func<T> rea
 
         private static void VerifyProjectElementViewInternal(ProjectElement viewXml, ProjectElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
 
             VerifyLinkedNotNull(viewXml);
             VerifyNotLinkedNotNull(realXml);
@@ -379,7 +412,11 @@ private static void VerifyProjectElementViewInternal(ProjectElement viewXml, Pro
 
         private static void VerifyProjectElementContainerView(ProjectElementContainer viewXml, ProjectElementContainer realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElementViewInternal(viewXml, realXml, context);
 
             Assert.Equal(realXml.Count, viewXml.Count);
@@ -458,7 +495,10 @@ public static void VerifyProjectCollectionLinks(IEnumerable<Project> projects, i
 
         public static void VerifyProjectElement(ProjectElement viewXml, ProjectElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
 
             if (viewXml is ProjectElementContainer viewContainer)
             {
@@ -474,7 +514,11 @@ public static void VerifyProjectElement(ProjectElement viewXml, ProjectElement r
 
         public static void Verify(ProjectRootElement viewXml, ProjectRootElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.FullPath, viewXml.FullPath);
@@ -517,7 +561,11 @@ public static void Verify(ProjectRootElement viewXml, ProjectRootElement realXml
 
         public static void Verify(ProjectChooseElement viewXml, ProjectChooseElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
 
@@ -527,7 +575,11 @@ public static void Verify(ProjectChooseElement viewXml, ProjectChooseElement rea
 
         public static void Verify(ProjectWhenElement viewXml, ProjectWhenElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
 
@@ -538,7 +590,11 @@ public static void Verify(ProjectWhenElement viewXml, ProjectWhenElement realXml
 
         public static void Verify(ProjectOtherwiseElement viewXml, ProjectOtherwiseElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
 
@@ -549,7 +605,11 @@ public static void Verify(ProjectOtherwiseElement viewXml, ProjectOtherwiseEleme
 
         public static void Verify(ProjectExtensionsElement viewXml, ProjectExtensionsElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.Content, viewXml.Content);
@@ -557,7 +617,11 @@ public static void Verify(ProjectExtensionsElement viewXml, ProjectExtensionsEle
 
         public static void Verify(ProjectMetadataElement viewXml, ProjectMetadataElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.Name, viewXml.Name);
@@ -567,7 +631,11 @@ public static void Verify(ProjectMetadataElement viewXml, ProjectMetadataElement
 
         public static void Verify(ProjectTaskElement viewXml, ProjectTaskElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.Name, viewXml.Name);
@@ -627,7 +695,11 @@ public static void Verify(ProjectTaskElement viewXml, ProjectTaskElement realXml
 
         public static void Verify(ProjectOutputElement viewXml, ProjectOutputElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.TaskParameter, viewXml.TaskParameter);
@@ -641,7 +713,10 @@ public static void Verify(ProjectOutputElement viewXml, ProjectOutputElement rea
 
         public static void Verify(ProjectUsingTaskBodyElement viewXml, ProjectUsingTaskBodyElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
 
             VerifyProjectElement(viewXml, realXml, context);
 
@@ -652,7 +727,10 @@ public static void Verify(ProjectUsingTaskBodyElement viewXml, ProjectUsingTaskB
 
         public static void Verify(ProjectUsingTaskParameterElement viewXml, ProjectUsingTaskParameterElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
 
             VerifyProjectElement(viewXml, realXml, context);
 
@@ -667,7 +745,10 @@ public static void Verify(ProjectUsingTaskParameterElement viewXml, ProjectUsing
 
         public static void Verify(UsingTaskParameterGroupElement viewXml, UsingTaskParameterGroupElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
 
             VerifyProjectElement(viewXml, realXml, context);
 
@@ -676,7 +757,11 @@ public static void Verify(UsingTaskParameterGroupElement viewXml, UsingTaskParam
 
         public static void Verify(ProjectUsingTaskElement viewXml, ProjectUsingTaskElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
 
@@ -704,7 +789,11 @@ public static void Verify(ProjectUsingTaskElement viewXml, ProjectUsingTaskEleme
 
         public static void Verify(ProjectTargetElement viewXml, ProjectTargetElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
 
@@ -733,7 +822,11 @@ public static void Verify(ProjectTargetElement viewXml, ProjectTargetElement rea
 
         public static void Verify(ProjectImportElement viewXml, ProjectImportElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
 
@@ -752,7 +845,11 @@ public static void Verify(ProjectImportElement viewXml, ProjectImportElement rea
 
         public static void Verify(ProjectImportGroupElement viewXml, ProjectImportGroupElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             ViewValidation.Verify(viewXml.Imports, realXml.Imports, ViewValidation.Verify, context);
@@ -760,7 +857,11 @@ public static void Verify(ProjectImportGroupElement viewXml, ProjectImportGroupE
 
         public static void Verify(ProjectItemDefinitionElement viewXml, ProjectItemDefinitionElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.ItemType, viewXml.ItemType);
@@ -769,7 +870,11 @@ public static void Verify(ProjectItemDefinitionElement viewXml, ProjectItemDefin
 
         public static void Verify(ProjectItemDefinitionGroupElement viewXml, ProjectItemDefinitionGroupElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             ViewValidation.Verify(viewXml.ItemDefinitions, realXml.ItemDefinitions, ViewValidation.Verify, context);
@@ -777,7 +882,11 @@ public static void Verify(ProjectItemDefinitionGroupElement viewXml, ProjectItem
 
         public static void Verify(ProjectItemElement viewXml, ProjectItemElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.ItemType, viewXml.ItemType);
@@ -803,7 +912,11 @@ public static void Verify(ProjectItemElement viewXml, ProjectItemElement realXml
 
         public static void Verify(ProjectItemGroupElement viewXml, ProjectItemGroupElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Verify(viewXml.Items, realXml.Items, Verify, context);
@@ -811,7 +924,11 @@ public static void Verify(ProjectItemGroupElement viewXml, ProjectItemGroupEleme
 
         public static void Verify(ProjectPropertyElement viewXml, ProjectPropertyElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.Name, viewXml.Name);
@@ -820,7 +937,11 @@ public static void Verify(ProjectPropertyElement viewXml, ProjectPropertyElement
 
         public static void Verify(ProjectPropertyGroupElement viewXml, ProjectPropertyGroupElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
             Verify(viewXml.Properties, realXml.Properties, Verify, context);
             Verify(viewXml.PropertiesReversed, realXml.PropertiesReversed, Verify, context);
@@ -828,7 +949,11 @@ public static void Verify(ProjectPropertyGroupElement viewXml, ProjectPropertyGr
 
         public static void Verify(ProjectSdkElement viewXml, ProjectSdkElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
             Assert.Equal(realXml.Name, viewXml.Name);
             Assert.Equal(realXml.Version, viewXml.Version);
@@ -837,7 +962,11 @@ public static void Verify(ProjectSdkElement viewXml, ProjectSdkElement realXml,
 
         public static void Verify(ProjectOnErrorElement viewXml, ProjectOnErrorElement realXml, ValidationContext context = null)
         {
-            if (viewXml == null && realXml == null) return;
+            if (viewXml == null && realXml == null)
+            {
+                return;
+            }
+
             VerifyProjectElement(viewXml, realXml, context);
 
             Assert.Equal(realXml.ExecuteTargetsAttribute, viewXml.ExecuteTargetsAttribute);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
index 4e1161c32ab..8a6ca8bd116 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
@@ -121,48 +121,165 @@ private static bool VerifyCheckType<T>(object view, object real, ValidationConte
         // "Slow" Verify, probing all known link types
         public static void VerifyFindType(object view, object real, ValidationContext context = null)
         {
-            if (view == null && real == null) return;
+            if (view == null && real == null)
+            {
+                return;
+            }
+
             VerifyLinkedNotNull(view);
             VerifyNotLinkedNotNull(real);
 
             // construction
-            if (VerifyCheckType<ProjectMetadataElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectChooseElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectWhenElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectOtherwiseElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectTaskElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectOutputElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectUsingTaskBodyElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectUsingTaskParameterElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<UsingTaskParameterGroupElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectUsingTaskElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectTargetElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectRootElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectExtensionsElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectImportElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectImportGroupElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectItemDefinitionElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectItemDefinitionGroupElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectItemElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectItemGroupElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectPropertyElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectPropertyGroupElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectSdkElement>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectOnErrorElement>(view, real, context, Verify)) return;
+            if (VerifyCheckType<ProjectMetadataElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectChooseElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectWhenElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectOtherwiseElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectTaskElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectOutputElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectUsingTaskBodyElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectUsingTaskParameterElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<UsingTaskParameterGroupElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectUsingTaskElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectTargetElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectRootElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectExtensionsElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectImportElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectImportGroupElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectItemDefinitionElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectItemDefinitionGroupElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectItemElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectItemGroupElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectPropertyElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectPropertyGroupElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectSdkElement>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectOnErrorElement>(view, real, context, Verify))
+            {
+                return;
+            }
 
             // evaluation
-            if (VerifyCheckType<ProjectProperty>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectMetadata>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectItemDefinition>(view, real, context, Verify)) return;
-            if (VerifyCheckType<ProjectItem>(view, real, context, Verify)) return;
-            if (VerifyCheckType<Project>(view, real, context, Verify)) return;
+            if (VerifyCheckType<ProjectProperty>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectMetadata>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectItemDefinition>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<ProjectItem>(view, real, context, Verify))
+            {
+                return;
+            }
+
+            if (VerifyCheckType<Project>(view, real, context, Verify))
+            {
+                return;
+            }
 
             throw new NotImplementedException($"Unknown type:{view.GetType().Name}");
         }
 
         public static void VerifyMetadata(IEnumerable<KeyValuePair<string, string>> expected, Func<string, string> getMetadata, Func<string, bool> hasMetadata = null)
         {
-            if (expected == null) return;
+            if (expected == null)
+            {
+                return;
+            }
 
             foreach (var md in expected)
             {
@@ -177,7 +294,11 @@ public static void VerifyMetadata(IEnumerable<KeyValuePair<string, string>> expe
 
         public static void Verify<T>(IEnumerable<T> viewCollection, IEnumerable<T> realCollection, Action<T, T, ValidationContext> validator, ValidationContext context = null)
         {
-            if (viewCollection == null && realCollection == null) return;
+            if (viewCollection == null && realCollection == null)
+            {
+                return;
+            }
+
             Assert.NotNull(viewCollection);
             Assert.NotNull(realCollection);
 
@@ -192,7 +313,11 @@ public static void Verify<T>(IEnumerable<T> viewCollection, IEnumerable<T> realC
 
         public static void Verify<T>(IDictionary<string, T> viewCollection, IDictionary<string, T> realCollection, Action<T, T, ValidationContext> validator, ValidationContext context = null)
         {
-            if (viewCollection == null && realCollection == null) return;
+            if (viewCollection == null && realCollection == null)
+            {
+                return;
+            }
+
             Assert.NotNull(viewCollection);
             Assert.NotNull(realCollection);
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
index ea46c70faa3..9b512430af6 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
@@ -68,7 +68,11 @@ public ProjectItem GetSingleItemWithVerify(ObjectType which, string evaluatedInc
             var viewItems = this.View.GetItemsByEvaluatedInclude(evaluatedInclude);
 
             ViewValidation.Verify(viewItems, realItems, ViewValidation.Verify, new ValidationContext(this));
-            if (viewItems == null || viewItems.Count == 0) return null;
+            if (viewItems == null || viewItems.Count == 0)
+            {
+                return null;
+            }
+
             Assert.Equal(1, viewItems.Count);
             return which == ObjectType.View ? viewItems.First() : realItems.First();
         }
@@ -93,7 +97,11 @@ internal static partial class ViewValidation
     {
         public static void Verify(ProjectProperty view, ProjectProperty real, ValidationContext context)
         {
-            if (view == null && real == null) return;
+            if (view == null && real == null)
+            {
+                return;
+            }
+
             VerifyLinkedNotNull(view);
             VerifyNotLinkedNotNull(real);
 
@@ -121,7 +129,11 @@ public static void Verify(ProjectProperty view, ProjectProperty real, Validation
         // public static void Verify(ProjectMetadata view, ProjectMetadata real) => Verify(view, real, null);
         public static void Verify(ProjectMetadata view, ProjectMetadata real, ValidationContext context)
         {
-            if (view == null && real == null) return;
+            if (view == null && real == null)
+            {
+                return;
+            }
+
             VerifyLinkedNotNull(view);
             VerifyNotLinkedNotNull(real);
 
@@ -150,7 +162,11 @@ public static void Verify(ProjectMetadata view, ProjectMetadata real, Validation
         // public static void Verify(ProjectItemDefinition view, ProjectItemDefinition real) => Verify(view, real, null);
         public static void Verify(ProjectItemDefinition view, ProjectItemDefinition real, ValidationContext context)
         {
-            if (view == null && real == null) return;
+            if (view == null && real == null)
+            {
+                return;
+            }
+
             VerifyLinkedNotNull(view);
             VerifyNotLinkedNotNull(real);
 
@@ -188,7 +204,11 @@ public static void Verify(ProjectItemDefinition view, ProjectItemDefinition real
         // public static void Verify(ProjectItem view, ProjectItem real) => Verify(view, real, null);
         public static void Verify(ProjectItem view, ProjectItem real, ValidationContext context = null)
         {
-            if (view == null && real == null) return;
+            if (view == null && real == null)
+            {
+                return;
+            }
+
             VerifyLinkedNotNull(view);
             VerifyNotLinkedNotNull(real);
 
@@ -234,7 +254,11 @@ public static void Verify(ProjectItem view, ProjectItem real, ValidationContext
 
         private static void Verify(SdkReference view, SdkReference real, ValidationContext context = null)
         {
-            if (view == null && real == null) return;
+            if (view == null && real == null)
+            {
+                return;
+            }
+
             Assert.NotNull(view);
             Assert.NotNull(real);
 
@@ -245,7 +269,11 @@ private static void Verify(SdkReference view, SdkReference real, ValidationConte
 
         private static void Verify(SdkResult view, SdkResult real, ValidationContext context = null)
         {
-            if (view == null && real == null) return;
+            if (view == null && real == null)
+            {
+                return;
+            }
+
             Assert.NotNull(view);
             Assert.NotNull(real);
             Assert.Equal(real.Success, view.Success);
@@ -263,7 +291,11 @@ private static void Verify(ResolvedImport view, ResolvedImport real, ValidationC
 
         private static void Verify(List<string> viewProps, List<string> realProps, ValidationContext context = null)
         {
-            if (viewProps == null && realProps == null) return;
+            if (viewProps == null && realProps == null)
+            {
+                return;
+            }
+
             Assert.NotNull(viewProps);
             Assert.NotNull(realProps);
             Assert.Equal(realProps.Count, viewProps.Count);
@@ -276,14 +308,22 @@ private static void Verify(List<string> viewProps, List<string> realProps, Valid
 
         public static void Verify(Project view, Project real, ValidationContext context = null)
         {
-            if (view == null && real == null) return;
+            if (view == null && real == null)
+            {
+                return;
+            }
+
             var pair = new ProjectPair(view, real);
             Verify(pair, context);
         }
 
         public static void Verify(ProjectPair pair, ValidationContext context = null)
         {
-            if (pair == null) return;
+            if (pair == null)
+            {
+                return;
+            }
+
             var real = pair.Real;
             var view = pair.View;
             context ??= new ValidationContext();
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
index ea551d51ac1..b4548990b32 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
@@ -13,7 +13,10 @@ static class CollectionHelpers
     {
         public static IList<A> ConvertCollection<A,B>(this IEnumerable<B> source, Func<B, A> converter)
         {
-            if (source == null) return null;
+            if (source == null)
+            {
+                return null;
+            }
             // Just copy ...
             List<A> result = new List<A>();
             foreach (var b in source)
@@ -27,7 +30,10 @@ public static IList<A> ConvertCollection<A,B>(this IEnumerable<B> source, Func<B
         public static IList<T> ImportCollection<T>(this ProjectCollectionLinker importer, IEnumerable<MockProjectElementLinkRemoter> source)
             where T : ProjectElement
         {
-            if (source == null) return null;
+            if (source == null)
+            {
+                return null;
+            }
             // Just copy ...
             List<T> result = new List<T>();
             foreach (var sRemoter in source)
@@ -43,7 +49,10 @@ public static IList<T> ImportCollection<T, RMock>(this ProjectCollectionLinker i
             where T : class
             where RMock : MockLinkRemoter<T>, new()
         {
-            if (source == null) return null;
+            if (source == null)
+            {
+                return null;
+            }
             // Just copy ...
             List<T> result = new List<T>();
             foreach (var sRemoter in source)
@@ -58,7 +67,10 @@ public static IList<T> ImportCollection<T, RMock>(this ProjectCollectionLinker i
         public static IList<MockProjectElementLinkRemoter> ExportCollection<T>(this ProjectCollectionLinker exporter, IEnumerable<T> source)
             where T : ProjectElement
         {
-            if (source == null) return null;
+            if (source == null)
+            {
+                return null;
+            }
             // Just copy ...
             List<MockProjectElementLinkRemoter> result = new List<MockProjectElementLinkRemoter>();
             foreach (var s in source)
@@ -73,7 +85,10 @@ public static IList<RMock> ExportCollection<T, RMock>(this ProjectCollectionLink
             where T : class
             where RMock : MockLinkRemoter<T>, new()
         {
-            if (source == null) return null;
+            if (source == null)
+            {
+                return null;
+            }
             // Just copy ...
             List<RMock> result = new List<RMock>();
             foreach (var s in source)
@@ -89,7 +104,10 @@ public static IDictionary<TKey, TValue> ImportDictionary<TKey, TValue, RMock>(th
             where TValue : class
             where RMock : MockLinkRemoter<TValue>, new()
         {
-            if (source == null) return null;
+            if (source == null)
+            {
+                return null;
+            }
             // Just copy ...
             Dictionary<TKey, TValue> result = new Dictionary<TKey, TValue>();
             foreach (var sRemoter in source)
@@ -105,7 +123,10 @@ public static IDictionary<TKey, RMock> ExportDictionary<TKey, TValue, RMock>(thi
             where TValue : class
             where RMock : MockLinkRemoter<TValue>, new()
         {
-            if (source == null) return null;
+            if (source == null)
+            {
+                return null;
+            }
             // Just copy ...
             Dictionary<TKey, RMock> result = new Dictionary<TKey, RMock>();
             foreach (var s in source)
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectMetadataLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectMetadataLink.cs
index 1399fb28746..2427355003a 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectMetadataLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectMetadataLink.cs
@@ -23,7 +23,11 @@ public object Parent
             get
             {
                 var parent = ProjectMetadataLink.GetParent(this.Source);
-                if (parent == null) return null;
+                if (parent == null)
+                {
+                    return null;
+                }
+
                 var itemParent = parent as ProjectItem;
                 if (itemParent != null)
                 {
@@ -58,7 +62,11 @@ public override object Parent
             get
             {
                 var parentRemoter = this.Proxy.Parent;
-                if (parentRemoter == null) return null;
+                if (parentRemoter == null)
+                {
+                    return null;
+                }
+
                 var itemParent = parentRemoter as MockProjectItemLinkRemoter;
                 if (itemParent != null)
                 {
diff --git a/src/Build.OM.UnitTests/TransientIO.cs b/src/Build.OM.UnitTests/TransientIO.cs
index 982474d02ea..d30000833b1 100644
--- a/src/Build.OM.UnitTests/TransientIO.cs
+++ b/src/Build.OM.UnitTests/TransientIO.cs
@@ -45,7 +45,11 @@ private TransientIO(TransientIO parent, string subFolder)
 
         public bool IsControled(string path)
         {
-            if (this.root == null || path == null) return false;
+            if (this.root == null || path == null)
+            {
+                return false;
+            }
+
             var tempRoot = this.RootFolder;
             path = Path.GetFullPath(path);
             return path != null && tempRoot != null
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index c0d9aa78bbc..af7884c0fb4 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -779,9 +779,21 @@ protected bool Equals(BaseClass other)
 
             public override bool Equals(object obj)
             {
-                if (ReferenceEquals(null, obj)) return false;
-                if (ReferenceEquals(this, obj)) return true;
-                if (obj.GetType() != this.GetType()) return false;
+                if (ReferenceEquals(null, obj))
+                {
+                    return false;
+                }
+
+                if (ReferenceEquals(this, obj))
+                {
+                    return true;
+                }
+
+                if (obj.GetType() != this.GetType())
+                {
+                    return false;
+                }
+
                 return Equals((BaseClass) obj);
             }
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index fdaf722b36c..a9ebe2ecba7 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -1575,7 +1575,10 @@ public void CancelledBuild()
         [Fact]
         public void CancelledBuildWithDelay20()
         {
-            if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null) return;
+            if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
+            {
+                return;
+            }
 
             string contents = CleanupFileContents(@"
 <Project xmlns='msbuildnamespace' ToolsVersion='2.0'>
@@ -1611,7 +1614,10 @@ public void CancelledBuildWithDelay20()
         [Fact]
         public void CancelledBuildInTaskHostWithDelay20()
         {
-            if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null) return;
+            if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
+            {
+                return;
+            }
 
             string contents = CleanupFileContents(@"
 <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index e63f9733bec..2d0d4fde76f 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -717,7 +717,9 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
                 resolverContext.Logger.LogMessage("MockSdkResolver1 running", MessageImportance.Normal);
 
                 if (sdk.Name.StartsWith("1"))
+                {
                     return factory.IndicateSuccess("resolverpath1", "version1");
+                }
 
                 return factory.IndicateFailure(new[] { "ERROR1" });
             }
@@ -734,7 +736,9 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
                 resolverContext.Logger.LogMessage("MockSdkResolver2 running", MessageImportance.Normal);
 
                 if (sdk.Name.StartsWith("2"))
+                {
                     return factory.IndicateSuccess("resolverpath2", "version2", new[] {"WARNING2"});
+                }
 
                 return factory.IndicateFailure(new[] {"ERROR2"}, new[] {"WARNING2"});
             }
@@ -751,7 +755,9 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
                 resolverContext.Logger.LogMessage("MockSdkResolverWithResolvableSdkPattern1 running", MessageImportance.Normal);
 
                 if (sdk.Name.StartsWith("11"))
+                {
                     return factory.IndicateSuccess("resolverpathwithresolvablesdkpattern1", "version3");
+                }
 
                 return factory.IndicateFailure(new[] { "ERROR3" });
             }
@@ -768,7 +774,9 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
                 resolverContext.Logger.LogMessage("MockSdkResolverWithResolvableSdkPattern2 running", MessageImportance.Normal);
 
                 if (sdk.Name.StartsWith("2"))
+                {
                     return factory.IndicateSuccess("resolverpathwithresolvablesdkpattern2", "version4", new[] { "WARNING4" });
+                }
 
                 return factory.IndicateFailure(new[] { "ERROR4" }, new[] { "WARNING4" });
             }
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index ae3e2cd371c..188556cb714 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -583,7 +583,10 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
                 // finally clean up
                 foreach (string path in filesToDelete)
                 {
-                    if (File.Exists(path)) File.Delete(path);
+                    if (File.Exists(path))
+                    {
+                        File.Delete(path);
+                    }
                 }
 
                 ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
@@ -898,20 +901,50 @@ bool includeOutput2
                     File.SetLastWriteTime(output2, (DateTime)output2Time);
                 }
 
-                if (includeInput1) inputs.Add(input1);
-                if (includeInput2) inputs.Add(input2);
-                if (includeOutput1) outputs.Add(output1);
-                if (includeOutput2) outputs.Add(output2);
+                if (includeInput1)
+                {
+                    inputs.Add(input1);
+                }
+
+                if (includeInput2)
+                {
+                    inputs.Add(input2);
+                }
+
+                if (includeOutput1)
+                {
+                    outputs.Add(output1);
+                }
+
+                if (includeOutput2)
+                {
+                    outputs.Add(output2);
+                }
 
                 DependencyAnalysisLogDetail detail;
                 Assert.Equal(expectedAnyOutOfDate, TargetUpToDateChecker.IsAnyOutOfDate(out detail, Directory.GetCurrentDirectory(), inputs, outputs));
             }
             finally
             {
-                if (File.Exists(input1)) File.Delete(input1);
-                if (File.Exists(input2)) File.Delete(input2);
-                if (File.Exists(output1)) File.Delete(output1);
-                if (File.Exists(output2)) File.Delete(output2);
+                if (File.Exists(input1))
+                {
+                    File.Delete(input1);
+                }
+
+                if (File.Exists(input2))
+                {
+                    File.Delete(input2);
+                }
+
+                if (File.Exists(output1))
+                {
+                    File.Delete(output1);
+                }
+
+                if (File.Exists(output2))
+                {
+                    File.Delete(output2);
+                }
             }
         }
 
@@ -1036,9 +1069,20 @@ private void SimpleSymlinkInputCheck(DateTime symlinkWriteTime, DateTime targetW
             }
             finally
             {
-                if (File.Exists(inputTarget)) File.Delete(inputTarget);
-                if (File.Exists(inputSymlink)) File.Delete(inputSymlink);
-                if (File.Exists(outputTarget)) File.Delete(outputTarget);
+                if (File.Exists(inputTarget))
+                {
+                    File.Delete(inputTarget);
+                }
+
+                if (File.Exists(inputSymlink))
+                {
+                    File.Delete(inputSymlink);
+                }
+
+                if (File.Exists(outputTarget))
+                {
+                    File.Delete(outputTarget);
+                }
             }
         }
     }
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index 5622f9e6bf6..2026c5c56e2 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -564,8 +564,15 @@ public void InferEscapedOutputsFromTask()
             }
             finally
             {
-                if (inputFile != null) File.Delete(inputFile);
-                if (outputFile != null) File.Delete(outputFile);
+                if (inputFile != null)
+                {
+                    File.Delete(inputFile);
+                }
+
+                if (outputFile != null)
+                {
+                    File.Delete(outputFile);
+                }
             }
         }
 
@@ -650,8 +657,15 @@ public void FullPathMetadataOnItemUnescaped()
             }
             finally
             {
-                if (File.Exists(projectAbsolutePath)) File.Delete(projectAbsolutePath);
-                if (Directory.Exists(path)) FileUtilities.DeleteWithoutTrailingBackslash(path);
+                if (File.Exists(projectAbsolutePath))
+                {
+                    File.Delete(projectAbsolutePath);
+                }
+
+                if (Directory.Exists(path))
+                {
+                    FileUtilities.DeleteWithoutTrailingBackslash(path);
+                }
             }
         }
 
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 43e9e639f96..ccd370b5e81 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4885,7 +4885,9 @@ private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<Mo
             using (TestEnvironment env = TestEnvironment.Create())
             {
                 if (!string.IsNullOrWhiteSpace(envVarValue))
+                {
                     env.SetEnvironmentVariable("MsBuildLogPropertyTracking", envVarValue);
+                }
 
                 env.SetEnvironmentVariable("DEFINED_ENVIRONMENT_VARIABLE", "It's Defined!");
                 env.SetEnvironmentVariable("DEFINED_ENVIRONMENT_VARIABLE2", "It's also Defined!");
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index 59b589aa3d8..e3787657f65 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -589,18 +589,30 @@ public override string ToString()
             {
                 var result = new StringBuilder(256);
                 if (Mode.HasValue)
+                {
                     result.Append(Mode);
+                }
                 else
+                {
                     result.Append($"{nameof(Mode)}: <null>");
+                }
 
                 result.Append($", {Template}, {nameof(TemplateName)}: {TemplateName}, {nameof(TemplateVersion)}: {TemplateVersion}");
 
                 if (SetNameProperty)
+                {
                     result.Append(", SetName");
+                }
+
                 if (SetVersionProperty)
+                {
                     result.Append(", SetVersion");
+                }
+
                 if (ExpectedSuccess)
+                {
                     result.Append(", ExpectedSuccess");
+                }
 
                 return result.ToString();
             }
@@ -632,15 +644,21 @@ void AddProperty(string name, string value) =>
                 (projectOptions.GlobalProperties ??= new Dictionary<string, string>()).Add(name, value);
 
             if (data.SetNameProperty)
+            {
                 AddProperty(SdkNamePropertyName, SdkName);
+            }
 
             if (data.SetVersionProperty)
+            {
                 AddProperty(SdkVersionPropertyName, SdkExpectedVersion);
+            }
 
             using var xmlReader = XmlReader.Create(new StringReader(projectContents));
 
             if (!data.ExpectedSuccess)
+            {
                 projectOptions.LoadSettings |= ProjectLoadSettings.IgnoreMissingImports;
+            }
 
             var project = Project.FromXmlReader(xmlReader, projectOptions);
 
diff --git a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
index a065e5de133..eec4ca3fb28 100644
--- a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
@@ -413,7 +413,10 @@ public void Dispose()
         {
             foreach (string file in FilesWithExistenceChecks)
             {
-                if (File.Exists(file)) File.Delete(file);
+                if (File.Exists(file))
+                {
+                    File.Delete(file);
+                }
             }
         }
 
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index e7e6db9e2fe..22f7a510ac4 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -67,7 +67,10 @@ public void BasicNoExistingFile()
             }
             finally
             {
-                if (log != null) File.Delete(log);
+                if (log != null)
+                {
+                    File.Delete(log);
+                }
             }
         }
 
@@ -90,7 +93,10 @@ public void InvalidFile()
                 }
                 finally
                 {
-                    if (log != null) File.Delete(log);
+                    if (log != null)
+                    {
+                        File.Delete(log);
+                    }
                 }
             }
            );
@@ -119,7 +125,10 @@ public void SpecificVerbosity()
             }
             finally
             {
-                if (log != null) File.Delete(log);
+                if (log != null)
+                {
+                    File.Delete(log);
+                }
             }
         }
 
@@ -192,7 +201,10 @@ public void InvalidEncoding()
                 }
                 finally
                 {
-                    if (log != null) File.Delete(log);
+                    if (log != null)
+                    {
+                        File.Delete(log);
+                    }
                 }
             }
            );
@@ -218,7 +230,10 @@ public void ValidEncoding()
             }
             finally
             {
-                if (log != null) File.Delete(log);
+                if (log != null)
+                {
+                    File.Delete(log);
+                }
             }
         }
 
@@ -243,7 +258,10 @@ public void ValidEncoding2()
             }
             finally
             {
-                if (log != null) File.Delete(log);
+                if (log != null)
+                {
+                    File.Delete(log);
+                }
             }
         }
 
@@ -285,7 +303,10 @@ public void BasicExistingFileNoAppend()
             }
             finally
             {
-                if (log != null) File.Delete(log);
+                if (log != null)
+                {
+                    File.Delete(log);
+                }
             }
         }
 
@@ -306,7 +327,10 @@ public void BasicExistingFileAppend()
             }
             finally
             {
-                if (log != null) File.Delete(log);
+                if (log != null)
+                {
+                    File.Delete(log);
+                }
             }
         }
 
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index ae6880ac5bd..eb854c275d1 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -72,7 +72,10 @@ public void ErrorPosition()
         /// <param name="lexer"></param>
         private void AdvanceToScannerError(Scanner lexer)
         {
-            while (lexer.Advance() && !lexer.IsNext(Token.TokenType.EndOfInput));
+            while (lexer.Advance() && !lexer.IsNext(Token.TokenType.EndOfInput))
+            {
+                ;
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index a4c0de12aca..7dd16c7d221 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -421,7 +421,10 @@ private async Task<bool> BuildProjectsInParallel(Dictionary<string, string> prop
             var projectToBuildInParallel = projectsToBuildList.ToArray();
 
             // Make the call to build the projects
-            if (projectToBuildInParallel.Length <= 0) return success;
+            if (projectToBuildInParallel.Length <= 0)
+            {
+                return success;
+            }
 
             bool executeResult = await ExecuteTargets
             (
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 3aefd150c03..ab5b1efb4db 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -551,7 +551,9 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
             itemsCount += allAdds?.Count ?? 0;          // Add all the additions
             itemsCount -= allRemoves?.Count ?? 0;       // Remove the removals
             if (itemsCount < 0)
+            {
                 itemsCount = 0;
+            }
 
             // We have adds and/or removes and/or modifies to incorporate.
             // We can't modify the group, because that might
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 0ccdd796da6..96f5e14e981 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -171,7 +171,10 @@ public int GetHashCode(DirectoryInfo value)
 
         private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)
         {
-            if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;
+            if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest))
+            {
+                return false;
+            }
 
             SdkResolverManifest manifest = null;
             try
@@ -213,7 +216,10 @@ private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifes
 
         private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)
         {
-            if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;
+            if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath))
+            {
+                return false;
+            }
 
             manifestsList.Add(new SdkResolverManifest(DisplayName: assemblyPath, Path: assemblyPath, ResolvableSdkRegex: null));
             return true;
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index b581d671b9d..663c824dbfd 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -342,14 +342,20 @@ public T Get(string key)
         public T Get(string key, int index, int length)
         {
             if (length < 0)
+            {
                 throw new ArgumentOutOfRangeException(nameof(length));
+            }
 
             if (index < 0 || index > (key == null ? 0 : key.Length) - length)
+            {
                 throw new ArgumentOutOfRangeException(nameof(index));
+            }
 
             if (_constrainedComparer == null)
+            {
                 throw new InvalidOperationException("Cannot do a constrained lookup on this collection.");
-        
+            }
+
             return GetCore(key, index, length);
         }
 
@@ -595,7 +601,9 @@ public void Add(T item)
         void IDictionary<string, T>.Add(string key, T item)
         {
             if (key != item.Key)
+            {
                 throw new InvalidOperationException();
+            }
 
             AddEvenIfPresent(item);
         }
@@ -988,7 +996,9 @@ public bool SetEquals(IEnumerable<T> other) {
         void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array, int index)
         {
             if (index < 0 || Count > array.Length - index)
+            {
                 throw new ArgumentException("index");
+            }
 
             int i = index;
             foreach (var entry in this)
@@ -1703,7 +1713,9 @@ private int InternalGetHashCode(string item, int index, int length)
         {
             // No need to check for null 'item' as we own all comparers
             if (_constrainedComparer != null)
+            {
                 return _constrainedComparer.GetHashCode(item, index, length) & Lower31BitMask;
+            }
 
             return InternalGetHashCode(item);
         }
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index 0b8916d5f2b..f27a1a95d87 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -544,7 +544,11 @@ internal string GetAttributeValue(string attributeName, bool nullIfNotExists = f
 
         internal string GetAttributeValue(string attributeName, ref string cache)
         {
-            if (cache != null) return cache;
+            if (cache != null)
+            {
+                return cache;
+            }
+
             var value = GetAttributeValue(attributeName, false);
             if (Link == null)
             {
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index 5865039ceff..95da474dceb 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -88,7 +88,11 @@ public string Name
                 if (Link != null) { return TargetLink.Name; }
 
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
-                if (_name != null) return _name;
+                if (_name != null)
+                {
+                    return _name;
+                }
+
                 string unescapedValue = EscapingUtilities.UnescapeAll(GetAttributeValue(XMakeAttributes.name));
                 return _name = unescapedValue;
             }
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index f8f74e0686a..d2e91545918 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -134,10 +134,14 @@ internal string UnexpectedlyFound
         internal bool Advance()
         {
             if (_errorState)
+            {
                 return false;
+            }
 
             if (_lookahead?.IsToken(Token.TokenType.EndOfInput) == true)
+            {
                 return true;
+            }
 
             SkipWhiteSpace();
 
@@ -166,11 +170,17 @@ internal bool Advance()
                         break;
                     case '$':
                         if (!ParseProperty())
+                        {
                             return false;
+                        }
+
                         break;
                     case '%':
                         if (!ParseItemMetadata())
+                        {
                             return false;
+                        }
+
                         break;
                     case '@':
                         int start = _parsePoint;
@@ -186,7 +196,10 @@ internal bool Advance()
                             }
                         }
                         if (!ParseItemList())
+                        {
                             return false;
+                        }
+
                         break;
                     case '!':
                         // negation and not-equal
@@ -253,12 +266,18 @@ internal bool Advance()
                         break;
                     case '\'':
                         if (!ParseQuotedString())
+                        {
                             return false;
+                        }
+
                         break;
                     default:
                         // Simple strings, function calls, decimal numbers, hex numbers
                         if (!ParseRemaining())
+                        {
                             return false;
+                        }
+
                         break;
                 }
             }
@@ -644,12 +663,16 @@ private bool ParseRemaining()
             if (CharacterUtilities.IsNumberStart(_expression[_parsePoint])) // numeric
             {
                 if (!ParseNumeric(start))
+                {
                     return false;
+                }
             }
             else if (CharacterUtilities.IsSimpleStringStart(_expression[_parsePoint])) // simple string (handle 'and' and 'or')
             {
                 if (!ParseSimpleStringOrFunction(start))
+                {
                     return false;
+                }
             }
             else
             {
@@ -742,25 +765,37 @@ private bool ParseNumeric(int start)
         private void SkipWhiteSpace()
         {
             while (_parsePoint < _expression.Length && char.IsWhiteSpace(_expression[_parsePoint]))
+            {
                 _parsePoint++;
+            }
+
             return;
         }
         private void SkipDigits()
         {
             while (_parsePoint < _expression.Length && char.IsDigit(_expression[_parsePoint]))
+            {
                 _parsePoint++;
+            }
+
             return;
         }
         private void SkipHexDigits()
         {
             while (_parsePoint < _expression.Length && CharacterUtilities.IsHexDigit(_expression[_parsePoint]))
+            {
                 _parsePoint++;
+            }
+
             return;
         }
         private void SkipSimpleStringChars()
         {
             while (_parsePoint < _expression.Length && CharacterUtilities.IsSimpleStringChar(_expression[_parsePoint]))
+            {
                 _parsePoint++;
+            }
+
             return;
         }
     }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 59dba0b96ad..3deaa98dbdc 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1648,7 +1648,9 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
                 // In the rare case that the property we've enabled for search paths hasn't been defined
                 // we will skip it, but continue with other paths in the fallback order.
                 if (string.IsNullOrEmpty(extensionPath))
+                {
                     continue;
+                }
 
                 string extensionPathExpanded = _data.ExpandString(extensionPath);
 
@@ -1791,7 +1793,11 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                 // for backward compatibility, we shouldn't change that. But resolvers should be exposed to a string
                 // that's null or a full path, so correct that here.
                 var solutionPath = _data.GetProperty(SolutionProjectGenerator.SolutionPathPropertyName)?.EvaluatedValue;
-                if (solutionPath == "*Undefined*") solutionPath = null;
+                if (solutionPath == "*Undefined*")
+                {
+                    solutionPath = null;
+                }
+
                 var projectPath = _data.GetProperty(ReservedPropertyNames.projectFullPath)?.EvaluatedValue;
 
                 CompareInfo compareInfo = CultureInfo.InvariantCulture.CompareInfo;
@@ -1810,13 +1816,17 @@ static bool HasProperty(string value, CompareInfo compareInfo) =>
                     if (mode != SdkReferencePropertyExpansionMode.NoExpansion)
                     {
                         if (mode == SdkReferencePropertyExpansionMode.DefaultExpand)
+                        {
                             mode = SdkReferencePropertyExpansionMode.ExpandUnescape;
+                        }
 
                         static string EvaluateProperty(string value, IElementLocation location,
                             Expander<P, I> expander, SdkReferencePropertyExpansionMode mode)
                         {
                             if (value == null)
+                            {
                                 return null;
+                            }
 
                             const ExpanderOptions Options = ExpanderOptions.ExpandProperties;
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index cddd1390eda..99d92be2005 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -271,7 +271,9 @@ public ImmutableList<I> GetMatchedItems(ImmutableHashSet<string> globsToIgnore)
                 foreach (ItemData data in GetItemData(globsToIgnore))
                 {
                     if (data.ConditionResult)
+                    {
                         items.Add(data.Item);
+                    }
                 }
 
                 return items.ToImmutable();
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs b/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
index bdb57bf9566..6e8fc5c0349 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
@@ -41,7 +41,9 @@ protected override string NormalizeExpression(string description, EvaluationLoca
             text = text.Replace(Separator, "\\" + Separator);
 
             if (text.Length > 100)
+            {
                 text = text.Remove(100) + "...";
+            }
 
             return '`' + text + '`';
         }
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index b113e73a6ec..1450ecf4e7a 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -165,7 +165,10 @@ private void TrackPropertyRead(string name, P property)
             // MSBuild looks up a property called "InnerBuildProperty". If that isn't present,
             // an empty string is returned and it then attempts to look up the value for that property
             // (which is an empty string). Thus this check.
-            if (string.IsNullOrEmpty(name)) return;
+            if (string.IsNullOrEmpty(name))
+            {
+                return;
+            }
 
             // If a property matches the name of an environment variable, but has NOT been overwritten by a non-environment-variable property
             // track it as an environment variable read.
@@ -185,7 +188,10 @@ private void TrackPropertyRead(string name, P property)
         /// <param name="name">The name of the environment variable read.</param>
         private void TrackEnvironmentVariableRead(string name)
         {
-            if ((_settings & PropertyTrackingSetting.EnvironmentVariableRead) != PropertyTrackingSetting.EnvironmentVariableRead) return;
+            if ((_settings & PropertyTrackingSetting.EnvironmentVariableRead) != PropertyTrackingSetting.EnvironmentVariableRead)
+            {
+                return;
+            }
 
             var args = new EnvironmentVariableReadEventArgs(
                 name,
@@ -201,7 +207,10 @@ private void TrackEnvironmentVariableRead(string name)
         /// <param name="name">The name of the uninitialized property read.</param>
         private void TrackUninitializedPropertyRead(string name)
         {
-            if ((_settings & PropertyTrackingSetting.UninitializedPropertyRead) != PropertyTrackingSetting.UninitializedPropertyRead) return;
+            if ((_settings & PropertyTrackingSetting.UninitializedPropertyRead) != PropertyTrackingSetting.UninitializedPropertyRead)
+            {
+                return;
+            }
 
             var args = new UninitializedPropertyReadEventArgs(
                 name,
@@ -240,7 +249,10 @@ private void TrackPropertyWrite(P predecessor, P property, string location, Prop
         /// <param name="source">The source of the property.</param>
         private void TrackPropertyInitialValueSet(P property, PropertySource source)
         {
-            if ((_settings & PropertyTrackingSetting.PropertyInitialValueSet) != PropertyTrackingSetting.PropertyInitialValueSet) return;
+            if ((_settings & PropertyTrackingSetting.PropertyInitialValueSet) != PropertyTrackingSetting.PropertyInitialValueSet)
+            {
+                return;
+            }
 
             var args = new PropertyInitialValueSetEventArgs(
                     property.Name,
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index d3cb5c170a7..f32a0fa608b 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1680,7 +1680,9 @@ public IEnumerable<ProjectItemInstance> GetItemsByItemTypeAndEvaluatedInclude(st
                 foreach (var item in GetItems(itemType))
                 {
                     if (string.Equals(item.EvaluatedInclude, evaluatedInclude, StringComparison.OrdinalIgnoreCase))
+                    {
                         yield return item;
+                    }
                 }
             }
             else
@@ -1688,7 +1690,9 @@ public IEnumerable<ProjectItemInstance> GetItemsByItemTypeAndEvaluatedInclude(st
                 foreach (var item in GetItemsByEvaluatedInclude(evaluatedInclude))
                 {
                     if (string.Equals(item.ItemType, itemType, StringComparison.OrdinalIgnoreCase))
+                    {
                         yield return item;
+                    }
                 }
             }
         }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 5d5c32727de..9722ff1d00e 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -75,11 +75,17 @@ internal abstract class BaseConsoleLogger : INodeLogger
         /// </summary>
         public void ParseParameters()
         {
-            if (Parameters == null) return;
+            if (Parameters == null)
+            {
+                return;
+            }
 
             foreach (string parameter in Parameters.Split(parameterDelimiters))
             {
-                if (string.IsNullOrWhiteSpace(parameter)) continue;
+                if (string.IsNullOrWhiteSpace(parameter))
+                {
+                    continue;
+                }
 
                 string[] parameterAndValue = parameter.Split(s_parameterValueSplitCharacter);
                 ApplyParameter(parameterAndValue[0], parameterAndValue.Length > 1 ? parameterAndValue[1] : null);
@@ -127,7 +133,10 @@ public int Compare(Object a, Object b)
         internal string IndentString(string s, int indent)
         {
             // It's possible the event has a null message
-            if (s == null) return string.Empty;
+            if (s == null)
+            {
+                return string.Empty;
+            }
 
             // This will never return an empty array.  The returned array will always
             // have at least one non-null element, even if "s" is totally empty.
@@ -578,7 +587,10 @@ internal virtual void OutputProperties(List<DictionaryEntry> list)
         /// </summary>
         internal void WriteItems(SortedList itemTypes)
         {
-            if (Verbosity != LoggerVerbosity.Diagnostic || !showItemAndPropertyList || itemTypes.Count == 0) return;
+            if (Verbosity != LoggerVerbosity.Diagnostic || !showItemAndPropertyList || itemTypes.Count == 0)
+            {
+                return;
+            }
 
             // Write the banner
             setColor(ConsoleColor.Green);
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index d4320ced186..17909615925 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -105,7 +105,10 @@ ColorResetter colorReset
         /// </summary>
         private void InitializeBaseConsoleLogger()
         {
-            if (_consoleLogger != null) return;
+            if (_consoleLogger != null)
+            {
+                return;
+            }
 
             bool useMPLogger = false;
             bool disableConsoleColor = false;
@@ -116,7 +119,10 @@ private void InitializeBaseConsoleLogger()
                 string[] parameterComponents = _parameters.Split(BaseConsoleLogger.parameterDelimiters);
                 foreach (string param in parameterComponents)
                 {
-                    if (param.Length <= 0) continue;
+                    if (param.Length <= 0)
+                    {
+                        continue;
+                    }
 
                     if (string.Equals(param, "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                     {
diff --git a/src/Build/Logging/FancyLogger/ANSIBuilder.cs b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
index 4bd20820b46..733ba1dc241 100644
--- a/src/Build/Logging/FancyLogger/ANSIBuilder.cs
+++ b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
@@ -25,7 +25,10 @@ public static int ANSIBreakpoint(string text, int position)
         }
         public static int ANSIBreakpoint(string text, int position, int initialPosition)
         {
-            if (position >= text.Length) return text.Length;
+            if (position >= text.Length)
+            {
+                return text.Length;
+            }
             int nonAnsiIndex = 0;
             // Match nextMatch = Regex.Match(text, ANSIRegex);
             Match nextMatch = ANSIRegexRegex.Match(text, initialPosition);
@@ -66,7 +69,11 @@ public static string Center(string text)
             {
                 string result = String.Empty;
                 string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth) return text;
+                if (noFormatString.Length > Console.BufferWidth)
+                {
+                    return text;
+                }
+
                 int space = (Console.BufferWidth - noFormatString.Length) / 2;
                 result += new string(' ', space);
                 result += text;
@@ -78,7 +85,11 @@ public static string Right(string text)
             {
                 string result = String.Empty;
                 string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth) return text;
+                if (noFormatString.Length > Console.BufferWidth)
+                {
+                    return text;
+                }
+
                 int space = Console.BufferWidth - noFormatString.Length;
                 result += new string(' ', space);
                 result += text;
@@ -89,7 +100,11 @@ public static string Left(string text)
             {
                 string result = String.Empty;
                 string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth) return text;
+                if (noFormatString.Length > Console.BufferWidth)
+                {
+                    return text;
+                }
+
                 int space = Console.BufferWidth - noFormatString.Length;
                 result += text;
                 result += new string(' ', space);
@@ -101,7 +116,11 @@ public static string SpaceBetween(string leftText, string rightText, int width)
                 string result = String.Empty;
                 string leftNoFormatString = ANSIRemove(leftText);
                 string rightNoFormatString = ANSIRemove(rightText);
-                if (leftNoFormatString.Length + rightNoFormatString.Length > Console.BufferWidth) return leftText + rightText;
+                if (leftNoFormatString.Length + rightNoFormatString.Length > Console.BufferWidth)
+                {
+                    return leftText + rightText;
+                }
+
                 int space = Console.BufferWidth - (leftNoFormatString.Length + rightNoFormatString.Length);
                 result += leftText;
                 result += new string(' ', space - 1);
@@ -302,7 +321,11 @@ public static string SetStop()
 
             public static string ForwardTab(int n)
             {
-                if (n == 0) return "";
+                if (n == 0)
+                {
+                    return "";
+                }
+
                 return String.Format("\x1b[{0}I", n);
             }
 
diff --git a/src/Build/Logging/FancyLogger/FancyLogger.cs b/src/Build/Logging/FancyLogger/FancyLogger.cs
index a364ee13cb9..9aef8862533 100644
--- a/src/Build/Logging/FancyLogger/FancyLogger.cs
+++ b/src/Build/Logging/FancyLogger/FancyLogger.cs
@@ -70,7 +70,10 @@ void Render()
                 Task.Delay((i / 60) * 1_000).ContinueWith((t) =>
                 {
                     // Rerender projects only when needed
-                    foreach (var project in projects) project.Value.Log();
+                    foreach (var project in projects)
+                    {
+                        project.Value.Log();
+                    }
                     // Rerender buffer
                     FancyLoggerBuffer.Render();
                 });
@@ -81,7 +84,10 @@ void Render()
                     switch (key)
                     {
                         case ConsoleKey.UpArrow:
-                            if (FancyLoggerBuffer.TopLineIndex > 0) FancyLoggerBuffer.TopLineIndex--;
+                            if (FancyLoggerBuffer.TopLineIndex > 0)
+                            {
+                                FancyLoggerBuffer.TopLineIndex--;
+                            }
                             FancyLoggerBuffer.ShouldRerender = true;
                             break;
                         case ConsoleKey.DownArrow:
@@ -111,7 +117,10 @@ void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
             // If id already exists...
-            if (projects.ContainsKey(id)) return;
+            if (projects.ContainsKey(id))
+            {
+                return;
+            }
             // Add project
             FancyLoggerProjectNode node = new FancyLoggerProjectNode(e);
             projects[id] = node;
@@ -123,7 +132,10 @@ void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
             // Update line
             node.Finished = true;
             // Log
@@ -135,7 +147,10 @@ void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
             // Update
             node.AddTarget(e);
             // Log
@@ -146,7 +161,10 @@ void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
             // Update
             node.FinishedTargets++;
             // Log
@@ -158,7 +176,10 @@ void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
             // Update
             node.AddTask(e);
             existingTasks++;
@@ -174,10 +195,16 @@ void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
         // Raised messages, warnings and errors
         void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
         {
-            if (e is TaskCommandLineEventArgs) return;
+            if (e is TaskCommandLineEventArgs)
+            {
+                return;
+            }
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
             // Update
             node.AddMessage(e);
             // Log
@@ -188,7 +215,10 @@ void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
             // Update
             node.AddWarning(e);
             // Log
@@ -198,7 +228,10 @@ void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node))
+            {
+                return;
+            }
             // Update
             node.AddError(e);
             // Log
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
index 04923ba5461..4b9e19175b1 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
@@ -23,8 +23,14 @@ public string Text
             {
                 // Set text value and get wrapped lines
                 _text = value;
-                if (ShouldWrapLines) WrappedText = ANSIBuilder.ANSIWrap(value, Console.BufferWidth);
-                else WrappedText = new List<string> { value };
+                if (ShouldWrapLines)
+                {
+                    WrappedText = ANSIBuilder.ANSIWrap(value, Console.BufferWidth);
+                }
+                else
+                {
+                    WrappedText = new List<string> { value };
+                }
                 // Buffer should rerender
                 FancyLoggerBuffer.ShouldRerender = true;
             }
@@ -86,7 +92,11 @@ public static void Terminate()
         #region Rendering
         public static void Render()
         {
-            if (IsTerminated || !ShouldRerender) return;
+            if (IsTerminated || !ShouldRerender)
+            {
+                return;
+            }
+
             ShouldRerender = false;
             Console.Write(
                 // Write header
@@ -95,9 +105,12 @@ public static void Render()
                 // Write footer
                 ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
                 // TODO: Remove and replace with actual footer
-                new string('-', Console.BufferWidth) +$"\nBuild progress: XX%\tTopLineIndex={TopLineIndex}"
-            );
-            if (Lines.Count == 0) return;
+                new string('-', Console.BufferWidth) + $"\nBuild progress: XX%\tTopLineIndex={TopLineIndex}");
+
+            if (Lines.Count == 0)
+            {
+                return;
+            }
 
             // Iterate over lines and display on terminal
             string contents = string.Empty;
@@ -106,17 +119,28 @@ public static void Render()
             foreach (FancyLoggerBufferLine line in Lines)
             {
                 // Continue if accum line count + next lines < scrolling area
-                if (accumulatedLineCount + line.WrappedText.Count < TopLineIndex) {
+                if (accumulatedLineCount + line.WrappedText.Count < TopLineIndex)
+                {
                     accumulatedLineCount += line.WrappedText.Count;
                     continue;
                 }
+
                 // Break if exceeds scrolling area
-                if (accumulatedLineCount - TopLineIndex > ScrollableAreaHeight) break;
-                foreach (string s in line.WrappedText) {
+                if (accumulatedLineCount - TopLineIndex > ScrollableAreaHeight)
+                {
+                    break;
+                }
+
+                foreach (string s in line.WrappedText)
+                {
                     // Get line index relative to scroll area
                     lineIndex = accumulatedLineCount - TopLineIndex;
                     // Print if line in scrolling area
-                    if (lineIndex >= 0 && lineIndex < ScrollableAreaHeight) contents += ANSIBuilder.Cursor.Position(lineIndex + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd() + s;
+                    if (lineIndex >= 0 && lineIndex < ScrollableAreaHeight)
+                    {
+                        contents += ANSIBuilder.Cursor.Position(lineIndex + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd() + s;
+                    }
+
                     accumulatedLineCount++;
                 }
             }
@@ -137,7 +161,11 @@ public static int GetLineIndexById(int lineId)
         public static FancyLoggerBufferLine? GetLineById(int lineId)
         {
             int index = GetLineIndexById(lineId);
-            if (index == -1) return null;
+            if (index == -1)
+            {
+                return null;
+            }
+
             return Lines[index];
         }
         #endregion
@@ -159,7 +187,10 @@ public static int GetLineIndexById(int lineId)
             {
                 // Get line index
                 int lineIndex = GetLineIndexById(lineId);
-                if (lineIndex == -1) return null;
+                if (lineIndex == -1)
+                {
+                    return null;
+                }
                 // Get line end index
                 Lines.Insert(lineIndex, line);
             }
@@ -196,7 +227,10 @@ public static void DeleteLine(int lineId)
         {
             // Get line index
             int lineIndex = GetLineIndexById(lineId);
-            if (lineIndex == -1) return;
+            if (lineIndex == -1)
+            {
+                return;
+            }
             // Delete
             Lines.RemoveAt(lineIndex);
             ShouldRerender = true;
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
index f31f56d213c..57dd32bd9d6 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
@@ -28,7 +28,10 @@ public enum MessageType
         public FancyLoggerMessageNode(LazyFormattedBuildEventArgs args)
         {
             Message = args.Message ?? string.Empty;
-            if (Message.Length > MAX_LENGTH) Message = Message.Substring(0, MAX_LENGTH - 1) + "";
+            if (Message.Length > MAX_LENGTH)
+            {
+                Message = Message.Substring(0, MAX_LENGTH - 1) + "";
+            }
             // Get type
             switch (args)
             {
@@ -73,7 +76,11 @@ public string ToANSIString()
         // TODO: Rename to Log after FancyLogger's API becomes internal
         public void Log()
         {
-            if (Line == null) return;
+            if (Line == null)
+            {
+                return;
+            }
+
             Line.Text = $"     {ToANSIString()}";
         }
     }
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
index 46553f529f2..6bba1fa99f1 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
@@ -59,7 +59,11 @@ public FancyLoggerProjectNode(ProjectStartedEventArgs args)
         // TODO: Rename to Render() after FancyLogger's API becomes internal
         public void Log()
         {
-            if (!ShouldRerender) return;
+            if (!ShouldRerender)
+            {
+                return;
+            }
+
             ShouldRerender = false;
             // Project details
             string lineContents = ANSIBuilder.Alignment.SpaceBetween(
@@ -73,32 +77,67 @@ public void Log()
                 Console.WindowWidth
             );
             // Create or update line
-            if (Line is null) Line = FancyLoggerBuffer.WriteNewLine(lineContents, false);
-            else Line.Text = lineContents;
+            if (Line is null)
+            {
+                Line = FancyLoggerBuffer.WriteNewLine(lineContents, false);
+            }
+            else
+            {
+                Line.Text = lineContents;
+            }
 
             // For finished projects
             if (Finished)
             {
-                if (CurrentTargetLine is not null) FancyLoggerBuffer.DeleteLine(CurrentTargetLine.Id);
+                if (CurrentTargetLine is not null)
+                {
+                    FancyLoggerBuffer.DeleteLine(CurrentTargetLine.Id);
+                }
+
                 foreach (FancyLoggerMessageNode node in AdditionalDetails.ToList())
                 {
                     // Only delete high priority messages
-                    if (node.Type != FancyLoggerMessageNode.MessageType.HighPriorityMessage) continue;
-                    if (node.Line is not null) FancyLoggerBuffer.DeleteLine(node.Line.Id);
+                    if (node.Type != FancyLoggerMessageNode.MessageType.HighPriorityMessage)
+                    {
+                        continue;
+                    }
+
+                    if (node.Line is not null)
+                    {
+                        FancyLoggerBuffer.DeleteLine(node.Line.Id);
+                    }
                 }
             }
 
             // Current target details
-            if (CurrentTargetNode is null) return;
+            if (CurrentTargetNode is null)
+            {
+                return;
+            }
+
             string currentTargetLineContents = $"     {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
-            if (CurrentTargetLine is null) CurrentTargetLine = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
-            else CurrentTargetLine.Text = currentTargetLineContents;
+            if (CurrentTargetLine is null)
+            {
+                CurrentTargetLine = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
+            }
+            else
+            {
+                CurrentTargetLine.Text = currentTargetLineContents;
+            }
 
             // Messages, warnings and errors
             foreach (FancyLoggerMessageNode node in AdditionalDetails)
             {
-                if (Finished && node.Type == FancyLoggerMessageNode.MessageType.HighPriorityMessage) continue;
-                if (node.Line is null) node.Line = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, "Message");
+                if (Finished && node.Type == FancyLoggerMessageNode.MessageType.HighPriorityMessage)
+                {
+                    continue;
+                }
+
+                if (node.Line is null)
+                {
+                    node.Line = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, "Message");
+                }
+
                 node.Log();
             }
         }
@@ -112,12 +151,22 @@ public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)
         {
             // Get target id
             int targetId = args.BuildEventContext!.TargetId;
-            if (CurrentTargetNode?.Id == targetId) return CurrentTargetNode.AddTask(args);
-            else return null;
+            if (CurrentTargetNode?.Id == targetId)
+            {
+                return CurrentTargetNode.AddTask(args);
+            }
+            else
+            {
+                return null;
+            }
         }
         public FancyLoggerMessageNode? AddMessage(BuildMessageEventArgs args)
         {
-            if (args.Importance != MessageImportance.High) return null;
+            if (args.Importance != MessageImportance.High)
+            {
+                return null;
+            }
+
             MessageCount++;
             FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
             AdditionalDetails.Add(node);
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 100370273f7..e48fe99e138 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -163,11 +163,17 @@ public override void Shutdown()
         /// </summary>
         private void ParseFileLoggerParameters()
         {
-            if (Parameters == null) return;
+            if (Parameters == null)
+            {
+                return;
+            }
 
             foreach (string parameter in Parameters.Split(s_fileLoggerParameterDelimiters))
             {
-                if (parameter.Length <= 0) continue;
+                if (parameter.Length <= 0)
+                {
+                    continue;
+                }
 
                 var parameterAndValue = parameter.Split(s_fileLoggerParameterValueSplitCharacter);
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 8d7cf63540a..265d6c3155e 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -224,7 +224,10 @@ public override void BuildStartedHandler(object sender, BuildStartedEventArgs e)
             buildStarted = e.Timestamp;
             _hasBuildStarted = true;
 
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
             {
@@ -345,12 +348,18 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         /// </summary>
         private void ShowFlatErrorWarningSummary()
         {
-            if (warningList.Count == 0 && errorList.Count == 0) return;
+            if (warningList.Count == 0 && errorList.Count == 0)
+            {
+                return;
+            }
 
             // If we're showing only warnings and/or errors, don't summarize.
             // This is the buildc.err case. There's no point summarizing since we'd just 
             // repeat the entire log content again.
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             // Make some effort to distinguish this summary from the output above, since otherwise
             // it's not clear in lower verbosities
@@ -384,12 +393,18 @@ private void ShowFlatErrorWarningSummary()
         /// </summary>
         private void ShowNestedErrorWarningSummary()
         {
-            if (warningList.Count == 0 && errorList.Count == 0) return;
+            if (warningList.Count == 0 && errorList.Count == 0)
+            {
+                return;
+            }
 
             // If we're showing only warnings and/or errors, don't summarize.
             // This is the buildc.err case. There's no point summarizing since we'd just 
             // repeat the entire log content again.
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             if (warningCount > 0)
             {
@@ -720,7 +735,11 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         /// <param name="properties">List of properties</param>
         internal void WriteProperties(BuildEventArgs e, IEnumerable properties)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
+
             var propertyList = ExtractPropertyList(properties);
 
             // if there are no properties to display return out of the method and dont print out anything related to displaying
@@ -783,7 +802,11 @@ internal override void OutputEnvironment(IDictionary<string, string> environment
         /// <param name="items">List of items</param>
         internal void WriteItems(BuildEventArgs e, IEnumerable items)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
+
             SortedList itemList = ExtractItemList(items);
 
             // If there are no Items to display return out of the method and don't print out anything related to displaying
@@ -1099,7 +1122,10 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
         /// </summary>
         public override void MessageHandler(object sender, BuildMessageEventArgs e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
             bool print = false;
@@ -1189,7 +1215,10 @@ public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
 
         private void DisplayDeferredStartedEvents(BuildEventContext e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             // Display any project started events which were deferred until a visible 
             // message from their project is displayed
@@ -1388,7 +1417,10 @@ private void WriteBasedOnPrefix(string nonNullMessage, bool prefixAlreadyWritten
         /// </summary>
         private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             // Get the deferred target started event
             TargetStartedEventMinimumFields targetStartedEvent = _buildEventManager.GetTargetStartedEvent(e);
@@ -1460,7 +1492,10 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
         /// </summary>
         private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             if (!SkipProjectStartedText)
             {
@@ -1530,7 +1565,10 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
         /// </summary>
         public override void CustomEventHandler(object sender, CustomBuildEventArgs e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
             if (IsVerbosityAtLeast(LoggerVerbosity.Detailed))
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index abb9c752d78..a05005b8f8a 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -192,7 +192,10 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         /// </summary>
         private void ShowErrorWarningSummary()
         {
-            if (warningCount == 0 && errorCount == 0) return;
+            if (warningCount == 0 && errorCount == 0)
+            {
+                return;
+            }
 
             // Make some effort to distinguish the summary from the previous output
             WriteNewLine();
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index e8f386c6f61..ec1de582bd3 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -173,7 +173,9 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
                 catch (Exception ex)
                 {
                     if (ExceptionHandling.NotExpectedRegistryException(ex))
+                    {
                         throw;
+                    }
 
                     throw new RegistryException(ex.Message, wrapper.Name + "\\" + keyNames[i], ex);
                 }
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 6877edb8f72..8356633c1d9 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -861,7 +861,9 @@ private bool HasRepairPattern(ProjectImportElement importElement)
                     // $(MSBuildExtensionsPath)\Microsoft.VisualStudio.OfficeTools.targets
                     if (importElement.Project.Equals(XMakeProjectStrings.officeTargetsVS2005Import, StringComparison.OrdinalIgnoreCase)
                         || importElement.Project.Equals(XMakeProjectStrings.officeTargetsVS2005Import2, StringComparison.OrdinalIgnoreCase))
+                    {
                         bHasRepairPattern = true;
+                    }
                 }
             }
 
@@ -1005,10 +1007,14 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
 
             // no other F# imports - do nothing
             if (fsharpTargetsFS10Import == null && fsharpTargetsFS40Import == null && fsharpTargetsFS45Import == null && fsharpTargetsDev11PortableImport == null)
+            {
                 return false;
+            }
 
             if (!actuallyMakeChanges)
+            {
                 return true;
+            }
 
             // both branches adds this elements to the project
             var chooseElement = xmakeProject.CreateChooseElement(); // (1)
@@ -1085,13 +1091,24 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             chooseElement.Parent.InsertAfterChild(dev12PlusImportElement, chooseElement);
 
             if (fsharpTargetsFS10Import != null)
+            {
                 xmakeProject.RemoveChild(fsharpTargetsFS10Import);
+            }
+
             if (fsharpTargetsFS40Import != null)
+            {
                 xmakeProject.RemoveChild(fsharpTargetsFS40Import);
+            }
+
             if (fsharpTargetsFS45Import != null)
+            {
                 xmakeProject.RemoveChild(fsharpTargetsFS45Import);
+            }
+
             if (fsharpTargetsDev11PortableImport != null)
+            {
                 xmakeProject.RemoveChild(fsharpTargetsDev11PortableImport);
+            }
 
             const string ReferenceItemType = "Reference";
 
@@ -2101,7 +2118,9 @@ XmlElementWithLocation      configElement
             if (!string.IsNullOrEmpty(outputPath))
             {
                 if (outputPath[outputPath.Length-1] != Path.DirectorySeparatorChar)
+                {
                     outputPath += Path.DirectorySeparatorChar;
+                }
 
                 configElement.RemoveAttribute(VSProjectAttributes.outputPath);
                 configPropertyGroup.AddProperty(VSProjectAttributes.outputPath, ProjectCollection.Escape(outputPath));
@@ -3342,7 +3361,9 @@ private bool IsFilePresentButEmpty(string relPath, string linkPath)
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedException(e))
+                {
                     throw;
+                }
                 // if we can't say for sure it's empty, play safe and return false
                 return false;
             }
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 89ebe3363b9..b743c0bc57f 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -448,7 +448,9 @@ IItemPropertyGrouping insertionPoint
                 ChangePropertyGroupCount(1);
             }
             else if (newGroup is Choose)
+            {
                 this.chooseCount++;
+            }
         }
 
         /// <summary>
@@ -478,7 +480,9 @@ IItemPropertyGrouping newGroup
                 ChangePropertyGroupCount(1);
             }
             else if (newGroup is Choose)
+            {
                 this.chooseCount++;
+            }
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index d8fb84eae17..cb5f3833cec 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -47,7 +47,9 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
                     catch (Exception e) // Catching Exception, but rethrowing unless it's an IO related exception.
                     {
                         if (ExceptionHandling.NotExpectedException(e))
+                        {
                             throw;
+                        }
 
                         // Ignore invalid characters or path related exceptions
 
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index e428728b559..9dfbd1082ba 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -302,7 +302,9 @@ private GenericExpressionNode Factor(string expression)
             {
                 GenericExpressionNode child = Expr(expression);
                 if (Same(expression, Token.TokenType.RightParenthesis))
+                {
                     return child;
+                }
                 else
                 {
                     errorPosition = lexer.GetErrorPosition();
@@ -332,7 +334,9 @@ private GenericExpressionNode Factor(string expression)
         private void Arglist(string expression, ArrayList arglist)
         {
             if (!lexer.IsNext(Token.TokenType.RightParenthesis))
+            {
                 Args(expression, arglist);
+            }
         }
 
         private void Args(string expression, ArrayList arglist)
@@ -393,7 +397,9 @@ private bool Same(string expression, Token.TokenType token)
                 return true;
             }
             else
+            {
                 return false;
+            }
         }
     }
 }
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index 83ae741d5ac..25734ce9a51 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -146,10 +146,14 @@ internal string UnexpectedlyFound
         internal bool Advance()
         {
             if (errorState)
+            {
                 return false;
+            }
 
             if (lookahead?.IsToken(Token.TokenType.EndOfInput) == true)
-                return true;          
+            {
+                return true;
+            }
 
             SkipWhiteSpace();
 
@@ -178,7 +182,10 @@ internal bool Advance()
                         break;
                     case '$':
                         if (!ParseProperty())
+                        {
                             return false;
+                        }
+
                         break;
                     case '%':
                         // If the caller specified that he DOESN'T want to allow item metadata ...
@@ -191,7 +198,10 @@ internal bool Advance()
                             return false;
                         }
                         if (!ParseItemMetadata())
+                        {
                             return false;
+                        }
+
                         break;
                     case '@':
                         int start = this.parsePoint;
@@ -207,7 +217,10 @@ internal bool Advance()
                             }
                         }
                         if (!ParseItemList())
+                        {
                             return false;
+                        }
+
                         break;
                     case '!':
                         // negation and not-equal
@@ -274,12 +287,18 @@ internal bool Advance()
                         break;
                     case '\'':
                         if (!ParseQuotedString())
+                        {
                             return false;
+                        }
+
                         break;
                     default:
                         // Simple strings, function calls, decimal numbers, hex numbers
                         if (!ParseRemaining())
+                        {
                             return false;
+                        }
+
                         break;
                 }
             }
@@ -532,12 +551,16 @@ private bool ParseRemaining()
             if (CharacterUtilities.IsNumberStart(expression[parsePoint])) // numeric
             {
                 if (!ParseNumeric(start))
+                {
                     return false;
+                }
             }
             else if (CharacterUtilities.IsSimpleStringStart(expression[parsePoint])) // simple string (handle 'and' and 'or')
             {
                 if (!ParseSimpleStringOrFunction(start))
+                {
                     return false;
+                }
             }
             else
             {
@@ -622,25 +645,37 @@ private bool ParseNumeric( int start )
         private void SkipWhiteSpace()
         {
             while (parsePoint < expression.Length && char.IsWhiteSpace(expression[parsePoint]))
+            {
                 parsePoint++;
+            }
+
             return;
         }
         private void SkipDigits()
         {
             while (parsePoint < expression.Length && char.IsDigit(expression[parsePoint]))
+            {
                 parsePoint++;
+            }
+
             return;
         }
         private void SkipHexDigits()
         {
             while (parsePoint < expression.Length && CharacterUtilities.IsHexDigit(expression[parsePoint]))
+            {
                 parsePoint++;
+            }
+
             return;
         }
         private void SkipSimpleStringChars()
         {
             while (parsePoint < expression.Length && CharacterUtilities.IsSimpleStringChar(expression[parsePoint]))
+            {
                 parsePoint++;
+            }
+
             return;
         }
     }
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index e0bd956d1c4..392f2f6f042 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -1735,9 +1735,13 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                     if (Engine.debugMode)
                     {
                         if (taskExecutionContext.BuildContext.BuildRequest != null)
+                        {
                             Console.WriteLine("NodeId: " + NodeId + " Got output update " + taskExecutionContext.ParentProject.FullFileName + " HandleId: " + taskExecutionContext.BuildContext.BuildRequest.HandleId + " Time: " + DateTime.Now.ToLongTimeString() + ":" + DateTime.Now.Millisecond);
+                        }
                         else
+                        {
                             Console.WriteLine("NodeId: " + NodeId + " Got output update " + taskExecutionContext.ParentProject.FullFileName + " HandleId: None Time: " + DateTime.Now.ToLongTimeString() + ":" + DateTime.Now.Millisecond);
+                        }
                     }
 
                     // In inproc scenario we may receive a task done notification for a build context
@@ -1752,9 +1756,13 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                         if (Engine.debugMode)
                         {
                             if (taskExecutionContext.BuildContext.BuildRequest != null)
+                            {
                                 Console.WriteLine("Ignoring task output notification. NodeId: " + NodeId + " Got output update " + taskExecutionContext.ParentProject.FullFileName + " HandleId: " + taskExecutionContext.BuildContext.BuildRequest.HandleId);
+                            }
                             else
+                            {
                                 Console.WriteLine("Ignoring task output notification. NodeId: " + NodeId + " Got output update " + taskExecutionContext.ParentProject.FullFileName);
+                            }
                         }
                     }
 
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index 2cd7ba7bcd4..b1d2655ddb3 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -1955,7 +1955,10 @@ private string ExpandSingleMetadata(Match itemMetadataMatch)
         /// </summary>
         private string GetValueFromMetadataTable(string itemType, string metadataName, string metadataValue)
         {
-            if (itemMetadata == null) return null;
+            if (itemMetadata == null)
+            {
+                return null;
+            }
 
             if (implicitMetadataItemType == null)
             {
@@ -1993,7 +1996,10 @@ private string GetValueFromMetadataTable(string itemType, string metadataName, s
         /// </summary>
         private string GetDefaultMetadataValue(string itemType, string metadataName, string metadataValue)
         {
-            if (specificItemDefinitionLibrary == null) return null;
+            if (specificItemDefinitionLibrary == null)
+            {
+                return null;
+            }
 
             if (itemType == null || String.Equals(itemType, specificItemDefinitionLibrary.ItemType, StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 45327c63a75..8be5f2364a0 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -4029,7 +4029,9 @@ bool        importedProject
                 catch (Exception e) // Catching Exception, but rethrowing unless it's an IO related exception.
                 {
                     if (ExceptionHandling.NotExpectedException(e))
+                    {
                         throw;
+                    }
 
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, importElement, "InvalidAttributeValueWithException", importedFilename, XMakeAttributes.project, XMakeElements.import, e.Message);
                 }
@@ -4155,7 +4157,9 @@ private XmlDocument LoadImportedProject(Import import)
                             catch (Exception e)
                             {
                                 if (ExceptionHandling.NotExpectedException(e))
+                                {
                                     throw;
+                                }
 
                                 BuildEventFileInfo fileInfo = new BuildEventFileInfo(import.EvaluatedProjectPath);
                                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false,
diff --git a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
index b0a635794c7..2d07eef45b4 100644
--- a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
+++ b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
@@ -75,7 +75,9 @@ public virtual string Name
                 catch (Exception ex)
                 {
                     if (NotExpectedException(ex))
+                    {
                         throw;
+                    }
 
                     throw new RegistryException(ex.Message, ex);
                 }
@@ -96,7 +98,9 @@ public virtual object GetValue(string name)
             catch (Exception ex)
             {
                 if (NotExpectedException(ex))
+                {
                     throw;
+                }
 
                 throw new RegistryException(ex.Message, Name + "@" + name, ex);
             }
@@ -115,7 +119,9 @@ public virtual string[] GetValueNames()
             catch (Exception ex)
             {
                 if (NotExpectedException(ex))
+                {
                     throw;
+                }
 
                 throw new RegistryException(ex.Message, Name, ex);
             }
@@ -134,7 +140,9 @@ public virtual string[] GetSubKeyNames()
             catch (Exception ex)
             {
                 if (NotExpectedException(ex))
+                {
                     throw;
+                }
 
                 throw new RegistryException(ex.Message, Name, ex);
             }
@@ -162,7 +170,9 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
                 catch (Exception ex)
                 {
                     if (NotExpectedException(ex))
+                    {
                         throw;
+                    }
 
                     throw new RegistryException(ex.Message, wrapper.Name + "\\" + keyNames[i], ex);
                 }
@@ -199,7 +209,9 @@ private RegistryKey WrappedKey
                     catch (Exception ex)
                     {
                         if (NotExpectedException(ex))
+                        {
                             throw;
+                        }
 
                         throw new RegistryException(ex.Message, Name, ex);
                     }
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index 937cd28b801..9d2ecfe4f43 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -842,9 +842,13 @@ private void ProcessTaskOutputs(TaskExecutionContext executionContext)
                                                 howToBuild == DependencyAnalysisResult.IncrementalBuild,
                                                 "We can only see a failure for an execution stage");
                     if (howToBuild != DependencyAnalysisResult.FullBuild)
+                    {
                         howToBuild = DependencyAnalysisResult.SkipUpToDate;
+                    }
                     else
+                    {
                         exitBatchDueToError = true;
+                    }
                 }
             }
 
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index 5f0e47a7c76..44d7273d9ff 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -215,7 +215,9 @@ private AppDomain PrepareAppDomain()
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedReflectionException(e))
+                {
                     throw;
+                }
 
                 // Reflection related exception
                 ProjectErrorUtilities.VerifyThrowInvalidProject(false, taskNode, "TaskInstantiationFailureError", TaskName, TaskClass.Assembly.ToString(), e.Message);
@@ -539,7 +541,9 @@ private ITask InstantiateTask(AppDomain taskAppDomain)
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedReflectionException(e))
+                {
                     throw;
+                }
 
                 // Reflection related exception
                 loggingServices.LogError(buildEventContext, CreateBuildEventFileInfoForTask(),
@@ -666,7 +670,9 @@ private Dictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute()
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedReflectionException(e))
+                {
                     throw;
+                }
 
                 // Reflection related exception
                 loggingServices.LogError(buildEventContext, CreateBuildEventFileInfoForTask(), "AttributeTypeLoadError", TaskName, e.Message);
@@ -961,7 +967,9 @@ internal bool GatherGeneratedTaskOutputs
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedReflectionException(e))
+                {
                     throw;
+                }
 
                 ProjectErrorUtilities.VerifyThrowInvalidProject(false, taskOutputSpecification.TaskParameterAttribute,
                     "FailedToRetrieveTaskOutputs", TaskName, taskParameterName, e.Message);
@@ -1283,7 +1291,9 @@ out bool taskParameterSet
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedReflectionException(e))
+                {
                     throw;
+                }
 
                 // Reflection related exception
                 loggingServices.LogError(buildEventContext, CreateBuildEventFileInfoForTask(), "TaskParametersError", TaskName, e.Message);
@@ -1560,7 +1570,9 @@ object parameterValue
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedReflectionException(e))
+                {
                     throw;
+                }
 
                 loggingServices.LogFatalTaskError(buildEventContext, e,
                     CreateBuildEventFileInfoForTask(),
diff --git a/src/Deprecated/Engine/Engine/TaskRegistry.cs b/src/Deprecated/Engine/Engine/TaskRegistry.cs
index b1c83181b4b..ff97839c4c7 100644
--- a/src/Deprecated/Engine/Engine/TaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/TaskRegistry.cs
@@ -250,7 +250,9 @@ out LoadedType taskClass
                 catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
                 {
                     if (ExceptionHandling.NotExpectedReflectionException(e))
+                    {
                         throw;
+                    }
 
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, taskNode, "TaskLoadFailure", taskName, assembly.ToString(), e.Message);
                 }
diff --git a/src/Deprecated/Engine/Engine/ToolsetReader.cs b/src/Deprecated/Engine/Engine/ToolsetReader.cs
index c952cf4bb5c..e7792858cab 100644
--- a/src/Deprecated/Engine/Engine/ToolsetReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetReader.cs
@@ -222,7 +222,9 @@ private static bool ConfigurationFileMayHaveToolsets()
             catch (Exception e) // Catching Exception, but rethrowing unless it's an IO related exception.
             {
                 if (ExceptionHandling.NotExpectedException(e))
+                {
                     throw;
+                }
 
                 // There was some problem reading the config file: let the configuration reader
                 // encounter it
@@ -464,7 +466,9 @@ private string ExpandRelativePathsRelativeToExeLocation(string path)
             catch (Exception e) // Catching Exception, but rethrowing unless it's an IO related exception.
             {
                 if (ExceptionHandling.NotExpectedException(e))
+                {
                     throw;
+                }
                 // This means that the path looked relative, but was an invalid path. In this case, we'll
                 // just not expand it, and carry on - to be consistent with what happens when there's a
                 // non-relative bin path with invalid characters. The problem will be detected later when
diff --git a/src/Deprecated/Engine/Engine/ToolsetState.cs b/src/Deprecated/Engine/Engine/ToolsetState.cs
index 15436e47e88..c06056b601f 100644
--- a/src/Deprecated/Engine/Engine/ToolsetState.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetState.cs
@@ -204,7 +204,9 @@ private void RegisterDefaultTasks(BuildEventContext buildEventContext)
                     catch (Exception e) // Catching Exception, but rethrowing unless it's an IO related exception.
                     {
                         if (ExceptionHandling.NotExpectedException(e))
+                        {
                             throw;
+                        }
 
                         loggingServices.LogWarning( buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                             "DefaultTasksFileLoadFailureWarning",
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index a8bfd10fa98..969428b2d3b 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -90,7 +90,10 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedException(e))
-                   throw;
+                {
+                    throw;
+                }
+
                 string errorCode;
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, e.Message);
@@ -121,7 +124,10 @@ private void Write(string text)
             catch (Exception ex) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedException(ex))
-                   throw;
+                {
+                    throw;
+                }
+
                 string errorCode;
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, ex.Message);
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 180d133c560..f812a865313 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -187,7 +187,10 @@ public override void BuildStartedHandler(object sender, BuildStartedEventArgs e)
             buildStarted = e.Timestamp;
             hasBuildStarted = true;
 
-            if (showOnlyErrors || showOnlyWarnings) return; 
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
             {
@@ -306,12 +309,18 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         /// </summary>
         private void ShowFlatErrorWarningSummary()
         {
-            if (warningList.Count == 0 && errorList.Count == 0) return;
+            if (warningList.Count == 0 && errorList.Count == 0)
+            {
+                return;
+            }
 
             // If we're showing only warnings and/or errors, don't summarize.
             // This is the buildc.err case. There's no point summarizing since we'd just 
             // repeat the entire log content again.
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             // Make some effort to distinguish this summary from the output above, since otherwise
             // it's not clear in lower verbosities
@@ -345,12 +354,18 @@ private void ShowFlatErrorWarningSummary()
         /// </summary>
         private void ShowNestedErrorWarningSummary()
         {
-            if (warningList.Count == 0 && errorList.Count == 0) return;
+            if (warningList.Count == 0 && errorList.Count == 0)
+            {
+                return;
+            }
 
             // If we're showing only warnings and/or errors, don't summarize.
             // This is the buildc.err case. There's no point summarizing since we'd just 
             // repeat the entire log content again.
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             if (warningCount > 0)
             {
@@ -598,7 +613,11 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         /// <param name="properties">List of properties</param>
         internal void WriteProperties(BuildEventArgs e, IEnumerable properties)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
+
             ArrayList propertyList = ExtractPropertyList(properties);
 
             // if there are no properties to display return out of the method and dont print out anything related to displaying
@@ -636,7 +655,11 @@ internal override void OutputProperties(ArrayList list)
         /// <param name="items">List of items</param>
         internal void WriteItems(BuildEventArgs e, IEnumerable items)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
+
             SortedList itemList = ExtractItemList(items);
   
             // if there are no Items to display return out of the method and dont print out anything related to displaying
@@ -917,7 +940,10 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
         /// </summary>
         public override void MessageHandler(object sender, BuildMessageEventArgs e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
             bool print = false;
@@ -987,7 +1013,10 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
 
         private void DisplayDeferredStartedEvents(BuildEventContext e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             // Display any project started events which were deferred until a visible 
             // message from their project is displayed
@@ -1208,7 +1237,10 @@ private void WriteBasedOnPrefix(string nonNullMessage, bool prefixAlreadyWritten
         /// </summary>
         private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             // Get the deferred target started event
             TargetStartedEventMinimumFields targetStartedEvent = buildEventManager.GetTargetStartedEvent(e);
@@ -1259,7 +1291,10 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
         /// </summary>
         private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             if (!SkipProjectStartedText)
             {
@@ -1327,7 +1362,10 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
         /// </summary>
         public override void CustomEventHandler(object sender, CustomBuildEventArgs e)
         {
-            if (showOnlyErrors || showOnlyWarnings) return;
+            if (showOnlyErrors || showOnlyWarnings)
+            {
+                return;
+            }
 
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
             if (IsVerbosityAtLeast(LoggerVerbosity.Detailed))
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index 7fc7d154a32..319e9e551e2 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -183,7 +183,10 @@ public override void BuildFinishedHandler(object sender, BuildFinishedEventArgs
         /// </summary>
         private void ShowErrorWarningSummary()
         {
-            if (warningCount == 0 && errorCount == 0) return;
+            if (warningCount == 0 && errorCount == 0)
+            {
+                return;
+            }
 
             // Make some effort to distinguish the summary from the previous output
             WriteNewLine();
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index 6d1d947f2e5..d8c445e7665 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -425,7 +425,9 @@ internal void SetValue(string value)
             // NO OP if the value we set is the same we already have
             // This will prevent making the project dirty
             if (value == this.propertyValue)
+            {
                 return;
+            }
 
             // NOTE: allow output properties to be modified -- they're just like normal properties (except for their
             // precedence), and it doesn't really matter if they are modified, since they are transient (virtual)
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index 672eaee766f..13646e3e2a8 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -491,11 +491,20 @@ internal string ImportedFromFilename
             get
             {
                 if (!this.importedFromAnotherProject)
+                {
                     return string.Empty;
+                }
+
                 if (this.importedFromFilename != null)
+                {
                     return this.importedFromFilename;
+                }
+
                 if (this.PropertyGroupElement != null)
+                {
                     return XmlUtilities.GetXmlNodeFile(this.PropertyGroupElement, string.Empty);
+                }
+
                 ErrorUtilities.VerifyThrow(false, "BuildPropertyGroup is imported, doesn't have an ownerDocument, and importedFilename is null.");
                 return string.Empty;
             }
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index a86d5e08b5a..a1e97f9ab46 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -485,7 +485,10 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                 catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
                 {
                     if (ExceptionHandling.NotExpectedException(e))
+                    {
                         throw;
+                    }
+
                     ErrorUtilities.VerifyThrowInvalidOperation(false, "Shared.InvalidFilespecForTransform", modifier, itemSpec, e.Message);
                 }
 
@@ -733,7 +736,9 @@ internal static FileInfo GetFileInfoNoThrow(string filePath)
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
                 if (ExceptionHandling.NotExpectedException(e))
+                {
                     throw;
+                }
 
                 // Invalid or inaccessible path: treat as if nonexistent file, just as File.Exists does
                 return null;
diff --git a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
index 474f6b711d9..22360872b7b 100644
--- a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
@@ -49,7 +49,9 @@ internal bool IncludeInBuild
         static private string RemoveSpaceFromAnyCpuPlatform(string platformName)
         {
             if (string.Equals(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
+            {
                 return "AnyCPU";
+            }
 
             return platformName;
         }
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 7790ff7d26e..8db06ef986b 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -1109,7 +1109,9 @@ internal void ParseSolutionConfigurations()
 
                 //Fixing bug 555577: Solution file can have description information, in which case we ignore.
                 if (String.Equals(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
+                {
                     continue;
+                }
 
                 // Both names must be identical
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(fullConfigurationName == configurationNames[1].Trim(), "SubCategoryForSolutionParsingErrors",
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index 6dc05efbbac..4aacda51882 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -134,7 +134,9 @@ static internal void Generate(SolutionParser solution, Project msbuildProject, s
             catch (Exception ex)
             {
                 if (ExceptionHandling.IsCriticalException(ex))
+                {
                     throw;
+                }
                 // Eat any regular exceptions: we'll just not use the cache
                 parentEngine.LoggingServices.LogComment(projectBuildEventContext, "SolutionCacheReadError", solutionProjectCache, ex.Message);
             }
@@ -160,7 +162,9 @@ private static void UpdateCache(Engine parentEngine, Project msbuildProject, str
             catch (Exception ex)
             {
                 if (ExceptionHandling.IsCriticalException(ex))
+                {
                     throw;
+                }
                 // Eat any regular exceptions: we'll just not use the cache
                 parentEngine.LoggingServices.LogComment(projectBuildEventContext, "SolutionCacheWriteError", solutionProjectCache, ex.Message);
             }
@@ -834,7 +838,9 @@ string projectConfigurationName
                 referenceItemName.ToString(), importLibraryItemName.ToString(), out referenceGuidsToRemove);
 
             if (string.IsNullOrEmpty(referenceGuidsToRemove))
+            {
                 referenceGuidsToRemove = string.Empty;
+            }
 
             string fullProjectPath = null;
             string projectPath = null;
@@ -848,7 +854,9 @@ string projectConfigurationName
             catch (Exception e)
             {
                 if (ExceptionHandling.NotExpectedException(e))
+                {
                     throw;
+                }
 
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false,
                     "SubCategoryForSolutionParsingErrors",
@@ -921,7 +929,9 @@ string subTargetName
             catch (Exception e)
             {
                 if (ExceptionHandling.NotExpectedException(e))
+                {
                     throw;
+                }
 
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false,
                     "SubCategoryForSolutionParsingErrors",
@@ -1195,7 +1205,9 @@ string solutionFile
                 catch (Exception e)
                 {
                     if (ExceptionHandling.NotExpectedException(e))
+                    {
                         throw;
+                    }
 
                     ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false,
                         "SubCategoryForSolutionParsingErrors",
@@ -2080,7 +2092,10 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                     // We don't want any problems scanning the project file to result in aborting the build.
                     catch (Exception e)
                     {
-                        if (ExceptionHandling.IsCriticalException(e)) throw;
+                        if (ExceptionHandling.IsCriticalException(e))
+                        {
+                            throw;
+                        }
 
                         parentEngine.LoggingServices.LogWarning(projectBuildEventContext, "SubCategoryForSolutionParsingErrors", new BuildEventFileInfo(project.RelativePath),
                             "SolutionScanProjectDependenciesFailed", project.RelativePath, e.Message);
@@ -2119,7 +2134,10 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                     // We don't want any problems scanning the project file to result in aborting the build.
                     catch (Exception e)
                     {
-                        if (ExceptionHandling.IsCriticalException(e)) throw;
+                        if (ExceptionHandling.IsCriticalException(e))
+                        {
+                            throw;
+                        }
 
                         parentEngine.LoggingServices.LogWarning(projectBuildEventContext, "SubCategoryForSolutionParsingErrors", new BuildEventFileInfo(project.RelativePath),
                             "SolutionScanProjectDependenciesFailed", project.RelativePath, e.Message);
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index e625642076d..d3d5bd886bd 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -139,7 +139,10 @@ public static CultureInfo[] GetAllCultures()
         /// </summary>
         private static void Initialize()
         {
-            if (s_initialized) return;
+            if (s_initialized)
+            {
+                return;
+            }
 
             s_assemblylocationProperty = typeof(Assembly).GetProperty("Location", typeof(string));
             s_cultureInfoGetCultureMethod = typeof(CultureInfo).GetMethod("GetCultures");
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index dfbe41864a8..17cdbbe64d1 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -692,7 +692,10 @@ internal static bool IsMono
     {
         get
         {
-            if (_isMono != null) return _isMono.Value;
+            if (_isMono != null)
+            {
+                return _isMono.Value;
+            }
 
             lock (IsMonoLock)
             {
diff --git a/src/Framework/ReuseableStringBuilder.cs b/src/Framework/ReuseableStringBuilder.cs
index 924fb0e0071..da50fd42367 100644
--- a/src/Framework/ReuseableStringBuilder.cs
+++ b/src/Framework/ReuseableStringBuilder.cs
@@ -358,11 +358,15 @@ private static int SelectBracketedCapacity(int requiredCapacity)
                 const int minimumCapacity = 0x100; // 256 characters, 512 bytes
 
                 if (requiredCapacity <= minimumCapacity)
+                {
                     return minimumCapacity;
+                }
 
                 // If user wants bigger capacity than maximum respect it as it could be used as buffer in P/Invoke.
                 if (requiredCapacity >= MaxBuilderSizeCapacity)
+                {
                     return requiredCapacity;
+                }
 
                 // Find next power of two http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
                 int v = requiredCapacity;
diff --git a/src/Framework/Sdk/SdkReference.cs b/src/Framework/Sdk/SdkReference.cs
index 6b64974f348..3ea93024a6a 100644
--- a/src/Framework/Sdk/SdkReference.cs
+++ b/src/Framework/Sdk/SdkReference.cs
@@ -53,8 +53,16 @@ public SdkReference(string name, string version, string minimumVersion)
         /// </returns>
         public bool Equals(SdkReference other)
         {
-            if (other is null) return false;
-            if (ReferenceEquals(this, other)) return true;
+            if (other is null)
+            {
+                return false;
+            }
+
+            if (ReferenceEquals(this, other))
+            {
+                return true;
+            }
+
             return string.Equals(Name, other.Name, StringComparison.OrdinalIgnoreCase) &&
                    string.Equals(Version, other.Version, StringComparison.OrdinalIgnoreCase) &&
                    string.Equals(MinimumVersion, other.MinimumVersion, StringComparison.OrdinalIgnoreCase);
@@ -71,12 +79,22 @@ public bool Equals(SdkReference other)
         public static bool TryParse(string sdk, out SdkReference sdkReference)
         {
             sdkReference = null;
-            if (string.IsNullOrWhiteSpace(sdk)) return false;
+            if (string.IsNullOrWhiteSpace(sdk))
+            {
+                return false;
+            }
 
             var parts = sdk.Split(MSBuildConstants.ForwardSlash).Select(i => i.Trim()).ToArray();
 
-            if (parts.Length < 1 || parts.Length > 2) return false;
-            if (string.IsNullOrWhiteSpace(parts[0])) return false;
+            if (parts.Length < 1 || parts.Length > 2)
+            {
+                return false;
+            }
+
+            if (string.IsNullOrWhiteSpace(parts[0]))
+            {
+                return false;
+            }
 
             if (parts.Length == 1 || string.IsNullOrWhiteSpace(parts[1]))
             {
@@ -97,8 +115,16 @@ public static bool TryParse(string sdk, out SdkReference sdkReference)
         /// <inheritdoc />
         public override bool Equals(object obj)
         {
-            if (obj is null) return false;
-            if (ReferenceEquals(this, obj)) return true;
+            if (obj is null)
+            {
+                return false;
+            }
+
+            if (ReferenceEquals(this, obj))
+            {
+                return true;
+            }
+
             return obj is SdkReference && Equals((SdkReference) obj);
         }
 
diff --git a/src/Framework/VisualStudioLocationHelper.cs b/src/Framework/VisualStudioLocationHelper.cs
index be2ec623f5b..75427007b78 100644
--- a/src/Framework/VisualStudioLocationHelper.cs
+++ b/src/Framework/VisualStudioLocationHelper.cs
@@ -42,7 +42,10 @@ internal static IList<VisualStudioInstance> GetInstances()
                 {
                     // Call e.Next to query for the next instance (single item or nothing returned).
                     e.Next(1, instances, out fetched);
-                    if (fetched <= 0) continue;
+                    if (fetched <= 0)
+                    {
+                        continue;
+                    }
 
                     var instance = instances[0];
                     var state = ((ISetupInstance2) instance).GetState();
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 3597bc3fa3d..a3240afba8f 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1028,7 +1028,10 @@ public void InvalidToolsVersionErrors()
                 }
                 finally
                 {
-                    if (File.Exists(filename)) File.Delete(filename);
+                    if (File.Exists(filename))
+                    {
+                        File.Delete(filename);
+                    }
                 }
             }
            );
diff --git a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
index 91839f18a69..509096a06aa 100644
--- a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
+++ b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
@@ -56,7 +56,11 @@ public void VerifyInvalidProjectSchema()
             }
             finally
             {
-                if (projectFilename != null) File.Delete(projectFilename);
+                if (projectFilename != null)
+                {
+                    File.Delete(projectFilename);
+                }
+
                 CleanupSchemaFiles(msbuildTempXsdFilenames);
                 Environment.SetEnvironmentVariable("MSBuildOldOM", oldValueForMSBuildOldOM);
                 Environment.SetEnvironmentVariable("MSBuildLoadMicrosoftTargetsReadOnly", oldValueForMSBuildLoadMicrosoftTargetsReadOnly);
@@ -95,8 +99,16 @@ public void VerifyInvalidSchemaItself1()
             }
             finally
             {
-                if (projectFilename != null) File.Delete(projectFilename);
-                if (invalidSchemaFile != null) File.Delete(invalidSchemaFile);
+                if (projectFilename != null)
+                {
+                    File.Delete(projectFilename);
+                }
+
+                if (invalidSchemaFile != null)
+                {
+                    File.Delete(invalidSchemaFile);
+                }
+
                 Environment.SetEnvironmentVariable("MSBuildOldOM", oldValueForMSBuildOldOM);
                 Environment.SetEnvironmentVariable("MSBuildLoadMicrosoftTargetsReadOnly", oldValueForMSBuildLoadMicrosoftTargetsReadOnly);
             }
@@ -147,8 +159,16 @@ public void VerifyInvalidSchemaItself2()
             }
             finally
             {
-                if (invalidSchemaFile != null) File.Delete(invalidSchemaFile);
-                if (projectFilename != null) File.Delete(projectFilename);
+                if (invalidSchemaFile != null)
+                {
+                    File.Delete(invalidSchemaFile);
+                }
+
+                if (projectFilename != null)
+                {
+                    File.Delete(projectFilename);
+                }
+
                 Environment.SetEnvironmentVariable("MSBuildOldOM", oldValueForMSBuildOldOM);
                 Environment.SetEnvironmentVariable("MSBuildLoadMicrosoftTargetsReadOnly", oldValueForMSBuildLoadMicrosoftTargetsReadOnly);
             }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index cf6ba40db6a..d1934341472 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -3301,7 +3301,10 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
             for (int i = 0; i < groupedFileLoggerParameters.Length; i++)
             {
                 // If we had no, say, "/fl5" then continue; we may have a "/fl6" and so on
-                if (groupedFileLoggerParameters[i] == null) continue;
+                if (groupedFileLoggerParameters[i] == null)
+                {
+                    continue;
+                }
 
                 string fileParameters = "SHOWPROJECTFILE=TRUE;";
                 // Use a default log file name of "msbuild.log", "msbuild1.log", "msbuild2.log", etc; put this first on the parameter
diff --git a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
index a27b5f6dbba..95ed01ea63c 100644
--- a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
+++ b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
@@ -170,7 +170,9 @@ private bool TryAddInternal(TKey key, int hashcode, TValue value, bool updateIfE
                 try
                 {
                     if (acquireLock)
+                    {
                         lockTaken = Monitor.TryEnter(tables._locks[lockNo]);
+                    }
 
                     // If the table just got resized, we may not be holding the right lock, and must retry.
                     // This should be a rare occurrence.
@@ -238,7 +240,9 @@ private bool TryAddInternal(TKey key, int hashcode, TValue value, bool updateIfE
                 finally
                 {
                     if (lockTaken)
+                    {
                         Monitor.Exit(tables._locks[lockNo]);
+                    }
                 }
 
                 //
@@ -281,8 +285,15 @@ private static void ThrowKeyNullException()
         /// if the key was not in the dictionary.</returns>
         public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory)
         {
-            if (key == null) ThrowKeyNullException();
-            if (valueFactory == null) throw new ArgumentNullException(nameof(valueFactory));
+            if (key == null)
+            {
+                ThrowKeyNullException();
+            }
+
+            if (valueFactory == null)
+            {
+                throw new ArgumentNullException(nameof(valueFactory));
+            }
 
             int hashcode = _comparer.GetHashCode(key);
 
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index e67cbcbd153..00108f00b55 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -93,7 +93,9 @@ private static BuildEnvironment Initialize()
             {
                 var env = location();
                 if (env != null)
+                {
                     return env;
+                }
             }
 
             // If we can't find a suitable environment, continue in the 'None' mode. If not running tests,
@@ -135,10 +137,15 @@ private static BuildEnvironment TryFromEnvironmentVariable()
         private static BuildEnvironment TryFromVisualStudioProcess()
         {
             if (!NativeMethodsShared.IsWindows)
+            {
                 return null;
+            }
 
             var vsProcess = s_getProcessFromRunningProcess();
-            if (!IsProcessInList(vsProcess, s_visualStudioProcess)) return null;
+            if (!IsProcessInList(vsProcess, s_visualStudioProcess))
+            {
+                return null;
+            }
 
             var vsRoot = FileUtilities.GetFolderAbove(vsProcess, 3);
             string msBuildExe = GetMSBuildExeFromVsRoot(vsRoot);
@@ -154,7 +161,10 @@ private static BuildEnvironment TryFromVisualStudioProcess()
         private static BuildEnvironment TryFromMSBuildProcess()
         {
             var msBuildExe = s_getProcessFromRunningProcess();
-            if (!IsProcessInList(msBuildExe, s_msBuildProcess)) return null;
+            if (!IsProcessInList(msBuildExe, s_msBuildProcess))
+            {
+                return null;
+            }
 
             // First check if we're in a VS installation
             if (NativeMethodsShared.IsWindows &&
@@ -180,7 +190,10 @@ private static BuildEnvironment TryFromMSBuildProcess()
         private static BuildEnvironment TryFromMSBuildAssembly()
         {
             var buildAssembly = s_getExecutingAssemblyPath();
-            if (buildAssembly == null) return null;
+            if (buildAssembly == null)
+            {
+                return null;
+            }
 
             // Check for MSBuild.[exe|dll] next to the current assembly
             var msBuildExe = Path.Combine(FileUtilities.GetFolderAbove(buildAssembly), "MSBuild.exe");
@@ -195,8 +208,14 @@ private static BuildEnvironment TryFromMSBuildAssembly()
 
             // We're not in VS, check for MSBuild.exe / dll to consider this a standalone environment.
             string msBuildPath = null;
-            if (FileSystems.Default.FileExists(msBuildExe)) msBuildPath = msBuildExe;
-            else if (FileSystems.Default.FileExists(msBuildDll)) msBuildPath = msBuildDll;
+            if (FileSystems.Default.FileExists(msBuildExe))
+            {
+                msBuildPath = msBuildExe;
+            }
+            else if (FileSystems.Default.FileExists(msBuildDll))
+            {
+                msBuildPath = msBuildDll;
+            }
 
             if (!string.IsNullOrEmpty(msBuildPath))
             {
@@ -247,7 +266,10 @@ private static BuildEnvironment TryFromDevConsole()
             var vsVersion = s_getEnvironmentVariable("VisualStudioVersion");
 
             if (string.IsNullOrEmpty(vsInstallDir) || string.IsNullOrEmpty(vsVersion) ||
-                vsVersion != CurrentVisualStudioVersion || !FileSystems.Default.DirectoryExists(vsInstallDir)) return null;
+                vsVersion != CurrentVisualStudioVersion || !FileSystems.Default.DirectoryExists(vsInstallDir))
+            {
+                return null;
+            }
 
             return new BuildEnvironment(
                 BuildEnvironmentMode.VisualStudio,
@@ -271,7 +293,10 @@ private static BuildEnvironment TryFromSetupApi()
                 .Where(i => i.Version.Major == v.Major && FileSystems.Default.DirectoryExists(i.Path))
                 .ToList();
 
-            if (instances.Count == 0) return null;
+            if (instances.Count == 0)
+            {
+                return null;
+            }
 
             if (instances.Count > 1)
             {
@@ -294,7 +319,10 @@ private static BuildEnvironment TryFromAppContextBaseDirectory()
             // but the toolset files are copied to the app's directory via "contentFiles".
 
             var appContextBaseDirectory = s_getAppContextBaseDirectory();
-            if (string.IsNullOrEmpty(appContextBaseDirectory)) return null;
+            if (string.IsNullOrEmpty(appContextBaseDirectory))
+            {
+                return null;
+            }
 
             // Look for possible MSBuild exe names in the AppContextBaseDirectory
             return s_msBuildExeNames
@@ -530,7 +558,9 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
 
             // We can't detect an environment, don't try to set other paths.
             if (mode == BuildEnvironmentMode.None || currentMSBuildExeFile == null || currentToolsDirectory == null)
+            {
                 return;
+            }
 
             var msBuildExeName = currentMSBuildExeFile.Name;
 
diff --git a/src/Shared/EncodingUtilities.cs b/src/Shared/EncodingUtilities.cs
index 40ae3a34e5b..b32122b34f7 100644
--- a/src/Shared/EncodingUtilities.cs
+++ b/src/Shared/EncodingUtilities.cs
@@ -35,7 +35,9 @@ internal static Encoding CurrentSystemOemEncoding
             {
                 // if we already have it, no need to do it again
                 if (s_currentOemEncoding != null)
+                {
                     return s_currentOemEncoding;
+                }
 
                 // fall back to default ANSI encoding if we have problems
 #if FEATURE_ENCODING_DEFAULT
@@ -82,13 +84,19 @@ internal static Encoding CurrentSystemOemEncoding
         internal static bool SimilarToEncoding(this Encoding encoding1, Encoding encoding2)
         {
             if (encoding1 == null)
+            {
                 return encoding2 == null;
+            }
 
             if (encoding2 == null)
+            {
                 return false;
+            }
 
             if (Equals(encoding1, encoding2))
+            {
                 return true;
+            }
 
             return encoding1.EncodingName == encoding2.EncodingName;
         }
@@ -121,7 +129,10 @@ internal static bool StartsWithPreamble(this Stream stream)
         /// <returns>True when the first 3 bytes of the Stream are equal to the preamble.</returns>
         internal static bool StartsWithPreamble(this Stream stream, byte[] preamble)
         {
-            if (preamble == null) return false;
+            if (preamble == null)
+            {
+                return false;
+            }
 
             int bytesRead;
             var buffer = new byte[preamble.Length];
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 63025199472..76175c78e4e 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -376,7 +376,11 @@ internal static String GetDirectoryNameOfFullPath(String fullPath)
             if (fullPath != null)
             {
                 int i = fullPath.Length;
-                while (i > 0 && fullPath[--i] != Path.DirectorySeparatorChar && fullPath[i] != Path.AltDirectorySeparatorChar);
+                while (i > 0 && fullPath[--i] != Path.DirectorySeparatorChar && fullPath[i] != Path.AltDirectorySeparatorChar)
+                {
+                    ;
+                }
+
                 return FixFilePath(fullPath.Substring(0, i));
             }
             return null;
@@ -1098,7 +1102,9 @@ internal static bool IsBinaryLogFilename(string filename)
         private static bool HasExtension(string filename, string extension)
         {
             if (String.IsNullOrEmpty(filename))
+            {
                 return false;
+            }
 
             return filename.EndsWith(extension, PathComparison);
         }
@@ -1231,7 +1237,9 @@ private static bool IsRootedNoThrow(string path)
         internal static string GetFolderAbove(string path, int count = 1)
         {
             if (count < 1)
+            {
                 return path;
+            }
 
             var parent = Directory.GetParent(path);
 
@@ -1358,8 +1366,15 @@ internal static bool PathsEqual(string path1, string path2)
                 }
 
                 // uppercase both chars - notice that we need just one compare per char
-                if ((uint)(charA - 'a') <= (uint)('z' - 'a')) charA -= 0x20;
-                if ((uint)(charB - 'a') <= (uint)('z' - 'a')) charB -= 0x20;
+                if ((uint)(charA - 'a') <= (uint)('z' - 'a'))
+                {
+                    charA -= 0x20;
+                }
+
+                if ((uint)(charB - 'a') <= (uint)('z' - 'a'))
+                {
+                    charB -= 0x20;
+                }
 
                 // Set path delimiters the same
                 if (charA == '\\')
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index bd0bae9633a..02ada21382d 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -235,7 +235,9 @@ private static DT CreateDelegate<DT>(String entryPointName)
                 IntPtr entryPoint = GetProcAddress(s_fileTrackerDllHandle, entryPointName);
 
                 if (IntPtr.Zero == entryPoint)
+                {
                     throw new EntryPointNotFoundException(fileTrackerDllName.Value + "!" + entryPointName);
+                }
 
                 return (DT)(Object)Marshal.GetDelegateForFunctionPointer(entryPoint, typeof(DT));
             }
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index 6850b11f1a2..7aab7c41054 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -117,7 +117,9 @@ public static void TranslateHashSet<T>(
             NodePacketCollectionCreator<HashSet<T>> collectionFactory) where T : class, ITranslatable
         {
             if (!translator.TranslateNullable(hashSet))
+            {
                 return;
+            }
 
             int count = default;
             if (translator.Mode == TranslationDirection.WriteToStream)
@@ -150,7 +152,9 @@ public static void TranslateHashSet<T>(
         public static void Translate(this ITranslator translator, ref CultureInfo cultureInfo)
         {
             if (!translator.TranslateNullable(cultureInfo))
+            {
                 return;
+            }
 
             int lcid = default;
 
@@ -170,7 +174,9 @@ public static void Translate(this ITranslator translator, ref CultureInfo cultur
         public static void Translate(this ITranslator translator, ref Version version)
         {
             if (!translator.TranslateNullable(version))
+            {
                 return;
+            }
 
             int major = 0;
             int minor = 0;
@@ -210,7 +216,9 @@ public static void Translate(this ITranslator translator, ref Version version)
         public static void Translate(this ITranslator translator, ref AssemblyName assemblyName)
         {
             if (!translator.TranslateNullable(assemblyName))
+            {
                 return;
+            }
 
             string name = null;
             Version version = null;
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 006a7b607d8..bf08dd752cf 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -203,7 +203,10 @@ public void GetFileInfoNoThrowBasic()
             }
             finally
             {
-                if (file != null) File.Delete(file);
+                if (file != null)
+                {
+                    File.Delete(file);
+                }
             }
         }
 
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 2f07fca6d10..5af9c7c7abf 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -434,7 +434,10 @@ internal void AssertLogContains(bool isCaseSensitive, params string[] contains)
                     if (currentLine.Contains(comparer))
                     {
                         index++;
-                        if (index == contains.Length) break;
+                        if (index == contains.Length)
+                        {
+                            break;
+                        }
                     }
 
                     currentLine = reader.ReadLine();
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index a8f02e7d2cc..960be527e74 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1042,7 +1042,10 @@ internal static void DeleteTempFiles(string[] files)
         {
             for (int i = 0; i < files.Length; i++)
             {
-                if (FileSystems.Default.FileExists(files[i])) File.Delete(files[i]);
+                if (FileSystems.Default.FileExists(files[i]))
+                {
+                    File.Delete(files[i]);
+                }
             }
         }
 
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 51ea0482d88..0d1a3147432 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -85,11 +85,15 @@ private void Cleanup()
 
                 // Reset test variants
                 foreach (var variant in _variants)
+                {
                     variant.Revert();
+                }
 
                 // Assert invariants
                 foreach (var item in _invariants)
+                {
                     item.AssertInvariant(Output);
+                }
 
                 SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", "");
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
diff --git a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
index dd423c774cb..0d26dd70755 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
@@ -51,7 +51,9 @@ public void ValidFrameworkName(FrameworkName value)
         private ITranslator GetReadTranslator()
         {
             if (_serializationStream == null)
+            {
                 throw new InvalidOperationException("GetWriteTranslator has to be called before GetReadTranslator");
+            }
 
             _serializationStream.Seek(0, SeekOrigin.Begin);
             return BinaryTranslator.GetReadTranslator(_serializationStream, null);
diff --git a/src/Tasks.UnitTests/ComReference_Tests.cs b/src/Tasks.UnitTests/ComReference_Tests.cs
index 855313c7070..6c2f1ed8fc6 100644
--- a/src/Tasks.UnitTests/ComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ComReference_Tests.cs
@@ -20,7 +20,9 @@ private static Dictionary<string, string> ExistingFilesDictionary
             get
             {
                 if (s_existingFiles.Count != 0)
+                {
                     return s_existingFiles;
+                }
 
                 s_existingFiles.Add(@"C:\test\typelib1.dll", string.Empty);
                 s_existingFiles.Add(@"C:\test\typelib2\2.dll", string.Empty);
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index 57d7bc48213..3643e814789 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -68,9 +68,13 @@ internal static int ValidateHasParameter(ToolTaskExtension t, string parameter,
             CommandLineBuilderExtension b = new CommandLineBuilderExtension();
 
             if (useResponseFile)
+            {
                 t.AddResponseFileCommands(b);
+            }
             else
+            {
                 t.AddCommandLineCommands(b);
+            }
 
             string cl = b.ToString();
             string msg = String.Format("Command-line = [{0}]\r\n", cl);
@@ -150,9 +154,13 @@ bool useResponseFile
             CommandLineBuilderExtension b = new CommandLineBuilderExtension();
 
             if (useResponseFile)
+            {
                 t.AddResponseFileCommands(b);
+            }
             else
+            {
                 t.AddCommandLineCommands(b);
+            }
 
             string cl = b.ToString();
 
@@ -197,9 +205,13 @@ internal static void ValidateContains(ToolTaskExtension t, string lookFor, bool
             CommandLineBuilderExtension b = new CommandLineBuilderExtension();
 
             if (useResponseFile)
+            {
                 t.AddResponseFileCommands(b);
+            }
             else
+            {
                 t.AddCommandLineCommands(b);
+            }
 
             string cl = b.ToString();
             string msg = String.Format("Command-line = [{0}]\r\n", cl);
@@ -226,9 +238,13 @@ internal static void ValidateDoesNotContain(ToolTaskExtension t, string lookFor,
             CommandLineBuilderExtension b = new CommandLineBuilderExtension();
 
             if (useResponseFile)
+            {
                 t.AddResponseFileCommands(b);
+            }
             else
+            {
                 t.AddCommandLineCommands(b);
+            }
 
             string cl = b.ToString();
             string msg = String.Format("Command-line = [{0}]\r\n", cl);
@@ -253,9 +269,13 @@ internal static void ValidateEquals(ToolTaskExtension t, string lookFor, bool us
             CommandLineBuilderExtension b = new CommandLineBuilderExtension();
 
             if (useResponseFile)
+            {
                 t.AddResponseFileCommands(b);
+            }
             else
+            {
                 t.AddCommandLineCommands(b);
+            }
 
             string cl = b.ToString();
             string msg = String.Format("Command-line = [{0}]\r\n", cl);
@@ -274,9 +294,13 @@ internal static string GetCommandLine(ToolTaskExtension t, bool useResponseFile)
             CommandLineBuilderExtension b = new CommandLineBuilderExtension();
 
             if (useResponseFile)
+            {
                 t.AddResponseFileCommands(b);
+            }
             else
+            {
                 t.AddCommandLineCommands(b);
+            }
 
             return b.ToString();
         }
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 4477c7e5432..a20b863dfc2 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -510,7 +510,9 @@ public void DoCopyOverDifferentFile()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile)) // HIGHCHAR: Test reads ASCII (not ANSI).
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
@@ -967,7 +969,9 @@ public void DoNotRetryCopyWhenDestinationFileIsFolder()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))   // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
                 ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
@@ -1329,7 +1333,9 @@ public void CopyToDestinationFolder()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 if (!UseHardLinks)
                 {
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index c882200d44e..5d8456902f8 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -316,7 +316,10 @@ public void TempPathContainsAmpersand1()
             finally
             {
                 Environment.SetEnvironmentVariable("TMP", oldTmp);
-                if (Directory.Exists(newTmp)) FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                if (Directory.Exists(newTmp))
+                {
+                    FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                }
             }
         }
 
@@ -351,7 +354,10 @@ public void TempPathContainsAmpersand2()
             finally
             {
                 Environment.SetEnvironmentVariable("TMP", oldTmp);
-                if (Directory.Exists(newTmp)) FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                if (Directory.Exists(newTmp))
+                {
+                    FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                }
             }
         }
 
@@ -385,7 +391,10 @@ public void TempPathContainsAmpersand3()
             finally
             {
                 Environment.SetEnvironmentVariable("TMP", oldTmp);
-                if (Directory.Exists(newTmp)) FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                if (Directory.Exists(newTmp))
+                {
+                    FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                }
             }
         }
 
@@ -419,7 +428,10 @@ public void TempPathContainsAmpersand4()
             finally
             {
                 Environment.SetEnvironmentVariable("TMP", oldTmp);
-                if (Directory.Exists(newTmp)) FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                if (Directory.Exists(newTmp))
+                {
+                    FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                }
             }
         }
 
@@ -561,7 +573,9 @@ private void RunExec(bool includeNonAnsiInCommand, string expectedEncoding, stri
             finally
             {
                 if (Directory.Exists(folder))
+                {
                     FileUtilities.DeleteWithoutTrailingBackslash(folder, true);
+                }
             }
 
             return;
@@ -596,9 +610,13 @@ public void BogusCustomRegexesCauseOneErrorEach()
         {
             Exec exec;
             if (NativeMethodsShared.IsWindows)
+            {
                 exec = PrepareExec("echo Some output & echo Some output & echo Some output & echo Some output ");
+            }
             else
+            {
                 exec = PrepareExec("echo Some output ; echo Some output ; echo Some output ; echo Some output ");
+            }
 
             exec.CustomErrorRegularExpression = "~!@#$%^_)(*&^%$#@@#XF &%^%T$REd((((([[[[";
             exec.CustomWarningRegularExpression = "*";
@@ -615,9 +633,14 @@ public void CustomErrorRegexSupplied()
         {
             string cmdLine;
             if (NativeMethodsShared.IsWindows)
+            {
                 cmdLine = "echo Some output & echo ALERT:This is an error & echo Some more output";
+            }
             else
+            {
                 cmdLine = "echo Some output ; echo ALERT:This is an error ; echo Some more output";
+            }
+
             Exec exec = PrepareExec(cmdLine);
             bool result = exec.Execute();
 
@@ -641,9 +664,13 @@ public void CustomWarningRegexSupplied()
         {
             string cmdLine;
             if (NativeMethodsShared.IsWindows)
+            {
                 cmdLine = "echo Some output & echo YOOHOO:This is a warning & echo Some more output";
+            }
             else
+            {
                 cmdLine = "echo Some output ; echo YOOHOO:This is a warning ; echo Some more output";
+            }
 
             Exec exec = PrepareExec(cmdLine);
             bool result = exec.Execute();
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index adf456748bc..36644689e78 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -26,7 +26,10 @@ public void BasicMove()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
+                {
                     sw.Write("This is a source temp file.");
+                }
+
                 FileInfo file = new FileInfo(sourceFile);
                 file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
@@ -68,7 +71,10 @@ public void BasicMoveOverwriteReadOnlyFilesTrue()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
+                {
                     sw.Write("This is a source temp file.");
+                }
+
                 FileInfo file = new FileInfo(sourceFile);
                 file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
@@ -119,7 +125,9 @@ public void NonexistentSource()
             {
                 File.Delete(sourceFile);
                 using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -139,7 +147,9 @@ public void NonexistentSource()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a destination temp file.", destinationFileContents); // "Expected the destination file to still contain the contents of destination file."
             }
@@ -196,10 +206,14 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -218,7 +232,9 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a destination temp file.", destinationFileContents); // "Expected the destination file to be unchanged."
 
@@ -245,10 +261,14 @@ public void MoveOverExistingFileDestinationWriteable()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -264,7 +284,9 @@ public void MoveOverExistingFileDestinationWriteable()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
             }
@@ -291,10 +313,14 @@ public void MoveOverExistingFileOverwriteReadOnly()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -314,7 +340,9 @@ public void MoveOverExistingFileOverwriteReadOnly()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
@@ -339,10 +367,14 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -362,7 +394,9 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destinationFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
@@ -652,7 +686,9 @@ public void MoveToNonexistentDestinationFolder()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 // Don't create the dest folder, let task do that
 
@@ -671,7 +707,9 @@ public void MoveToNonexistentDestinationFolder()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination file to contain the contents of source file."
 
@@ -753,7 +791,9 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index 49bed4e7b44..2c788d25424 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -30,11 +30,19 @@ static internal ITaskItem CreateReferenceItem(string itemSpec, string projectGui
             TaskItem reference = new TaskItem(itemSpec);
 
             if (projectGuid != null)
+            {
                 reference.SetMetadata(attributeProject, projectGuid);
+            }
+
             if (package != null)
+            {
                 reference.SetMetadata("Package", package);
+            }
+
             if (name != null)
+            {
                 reference.SetMetadata("Name", name);
+            }
 
             return reference;
         }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index dc5742c039b..1a6baec5f1e 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -107,7 +107,9 @@ public void OutputResourceMetadataPopulatedOnInputItems()
             File.Delete(resxFile2);
             File.Delete(resxFile3);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -176,8 +178,15 @@ public void ResX2ResourcesWithReferences()
             finally
             {
                 File.Delete(systemDll);
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
             }
         }
 
@@ -219,7 +228,9 @@ public void BasicResources2ResX()
             File.Delete(t.OutputResources[0].ItemSpec);
             File.Delete(t2a.OutputResources[0].ItemSpec);
             foreach (ITaskItem item in t2b.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -245,7 +256,9 @@ public void BasicResources2Text()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -397,11 +410,30 @@ public void ForceSomeOutOfDate()
             }
             finally
             {
-                if (firstResx != null) File.Delete(firstResx);
-                if (secondResx != null) File.Delete(secondResx);
-                if (cache != null) File.Delete(cache);
-                if (firstResx != null) File.Delete(Path.ChangeExtension(firstResx, ".resources"));
-                if (secondResx != null) File.Delete(Path.ChangeExtension(secondResx, ".resources"));
+                if (firstResx != null)
+                {
+                    File.Delete(firstResx);
+                }
+
+                if (secondResx != null)
+                {
+                    File.Delete(secondResx);
+                }
+
+                if (cache != null)
+                {
+                    File.Delete(cache);
+                }
+
+                if (firstResx != null)
+                {
+                    File.Delete(Path.ChangeExtension(firstResx, ".resources"));
+                }
+
+                if (secondResx != null)
+                {
+                    File.Delete(Path.ChangeExtension(secondResx, ".resources"));
+                }
             }
         }
 
@@ -511,10 +543,25 @@ public void NothingOutOfDate()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (txtFile != null) File.Delete(txtFile);
-                if (resourcesFile1 != null) File.Delete(resourcesFile1);
-                if (resourcesFile2 != null) File.Delete(resourcesFile2);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
+
+                if (resourcesFile1 != null)
+                {
+                    File.Delete(resourcesFile1);
+                }
+
+                if (resourcesFile2 != null)
+                {
+                    File.Delete(resourcesFile2);
+                }
             }
         }
 
@@ -574,10 +621,25 @@ public void NothingOutOfDateExceptReference()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (stateFile != null) File.Delete(stateFile);
-                if (localSystemDll != null) File.Delete(localSystemDll);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (stateFile != null)
+                {
+                    File.Delete(stateFile);
+                }
+
+                if (localSystemDll != null)
+                {
+                    File.Delete(localSystemDll);
+                }
             }
         }
 
@@ -625,10 +687,25 @@ public void NothingOutOfDateExceptAdditionalInput()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
-                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec))
+                {
+                    File.Delete(additionalInputs[0].ItemSpec);
+                }
+
+                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec))
+                {
+                    File.Delete(additionalInputs[1].ItemSpec);
+                }
             }
         }
 
@@ -654,7 +731,9 @@ public void BasicText2ResX()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -698,7 +777,9 @@ public void ResX2ResX()
                 File.Delete(t.OutputResources[0].ItemSpec);
                 File.Delete(t2a.OutputResources[0].ItemSpec);
                 foreach (ITaskItem item in t2b.FilesWritten)
+                {
                     File.Delete(item.ItemSpec);
+                }
             }
             catch (Exception e)
             {
@@ -740,10 +821,15 @@ public void Text2Text()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
+
             File.Delete(t2.Sources[0].ItemSpec);
             foreach (ITaskItem item in t2.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -777,9 +863,13 @@ public void StronglyTypedResources()
 
                 string typeName = null;
                 if (t.StronglyTypedNamespace != null)
+                {
                     typeName = t.StronglyTypedNamespace + ".";
+                }
                 else
+                {
                     typeName = "";
+                }
 
                 typeName += t.StronglyTypedClassName;
 
@@ -832,9 +922,13 @@ public void StronglyTypedResourcesUpToDate()
 
                 string typeName = null;
                 if (t.StronglyTypedNamespace != null)
+                {
                     typeName = t.StronglyTypedNamespace + ".";
+                }
                 else
+                {
                     typeName = "";
+                }
 
                 typeName += t.StronglyTypedClassName;
 
@@ -956,10 +1050,25 @@ public void StronglyTypedResourcesOutOfDate()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (strFile != null) File.Delete(strFile);
-                if (cacheFile != null) File.Delete(cacheFile);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (strFile != null)
+                {
+                    File.Delete(strFile);
+                }
+
+                if (cacheFile != null)
+                {
+                    File.Delete(cacheFile);
+                }
             }
         }
 
@@ -1009,9 +1118,20 @@ public void StronglyTypedResourcesWithFilename()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (strFile != null) File.Delete(strFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (strFile != null)
+                {
+                    File.Delete(strFile);
+                }
             }
         }
 
@@ -1044,9 +1164,13 @@ public void StronglyTypedResourcesVB()
 
                 string typeName = null;
                 if (t.StronglyTypedNamespace != null)
+                {
                     typeName = t.StronglyTypedNamespace + ".";
+                }
                 else
+                {
                     typeName = "";
+                }
 
                 typeName += t.StronglyTypedClassName;
 
@@ -1207,7 +1331,9 @@ public void TextToResourcesBadFormat()
                 // Done, so clean up.
                 File.Delete(t.Sources[0].ItemSpec);
                 foreach (ITaskItem item in t.FilesWritten)
+                {
                     File.Delete(item.ItemSpec);
+                }
             }
 
             // text file uses the strings token; since it's only a warning we have to have special asserts
@@ -1224,7 +1350,9 @@ public void TextToResourcesBadFormat()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1273,10 +1401,25 @@ public void FailedResXReader()
             }
             finally
             {
-                if (resxFile1 != null) File.Delete(resxFile1);
-                if (resxFile2 != null) File.Delete(resxFile2);
-                if (resourcesFile1 != null) File.Delete(resourcesFile1);
-                if (resourcesFile2 != null) File.Delete(resourcesFile2);
+                if (resxFile1 != null)
+                {
+                    File.Delete(resxFile1);
+                }
+
+                if (resxFile2 != null)
+                {
+                    File.Delete(resxFile2);
+                }
+
+                if (resourcesFile1 != null)
+                {
+                    File.Delete(resourcesFile1);
+                }
+
+                if (resourcesFile2 != null)
+                {
+                    File.Delete(resourcesFile2);
+                }
             }
         }
 
@@ -1333,10 +1476,25 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
             }
             finally
             {
-                if (resxFile1 != null) File.Delete(resxFile1);
-                if (resxFile2 != null) File.Delete(resxFile2);
-                if (resourcesFile1 != null) File.Delete(resourcesFile1);
-                if (resourcesFile2 != null) File.Delete(resourcesFile2);
+                if (resxFile1 != null)
+                {
+                    File.Delete(resxFile1);
+                }
+
+                if (resxFile2 != null)
+                {
+                    File.Delete(resxFile2);
+                }
+
+                if (resourcesFile1 != null)
+                {
+                    File.Delete(resourcesFile1);
+                }
+
+                if (resourcesFile2 != null)
+                {
+                    File.Delete(resourcesFile2);
+                }
             }
         }
 
@@ -1361,7 +1519,9 @@ public void DuplicateResourceNames()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1390,7 +1550,9 @@ public void UnsupportedTextType()
             File.Delete(t.Sources[0].ItemSpec);
             File.Delete(bitmap);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1418,8 +1580,15 @@ public void InvalidStateFile()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
             }
         }
 
@@ -1452,7 +1621,9 @@ public void FailedResourceReader()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1483,7 +1654,9 @@ public void FailedSTRProperty()
             File.Delete(t.Sources[0].ItemSpec);
             File.Delete(t.StronglyTypedFileName);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1515,7 +1688,10 @@ public void InvalidReference()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
     }
@@ -1567,7 +1743,9 @@ public void AttributeForwarding()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1595,7 +1773,9 @@ public void AttributeForwardingOnEmptyOutputs()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1624,9 +1804,14 @@ public void OutputFilesNotSpecified()
 
             // Done, so clean up.
             foreach (ITaskItem item in t.Sources)
+            {
                 File.Delete(item.ItemSpec);
+            }
+
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1854,7 +2039,9 @@ public void EmptySources()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -1921,8 +2108,15 @@ public void SourceItemMissing()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
             }
         }
 
@@ -1959,7 +2153,9 @@ public void StateFileUnwritable()
                     foreach (ITaskItem item in t.FilesWritten)
                     {
                         if (item.ItemSpec != null)
+                        {
                             File.Delete(item.ItemSpec);
+                        }
                     }
                 }
             }
@@ -1992,7 +2188,9 @@ public void InputFileExtension()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2024,7 +2222,9 @@ public void OutputFileExtension()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2054,7 +2254,9 @@ public void SourcesMatchesOutputResources()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2086,7 +2288,9 @@ public void UnknownStronglyTypedLanguage()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2119,10 +2323,25 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resxFile2 != null) File.Delete(resxFile2);
-                if (resxFile != null) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
-                if (resxFile2 != null) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resxFile2 != null)
+                {
+                    File.Delete(resxFile2);
+                }
+
+                if (resxFile != null)
+                {
+                    File.Delete(Path.ChangeExtension(resxFile, ".resources"));
+                }
+
+                if (resxFile2 != null)
+                {
+                    File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                }
             }
         }
 
@@ -2165,7 +2384,10 @@ public void BadStronglyTypedFilename()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
 
@@ -2199,7 +2421,10 @@ public void StronglyTypedResourceClassWithoutLanguage()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
 
@@ -2233,7 +2458,10 @@ public void StronglyTypedResourceNamespaceWithoutLanguage()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
 
@@ -2267,7 +2495,10 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
 
@@ -2312,9 +2543,20 @@ public void StronglyTypedResourceFileIsExistingDirectory()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (dir != null) FileUtilities.DeleteWithoutTrailingBackslash(dir);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (dir != null)
+                {
+                    FileUtilities.DeleteWithoutTrailingBackslash(dir);
+                }
             }
         }
 
@@ -2340,7 +2582,10 @@ public void Regress25163_OutputResourcesContainsInvalidPathCharacters()
             }
             finally
             {
-                if (resourcesFile != null) File.Delete(resourcesFile);
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
             }
         }
     }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index aea579d8787..c8b095568d2 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -137,7 +137,9 @@ public void OutputResourceMetadataPopulatedOnInputItems()
             File.Delete(resxFile2);
             File.Delete(resxFile3);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -217,8 +219,15 @@ public void ResX2ResourcesWithReferences()
             finally
             {
                 File.Delete(systemDll);
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
             }
         }
 
@@ -266,7 +275,9 @@ public void BasicResources2ResX()
             File.Delete(t.OutputResources[0].ItemSpec);
             File.Delete(t2a.OutputResources[0].ItemSpec);
             foreach (ITaskItem item in t2b.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -298,7 +309,9 @@ public void BasicResources2Text()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -757,10 +770,25 @@ public void NothingOutOfDate()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (txtFile != null) File.Delete(txtFile);
-                if (resourcesFile1 != null) File.Delete(resourcesFile1);
-                if (resourcesFile2 != null) File.Delete(resourcesFile2);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
+
+                if (resourcesFile1 != null)
+                {
+                    File.Delete(resourcesFile1);
+                }
+
+                if (resourcesFile2 != null)
+                {
+                    File.Delete(resourcesFile2);
+                }
             }
         }
 
@@ -831,10 +859,25 @@ public void NothingOutOfDateExceptReference()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (stateFile != null) File.Delete(stateFile);
-                if (localSystemDll != null) File.Delete(localSystemDll);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (stateFile != null)
+                {
+                    File.Delete(stateFile);
+                }
+
+                if (localSystemDll != null)
+                {
+                    File.Delete(localSystemDll);
+                }
             }
         }
 
@@ -889,10 +932,25 @@ public void NothingOutOfDateExceptAdditionalInput()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
-                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec))
+                {
+                    File.Delete(additionalInputs[0].ItemSpec);
+                }
+
+                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec))
+                {
+                    File.Delete(additionalInputs[1].ItemSpec);
+                }
             }
         }
 
@@ -925,7 +983,9 @@ public void BasicText2ResX()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -971,7 +1031,9 @@ public void ResX2ResX()
             File.Delete(t.OutputResources[0].ItemSpec);
             File.Delete(t2a.OutputResources[0].ItemSpec);
             foreach (ITaskItem item in t2b.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1012,10 +1074,15 @@ public void Text2Text()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
+
             File.Delete(t2.Sources[0].ItemSpec);
             foreach (ITaskItem item in t2.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1052,9 +1119,13 @@ public void StronglyTypedResources()
 
                 string typeName = null;
                 if (t.StronglyTypedNamespace != null)
+                {
                     typeName = t.StronglyTypedNamespace + ".";
+                }
                 else
+                {
                     typeName = "";
+                }
 
                 typeName += t.StronglyTypedClassName;
 
@@ -1112,9 +1183,13 @@ public void StronglyTypedResourcesUpToDate()
 
                 string typeName = null;
                 if (t.StronglyTypedNamespace != null)
+                {
                     typeName = t.StronglyTypedNamespace + ".";
+                }
                 else
+                {
                     typeName = "";
+                }
 
                 typeName += t.StronglyTypedClassName;
 
@@ -1235,9 +1310,20 @@ public void StronglyTypedResourcesOutOfDate()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (strFile != null) File.Delete(strFile);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (strFile != null)
+                {
+                    File.Delete(strFile);
+                }
             }
         }
 
@@ -1290,9 +1376,20 @@ public void StronglyTypedResourcesWithFilename()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (strFile != null) File.Delete(strFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (strFile != null)
+                {
+                    File.Delete(strFile);
+                }
             }
         }
 
@@ -1329,9 +1426,13 @@ public void StronglyTypedResourcesVB()
 
                 string typeName = null;
                 if (t.StronglyTypedNamespace != null)
+                {
                     typeName = t.StronglyTypedNamespace + ".";
+                }
                 else
+                {
                     typeName = "";
+                }
 
                 typeName += t.StronglyTypedClassName;
 
@@ -1554,7 +1655,9 @@ public void TextToResourcesBadFormat()
                 // Done, so clean up.
                 File.Delete(t.Sources[0].ItemSpec);
                 foreach (ITaskItem item in t.FilesWritten)
+                {
                     File.Delete(item.ItemSpec);
+                }
             }
 
             // text file uses the strings token; since it's only a warning we have to have special asserts
@@ -1571,7 +1674,9 @@ public void TextToResourcesBadFormat()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1618,10 +1723,25 @@ public void FailedResXReader()
             }
             finally
             {
-                if (resxFile1 != null) File.Delete(resxFile1);
-                if (resxFile2 != null) File.Delete(resxFile2);
-                if (resourcesFile1 != null) File.Delete(resourcesFile1);
-                if (resourcesFile2 != null) File.Delete(resourcesFile2);
+                if (resxFile1 != null)
+                {
+                    File.Delete(resxFile1);
+                }
+
+                if (resxFile2 != null)
+                {
+                    File.Delete(resxFile2);
+                }
+
+                if (resourcesFile1 != null)
+                {
+                    File.Delete(resourcesFile1);
+                }
+
+                if (resourcesFile2 != null)
+                {
+                    File.Delete(resourcesFile2);
+                }
             }
         }
 
@@ -1675,10 +1795,25 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
             }
             finally
             {
-                if (resxFile1 != null) File.Delete(resxFile1);
-                if (resxFile2 != null) File.Delete(resxFile2);
-                if (resourcesFile1 != null) File.Delete(resourcesFile1);
-                if (resourcesFile2 != null) File.Delete(resourcesFile2);
+                if (resxFile1 != null)
+                {
+                    File.Delete(resxFile1);
+                }
+
+                if (resxFile2 != null)
+                {
+                    File.Delete(resxFile2);
+                }
+
+                if (resourcesFile1 != null)
+                {
+                    File.Delete(resourcesFile1);
+                }
+
+                if (resourcesFile2 != null)
+                {
+                    File.Delete(resourcesFile2);
+                }
             }
         }
 
@@ -1702,7 +1837,9 @@ public void DuplicateResourceNames()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1728,7 +1865,9 @@ public void UnsupportedTextType()
             File.Delete(t.Sources[0].ItemSpec);
             File.Delete(bitmap);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1759,8 +1898,15 @@ public void InvalidStateFile()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
             }
         }
 
@@ -1792,7 +1938,9 @@ public void FailedResourceReader()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         [Theory]
@@ -1848,7 +1996,9 @@ public void FailedSTRProperty()
             File.Delete(t.Sources[0].ItemSpec);
             File.Delete(t.StronglyTypedFileName);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1882,7 +2032,10 @@ public void InvalidReference()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
     }
@@ -1934,7 +2087,9 @@ public void AttributeForwarding()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1962,7 +2117,9 @@ public void AttributeForwardingOnEmptyOutputs()
             // Done, so clean up.
             File.Delete(t.Sources[0].ItemSpec);
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -1991,9 +2148,14 @@ public void OutputFilesNotSpecified()
 
             // Done, so clean up.
             foreach (ITaskItem item in t.Sources)
+            {
                 File.Delete(item.ItemSpec);
+            }
+
             foreach (ITaskItem item in t.FilesWritten)
+            {
                 File.Delete(item.ItemSpec);
+            }
         }
 
         /// <summary>
@@ -2233,7 +2395,9 @@ public void EmptySources()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2297,8 +2461,15 @@ public void SourceItemMissing()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
             }
         }
 
@@ -2333,7 +2504,9 @@ public void StateFileUnwritable()
                     foreach (ITaskItem item in t.FilesWritten)
                     {
                         if (item.ItemSpec != null)
+                        {
                             File.Delete(item.ItemSpec);
+                        }
                     }
                 }
             }
@@ -2365,7 +2538,9 @@ public void InputFileExtension()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2395,7 +2570,9 @@ public void OutputFileExtension()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2425,7 +2602,9 @@ public void SourcesMatchesOutputResources()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2456,7 +2635,9 @@ public void UnknownStronglyTypedLanguage()
                 foreach (ITaskItem item in t.FilesWritten)
                 {
                     if (item.ItemSpec != null)
+                    {
                         File.Delete(item.ItemSpec);
+                    }
                 }
             }
         }
@@ -2489,10 +2670,25 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
             }
             finally
             {
-                if (resxFile != null) File.Delete(resxFile);
-                if (resxFile2 != null) File.Delete(resxFile2);
-                if (resxFile != null) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
-                if (resxFile2 != null) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                if (resxFile != null)
+                {
+                    File.Delete(resxFile);
+                }
+
+                if (resxFile2 != null)
+                {
+                    File.Delete(resxFile2);
+                }
+
+                if (resxFile != null)
+                {
+                    File.Delete(Path.ChangeExtension(resxFile, ".resources"));
+                }
+
+                if (resxFile2 != null)
+                {
+                    File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                }
             }
         }
 
@@ -2529,7 +2725,10 @@ public void BadStronglyTypedFilename()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
 
@@ -2563,7 +2762,10 @@ public void StronglyTypedResourceClassWithoutLanguage()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
 
@@ -2597,7 +2799,10 @@ public void StronglyTypedResourceNamespaceWithoutLanguage()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
 
@@ -2631,7 +2836,10 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
             }
         }
 
@@ -2673,9 +2881,20 @@ public void StronglyTypedResourceFileIsExistingDirectory()
             }
             finally
             {
-                if (txtFile != null) File.Delete(txtFile);
-                if (resourcesFile != null) File.Delete(resourcesFile);
-                if (dir != null) FileUtilities.DeleteWithoutTrailingBackslash(dir);
+                if (txtFile != null)
+                {
+                    File.Delete(txtFile);
+                }
+
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
+
+                if (dir != null)
+                {
+                    FileUtilities.DeleteWithoutTrailingBackslash(dir);
+                }
             }
         }
 
@@ -2702,7 +2921,10 @@ public void Regress25163_OutputResourcesContainsInvalidPathCharacters()
             }
             finally
             {
-                if (resourcesFile != null) File.Delete(resourcesFile);
+                if (resourcesFile != null)
+                {
+                    File.Delete(resourcesFile);
+                }
             }
         }
     }
@@ -3493,9 +3715,13 @@ public static string CreateBasicResourcesFile(bool useResX, ITestOutputHelper ou
 
             string sourceFile;
             if (useResX)
+            {
                 sourceFile = WriteTestResX(false, null, null);
+            }
             else
+            {
                 sourceFile = WriteTestText(null, null);
+            }
 
             t.Sources = new ITaskItem[] { new TaskItem(sourceFile) };
 
@@ -3682,7 +3908,9 @@ public static string GetTestResXContent(bool useType, string linkedBitmap, strin
                 );
 
             if (extraToken != null)
+            {
                 resgenFileContents.Append(extraToken);
+            }
 
             if (useType)
             {
@@ -3865,9 +4093,13 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
 
                 string codeFileExtension = null;
                 if (strLanguage == "CSharp")
+                {
                     codeFileExtension = ".cs";
+                }
                 else if (strLanguage == "VB")
+                {
                     codeFileExtension = ".vb";
+                }
 
                 // Execute task
                 Utilities.ExecuteTask(t);
@@ -3918,9 +4150,13 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
 
                 string typeName;
                 if (t.StronglyTypedNamespace != null)
+                {
                     typeName = t.StronglyTypedNamespace + ".";
+                }
                 else
+                {
                     typeName = "";
+                }
 
                 typeName += t.StronglyTypedClassName;
                 // Verify that the type is generated correctly
diff --git a/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs b/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
index 80b0140226a..824e5507aeb 100644
--- a/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
+++ b/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
@@ -295,7 +295,10 @@ public void CommandLineErrorsReportFullCommandlineAmpersandTemp()
             {
                 Environment.SetEnvironmentVariable("TMP", oldTmp);
                 ObjectModelHelpers.DeleteDirectory(newTmp);
-                if (Directory.Exists(newTmp)) FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                if (Directory.Exists(newTmp))
+                {
+                    FileUtilities.DeleteWithoutTrailingBackslash(newTmp);
+                }
             }
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index a5a8fe5a9f8..d5611e3c4e0 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -93,7 +93,9 @@ public AssemblyFoldersFromConfigResolver(string searchPathElement, GetAssemblyNa
         private void LazyInitialize()
         {
             if (_isInitialized)
+            {
                 return;
+            }
 
             _isInitialized = true;
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 5e5f39a1656..681e34d39e6 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -352,11 +352,17 @@ private FrameworkName GetFrameworkName()
         /// <returns></returns>
         private void CorePopulateMetadata()
         {
-            if (_metadataRead) return;
+            if (_metadataRead)
+            {
+                return;
+            }
 
             lock (this)
             {
-                if (_metadataRead) return;
+                if (_metadataRead)
+                {
+                    return;
+                }
 
                 using (var stream = File.OpenRead(_sourceFile))
                 using (var peFile = new PEReader(stream))
@@ -1093,7 +1099,9 @@ private static uint RvaToOffset(HeaderInfo[] sections, uint rva)
             foreach (var s in sections)
             {
                 if (rva >= s.VirtualAddress && rva < s.VirtualAddress + s.Size)
+                {
                     return s.FileOffset + (rva - s.VirtualAddress);
+                }
             }
             return 0;
         }
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index afeaeb68a3e..53bead5fd07 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -192,7 +192,10 @@ internal static string RetrievePathFromFusionName(string strongName)
 
                 assemblyCache.QueryAssemblyInfo(0, strongName, ref assemblyInfo);
 
-                if (assemblyInfo.cbAssemblyInfo == 0) return null;
+                if (assemblyInfo.cbAssemblyInfo == 0)
+                {
+                    return null;
+                }
 
                 assemblyInfo.pszCurrentAssemblyPathBuf = new string(new char[assemblyInfo.cchBuf]);
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 9dc674cb6ac..76c2088bda6 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1304,7 +1304,9 @@ internal static string ByteArrayToString(byte[] a)
 
             var buffer = new StringBuilder(a.Length * 2);
             for (int i = 0; i < a.Length; ++i)
+            {
                 buffer.Append(a[i].ToString("x2", CultureInfo.InvariantCulture));
+            }
 
             return buffer.ToString();
         }
@@ -2664,10 +2666,14 @@ private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, Fil
         private static IReadOnlyCollection<DependentAssembly> CombineRemappedAssemblies(IReadOnlyCollection<DependentAssembly> first, IReadOnlyCollection<DependentAssembly> second)
         {
             if (first == null)
+            {
                 return second;
+            }
 
             if (second == null)
+            {
                 return first;
+            }
 
             var combined = new List<DependentAssembly>(first.Count + second.Count);
             combined.AddRange(first);
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index ce5faa9fb28..b87ae941577 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -1107,7 +1107,10 @@ private Product CreateProduct(XmlNode node)
                 XmlNode packageFilesNode = node.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":Package/" + BOOTSTRAPPER_PREFIX + ":PackageFiles", _xmlNamespaceManager);
                 string copyAllPackageFiles = String.Empty;
 
-                if (packageFilesNode != null) copyAllPackageFiles = ReadAttribute(packageFilesNode, "CopyAllPackageFiles");
+                if (packageFilesNode != null)
+                {
+                    copyAllPackageFiles = ReadAttribute(packageFilesNode, "CopyAllPackageFiles");
+                }
 
                 product = new Product(node, productCode, results, copyAllPackageFiles);
                 XmlNodeList packageNodeList = node.SelectNodes(BOOTSTRAPPER_PREFIX + ":Package", _xmlNamespaceManager);
@@ -1124,7 +1127,10 @@ private Product CreateProduct(XmlNode node)
             }
 
             if (fPackageAdded)
+            {
                 return product;
+            }
+
             return null;
         }
 
@@ -1625,7 +1631,10 @@ private static void ClearReadOnlyAttribute(string strFileName)
 
         private static string ByteArrayToString(byte[] byteArray)
         {
-            if (byteArray == null) return null;
+            if (byteArray == null)
+            {
+                return null;
+            }
 
             var output = new StringBuilder(byteArray.Length);
             foreach (byte byteValue in byteArray)
@@ -1687,7 +1696,10 @@ private Package GetPackageForSettings(BuildSettings settings, ProductBuilder bui
             if (ci != null)
             {
                 package = builder.Product.Packages.Package(ci.Name);
-                if (package != null) return package;
+                if (package != null)
+                {
+                    return package;
+                }
 
                 // Target culture not found?  Go through the progression of parent cultures (up until but excluding the invariant culture) -> fallback culture -> parent fallback culture -> default culture -> parent default culture -> any culture available
                 // Note: there is no warning if the parent culture of the requested culture is found
@@ -1697,7 +1709,10 @@ private Package GetPackageForSettings(BuildSettings settings, ProductBuilder bui
                 while (parentCulture != CultureInfo.InvariantCulture)
                 {
                     package = GetPackageForSettings_Helper(ci, parentCulture, builder, results, false);
-                    if (package != null) return package;
+                    if (package != null)
+                    {
+                        return package;
+                    }
 
                     parentCulture = parentCulture.Parent;
                 }
@@ -1706,26 +1721,41 @@ private Package GetPackageForSettings(BuildSettings settings, ProductBuilder bui
             if (fallbackCI != null)
             {
                 package = GetPackageForSettings_Helper(ci, fallbackCI, builder, results, true);
-                if (package != null) return package;
+                if (package != null)
+                {
+                    return package;
+                }
 
                 if (!fallbackCI.IsNeutralCulture)
                 {
                     package = GetPackageForSettings_Helper(ci, fallbackCI.Parent, builder, results, true);
-                    if (package != null) return package;
+                    if (package != null)
+                    {
+                        return package;
+                    }
                 }
             }
 
             package = GetPackageForSettings_Helper(ci, Util.DefaultCultureInfo, builder, results, true);
-            if (package != null) return package;
+            if (package != null)
+            {
+                return package;
+            }
 
             if (!Util.DefaultCultureInfo.IsNeutralCulture)
             {
                 package = GetPackageForSettings_Helper(ci, Util.DefaultCultureInfo.Parent, builder, results, true);
-                if (package != null) return package;
+                if (package != null)
+                {
+                    return package;
+                }
             }
 
             if (results != null && ci != null)
+            {
                 results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.UsingProductCulture", ci.Name, builder.Name, builder.Product.Packages.Item(0).Culture));
+            }
+
             return builder.Product.Packages.Item(0);
         }
 
@@ -1806,14 +1836,21 @@ private XmlNode GetResourcesNodeForSettings(BuildSettings settings, BuildResults
             {
                 // Work through the progression of parent cultures (up until but excluding the invariant culture) -> fallback culture -> parent fallback culture -> default culture -> parent default culture -> any available culture
                 cultureNode = GetResourcesNodeForSettings_Helper(ci, ci, results, ref codepage, false);
-                if (cultureNode != null) return cultureNode;
+                if (cultureNode != null)
+                {
+                    return cultureNode;
+                }
+
                 CultureInfo parentCulture = ci.Parent;
 
                 // Keep going up the chain of parents, stopping at the invariant culture
                 while (parentCulture != CultureInfo.InvariantCulture)
                 {
                     cultureNode = GetResourcesNodeForSettings_Helper(ci, parentCulture, results, ref codepage, false);
-                    if (cultureNode != null) return cultureNode;
+                    if (cultureNode != null)
+                    {
+                        return cultureNode;
+                    }
 
                     parentCulture = parentCulture.Parent;
                 }
@@ -1822,22 +1859,34 @@ private XmlNode GetResourcesNodeForSettings(BuildSettings settings, BuildResults
             if (fallbackCI != null)
             {
                 cultureNode = GetResourcesNodeForSettings_Helper(ci, fallbackCI, results, ref codepage, true);
-                if (cultureNode != null) return cultureNode;
+                if (cultureNode != null)
+                {
+                    return cultureNode;
+                }
 
                 if (!fallbackCI.IsNeutralCulture)
                 {
                     cultureNode = GetResourcesNodeForSettings_Helper(ci, fallbackCI.Parent, results, ref codepage, true);
-                    if (cultureNode != null) return cultureNode;
+                    if (cultureNode != null)
+                    {
+                        return cultureNode;
+                    }
                 }
             }
 
             cultureNode = GetResourcesNodeForSettings_Helper(ci, Util.DefaultCultureInfo, results, ref codepage, true);
-            if (cultureNode != null) return cultureNode;
+            if (cultureNode != null)
+            {
+                return cultureNode;
+            }
 
             if (!Util.DefaultCultureInfo.IsNeutralCulture)
             {
                 cultureNode = GetResourcesNodeForSettings_Helper(ci, Util.DefaultCultureInfo.Parent, results, ref codepage, true);
-                if (cultureNode != null) return cultureNode;
+                if (cultureNode != null)
+                {
+                    return cultureNode;
+                }
             }
 
             KeyValuePair<string, XmlNode> altCulturePair = _cultures.FirstOrDefault();
@@ -2173,7 +2222,11 @@ private static void ConvertChildsNodeToAttributes(XmlNode node)
 
         private static string GetLogPath()
         {
-            if (!s_logging) return null;
+            if (!s_logging)
+            {
+                return null;
+            }
+
             string logPath = System.IO.Path.Combine(
                 Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                 @"Microsoft\VisualStudio\" + VisualStudioConstants.CurrentVisualStudioVersion + @"\VSPLOG");
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index a6361b25472..9ee09d26325 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -133,7 +133,10 @@ protected override bool OnManifestLoaded(Manifest manifest)
         protected override bool OnManifestResolved(Manifest manifest)
         {
             if (UseApplicationTrust)
+            {
                 return BuildResolvedSettings(manifest as ApplicationManifest);
+            }
+
             return true;
         }
 
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 5d7ef6a9107..fd9d9387867 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -3132,13 +3132,17 @@ internal void ReadAssemblyResources(String name, String outFileOrDir)
                 {
                     satCulture = assemblyName.CultureInfo;
                     if (!satCulture.Equals(CultureInfo.InvariantCulture))
+                    {
                         expectedExt = '.' + satCulture.Name + ".resources";
+                    }
                 }
 
                 foreach (String resName in resources)
                 {
                     if (!resName.EndsWith(".resources", StringComparison.OrdinalIgnoreCase)) // Skip non-.resources assembly blobs
+                    {
                         continue;
+                    }
 
                     if (mainAssembly)
                     {
@@ -3190,7 +3194,9 @@ internal void ReadAssemblyResources(String name, String outFileOrDir)
                             {
                                 // Remove the culture from the filename
                                 if (reader.outputFileName.EndsWith("." + reader.cultureName, StringComparison.OrdinalIgnoreCase))
+                                {
                                     reader.outputFileName = reader.outputFileName.Remove(reader.outputFileName.Length - (reader.cultureName.Length + 1));
+                                }
                             }
                             _readers.Add(reader);
 
@@ -3234,7 +3240,9 @@ private NeutralResourcesLanguageAttribute CheckAssemblyCultureInfo(String name,
                     neutralResourcesLanguageAttribute = (NeutralResourcesLanguageAttribute)attrs[0];
                     bool fallbackToSatellite = neutralResourcesLanguageAttribute.Location == UltimateResourceFallbackLocation.Satellite;
                     if (!fallbackToSatellite && neutralResourcesLanguageAttribute.Location != UltimateResourceFallbackLocation.MainAssembly)
+                    {
                         _logger.LogWarningWithCodeFromResources(null, name, 0, 0, 0, 0, "GenerateResource.UnrecognizedUltimateResourceFallbackLocation", neutralResourcesLanguageAttribute.Location, name);
+                    }
                     // This MSBuild task needs to not report an error for main assemblies that don't have managed resources.
                 }
             }
@@ -3253,7 +3261,9 @@ private NeutralResourcesLanguageAttribute CheckAssemblyCultureInfo(String name,
                 }
 
                 if (!ContainsProperlyNamedResourcesFiles(a, false))
+                {
                     _logger.LogWarningWithCodeFromResources("GenerateResource.SatelliteAssemblyContainsNoResourcesFile", assemblyName.CultureInfo.Name);
+                }
             }
             return neutralResourcesLanguageAttribute;
         }
@@ -3264,7 +3274,9 @@ private static bool ContainsProperlyNamedResourcesFiles(Assembly a, bool mainAss
             foreach (String manifestResourceName in a.GetManifestResourceNames())
             {
                 if (manifestResourceName.EndsWith(postfix, StringComparison.OrdinalIgnoreCase))
+                {
                     return true;
+                }
             }
 
             return false;
@@ -3575,15 +3587,21 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                     while (ch != '=')
                     {
                         if (ch == '\r' || ch == '\n')
+                        {
                             throw new TextFileException(_logger.FormatResourceString("GenerateResource.NoEqualsInLine", name), fileName, sr.LineNumber, sr.LinePosition);
+                        }
 
                         name.Append((char)ch);
                         ch = sr.Read();
                         if (ch == -1)
+                        {
                             break;
+                        }
                     }
                     if (name.Length == 0)
+                    {
                         throw new TextFileException(_logger.FormatResourceString("GenerateResource.NoNameInLine"), fileName, sr.LineNumber, sr.LinePosition);
+                    }
 
                     // For the INF file, we must allow a space on both sides of the equals
                     // sign.  Deal with it.
@@ -3594,7 +3612,9 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                     ch = sr.Read(); // move past =
                     // If it exists, move past the first space after the equals sign.
                     if (ch == ' ')
+                    {
                         ch = sr.Read();
+                    }
 
                     // Read in value
                     value.Length = 0;
@@ -3633,7 +3653,10 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                                     {
                                         int n = sr.Read(hex, index, numChars);
                                         if (n == 0)
+                                        {
                                             throw new TextFileException(_logger.FormatResourceString("GenerateResource.InvalidEscape", name.ToString(), (char)ch), fileName, sr.LineNumber, sr.LinePosition);
+                                        }
+
                                         index += n;
                                         numChars -= n;
                                     }
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index 237a138dd64..8208fd280b1 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -327,7 +327,9 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
             {
                 res = RmEndSession(handle);
                 if (res != 0)
+                {
                     throw GetException(res, "RmEndSession", "Failed to end the restart manager session.");
+                }
             }
 
             return Enumerable.Empty<ProcessInfo>();
diff --git a/src/Tasks/ManifestUtil/ApplicationIdentity.cs b/src/Tasks/ManifestUtil/ApplicationIdentity.cs
index 8b7aec3900b..30e0f1dd088 100644
--- a/src/Tasks/ManifestUtil/ApplicationIdentity.cs
+++ b/src/Tasks/ManifestUtil/ApplicationIdentity.cs
@@ -54,7 +54,10 @@ public ApplicationIdentity(string url, string deployManifestPath, string applica
 		public ApplicationIdentity(string url, AssemblyIdentity deployManifestIdentity, AssemblyIdentity applicationManifestIdentity)
         {
             if (String.IsNullOrEmpty(url))
+            {
                 throw new ArgumentNullException(nameof(url));
+            }
+
             _url = url;
             _deployManifestIdentity = deployManifestIdentity ?? throw new ArgumentNullException(nameof(deployManifestIdentity));
             _applicationManifestIdentity = applicationManifestIdentity ?? throw new ArgumentNullException(nameof(applicationManifestIdentity));
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 6997aeaadb7..ab30921344b 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -278,7 +278,11 @@ public string OSVersion
         {
             get
             {
-                if (String.IsNullOrEmpty(_oSMajor)) return null;
+                if (String.IsNullOrEmpty(_oSMajor))
+                {
+                    return null;
+                }
+
                 Version v;
                 try
                 {
@@ -509,9 +513,16 @@ private void ValidateCom()
 
         private void ValidateConfig()
         {
-            if (String.IsNullOrEmpty(ConfigFile)) return;
+            if (String.IsNullOrEmpty(ConfigFile))
+            {
+                return;
+            }
+
             FileReference configFile = FileReferences.FindTargetPath(ConfigFile);
-            if (configFile == null) return;
+            if (configFile == null)
+            {
+                return;
+            }
 
             if (!TrustInfo.IsFullTrust)
             {
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 66261651f2c..f1d88166b17 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -144,7 +144,10 @@ public AssemblyIdentity(string name, string version, string publicKeyToken, stri
         public AssemblyIdentity(AssemblyIdentity identity)
         {
             if (identity == null)
+            {
                 return;
+            }
+
             _name = identity._name;
             _version = identity._version;
             _publicKeyToken = identity._publicKeyToken;
diff --git a/src/Tasks/ManifestUtil/AssemblyReference.cs b/src/Tasks/ManifestUtil/AssemblyReference.cs
index 702790b55d4..2f63008164f 100644
--- a/src/Tasks/ManifestUtil/AssemblyReference.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReference.cs
@@ -86,11 +86,18 @@ internal bool IsVirtual
             get
             {
                 if (AssemblyIdentity == null)
+                {
                     return false;
+                }
+
                 if (String.Equals(AssemblyIdentity.Name, Constants.CLRPlatformAssemblyName, StringComparison.OrdinalIgnoreCase))
+                {
                     return true;
+                }
                 else
+                {
                     return false;
+                }
             }
         }
 
@@ -120,14 +127,24 @@ protected internal override string SortName
             get
             {
                 if (_assemblyIdentity == null)
+                {
                     return null;
+                }
+
                 string name = _assemblyIdentity.ToString();
                 if (IsVirtual)
+                {
                     name = "1: " + name; // virtual assemblies are first
+                }
                 else if (_isPrerequisite)
+                {
                     name = "2: " + name; // prerequisites are second
+                }
                 else
+                {
                     name = "3: " + name + ", " + TargetPath; // eveything else...
+                }
+
                 return name;
             }
         }
@@ -136,9 +153,15 @@ public override string ToString()
         {
             string str = base.ToString();
             if (!String.IsNullOrEmpty(str))
+            {
                 return str;
+            }
+
             if (_assemblyIdentity != null)
+            {
                 return _assemblyIdentity.ToString();
+            }
+
             return String.Empty;
         }
 
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 96a941a43e0..6daa303b780 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -46,7 +46,9 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
             _outputDisplayName = outputDisplayName;
 
             if (NativeMethods.SfcIsFileProtected(IntPtr.Zero, path) != 0)
+            {
                 outputMessages.AddWarningMessage("GenerateManifest.ComImport", outputDisplayName, _resources.GetString("ComImporter.ProtectedFile"));
+            }
 
             object obj = null;
             try { NativeMethods.LoadTypeLibEx(path, NativeMethods.RegKind.RegKind_None, out obj); }
diff --git a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
index bcf29162ac8..0bbb2d4b8ce 100644
--- a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
+++ b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
@@ -60,7 +60,10 @@ private bool EnumResNameCallback(IntPtr hModule, IntPtr pType, IntPtr pName, Int
 
         public static Stream Read(string path)
         {
-            if (path == null) throw new ArgumentNullException(nameof(path));
+            if (path == null)
+            {
+                throw new ArgumentNullException(nameof(path));
+            }
 
             if (!path.EndsWith(".manifest", StringComparison.Ordinal) && !path.EndsWith(".dll", StringComparison.Ordinal))
             {
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 0d17d52f4e4..207c6eaf6c7 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -233,7 +233,10 @@ public void ResolveFiles()
         public void ResolveFiles(string[] searchPaths)
         {
             if (searchPaths == null)
+            {
                 throw new ArgumentNullException(nameof(searchPaths));
+            }
+
             CollectionToArray();
             ResolveFiles_1(searchPaths);
             ResolveFiles_2(searchPaths);
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index 28879b378ab..6d5fc0a1f01 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -106,7 +106,11 @@ private static Manifest ReadEmbeddedManifest(string path)
         /// <returns>A base object representation of the manifest. Can be cast to AssemblyManifest, ApplicationManifest, or DeployManifest to access more specific functionality.</returns>
         public static Manifest ReadManifest(string path, bool preserveStream)
         {
-            if (path == null) throw new ArgumentNullException(nameof(path));
+            if (path == null)
+            {
+                throw new ArgumentNullException(nameof(path));
+            }
+
             string manifestType = null;
             if (path.EndsWith(".application", StringComparison.Ordinal))
             {
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index 1b2dbef040f..862fdb621ab 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -90,11 +90,15 @@ private void ImportCustomAttributesNames()
             {
                 EntityHandle ctorHandle = _reader.GetCustomAttribute(handle).Constructor;
                 if (ctorHandle.Kind != HandleKind.MemberReference)
+                {
                     continue;
+                }
 
                 EntityHandle mHandle = _reader.GetMemberReference((MemberReferenceHandle)ctorHandle).Parent;
                 if (mHandle.Kind != HandleKind.TypeReference)
+                {
                     continue;
+                }
 
                 string type = GetTypeName((TypeReferenceHandle)mHandle);
 
@@ -173,7 +177,9 @@ private string GetPublicKeyToken()
             }
 
             if (!String.IsNullOrEmpty(publicKeyToken))
+            {
                 publicKeyToken = publicKeyToken.ToUpperInvariant();
+            }
 
             return publicKeyToken;
         }
@@ -346,9 +352,14 @@ private void ImportAttributes()
             string version = refid.GetAttribute(null, "version");
             string publicKeyToken = refid.GetAttribute(null, "publicKeyToken");
             if (String.Equals(publicKeyToken, "neutral", StringComparison.OrdinalIgnoreCase))
+            {
                 publicKeyToken = String.Empty;
+            }
             else if (!String.IsNullOrEmpty(publicKeyToken))
+            {
                 publicKeyToken = publicKeyToken.ToUpperInvariant();
+            }
+
             string culture = refid.GetAttribute(null, "culture");
             string processorArchitecture = refid.GetAttribute(null, "processorArchitecture");
             if (!String.IsNullOrEmpty(processorArchitecture))
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index a9136b0f290..40d8fe1ce04 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -38,7 +38,11 @@ public static string[] GetPathSegments(string path)
         // Resolves the path, and if path is a url also canonicalizes it.
         public static string Format(string path)
         {
-            if (String.IsNullOrEmpty(path)) return path;
+            if (String.IsNullOrEmpty(path))
+            {
+                return path;
+            }
+
             string resolvedPath = Resolve(path);
             Uri u = new Uri(resolvedPath);
             return u.AbsoluteUri;
@@ -46,12 +50,36 @@ public static string Format(string path)
 
         public static bool IsAssembly(string path)
         {
-            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException(nameof(path));
-            if (String.Equals(Path.GetExtension(path), ".application", StringComparison.Ordinal)) return true;
-            if (String.Equals(Path.GetExtension(path), ".manifest", StringComparison.Ordinal)) return true;
-            if (!IsProgramFile(path)) return false; // optimization, don't want to sniff every every kind of file -- just dll's or exe's
-            if (IsManagedAssembly(path)) return true;
-            if (IsNativeAssembly(path)) return true;
+            if (String.IsNullOrEmpty(path))
+            {
+                throw new ArgumentNullException(nameof(path));
+            }
+
+            if (String.Equals(Path.GetExtension(path), ".application", StringComparison.Ordinal))
+            {
+                return true;
+            }
+
+            if (String.Equals(Path.GetExtension(path), ".manifest", StringComparison.Ordinal))
+            {
+                return true;
+            }
+
+            if (!IsProgramFile(path))
+            {
+                return false; // optimization, don't want to sniff every every kind of file -- just dll's or exe's
+            }
+
+            if (IsManagedAssembly(path))
+            {
+                return true;
+            }
+
+            if (IsNativeAssembly(path))
+            {
+                return true;
+            }
+
             return false;
         }
 
@@ -75,21 +103,38 @@ public static bool IsLocalPath(string path)
         {
             Uri u = new Uri(path, UriKind.RelativeOrAbsolute);
             if (!u.IsAbsoluteUri)
+            {
                 return true;
+            }
+
             return String.IsNullOrEmpty(u.Host);
         }
 
         public static bool IsManagedAssembly(string path)
         {
-            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException(nameof(path));
+            if (String.IsNullOrEmpty(path))
+            {
+                throw new ArgumentNullException(nameof(path));
+            }
+
             using (MetadataReader r = MetadataReader.Create(path))
+            {
                 return r != null;
+            }
         }
 
         public static bool IsNativeAssembly(string path)
         {
-            if (String.IsNullOrEmpty(path)) throw new ArgumentNullException(nameof(path));
-            if (String.Equals(Path.GetExtension(path), ".manifest", StringComparison.Ordinal)) return true;
+            if (String.IsNullOrEmpty(path))
+            {
+                throw new ArgumentNullException(nameof(path));
+            }
+
+            if (String.Equals(Path.GetExtension(path), ".manifest", StringComparison.Ordinal))
+            {
+                return true;
+            }
+
             return EmbeddedManifestReader.Read(path) != null;
         }
 
@@ -116,14 +161,20 @@ public static bool IsUncPath(string path)
         {
             Uri u;
             if (!Uri.TryCreate(path, UriKind.Absolute, out u) || u == null)
+            {
                 return false;
+            }
+
             return u.IsUnc;
         }
 
         public static bool IsUrl(string path)
         {
             if (!Uri.TryCreate(path, UriKind.Absolute, out Uri u) || u == null)
+            {
                 return false;
+            }
+
             return !u.IsUnc && !String.IsNullOrEmpty(u.Host);
         }
 
@@ -131,8 +182,16 @@ public static bool IsUrl(string path)
         // If path is a relative path, resolves to a full path.
         public static string Resolve(string path)
         {
-            if (String.IsNullOrEmpty(path)) return path;
-            if (IsUncPath(path)) return path; // if it's UNC then do nothing
+            if (String.IsNullOrEmpty(path))
+            {
+                return path;
+            }
+
+            if (IsUncPath(path))
+            {
+                return path; // if it's UNC then do nothing
+            }
+
             if (IsUrl(path)) // if it's a URL then need to check for "localhost"...
             {
                 // Replace "localhost" with the actual machine name...
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 8e16ee1a599..150b0256d7c 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -419,11 +419,16 @@ private static SecurityElement XmlElementToSecurityElement(XmlElement xe)
         {
             SecurityElement se = new SecurityElement(xe.Name);
             foreach (XmlAttribute xa in xe.Attributes)
+            {
                 se.AddAttribute(xa.Name, xa.Value);
+            }
+
             foreach (XmlNode xn in xe.ChildNodes)
             {
                 if (xn.NodeType == XmlNodeType.Element)
+                {
                     se.AddChild(XmlElementToSecurityElement((XmlElement)xn));
+                }
             }
 
             return se;
@@ -434,7 +439,10 @@ private static string[] XmlToIdentityList(XmlElement psElement)
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(psElement.OwnerDocument.NameTable);
             XmlNodeList nodes = psElement.SelectNodes(XPaths.permissionClassAttributeQuery, nsmgr);
             if (nodes == null || nodes.Count == 0)
+            {
                 nodes = psElement.SelectNodes(XmlUtil.TrimPrefix(XPaths.permissionClassAttributeQuery));
+            }
+
             string[] a;
             if (nodes != null)
             {
@@ -660,9 +668,13 @@ private static void SignFileInternal(X509Certificate2 cert,
             if (PathUtil.IsPEFile(path))
             {
                 if (IsCertInStore(cert))
+                {
                     SignPEFile(cert, timestampUrl, path, resources, useSha256);
+                }
                 else
+                {
                     throw new InvalidOperationException(resources.GetString("SignFile.CertNotInStore"));
+                }
             }
             else
             {
@@ -675,7 +687,10 @@ private static void SignFileInternal(X509Certificate2 cert,
 #endif
                 {
                     if (rsa == null)
+                    {
                         throw new ApplicationException(resources.GetString("SecurityUtil.OnlyRSACertsAreAllowed"));
+                    }
+
                     try
                     {
                         var doc = new XmlDocument { PreserveWhitespace = true };
@@ -711,9 +726,14 @@ private static void SignFileInternal(X509Certificate2 cert,
                         // No need to check hModule - Sign() method will quickly fail if we did not load clr.dll
 #endif
                         if (timestampUrl == null)
+                        {
                             manifest.Sign(signer);
+                        }
                         else
+                        {
                             manifest.Sign(signer, timestampUrl.ToString(), disallowMansignTimestampFallback);
+                        }
+
                         doc.Save(path);
                     }
                     catch (Exception ex)
@@ -887,7 +907,9 @@ private static bool IsCertInStore(X509Certificate2 cert)
                 personalStore.Open(OpenFlags.ReadOnly);
                 X509Certificate2Collection foundCerts = personalStore.Certificates.Find(X509FindType.FindByThumbprint, cert.Thumbprint, false);
                 if (foundCerts.Count == 1)
+                {
                     return true;
+                }
             }
             finally
             {
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index dc7880cd52a..351a7e7546f 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -187,7 +187,10 @@ private XmlElement GetInputPermissionSetElement()
         private XmlElement GetInputRequestedPrivilegeElement()
         {
             if (_inputTrustInfoDocument == null)
+            {
                 return null;
+            }
+
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(_inputTrustInfoDocument.NameTable);
             XmlElement trustInfoElement = _inputTrustInfoDocument.DocumentElement;
             XmlElement securityElement = (XmlElement) trustInfoElement?.SelectSingleNode(XPaths.securityElement, nsmgr);
@@ -506,7 +509,9 @@ private void ReadTrustInfo(string xml)
 #endif
             XmlAttribute sameSiteAttribute = (XmlAttribute)psElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.sameSiteAttribute));
             if (sameSiteAttribute != null)
+            {
                 _sameSiteSetting = sameSiteAttribute.Value;
+            }
         }
 
         /// <summary>
@@ -733,7 +738,9 @@ public void WriteManifest(Stream input, Stream output)
 
             XmlNodeList permissionSetNodes = applicationRequestMinimumElement.SelectNodes(XPaths.permissionSetElement, nsmgr);
             foreach (XmlNode permissionSetNode in permissionSetNodes)
+            {
                 applicationRequestMinimumElement.RemoveChild(permissionSetNode);
+            }
 
             XmlElement fullTrustPermissionSetElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.permissionSetElement), XmlNamespaces.asmv2);
             XmlAttribute unrestrictedAttribute = document.CreateAttribute(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute), XmlNamespaces.asmv2);
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index fd197c183f5..0c96f6289ef 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -63,20 +63,32 @@ internal static class Util
         public static string ByteArrayToHex(Byte[] a)
         {
             if (a == null)
+            {
                 return null;
+            }
+
             StringBuilder s = new StringBuilder(a.Length);
             foreach (Byte b in a)
+            {
                 s.Append(b.ToString("X02", CultureInfo.InvariantCulture));
+            }
+
             return s.ToString();
         }
 
         public static string ByteArrayToString(Byte[] a)
         {
             if (a == null)
+            {
                 return null;
+            }
+
             StringBuilder s = new StringBuilder(a.Length);
             foreach (Byte b in a)
+            {
                 s.Append(Convert.ToChar(b));
+            }
+
             return s.ToString();
         }
 
@@ -105,9 +117,13 @@ public static string FilterNonprintableChars(string value)
             while (i < sb.Length)
             {
                 if (sb[i] < ' ')
+                {
                     sb.Remove(i, 1);
+                }
                 else
+                {
                     ++i;
+                }
             }
 
             return sb.ToString();
@@ -139,7 +155,9 @@ public static string GetClrVersion()
         public static string GetClrVersion(string targetFrameworkVersion)
         {
             if (string.IsNullOrEmpty(targetFrameworkVersion))
+            {
                 return GetClrVersion();
+            }
 
             Version clrVersion;
 #if RUNTIME_TYPE_NETCORE
@@ -252,10 +270,17 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
 
         private static string GetLogPath()
         {
-            if (!logging) return null;
+            if (!logging)
+            {
+                return null;
+            }
+
             string logPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), @"Microsoft\VisualStudio\8.0\VSPLOG");
             if (!FileSystems.Default.DirectoryExists(logPath))
+            {
                 Directory.CreateDirectory(logPath);
+            }
+
             return logPath;
         }
 
@@ -268,7 +293,9 @@ public static string GetRegisteredOrganization()
                 string org = (string)key.GetValue("RegisteredOrganization");
                 org = org?.Trim();
                 if (!String.IsNullOrEmpty(org))
+                {
                     return org;
+                }
             }
             return null;
         }
@@ -281,9 +308,15 @@ public static bool IsValidAssemblyName(string value)
         public static bool IsValidCulture(string value)
         {
             if (String.Equals(value, "neutral", StringComparison.OrdinalIgnoreCase))
+            {
                 return true; // "neutral" is valid in a manifest but not in CultureInfo class
+            }
+
             if (String.Equals(value, "*", StringComparison.OrdinalIgnoreCase))
+            {
                 return true; // "*" is same as "neutral"
+            }
+
             CultureInfo culture;
             try
             {
@@ -330,13 +363,24 @@ public static bool IsValidVersion(string value, int octets)
             }
 
             if (octets >= 1 && version.Major < 0)
+            {
                 return false;
+            }
+
             if (octets >= 2 && version.Minor < 0)
+            {
                 return false;
+            }
+
             if (octets >= 3 && version.Build < 0)
+            {
                 return false;
+            }
+
             if (octets >= 4 && version.Revision < 0)
+            {
                 return false;
+            }
 
             return true;
         }
@@ -344,7 +388,10 @@ public static bool IsValidVersion(string value, int octets)
         internal static bool IsValidFrameworkVersion(string value)
         {
             if (value.StartsWith("v", StringComparison.OrdinalIgnoreCase))
+            {
                 return IsValidVersion(value.Substring(1), 2);
+            }
+
             return IsValidVersion(value, 2);
         }
 
@@ -353,7 +400,9 @@ public static string PlatformToProcessorArchitecture(string platform)
             for (int i = 0; i < s_platforms.Length; ++i)
             {
                 if (String.Equals(platform, s_platforms[i], StringComparison.OrdinalIgnoreCase))
+                {
                     return s_processorArchitectures[i];
+                }
             }
 
             return null;
@@ -362,9 +411,15 @@ public static string PlatformToProcessorArchitecture(string platform)
         private static ITaskItem[] RemoveDuplicateItems(ITaskItem[] items)
         {
             if (items == null)
+            {
                 return null;
+            }
+
             if (items.Length <= 1)
+            {
                 return items;
+            }
+
             var list = new Dictionary<string, ITaskItem>();
             foreach (ITaskItem item in items)
             {
@@ -397,7 +452,10 @@ public static ITaskItem[] SortItems(ITaskItem[] items)
         {
             ITaskItem[] outputItems = RemoveDuplicateItems(items);
             if (outputItems != null)
+            {
                 Array.Sort(outputItems, s_itemComparer);
+            }
+
             return outputItems;
         }
 
@@ -418,7 +476,10 @@ public static void WriteFile(string path, Stream s)
         public static void WriteLog(string text)
         {
             if (!logging)
+            {
                 return;
+            }
+
             if (s_logFileWriter == null)
             {
                 try
@@ -450,7 +511,10 @@ public static void WriteLog(string text)
         public static void WriteLogFile(string filename, Stream s)
         {
             if (!logging)
+            {
                 return;
+            }
+
             string path = Path.Combine(logPath, filename);
             StreamReader r = new StreamReader(s);
             string text = r.ReadToEnd();
@@ -476,7 +540,10 @@ public static void WriteLogFile(string filename, Stream s)
         public static void WriteLogFile(string filename, string s)
         {
             if (!logging)
+            {
                 return;
+            }
+
             string path = Path.Combine(logPath, filename);
             try
             {
@@ -503,7 +570,10 @@ public static void WriteLogFile(string filename, string s)
         public static void WriteLogFile(string filename, System.Xml.XmlElement element)
         {
             if (!logging)
+            {
                 return;
+            }
+
             WriteLogFile(filename, element.OuterXml);
         }
 
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index e370c0cad8a..93a6dd59c88 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -25,9 +25,13 @@ public static string GetQName(XmlTextReader r, XmlNamespaceManager nsmgr)
         {
             string prefix = !String.IsNullOrEmpty(r.Prefix) ? r.Prefix : nsmgr.LookupPrefix(r.NamespaceURI);
             if (!String.IsNullOrEmpty(prefix))
+            {
                 return prefix + ":" + r.LocalName;
+            }
             else
+            {
                 return r.LocalName;
+            }
         }
 
         // NOTE: XmlDocument.ImportNode munges "xmlns:asmv2" to "xmlns:d1p1" for some reason, use XmlUtil.CloneElementToDocument instead
@@ -60,7 +64,10 @@ public static string TrimPrefix(string s)
         {
             int i = s.IndexOf(':');
             if (i < 0)
+            {
                 return s;
+            }
+
             return s.Substring(i + 1);
         }
 
@@ -144,7 +151,9 @@ public override Object GetEntity(Uri uri, string role, Type t)
                     s = a.GetManifestResourceStream(String.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(Util).Namespace, filename));
 
                     if (s != null)
+                    {
                         return s;
+                    }
 
                     // Next look in current directory...
                     try
@@ -155,7 +164,9 @@ public override Object GetEntity(Uri uri, string role, Type t)
                     {
                     }
                     if (s != null)
+                    {
                         return s;
+                    }
                 }
 
                 // Lastly, look at full specified uri path...
@@ -170,7 +181,9 @@ public override Object GetEntity(Uri uri, string role, Type t)
                 {
                 }
                 if (s != null)
+                {
                     return s;
+                }
 
                 // Didn't find the resource...
                 Debug.Fail(String.Format(CultureInfo.CurrentCulture, "ResourceResolver could not find file '{0}'", filename));
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 9c29d1cbb1d..337511e8a91 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -286,11 +286,16 @@ public override XmlElement GetIdElement(XmlDocument document, string idValue)
         {
             // We only care about Id references inside of the KeyInfo section
             if (_verify)
+            {
                 return base.GetIdElement(document, idValue);
+            }
 
             KeyInfo keyInfo = this.KeyInfo;
             if (keyInfo.Id != idValue)
+            {
                 return null;
+            }
+
             return keyInfo.GetXml();
         }
     }
@@ -382,7 +387,10 @@ private XmlElement ExtractPrincipalFromManifest()
             nsm.AddNamespace("asm", AssemblyNamespaceUri);
             XmlNode assemblyIdentityNode = _manifestDom.SelectSingleNode("asm:assembly/asm:assemblyIdentity", nsm);
             if (assemblyIdentityNode == null)
+            {
                 throw new CryptographicException(Win32.TRUST_E_SUBJECT_FORM_UNKNOWN);
+            }
+
             return assemblyIdentityNode as XmlElement;
         }
 
@@ -442,7 +450,9 @@ private static void RemoveExistingSignature(XmlDocument manifestDom)
             nsm.AddNamespace("ds", SignedXml.XmlDsigNamespaceUrl);
             XmlNode signatureNode = manifestDom.SelectSingleNode("asm:assembly/ds:Signature", nsm);
             if (signatureNode != null)
+            {
                 signatureNode.ParentNode.RemoveChild(signatureNode);
+            }
         }
 
         /// <summary>
@@ -836,13 +846,19 @@ private static string ObtainRFC3161Timestamp(string timeStampUrl, string signatu
                 finally
                 {
                     if (ppTsContext != IntPtr.Zero)
+                    {
                         Win32.CryptMemFree(ppTsContext);
+                    }
 
                     if (ppTsSigner != IntPtr.Zero)
+                    {
                         Win32.CertFreeCertificateContext(ppTsSigner);
+                    }
 
                     if (phStore != IntPtr.Zero)
+                    {
                         Win32.CertCloseStore(phStore, 0);
+                    }
                 }
             }
 
@@ -1063,12 +1079,16 @@ internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey) :
         internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate, bool useSha256)
         {
             if (strongNameKey == null)
+            {
                 throw new ArgumentNullException(nameof(strongNameKey));
+            }
 
 #if (true) // BUGBUG: Fusion only supports RSA. Do we throw if not RSA???
             RSA rsa = strongNameKey as RSA;
             if (rsa == null)
+            {
                 throw new ArgumentNullException(nameof(strongNameKey));
+            }
 #endif
             _strongNameKey = strongNameKey;
             _certificate = certificate;
@@ -1143,9 +1163,15 @@ internal X509IncludeOption IncludeOption
             set
             {
                 if (value < X509IncludeOption.None || value > X509IncludeOption.WholeChain)
+                {
                     throw new ArgumentException("value");
+                }
+
                 if (_includeOption == X509IncludeOption.None)
+                {
                     throw new NotSupportedException();
+                }
+
                 _includeOption = value;
             }
         }
@@ -1161,7 +1187,9 @@ internal CmiManifestSignerFlag Flag
                 unchecked
                 {
                     if ((value & ((CmiManifestSignerFlag)~CimManifestSignerFlagMask)) != 0)
+                    {
                         throw new ArgumentException("value");
+                    }
                 }
                 _signerFlag = value;
             }
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 2fdd200203a..f81a61a02e1 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -95,7 +95,11 @@ private RedistList(AssemblyTableInfo[] assemblyTableInfos)
             var assemblyList = new List<AssemblyEntry>();
             var remappingEntries = new List<AssemblyRemapping>();
 
-            if (assemblyTableInfos == null) throw new ArgumentNullException(nameof(assemblyTableInfos));
+            if (assemblyTableInfos == null)
+            {
+                throw new ArgumentNullException(nameof(assemblyTableInfos));
+            }
+
             foreach (AssemblyTableInfo assemblyTableInfo in assemblyTableInfos)
             {
                 ReadFile(assemblyTableInfo, assemblyList, errors, errorFilenames, remappingEntries);
@@ -332,7 +336,11 @@ internal string RedistName(string assemblyName)
         /// </summary>
         public static RedistList GetRedistList(AssemblyTableInfo[] assemblyTables)
         {
-            if (assemblyTables == null) throw new ArgumentNullException(nameof(assemblyTables));
+            if (assemblyTables == null)
+            {
+                throw new ArgumentNullException(nameof(assemblyTables));
+            }
+
             Array.Sort(assemblyTables);
 
             var keyBuilder = assemblyTables.Length > 0 ? new StringBuilder(assemblyTables[0].Descriptor) : new StringBuilder();
@@ -359,14 +367,22 @@ public static RedistList GetRedistList(AssemblyTableInfo[] assemblyTables)
 
         private static string GetSimpleName(string assemblyName)
         {
-            if (assemblyName == null) throw new ArgumentNullException(nameof(assemblyName));
+            if (assemblyName == null)
+            {
+                throw new ArgumentNullException(nameof(assemblyName));
+            }
+
             int i = assemblyName.IndexOf(",", StringComparison.Ordinal);
             return i > 0 ? assemblyName.Substring(0, i) : assemblyName;
         }
 
         private AssemblyEntry GetUnifiedAssemblyEntry(string assemblyName)
         {
-            if (assemblyName == null) throw new ArgumentNullException(nameof(assemblyName));
+            if (assemblyName == null)
+            {
+                throw new ArgumentNullException(nameof(assemblyName));
+            }
+
             if (!_assemblyNameToUnifiedAssemblyName.TryGetValue(assemblyName, out AssemblyEntry unifiedEntry))
             {
                 string simpleName = GetSimpleName(assemblyName);
@@ -875,7 +891,10 @@ public int Compare(object a, object b)
             public int Compare(AssemblyEntry firstEntry, AssemblyEntry secondEntry)
             {
                 Debug.Assert(firstEntry != null && secondEntry != null);
-                if (firstEntry == null || secondEntry == null) return 0;
+                if (firstEntry == null || secondEntry == null)
+                {
+                    return 0;
+                }
 
                 AssemblyNameExtension firstAssemblyName = firstEntry.AssemblyNameExtension;
                 AssemblyNameExtension secondAssemblyName = secondEntry.AssemblyNameExtension;
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index bdca81a2457..b817ce6243e 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1164,7 +1164,9 @@ bool IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, out
 
             // if we have a strong name, strip off everything but the assembly name
             if (commaIndex != -1)
+            {
                 assemblyName = assemblyName.Substring(0, commaIndex);
+            }
 
             assemblyName += ".dll";
 
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 80e55c6aaca..5944fc38e04 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -953,7 +953,11 @@ public void Add(ITaskItem item, bool includedByDefault)
             {
                 string targetPath = GetItemTargetPath(item);
                 Debug.Assert(!String.IsNullOrEmpty(targetPath));
-                if (String.IsNullOrEmpty(targetPath)) return;
+                if (String.IsNullOrEmpty(targetPath))
+                {
+                    return;
+                }
+
                 string key = targetPath.ToLowerInvariant();
                 Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same '{0}' attribute detected", ItemMetadataNames.targetPath));
                 var entry = new MapEntry(item, includedByDefault);
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 91786f0f529..9a8d761b86c 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -313,20 +313,32 @@ internal static string[] ParseResxFileRefString(string stringValue)
                 {
                     int lastIndexOfQuote = stringValue.LastIndexOf("\"");
                     if (lastIndexOfQuote - 1 < 0)
+                    {
                         throw new ArgumentException(nameof(stringValue));
+                    }
+
                     fileName = stringValue.Substring(1, lastIndexOfQuote - 1); // remove the quotes in" ..... "
                     if (lastIndexOfQuote + 2 > stringValue.Length)
+                    {
                         throw new ArgumentException(nameof(stringValue));
+                    }
+
                     remainingString = stringValue.Substring(lastIndexOfQuote + 2);
                 }
                 else
                 {
                     int nextSemiColumn = stringValue.IndexOf(";");
                     if (nextSemiColumn == -1)
+                    {
                         throw new ArgumentException(nameof(stringValue));
+                    }
+
                     fileName = stringValue.Substring(0, nextSemiColumn);
                     if (nextSemiColumn + 1 > stringValue.Length)
+                    {
                         throw new ArgumentException(nameof(stringValue));
+                    }
+
                     remainingString = stringValue.Substring(nextSemiColumn + 1);
                 }
                 string[] parts = remainingString.Split(';');
diff --git a/src/Tasks/System.Design.cs b/src/Tasks/System.Design.cs
index 0ab4947d7b6..ba42df9c7e5 100644
--- a/src/Tasks/System.Design.cs
+++ b/src/Tasks/System.Design.cs
@@ -129,7 +129,10 @@ public static string GetString(string name, params object[] args)
         {
             SR sys = GetLoader();
             if (sys == null)
+            {
                 return null;
+            }
+
             string res = sys._resources.GetString(name, SR.Culture);
 
             if (args?.Length > 0)
@@ -154,7 +157,10 @@ public static string GetString(string name)
         {
             SR sys = GetLoader();
             if (sys == null)
+            {
                 return null;
+            }
+
             return sys._resources.GetString(name, SR.Culture);
         }
 
@@ -169,7 +175,10 @@ public static object GetObject(string name)
         {
             SR sys = GetLoader();
             if (sys == null)
+            {
                 return null;
+            }
+
             return sys._resources.GetObject(name, SR.Culture);
         }
     }
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index da98c85bd10..ef519c76b0f 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -245,7 +245,9 @@ AssemblyTableInfo[] installedAssemblyTableInfos
         public override void Translate(ITranslator translator)
         {
             if (instanceLocalFileStateCache is null)
+            {
                 throw new NullReferenceException(nameof(instanceLocalFileStateCache));
+            }
 
             translator.TranslateDictionary(
                 ref instanceLocalFileStateCache,
diff --git a/src/Tasks/TaskTranslatorHelpers.cs b/src/Tasks/TaskTranslatorHelpers.cs
index 6e43de0c3a4..040376b731b 100644
--- a/src/Tasks/TaskTranslatorHelpers.cs
+++ b/src/Tasks/TaskTranslatorHelpers.cs
@@ -14,7 +14,9 @@ internal static class TaskTranslatorHelpers
         public static void Translate(this ITranslator translator, ref FrameworkName frameworkName)
         {
             if (!translator.TranslateNullable(frameworkName))
+            {
                 return;
+            }
 
             string identifier = null;
             Version version = null;
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index 28a24d722ea..f9dde2dd5fe 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -942,7 +942,9 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
         private bool ContainsCurrentPlatform(Property property)
         {
             if (Platform == null)
+            {
                 return true;
+            }
 
             if (property.Values.Count > 0)
             {
@@ -966,7 +968,9 @@ private bool ContainsCurrentPlatform(string SwitchValue)
         {
             // If we don't have a platform defined it meens all
             if (Platform == null)
+            {
                 return true;
+            }
 
             if (_relationsParser.SwitchRelationsList.TryGetValue(SwitchValue, out SwitchRelations rel))
             {
@@ -975,7 +979,9 @@ private bool ContainsCurrentPlatform(string SwitchValue)
                     foreach (string excludedPlatform in rel.ExcludedPlatforms)
                     {
                         if (Platform == excludedPlatform)
+                        {
                             return false;
+                        }
                     }
                 }
                 if (rel.IncludedPlatforms.Count > 0)
@@ -984,7 +990,9 @@ private bool ContainsCurrentPlatform(string SwitchValue)
                     foreach (string includedPlatform in rel.IncludedPlatforms)
                     {
                         if (Platform == includedPlatform)
+                        {
                             isIncluded = true;
+                        }
                     }
                     return isIncluded;
                 }
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index 73fc516867b..4fdec8b3788 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -126,7 +126,9 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
             {
                 isRootedPath = Path.IsPathRooted(contentOrFile);
                 if (!isRootedPath)
+                {
                     maybeFullPath = Path.GetFullPath(contentOrFile);
+                }
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
@@ -138,7 +140,9 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
                 // valid *absolute* file path
 
                 if (!FileSystems.Default.FileExists(contentOrFile))
+                {
                     throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Xaml.RuleFileNotFound", contentOrFile));
+                }
 
                 return ParseXamlDocument(new StreamReader(contentOrFile), desiredRule);
             }
@@ -146,12 +150,16 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
             // On Windows, xml content string is not a valid path, so, maybeFullPath == null
             // On Unix, xml content string would be a valid path, so, maybeFullPath != null
             if (maybeFullPath == null)
+            {
                 // Unable to convert to a path, parse as XML
                 return ParseXamlDocument(new StringReader(contentOrFile), desiredRule);
+            }
 
             if (FileSystems.Default.FileExists(maybeFullPath))
+            {
                 // file found, parse as a file
                 return ParseXamlDocument(new StreamReader(maybeFullPath), desiredRule);
+            }
 
             // @maybeFullPath is either:
             //  - a non-existent fullpath
@@ -160,9 +168,13 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
             //
             // On Windows, this means that @contentOrFile is really a non-existent file name
             if (NativeMethodsShared.IsWindows)
+            {
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Xaml.RuleFileNotFound", maybeFullPath));
+            }
             else // On !Windows, try parsing as XML
+            {
                 return ParseXamlDocument(new StringReader(contentOrFile), desiredRule);
+            }
         }
 
         /// <summary>
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 2a0ecc35e16..ffa2a30100c 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -319,9 +319,13 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
             if (resourcesNamespace != null)
             {
                 if (resourcesNamespace.Length > 0)
+                {
                     resMgrCtorParam = resourcesNamespace + '.' + baseName;
+                }
                 else
+                {
                     resMgrCtorParam = baseName;
+                }
             }
             else if (!string.IsNullOrEmpty(nameSpace))
             {
@@ -341,9 +345,14 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
             CodeConstructor ctor = new CodeConstructor();
             ctor.CustomAttributes.Add(suppressMessageAttrib);
             if (useStatic || internalClass)
+            {
                 ctor.Attributes = MemberAttributes.FamilyAndAssembly;
+            }
             else
+            {
                 ctor.Attributes = MemberAttributes.Public;
+            }
+
             srClass.Members.Add(ctor);
 
             // Emit _resMgr field.
@@ -353,7 +362,10 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
                 Attributes = MemberAttributes.Private
             };
             if (useStatic)
+            {
                 field.Attributes |= MemberAttributes.Static;
+            }
+
             srClass.Members.Add(field);
 
             // Emit _resCulture field, and leave it set to null.
@@ -361,7 +373,10 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
             field = new CodeMemberField(CultureTypeReference, CultureInfoFieldName);
             field.Attributes = MemberAttributes.Private;
             if (useStatic)
+            {
                 field.Attributes |= MemberAttributes.Static;
+            }
+
             srClass.Members.Add(field);
 
             // Emit ResMgr property
@@ -372,11 +387,18 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
             resMgr.HasSet = false;
             resMgr.Type = ResMgrCodeTypeReference;
             if (internalClass)
+            {
                 resMgr.Attributes = MemberAttributes.Assembly;
+            }
             else
+            {
                 resMgr.Attributes = MemberAttributes.Public;
+            }
+
             if (useStatic)
+            {
                 resMgr.Attributes |= MemberAttributes.Static;
+            }
 
             // Mark the ResMgr property as advanced
             var editorBrowsableStateTypeRef =
@@ -398,12 +420,18 @@ private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, String na
             culture.HasSet = true;
             culture.Type = CultureTypeReference;
             if (internalClass)
+            {
                 culture.Attributes = MemberAttributes.Assembly;
+            }
             else
+            {
                 culture.Attributes = MemberAttributes.Public;
+            }
 
             if (useStatic)
+            {
                 culture.Attributes |= MemberAttributes.Static;
+            }
 
             // Mark the Culture property as advanced
             culture.CustomAttributes.Add(editorBrowsableAdvancedAttribute);
@@ -468,7 +496,9 @@ private static string TruncateAndFormatCommentStringForOutput(string commentStri
             {
                 // Stop at some length
                 if (commentString.Length > DocCommentLengthThreshold)
+                {
                     commentString = SR.GetString(SR.StringPropertyTruncatedComment, commentString.Substring(0, DocCommentLengthThreshold));
+                }
 
                 // Encode the comment so it is safe for xml.  SecurityElement.Escape is the only method I've found to do this. 
                 commentString = System.Security.SecurityElement.Escape(commentString);
@@ -545,12 +575,18 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
 
             prop.Type = valueType;
             if (internalClass)
+            {
                 prop.Attributes = MemberAttributes.Assembly;
+            }
             else
+            {
                 prop.Attributes = MemberAttributes.Public;
+            }
 
             if (useStatic)
+            {
                 prop.Attributes |= MemberAttributes.Static;
+            }
 
             // For Strings, emit this:
             //    return ResourceManager.GetString("name", _resCulture);
@@ -573,11 +609,17 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
             }
 
             if (isString)
+            {
                 getMethodName = "GetString";
+            }
             else if (isStream)
+            {
                 getMethodName = "GetStream";
+            }
             else
+            {
                 getMethodName = "GetObject";
+            }
 
             if (isString)
             {
@@ -587,9 +629,13 @@ private static bool DefineResourceFetchingProperty(String propertyName, String r
             { // Stream or Object
                 if (valueAsString == null ||
                     String.Equals(typeName, valueAsString)) // If the type did not override ToString, ToString just returns the type name.
+                {
                     text = SR.GetString(SR.NonStringPropertyComment, typeName);
+                }
                 else
+                {
                     text = SR.GetString(SR.NonStringPropertyDetailedComment, typeName, valueAsString);
+                }
             }
 
             prop.Comments.Add(new CodeCommentStatement(DocCommentSummaryStart, true));
@@ -625,29 +671,42 @@ internal static String VerifyResourceName(String key, CodeDomProvider provider)
         private static String VerifyResourceName(String key, CodeDomProvider provider, bool isNameSpace)
         {
             if (key == null)
+            {
                 throw new ArgumentNullException(nameof(key));
+            }
+
             if (provider == null)
+            {
                 throw new ArgumentNullException(nameof(provider));
+            }
 
             foreach (char c in s_charsToReplace)
             {
                 // For namespaces, allow . and ::
                 if (!(isNameSpace && (c == '.' || c == ':')))
+                {
                     key = key.Replace(c, ReplacementChar);
+                }
             }
 
             if (provider.IsValidIdentifier(key))
+            {
                 return key;
+            }
 
             // Now try fixing up keywords like "for".  
             key = provider.CreateValidIdentifier(key);
             if (provider.IsValidIdentifier(key))
+            {
                 return key;
+            }
 
             // make one last ditch effort by prepending _.  This fixes keys that start with a number
             key = "_" + key;
             if (provider.IsValidIdentifier(key))
+            {
                 return key;
+            }
 
             return null;
         }
diff --git a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
index b37dbed11db..e065da82058 100644
--- a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
+++ b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
@@ -203,7 +203,10 @@ nor is this
             }
             finally
             {
-                if (file != null) File.Delete(file);
+                if (file != null)
+                {
+                    File.Delete(file);
+                }
             }
         }
 
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
index 85ccedf6f8b..9456ec19cb7 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
@@ -40,7 +40,9 @@ protected override async Task AfterTestAssemblyStartingAsync()
 
                 // Instantiate all the fixtures
                 foreach (var fixtureAttr in fixturesAttrs.Where(a => a.LifetimeScope == AssemblyFixtureAttribute.Scope.Assembly))
+                {
                     assemblyFixtureMappings[fixtureAttr.FixtureType] = Activator.CreateInstance(fixtureAttr.FixtureType);
+                }
             });
         }
 
@@ -48,7 +50,9 @@ protected override Task BeforeTestAssemblyFinishedAsync()
         {
             // Make sure we clean up everybody who is disposable, and use Aggregator.Run to isolate Dispose failures
             foreach (var disposable in assemblyFixtureMappings.Values.OfType<IDisposable>())
+            {
                 Aggregator.Run(disposable.Dispose);
+            }
 
             return base.BeforeTestAssemblyFinishedAsync();
         }
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
index 6b64d7f4e42..7ca3236a5bd 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
@@ -33,14 +33,18 @@ protected override async Task AfterTestClassStartingAsync()
             {
                 // Instantiate all the fixtures
                 foreach (var fixtureAttr in assemblyFixtureAttributes.Where(a => a.LifetimeScope == AssemblyFixtureAttribute.Scope.Class))
+                {
                     assemblyFixtureMappings[fixtureAttr.FixtureType] = Activator.CreateInstance(fixtureAttr.FixtureType);
+                }
             });
         }
         protected override Task BeforeTestClassFinishedAsync()
         {
             // Make sure we clean up everybody who is disposable, and use Aggregator.Run to isolate Dispose failures
             foreach (var disposable in assemblyFixtureMappings.Values.OfType<IDisposable>())
+            {
                 Aggregator.Run(disposable.Dispose);
+            }
 
             return base.BeforeTestClassFinishedAsync();
         }
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
index 6ccda839570..0b5ec858f9d 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
@@ -37,9 +37,10 @@ protected override Task<RunSummary> RunTestClassAsync(ITestClass testClass, IRef
             // so instead we'll just let collection fixtures override assembly fixtures.
             var combinedFixtures = new Dictionary<Type, object>(assemblyFixtureMappings);
             foreach (var kvp in CollectionFixtureMappings)
+            {
                 combinedFixtures[kvp.Key] = kvp.Value;
+            }
 
-            
             return new XunitTestClassRunnerWithAssemblyFixture(assemblyFixtureAttributes, testClass, @class, testCases, diagnosticMessageSink, MessageBus, TestCaseOrderer, new ExceptionAggregator(Aggregator), CancellationTokenSource, combinedFixtures).RunAsync();
         }
     }
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestFrameworkExecutorWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestFrameworkExecutorWithAssemblyFixture.cs
index 42d906d9e97..87f32b0827f 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestFrameworkExecutorWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestFrameworkExecutorWithAssemblyFixture.cs
@@ -16,7 +16,9 @@ public XunitTestFrameworkExecutorWithAssemblyFixture(AssemblyName assemblyName,
         protected override async void RunTestCases(IEnumerable<IXunitTestCase> testCases, IMessageSink executionMessageSink, ITestFrameworkExecutionOptions executionOptions)
         {
             using (var assemblyRunner = new XunitTestAssemblyRunnerWithAssemblyFixture(TestAssembly, testCases, DiagnosticMessageSink, executionMessageSink, executionOptions))
+            {
                 await assemblyRunner.RunAsync();
+            }
         }
     }
 }
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestMethodRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestMethodRunnerWithAssemblyFixture.cs
index 29765c69e2b..29d87c7950b 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestMethodRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestMethodRunnerWithAssemblyFixture.cs
@@ -37,7 +37,9 @@ protected override void AfterTestMethodStarting()
             {
                 // Instantiate all the fixtures
                 foreach (var fixtureAttr in assemblyFixtureAttributes.Where(a => a.LifetimeScope == AssemblyFixtureAttribute.Scope.Method))
+                {
                     assemblyFixtureMappings[fixtureAttr.FixtureType] = Activator.CreateInstance(fixtureAttr.FixtureType);
+                }
             });
         }
 
@@ -45,7 +47,9 @@ protected override void BeforeTestMethodFinished()
         {
             // Make sure we clean up everybody who is disposable, and use Aggregator.Run to isolate Dispose failures
             foreach (var disposable in assemblyFixtureMappings.Values.OfType<IDisposable>())
+            {
                 Aggregator.Run(disposable.Dispose);
+            }
 
             base.BeforeTestMethodFinished();
         }
