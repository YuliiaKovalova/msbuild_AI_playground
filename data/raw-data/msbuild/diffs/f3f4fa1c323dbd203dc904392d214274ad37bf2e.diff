diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index 344e0b9ef0e..fee348d4042 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -2548,6 +2548,153 @@ namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
     public partial interface IResolveAssemblyReferenceTaskHandler : System.IDisposable
     {
+        System.Threading.Tasks.Task<Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResult> ExecuteAsync(Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceRequest input, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
+    }
+    [MessagePack.MessagePackObjectAttribute(false)]
+    public partial class ReadOnlyTaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
+    {
+        public ReadOnlyTaskItem(string itemSpec) { }
+        [MessagePack.IgnoreMemberAttribute]
+        public string EvaluatedIncludeEscaped { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(0)]
+        public string ItemSpec { get { throw null; } set { } }
+        [MessagePack.IgnoreMemberAttribute]
+        public int MetadataCount { get { throw null; } set { } }
+        [MessagePack.IgnoreMemberAttribute]
+        public System.Collections.ICollection MetadataNames { get { throw null; } }
+        [MessagePack.KeyAttribute(1)]
+        public System.Collections.Generic.Dictionary<string, string> MetadataNameToValue { get { throw null; } set { } }
+        public System.Collections.IDictionary CloneCustomMetadata() { throw null; }
+        public System.Collections.IDictionary CloneCustomMetadataEscaped() { throw null; }
+        public void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }
+        public string GetMetadata(string metadataName) { throw null; }
+        public string GetMetadataValueEscaped(string metadataName) { throw null; }
+        public void RemoveMetadata(string metadataName) { }
+        public void SetMetadata(string metadataName, string metadataValue) { }
+        public void SetMetadataValueLiteral(string metadataName, string metadataValue) { }
+    }
+    [MessagePack.MessagePackObjectAttribute(false)]
+    public partial class ResolveAssemblyReferenceRequest
+    {
+        public ResolveAssemblyReferenceRequest() { }
+        [MessagePack.KeyAttribute(0)]
+        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(1)]
+        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(2)]
+        public string AppConfigFile { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(3)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] Assemblies { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(4)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] AssemblyFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(5)]
+        public bool AutoUnify { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(6)]
+        public string[] CandidateAssemblyFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(7)]
+        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(8)]
+        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(9)]
+        public bool FindDependencies { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(10)]
+        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(11)]
+        public bool FindRelatedFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(12)]
+        public bool FindSatellites { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(13)]
+        public bool FindSerializationAssemblies { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(14)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(15)]
+        public string[] FullFrameworkFolders { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(16)]
+        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(17)]
+        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(18)]
+        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(19)]
+        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(20)]
+        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(21)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(22)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(23)]
+        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(24)]
+        public string ProfileName { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(25)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(26)]
+        public string[] SearchPaths { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(27)]
+        public bool Silent { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(28)]
+        public string StateFile { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(29)]
+        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(30)]
+        public string TargetedRuntimeVersion { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(31)]
+        public string[] TargetFrameworkDirectories { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(32)]
+        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(33)]
+        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(34)]
+        public string[] TargetFrameworkSubsets { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(35)]
+        public string TargetFrameworkVersion { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(36)]
+        public string TargetProcessorArchitecture { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(37)]
+        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(38)]
+        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(39)]
+        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
+    }
+    [MessagePack.MessagePackObjectAttribute(false)]
+    public sealed partial class ResolveAssemblyReferenceResponse
+    {
+        public ResolveAssemblyReferenceResponse() { }
+        [MessagePack.KeyAttribute(0)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] CopyLocalFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(1)]
+        public string DependsOnNETStandard { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(2)]
+        public string DependsOnSystemRuntime { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(3)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FilesWritten { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(4)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] RelatedFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(5)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedDependencyFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(6)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(7)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SatelliteFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(8)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ScatterFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(9)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SerializationAssemblyFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(10)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SuggestedRedirects { get { throw null; } set { } }
+    }
+    [MessagePack.MessagePackObjectAttribute(false)]
+    public sealed partial class ResolveAssemblyReferenceResult
+    {
+        public ResolveAssemblyReferenceResult() { }
+        [MessagePack.KeyAttribute(2)]
+        public System.Collections.Generic.List<Microsoft.Build.Framework.LazyFormattedBuildEventArgs> BuildEventArgs { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(1)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResponse Response { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(0)]
+        public bool TaskResult { get { throw null; } set { } }
     }
 }
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Server
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index e56a2127dd3..eb5a0927dc6 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -2170,6 +2170,153 @@ namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
     public partial interface IResolveAssemblyReferenceTaskHandler : System.IDisposable
     {
+        System.Threading.Tasks.Task<Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResult> ExecuteAsync(Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceRequest input, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
+    }
+    [MessagePack.MessagePackObjectAttribute(false)]
+    public partial class ReadOnlyTaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
+    {
+        public ReadOnlyTaskItem(string itemSpec) { }
+        [MessagePack.IgnoreMemberAttribute]
+        public string EvaluatedIncludeEscaped { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(0)]
+        public string ItemSpec { get { throw null; } set { } }
+        [MessagePack.IgnoreMemberAttribute]
+        public int MetadataCount { get { throw null; } set { } }
+        [MessagePack.IgnoreMemberAttribute]
+        public System.Collections.ICollection MetadataNames { get { throw null; } }
+        [MessagePack.KeyAttribute(1)]
+        public System.Collections.Generic.Dictionary<string, string> MetadataNameToValue { get { throw null; } set { } }
+        public System.Collections.IDictionary CloneCustomMetadata() { throw null; }
+        public System.Collections.IDictionary CloneCustomMetadataEscaped() { throw null; }
+        public void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }
+        public string GetMetadata(string metadataName) { throw null; }
+        public string GetMetadataValueEscaped(string metadataName) { throw null; }
+        public void RemoveMetadata(string metadataName) { }
+        public void SetMetadata(string metadataName, string metadataValue) { }
+        public void SetMetadataValueLiteral(string metadataName, string metadataValue) { }
+    }
+    [MessagePack.MessagePackObjectAttribute(false)]
+    public partial class ResolveAssemblyReferenceRequest
+    {
+        public ResolveAssemblyReferenceRequest() { }
+        [MessagePack.KeyAttribute(0)]
+        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(1)]
+        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(2)]
+        public string AppConfigFile { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(3)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] Assemblies { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(4)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] AssemblyFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(5)]
+        public bool AutoUnify { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(6)]
+        public string[] CandidateAssemblyFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(7)]
+        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(8)]
+        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(9)]
+        public bool FindDependencies { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(10)]
+        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(11)]
+        public bool FindRelatedFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(12)]
+        public bool FindSatellites { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(13)]
+        public bool FindSerializationAssemblies { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(14)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(15)]
+        public string[] FullFrameworkFolders { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(16)]
+        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(17)]
+        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(18)]
+        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(19)]
+        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(20)]
+        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(21)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(22)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(23)]
+        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(24)]
+        public string ProfileName { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(25)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(26)]
+        public string[] SearchPaths { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(27)]
+        public bool Silent { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(28)]
+        public string StateFile { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(29)]
+        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(30)]
+        public string TargetedRuntimeVersion { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(31)]
+        public string[] TargetFrameworkDirectories { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(32)]
+        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(33)]
+        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(34)]
+        public string[] TargetFrameworkSubsets { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(35)]
+        public string TargetFrameworkVersion { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(36)]
+        public string TargetProcessorArchitecture { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(37)]
+        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(38)]
+        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(39)]
+        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
+    }
+    [MessagePack.MessagePackObjectAttribute(false)]
+    public sealed partial class ResolveAssemblyReferenceResponse
+    {
+        public ResolveAssemblyReferenceResponse() { }
+        [MessagePack.KeyAttribute(0)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] CopyLocalFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(1)]
+        public string DependsOnNETStandard { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(2)]
+        public string DependsOnSystemRuntime { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(3)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FilesWritten { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(4)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] RelatedFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(5)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedDependencyFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(6)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(7)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SatelliteFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(8)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ScatterFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(9)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SerializationAssemblyFiles { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(10)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SuggestedRedirects { get { throw null; } set { } }
+    }
+    [MessagePack.MessagePackObjectAttribute(false)]
+    public sealed partial class ResolveAssemblyReferenceResult
+    {
+        public ResolveAssemblyReferenceResult() { }
+        [MessagePack.KeyAttribute(2)]
+        public System.Collections.Generic.List<Microsoft.Build.Framework.LazyFormattedBuildEventArgs> BuildEventArgs { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(1)]
+        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResponse Response { get { throw null; } set { } }
+        [MessagePack.KeyAttribute(0)]
+        public bool TaskResult { get { throw null; } set { } }
     }
 }
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Server
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index ea72f3f30e4..25b067d1df6 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1385,7 +1385,7 @@ internal ProjectTaskOutputPropertyInstance() { }
     public sealed partial class RarNode
     {
         public RarNode() { }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out System.Exception shutdownException, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { shutdownException = default(System.Exception); throw null; }
         public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
     }
     public partial class RequestedProjectState
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index f26460cd981..f7074418d01 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1379,7 +1379,7 @@ internal ProjectTaskOutputPropertyInstance() { }
     public sealed partial class RarNode
     {
         public RarNode() { }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out System.Exception shutdownException, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { shutdownException = default(System.Exception); throw null; }
         public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
     }
     public partial class RequestedProjectState
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 307aa1a24c1..ac6ff07484a 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -59,12 +59,6 @@ public ResolveAssemblyReference()
         {
         }
 
-        internal ResolveAssemblyReference(ResolveAssemblyReferenceInput input)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(input, nameof(input));
-            ResolveAssemblyReferenceInput = input;
-        }
-
         #region Properties
 
         private ITaskItem[] _assemblyFiles = Array.Empty<TaskItem>();
@@ -915,52 +909,51 @@ public String DependsOnNETStandard
             private set;
         }
 
-        private ResolveAssemblyReferenceInput ResolveAssemblyReferenceInput
-        {
-            get
-            {
-                return new ResolveAssemblyReferenceInput
-                {
-                    AllowedAssemblyExtensions = AllowedAssemblyExtensions,
-                    AllowedRelatedFileExtensions = AllowedRelatedFileExtensions,
-                    AppConfigFile = AppConfigFile,
-                    Assemblies = Assemblies,
-                    AssemblyFiles = AssemblyFiles,
-                    AutoUnify = AutoUnify,
-                    CandidateAssemblyFiles = CandidateAssemblyFiles,
-                    CopyLocalDependenciesWhenParentReferenceInGac = CopyLocalDependenciesWhenParentReferenceInGac,
-                    FindDependencies = FindDependencies,
-                    FindDependenciesOfExternallyResolvedReferences = FindDependenciesOfExternallyResolvedReferences,
-                    FindRelatedFiles = FindRelatedFiles,
-                    FindSatellites = FindSatellites,
-                    FindSerializationAssemblies = FindSerializationAssemblies,
-                    FullFrameworkAssemblyTables = FullFrameworkAssemblyTables,
-                    FullFrameworkFolders = FullFrameworkFolders,
-                    FullTargetFrameworkSubsetNames = FullTargetFrameworkSubsetNames,
-                    IgnoreDefaultInstalledAssemblySubsetTables = IgnoreDefaultInstalledAssemblySubsetTables,
-                    IgnoreDefaultInstalledAssemblyTables = IgnoreDefaultInstalledAssemblyTables,
-                    IgnoreTargetFrameworkAttributeVersionMismatch = IgnoreTargetFrameworkAttributeVersionMismatch,
-                    IgnoreVersionForFrameworkReferences = IgnoreVersionForFrameworkReferences,
-                    InstalledAssemblySubsetTables = InstalledAssemblySubsetTables,
-                    InstalledAssemblyTables = InstalledAssemblyTables,
-                    LatestTargetFrameworkDirectories = LatestTargetFrameworkDirectories,
-                    ProfileName = ProfileName,
-                    SearchPaths = SearchPaths,
-                    Silent = Silent,
-                    StateFile = StateFile,
-                    SupportsBindingRedirectGeneration = SupportsBindingRedirectGeneration,
-                    TargetedRuntimeVersion = TargetedRuntimeVersion,
-                    TargetFrameworkDirectories = TargetFrameworkDirectories,
-                    TargetFrameworkMoniker = TargetFrameworkMoniker,
-                    TargetFrameworkMonikerDisplayName = TargetFrameworkMonikerDisplayName,
-                    TargetFrameworkSubsets = TargetFrameworkSubsets,
-                    TargetFrameworkVersion = TargetFrameworkVersion,
-                    TargetProcessorArchitecture = TargetProcessorArchitecture,
-                    UnresolveFrameworkAssembliesFromHigherFrameworks = UnresolveFrameworkAssembliesFromHigherFrameworks,
-                    UseResolveAssemblyReferenceService = UseResolveAssemblyReferenceService,
-                    WarnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatch
-                };
-            }
+        internal ResolveAssemblyReferenceTaskInput ResolveAssemblyReferenceInput
+        {
+            get => new ResolveAssemblyReferenceTaskInput
+            {
+                AllowedAssemblyExtensions = AllowedAssemblyExtensions,
+                AllowedRelatedFileExtensions = AllowedRelatedFileExtensions,
+                AppConfigFile = AppConfigFile,
+                Assemblies = Assemblies,
+                AssemblyFiles = AssemblyFiles,
+                AutoUnify = AutoUnify,
+                CandidateAssemblyFiles = CandidateAssemblyFiles,
+                CopyLocalDependenciesWhenParentReferenceInGac = CopyLocalDependenciesWhenParentReferenceInGac,
+                DoNotCopyLocalIfInGac = DoNotCopyLocalIfInGac,
+                FindDependencies = FindDependencies,
+                FindDependenciesOfExternallyResolvedReferences = FindDependenciesOfExternallyResolvedReferences,
+                FindRelatedFiles = FindRelatedFiles,
+                FindSatellites = FindSatellites,
+                FindSerializationAssemblies = FindSerializationAssemblies,
+                FullFrameworkAssemblyTables = FullFrameworkAssemblyTables,
+                FullFrameworkFolders = FullFrameworkFolders,
+                FullTargetFrameworkSubsetNames = FullTargetFrameworkSubsetNames,
+                IgnoreDefaultInstalledAssemblySubsetTables = IgnoreDefaultInstalledAssemblySubsetTables,
+                IgnoreDefaultInstalledAssemblyTables = IgnoreDefaultInstalledAssemblyTables,
+                IgnoreTargetFrameworkAttributeVersionMismatch = IgnoreTargetFrameworkAttributeVersionMismatch,
+                IgnoreVersionForFrameworkReferences = IgnoreVersionForFrameworkReferences,
+                InstalledAssemblySubsetTables = InstalledAssemblySubsetTables,
+                InstalledAssemblyTables = InstalledAssemblyTables,
+                LatestTargetFrameworkDirectories = LatestTargetFrameworkDirectories,
+                ProfileName = ProfileName,
+                ResolvedSDKReferences = ResolvedSDKReferences,
+                SearchPaths = SearchPaths,
+                Silent = Silent,
+                StateFile = StateFile,
+                SupportsBindingRedirectGeneration = SupportsBindingRedirectGeneration,
+                TargetedRuntimeVersion = TargetedRuntimeVersion,
+                TargetFrameworkDirectories = TargetFrameworkDirectories,
+                TargetFrameworkMoniker = TargetFrameworkMoniker,
+                TargetFrameworkMonikerDisplayName = TargetFrameworkMonikerDisplayName,
+                TargetFrameworkSubsets = TargetFrameworkSubsets,
+                TargetFrameworkVersion = TargetFrameworkVersion,
+                TargetProcessorArchitecture = TargetProcessorArchitecture,
+                UnresolveFrameworkAssembliesFromHigherFrameworks = UnresolveFrameworkAssembliesFromHigherFrameworks,
+                UseResolveAssemblyReferenceService = UseResolveAssemblyReferenceService,
+                WarnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatch
+            };
             set
             {
                 AllowedAssemblyExtensions = value.AllowedAssemblyExtensions;
@@ -971,6 +964,7 @@ private ResolveAssemblyReferenceInput ResolveAssemblyReferenceInput
                 AutoUnify = value.AutoUnify;
                 CandidateAssemblyFiles = value.CandidateAssemblyFiles;
                 CopyLocalDependenciesWhenParentReferenceInGac = value.CopyLocalDependenciesWhenParentReferenceInGac;
+                DoNotCopyLocalIfInGac = value.DoNotCopyLocalIfInGac;
                 FindDependencies = value.FindDependencies;
                 FindDependenciesOfExternallyResolvedReferences = value.FindDependenciesOfExternallyResolvedReferences;
                 FindRelatedFiles = value.FindRelatedFiles;
@@ -987,6 +981,7 @@ private ResolveAssemblyReferenceInput ResolveAssemblyReferenceInput
                 InstalledAssemblyTables = value.InstalledAssemblyTables;
                 LatestTargetFrameworkDirectories = value.LatestTargetFrameworkDirectories;
                 ProfileName = value.ProfileName;
+                ResolvedSDKReferences = value.ResolvedSDKReferences;
                 SearchPaths = value.SearchPaths;
                 Silent = value.Silent;
                 StateFile = value.StateFile;
@@ -1004,6 +999,38 @@ private ResolveAssemblyReferenceInput ResolveAssemblyReferenceInput
             }
         }
 
+        internal ResolveAssemblyReferenceTaskOutput ResolveAssemblyReferenceOutput
+        {
+            get => new ResolveAssemblyReferenceTaskOutput
+            {
+                CopyLocalFiles = CopyLocalFiles,
+                DependsOnNETStandard = DependsOnNETStandard,
+                DependsOnSystemRuntime = DependsOnSystemRuntime,
+                FilesWritten = FilesWritten,
+                RelatedFiles = RelatedFiles,
+                ResolvedDependencyFiles = ResolvedDependencyFiles,
+                ResolvedFiles = ResolvedFiles,
+                SatelliteFiles = SatelliteFiles,
+                ScatterFiles = ScatterFiles,
+                SerializationAssemblyFiles = SerializationAssemblyFiles,
+                SuggestedRedirects = SuggestedRedirects,
+            };
+            set
+            {
+                _copyLocalFiles = value.CopyLocalFiles;
+                DependsOnNETStandard = value.DependsOnNETStandard;
+                DependsOnSystemRuntime = value.DependsOnSystemRuntime;
+                FilesWritten = value.FilesWritten;
+                _relatedFiles = value.RelatedFiles;
+                _resolvedDependencyFiles = value.ResolvedDependencyFiles;
+                _resolvedFiles = value.ResolvedFiles;
+                _satelliteFiles = value.SatelliteFiles;
+                _scatterFiles = value.ScatterFiles;
+                _serializationAssemblyFiles = value.SerializationAssemblyFiles;
+                _suggestedRedirects = value.SuggestedRedirects;
+            }
+        }
+
         #endregion
         #region Logging
 
@@ -3091,7 +3118,10 @@ public override bool Execute()
                 if (connected)
                 {
                     // Client is connected to the RAR node, we can execute RAR task remotely
-                    // return client.Execute(); // TODO: Let it do something.
+                    ResolveAssemblyReferenceResult result = client.Execute(ResolveAssemblyReferenceInput);
+                    ResolveAssemblyReferenceOutput = result.Output;
+                    LogEvents(result.BuildEventArgs);
+                    return result.TaskResult;
                 }
             }
 
@@ -3117,6 +3147,49 @@ public override bool Execute()
             );
         }
 
+        private void LogEvents(IEnumerable<LazyFormattedBuildEventArgs> buildEventArgs)
+        {
+            foreach (LazyFormattedBuildEventArgs buildEvent in buildEventArgs)
+            {
+                switch (buildEvent)
+                {
+                    case CustomBuildEventArgs customBuildEvent:
+                        BuildEngine.LogCustomEvent(customBuildEvent);
+                        break;
+                    case BuildErrorEventArgs buildErrorEvent:
+                        BuildEngine.LogErrorEvent(buildErrorEvent);
+                        break;
+                    case BuildMessageEventArgs buildMessageEvent:
+                        BuildEngine.LogMessageEvent(buildMessageEvent);
+                        break;
+                    case BuildWarningEventArgs buildWarningEvent:
+                        BuildEngine.LogWarningEvent(buildWarningEvent);
+                        break;
+                    default:
+                        ErrorUtilities.ThrowInternalError("Unexpected build event"); 
+                        break;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Execute task. This metod is intended to use from RAR as a Service node
+        /// </summary>
+        /// <param name="input">Required input to the task</param>
+        /// <returns>If tasks was executed successfully</returns>
+        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceTaskInput input)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(input, nameof(input));
+
+            // Prepare environment
+            ResolveAssemblyReferenceInput = input;
+            // Since this method should be run from RAR node, we prevent it from creating loop.
+            UseResolveAssemblyReferenceService = false;
+
+            bool result = Execute();
+
+            return new ResolveAssemblyReferenceResult(result, ResolveAssemblyReferenceOutput);
+        }
         #endregion
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index b0c0e8bfaed..2f0607e8a7f 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -344,10 +344,19 @@
     <Compile Include="ResourceHandling\*.cs" />
     <Compile Include="ResolveAssemblyReferences\Client\RarClient.cs" />
     <Compile Include="ResolveAssemblyReferences\Contract\IResolveAssemblyReferenceTaskHandler.cs" />
+    <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceResult.cs" />
+    <Compile Include="ResolveAssemblyReferences\Contract\ReadOnlyTaskItem.cs" />
+    <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceRequest.cs" />
+    <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceResponse.cs" />
+    <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceTaskInput.cs" />
+    <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceTaskOutput.cs" />
+    <Compile Include="ResolveAssemblyReferences\LazyFromattedBuildEventArgsFormatter.cs" />
     <Compile Include="ResolveAssemblyReferences\RpcUtils.cs" />
     <Compile Include="ResolveAssemblyReferences\Server\RarController.cs" />
-    <Compile Include="ResolveAssemblyReferences\Services\RarTaskHandler.cs" />
+    <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceBuildEngine.cs" />
+    <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceSerializedTaskHandler.cs" />
     <Compile Include="ResolveAssemblyReferences\Server\ServerMutex.cs" />
+    <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceTaskHandler.cs" />
     <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
diff --git a/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs b/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
index 737bcf50496..8df2927c08b 100644
--- a/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
@@ -2,12 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.IO;
 using System.IO.Pipes;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;
 using StreamJsonRpc;
 
 
@@ -20,7 +20,7 @@ internal sealed class RarClient : IDisposable
         /// </summary>
         private const int DefaultConnectionTimeout = 300;
         private readonly IRarBuildEngine _rarBuildEngine;
-        private NamedPipeClientStream _clientStream;
+        private Stream _clientStream;
 
         public RarClient(IRarBuildEngine rarBuildEngine)
         {
@@ -35,7 +35,7 @@ internal bool Connect(int timeout)
                 return true;
 
             string pipeName = _rarBuildEngine.GetRarPipeName();
-            NamedPipeClientStream stream = _rarBuildEngine.GetRarClientStream(pipeName, timeout);
+            Stream stream = _rarBuildEngine.GetRarClientStream(pipeName, timeout);
 
             if (stream == null)
                 return false; // We couldn't connect
@@ -49,13 +49,14 @@ internal bool CreateNode()
             return _rarBuildEngine.CreateRarNode();
         }
 
-        internal object Execute()
+        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceTaskInput input)
         {
-            throw new NotImplementedException();
-            //using IResolveAssemblyReferenceTaskHandler client = GetRpcClient();
+            ResolveAssemblyReferenceRequest request = new ResolveAssemblyReferenceRequest(input);
+
+            IResolveAssemblyReferenceTaskHandler client = GetRpcClient();
 
             // TODO: Find out if there is any possibility of awaiting it.
-            //return client.GetNumber(parameter).GetAwaiter().GetResult();
+            return client.ExecuteAsync(request).GetAwaiter().GetResult();
         }
 
         private IResolveAssemblyReferenceTaskHandler GetRpcClient()
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs b/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs
index c8a74410837..40610718d96 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs
@@ -2,11 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Threading;
 using System.Threading.Tasks;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
     public interface IResolveAssemblyReferenceTaskHandler : IDisposable
     {
+        Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default);
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
new file mode 100644
index 00000000000..31055702e4f
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
@@ -0,0 +1,130 @@
+﻿using MessagePack;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Windows;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
+{
+    [MessagePackObject]
+    public partial class ReadOnlyTaskItem : ITaskItem2
+    {
+        [IgnoreMember]
+        public ICollection MetadataNames { get; }
+
+        [IgnoreMember]
+        public int MetadataCount { get; set; }
+
+        [Key(0)]
+        public string ItemSpec { get; set; }
+
+        [Key(1)]
+        public Dictionary<string, string> MetadataNameToValue { get; set; }
+
+      
+        [IgnoreMember]
+        public string EvaluatedIncludeEscaped
+        {
+            get => EscapingUtilities.UnescapeAll(ItemSpec);
+
+            set => throw new NotImplementedException();
+        }
+
+       
+
+        public ReadOnlyTaskItem(string itemSpec)
+        {
+            ItemSpec = itemSpec;
+            MetadataNameToValue = new Dictionary<string, string>();
+        }
+
+        public string GetMetadata(string metadataName)
+        {
+            string metadataValue = GetMetadataValueEscaped(metadataName);
+            return EscapingUtilities.UnescapeAll(metadataValue);
+        }
+
+        public void SetMetadata(string metadataName, string metadataValue)
+        {
+            MetadataNameToValue[metadataName] = metadataValue;
+        }
+
+        public void RemoveMetadata(string metadataName)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void CopyMetadataTo(ITaskItem destinationItem)
+        {
+            foreach (KeyValuePair<string, string> metadataNameWithValue in MetadataNameToValue)
+            {
+                destinationItem.SetMetadata(metadataNameWithValue.Key, metadataNameWithValue.Value);
+            }
+        }
+
+        public IDictionary CloneCustomMetadata()
+        {
+            throw new NotImplementedException();
+        }
+
+        public string GetMetadataValueEscaped(string metadataName)
+        {
+            bool isFound = MetadataNameToValue.TryGetValue(metadataName, out string metadataValue);
+            return isFound ? metadataValue : string.Empty;
+        }
+
+        public void SetMetadataValueLiteral(string metadataName, string metadataValue)
+        {
+            throw new NotImplementedException();
+        }
+
+        public IDictionary CloneCustomMetadataEscaped()
+        {
+            throw new NotImplementedException();
+        }
+
+        internal static ReadOnlyTaskItem[] CreateArray(ITaskItem[] items)
+        {
+            if (items == null)
+                return null;
+
+            ReadOnlyTaskItem[] readOnlyTaskItems = new ReadOnlyTaskItem[items.Length];
+            for (int i = 0; i < items.Length; i++)
+            {
+                if (items[i] == null)
+                    continue;
+
+                ReadOnlyTaskItem readOnlyTaskItem = new ReadOnlyTaskItem(items[i].ItemSpec);
+                items[i].CopyMetadataTo(readOnlyTaskItem);
+                readOnlyTaskItems[i] = readOnlyTaskItem;
+            }
+
+            return readOnlyTaskItems;
+        }
+
+        internal static ITaskItem[] ToTaskItem(ReadOnlyTaskItem[] readOnlyTaskItems)
+        {
+            if (readOnlyTaskItems == null)
+                return null;
+
+            ITaskItem[] items = new ITaskItem[readOnlyTaskItems.Length];
+            for (int i = 0; i < items.Length; i++)
+            {
+                if (readOnlyTaskItems[i] == null)
+                    continue;
+
+                TaskItem item = new TaskItem(readOnlyTaskItems[i].ItemSpec);
+                readOnlyTaskItems[i].CopyMetadataTo(item);
+                items[i] = item;
+            }
+
+            return items;
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceInput.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceInput.cs
deleted file mode 100644
index f20e0967a51..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceInput.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿using Microsoft.Build.Framework;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
-{
-    public class ResolveAssemblyReferenceInput
-    {
-        public string[] AllowedAssemblyExtensions { get; internal set; }
-        public string[] AllowedRelatedFileExtensions { get; internal set; }
-        public string AppConfigFile { get; internal set; }
-        public ITaskItem[] Assemblies { get; internal set; }
-        public ITaskItem[] AssemblyFiles { get; internal set; }
-        public bool AutoUnify { get; internal set; }
-        public string[] CandidateAssemblyFiles { get; internal set; }
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get; internal set; }
-        public bool FindDependencies { get; internal set; }
-        public bool FindDependenciesOfExternallyResolvedReferences { get; internal set; }
-        public bool FindRelatedFiles { get; internal set; }
-        public bool FindSatellites { get; internal set; }
-        public bool FindSerializationAssemblies { get; internal set; }
-        public ITaskItem[] FullFrameworkAssemblyTables { get; internal set; }
-        public string[] FullFrameworkFolders { get; internal set; }
-        public string[] FullTargetFrameworkSubsetNames { get; internal set; }
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get; internal set; }
-        public bool IgnoreDefaultInstalledAssemblyTables { get; internal set; }
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; internal set; }
-        public bool IgnoreVersionForFrameworkReferences { get; internal set; }
-        public ITaskItem[] InstalledAssemblySubsetTables { get; internal set; }
-        public ITaskItem[] InstalledAssemblyTables { get; internal set; }
-        public string[] LatestTargetFrameworkDirectories { get; internal set; }
-        public string ProfileName { get; internal set; }
-        public string[] SearchPaths { get; internal set; }
-        public bool Silent { get; internal set; }
-        public string StateFile { get; internal set; }
-        public bool SupportsBindingRedirectGeneration { get; internal set; }
-        public string TargetedRuntimeVersion { get; internal set; }
-        public string[] TargetFrameworkDirectories { get; internal set; }
-        public string TargetFrameworkMoniker { get; internal set; }
-        public string TargetFrameworkMonikerDisplayName { get; internal set; }
-        public string[] TargetFrameworkSubsets { get; internal set; }
-        public string TargetFrameworkVersion { get; internal set; }
-        public string TargetProcessorArchitecture { get; internal set; }
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; internal set; }
-        public bool UseResolveAssemblyReferenceService { get; internal set; }
-        public string WarnOrErrorOnTargetArchitectureMismatch { get; internal set; }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
new file mode 100644
index 00000000000..fada41c8f13
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
@@ -0,0 +1,177 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using MessagePack;
+using System.IO;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
+{
+    [MessagePackObject]
+    public class ResolveAssemblyReferenceRequest
+    {
+        public ResolveAssemblyReferenceRequest() { }
+        internal ResolveAssemblyReferenceRequest(ResolveAssemblyReferenceTaskInput input)
+        {
+            AllowedAssemblyExtensions = input.AllowedAssemblyExtensions;
+            AllowedRelatedFileExtensions = input.AllowedRelatedFileExtensions;
+            AppConfigFile = input.AppConfigFile;
+            Assemblies = ReadOnlyTaskItem.CreateArray(input.Assemblies);
+            AssemblyFiles = ReadOnlyTaskItem.CreateArray(input.AssemblyFiles);
+            AutoUnify = input.AutoUnify;
+            CandidateAssemblyFiles = input.CandidateAssemblyFiles;
+            CopyLocalDependenciesWhenParentReferenceInGac = input.CopyLocalDependenciesWhenParentReferenceInGac;
+            DoNotCopyLocalIfInGac = input.DoNotCopyLocalIfInGac;
+            FindDependencies = input.FindDependencies;
+            FindDependenciesOfExternallyResolvedReferences = input.FindDependenciesOfExternallyResolvedReferences;
+            FindRelatedFiles = input.FindRelatedFiles;
+            FindSatellites = input.FindSatellites;
+            FindSerializationAssemblies = input.FindSerializationAssemblies;
+            FullFrameworkAssemblyTables = ReadOnlyTaskItem.CreateArray(input.FullFrameworkAssemblyTables);
+            FullFrameworkFolders = input.FullFrameworkFolders;
+            FullTargetFrameworkSubsetNames = input.FullTargetFrameworkSubsetNames;
+            IgnoreDefaultInstalledAssemblySubsetTables = input.IgnoreDefaultInstalledAssemblySubsetTables;
+            IgnoreDefaultInstalledAssemblyTables = input.IgnoreDefaultInstalledAssemblyTables;
+            IgnoreTargetFrameworkAttributeVersionMismatch = input.IgnoreTargetFrameworkAttributeVersionMismatch;
+            IgnoreVersionForFrameworkReferences = input.IgnoreVersionForFrameworkReferences;
+            InstalledAssemblySubsetTables = ReadOnlyTaskItem.CreateArray(input.InstalledAssemblySubsetTables);
+            InstalledAssemblyTables = ReadOnlyTaskItem.CreateArray(input.InstalledAssemblyTables);
+            LatestTargetFrameworkDirectories = input.LatestTargetFrameworkDirectories;
+            ProfileName = input.ProfileName;
+            ResolvedSDKReferences = ReadOnlyTaskItem.CreateArray(input.ResolvedSDKReferences);
+            SearchPaths = input.SearchPaths;
+            Silent = input.Silent;
+            StateFile = Path.GetFullPath(input.StateFile);
+            SupportsBindingRedirectGeneration = input.SupportsBindingRedirectGeneration;
+            TargetedRuntimeVersion = input.TargetedRuntimeVersion;
+            TargetFrameworkDirectories = input.TargetFrameworkDirectories;
+            TargetFrameworkMoniker = input.TargetFrameworkMoniker;
+            TargetFrameworkMonikerDisplayName = input.TargetFrameworkMonikerDisplayName;
+            TargetFrameworkSubsets = input.TargetFrameworkSubsets;
+            TargetFrameworkVersion = input.TargetFrameworkVersion;
+            TargetProcessorArchitecture = input.TargetProcessorArchitecture;
+            UnresolveFrameworkAssembliesFromHigherFrameworks = input.UnresolveFrameworkAssembliesFromHigherFrameworks;
+            UseResolveAssemblyReferenceService = input.UseResolveAssemblyReferenceService;
+            WarnOrErrorOnTargetArchitectureMismatch = input.WarnOrErrorOnTargetArchitectureMismatch;
+        }
+
+        [Key(0)]
+        public string[] AllowedAssemblyExtensions { get; set; }
+
+        [Key(1)]
+        public string[] AllowedRelatedFileExtensions { get; set; }
+
+        [Key(2)]
+        public string AppConfigFile { get; set; }
+
+        [Key(3)]
+        public ReadOnlyTaskItem[] Assemblies { get; set; }
+
+        [Key(4)]
+        public ReadOnlyTaskItem[] AssemblyFiles { get; set; }
+
+        [Key(5)]
+        public bool AutoUnify { get; set; }
+
+        [Key(6)]
+        public string[] CandidateAssemblyFiles { get; set; }
+
+        [Key(7)]
+        public bool CopyLocalDependenciesWhenParentReferenceInGac { get; set; }
+
+        [Key(8)]
+        public bool DoNotCopyLocalIfInGac { get; set; }
+
+        [Key(9)]
+        public bool FindDependencies { get; set; }
+
+        [Key(10)]
+        public bool FindDependenciesOfExternallyResolvedReferences { get; set; }
+
+        [Key(11)]
+        public bool FindRelatedFiles { get; set; }
+
+        [Key(12)]
+        public bool FindSatellites { get; set; }
+
+        [Key(13)]
+        public bool FindSerializationAssemblies { get; set; }
+
+        [Key(14)]
+        public ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get; set; }
+
+        [Key(15)]
+        public string[] FullFrameworkFolders { get; set; }
+
+        [Key(16)]
+        public string[] FullTargetFrameworkSubsetNames { get; set; }
+
+        [Key(17)]
+        public bool IgnoreDefaultInstalledAssemblySubsetTables { get; set; }
+
+        [Key(18)]
+        public bool IgnoreDefaultInstalledAssemblyTables { get; set; }
+
+        [Key(19)]
+        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; set; }
+
+        [Key(20)]
+        public bool IgnoreVersionForFrameworkReferences { get; set; }
+
+        [Key(21)]
+        public ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get; set; }
+
+        [Key(22)]
+        public ReadOnlyTaskItem[] InstalledAssemblyTables { get; set; }
+
+        [Key(23)]
+        public string[] LatestTargetFrameworkDirectories { get; set; }
+
+        [Key(24)]
+        public string ProfileName { get; set; }
+
+        [Key(25)]
+        public ReadOnlyTaskItem[] ResolvedSDKReferences { get; set; }
+
+        [Key(26)]
+        public string[] SearchPaths { get; set; }
+
+        [Key(27)]
+        public bool Silent { get; set; }
+
+        [Key(28)]
+        public string StateFile { get; set; }
+
+        [Key(29)]
+        public bool SupportsBindingRedirectGeneration { get; set; }
+
+        [Key(30)]
+        public string TargetedRuntimeVersion { get; set; }
+
+        [Key(31)]
+        public string[] TargetFrameworkDirectories { get; set; }
+
+        [Key(32)]
+        public string TargetFrameworkMoniker { get; set; }
+
+        [Key(33)]
+        public string TargetFrameworkMonikerDisplayName { get; set; }
+
+        [Key(34)]
+        public string[] TargetFrameworkSubsets { get; set; }
+
+        [Key(35)]
+        public string TargetFrameworkVersion { get; set; }
+
+        [Key(36)]
+        public string TargetProcessorArchitecture { get; set; }
+
+        [Key(37)]
+        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; set; }
+
+        [Key(38)]
+        public bool UseResolveAssemblyReferenceService { get; set; }
+
+        [Key(39)]
+        public string WarnOrErrorOnTargetArchitectureMismatch { get; set; }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
new file mode 100644
index 00000000000..aa78c3fc168
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
@@ -0,0 +1,63 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using MessagePack;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
+{
+    [MessagePackObject]
+    public sealed class ResolveAssemblyReferenceResponse
+    {
+        public ResolveAssemblyReferenceResponse()
+        {
+        }
+
+        internal ResolveAssemblyReferenceResponse(ResolveAssemblyReferenceTaskOutput output)
+        {
+            CopyLocalFiles = ReadOnlyTaskItem.CreateArray(output.CopyLocalFiles);
+            DependsOnNETStandard = output.DependsOnNETStandard;
+            DependsOnSystemRuntime = output.DependsOnSystemRuntime;
+            FilesWritten = ReadOnlyTaskItem.CreateArray(output.FilesWritten);
+            RelatedFiles = ReadOnlyTaskItem.CreateArray(output.RelatedFiles);
+            ResolvedDependencyFiles = ReadOnlyTaskItem.CreateArray(output.ResolvedDependencyFiles);
+            ResolvedFiles = ReadOnlyTaskItem.CreateArray(output.ResolvedFiles);
+            SatelliteFiles = ReadOnlyTaskItem.CreateArray(output.SatelliteFiles);
+            ScatterFiles = ReadOnlyTaskItem.CreateArray(output.ScatterFiles);
+            SerializationAssemblyFiles = ReadOnlyTaskItem.CreateArray(output.SerializationAssemblyFiles);
+            SuggestedRedirects = ReadOnlyTaskItem.CreateArray(output.SuggestedRedirects);
+        }
+
+        [Key(0)]
+        public ReadOnlyTaskItem[] CopyLocalFiles { get; set; }
+
+        [Key(1)]
+        public string DependsOnNETStandard { get; set; }
+
+        [Key(2)]
+        public string DependsOnSystemRuntime { get; set; }
+
+        [Key(3)]
+        public ReadOnlyTaskItem[] FilesWritten { get; set; }
+
+        [Key(4)]
+        public ReadOnlyTaskItem[] RelatedFiles { get; set; }
+
+        [Key(5)]
+        public ReadOnlyTaskItem[] ResolvedDependencyFiles { get; set; }
+
+        [Key(6)]
+        public ReadOnlyTaskItem[] ResolvedFiles { get; set; }
+
+        [Key(7)]
+        public ReadOnlyTaskItem[] SatelliteFiles { get; set; }
+
+        [Key(8)]
+        public ReadOnlyTaskItem[] ScatterFiles { get; set; }
+
+        [Key(9)]
+        public ReadOnlyTaskItem[] SerializationAssemblyFiles { get; set; }
+
+        [Key(10)]
+        public ReadOnlyTaskItem[] SuggestedRedirects { get; set; }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
new file mode 100644
index 00000000000..e0450eaea9f
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
@@ -0,0 +1,34 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using MessagePack;
+using Microsoft.Build.Framework;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
+{
+    [MessagePackObject]
+    public sealed class ResolveAssemblyReferenceResult
+    {
+        public ResolveAssemblyReferenceResult()
+        {
+        }
+
+        internal ResolveAssemblyReferenceResult(bool taskResult, ResolveAssemblyReferenceTaskOutput output)
+        {
+            TaskResult = taskResult;
+            Response = new ResolveAssemblyReferenceResponse(output);
+        }
+
+        [Key(0)]
+        public bool TaskResult { get; set; }
+        [Key(1)]
+        public ResolveAssemblyReferenceResponse Response { get; set; }
+
+        [Key(2)]
+        public List<LazyFormattedBuildEventArgs> BuildEventArgs { get; set; }
+
+        [IgnoreMember]
+        internal ResolveAssemblyReferenceTaskOutput Output => new ResolveAssemblyReferenceTaskOutput(Response);
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskInput.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskInput.cs
new file mode 100644
index 00000000000..cbc462a4103
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskInput.cs
@@ -0,0 +1,138 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
+{
+    internal class ResolveAssemblyReferenceTaskInput
+    {
+        public ResolveAssemblyReferenceTaskInput()
+        {
+        }
+
+        public ResolveAssemblyReferenceTaskInput(ResolveAssemblyReferenceRequest request)
+        {
+            AllowedAssemblyExtensions = request.AllowedAssemblyExtensions;
+            AllowedRelatedFileExtensions = request.AllowedRelatedFileExtensions;
+            AppConfigFile = request.AppConfigFile;
+            Assemblies = request.Assemblies;
+            AssemblyFiles = request.AssemblyFiles;
+            AutoUnify = request.AutoUnify;
+            CandidateAssemblyFiles = request.CandidateAssemblyFiles;
+            CopyLocalDependenciesWhenParentReferenceInGac = request.CopyLocalDependenciesWhenParentReferenceInGac;
+            DoNotCopyLocalIfInGac = request.DoNotCopyLocalIfInGac;
+            FindDependencies = request.FindDependencies;
+            FindDependenciesOfExternallyResolvedReferences = request.FindDependenciesOfExternallyResolvedReferences;
+            FindRelatedFiles = request.FindRelatedFiles;
+            FindSatellites = request.FindSatellites;
+            FindSerializationAssemblies = request.FindSerializationAssemblies;
+            FullFrameworkAssemblyTables = request.FullFrameworkAssemblyTables;
+            FullFrameworkFolders = request.FullFrameworkFolders;
+            FullTargetFrameworkSubsetNames = request.FullTargetFrameworkSubsetNames;
+            IgnoreDefaultInstalledAssemblySubsetTables = request.IgnoreDefaultInstalledAssemblySubsetTables;
+            IgnoreDefaultInstalledAssemblyTables = request.IgnoreDefaultInstalledAssemblyTables;
+            IgnoreTargetFrameworkAttributeVersionMismatch = request.IgnoreTargetFrameworkAttributeVersionMismatch;
+            IgnoreVersionForFrameworkReferences = request.IgnoreVersionForFrameworkReferences;
+            InstalledAssemblySubsetTables = request.InstalledAssemblySubsetTables;
+            InstalledAssemblyTables = request.InstalledAssemblyTables;
+            LatestTargetFrameworkDirectories = request.LatestTargetFrameworkDirectories;
+            ProfileName = request.ProfileName;
+            ResolvedSDKReferences = request.ResolvedSDKReferences;
+            SearchPaths = request.SearchPaths;
+            Silent = request.Silent;
+            StateFile = request.StateFile;
+            SupportsBindingRedirectGeneration = request.SupportsBindingRedirectGeneration;
+            TargetedRuntimeVersion = request.TargetedRuntimeVersion;
+            TargetFrameworkDirectories = request.TargetFrameworkDirectories;
+            TargetFrameworkMoniker = request.TargetFrameworkMoniker;
+            TargetFrameworkMonikerDisplayName = request.TargetFrameworkMonikerDisplayName;
+            TargetFrameworkSubsets = request.TargetFrameworkSubsets;
+            TargetFrameworkVersion = request.TargetFrameworkVersion;
+            TargetProcessorArchitecture = request.TargetProcessorArchitecture;
+            UnresolveFrameworkAssembliesFromHigherFrameworks = request.UnresolveFrameworkAssembliesFromHigherFrameworks;
+            UseResolveAssemblyReferenceService = request.UseResolveAssemblyReferenceService;
+            WarnOrErrorOnTargetArchitectureMismatch = request.WarnOrErrorOnTargetArchitectureMismatch;
+        }
+
+        public string[] AllowedAssemblyExtensions { get; set; }
+
+        public string[] AllowedRelatedFileExtensions { get; set; }
+
+        public string AppConfigFile { get; set; }
+
+        public ITaskItem[] Assemblies { get; set; }
+
+        public ITaskItem[] AssemblyFiles { get; set; }
+
+        public bool AutoUnify { get; set; }
+
+        public string[] CandidateAssemblyFiles { get; set; }
+
+        public bool CopyLocalDependenciesWhenParentReferenceInGac { get; set; }
+
+        public bool DoNotCopyLocalIfInGac { get; set; }
+
+        public bool FindDependencies { get; set; }
+
+        public bool FindDependenciesOfExternallyResolvedReferences { get; set; }
+
+        public bool FindRelatedFiles { get; set; }
+
+        public bool FindSatellites { get; set; }
+
+        public bool FindSerializationAssemblies { get; set; }
+
+        public ITaskItem[] FullFrameworkAssemblyTables { get; set; }
+
+        public string[] FullFrameworkFolders { get; set; }
+
+        public string[] FullTargetFrameworkSubsetNames { get; set; }
+
+        public bool IgnoreDefaultInstalledAssemblySubsetTables { get; set; }
+
+        public bool IgnoreDefaultInstalledAssemblyTables { get; set; }
+
+        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; set; }
+
+        public bool IgnoreVersionForFrameworkReferences { get; set; }
+
+        public ITaskItem[] InstalledAssemblySubsetTables { get; set; }
+
+        public ITaskItem[] InstalledAssemblyTables { get; set; }
+
+        public string[] LatestTargetFrameworkDirectories { get; set; }
+
+        public string ProfileName { get; set; }
+
+        public ITaskItem[] ResolvedSDKReferences { get; set; }
+
+        public string[] SearchPaths { get; set; }
+
+        public bool Silent { get; set; }
+
+        public string StateFile { get; set; }
+
+        public bool SupportsBindingRedirectGeneration { get; set; }
+
+        public string TargetedRuntimeVersion { get; set; }
+
+        public string[] TargetFrameworkDirectories { get; set; }
+
+        public string TargetFrameworkMoniker { get; set; }
+
+        public string TargetFrameworkMonikerDisplayName { get; set; }
+
+        public string[] TargetFrameworkSubsets { get; set; }
+
+        public string TargetFrameworkVersion { get; set; }
+
+        public string TargetProcessorArchitecture { get; set; }
+
+        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; set; }
+
+        public bool UseResolveAssemblyReferenceService { get; set; }
+
+        public string WarnOrErrorOnTargetArchitectureMismatch { get; set; }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs
new file mode 100644
index 00000000000..8b6aaec33ae
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs
@@ -0,0 +1,52 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using MessagePack;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
+{
+    internal sealed class ResolveAssemblyReferenceTaskOutput
+    {
+        public ResolveAssemblyReferenceTaskOutput()
+        {
+        }
+
+        public ResolveAssemblyReferenceTaskOutput(ResolveAssemblyReferenceResponse response)
+        {
+            CopyLocalFiles = ReadOnlyTaskItem.ToTaskItem(response.CopyLocalFiles);
+            DependsOnNETStandard = response.DependsOnNETStandard;
+            DependsOnSystemRuntime = response.DependsOnSystemRuntime;
+            FilesWritten = ReadOnlyTaskItem.ToTaskItem(response.FilesWritten);
+            RelatedFiles = ReadOnlyTaskItem.ToTaskItem(response.RelatedFiles);
+            ResolvedDependencyFiles = ReadOnlyTaskItem.ToTaskItem(response.ResolvedDependencyFiles);
+            ResolvedFiles = ReadOnlyTaskItem.ToTaskItem(response.ResolvedFiles);
+            SatelliteFiles = ReadOnlyTaskItem.ToTaskItem(response.SatelliteFiles);
+            ScatterFiles = ReadOnlyTaskItem.ToTaskItem(response.ScatterFiles);
+            SerializationAssemblyFiles = ReadOnlyTaskItem.ToTaskItem(response.SerializationAssemblyFiles);
+            SuggestedRedirects = ReadOnlyTaskItem.ToTaskItem(response.SuggestedRedirects);
+        }
+
+        public ITaskItem[] CopyLocalFiles { get; set; }
+
+        public string DependsOnNETStandard { get; set; }
+
+        public string DependsOnSystemRuntime { get; set; }
+
+        public ITaskItem[] FilesWritten { get; set; }
+
+        public ITaskItem[] RelatedFiles { get; set; }
+
+        public ITaskItem[] ResolvedDependencyFiles { get; set; }
+
+        public ITaskItem[] ResolvedFiles { get; set; }
+
+        public ITaskItem[] SatelliteFiles { get; set; }
+
+        public ITaskItem[] ScatterFiles { get; set; }
+
+        public ITaskItem[] SerializationAssemblyFiles { get; set; }
+
+        public ITaskItem[] SuggestedRedirects { get; set; }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/LazyFromattedBuildEventArgsFormatter.cs b/src/Tasks/ResolveAssemblyReferences/LazyFromattedBuildEventArgsFormatter.cs
new file mode 100644
index 00000000000..eb608ba0c71
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/LazyFromattedBuildEventArgsFormatter.cs
@@ -0,0 +1,57 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using MessagePack;
+using MessagePack.Formatters;
+using Microsoft.Build.Framework;
+using Nerdbank.Streams;
+using System;
+using System.Buffers;
+using System.IO;
+using System.Runtime.Serialization;
+using System.Runtime.Serialization.Formatters.Binary;
+using System.Xml.Serialization;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences
+{
+    internal sealed class LazyFromattedBuildEventArgsFormatter : IMessagePackFormatter<LazyFormattedBuildEventArgs>
+    {
+        internal static readonly IMessagePackFormatter Instance = new LazyFromattedBuildEventArgsFormatter();
+
+        private LazyFromattedBuildEventArgsFormatter() { }
+
+        public LazyFormattedBuildEventArgs Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            ReadOnlySequence<byte>? buffer = reader.ReadBytes();
+
+            if (!buffer.HasValue)
+                return null;
+            try
+            {
+                // TODO: Remove this!
+                IFormatter formatter = new BinaryFormatter();
+                return (LazyFormattedBuildEventArgs)formatter.Deserialize(buffer.Value.AsStream());
+            }
+            catch (Exception)
+            {
+                return null;
+            }
+        }
+
+        public void Serialize(ref MessagePackWriter writer, LazyFormattedBuildEventArgs value, MessagePackSerializerOptions options)
+        {
+            if (value is null)
+            {
+                writer.Write((byte[])null);
+                return;
+            }
+
+            using MemoryStream stream = new MemoryStream();
+
+            // TODO: Remove this!
+            IFormatter formatter = new BinaryFormatter();
+            formatter.Serialize(stream, value);
+            writer.Write(stream.ToArray());
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs b/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
index e8d2d17e995..3d771bea55f 100644
--- a/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
+++ b/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
@@ -1,8 +1,12 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.IO;
-
+using MessagePack;
+using MessagePack.Formatters;
+using MessagePack.Resolvers;
+using Microsoft.Build.Framework;
 using Nerdbank.Streams;
 using StreamJsonRpc;
 
@@ -13,7 +17,22 @@ internal static class RpcUtils
     {
         internal static IJsonRpcMessageHandler GetRarMessageHandler(Stream stream)
         {
-            return new LengthHeaderMessageHandler(stream.UsePipe(), new MessagePackFormatter());
+            MessagePackFormatter formatter = new MessagePackFormatter();
+
+            IFormatterResolver resolver = CompositeResolver.Create(
+                new[]
+                {
+                    LazyFromattedBuildEventArgsFormatter.Instance
+                },
+                new[]
+                {
+                    StandardResolver.Instance
+                }
+            );
+            MessagePackSerializerOptions options = MessagePackSerializerOptions.Standard.WithResolver(resolver);
+
+            formatter.SetMessagePackSerializerOptions(options);
+            return new LengthHeaderMessageHandler(stream.UsePipe(), formatter);
         }
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
index 0e0ee9081e1..36907466c8c 100644
--- a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
@@ -42,11 +42,17 @@ public sealed class RarController
         /// </summary>
         private readonly TimeSpan Timeout = TimeSpan.FromMinutes(15);
 
+        /// <summary>
+        /// Construcotr for <see cref="RarController"/>
+        /// </summary>
+        /// <param name="pipeName">Name of pipe over which all comunication should go</param>
+        /// <param name="namedPipeServerFactory">Factor for server stream</param>
+        /// <param name="timeout">Timeout which should be used for communication</param>
         public RarController(
             string pipeName,
             Func<string, int?, int?, int, bool, NamedPipeServerStream> namedPipeServerFactory,
             TimeSpan? timeout = null)
-            : this(pipeName, namedPipeServerFactory, timeout: timeout, resolveAssemblyReferenceTaskHandler: new RarTaskHandler())
+            : this(pipeName, namedPipeServerFactory, timeout: timeout, resolveAssemblyReferenceTaskHandler: new ResolveAssemblyReferenceSerializedTaskHandler())
         {
         }
 
@@ -91,7 +97,7 @@ public async Task<int> StartAsync(CancellationToken cancellationToken = default)
 
         private async Task HandleClientAsync(Stream serverStream, CancellationToken cancellationToken = default)
         {
-            using JsonRpc server = GetRpcServer(serverStream, _resolveAssemblyReferenceTaskHandler);
+            JsonRpc server = GetRpcServer(serverStream, _resolveAssemblyReferenceTaskHandler);
             server.StartListening();
 
             try
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/RarTaskHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/RarTaskHandler.cs
deleted file mode 100644
index 90e9ca795de..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Services/RarTaskHandler.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Threading.Tasks;
-
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
-{
-    internal class RarTaskHandler : IResolveAssemblyReferenceTaskHandler
-    {
-        public void Dispose()
-        {
-            // For RPC dispose
-        }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs
new file mode 100644
index 00000000000..e90c1b39664
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceBuildEngine.cs
@@ -0,0 +1,102 @@
+﻿using Microsoft.Build.Framework;
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
+{
+    internal sealed class ResolveAssemblyReferenceBuildEngine : IBuildEngine7
+    {
+        public List<LazyFormattedBuildEventArgs> BuildEvent { get; } = new List<LazyFormattedBuildEventArgs>();
+
+        public bool AllowFailureWithoutError { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
+
+        public bool IsRunningMultipleNodes => throw new NotImplementedException();
+
+        public bool ContinueOnError => throw new NotImplementedException();
+
+        public int LineNumberOfTaskNode => 0;
+
+        public int ColumnNumberOfTaskNode => 0;
+
+        public string ProjectFileOfTaskNode => string.Empty;
+
+        public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion)
+        {
+            throw new NotImplementedException();
+        }
+
+        public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs)
+        {
+            throw new NotImplementedException();
+        }
+
+        public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs)
+        {
+            throw new NotImplementedException();
+        }
+
+        public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion)
+        {
+            throw new NotImplementedException();
+        }
+
+        public IReadOnlyDictionary<string, string> GetGlobalProperties()
+        {
+            throw new NotImplementedException();
+        }
+
+        public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void LogCustomEvent(CustomBuildEventArgs e)
+        {
+            BuildEvent.Add(e);
+        }
+
+        public void LogErrorEvent(BuildErrorEventArgs e)
+        {
+            BuildEvent.Add(e);
+        }
+
+        public void LogMessageEvent(BuildMessageEventArgs e)
+        {
+            BuildEvent.Add(e);
+        }
+
+        public void LogTelemetry(string eventName, IDictionary<string, string> properties)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void LogWarningEvent(BuildWarningEventArgs e)
+        {
+            BuildEvent.Add(e);
+        }
+
+        public void Reacquire()
+        {
+            throw new NotImplementedException();
+        }
+
+        public void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection)
+        {
+            throw new NotImplementedException();
+        }
+
+        public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void Yield()
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceSerializedTaskHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceSerializedTaskHandler.cs
new file mode 100644
index 00000000000..eb066d21ead
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceSerializedTaskHandler.cs
@@ -0,0 +1,41 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+using Microsoft.VisualStudio.Threading;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
+{
+    internal sealed class ResolveAssemblyReferenceSerializedTaskHandler : IResolveAssemblyReferenceTaskHandler
+    {
+        private const int MaxNumberOfConcurentClients = 1;
+
+        private readonly IResolveAssemblyReferenceTaskHandler _taskHandler;
+        private readonly AsyncSemaphore _semaphore;
+
+        public ResolveAssemblyReferenceSerializedTaskHandler(IResolveAssemblyReferenceTaskHandler taskHandler)
+        {
+            _taskHandler = taskHandler;
+            _semaphore = new AsyncSemaphore(MaxNumberOfConcurentClients);
+        }
+
+        public ResolveAssemblyReferenceSerializedTaskHandler() : this(new ResolveAssemblyReferenceTaskHandler())
+        {
+        }
+
+        public async Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default)
+        {
+            using (await _semaphore.EnterAsync(cancellationToken))
+            {
+                return await _taskHandler.ExecuteAsync(input, cancellationToken);
+            }
+        }
+
+        public void Dispose()
+        {
+            _semaphore?.Dispose();
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceTaskHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceTaskHandler.cs
new file mode 100644
index 00000000000..5e323567a8d
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceTaskHandler.cs
@@ -0,0 +1,32 @@
+﻿using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
+{
+    internal sealed class ResolveAssemblyReferenceTaskHandler : IResolveAssemblyReferenceTaskHandler
+    {
+        public Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default)
+        {
+            ResolveAssemblyReferenceTaskInput taskInput = new ResolveAssemblyReferenceTaskInput(input);
+            ResolveAssemblyReferenceBuildEngine buildEngine = new ResolveAssemblyReferenceBuildEngine();
+            ResolveAssemblyReference task = new ResolveAssemblyReference()
+            {
+                BuildEngine = buildEngine
+            };
+
+            ResolveAssemblyReferenceResult result = task.Execute(taskInput);
+            result.BuildEventArgs = buildEngine.BuildEvent;
+
+            return Task.FromResult(result);
+        }
+
+        public void Dispose()
+        {
+        }
+    }
+}
