diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index bf668ed0950..b389d8c784c 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -655,6 +655,424 @@ public void OneAttributePositionalAndNamedParamsVisualBasic()
             File.Delete(task.OutputFile.ItemSpec);
         }
 
+        /// <summary>
+        /// A type can be declared for a positional arguments using the metadata
+        /// "_Parameter1_TypeName" where the value is the full type name.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeForPositionalParameter()
+        {
+            TaskItem attribute = new("CLSCompliantAttribute");
+            attribute.SetMetadata("_Parameter1", "True");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.Boolean");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: CLSCompliantAttribute(true)]"
+            );
+        }
+
+        /// <summary>
+        /// A type can be declared for a positional arguments using the metadata
+        /// "Foo_TypeName" where the value is the full type name.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeForNamedParameter()
+        {
+            TaskItem attribute = new TaskItem("TestAttribute");
+            attribute.SetMetadata("BoolArgument", "False");
+            attribute.SetMetadata("BoolArgument_TypeName", "System.Boolean");
+            attribute.SetMetadata("Int32Argument", "42");
+            attribute.SetMetadata("Int32Argument_TypeName", "System.Int32");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(Int32Argument=42, BoolArgument=false)]"
+            );
+        }
+
+        /// <summary>
+        /// Metadata that looks like a declared type, but doesn't have corresponding named parameter
+        /// metadata should be treated as another named parameter for backward-compatibility.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypedWithoutCorrespondingNamedParameter()
+        {
+            TaskItem attribute = new TaskItem("TestAttribute");
+            attribute.SetMetadata("BoolArgument", "False");
+            attribute.SetMetadata("BoolArgument_TypeName", "System.Boolean");
+            attribute.SetMetadata("Int32Argument_TypeName", "System.Int32");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(Int32Argument_TypeName=""System.Int32"", BoolArgument=false)]"
+            );
+        }
+
+        /// <summary>
+        /// An unknown type name for a parameter should cause a failure.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeIsUnknown()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("TestParameter", "99");
+            attribute.SetMetadata("TestParameter_TypeName", "Foo.Bar");
+
+            ExecuteAndVerifyFailure(
+                CreateTask("c#", attribute),
+                "MSB3715"
+            );
+        }
+
+        /// <summary>
+        /// A parameter value that cannot be converted to the declared type should cause a failure.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeCausesConversionFailure()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("TestParameter", "99");
+            attribute.SetMetadata("TestParameter_TypeName", "System.Boolean");
+
+            ExecuteAndVerifyFailure(
+                CreateTask("c#", attribute),
+                "MSB3716"
+            );
+        }
+
+        /// <summary>
+        /// Parameter value that is too large for the declared data type should cause a failure.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeCausesOverflow()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("TestParameter", "1000");
+            attribute.SetMetadata("TestParameter_TypeName", "System.Byte");
+
+            ExecuteAndVerifyFailure(
+                CreateTask("c#", attribute),
+                "MSB3716"
+            );
+        }
+
+        /// <summary>
+        /// The metadata value should convert successfully to an enum.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeIsEnum()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "Local");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.DateTimeKind");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(System.DateTimeKind.Local)]"
+            );
+        }
+
+        /// <summary>
+        /// The metadata value should convert successfully to a type name in C#.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeIsTypeInCSharp()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "System.Console");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.Type");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(typeof(System.Console))]"
+            );
+        }
+
+        /// <summary>
+        /// The metadata value should convert successfully to a type name in VB.NET.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeIsTypeInVB()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "System.Console");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.Type");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("visualbasic", attribute),
+                @"<Assembly: TestAttribute(GetType(System.Console))>"
+            );
+        }
+
+        /// <summary>
+        /// Arrays are not supported for declared types. Literal arguments need to be used instead.
+        /// This test confirms that it fails instead of falling back to being treated as a string.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeOfArrayIsNotSupported()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "1,2,3");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.Int32[]");
+
+            ExecuteAndVerifyFailure(
+                CreateTask("c#", attribute),
+                "MSB3716"
+            );
+        }
+
+        /// <summary>
+        /// The exact code for a positional argument can be specified using
+        /// the metadata "_Parameter1_IsLiteral" with a value of "true".
+        /// </summary>
+        [Fact]
+        public void LiteralPositionalParameter()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "42 /* A comment */");
+            attribute.SetMetadata("_Parameter1_IsLiteral", "true");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(42 /* A comment */)]"
+            );
+        }
+
+        /// <summary>
+        /// The exact code for a named argument can be specified using
+        /// the metadata "Foo_IsLiteral" with a value of "true".
+        /// </summary>
+        [Fact]
+        public void LiteralNamedParameter()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("TestParameter", "42 /* A comment */");
+            attribute.SetMetadata("TestParameter_IsLiteral", "true");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(TestParameter=42 /* A comment */)]"
+            );
+        }
+
+        /// <summary>
+        /// The type of a positional argument can be inferred
+        /// if the type of the attribute is in mscorlib.
+        /// </summary>
+        [Fact]
+        public void InferredTypeForPositionalParameter()
+        {
+            TaskItem attribute = new("CLSCompliantAttribute");
+            attribute.SetMetadata("_Parameter1", "True");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: CLSCompliantAttribute(true)]"
+            );
+        }
+
+        /// <summary>
+        /// The type of a named argument can be inferred
+        /// if the type of the attribute is in mscorlib.
+        /// </summary>
+        [Fact]
+        public void InferredTypeForNamedParameter()
+        {
+            TaskItem attribute = new("System.Runtime.CompilerServices.InternalsVisibleToAttribute");
+            attribute.SetMetadata("_Parameter1", "MyAssembly");
+            attribute.SetMetadata("AllInternalsVisible", "True");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(""MyAssembly"", AllInternalsVisible=true)]"
+            );
+        }
+
+        /// <summary>
+        /// For backward-compatibility, if multiple constructors are found with the same number 
+        /// of position arguments that was specified in the metadata, then the constructor that
+        /// has strings for every parameter should be used.
+        /// </summary>
+        [Fact]
+        public void InferredTypePrefersStringWhenMultipleConstructorsAreFound()
+        {
+            TaskItem attribute = new("System.Diagnostics.Contracts.ContractOptionAttribute");
+            attribute.SetMetadata("_Parameter1", "a");
+            attribute.SetMetadata("_Parameter2", "b");
+            attribute.SetMetadata("_Parameter3", "false");
+
+            // There are two constructors with three parameters:
+            //   * ContractOptionAttribute(string, string, bool)
+            //   * ContractOptionAttribute(string, string, string)
+            //
+            // The first overload would come first when comparing the type names
+            // ("System.Boolean" comes before "System.String"), but because we
+            // need to remain backward-compatible, the constructor that takes
+            // all strings should be preferred over all other constructors.
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Diagnostics.Contracts.ContractOptionAttribute(""a"", ""b"", ""false"")]"
+            );
+        }
+
+        /// <summary>
+        /// When multiple constructors are found with the same number of
+        /// position arguments that was specified in the metadata, and none
+        /// of them have parameters of all strings, then the constructors
+        /// should be sorted by the names of the parameter types.
+        /// The first constructor is then selected.
+        /// </summary>
+        [Fact]
+        public void InferredTypeWithMultipleAttributeConstructorsIsDeterministic()
+        {
+            TaskItem attribute = new("System.Reflection.AssemblyFlagsAttribute");
+            attribute.SetMetadata("_Parameter1", "2");
+
+            // There are three constructors with a single parameter:
+            //   * AssemblyFlagsAttribute(int)
+            //   * AssemblyFlagsAttribute(uint)
+            //   * AssemblyFlagsAttribute(System.Reflection.AssemblyNameFlags)
+            //
+            // The int overload should be used, because "System.Int32"
+            // is alphabetically before any of the other types.
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Reflection.AssemblyFlagsAttribute(2)]"
+            );
+
+            // To prove that it's treating the argument as an int,
+            // we can specify an enum value which should fail type
+            // conversion and fall back to being used as a string.
+            attribute.SetMetadata("_Parameter1", "PublicKey");
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Reflection.AssemblyFlagsAttribute(""PublicKey"")]"
+            );
+        }
+
+        /// <summary>
+        /// If the attribute type is not in mscorlib, then the
+        /// parameter should be treated as a string when the parameter
+        /// is not given a declared type or is not marked as a literal.
+        /// </summary>
+        [Fact]
+        public void InferredTypeFallsBackToStringWhenTypeCannotBeInferred()
+        {
+            // Use an attribute that is not in mscorlib. TypeConverterAttribute is in the "System" assembly.
+            TaskItem attribute = new("System.ComponentModel.TypeConverterAttribute");
+            attribute.SetMetadata("_Parameter1", "false");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.ComponentModel.TypeConverterAttribute(""false"")]"
+            );
+        }
+
+        /// <summary>
+        /// If the parameter type cannot be converted to the inferred type,
+        /// then the parameter should be treated as a string.
+        /// </summary>
+        [Fact]
+        public void InferredTypeFallsBackToStringWhenTypeConversionFails()
+        {
+            TaskItem attribute = new("System.Diagnostics.DebuggableAttribute");
+            attribute.SetMetadata("_Parameter1", "True"); // Should be a boolean. Will be converted.
+            attribute.SetMetadata("_Parameter2", "42"); // Should be a boolean. Will fail type conversion.
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Diagnostics.DebuggableAttribute(true, ""42"")]"
+            );
+        }
+
+        /// <summary>
+        /// Individual parameters can be typed differently.
+        /// </summary>
+        [Fact]
+        public void UsingInferredDeclaredTypesAndLiteralsInSameAttribute()
+        {
+            TaskItem attribute = new("System.Diagnostics.Contracts.ContractOptionAttribute");
+            attribute.SetMetadata("_Parameter1", "foo");                    // Inferred as string.
+            attribute.SetMetadata("_Parameter2", @"""bar"" /* setting */"); // Literal string.
+            attribute.SetMetadata("_Parameter2_IsLiteral", "true");
+            attribute.SetMetadata("_Parameter3", "False");                  // Typed as boolean.
+            attribute.SetMetadata("_Parameter3_TypeName", "System.Boolean");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Diagnostics.Contracts.ContractOptionAttribute(""foo"", ""bar"" /* setting */, false)]"
+            );
+        }
+
+        private WriteCodeFragment CreateTask(string language, params TaskItem[] attributes)
+        {
+            WriteCodeFragment task = new();
+            task.Language = language;
+            task.OutputDirectory = new TaskItem(Path.GetTempPath());
+            task.AssemblyAttributes = attributes;
+            return task;
+        }
+
+        private void ExecuteAndVerifySuccess(WriteCodeFragment task, params string[] expectedAttributes)
+        {
+            MockEngine engine = new(true);
+            task.BuildEngine = engine;
+
+            try
+            {
+                var result = task.Execute();
+
+                // Provide the log output as the user message so that the assertion failure
+                // message is a bit more meaningful than just "Expected false to equal true".
+                Assert.True(result, engine.Log);
+
+                string content = File.ReadAllText(task.OutputFile.ItemSpec);
+                Console.WriteLine(content);
+
+                if (task.Language == "c#")
+                {
+                    CheckContentCSharp(content, expectedAttributes);
+                }
+                else
+                {
+                    CheckContentVB(content, expectedAttributes);
+                }
+            }
+            finally
+            {
+                if ((task.OutputFile is not null) && File.Exists(task.OutputFile.ItemSpec))
+                {
+                    File.Delete(task.OutputFile.ItemSpec);
+                }
+            }
+        }
+
+        private void ExecuteAndVerifyFailure(WriteCodeFragment task, string errorCode)
+        {
+            MockEngine engine = new(true);
+            task.BuildEngine = engine;
+
+            try
+            {
+                var result = task.Execute();
+
+                // Provide the log output as the user message so that the assertion failure
+                // message is a bit more meaningful than just "Expected true to equal false".
+                Assert.False(result, engine.Log);
+
+                engine.AssertLogContains(errorCode);
+
+            }
+            finally
+            {
+                if ((task.OutputFile is not null) && File.Exists(task.OutputFile.ItemSpec))
+                {
+                    File.Delete(task.OutputFile.ItemSpec);
+                }
+            }
+        }
+
         private static void CheckContentCSharp(string actualContent, params string[] expectedAttributes)
         {
             CheckContent(
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index a054ea6c65a..94401fe26bb 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2374,6 +2374,14 @@
       <value>MSB3714: The parameter "{0}" was supplied, but not all previously numbered parameters.</value>
       <comment>{StrBegin="MSB3714: "}</comment>
     </data>
+    <data name="WriteCodeFragment.ParameterTypeNotFound" xml:space="preserve">
+      <value>MSB3715: The type "{0}" was not found.</value>
+      <comment>{StrBegin="MSB3715: "}</comment>
+    </data>
+    <data name="WriteCodeFragment.CouldNotConvertValue" xml:space="preserve">
+      <value>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</value>
+      <comment>{StrBegin="MSB3716: "}</comment>
+    </data>
     <data name="WriteCodeFragment.NoWorkToDo" xml:space="preserve">
       <value>No output file was written because no code was specified to create.</value>
     </data>
@@ -2383,6 +2391,15 @@
     <data name="WriteCodeFragment.Comment" xml:space="preserve">
       <value>Generated by the MSBuild WriteCodeFragment class.</value>
     </data>
+    <data name="WriteCodeFragment.CouldNotInferParameterType" xml:space="preserve">
+      <value>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</value>
+    </data>
+    <data name="WriteCodeFragment.CouldNotConvertToInferredType" xml:space="preserve">
+      <value>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</value>
+    </data>
+    <data name="WriteCodeFragment.MultipleConstructorsFound" xml:space="preserve">
+      <value>Multiple attribute constructors were found for type inferencing.</value>
+    </data>
 
 
  <!--
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index c6ebbc2bf98..8c79fb15f9e 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: Neodpovídající hodnota hash souboru. Očekávalo se, že {0} bude mít hodnotu hash souboru {1} {2}, ale byla {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Nelze zapsat řádky do souboru {0}. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 9d261b2b46f..3d780d50873 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: Keine Dateihashübereinstimmung. "{0}" muss einen {1}-Dateihash von "{2}" aufweisen, dieser lautet jedoch "{3}".</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: In die Datei "{0}" konnten keine Zeilen geschrieben werden. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index df627557c4a..99bcd37f1b5 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -2600,6 +2600,31 @@
         <target state="new">MSB3952: File hash mismatch. Expected {0} to have a {1} file hash of {2}, but it was {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="new">MSB3491: Could not write lines to file "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 8a28657818f..1bd51554ca2 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: El hash del archivo no coincide. Se esperaba que {0} tuviera un hash de archivo {1} de {2}, pero era {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: No se pudieron escribir líneas en el archivo "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 3854fcf0c19..dd9cdd8d980 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: Incompatibilité au niveau du hachage de fichier. {0} devait avoir un hachage de fichier {1} de {2}, mais {3} a été utilisé.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Impossible d'écrire des lignes dans le fichier "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 14bdb0e8baf..a7cb8eb0c55 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: hash di file non corrispondente. L'hash di file {1} previsto per {0} è {2}, ma quello individuato è {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: non è stato possibile scrivere righe nel file "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index a4b07fadb16..86d2f26eb9d 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: ファイルのハッシュが一致しません。{0} には {2} の {1} ファイル ハッシュが想定されますが、実際は {3} でした。</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: 行をファイル "{0}" に書き込めませんでした。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index e801bdd91a6..5b014e17250 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: 파일 해시가 일치하지 않습니다. {0}에 {2}의 {1} 파일 해시가 필요하지만 {3}이었습니다.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: "{0}" 파일에 줄을 쓸 수 없습니다. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 4251be9ff36..8b8b84d6078 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: Niezgodność skrótów pliku. Oczekiwano, że element {0} będzie miał skrót pliku {1} równy {2}, ale miał skrót równy {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Nie można zapisać wierszy w pliku „{0}”. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 1dfff7329b4..1f2a4024011 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: incompatibilidade de hash de arquivo. Era esperado que {0} tivesse um hash de arquivo {1} de {2}, mas ele tinha {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Não foi possível gravar linhas no arquivo "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9e883f29af7..1268610ce7d 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: несоответствие хэша файла. Для {0} ожидался хэш файла {1}, соответствующий {2}, но вычисленное значение было равно {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Не удалось записать строки в файл "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 194e8b3f3e1..a5747e97b5f 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: Dosya karması uyuşmazlığı. {0} dosyasının {2} şeklinde bir {1} dosya karması olması bekleniyordu ama {3} şeklindeydi.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Satırlar "{0}" dosyasına yazılamadı. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 44e2fce72d4..bbfffffa2f7 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: 文件哈希不匹配。{0} 应具有 {1} 文件哈希 {2}，但却具有 {3}。</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: 未能向文件“{0}”写入命令行。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index a70ec8fb257..3dbe63dc6ba 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -2550,6 +2550,31 @@
         <target state="translated">MSB3952: 檔案雜湊不符。{0} 應要有 {1} 檔案雜湊 {2}，但其為 {3}。</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: 無法將行寫入檔案 "{0}"。{1}</target>
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index d7ece292dbb..c807b2bd22e 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -10,6 +10,7 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Security;
 using System.Text;
 using Microsoft.Build.Framework;
@@ -27,6 +28,10 @@ namespace Microsoft.Build.Tasks
     /// </comment>
     public class WriteCodeFragment : TaskExtension
     {
+        private const string TypeNameSuffix = "_TypeName";
+        private const string IsLiteralSuffix = "_IsLiteral";
+        private static readonly IEnumerable<string> NamespaceImports = new string[] { "System", "System.Reflection" };
+
         /// <summary>
         /// Language of code to generate.
         /// Language name can be any language for which a CodeDom provider is
@@ -162,26 +167,37 @@ private string GenerateCode(out string extension)
             }
 
             // For convenience, bring in the namespaces, where many assembly attributes lie
-            globalNamespace.Imports.Add(new CodeNamespaceImport("System"));
-            globalNamespace.Imports.Add(new CodeNamespaceImport("System.Reflection"));
+            foreach (string name in NamespaceImports)
+            {
+                globalNamespace.Imports.Add(new CodeNamespaceImport(name));
+            }
 
             foreach (ITaskItem attributeItem in AssemblyAttributes)
             {
-                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));
-
                 // Some attributes only allow positional constructor arguments, or the user may just prefer them.
                 // To set those, use metadata names like "_Parameter1", "_Parameter2" etc.
                 // If a parameter index is skipped, it's an error.
                 IDictionary customMetadata = attributeItem.CloneCustomMetadata();
 
-                var orderedParameters = new List<CodeAttributeArgument>(new CodeAttributeArgument[customMetadata.Count + 1] /* max possible slots needed */);
-                var namedParameters = new List<CodeAttributeArgument>();
+                // Some metadata may indicate the types of parameters. Use that metadata to determine
+                // the parameter types. Those metadata items will be removed from the dictionary.
+                Dictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);
+
+                var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);
+                var namedParameters = new List<AttributeParameter>();
 
                 foreach (DictionaryEntry entry in customMetadata)
                 {
                     string name = (string)entry.Key;
                     string value = (string)entry.Value;
 
+                    // Get the declared type information for this parameter.
+                    // If a type is not declared, then we infer the type.
+                    if (!parameterTypes.TryGetValue(name, out ParameterType type))
+                    {
+                        type = new ParameterType { Kind = ParameterTypeKind.Inferred };
+                    }
+
                     if (name.StartsWith("_Parameter", StringComparison.OrdinalIgnoreCase))
                     {
                         if (!Int32.TryParse(name.Substring("_Parameter".Length), out int index))
@@ -197,18 +213,19 @@ private string GenerateCode(out string extension)
                         }
 
                         // "_Parameter01" and "_Parameter1" would overwrite each other
-                        orderedParameters[index - 1] = new CodeAttributeArgument(String.Empty, new CodePrimitiveExpression(value));
+                        orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };
                     }
                     else
                     {
-                        namedParameters.Add(new CodeAttributeArgument(name, new CodePrimitiveExpression(value)));
+                        namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });
                     }
                 }
 
                 bool encounteredNull = false;
+                List<AttributeParameter> providedOrderedParameters = new();
                 for (int i = 0; i < orderedParameters.Count; i++)
                 {
-                    if (orderedParameters[i] == null)
+                    if (!orderedParameters[i].HasValue)
                     {
                         // All subsequent args should be null, else a slot was missed
                         encounteredNull = true;
@@ -221,12 +238,24 @@ private string GenerateCode(out string extension)
                         return null;
                     }
 
-                    attribute.Arguments.Add(orderedParameters[i]);
+                    providedOrderedParameters.Add(orderedParameters[i].Value);
                 }
 
-                foreach (CodeAttributeArgument namedParameter in namedParameters)
+                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));
+
+                // We might need the type of the attribute if we need to infer the
+                // types of the parameters. Search for it by the given type name,
+                // as well as within the namespaces that we automatically import.
+                Lazy<Type> attributeType = new(
+                    () => Type.GetType(attribute.Name) ?? NamespaceImports.Select(x => Type.GetType($"{x}.{attribute.Name}")).FirstOrDefault(),
+                    System.Threading.LazyThreadSafetyMode.None
+                );
+
+                if (
+                    !AddArguments(attribute, attributeType, providedOrderedParameters, true)
+                    || !AddArguments(attribute, attributeType, namedParameters, false))
                 {
-                    attribute.Arguments.Add(namedParameter);
+                    return null;
                 }
 
                 unit.AssemblyCustomAttributes.Add(attribute);
@@ -245,5 +274,312 @@ private string GenerateCode(out string extension)
             // as there's no point writing the file
             return haveGeneratedContent ? code : String.Empty;
         }
+
+        /// <summary>
+        /// Finds the metadata items that are used to indicate the types of
+        /// parameters, and removes those items from the given dictionary.
+        /// Returns a dictionary that maps parameter names to their declared types.
+        /// </summary>
+        private Dictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)
+        {
+            Dictionary<string, ParameterType> parameterTypes = new();
+            List<string> keysToRemove = new();
+
+            foreach (DictionaryEntry entry in customMetadata)
+            {
+                string key = (string)entry.Key;
+                string value = (string)entry.Value;
+
+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))
+                {
+                    // Remove the suffix to get the corresponding parameter name.
+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);
+
+                    // To remain as backward-compatible as possible, we will only treat this metadata
+                    // item as a type name if there's a corresponding metadata item for the parameter.
+                    // This is done to avoid the very small chance of treating "Foo_TypeName" as a
+                    // type indicator when it was previously being used as a named attribute parameter.
+                    if (customMetadata.Contains(parameterNameKey))
+                    {
+                        // Remove this metadata item so that
+                        // we don't use it as a parameter name.
+                        keysToRemove.Add(key);
+
+                        // The parameter will have an explicit type. The metadata value is the type name.
+                        parameterTypes[parameterNameKey] = new ParameterType {
+                            Kind = ParameterTypeKind.Typed,
+                            TypeName = value
+                        };
+                    }
+                }
+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))
+                {
+                    // Remove the suffix to get the corresponding parameter name.
+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);
+
+                    // As mentioned above for the type name metadata, we will only treat
+                    // this metadata item as a literal flag if there's a corresponding
+                    // metadata item for the parameter for backward-compatibility reasons.
+                    if (customMetadata.Contains(parameterNameKey))
+                    {
+                        // Remove this metadata item so that
+                        // we don't use it as a parameter name.
+                        keysToRemove.Add(key);
+
+                        // If the value is true, the parameter value will be the exact code
+                        // that needs to be written to the generated file for that parameter.
+                        if (string.Equals(value, "true", StringComparison.OrdinalIgnoreCase))
+                        {
+                            parameterTypes[parameterNameKey] = new ParameterType {
+                                Kind = ParameterTypeKind.Literal
+                            };
+                        }
+                    }
+                }
+            }
+
+            // Remove any metadata items that we used
+            // for type names or literal flags.
+            foreach (var key in keysToRemove)
+            {
+                customMetadata.Remove(key);
+            }
+
+            return parameterTypes;
+        }
+
+        /// <summary>
+        /// Uses the given parameters to add CodeDom arguments to the given attribute.
+        /// Returns true if the arguments could be defined, or false if the values could
+        /// not be converted to the required type. An error is also logged for failures.
+        /// </summary>
+        private bool AddArguments(
+            CodeAttributeDeclaration attribute,
+            Lazy<Type> attributeType,
+            IReadOnlyList<AttributeParameter> parameters,
+            bool isPositional
+        )
+        {
+            Type[] constructorParameterTypes = null;
+
+            for (int i = 0; i < parameters.Count; i++)
+            {
+                AttributeParameter parameter = parameters[i];
+                CodeExpression value;
+
+                switch (parameter.Type.Kind)
+                {
+                    case ParameterTypeKind.Literal:
+                        // The exact value provided by the metadata is what we use.
+                        // Note that this value is used verbatim, so its the user's
+                        // responsibility to ensure that it is in the correct language.
+                        value = new CodeSnippetExpression(parameter.Value);
+                        break;
+
+                    case ParameterTypeKind.Typed:
+                        if (string.Equals(parameter.Type.TypeName, "System.Type"))
+                        {
+                            // Types are a special case, because we can't convert a string to a
+                            // type, but because we're using the CodeDom, we don't need to
+                            // convert it. we can just create a type expression.
+                            value = new CodeTypeOfExpression(parameter.Value);
+                        }
+                        else
+                        {
+                            // We've been told what type this parameter needs to be.
+                            // If we cannot convert the value to that type, then we need to fail.
+                            if (!TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value))
+                            {
+                                return false;
+                            }
+                        }
+
+                        break;
+
+                    default:
+                        if (isPositional)
+                        {
+                            // For positional parameters, infer the type
+                            // using the constructor argument types.
+                            if (constructorParameterTypes is null)
+                            {
+                                constructorParameterTypes = FindPositionalParameterTypes(attributeType.Value, parameters);
+                            }
+
+                            value = ConvertParameterValueToInferredType(
+                                constructorParameterTypes[i],
+                                parameter.Value,
+                                $"#{i + 1}" /* back to 1 based */
+                            );
+                        }
+                        else
+                        {
+                            // For named parameters, use the type of the property if we can find it.
+                            value = ConvertParameterValueToInferredType(
+                                attributeType.Value?.GetProperty(parameter.Name)?.PropertyType,
+                                parameter.Value,
+                                parameter.Name
+                            );
+                        }
+
+                        break;
+
+                }
+
+                attribute.Arguments.Add(new CodeAttributeArgument(parameter.Name, value));
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Finds the types that the parameters are likely to be, by finding a constructor
+        /// on the attribute that has the same number of parameters that have been provided.
+        /// Returns an array of types with a length equal to the number of positional parameters.
+        /// If no suitable constructor is found, the array will contain null types.
+        /// </summary>
+        private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<AttributeParameter> positionalParameters)
+        {
+            // The attribute type might not be known.
+            if (attributeType is not null)
+            {
+                List<Type[]> candidates;
+
+                // Find the constructors with the same number
+                // of parameters as we will be specifying.
+                candidates = attributeType
+                    .GetConstructors()
+                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())
+                    .Where(t => t.Length == positionalParameters.Count)
+                    .ToList();
+
+                if (candidates.Count == 1)
+                {
+                    return candidates[0];
+                }
+                else if (candidates.Count > 1)
+                {
+                    Log.LogMessageFromResources("WriteCodeFragment.MultipleConstructorsFound");
+
+                    // Before parameter types could be specified, all parameter values were
+                    // treated as strings. To be backward-compatible, we need prefer the
+                    // constructor that has all string parameters, if it exists.
+                    var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));
+
+                    if (allStringParameters is not null)
+                    {
+                        return allStringParameters;
+                    }
+
+                    // There isn't a constructor where all parameters are strings, so we are free
+                    // to pick one of the candidates. To ensure that we always select the same
+                    // constructor, sort the candidates by type names, then pick the first one.
+                    return candidates
+                        .OrderBy(c => string.Join(",", c.Select(t => t.FullName)))
+                        .First();
+                }
+            }
+
+            // If a matching constructor was not found, or we don't
+            // know the attribute type, then return an array of null
+            // types to indicate that each parameter type is unknown.
+            return positionalParameters.Select(x => default(Type)).ToArray();
+        }
+
+        /// <summary>
+        /// Attempts to convert the raw value provided in the metadata to the type with the specified name.
+        /// Returns true if conversion is successful. An error is logged and false is returned if the conversion fails.
+        /// </summary>
+        private bool TryConvertParameterValue(string typeName, string rawValue, out CodeExpression value)
+        {
+            var parameterType = Type.GetType(typeName);
+
+            if (parameterType is null)
+            {
+                Log.LogErrorWithCodeFromResources("WriteCodeFragment.ParameterTypeNotFound", typeName);
+                value = null;
+                return false;
+            }
+
+            try
+            {
+                value = ConvertToCodeExpression(rawValue, parameterType);
+                return true;
+            }
+            catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            {
+                Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotConvertValue", rawValue, typeName, ex.Message);
+                value = null;
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Convert the raw value provided in the metadata to the type
+        /// that has been inferred based on the parameter position or name.
+        /// Returns the converted value as a CodeExpression if successful, or the raw value
+        /// as a CodeExpression if conversion fails. No errors are logged if the conversion fails.
+        /// </summary>
+        private CodeExpression ConvertParameterValueToInferredType(Type inferredType, string rawValue, string parameterName)
+        {
+            // If we don't know what type the parameter should be, then we 
+            // can't convert the type. We'll just treat is as a string.
+            if (inferredType is null)
+            {
+                Log.LogMessageFromResources("WriteCodeFragment.CouldNotInferParameterType", parameterName);
+                return new CodePrimitiveExpression(rawValue);
+            }
+
+            try
+            {
+                return ConvertToCodeExpression(rawValue, inferredType);
+            }
+            catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            {
+                // The conversion failed, but since we are inferring the type,
+                // we won't fail. We'll just treat the value as a string.
+                Log.LogMessageFromResources("WriteCodeFragment.CouldNotConvertToInferredType", parameterName, inferredType.Name, ex.Message);
+                return new CodePrimitiveExpression(rawValue);
+            }
+        }
+
+        /// <summary>
+        /// Converts the given value to a CodeExpression object where the value is the specified type.
+        /// Returns the CodeExpression if successful, or throws an exception if the conversion fails.
+        /// </summary>
+        private CodeExpression ConvertToCodeExpression(string value, Type targetType)
+        {
+            if (targetType == typeof(Type))
+            {
+                return new CodeTypeOfExpression(value);
+            }
+
+            if (targetType.IsEnum)
+            {
+                return new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(targetType), value);
+            }
+
+            return new CodePrimitiveExpression(Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture));
+        }
+
+        private enum ParameterTypeKind
+        {
+            Inferred,
+            Typed,
+            Literal
+        }
+
+        private struct ParameterType
+        {
+            public ParameterTypeKind Kind { get; init; }
+            public string TypeName { get; init; }
+        }
+
+        private struct AttributeParameter
+        {
+            public ParameterType Type { get; init; }
+            public string Name { get; init; }
+            public string Value { get; init; }
+        }
     }
 }
