diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index 9a0bb05138a..80557bcae89 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -424,6 +424,417 @@ public void TestSerializeArrayWithFactoryNull()
             Assert.True(TranslationHelpers.CompareCollections(value, deserializedValue, BaseClass.Comparer));
         }
 
+        /// <summary>
+        /// Tests interning strings within an intern scope.
+        /// </summary>
+        /// <remarks>
+        /// Most of the string intern tests use casing differences to assert whether interning was successful, rather
+        /// than asserting the underlying buffer contents. Although the intended use is to deduplicate many strings of the
+        /// same casing, this is harder to validate this high level, so we focus on testing behavior here.
+        /// </remarks>
+        [Theory]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        public void TestInternWithInterning(string value, bool nullable)
+        {
+            // Create a case mismatch to test if the string is deduplicated.
+            string valueUpperCase = value?.ToUpperInvariant();
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref value, nullable);
+                translator.Intern(ref valueUpperCase, nullable);
+            });
+
+            string deserializedValue = null;
+            string deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedValue, nullable);
+                translator.Intern(ref deserializedValueUpperCase, nullable);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            Assert.Equal(value, deserializedValue);
+            Assert.Equal(value, deserializedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning strings outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Theory]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        [InlineData(null, false)]
+        public void TestInternNoInterning(string value, bool nullable)
+        {
+            TranslationHelpers.GetWriteTranslator().Intern(ref value, nullable);
+
+            string deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Intern(ref deserializedValue, nullable);
+
+            // If we haven't blown up so far, assume we've skipped interning.
+            Assert.Equal(value, deserializedValue);
+        }
+
+        /// <summary>
+        /// Tests interning path-like strings within an intern scope.
+        /// </summary>
+        [Theory]
+        [InlineData(@"C:\src\msbuild\artifacts\bin\SomeProject.Namespace\Debug\net472\SomeProject.NameSpace.dll", true)]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData(@"C:\src\msbuild\artifacts\bin\SomeProject.Namespace\Debug\net472\SomeProject.NameSpace.dll", false)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        public void TestInternPathWithInterning(string value, bool nullable)
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string valueUpperCase = value?.ToUpperInvariant();
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.InternPath(ref value, nullable);
+                translator.InternPath(ref valueUpperCase, nullable);
+            });
+
+            string deserializedValue = null;
+            string deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.InternPath(ref deserializedValue, nullable);
+                translator.InternPath(ref deserializedValueUpperCase, nullable);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            Assert.Equal(value, deserializedValue);
+            Assert.Equal(value, deserializedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning components in path-like strings.
+        /// </summary>
+        [Fact]
+        public void TestInternPathWithComponentsFirst()
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string directory = @"C:\SRC\MSBUILD\ARTIFACTS\BIN\SOMEPROJECT.NAMESPACE\DEBUG\NET472\";
+            string fileName = @"SOMEPROJECT.NAMESPACE.DLL";
+            string fullPath = @"C:\src\msbuild\artifacts\bin\SomeProject.Namespace\Debug\net472\SomeProject.NameSpace.dll";
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref directory);
+                translator.InternPath(ref fileName);
+                translator.InternPath(ref fullPath);
+            });
+
+            string deserializedDirectory = null;
+            string deserializedFileName = null;
+            string deserializedFullPath = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref deserializedDirectory);
+                translator.InternPath(ref deserializedFileName);
+                translator.InternPath(ref deserializedFullPath);
+            });
+
+            // The path components should be reconstructed using the first encountered value.
+            Assert.Equal(directory, deserializedDirectory);
+            Assert.Equal(fileName, deserializedFileName);
+            Assert.Equal(Path.Combine(directory, fileName), deserializedFullPath);
+        }
+
+        /// <summary>
+        /// Tests interning components in path-like strings.
+        /// </summary>
+        [Fact]
+        public void TestInternPathWithFullPathFirst()
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string fullPath = @"c:\src\msbuild\artifacts\bin\someproject.namespace\debug\net472\someproject.namespace.dll";
+            string directory = @"C:\SRC\MSBUILD\ARTIFACTS\BIN\SOMEPROJECT.NAMESPACE\DEBUG\NET472\";
+            string fileName = @"SOMEPROJECT.NAMESPACE.DLL";
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref fullPath);
+                translator.InternPath(ref directory);
+                translator.InternPath(ref fileName);
+            });
+
+            string deserializedFullPath = null;
+            string deserializedDirectory = null;
+            string deserializedFileName = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref deserializedFullPath);
+                translator.InternPath(ref deserializedDirectory);
+                translator.InternPath(ref deserializedFileName);
+            });
+
+            // The path components should be reconstructed using the first encountered value.
+            Assert.Equal(fullPath, deserializedFullPath);
+            Assert.Equal(fullPath, Path.Combine(deserializedDirectory, deserializedFullPath));
+        }
+
+        /// <summary>
+        /// Tests serializing string arrays within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternStringArrayWithInterning()
+        {
+            // Create a case mismatch to test if the string is deduplicated.
+            string[] value1 = ["foo", "FOO"];
+            string[] value2 = ["Foo", "fOO"];
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref value1);
+                translator.Intern(ref value2);
+            });
+
+            string[] deserializedValue1 = null;
+            string[] deserializedValue2 = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedValue1);
+                translator.Intern(ref deserializedValue2);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            string[] expectedValue = ["foo", "foo"];
+            Assert.True(TranslationHelpers.CompareCollections(expectedValue, deserializedValue1, StringComparer.Ordinal));
+            Assert.True(TranslationHelpers.CompareCollections(expectedValue, deserializedValue2, StringComparer.Ordinal));
+        }
+
+        /// <summary>
+        /// Tests serializing string arrays outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Fact]
+        public void TestInternStringArrayNoInterning()
+        {
+            string[] value1 = ["foo", "FOO"];
+            string[] value2 = ["Foo", "fOO"];
+
+            ITranslator translator = TranslationHelpers.GetWriteTranslator();
+            translator.Intern(ref value1);
+            translator.Intern(ref value2);
+
+            string[] deserializedValue1 = null;
+            string[] deserializedValue2 = null;
+            translator = TranslationHelpers.GetReadTranslator();
+            translator.Intern(ref deserializedValue1);
+            translator.Intern(ref deserializedValue2);
+
+            Assert.True(TranslationHelpers.CompareCollections(value1, deserializedValue1, StringComparer.Ordinal));
+            Assert.True(TranslationHelpers.CompareCollections(value2, deserializedValue2, StringComparer.Ordinal));
+        }
+
+        /// <summary>
+        /// End-to-end test using a mixture of interned and non-interned operations to ensure that we don't hit
+        /// invalid states, as this will be the most common use case.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningMixedUsage()
+        {
+            string value1 = "Foobar";
+            string value2 = "foobar";
+            string valueToIntern = "FooBar";
+            int value3 = 10;
+            string value4 = "fooBar";
+
+            // Create a case mismatch to test if the string is deduplicated.
+            string valueToInternUpperCase = valueToIntern?.ToUpperInvariant();
+            string value5 = "Foo_Bar";
+
+            ITranslator translator = TranslationHelpers.GetWriteTranslator();
+
+            // Interleave interned and non-interned operations.
+            translator.Translate(ref value1);
+            translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Translate(ref value2);
+                translator.Intern(ref valueToIntern);
+                translator.Translate(ref value3);
+                translator.Intern(ref valueToInternUpperCase);
+                translator.Translate(ref value4);
+            });
+            translator.Translate(ref value5);
+
+            string deserializedValue1 = null;
+            string deserializedValue2 = null;
+            string deserializedInternedValue = null;
+            int deserializedValue3 = -1;
+            string deserializedValue4 = null;
+            string deserializedInternedValueUpperCase = null;
+            string deserializedValue5 = null;
+
+            translator = TranslationHelpers.GetReadTranslator();
+
+            // This will only succeed if both translators are correctly sequenced:
+            // packet body -> intern header -> intern body -> packet body.
+            translator.Translate(ref deserializedValue1);
+            translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Translate(ref deserializedValue2);
+                translator.Intern(ref deserializedInternedValue);
+                translator.Translate(ref deserializedValue3);
+                translator.Intern(ref deserializedInternedValueUpperCase);
+                translator.Translate(ref deserializedValue4);
+            });
+            translator.Translate(ref deserializedValue5);
+
+            // All non-interned values should maintain their original casing.
+            Assert.Equal(value1, deserializedValue1);
+            Assert.Equal(value2, deserializedValue2);
+            Assert.Equal(value3, deserializedValue3);
+            Assert.Equal(value4, deserializedValue4);
+            Assert.Equal(value5, deserializedValue5);
+
+            // All interned values should deserialize to the first encountered value.
+            Assert.Equal(valueToIntern, deserializedInternedValue);
+            Assert.Equal(valueToIntern, deserializedInternedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning path-like strings outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Theory]
+        [InlineData(@"C:\src\msbuild\artifacts\bin\SomeProject.Namespace\Debug\net472\SomeProject.NameSpace.dll", true)]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData(@"C:\src\msbuild\artifacts\bin\SomeProject.Namespace\Debug\net472\SomeProject.NameSpace.dll", false)]
+        [InlineData("", false)]
+        [InlineData(null, false)]
+        public void TestInternPathNoInterning(string value, bool nullable)
+        {
+            TranslationHelpers.GetWriteTranslator().InternPath(ref value, nullable);
+
+            string deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().InternPath(ref deserializedValue, nullable);
+
+            // If we haven't blown up so far, assume we've skipped interning.
+            Assert.Equal(value, deserializedValue);
+        }
+
+        /// <summary>
+        /// Tests no-op when nothing is written to the interner. E.g. a packet opens an intern scope, but none of its
+        /// translatable child objects write anything.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningNoWritesDoesNotThrow()
+        {
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 128, translator =>
+            {
+            });
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 128, translator =>
+            {
+            });
+        }
+
+        /// <summary>
+        /// Tests reusing a translator with different interning comparers.
+        /// This is important if the translator is reused for multiple packet types with different case sensitivity.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningResetsComparerBetweenScopes()
+        {
+            string mixedCaseValue = "StringWithSomeCasing";
+            string lowerCaseValue = "stringwithsomecasing";
+
+            MemoryStream serializationStream = new();
+            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(serializationStream);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
+
+            writeTranslator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref mixedCaseValue);
+                translator.Intern(ref lowerCaseValue);
+            });
+
+            serializationStream.Position = 0;
+
+            string deserializedMixedCaseValue = null;
+            string deserializedLowerCaseValue = null;
+
+            readTranslator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedMixedCaseValue);
+                translator.Intern(ref deserializedLowerCaseValue);
+            });
+
+            // Only the first casing should be interned.
+            Assert.Equal(mixedCaseValue, deserializedMixedCaseValue);
+            Assert.Equal(mixedCaseValue, deserializedLowerCaseValue);
+
+            // Simulate translator reuse by resetting the underlying stream.
+            serializationStream.Position = 0;
+            serializationStream.SetLength(0);
+
+            writeTranslator.WithInterning(StringComparer.Ordinal, initialCapacity: 2, translator =>
+            {
+                translator.Intern(ref mixedCaseValue);
+                translator.Intern(ref lowerCaseValue);
+            });
+
+            serializationStream.Position = 0;
+
+            readTranslator.WithInterning(StringComparer.Ordinal, initialCapacity: 2, translator =>
+            {
+                translator.Intern(ref deserializedMixedCaseValue);
+                translator.Intern(ref deserializedLowerCaseValue);
+            });
+
+            // Both casings should be interned if the comparer was correctly reset.
+            Assert.Equal(mixedCaseValue, deserializedMixedCaseValue);
+            Assert.Equal(lowerCaseValue, deserializedLowerCaseValue);
+        }
+
+        /// <summary>
+        /// Tests throwing an exception on nested intern scopes, which is unsupported.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningThrowsOnNestedScopes()
+        {
+            _ = Assert.Throws<InvalidOperationException>(() =>
+            {
+                ITranslator translator = TranslationHelpers.GetWriteTranslator();
+                translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                {
+                    translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                    {
+                    });
+                });
+            });
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                // Reset the stream, since the broken write will result in an IO exception when read.
+            });
+
+            _ = Assert.Throws<InvalidOperationException>(() =>
+            {
+                ITranslator translator = TranslationHelpers.GetReadTranslator();
+                translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                {
+                    translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                    {
+                    });
+                });
+            });
+        }
+
         /// <summary>
         /// Tests serializing a dictionary of { string, string }
         /// </summary>
@@ -539,6 +950,178 @@ public void TestSerializeDictionaryStringTNoComparerNull()
             Assert.Equal(value, deserializedValue);
         }
 
+        /// <summary>
+        /// Tests interning dictionaries of { string, string } within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternDictionaryStringString()
+        {
+            Dictionary<string, string> value = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["foo"] = "bar",
+                ["alpha"] = "omega",
+            };
+            Dictionary<string, string> valueUpperCase = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["FOO"] = "BAR",
+                ["ALPHA"] = "OMEGA",
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Dictionary<string, string> deserializedValue = null;
+            Dictionary<string, string> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(value["foo"], deserializedValue["foo"]);
+            Assert.Equal(value["alpha"], deserializedValue["alpha"]);
+
+            // All occurrences should deserialize to the first encountered value.
+            // We don't test the keys since the dictionary already uses an ignore case comparer, and
+            // we also want to test that the dictionary comparer matches on both sides.
+            Assert.Equal(valueUpperCase.Count, deserializedValueUpperCase.Count);
+            Assert.Equal(value["foo"], deserializedValueUpperCase["foo"]);
+            Assert.Equal(value["alpha"], deserializedValueUpperCase["alpha"]);
+        }
+
+        /// <summary>
+        /// Tests interning a dictionary of { string, T } within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternDictionaryStringT()
+        {
+            // Since we don't have string values, mismatch the key comparer to verify that interning works.
+            Dictionary<string, BaseClass> value = new(StringComparer.Ordinal)
+            {
+                ["foo"] = new BaseClass(1),
+                ["alpha"] = new BaseClass(2),
+            };
+            Dictionary<string, BaseClass> valueUpperCase = new(StringComparer.Ordinal)
+            {
+                ["FOO"] = new BaseClass(1),
+                ["ALPHA"] = new BaseClass(2),
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Dictionary<string, BaseClass> deserializedValue = null;
+            Dictionary<string, BaseClass> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(0, BaseClass.Comparer.Compare(value["foo"], deserializedValue["foo"]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(value["alpha"], deserializedValue["alpha"]));
+
+            // All occurrences should deserialize to the first encountered key.
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase["FOO"], deserializedValueUpperCase["foo"]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase["ALPHA"], deserializedValueUpperCase["alpha"]));
+        }
+
+        /// <summary>
+        /// Tests interning dictionaries of { string, string } with path-like values within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternPathDictionaryStringString()
+        {
+            Dictionary<string, string> value = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["foo"] = @"C:\src\msbuild\artifacts\bin\ProjectA.Namespace\Debug\net472\ProjectA.NameSpace.dll",
+                ["alpha"] = @"C:\src\msbuild\artifacts\bin\ProjectB.Namespace\Debug\net472\ProjectB.NameSpace.dll",
+            };
+            Dictionary<string, string> valueUpperCase = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["FOO"] = @"C:\SRC\MSBUILD\ARTIFACTS\BIN\PROJECTA.NAMESPACE\DEBUG\NET472\PROJECTA.NAMESPACE.DLL",
+                ["ALPHA"] = @"C:\SRC\MSBUILD\ARTIFACTS\BIN\PROJECTB.NAMESPACE\DEBUG\NET472\PROJECTB.NAMESPACE.DLL",
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Dictionary<string, string> deserializedValue = null;
+            Dictionary<string, string> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(value["foo"], deserializedValue["foo"]);
+            Assert.Equal(value["alpha"], deserializedValue["alpha"]);
+
+            // All occurrences should deserialize to the first encountered value.
+            // We don't test the keys since the dictionary already uses an ignore case comparer, and
+            // we also want to test that the dictionary comparer matches on both sides.
+            Assert.Equal(valueUpperCase.Count, deserializedValueUpperCase.Count);
+            Assert.Equal(value["foo"], deserializedValueUpperCase["foo"]);
+            Assert.Equal(value["alpha"], deserializedValueUpperCase["alpha"]);
+        }
+
+        /// <summary>
+        /// Tests interning a dictionary of { string, T } with path-like keys within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternPathDictionaryStringT()
+        {
+            const string PathA = @"C:\src\msbuild\artifacts\bin\ProjectA.Namespace\Debug\net472\ProjectA.NameSpace.dll";
+            const string PathB = @"C:\src\msbuild\artifacts\bin\ProjectB.Namespace\Debug\net472\ProjectB.NameSpace.dll";
+
+            // Since we don't have string values, mismatch the key comparer to verify that interning works.
+            Dictionary<string, BaseClass> value = new(StringComparer.Ordinal)
+            {
+                [PathA] = new BaseClass(1),
+                [PathB] = new BaseClass(2),
+            };
+            Dictionary<string, BaseClass> valueUpperCase = new(StringComparer.Ordinal)
+            {
+                [PathA.ToUpperInvariant()] = new BaseClass(1),
+                [PathB.ToUpperInvariant()] = new BaseClass(2),
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Dictionary<string, BaseClass> deserializedValue = null;
+            Dictionary<string, BaseClass> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(0, BaseClass.Comparer.Compare(value[PathA], deserializedValue[PathA]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(value[PathB], deserializedValue[PathB]));
+
+            // All occurrences should deserialize to the first encountered key.
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase[PathA.ToUpperInvariant()], deserializedValueUpperCase[PathA]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase[PathB.ToUpperInvariant()], deserializedValueUpperCase[PathB]));
+        }
+
+
         [Theory]
         [InlineData("en")]
         [InlineData("en-US")]
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 28b8aaf5209..f7d7931853f 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -50,30 +50,25 @@ internal static ITranslator GetWriteTranslator(Stream stream)
             return new BinaryWriteTranslator(stream);
         }
 
-        // TODO: Avoid expsoing write translator?
-        internal static ITranslator GetWriteTranslator(Stream stream, InterningWriteTranslator interner)
-        {
-            return new BinaryWriteTranslator(stream, interner, isInterning: true);
-        }
-
         /// <summary>
         /// Implementation of ITranslator for reading from a stream.
         /// </summary>
         private class BinaryReadTranslator : ITranslator
         {
             /// <summary>
-            /// The stream used as a source or destination for data.
+            /// The intern reader used in an intern scope.
             /// </summary>
-            private Stream _packetStream;
+            private readonly InterningReadTranslator _interner;
 
             /// <summary>
             /// The binary reader used in read mode.
             /// </summary>
             private BinaryReader _reader;
 
-            private InterningReadTranslator _interner;
-
-            public bool IsInterning { get; private set; }
+            /// <summary>
+            /// Whether the caller has entered an intern scope.
+            /// </summary>
+            private bool _isInterning;
 
 #nullable enable
             /// <summary>
@@ -81,9 +76,8 @@ private class BinaryReadTranslator : ITranslator
             /// </summary>
             public BinaryReadTranslator(Stream packetStream, BinaryReaderFactory buffer)
             {
-                _packetStream = packetStream;
                 _reader = buffer.Create(packetStream);
-                _interner = new(this);
+                _interner = new InterningReadTranslator(this);
             }
 #nullable disable
 
@@ -802,40 +796,45 @@ public bool TranslateNullable<T>(T value)
 
             public void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock)
             {
-                if (IsInterning)
+                if (_isInterning)
                 {
                     throw new InvalidOperationException("Cannot enter recursive intern block.");
                 }
 
-                IsInterning = true;
+                _isInterning = true;
 
+                // Deserialize the intern header before entering the intern scope.
                 _interner.Translate(this);
+
+                // No other setup is needed since we can parse the packet directly from the stream.
                 internBlock(this);
 
-                IsInterning = false;
+                _isInterning = false;
             }
 
-            public void Intern(ref string str, bool nullable)
+            public void Intern(ref string str, bool nullable = true)
             {
-                if (!IsInterning)
+                if (!_isInterning)
                 {
                     Translate(ref str);
+                    return;
                 }
-                else if (nullable)
-                {
-                    str = _interner.ReadNullable();
-                }
-                else
+
+                if (nullable && !TranslateNullable(string.Empty))
                 {
-                    str = _interner.Read();
+                    str = null;
+                    return;
                 }
+
+                str = _interner.Read();
             }
 
             public void Intern(ref string[] array)
             {
-                if (!IsInterning)
+                if (!_isInterning)
                 {
                     Translate(ref array);
+                    return;
                 }
 
                 if (!TranslateNullable(array))
@@ -843,30 +842,30 @@ public void Intern(ref string[] array)
                     return;
                 }
 
-
                 int count = _reader.ReadInt32();
                 array = new string[count];
 
                 for (int i = 0; i < count; i++)
                 {
-                    array[i] = _interner.ReadNullable();
+                    array[i] = _interner.Read();
                 }
             }
 
-            public void InternPath(ref string str, bool nullable)
+            public void InternPath(ref string str, bool nullable = true)
             {
-                if (!IsInterning)
+                if (!_isInterning)
                 {
                     Translate(ref str);
+                    return;
                 }
-                else if (nullable)
-                {
-                    str = _interner.ReadNullablePath();
-                }
-                else
+
+                if (nullable && !TranslateNullable(string.Empty))
                 {
-                    str = _interner.ReadPath();
+                    str = null;
+                    return;
                 }
+
+                str = _interner.ReadPath();
             }
         }
 
@@ -875,35 +874,30 @@ public void InternPath(ref string str, bool nullable)
         /// </summary>
         private class BinaryWriteTranslator : ITranslator
         {
-            /// <summary>
-            /// The stream used as a source or destination for data.
-            /// </summary>
-            private Stream _packetStream;
-
             /// <summary>
             /// The binary writer used in write mode.
             /// </summary>
             private BinaryWriter _writer;
 
-            private readonly InterningWriteTranslator _interner = new();
+            /// <summary>
+            /// The intern writer used in an intern scope.
+            /// This must be lazily instantiated since the interner has its own internal write translator, and
+            /// would otherwise go into a recursive loop on initalization.
+            /// </summary>
+            private InterningWriteTranslator _interner;
 
-            public bool IsInterning { get; private set; }
+            /// <summary>
+            /// Whether the caller has entered an intern scope.
+            /// </summary>
+            private bool _isInterning;
 
             /// <summary>
             /// Constructs a serializer from the specified stream, operating in the designated mode.
             /// </summary>
             /// <param name="packetStream">The stream serving as the source or destination of data.</param>
             public BinaryWriteTranslator(Stream packetStream)
-                : this(packetStream, new InterningWriteTranslator())
-            {
-            }
-
-            internal BinaryWriteTranslator(Stream packetStream, InterningWriteTranslator interner, bool isInterning = false)
             {
-                _packetStream = packetStream;
                 _writer = new BinaryWriter(packetStream);
-                _interner = interner;
-                IsInterning = isInterning;
             }
 
             /// <summary>
@@ -1604,67 +1598,88 @@ public bool TranslateNullable<T>(T value)
 
             public void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock)
             {
-                if (IsInterning)
+                if (_isInterning)
                 {
                     throw new InvalidOperationException("Cannot enter recursive intern block.");
                 }
 
-                _interner.InitCapacity(comparer, initialCapacity);
-                internBlock(_interner.Translator);
+                // Every new scope requires the interner's state to be reset.
+                _interner ??= new InterningWriteTranslator();
+                _interner.Setup(comparer, initialCapacity);
+
+                // Temporaily swap our writer with the interner.
+                // This forwards all writes to this translator into the interning buffer, so that any non-interned
+                // writes which are interleaved will be in the correct order.
+                BinaryWriter streamWriter = _writer;
+                _writer = _interner.Writer;
+                _isInterning = true;
+
+                try
+                {
+                    internBlock(this);
+                }
+                finally
+                {
+                    _writer = streamWriter;
+                    _isInterning = false;
+                }
+
+                // Write the interned buffer into the real output stream.
                 _interner.Translate(this);
             }
 
-            public void Intern(ref string str, bool nullable)
+            public void Intern(ref string str, bool nullable = true)
             {
-                if (!IsInterning)
+                if (!_isInterning)
                 {
                     Translate(ref str);
+                    return;
                 }
-                else if (nullable)
-                {
-                    _interner.InternNullable(str);
-                }
-                else
+
+                if (nullable && !TranslateNullable(str))
                 {
-                    _interner.Intern(str);
+                    return;
                 }
+
+                _interner.Intern(str);
             }
 
             public void Intern(ref string[] array)
             {
-                if (!IsInterning)
+                if (!_isInterning)
                 {
                     Translate(ref array);
+                    return;
                 }
 
-                if (!_interner.Translator.TranslateNullable(array))
+                if (!TranslateNullable(array))
                 {
                     return;
                 }
 
                 int count = array.Length;
-                _interner.Translator.Translate(ref count);
+                Translate(ref count);
 
                 for (int i = 0; i < count; i++)
                 {
-                    _interner.InternNullable(array[i]);
+                    _interner.Intern(array[i]);
                 }
             }
 
-            public void InternPath(ref string str, bool nullable)
+            public void InternPath(ref string str, bool nullable = true)
             {
-                if (!IsInterning)
+                if (!_isInterning)
                 {
                     Translate(ref str);
+                    return;
                 }
-                else if (nullable)
-                {
-                    _interner.InternNullablePath(str);
-                }
-                else
+
+                if (nullable && !TranslateNullable(str))
                 {
-                    _interner.InternPath(str);
+                    return;
                 }
+
+                _interner.InternPath(str);
             }
         }
     }
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index efe33cfb0a6..feb3ae3ed29 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -7,8 +7,6 @@
 using System.IO;
 using Microsoft.Build.Framework;
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
@@ -98,8 +96,6 @@ BinaryWriter Writer
             get;
         }
 
-        bool IsInterning { get; }
-
         /// <summary>
         /// Translates a boolean.
         /// </summary>
@@ -369,13 +365,58 @@ void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTrans
         /// <returns>True if the object should be written, false otherwise.</returns>
         bool TranslateNullable<T>(T value);
 
-        void Intern(ref string str, bool nullable = false);
-
-        void Intern(ref string[] array);
+        /// <summary>
+        /// Creates a scope which activates string interning / deduplication for any Intern_xx method.
+        /// This should generally be called from the root level packet.
+        /// </summary>
+        /// <param name="comparer">The strseaparating comparer to use when populating the intern cache.</param>
+        /// <param name="initialCapacity">The initial capacity of the intern cache.</param>
+        /// <param name="internBlock">A delegate providing a translator, in which all Intern_xx calls will go through the intern cache.</param>
+        /// <remarks>
+        /// Packet interning is implemented via a header with an array of all interned strings, followed by the body in
+        /// which any interned / duplicated strings are replaced by their ID.
+        /// <see cref="TranslationDirection"/> modes have different ordering requirements, so it would not be
+        /// possible to implement direction-agnostic serialization via the Intern_xx methods alone:
+        /// - Write: Because we don't know the full list of strings ahead of time, we need to create a temporary buffer
+        ///   for the packet body, which we can later offset when flushing to the real stream.
+        /// - Read: The intern header needs to be deserialized before the packet body, otherwise we won't know what
+        ///   string each ID maps to.
+        /// This method abstracts these requirements to the caller, such that the underlying translator will
+        /// automatically handle the appropriate IO ordering when entering / exiting the delegate scope.
+        /// </remarks>
+        void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock);
 
+        /// <summary>
+        /// Interns the string if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method.
+        /// </summary>
+        /// <param name="str">The value to be translated.</param>
+        /// <param name="nullable">
+        /// Whether to null check and translate the nullable marker.
+        /// Setting this to false can reduce packet sizes when interning large numbers of strings
+        /// which are validated to always be non-null, such as dictionary keys.
+        /// </param>
+        void Intern(ref string str, bool nullable = true);
 
-        void InternPath(ref string str, bool nullable = false);
+        /// <summary>
+        /// Interns each string in the array if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method. To match behavior, all strings
+        /// assumed to be non-null.
+        /// </summary>
+        /// <param name="array">The array to be translated.</param>
+        void Intern(ref string[] array);
 
-        void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock);
+        /// <summary>
+        /// Interns the string if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method.
+        /// If the string is determined to be path-like, the path components will be interned separately.
+        /// </summary>
+        /// <param name="str">The value to be translated.</param>
+        /// <param name="nullable">
+        /// Whether to null check and translate the nullable marker.
+        /// Setting this to false can reduce packet sizes when interning large numbers of strings
+        /// which are validated to always be non-null, such as dictionary keys.
+        /// </param>
+        void InternPath(ref string str, bool nullable = true);
     }
 }
diff --git a/src/Framework/InternPathIds.cs b/src/Framework/InternPathIds.cs
new file mode 100644
index 00000000000..029f31f95ed
--- /dev/null
+++ b/src/Framework/InternPathIds.cs
@@ -0,0 +1,7 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.BackEnd
+{
+    internal readonly record struct InternPathIds(int DirectoryId, int FileNameId);
+}
diff --git a/src/Framework/InterningReadTranslator.cs b/src/Framework/InterningReadTranslator.cs
index f717fc4a3c1..5cb93991091 100644
--- a/src/Framework/InterningReadTranslator.cs
+++ b/src/Framework/InterningReadTranslator.cs
@@ -4,52 +4,46 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.BackEnd
 {
+    /// <summary>
+    /// Reads strings form a translator which contains interned packets.
+    /// </summary>
+    /// <remarks>
+    /// This maintains a reusable lookup table to deserialize packets interned by <see cref="InterningWriteTranslator"/>.
+    /// On Translate, the intern header (aka the array of strings indexed by ID) is deserialized.
+    /// The caller can then forward reads to deserialize any interned values in the packet body.
+    /// </remarks>
     internal sealed class InterningReadTranslator : ITranslatable
     {
+        private readonly ITranslator _translator;
+
         private List<string> _strings = [];
 
-        private Dictionary<PathIds, string> _pathIdsToString = [];
-
-        private readonly ITranslator _translator;
+        private Dictionary<InternPathIds, string> _pathIdsToString = [];
 
         internal InterningReadTranslator(ITranslator translator)
         {
-            _translator = translator;
-        }
-
-        internal string? ReadNullable()
-        {
-            if (!_translator.TranslateNullable(string.Empty))
+            if (translator.Mode != TranslationDirection.ReadFromStream)
             {
-                return null;
+                throw new InvalidOperationException(
+                    $"{nameof(InterningReadTranslator)} can only be used with {nameof(TranslationDirection.ReadFromStream)}.");
             }
 
-            return Read();
+            _translator = translator;
         }
 
-        internal string Read()
+        internal string? Read()
         {
             int key = -1;
             _translator.Translate(ref key);
             return _strings[key];
         }
 
-        internal string? ReadNullablePath()
-        {
-            if (!_translator.TranslateNullable(string.Empty))
-            {
-                return null;
-            }
-
-            return ReadPath();
-        }
-
-        internal string ReadPath()
+        internal string? ReadPath()
         {
+            // If the writer set a null marker, read this as a single string.
             if (!_translator.TranslateNullable(string.Empty))
             {
                 return Read();
@@ -60,8 +54,9 @@ internal string ReadPath()
             _translator.Translate(ref directoryKey);
             _translator.Translate(ref fileNameKey);
 
-            PathIds pathIds = new(directoryKey, fileNameKey);
+            InternPathIds pathIds = new(directoryKey, fileNameKey);
 
+            // Only concatenate paths the first time we encounter a pair.
             if (_pathIdsToString.TryGetValue(pathIds, out string? path))
             {
                 return path;
@@ -77,18 +72,14 @@ internal string ReadPath()
 
         public void Translate(ITranslator translator)
         {
+            // Only deserialize the intern header since the caller will be reading directly from the stream.
             _translator.Translate(ref _strings);
-            foreach (string str in _strings)
-            {
-                Console.WriteLine(str);
-            }
 #if NET
+            _pathIdsToString.Clear();
             _pathIdsToString.EnsureCapacity(_strings.Count);
 #else
             _pathIdsToString = new(_strings.Count);
 #endif
         }
-
-        private readonly record struct PathIds(int DirectoryId, int FileNameId);
     }
 }
diff --git a/src/Framework/InterningWriteTranslator.cs b/src/Framework/InterningWriteTranslator.cs
index b992ca68e8d..a261ce6a483 100644
--- a/src/Framework/InterningWriteTranslator.cs
+++ b/src/Framework/InterningWriteTranslator.cs
@@ -4,55 +4,105 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.BackEnd
 {
+    /// <summary>
+    /// Writes strings into a translator with interning / deduplication.
+    /// </summary>
+    /// <remarks>
+    /// This maintains a reusable temporary buffer and lookup table for deduplicating strings within a translatable packet.
+    /// All unique strings (as determined by the comparer) will be assigned an incrementing ID and stored into a dictionary.
+    /// This ID will be written to a private buffer in place of the string and any repeat occurrences.
+    /// When serialized into another translator, the interner will:
+    /// 1. Serialize the list of unique strings to an array, where the ID is the index.
+    /// 2. Serialize the temporary buffer (aka the packet body) with all interned strings replaced by their ID.
+    /// This ordering is important since the reader will need the string lookup table before parsing the body.
+    /// As such, two rules need to be follwed when using this class:
+    /// 1. Any interleaved non-interned writes should be written using the exposed BinaryWriter to keep the overall
+    /// packet in sync.
+    /// 2. Translate should *only* be called after all internable writes have been processed.
+    /// </remarks>
     internal sealed class InterningWriteTranslator : ITranslatable
     {
-        private List<string> _strings = [];
+        private static readonly char[] DirectorySeparatorChars = [Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar];
 
-        private Dictionary<string, int> _stringToIds = [];
+        private static readonly string IsPathMarker = string.Empty;
 
-        private Dictionary<string, PathIds> _stringToPathIds = [];
+        private static readonly string? NotPathMarker = null;
 
-        private MemoryStream _packetStream = new();
+        private readonly ITranslator _translator;
 
-#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
-        // Recursive loop
-        internal ITranslator Translator { get; private set; }
-#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
+        private readonly MemoryStream _packetStream;
 
-        internal void InitCapacity(IEqualityComparer<string> comparer, int count)
+        private List<string> _strings = [];
+
+        private Dictionary<string, int> _stringToIds = [];
+
+        private Dictionary<string, InternPathIds> _stringToPathIds = [];
+
+        internal InterningWriteTranslator()
         {
-            if (Translator == null)
-            {
-                Translator = BinaryTranslator.GetWriteTranslator(_packetStream, this);
-            }
+            _packetStream = new MemoryStream();
+            _translator = BinaryTranslator.GetWriteTranslator(_packetStream);
 
-            int capacity = count * 8;
-            int bufferCapacity = capacity * 128;
-            _stringToIds = new Dictionary<string, int>(count * 8, comparer);
-            _stringToPathIds = new Dictionary<string, PathIds>(count * 8, comparer);
-            _strings.Clear();
-            _strings.Capacity = capacity;
-            _packetStream.Position = 0;
-            _packetStream.SetLength(0);
-            _packetStream.Capacity = bufferCapacity;
+            // Avoid directly exposing the buffered translator - any accidental Intern_xx method calls could go into a
+            // recursive loop.
+            Writer = _translator.Writer;
         }
 
-        internal void Intern(string str) => InternString(str);
-
-        internal void InternNullable(string str)
+        /// <summary>
+        /// The writer for the underlying buffer.
+        /// Use to forward any non-interning writes into this translator.
+        /// </summary>
+        internal BinaryWriter Writer { get; }
+
+        /// <summary>
+        /// Setup the intern cache and underlying buffer. This allows the interner to be reused.
+        /// </summary>
+        /// <param name="comparer">The string comparer to use for string deduplication.</param>
+        /// <param name="initialCapacity">An estimate of the number of unique strings to be interned.</param>
+        internal void Setup(IEqualityComparer<string> comparer, int initialCapacity)
         {
-            if (!Translator.TranslateNullable(str))
+#if NET
+            if (_stringToIds.Comparer == comparer)
             {
-                return;
+                // Clear before setting capacity, since dictionaries will rehash every entry.
+                _strings.Clear();
+                _stringToIds.Clear();
+                _stringToPathIds.Clear();
+                _strings.EnsureCapacity(initialCapacity);
+                _stringToIds.EnsureCapacity(initialCapacity);
+                _stringToPathIds.EnsureCapacity(initialCapacity);
             }
+            else
+            {
+#endif
+                // If the interner is in a reused translator, the comparer might not match between packets.
+                // Just throw away the old collections in this case.
+                _strings.Clear();
+                _strings.Capacity = initialCapacity;
+                _stringToIds = new Dictionary<string, int>(initialCapacity, comparer);
+                _stringToPathIds = new Dictionary<string, InternPathIds>(initialCapacity, comparer);
+#if NET
+            }
+#endif
+            _packetStream.Position = 0;
+            _packetStream.SetLength(0);
 
-            InternString(str);
+            // This is a rough estimate since the final size will depend on the length of each string and the total number
+            // of intern cache hits. Assume a mixture of short strings (e.g. item metadata pairs, RAR assembly metadata)
+            // and file paths (e.g. item include paths, RAR statefile entries).
+            const int CharactersPerString = 32;
+            const int BytesPerCharacter = 2;
+            const int BytesPerInternedString = 5;
+            int internHeaderSize = initialCapacity * CharactersPerString * BytesPerCharacter;
+            int packetPayloadSize = initialCapacity * BytesPerInternedString;
+            _packetStream.Capacity = internHeaderSize + packetPayloadSize;
         }
 
+        internal void Intern(string str) => _ = InternString(str);
+
         private int InternString(string str)
         {
             if (!_stringToIds.TryGetValue(str, out int index))
@@ -62,70 +112,62 @@ private int InternString(string str)
                 _strings.Add(str);
             }
 
-            Translator.Translate(ref index);
+            _translator.Translate(ref index);
             return index;
         }
 
-        internal void InternNullablePath(string str)
-        {
-            if (!Translator.TranslateNullable(str))
-            {
-                return;
-            }
-
-            InternPath(str);
-        }
-
         internal void InternPath(string str)
         {
-            if (_stringToPathIds.TryGetValue(str, out PathIds pathIds))
+            // If we've seen a string already and know it's path-like, we just need the index pair.
+            if (_stringToPathIds.TryGetValue(str, out InternPathIds pathIds))
             {
-                _ = Translator.TranslateNullable(string.Empty);
+                _ = _translator.TranslateNullable(IsPathMarker);
                 int directoryId = pathIds.DirectoryId;
                 int fileNameId = pathIds.FileNameId;
-                Translator.Translate(ref directoryId);
-                Translator.Translate(ref fileNameId);
+                _translator.Translate(ref directoryId);
+                _translator.Translate(ref fileNameId);
                 return;
             }
 
-            int splitId = str.LastIndexOf(Path.DirectorySeparatorChar);
-
-            if (splitId == -1)
-            {
-                splitId = str.LastIndexOf(Path.AltDirectorySeparatorChar);
-            }
-
+            // Quick and basic heuristic to check if we have a path-like string.
+            int splitId = str.LastIndexOfAny(DirectorySeparatorChars);
             bool hasDirectorySeparator = splitId > -1
                 && splitId < str.Length - 1
                 && str.IndexOf('%') == -1;
 
             if (!hasDirectorySeparator)
             {
-                string? dummy = null;
-                _ = Translator.TranslateNullable(dummy);
+                // Set a marker to signal the reader to parse this as a single string.
+                _ = _translator.TranslateNullable(NotPathMarker);
                 _ = InternString(str);
                 return;
             }
 
-            // If we've seen a string already and know it's pathlike, we just need the index duo
             string directory = str.Substring(0, splitId + 1);
             string fileName = str.Substring(splitId + 1);
 
-            _ = Translator.TranslateNullable(string.Empty);
+            _ = _translator.TranslateNullable(IsPathMarker);
             int directoryIndex = InternString(directory);
             int fileNameIndex = InternString(fileName);
 
-            _stringToPathIds.Add(str, new PathIds(directoryIndex, fileNameIndex));
+            _stringToPathIds.Add(str, new InternPathIds(directoryIndex, fileNameIndex));
         }
 
         public void Translate(ITranslator translator)
         {
+            if (translator.Mode != TranslationDirection.WriteToStream)
+            {
+                throw new InvalidOperationException(
+                    $"{nameof(InterningWriteTranslator)} can only be used with {nameof(TranslationDirection.WriteToStream)}.");
+            }
+
+            // Write the set of unique strings as the packet header.
             translator.Translate(ref _strings);
+
+            // Write the temporary buffer as the packet body.
             byte[] buffer = _packetStream.GetBuffer();
             int bufferSize = (int)_packetStream.Length;
             translator.Writer.Write(buffer, 0, bufferSize);
         }
-
-        private readonly record struct PathIds(int DirectoryId, int FileNameId);
     }
 }
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index 20e274a040d..b3c6a5573bd 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -89,7 +89,10 @@ public static void TranslateDictionary<T>(
             translator.TranslateDictionary(ref dictionary, comparer, AdaptFactory(valueFactory));
         }
 
-        public static void InternDictionary(this ITranslator translator, ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer)
+        public static void InternDictionary(
+            this ITranslator translator,
+            ref Dictionary<string, string> dictionary,
+            IEqualityComparer<string> comparer)
         {
             IDictionary<string, string> localDict = dictionary;
             translator.TranslateDictionary(
@@ -100,7 +103,11 @@ public static void InternDictionary(this ITranslator translator, ref Dictionary<
             dictionary = (Dictionary<string, string>)localDict;
         }
 
-        public static void InternDictionary<T>(this ITranslator translator, ref Dictionary<string, T> dictionary, IEqualityComparer<string> stringComparer, NodePacketValueFactory<T> valueFactory)
+        public static void InternDictionary<T>(
+            this ITranslator translator,
+            ref Dictionary<string, T> dictionary,
+            IEqualityComparer<string> stringComparer,
+            NodePacketValueFactory<T> valueFactory)
             where T : ITranslatable
         {
             IDictionary<string, T> localDict = dictionary;
@@ -112,9 +119,14 @@ public static void InternDictionary<T>(this ITranslator translator, ref Dictiona
             dictionary = (Dictionary<string, T>)localDict;
         }
 
-        public static void InternPathDictionary(this ITranslator translator, ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer)
+        public static void InternPathDictionary(
+            this ITranslator translator,
+            ref Dictionary<string, string> dictionary,
+            IEqualityComparer<string> comparer)
         {
             IDictionary<string, string> localDict = dictionary;
+
+            // For now, assume only the value contains path-like strings (e.g. TaskItem metadata).
             translator.TranslateDictionary(
                 ref localDict,
                 (ITranslator translator, ref string key) => translator.Intern(ref key),
@@ -123,7 +135,11 @@ public static void InternPathDictionary(this ITranslator translator, ref Diction
             dictionary = (Dictionary<string, string>)localDict;
         }
 
-        public static void InternPathDictionary<T>(this ITranslator translator, ref Dictionary<string, T> dictionary, IEqualityComparer<string> stringComparer, NodePacketValueFactory<T> valueFactory)
+        public static void InternPathDictionary<T>(
+            this ITranslator translator,
+            ref Dictionary<string, T> dictionary,
+            IEqualityComparer<string> stringComparer,
+            NodePacketValueFactory<T> valueFactory)
             where T : ITranslatable
         {
             IDictionary<string, T> localDict = dictionary;
@@ -293,14 +309,14 @@ public static void Translate(this ITranslator translator, ref AssemblyName assem
                 publicKeyToken = assemblyName.GetPublicKeyToken();
             }
 
-            translator.InternPath(ref name, nullable: true);
+            translator.Translate(ref name);
             translator.Translate(ref version);
             translator.TranslateEnum(ref flags, (int)flags);
             translator.TranslateEnum(ref processorArchitecture, (int)processorArchitecture);
             translator.Translate(ref cultureInfo);
             translator.TranslateEnum(ref hashAlgorithm, (int)hashAlgorithm);
             translator.TranslateEnum(ref versionCompatibility, (int)versionCompatibility);
-            translator.Intern(ref codeBase, nullable: true);
+            translator.Translate(ref codeBase);
 
             translator.Translate(ref publicKey);
             translator.Translate(ref publicKeyToken);
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index a61fa4aad10..cbb66f13907 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -265,13 +265,10 @@ public override void Translate(ITranslator translator)
                 throw new NullReferenceException(nameof(instanceLocalFileStateCache));
             }
 
-            translator.WithInterning(StringComparer.Ordinal, 100, translator =>
-            {
-                translator.InternPathDictionary(
-                    ref (translator.Mode == TranslationDirection.WriteToStream) ? ref instanceLocalOutgoingFileStateCache : ref instanceLocalFileStateCache,
-                    StringComparer.OrdinalIgnoreCase,
-                    t => new FileState(t));
-            });
+            translator.TranslateDictionary(
+                ref (translator.Mode == TranslationDirection.WriteToStream) ? ref instanceLocalOutgoingFileStateCache : ref instanceLocalFileStateCache,
+                StringComparer.OrdinalIgnoreCase,
+                (ITranslator t) => new FileState(t));
 
             // IsDirty should be false for either direction. Either this cache was brought
             // up-to-date with the on-disk cache or vice versa. Either way, they agree.
