diff --git a/.github/policies/resourceManagement.yml b/.github/policies/resourceManagement.yml
index effb189ad06..c65e138b268 100644
--- a/.github/policies/resourceManagement.yml
+++ b/.github/policies/resourceManagement.yml
@@ -168,5 +168,36 @@ configuration:
       - addReply:
           reply: Hello @${issueAuthor}, I noticed that you’re changing an *.swr file or any file under src/Package/MSBuild.VSSetup.*. Please make sure to validate this change by an experimental VS insertion. This is accomplished by pushing to an exp/* branch, which requires write permissions to this repo.
       description: Remind to run VS Perf DDRITs when deployed assemblies change
+    - if:
+      - payloadType: Issues
+      - labelAdded:
+          label: breaking-change
+      then:
+      - addReply:
+          reply: >-
+            Refer to the [.NET SDK breaking change guidelines](https://github.com/dotnet/sdk/blob/main/documentation/project-docs/breaking-change-guidelines.md#required-process-for-all-net-sdk-breaking-changes)
+      description: Add breaking change doc instructions to issue
+    - if:
+      - payloadType: Pull_Request
+      - labelAdded:
+          label: breaking-change
+      then:
+      - addLabel:
+          label: needs-breaking-change-doc-created
+      - addReply:
+          reply: >-
+            Added `needs-breaking-change-doc-created` label because this PR has the `breaking-change` label. 
+
+
+            When you commit this breaking change:
+
+
+            1. [ ] Create and link to this PR and the issue a matching issue in the dotnet/docs repo using the [breaking change documentation template](https://aka.ms/dotnet/docs/new-breaking-change-issue), then remove this `needs-breaking-change-doc-created` label.
+
+            2. [ ] Ask a committer to mail the `.NET SDK Breaking Change Notification` email list.
+
+
+            You can refer to the [.NET SDK breaking change guidelines](https://github.com/dotnet/sdk/blob/main/documentation/project-docs/breaking-change-guidelines.md)
+      description: Add breaking change instructions to PR.      
 onFailure: 
 onSuccess: 
diff --git a/.github/workflows/copilot-setup-steps.yml b/.github/workflows/copilot-setup-steps.yml
new file mode 100644
index 00000000000..1cc553480d6
--- /dev/null
+++ b/.github/workflows/copilot-setup-steps.yml
@@ -0,0 +1,25 @@
+name: "Copilot Setup Steps"
+
+# Allow testing of the setup steps from your repository's "Actions" tab.
+on: workflow_dispatch
+
+jobs:
+  # The job MUST be called `copilot-setup-steps` or it will not be picked up by Copilot.
+  # See https://docs.github.com/en/copilot/customizing-copilot/customizing-the-development-environment-for-copilot-coding-agent
+  copilot-setup-steps:
+    runs-on: ubuntu-latest
+
+    permissions:
+      contents: read
+
+    # You can define any steps you want, and they will run before the agent starts.
+    # If you do not check out your code, Copilot will do this for you.
+    steps:
+      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
+
+      - uses: actions/setup-dotnet@67a3573c9a986a3f9c594539f4ab511d57bb3ce9 # 4.3.1
+        with:
+          global-json-file: global.json
+
+      - name: Restore MSBuild
+        run: ./eng/common/build.sh --restore
diff --git a/.github/workflows/labeler-cache-retention.yml b/.github/workflows/labeler-cache-retention.yml
new file mode 100644
index 00000000000..235b0e42cf2
--- /dev/null
+++ b/.github/workflows/labeler-cache-retention.yml
@@ -0,0 +1,40 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Regularly restore the prediction models from cache to prevent cache eviction
+name: "Labeler: Cache Retention"
+
+# For more information about GitHub's action cache limits and eviction policy, see:
+# https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows#usage-limits-and-eviction-policy
+
+on:
+  schedule:
+    - cron: "10 3 * * *" # 3:10 every day (arbitrary time daily, modified to different values in each repository)
+
+  workflow_dispatch:
+    inputs:
+      cache_key:
+        description: "The cache key suffix to use for restoring the model from cache. Defaults to 'ACTIVE'."
+        required: true
+        default: "ACTIVE"
+
+env:
+  CACHE_KEY: ${{ inputs.cache_key || 'ACTIVE' }}
+
+jobs:
+  restore-cache:
+    # Do not automatically run the workflow on forks outside the 'dotnet' org
+    if: ${{ github.event_name == 'workflow_dispatch' || github.repository_owner == 'dotnet' }}
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        type: ["issues"] # Pulls are disabled in this repository, so "pulls" is removed from the matrix
+    steps:
+      - uses: dotnet/issue-labeler/restore@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: ${{ matrix.type }}
+          cache_key: ${{ env.CACHE_KEY }}
+          fail-on-cache-miss: true
diff --git a/.github/workflows/labeler-predict-issues.yml b/.github/workflows/labeler-predict-issues.yml
new file mode 100644
index 00000000000..8db06b94696
--- /dev/null
+++ b/.github/workflows/labeler-predict-issues.yml
@@ -0,0 +1,58 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Predict labels for Issues using a trained model
+name: "Labeler: Predict (Issues)"
+
+on:
+  # Only automatically predict area labels when issues are first opened
+  issues:
+    types: opened
+
+  # Allow dispatching the workflow via the Actions UI, specifying ranges of numbers
+  workflow_dispatch:
+    inputs:
+      issues:
+        description: "Issue Numbers (comma-separated list of ranges)."
+        required: true
+      cache_key:
+        description: "The cache key suffix to use for restoring the model. Defaults to 'ACTIVE'."
+        required: true
+        default: "ACTIVE"
+
+env:
+  # Do not allow failure for jobs triggered automatically (as this causes red noise on the workflows list)
+  ALLOW_FAILURE: ${{ github.event_name == 'workflow_dispatch' }}
+
+  LABEL_PREFIX: "Area: "
+  THRESHOLD: 0.40
+
+jobs:
+  predict-issue-label:
+    # Do not automatically run the workflow on forks outside the 'dotnet' org
+    if: ${{ github.event_name == 'workflow_dispatch' || github.repository_owner == 'dotnet' }}
+    runs-on: ubuntu-latest
+    permissions:
+      issues: write
+    steps:
+      - name: "Restore issues model from cache"
+        id: restore-model
+        uses: dotnet/issue-labeler/restore@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: issues
+          fail-on-cache-miss: ${{ env.ALLOW_FAILURE }}
+          quiet: true
+
+      - name: "Predict issue labels"
+        id: prediction
+        if: ${{ steps.restore-model.outputs.cache-hit == 'true' }}
+        uses: dotnet/issue-labeler/predict@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          issues: ${{ inputs.issues || github.event.issue.number }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          threshold: ${{ env.THRESHOLD }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+        continue-on-error: ${{ !env.ALLOW_FAILURE }}
diff --git a/.github/workflows/labeler-predict-pulls.yml b/.github/workflows/labeler-predict-pulls.yml
new file mode 100644
index 00000000000..ff0c2c61f1c
--- /dev/null
+++ b/.github/workflows/labeler-predict-pulls.yml
@@ -0,0 +1,72 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Predict labels for Pull Requests using a trained model
+name: "Labeler: Predict (Pulls)"
+
+on:
+  # Per to the following documentation:
+  # https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#pull_request_target
+  #
+  # The `pull_request_target` event runs in the context of the base of the pull request, rather
+  # than in the context of the merge commit, as the `pull_request` event does. This prevents
+  # execution of unsafe code from the head of the pull request that could alter the repository
+  # or steal any secrets you use in your workflow. This event allows your workflow to do things
+  # like label or comment on pull requests from forks.
+  #
+  # Only automatically predict area labels when pull requests are first opened
+  pull_request_target:
+    types: opened
+
+    # Configure the branches that need to have PRs labeled
+    branches:
+      - 'main'
+      - 'vs*'
+
+  # Allow dispatching the workflow via the Actions UI, specifying ranges of numbers
+  workflow_dispatch:
+    inputs:
+      pulls:
+        description: "Pull Request Numbers (comma-separated list of ranges)."
+        required: true
+      cache_key:
+        description: "The cache key suffix to use for restoring the model. Defaults to 'ACTIVE'."
+        required: true
+        default: "ACTIVE"
+
+env:
+  # Do not allow failure for jobs triggered automatically (this can block PR merge)
+  ALLOW_FAILURE: ${{ github.event_name == 'workflow_dispatch' }}
+
+  LABEL_PREFIX: "Area: "
+  THRESHOLD: 0.40
+
+jobs:
+  predict-pull-label:
+    # Do not automatically run the workflow on forks outside the 'dotnet' org
+    if: ${{ github.event_name == 'workflow_dispatch' || github.repository_owner == 'dotnet' }}
+    runs-on: ubuntu-latest
+    permissions:
+      pull-requests: write
+    steps:
+      - name: "Restore pulls model from cache"
+        id: restore-model
+        uses: dotnet/issue-labeler/restore@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: pulls
+          fail-on-cache-miss: ${{ env.ALLOW_FAILURE }}
+          quiet: true
+
+      - name: "Predict pull labels"
+        id: prediction
+        if: ${{ steps.restore-model.outputs.cache-hit == 'true' }}
+        uses: dotnet/issue-labeler/predict@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          pulls: ${{ inputs.pulls || github.event.number }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          threshold: ${{ env.THRESHOLD }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+        continue-on-error: ${{ !env.ALLOW_FAILURE }}
diff --git a/.github/workflows/labeler-promote.yml b/.github/workflows/labeler-promote.yml
new file mode 100644
index 00000000000..c01086c5177
--- /dev/null
+++ b/.github/workflows/labeler-promote.yml
@@ -0,0 +1,54 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Promote a model from staging to 'ACTIVE', backing up the currently 'ACTIVE' model
+name: "Labeler: Promotion"
+
+on:
+  # Dispatched via the Actions UI, promotes the staged models from
+  # a staged slot into the prediction environment
+  workflow_dispatch:
+    inputs:
+      issues:
+        description: "Issues: Promote Model"
+        type: boolean
+        required: true
+      pulls:
+        description: "Pulls: Promote Model"
+        type: boolean
+        required: true
+      staged_key:
+        description: "The cache key suffix to use for promoting a staged model to 'ACTIVE'. Defaults to 'staged'."
+        required: true
+        default: "staged"
+      backup_key:
+        description: "The cache key suffix to use for backing up the currently active model. Defaults to 'backup'."
+        default: "backup"
+
+permissions:
+  actions: write
+
+jobs:
+  promote-issues:
+    if: ${{ inputs.issues }}
+    runs-on: ubuntu-latest
+    steps:
+      - name: "Promote Model for Issues"
+        uses: dotnet/issue-labeler/promote@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "issues"
+          staged_key: ${{ inputs.staged_key }}
+          backup_key: ${{ inputs.backup_key }}
+
+  promote-pulls:
+    if: ${{ inputs.pulls }}
+    runs-on: ubuntu-latest
+    steps:
+      - name: "Promote Model for Pull Requests"
+        uses: dotnet/issue-labeler/promote@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "pulls"
+          staged_key: ${{ inputs.staged_key }}
+          backup_key: ${{ inputs.backup_key }}
diff --git a/.github/workflows/labeler-train.yml b/.github/workflows/labeler-train.yml
new file mode 100644
index 00000000000..85a816fb064
--- /dev/null
+++ b/.github/workflows/labeler-train.yml
@@ -0,0 +1,165 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Train the Issues and Pull Requests models for label prediction
+name: "Labeler: Training"
+
+on:
+  workflow_dispatch:
+    inputs:
+      type:
+        description: "Issues or Pull Requests"
+        type: choice
+        required: true
+        default: "Issues" # Pulls are disabled in this repository, so default to "Issues" only
+        options:
+          - "Both"
+          - "Issues"
+          - "Pull Requests"
+
+      steps:
+        description: "Training Steps"
+        type: choice
+        required: true
+        default: "All"
+        options:
+          - "All"
+          - "Download Data"
+          - "Train Model"
+          - "Test Model"
+
+      limit:
+        description: "Max number of items to download for training/testing the model (newest items are used). Defaults to the max number of pages times the page size."
+        type: number
+      page_size:
+        description: "Number of items per page in GitHub API requests. Defaults to 100 for issues, 25 for pull requests."
+        type: number
+      page_limit:
+        description: "Maximum number of pages to download for training/testing the model. Defaults to 1000 for issues, 4000 for pull requests."
+        type: number
+      cache_key_suffix:
+        description: "The cache key suffix to use for staged data/models (use 'ACTIVE' to bypass staging). Defaults to 'staged'."
+        required: true
+        default: "staged"
+
+env:
+  CACHE_KEY: ${{ inputs.cache_key_suffix }}
+  REPOSITORY: ${{ github.repository }}
+  LABEL_PREFIX: "Area: "
+  THRESHOLD: "0.40"
+  LIMIT: ${{ inputs.limit }}
+  PAGE_SIZE: ${{ inputs.page_size }}
+  PAGE_LIMIT: ${{ inputs.page_limit }}
+
+jobs:
+  download-issues:
+    if: ${{ contains(fromJSON('["Both", "Issues"]'), inputs.type) && contains(fromJSON('["All", "Download Data"]'), inputs.steps) }}
+    runs-on: ubuntu-latest
+    permissions:
+      issues: read
+    steps:
+      - name: "Download Issues"
+        uses: dotnet/issue-labeler/download@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "issues"
+          cache_key: ${{ env.CACHE_KEY }}
+          repository: ${{ env.REPOSITORY }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          limit: ${{ env.LIMIT }}
+          page_size: ${{ env.PAGE_SIZE }}
+          page_limit: ${{ env.PAGE_LIMIT }}
+          excluded_authors: ${{ env.EXCLUDED_AUTHORS }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+
+  download-pulls:
+    if: ${{ contains(fromJSON('["Both", "Pull Requests"]'), inputs.type) && contains(fromJSON('["All", "Download Data"]'), inputs.steps) }}
+    runs-on: ubuntu-latest
+    permissions:
+      pull-requests: read
+    steps:
+      - name: "Download Pull Requests"
+        uses: dotnet/issue-labeler/download@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "pulls"
+          cache_key: ${{ env.CACHE_KEY }}
+          repository: ${{ env.REPOSITORY }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          limit: ${{ env.LIMIT }}
+          page_size: ${{ env.PAGE_SIZE }}
+          page_limit: ${{ env.PAGE_LIMIT }}
+          excluded_authors: ${{ env.EXCLUDED_AUTHORS }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+
+  train-issues:
+    if: ${{ always() && contains(fromJSON('["Both", "Issues"]'), inputs.type) && contains(fromJSON('["All", "Train Model"]'), inputs.steps) && contains(fromJSON('["success", "skipped"]'), needs.download-issues.result) }}
+    runs-on: ubuntu-latest
+    permissions: {}
+    needs: download-issues
+    steps:
+      - name: "Train Model for Issues"
+        uses: dotnet/issue-labeler/train@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "issues"
+          data_cache_key: ${{ env.CACHE_KEY }}
+          model_cache_key: ${{ env.CACHE_KEY }}
+
+  train-pulls:
+    if: ${{ always() && contains(fromJSON('["Both", "Pull Requests"]'), inputs.type) && contains(fromJSON('["All", "Train Model"]'), inputs.steps) && contains(fromJSON('["success", "skipped"]'), needs.download-pulls.result) }}
+    runs-on: ubuntu-latest
+    permissions: {}
+    needs: download-pulls
+    steps:
+      - name: "Train Model for Pull Requests"
+        uses: dotnet/issue-labeler/train@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "pulls"
+          data_cache_key: ${{ env.CACHE_KEY }}
+          model_cache_key: ${{ env.CACHE_KEY }}
+
+  test-issues:
+    if: ${{ always() && contains(fromJSON('["Both", "Issues"]'), inputs.type) && contains(fromJSON('["All", "Test Model"]'), inputs.steps) && contains(fromJSON('["success", "skipped"]'), needs.train-issues.result) }}
+    runs-on: ubuntu-latest
+    permissions:
+      issues: read
+    needs: train-issues
+    steps:
+      - name: "Test Model for Issues"
+        uses: dotnet/issue-labeler/test@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "issues"
+          cache_key: ${{ env.CACHE_KEY }}
+          repository: ${{ env.REPOSITORY }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          threshold: ${{ env.THRESHOLD }}
+          limit: ${{ env.LIMIT }}
+          page_size: ${{ env.PAGE_SIZE }}
+          page_limit: ${{ env.PAGE_LIMIT }}
+          excluded_authors: ${{ env.EXCLUDED_AUTHORS }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+
+  test-pulls:
+    if: ${{ always() && contains(fromJSON('["Both", "Pull Requests"]'), inputs.type) && contains(fromJSON('["All", "Test Model"]'), inputs.steps) && contains(fromJSON('["success", "skipped"]'), needs.train-pulls.result) }}
+    runs-on: ubuntu-latest
+    permissions:
+      pull-requests: read
+    needs: train-pulls
+    steps:
+      - name: "Test Model for Pull Requests"
+        uses: dotnet/issue-labeler/test@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "pulls"
+          cache_key: ${{ env.CACHE_KEY }}
+          repository: ${{ env.REPOSITORY }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          threshold: ${{ env.THRESHOLD }}
+          limit: ${{ env.LIMIT }}
+          page_size: ${{ env.PAGE_SIZE }}
+          page_limit: ${{ env.PAGE_LIMIT }}
+          excluded_authors: ${{ env.EXCLUDED_AUTHORS }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
diff --git a/.github/workflows/labeler.md b/.github/workflows/labeler.md
new file mode 100644
index 00000000000..84d004aeed5
--- /dev/null
+++ b/.github/workflows/labeler.md
@@ -0,0 +1,36 @@
+# Issue-Labeler Workflows
+
+This repository uses actions from [dotnet/issue-labeler](https://github.com/dotnet/issue-labeler) to predict area labels for issues and pull requests.
+
+The following workflow templates were imported and updated from [dotnet/issue-labeler/wiki/Onboarding](https://github.com/dotnet/issue-labeler/wiki/Onboarding):
+
+1. `labeler-cache-retention.yml`
+2. `labeler-predict-issues.yml`
+3. `labeler-predict-pulls.yml`
+4. `labeler-promote.yml`
+5. `labeler-train.yml`
+
+## Repository Configuration
+
+Across these workflows, the following changes were made to configure the issue labeler for this repository:
+
+1. Set `LABEL_PREFIX` to `"Area: "`:
+    - `labeler-predict-issues.yml`
+    - `labeler-predict-pulls.yml`
+    - `labeler-train.yml`
+2. Remove the `DEFAULT_LABEL` setting since no default label is applied when prediction is not made:
+    - `labeler-predict-issues.yml`
+    - `labeler-predict-pulls.yml`
+3. Remove the `EXCLUDED_AUTHORS` value as we do not bypass labeling for any authors' issues/pulls in this repository:
+    - `labeler-predict-issues.yml`
+    - `labeler-predict-pulls.yml`
+4. Update the pull request labeling branches to include `main` and `vs*`:
+    - `labeler-predict-pulls.yml`
+5. Remove the `repository` input for training the models against another repository:
+    - `labeler-train.yml`
+6. Update the cache retention cron schedule to an arbitrary time of day:
+    - `labeler-cache-retention.yml`
+7. Disable pull request training, cache retention, and predition
+    - `labeler-train.yml` - Change the default from "Both" to "Issues"
+    - `labeler-cache-retention.yml` - Remove "pulls" from the job matrix (leaving a comment)
+    - `labeler-predict-pulls.yml` - Workflow marked as Disabled via GitHub UI
diff --git a/.github/workflows/perfstar-branch.yml b/.github/workflows/perfstar-branch.yml
new file mode 100644
index 00000000000..f7f52492417
--- /dev/null
+++ b/.github/workflows/perfstar-branch.yml
@@ -0,0 +1,55 @@
+name: Create Perf Branch on /perfstar comment
+
+on:
+  issue_comment:
+    types: [created]
+
+permissions:
+  contents: write
+  pull-requests: read
+
+jobs:
+  create_perf_branch:
+    if: |
+      github.event.issue.pull_request &&
+      github.event.comment.body == '/perfstar' &&
+      contains(fromJSON('["COLLABORATOR", "MEMBER", "OWNER"]'), github.event.comment.author_association)
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout repository
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+
+      - name: Get PR information
+        id: pr_info
+        run: |
+          PR_DATA=$(gh pr view ${{ github.event.issue.number }} --json headRefName,headRefOid,headRepository)
+          HEAD_REF=$(echo $PR_DATA | jq -r '.headRefName')
+          HEAD_SHA=$(echo $PR_DATA | jq -r '.headRefOid')
+          HEAD_REPO=$(echo $PR_DATA | jq -r '.headRepository.nameWithOwner')
+          
+          echo "pr_head_branch=${HEAD_REF}" >> $GITHUB_OUTPUT
+          echo "pr_head_sha=${HEAD_SHA}" >> $GITHUB_OUTPUT
+          echo "pr_head_repo=${HEAD_REPO}" >> $GITHUB_OUTPUT
+          echo "new_branch_name=perf/${HEAD_REF}" >> $GITHUB_OUTPUT
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+
+      - name: Create and push perf branch
+        run: |
+          git config user.name "github-actions[bot]"
+          git config user.email "github-actions[bot]@users.noreply.github.com"
+          
+          # Ensure we can access the PR's commits (especially important for forks)
+          git fetch origin pull/${{ github.event.issue.number }}/head:pr-${{ github.event.issue.number }}-head
+          
+          # Create branch from PR head
+          git checkout -b ${{ steps.pr_info.outputs.new_branch_name }} ${{ steps.pr_info.outputs.pr_head_sha }}
+          
+          # Merge main branch
+          git fetch origin main
+          git merge origin/main --no-ff --no-edit -m "Merge main into ${{ steps.pr_info.outputs.new_branch_name }} for perf testing"
+          
+          # Push branch
+          git push origin ${{ steps.pr_info.outputs.new_branch_name }}
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 3ea490a61af..03d6b6d9b64 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -14,40 +14,40 @@ variables:
   value: none
 
 jobs:
-# - job: CheckVersionBumpOnReleaseBranches
-#   displayName: "Check Version Bump On Release Branches"
-#   steps:
-#   - powershell: |
-#       $versionsFile = "eng/Versions.props"
-#       $changedFiles = git diff --name-only HEAD HEAD~1
-#       $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
-#       $isInitialCommit = $false
-#       $isVersionBumped = $false
-#       if ($changedVersionsFile -ne $null) {
-#         $difference = git diff HEAD~1 $versionsFile
-#         $changedContent = $difference -join "%"
-#         # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
-#         $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
-#         $isInitialCommit = $changedContent -match $initialCommitPattern
-#         $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
-#         if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
-#           try {
-#             $previousPatch = [Convert]::ToInt32($Matches.previous)
-#             $currentPatch = [Convert]::ToInt32($Matches.current)
-#             if ($currentPatch -gt $previousPatch) {
-#               $isVersionBumped = $true
-#             }
-#           } catch {
-#             Write-Host "An error occurred during conversion: $_"
-#           }
-#         }
-#       }
+- job: CheckVersionBumpOnReleaseBranches
+  displayName: "Check Version Bump On Release Branches"
+  steps:
+  - powershell: |
+      $versionsFile = "eng/Versions.props"
+      $changedFiles = git diff --name-only HEAD HEAD~1
+      $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
+      $isInitialCommit = $false
+      $isVersionBumped = $false
+      if ($changedVersionsFile -ne $null) {
+        $difference = git diff HEAD~1 $versionsFile
+        $changedContent = $difference -join "%"
+        # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
+        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
+        $isInitialCommit = $changedContent -match $initialCommitPattern
+        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
+        if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
+          try {
+            $previousPatch = [Convert]::ToInt32($Matches.previous)
+            $currentPatch = [Convert]::ToInt32($Matches.current)
+            if ($currentPatch -gt $previousPatch) {
+              $isVersionBumped = $true
+            }
+          } catch {
+            Write-Host "An error occurred during conversion: $_"
+          }
+        }
+      }
 
-#       if (!($isInitialCommit -or $isVersionBumped)) {
-#         throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
-#       }
-#     condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
-#     displayName: "Check if patch version is bumped up"
+      if (!($isInitialCommit -or $isVersionBumped)) {
+        throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
+      }
+    condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
+    displayName: "Check if patch version is bumped up"
 
 - job: IfOnlyDocumentionChanged
   displayName: "Check whether Test Results need to be executed"
@@ -110,11 +110,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -294,7 +298,7 @@ jobs:
         Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh' --onlyDocChanged $(onlyDocChanged)
     displayName: CI Build
-    env: 
+    env:
         MSBUILDUSESERVER: "1"
   - task: PublishTestResults@2
     displayName: Publish .NET Test Results
@@ -308,11 +312,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -361,7 +369,7 @@ jobs:
         Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh' --onlyDocChanged $(onlyDocChanged)
     displayName: CI Build
-    env: 
+    env:
         MSBUILDUSESERVER: "1"
   - task: PublishTestResults@2
     displayName: Publish .NET Test Results
@@ -375,11 +383,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index d1b60b226d6..28020dc480d 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -117,7 +117,7 @@ extends:
         - name: TeamName
           value: MSBuild
         - name: VisualStudio.MajorVersion
-          value: 17
+          value: 18
         - name: VisualStudio.ChannelName
           value: 'int.main'
         - name: VisualStudio.DropName
diff --git a/Directory.Build.props b/Directory.Build.props
index b0454aa3564..73597368f57 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -41,6 +41,8 @@
     <PackageTags>MSBuild</PackageTags>
 
     <TargetMSBuildToolsVersion>Current</TargetMSBuildToolsVersion>
+    <!-- When building in the VMR, we never need to publish Windows PDBs. Any conversion to Windows PDBs will be done during staging if necessary. -->
+    <PublishWindowsPdb Condition="'$(DotNetBuildOrchestrator)' == 'true'">false</PublishWindowsPdb>
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/Directory.Build.targets b/Directory.Build.targets
index f2c71b74a0e..3538e50a581 100644
--- a/Directory.Build.targets
+++ b/Directory.Build.targets
@@ -7,6 +7,11 @@
     <Description Condition="'$(Description)' == ''">$(TargetFileName)</Description>
   </PropertyGroup>
 
+  <!-- Disable package validation as source build filters out target frameworks. -->
+  <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' == 'true'">
+    <EnablePackageValidation>false</EnablePackageValidation>
+  </PropertyGroup>
+
   <ItemGroup Condition=" '$(IsPackable)' == 'true' ">
     <None Include="$(ThirdPartyNotice)" Pack="true" PackagePath="notices" Visible="false" />
     <None Include="README.md" Pack="true" PackagePath="\" />
diff --git a/azure-pipelines/vs-insertion-experimental.yml b/azure-pipelines/vs-insertion-experimental.yml
index 965ceb7d478..ab2ce364131 100644
--- a/azure-pipelines/vs-insertion-experimental.yml
+++ b/azure-pipelines/vs-insertion-experimental.yml
@@ -2,16 +2,6 @@
 trigger: none
 name: $(Date:yyyyMMdd).$(Rev:r)
 
-# Since our release branch is the one flowing into main
-# we will keep our main experimental insertions to make sure everything is alright
-schedules:
-  - cron: '0 3 * * 1,3,5' # Runs every Monday, Wednesday and Friday at 3AM UTC
-    displayName: Experimental VS insertion main
-    branches:
-      include:
-        - main
-    always: false # Don't run if there are no code changes
-    
 resources:
   pipelines:
   - pipeline: 'MSBuild'
diff --git a/azure-pipelines/vs-insertion.yml b/azure-pipelines/vs-insertion.yml
index 2f2046c4687..2f8d8732f04 100644
--- a/azure-pipelines/vs-insertion.yml
+++ b/azure-pipelines/vs-insertion.yml
@@ -12,13 +12,13 @@ trigger: none
 pr: none
 name: $(Date:yyyyMMdd).$(Rev:r)
 
-# schedules:
-#   - cron: '0 3 * * 1-5' # Runs every weekday at 3AM UTC
-#     displayName: Daily VS insertion main
-#     branches:
-#       include:
-#         - main
-#     always: false # Don't run if there are no code changes
+schedules:
+  - cron: '0 3 * * 1-5' # Runs every weekday at 3AM UTC
+    displayName: Daily VS insertion main
+    branches:
+      include:
+        - main
+    always: false # Don't run if there are no code changes
 
 resources:
   pipelines:
@@ -66,7 +66,7 @@ variables:
   # `auto` should work every time and selecting a branch in parameters is likely to fail due to incompatible versions in MSBuild and VS
   - name: AutoInsertTargetBranch
     ${{ if eq(variables['Build.SourceBranchName'], 'vs17.14') }}:
-      value: 'main'
+      value: 'rel/d17.14'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.13') }}:
       value: 'rel/d17.13'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.12') }}:
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index 892e17a178a..2f0d197c2b1 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -12,12 +12,11 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 | [BC0106](#bc0106---copytooutputdirectoryalways-should-be-avoided) | Warning | N/A | 9.0.200 | CopyToOutputDirectory='Always' should be avoided. |
 | [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework and TargetFrameworks specified together. |
 | [BC0108](#bc0108---targetframework-or-targetframeworks-specified-in-non-sdk-style-project) | Warning | N/A | 9.0.300 | TargetFramework or TargetFrameworks specified in non-SDK style project. |
-| [BC0109](#bc0109---building-using-the-exec-task) | Warning | N/A | 9.0.300 | Building using the Exec task. |
 | [BC0201](#bc0201---usage-of-undefined-property) | Warning | Project | 9.0.100 | Usage of undefined property. |
 | [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Project | 9.0.100 | Property first declared after it was used. |
 | [BC0203](#bc0203----property-declared-but-never-used) | None | Project | 9.0.100 | Property declared but never used. |
 | [BC0301](#bc0301---building-from-downloads-folder) | None | Project | 9.0.300 | Building from Downloads folder. |
-
+| [BC0302](#bc0302---building-using-the-exec-task) | Warning | N/A | 9.0.300 | Building using the Exec task. |
 
 Notes: 
  * What does the 'N/A' scope mean? The scope of checks are only applicable and configurable in cases where evaluation-time data are being used and the source of the data is determinable and available. Otherwise the scope of whole build is always checked.
@@ -138,14 +137,6 @@ dotnet build my-multi-target.csproj /p:TargetFramework=net9.0
 
 Make sure the Target Framework is specified appropriately for your project.
 
-<a name="BC0109"></a>
-## BC0109 - Building using the Exec task.
-
-"The 'Exec' task should not be used to build projects."
-
-Building projects using the dotnet/msbuild/nuget CLI in the `Exec` task is not recommended, as it spawns a separate build process that the MSBuild engine cannot track. Please use the [MSBuild task](https://learn.microsoft.com/visualstudio/msbuild/msbuild-task) instead.
-
-
 <a name="BC0201"></a>
 ## BC0201 - Usage of undefined property.
 
@@ -205,6 +196,13 @@ Placing project files into Downloads folder (or any other folder that cannot be
 
 Place your projects into trusted locations - including cases when you intend to only open the project in IDE.
 
+<a name="BC0302"></a>
+## BC0302 - Building using the Exec task.
+
+"The 'Exec' task should not be used to build projects."
+
+Building projects using the dotnet/msbuild/nuget CLI in the `Exec` task is not recommended, as it spawns a separate build process that the MSBuild engine cannot track. Please use the [MSBuild task](https://learn.microsoft.com/visualstudio/msbuild/msbuild-task) instead.
+
 <BR/>
 <BR/>
 <BR/>
diff --git a/documentation/specs/custom-cultures.md b/documentation/specs/custom-cultures.md
new file mode 100644
index 00000000000..a3e683c25e4
--- /dev/null
+++ b/documentation/specs/custom-cultures.md
@@ -0,0 +1,42 @@
+# MSBuild Custom Cultures Support
+
+## Overview
+
+The `EnableCustomCulture` property provides an opt-in mechanism for handling custom culture-specific resources in MSBuild projects. This feature allows for greater control over which directories are treated as culture-specific resources during the build process.
+
+## Purpose
+
+In some projects, directory names that match culture name patterns might not actually be culture resources. This can cause issues with resource compilation and deployment. This feature flag enables:
+
+1. Control over whether custom culture detection is enabled
+2. Fine-grained configuration of which directories should be excluded from culture-specific resource processing
+
+## Usage
+
+### Enabling the Feature
+
+To enable the custom cultures feature, set the `EnableCustomCulture` property `true`.
+
+```xml
+<PropertyGroup>
+  <EnableCustomCulture>true</EnableCustomCulture>
+</PropertyGroup>
+```
+
+### Excluding Specific Directories
+
+When the feature is enabled, you can specify directories that should not be treated as culture-specific resources using the `NonCultureResourceDirectories` property:
+
+```xml
+<PropertyGroup>
+  <NonCultureResourceDirectories>long;hash;temp</NonCultureResourceDirectories>
+</PropertyGroup>
+```
+
+In this example, directories named "long", "hash", or "temp" will not be processed as culture-specific resources and the assemblied inside of them will be skipped, even if their names match culture naming patterns. Globbing is not supported.
+
+## Additional Notes
+
+- This feature does not affect the standard resource handling for well-known cultures.
+- The feature is designed to be backward compatible - existing projects without the feature flag will behave the same as before.
+- Performance impact is minimal, as the exclusion check happens only during the resource discovery phase of the build.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 6b88ed66097..833299ed296 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -26,7 +26,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ### 17.14
 - ~[.SLNX support - use the new parser for .sln and .slnx](https://github.com/dotnet/msbuild/pull/10836)~ reverted after compat problems discovered
-- [Support custom culture in RAR](https://github.com/dotnet/msbuild/pull/11000)
+- ~~[Support custom culture in RAR](https://github.com/dotnet/msbuild/pull/11000)~~ - see [11607](https://github.com/dotnet/msbuild/pull/11607) for details
 - [VS Telemetry](https://github.com/dotnet/msbuild/pull/11255)
 
 ### 17.12
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index d4330ba658d..2466f17e7dd 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -63,14 +63,27 @@
     </ItemGroup>
   </Target>
 
+  <!-- The task allows to find VS bits on machine. These files will be used as a source for patching on the top of them. -->
+  <UsingTask TaskName="LocateVisualStudioTask"
+             AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"
+             TaskFactory="RoslynCodeTaskFactory">
+    <Task>
+      <Code Source="$(MSBuildThisFileDirectory)..\src\MSBuild.Bootstrap.Utils\Tasks\LocateVisualStudioTask.cs" Language="cs" />
+    </Task>
+  </UsingTask>
   <Target Name="BootstrapFull" DependsOnTargets="CleanBootstrapFolder;SetBinPaths;GatherNuGetDependencies">
+
+      <LocateVisualStudioTask>
+        <Output TaskParameter="VsInstallPath" PropertyName="AvailableVsInstallPath" />
+      </LocateVisualStudioTask>
+
     <ItemGroup>
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\*.targets" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\*.props" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\Tracker*.dll" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\Tracker*.exe" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\FileTracker*.dll" />
-      <SdkResolverFiles Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\**\*.*" />
+      <SdkResolverFiles Include="$(AvailableVsInstallPath)\MSBuild\Current\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\**\*.*" />
       <NuGetSdkResolverManifest Include="$(RepoRoot)src\MSBuild\SdkResolvers\VS\Microsoft.Build.NuGetSdkResolver.xml" />
       <InstalledSdks Include="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Sdks\**\*.*" />
 
@@ -105,6 +118,7 @@
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.exe.config" />
       <FreshlyBuiltBinariesx64 Include="$(MSBuildTaskHostX64BinPath)**\*.exe.config" />
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.dll.config" />
+      <FreshlyBuiltBinariesx64 Remove="$(X64BinPath)**\Microsoft.VisualStudio.SolutionPersistence.dll" />
 
       <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.Tasks.Core.dll" />
       <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.dll" />
diff --git a/eng/Build.props b/eng/Build.props
index 591a4d41340..fec5d08db7d 100644
--- a/eng/Build.props
+++ b/eng/Build.props
@@ -6,11 +6,12 @@
   </PropertyGroup>
 
   <ItemGroup>
-	<!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
-	Without this, arcade tries to build all three MSBuild solution at once, which leads to
-	locked file errors. -->
+    <!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
+         Without this, arcade tries to build all three MSBuild solution at once, which leads to
+         locked file errors. -->
     <ProjectToBuild Remove="@(ProjectToBuild)" />
-    <ProjectToBuild Include="$(RepoRoot)MSBuild.sln" />
+    <ProjectToBuild Include="$(RepoRoot)MSBuild.sln" Condition="'$(DotNetBuildSourceOnly)' != 'true'" />
+    <ProjectToBuild Include="$(RepoRoot)MSBuild.SourceBuild.slnf" Condition="'$(DotNetBuildSourceOnly)' == 'true'" />
   </ItemGroup>
 
 </Project>
diff --git a/eng/DotNetBuild.props b/eng/DotNetBuild.props
index 778419d070a..87db021212d 100644
--- a/eng/DotNetBuild.props
+++ b/eng/DotNetBuild.props
@@ -1,21 +1,13 @@
 <!-- When altering this file, include @dotnet/product-construction as a reviewer. -->
-
 <Project>
 
+  <!-- TODO: Remove this file when msbuild upgrades to Arcade 10 -->
   <PropertyGroup>
     <GitHubRepositoryName>msbuild</GitHubRepositoryName>
     <SourceBuildManagedOnly>true</SourceBuildManagedOnly>
+    <ReportPrebuiltUsage Condition="'$(DotNetBuildSourceOnly)' == 'true'">$(DotNetBuildOrchestrator)</ReportPrebuiltUsage>
+    <SetUpSourceBuildIntermediateNupkgCache>false</SetUpSourceBuildIntermediateNupkgCache>
+    <CreateIntermediatePackage>false</CreateIntermediatePackage>
   </PropertyGroup>
 
-  <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration"
-          Condition="'$(DotNetBuildSourceOnly)' == 'true'">
-    <PropertyGroup>
-      <!-- Filter down projects aggressively in source-only modes. -->
-      <InnerBuildArgs>$(InnerBuildArgs) /p:Projects="$(InnerSourceBuildRepoRoot)MSBuild.SourceBuild.slnf"</InnerBuildArgs>
-
-      <!-- Disable package validation as source build filters out target frameworks. -->
-      <InnerBuildArgs>$(InnerBuildArgs) /p:EnablePackageValidation=false</InnerBuildArgs>
-    </PropertyGroup>
-  </Target>
-
 </Project>
diff --git a/eng/Packages.props b/eng/Packages.props
index 6afcad00799..456f037819e 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -34,6 +34,7 @@
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
     <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
+    <PackageVersion Include="System.Threading.Tasks.Extensions" Version="$(SystemThreadingTasksExtensionsVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
     <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
     <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
diff --git a/eng/Publishing.props b/eng/Publishing.props
index 6db69f7afa9..5f9650d32dc 100644
--- a/eng/Publishing.props
+++ b/eng/Publishing.props
@@ -1,6 +1,9 @@
-<?xml version="1.0" encoding="utf-8"?>
 <Project>
-    <PropertyGroup>
-        <PublishingVersion>3</PublishingVersion>
-    </PropertyGroup>
-</Project>
\ No newline at end of file
+
+  <!-- Update Artifacts with Kind=Package to have additional metadata item Category="ToolingPackage".
+       Depending on channel configuration, this means that these assets could be pushed to a different feed. -->
+  <ItemGroup>
+    <Artifact Update="@(Artifact->WithMetadataValue('Kind', 'Package'))" Category="ToolingPackage" />
+  </ItemGroup>
+
+</Project>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
deleted file mode 100644
index 6bf7dfcbf3a..00000000000
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<!-- When altering this file or making other Source Build related changes, include @dotnet/source-build as a reviewer. -->
-<!-- See aka.ms/dotnet/prebuilts for guidance on what pre-builts are and how to eliminate them. -->
-
-<UsageData>
-  <IgnorePatterns>
-    <!-- 9.0 packages are not allowed in the 9.0 build, because they're not "current", so baseline them. -->
-    <UsagePattern IdentityGlob="System.CodeDom/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Collections.Immutable/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Diagnostics.DiagnosticSource/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.Metadata/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Resources.Extensions/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Threading.Channels/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*9.0.0*" />
-
-    <!-- dependency of System.Configuration.ConfigurationManager -->
-    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*9.0.0*" />
-    <!-- dependency of System.Resources.Extensions -->
-    <UsagePattern IdentityGlob="System.Formats.Nrbf/*9.0.0*" />
-    <!-- dependency of System.Security.Cryptography.Pkcs -->
-    <UsagePattern IdentityGlob="Microsoft.Bcl.Cryptography/*9.0.0*" />
-  </IgnorePatterns>
-  <Usages>
-  </Usages>
-</UsageData>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 6e1e643d391..086b8555ebc 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,18 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
+  <Source Uri="https://github.com/dotnet/dotnet" Mapping="msbuild" Sha="ad8565092bbfdd5c8b4a94a718d10b2d394f7aee" BarId="268384" />
   <ProductDependencies>
-    <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.25170.3">
-      <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>6968f7059f4418e985febe704a3b1320f9e5887d</Sha>
-      <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
-    </Dependency>
-    <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-externals" Version="9.0.0-alpha.1.25160.2">
-      <Uri>https://github.com/dotnet/source-build-externals</Uri>
-      <Sha>e2c3c1329ea432b36e4570d977271454e8abb0a0</Sha>
-      <SourceBuild RepoName="source-build-externals" ManagedOnly="true" />
-    </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
     <Dependency Name="Microsoft.Bcl.Cryptography" Version="9.0.0">
       <Uri>https://github.com/dotnet/runtime</Uri>
@@ -123,36 +112,21 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25164.2">
-      <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
-    </Dependency>
-    <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.25164.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25266.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
-      <SourceBuild RepoName="arcade" ManagedOnly="true" />
+      <Sha>c62eeb5b5432f9eaa034fbd641ccd9fd0d928fb3</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.25164.2">
-      <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
-    </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.97">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.15.0-preview.1.65">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>8f6362aea4972acab1454de411cfe835619e4e41</Sha>
-    </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25179.1">
-      <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>304768b76e90f5d224b745e3a03cfc5e9509baf6</Sha>
+      <Sha>58c248e36695c9586c486e8876a43046e0817d41</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-3.25179.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25262.10">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>304768b76e90f5d224b745e3a03cfc5e9509baf6</Sha>
-      <SourceBuild RepoName="roslyn" ManagedOnly="true" />
+      <Sha>8edf7bcd4f1594c3d68a6a567469f41dbd33dd1b</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25164.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25266.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
+      <Sha>c62eeb5b5432f9eaa034fbd641ccd9fd0d928fb3</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 7a862bae10f..b531eaf7abb 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -20,7 +20,6 @@
   <PropertyGroup>
     <UsingToolIbcOptimization>true</UsingToolIbcOptimization>
     <UsingToolVisualStudioIbcTraining>true</UsingToolVisualStudioIbcTraining>
-    <UsingToolMicrosoftNetCompilers>true</UsingToolMicrosoftNetCompilers>
     <UsingToolSymbolUploader>true</UsingToolSymbolUploader>
     <UsingToolVSSDK>true</UsingToolVSSDK>
   </PropertyGroup>
@@ -29,25 +28,22 @@
        This is to prevent "package downgrade" errors coming from other packages that are
        already consuming the newest version of these same dependencies. -->
   <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' == 'true'">
-    <!-- Use newest package versions. -->
-    <SystemMemoryVersion>4.6.0</SystemMemoryVersion>
-    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <MicrosoftIORedistVersion>6.1.3</MicrosoftIORedistVersion>
+    <SystemMemoryVersion>4.6.3</SystemMemoryVersion>
+    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.2</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemThreadingTasksExtensionsVersion>4.6.3</SystemThreadingTasksExtensionsVersion>
   </PropertyGroup>
   <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Keep using older versions. Upgrade carefully. -->
+    <MicrosoftIORedistVersion>6.1.0</MicrosoftIORedistVersion>
     <!--
         Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
-        When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
-        and follow the guidelines written here (internal-link): https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/1796/How-to-add-a-Known-Issue
+        As a result, we CONTINUE TO REFERENCE the old versions at build time, so those are the versions that get embedded into MSBuild assemblies.
+        However, we can update, binding-redirect to, and distribute the newest version (that matches the VS-referenced versions) in order to get the benefits of updating.
+        See uses of $(UseFrozenMaintenancePackageVersions) for details.
     -->
-    <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
-    <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
-  </PropertyGroup>
-  <PropertyGroup>
-    <!-- manually maintained versions -->
-    <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
-    <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
-    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
+    <SystemMemoryVersion>4.6.0</SystemMemoryVersion>
+    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemThreadingTasksExtensionsVersion>4.6.0</SystemThreadingTasksExtensionsVersion>
   </PropertyGroup>
   <PropertyGroup>
     <!-- dotnet/runtime packages -->
@@ -61,12 +57,14 @@
     <SystemReflectionMetadataLoadContextVersion>9.0.0</SystemReflectionMetadataLoadContextVersion>
     <SystemResourcesExtensionsVersion>9.0.0</SystemResourcesExtensionsVersion>
     <SystemSecurityCryptographyProtectedDataVersion>9.0.0</SystemSecurityCryptographyProtectedDataVersion>
+    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>9.0.0</SystemTextEncodingCodePagesVersion>
     <SystemTextJsonVersion>9.0.0</SystemTextJsonVersion>
     <SystemThreadingChannelsVersion>9.0.0</SystemThreadingChannelsVersion>
     <SystemThreadingTasksDataflowVersion>9.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
   <PropertyGroup>
+    <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
     <!-- maintained in eng/dependabot/Packages.props -->
     <!--
     <SystemCodeDomVersion></SystemCodeDomVersion>
@@ -82,12 +80,12 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25164.2</MicrosoftDotNetXUnitExtensionsVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25179.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.14.0-preview.1.97</NuGetBuildTasksVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25266.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <NuGetBuildTasksVersion>6.15.0-preview.1.65</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25262.10</MicrosoftNetCompilersToolsetVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
-    <BootstrapSdkVersion>9.0.200-preview.0.24603.3</BootstrapSdkVersion>
+    <BootstrapSdkVersion>9.0.203</BootstrapSdkVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/core-templates/job/source-build.yml b/eng/common/core-templates/job/source-build.yml
index c4713c8b6ed..d47f09d58fd 100644
--- a/eng/common/core-templates/job/source-build.yml
+++ b/eng/common/core-templates/job/source-build.yml
@@ -26,6 +26,8 @@ parameters:
   #   Specifies the build script to invoke to perform the build in the repo. The default
   #   './build.sh' should work for typical Arcade repositories, but this is customizable for
   #   difficult situations.
+  # buildArguments: ''
+  #   Specifies additional build arguments to pass to the build script.
   # jobProperties: {}
   #   A list of job properties to inject at the top level, for potential extensibility beyond
   #   container and pool.
diff --git a/eng/common/core-templates/job/source-index-stage1.yml b/eng/common/core-templates/job/source-index-stage1.yml
index 205fb5b3a39..8b833332b3e 100644
--- a/eng/common/core-templates/job/source-index-stage1.yml
+++ b/eng/common/core-templates/job/source-index-stage1.yml
@@ -1,7 +1,7 @@
 parameters:
   runAsPublic: false
-  sourceIndexUploadPackageVersion: 2.0.0-20240522.1
-  sourceIndexProcessBinlogPackageVersion: 1.0.1-20240522.1
+  sourceIndexUploadPackageVersion: 2.0.0-20250425.2
+  sourceIndexProcessBinlogPackageVersion: 1.0.1-20250425.2
   sourceIndexPackageSource: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json
   sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
   preSteps: []
diff --git a/eng/common/core-templates/steps/source-build.yml b/eng/common/core-templates/steps/source-build.yml
index 2915d29bb7f..37133b55b75 100644
--- a/eng/common/core-templates/steps/source-build.yml
+++ b/eng/common/core-templates/steps/source-build.yml
@@ -79,6 +79,7 @@ steps:
     ${{ coalesce(parameters.platform.buildScript, './build.sh') }} --ci \
       --configuration $buildConfig \
       --restore --build --pack $publishArgs -bl \
+      ${{ parameters.platform.buildArguments }} \
       $officialBuildArgs \
       $internalRuntimeDownloadArgs \
       $internalRestoreArgs \
diff --git a/global.json b/global.json
index e2e3c22ae34..854434d36d6 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "9.0.104",
+    "dotnet": "9.0.106",
     "vs": {
       "version": "17.12.0"
     },
     "xcopy-msbuild": "17.12.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25164.2"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25266.2"
   }
 }
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index d5b4b8bbf38..61d2d5b6516 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.IO;
+using System.Reflection;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
@@ -22,7 +23,19 @@ public NugetRestoreTests(ITestOutputHelper output)
         [WindowsFullFrameworkOnlyFact]
         public void TestOldNuget()
         {
-            string msbuildExePath = Path.GetDirectoryName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe)!;
+            TestNugetRestore(string.Empty);
+        }
+
+        [WindowsFullFrameworkOnlyFact]
+        public void TestOldNugetWithMsBuild64bit()
+        {
+            TestNugetRestore("amd64");
+        }
+
+        private void TestNugetRestore(string msbuildSubFolder)
+        {
+            string currentAssemblyDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!;
+            string bootstrapMsBuildBinaryDir = Path.Combine(RunnerUtilities.BootstrapMsBuildBinaryLocation, msbuildSubFolder);
             using TestEnvironment testEnvironment = TestEnvironment.Create();
             TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
             // The content of the solution isn't known to matter, but having a custom solution makes it easier to add requirements should they become evident.
@@ -46,7 +59,7 @@ public void TestOldNuget()
 EndGlobalSection
 EndGlobal
 ");
-            RunnerUtilities.RunProcessAndGetOutput(Path.Combine(msbuildExePath, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + msbuildExePath + "\"", out bool success, outputHelper: _output);
+            RunnerUtilities.RunProcessAndGetOutput(Path.Combine(currentAssemblyDir, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + bootstrapMsBuildBinaryDir + "\"", out bool success, outputHelper: _output);
             success.ShouldBeTrue();
         }
     }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index bd2346f8b43..1db628811a0 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -207,8 +207,7 @@ public ElementLinkPair<CT> QuerySingleChildrenWithValidation<CT>(Func<T, IEnumer
 
     internal sealed class ProjectXmlPair : ElementLinkPair<ProjectRootElement>
     {
-        private ProjectPair Project { get; }
-        public ProjectXmlPair(ProjectPair pair) : base(null, pair.View.Xml, pair.Real.Xml) { this.Project = pair; this.PRE = this; }
+        public ProjectXmlPair(ProjectPair pair) : base(null, pair.View.Xml, pair.Real.Xml) { this.PRE = this; }
         public ProjectXmlPair(ProjectRootElement viewXml, ProjectRootElement realXml) : base(null, viewXml, realXml) { this.PRE = this; }
 
         public ElementLinkPair<CT> CreateWithVerify<CT>(Func<ProjectRootElement, CT> creator)
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
index f8d3cb321d5..a723c355ad9 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
@@ -40,12 +40,5 @@ public RemotedResolvedImport(ResolvedImport resolvedImport, ProjectCollectionLin
         public SdkResult SdkResult { get; }
 
         public bool IsImported { get; }
-
-        private ResolvedImport Import(ProjectCollectionLinker importer)
-        {
-            var importElement = (ProjectImportElement)importer.Import<ProjectElement, MockProjectImportElementLinkRemoter>(this.ImportingElement);
-            var projectElement = (ProjectRootElement)importer.Import<ProjectElement, MockProjectRootElementLinkRemoter>(this.ImportedProject);
-            return importer.LinkFactory.Create(importElement, projectElement, 0, this.SdkResult, this.IsImported);
-        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index 9a0bb05138a..fcf4e5a1e54 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -424,6 +424,417 @@ public void TestSerializeArrayWithFactoryNull()
             Assert.True(TranslationHelpers.CompareCollections(value, deserializedValue, BaseClass.Comparer));
         }
 
+        /// <summary>
+        /// Tests interning strings within an intern scope.
+        /// </summary>
+        /// <remarks>
+        /// Most of the string intern tests use casing differences to assert whether interning was successful, rather
+        /// than asserting the underlying buffer contents. Although the intended use is to deduplicate many strings of the
+        /// same casing, this is harder to validate this high level, so we focus on testing behavior here.
+        /// </remarks>
+        [Theory]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        public void TestInternWithInterning(string value, bool nullable)
+        {
+            // Create a case mismatch to test if the string is deduplicated.
+            string valueUpperCase = value?.ToUpperInvariant();
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref value, nullable);
+                translator.Intern(ref valueUpperCase, nullable);
+            });
+
+            string deserializedValue = null;
+            string deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedValue, nullable);
+                translator.Intern(ref deserializedValueUpperCase, nullable);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            Assert.Equal(value, deserializedValue);
+            Assert.Equal(value, deserializedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning strings outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Theory]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        [InlineData(null, false)]
+        public void TestInternNoInterning(string value, bool nullable)
+        {
+            TranslationHelpers.GetWriteTranslator().Intern(ref value, nullable);
+
+            string deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Intern(ref deserializedValue, nullable);
+
+            // If we haven't blown up so far, assume we've skipped interning.
+            Assert.Equal(value, deserializedValue);
+        }
+
+        /// <summary>
+        /// Tests interning path-like strings within an intern scope.
+        /// </summary>
+        [Theory]
+        [InlineData(@"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll", true)]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData(@"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll", false)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        public void TestInternPathWithInterning(string value, bool nullable)
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string valueUpperCase = value?.ToUpperInvariant();
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.InternPath(ref value, nullable);
+                translator.InternPath(ref valueUpperCase, nullable);
+            });
+
+            string deserializedValue = null;
+            string deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.InternPath(ref deserializedValue, nullable);
+                translator.InternPath(ref deserializedValueUpperCase, nullable);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            Assert.Equal(value, deserializedValue);
+            Assert.Equal(value, deserializedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning components in path-like strings.
+        /// </summary>
+        [Fact]
+        public void TestInternPathWithComponentsFirst()
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string directory = @"C:/SRC/MSBUILD/ARTIFACTS/BIN/SOMEPROJECT.NAMESPACE/DEBUG/NET472/";
+            string fileName = @"SOMEPROJECT.NAMESPACE.DLL";
+            string fullPath = @"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll";
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref directory);
+                translator.InternPath(ref fileName);
+                translator.InternPath(ref fullPath);
+            });
+
+            string deserializedDirectory = null;
+            string deserializedFileName = null;
+            string deserializedFullPath = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref deserializedDirectory);
+                translator.InternPath(ref deserializedFileName);
+                translator.InternPath(ref deserializedFullPath);
+            });
+
+            // The path components should be reconstructed using the first encountered value.
+            Assert.Equal(directory, deserializedDirectory);
+            Assert.Equal(fileName, deserializedFileName);
+            Assert.Equal(Path.Combine(directory, fileName), deserializedFullPath);
+        }
+
+        /// <summary>
+        /// Tests interning components in path-like strings.
+        /// </summary>
+        [Fact]
+        public void TestInternPathWithFullPathFirst()
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string fullPath = @"c:/src/msbuild/artifacts/bin/someproject.namespace/debug/net472/someproject.namespace.dll";
+            string directory = @"C:/SRC/MSBUILD/ARTIFACTS/BIN/SOMEPROJECT.NAMESPACE/DEBUG/NET472/";
+            string fileName = @"SOMEPROJECT.NAMESPACE.DLL";
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref fullPath);
+                translator.InternPath(ref directory);
+                translator.InternPath(ref fileName);
+            });
+
+            string deserializedFullPath = null;
+            string deserializedDirectory = null;
+            string deserializedFileName = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref deserializedFullPath);
+                translator.InternPath(ref deserializedDirectory);
+                translator.InternPath(ref deserializedFileName);
+            });
+
+            // The path components should be reconstructed using the first encountered value.
+            Assert.Equal(fullPath, deserializedFullPath);
+            Assert.Equal(fullPath, Path.Combine(deserializedDirectory, deserializedFileName));
+        }
+
+        /// <summary>
+        /// Tests serializing string arrays within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternStringArrayWithInterning()
+        {
+            // Create a case mismatch to test if the string is deduplicated.
+            string[] value1 = ["foo", "FOO"];
+            string[] value2 = ["Foo", "fOO"];
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref value1);
+                translator.Intern(ref value2);
+            });
+
+            string[] deserializedValue1 = null;
+            string[] deserializedValue2 = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedValue1);
+                translator.Intern(ref deserializedValue2);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            string[] expectedValue = ["foo", "foo"];
+            Assert.True(TranslationHelpers.CompareCollections(expectedValue, deserializedValue1, StringComparer.Ordinal));
+            Assert.True(TranslationHelpers.CompareCollections(expectedValue, deserializedValue2, StringComparer.Ordinal));
+        }
+
+        /// <summary>
+        /// Tests serializing string arrays outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Fact]
+        public void TestInternStringArrayNoInterning()
+        {
+            string[] value1 = ["foo", "FOO"];
+            string[] value2 = ["Foo", "fOO"];
+
+            ITranslator translator = TranslationHelpers.GetWriteTranslator();
+            translator.Intern(ref value1);
+            translator.Intern(ref value2);
+
+            string[] deserializedValue1 = null;
+            string[] deserializedValue2 = null;
+            translator = TranslationHelpers.GetReadTranslator();
+            translator.Intern(ref deserializedValue1);
+            translator.Intern(ref deserializedValue2);
+
+            Assert.True(TranslationHelpers.CompareCollections(value1, deserializedValue1, StringComparer.Ordinal));
+            Assert.True(TranslationHelpers.CompareCollections(value2, deserializedValue2, StringComparer.Ordinal));
+        }
+
+        /// <summary>
+        /// End-to-end test using a mixture of interned and non-interned operations to ensure that we don't hit
+        /// invalid states, as this will be the most common use case.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningMixedUsage()
+        {
+            string value1 = "Foobar";
+            string value2 = "foobar";
+            string valueToIntern = "FooBar";
+            int value3 = 10;
+            string value4 = "fooBar";
+
+            // Create a case mismatch to test if the string is deduplicated.
+            string valueToInternUpperCase = valueToIntern?.ToUpperInvariant();
+            string value5 = "Foo_Bar";
+
+            ITranslator translator = TranslationHelpers.GetWriteTranslator();
+
+            // Interleave interned and non-interned operations.
+            translator.Translate(ref value1);
+            translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Translate(ref value2);
+                translator.Intern(ref valueToIntern);
+                translator.Translate(ref value3);
+                translator.Intern(ref valueToInternUpperCase);
+                translator.Translate(ref value4);
+            });
+            translator.Translate(ref value5);
+
+            string deserializedValue1 = null;
+            string deserializedValue2 = null;
+            string deserializedInternedValue = null;
+            int deserializedValue3 = -1;
+            string deserializedValue4 = null;
+            string deserializedInternedValueUpperCase = null;
+            string deserializedValue5 = null;
+
+            translator = TranslationHelpers.GetReadTranslator();
+
+            // This will only succeed if both translators are correctly sequenced:
+            // packet body -> intern header -> intern body -> packet body.
+            translator.Translate(ref deserializedValue1);
+            translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Translate(ref deserializedValue2);
+                translator.Intern(ref deserializedInternedValue);
+                translator.Translate(ref deserializedValue3);
+                translator.Intern(ref deserializedInternedValueUpperCase);
+                translator.Translate(ref deserializedValue4);
+            });
+            translator.Translate(ref deserializedValue5);
+
+            // All non-interned values should maintain their original casing.
+            Assert.Equal(value1, deserializedValue1);
+            Assert.Equal(value2, deserializedValue2);
+            Assert.Equal(value3, deserializedValue3);
+            Assert.Equal(value4, deserializedValue4);
+            Assert.Equal(value5, deserializedValue5);
+
+            // All interned values should deserialize to the first encountered value.
+            Assert.Equal(valueToIntern, deserializedInternedValue);
+            Assert.Equal(valueToIntern, deserializedInternedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning path-like strings outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Theory]
+        [InlineData(@"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll", true)]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData(@"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll", false)]
+        [InlineData("", false)]
+        [InlineData(null, false)]
+        public void TestInternPathNoInterning(string value, bool nullable)
+        {
+            TranslationHelpers.GetWriteTranslator().InternPath(ref value, nullable);
+
+            string deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().InternPath(ref deserializedValue, nullable);
+
+            // If we haven't blown up so far, assume we've skipped interning.
+            Assert.Equal(value, deserializedValue);
+        }
+
+        /// <summary>
+        /// Tests no-op when nothing is written to the interner. E.g. a packet opens an intern scope, but none of its
+        /// translatable child objects write anything.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningNoWritesDoesNotThrow()
+        {
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 128, translator =>
+            {
+            });
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 128, translator =>
+            {
+            });
+        }
+
+        /// <summary>
+        /// Tests reusing a translator with different interning comparers.
+        /// This is important if the translator is reused for multiple packet types with different case sensitivity.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningResetsComparerBetweenScopes()
+        {
+            string mixedCaseValue = "StringWithSomeCasing";
+            string lowerCaseValue = "stringwithsomecasing";
+
+            MemoryStream serializationStream = new();
+            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(serializationStream);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
+
+            writeTranslator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref mixedCaseValue);
+                translator.Intern(ref lowerCaseValue);
+            });
+
+            serializationStream.Position = 0;
+
+            string deserializedMixedCaseValue = null;
+            string deserializedLowerCaseValue = null;
+
+            readTranslator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedMixedCaseValue);
+                translator.Intern(ref deserializedLowerCaseValue);
+            });
+
+            // Only the first casing should be interned.
+            Assert.Equal(mixedCaseValue, deserializedMixedCaseValue);
+            Assert.Equal(mixedCaseValue, deserializedLowerCaseValue);
+
+            // Simulate translator reuse by resetting the underlying stream.
+            serializationStream.Position = 0;
+            serializationStream.SetLength(0);
+
+            writeTranslator.WithInterning(StringComparer.Ordinal, initialCapacity: 2, translator =>
+            {
+                translator.Intern(ref mixedCaseValue);
+                translator.Intern(ref lowerCaseValue);
+            });
+
+            serializationStream.Position = 0;
+
+            readTranslator.WithInterning(StringComparer.Ordinal, initialCapacity: 2, translator =>
+            {
+                translator.Intern(ref deserializedMixedCaseValue);
+                translator.Intern(ref deserializedLowerCaseValue);
+            });
+
+            // Both casings should be interned if the comparer was correctly reset.
+            Assert.Equal(mixedCaseValue, deserializedMixedCaseValue);
+            Assert.Equal(lowerCaseValue, deserializedLowerCaseValue);
+        }
+
+        /// <summary>
+        /// Tests throwing an exception on nested intern scopes, which is unsupported.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningThrowsOnNestedScopes()
+        {
+            _ = Assert.Throws<InvalidOperationException>(() =>
+            {
+                ITranslator translator = TranslationHelpers.GetWriteTranslator();
+                translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                {
+                    translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                    {
+                    });
+                });
+            });
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                // Reset the stream, since the broken write will result in an IO exception when read.
+            });
+
+            _ = Assert.Throws<InvalidOperationException>(() =>
+            {
+                ITranslator translator = TranslationHelpers.GetReadTranslator();
+                translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                {
+                    translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                    {
+                    });
+                });
+            });
+        }
+
         /// <summary>
         /// Tests serializing a dictionary of { string, string }
         /// </summary>
@@ -539,6 +950,178 @@ public void TestSerializeDictionaryStringTNoComparerNull()
             Assert.Equal(value, deserializedValue);
         }
 
+        /// <summary>
+        /// Tests interning dictionaries of { string, string } within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternDictionaryStringString()
+        {
+            Dictionary<string, string> value = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["foo"] = "bar",
+                ["alpha"] = "omega",
+            };
+            Dictionary<string, string> valueUpperCase = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["FOO"] = "BAR",
+                ["ALPHA"] = "OMEGA",
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Dictionary<string, string> deserializedValue = null;
+            Dictionary<string, string> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(value["foo"], deserializedValue["foo"]);
+            Assert.Equal(value["alpha"], deserializedValue["alpha"]);
+
+            // All occurrences should deserialize to the first encountered value.
+            // We don't test the keys since the dictionary already uses an ignore case comparer, and
+            // we also want to test that the dictionary comparer matches on both sides.
+            Assert.Equal(valueUpperCase.Count, deserializedValueUpperCase.Count);
+            Assert.Equal(value["foo"], deserializedValueUpperCase["foo"]);
+            Assert.Equal(value["alpha"], deserializedValueUpperCase["alpha"]);
+        }
+
+        /// <summary>
+        /// Tests interning a dictionary of { string, T } within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternDictionaryStringT()
+        {
+            // Since we don't have string values, mismatch the key comparer to verify that interning works.
+            Dictionary<string, BaseClass> value = new(StringComparer.Ordinal)
+            {
+                ["foo"] = new BaseClass(1),
+                ["alpha"] = new BaseClass(2),
+            };
+            Dictionary<string, BaseClass> valueUpperCase = new(StringComparer.Ordinal)
+            {
+                ["FOO"] = new BaseClass(1),
+                ["ALPHA"] = new BaseClass(2),
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Dictionary<string, BaseClass> deserializedValue = null;
+            Dictionary<string, BaseClass> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(0, BaseClass.Comparer.Compare(value["foo"], deserializedValue["foo"]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(value["alpha"], deserializedValue["alpha"]));
+
+            // All occurrences should deserialize to the first encountered key.
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase["FOO"], deserializedValueUpperCase["foo"]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase["ALPHA"], deserializedValueUpperCase["alpha"]));
+        }
+
+        /// <summary>
+        /// Tests interning dictionaries of { string, string } with path-like values within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternPathDictionaryStringString()
+        {
+            Dictionary<string, string> value = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["foo"] = @"C:/src/msbuild/artifacts/bin/ProjectA.Namespace/Debug/net472/ProjectA.NameSpace.dll",
+                ["alpha"] = @"C:/src/msbuild/artifacts/bin/ProjectB.Namespace/Debug/net472/ProjectB.NameSpace.dll",
+            };
+            Dictionary<string, string> valueUpperCase = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["FOO"] = @"C:/SRC/MSBUILD/ARTIFACTS/BIN/PROJECTA.NAMESPACE/DEBUG/NET472/PROJECTA.NAMESPACE.DLL",
+                ["ALPHA"] = @"C:/SRC/MSBUILD/ARTIFACTS/BIN/PROJECTB.NAMESPACE/DEBUG/NET472/PROJECTB.NAMESPACE.DLL",
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Dictionary<string, string> deserializedValue = null;
+            Dictionary<string, string> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(value["foo"], deserializedValue["foo"]);
+            Assert.Equal(value["alpha"], deserializedValue["alpha"]);
+
+            // All occurrences should deserialize to the first encountered value.
+            // We don't test the keys since the dictionary already uses an ignore case comparer, and
+            // we also want to test that the dictionary comparer matches on both sides.
+            Assert.Equal(valueUpperCase.Count, deserializedValueUpperCase.Count);
+            Assert.Equal(value["foo"], deserializedValueUpperCase["foo"]);
+            Assert.Equal(value["alpha"], deserializedValueUpperCase["alpha"]);
+        }
+
+        /// <summary>
+        /// Tests interning a dictionary of { string, T } with path-like keys within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternPathDictionaryStringT()
+        {
+            const string PathA = @"C:/src/msbuild/artifacts/bin/ProjectA.Namespace/Debug/net472/ProjectA.NameSpace.dll";
+            const string PathB = @"C:/src/msbuild/artifacts/bin/ProjectB.Namespace/Debug/net472/ProjectB.NameSpace.dll";
+
+            // Since we don't have string values, mismatch the key comparer to verify that interning works.
+            Dictionary<string, BaseClass> value = new(StringComparer.Ordinal)
+            {
+                [PathA] = new BaseClass(1),
+                [PathB] = new BaseClass(2),
+            };
+            Dictionary<string, BaseClass> valueUpperCase = new(StringComparer.Ordinal)
+            {
+                [PathA.ToUpperInvariant()] = new BaseClass(1),
+                [PathB.ToUpperInvariant()] = new BaseClass(2),
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Dictionary<string, BaseClass> deserializedValue = null;
+            Dictionary<string, BaseClass> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(0, BaseClass.Comparer.Compare(value[PathA], deserializedValue[PathA]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(value[PathB], deserializedValue[PathB]));
+
+            // All occurrences should deserialize to the first encountered key.
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase[PathA.ToUpperInvariant()], deserializedValueUpperCase[PathA]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase[PathB.ToUpperInvariant()], deserializedValueUpperCase[PathB]));
+        }
+
+
         [Theory]
         [InlineData("en")]
         [InlineData("en-US")]
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
index d588c980ab4..b1db9f4d040 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -59,14 +59,12 @@ public class BuildManager_Logging_Tests : IDisposable
         private readonly ProjectCollection _projectCollection;
 
         private readonly TestEnvironment _env;
-        private readonly ITestOutputHelper _output;
 
         /// <summary>
         /// SetUp
         /// </summary>
         public BuildManager_Logging_Tests(ITestOutputHelper output)
         {
-            _output = output;
             // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.
             BuildManager.DefaultBuildManager.Dispose();
 
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index b7ea019500a..3d9c91ca2c4 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -52,7 +52,6 @@ public List<FullyQualifiedBuildRequest[]> NewRequests
             }
 
 
-            private IBuildComponentHost _host;
             private Thread _builderThread;
             private BuildRequestEntry _entry;
             private AutoResetEvent _continueEvent;
@@ -224,12 +223,10 @@ public void WaitForCancelCompletion()
 
             public void InitializeComponent(IBuildComponentHost host)
             {
-                _host = host;
             }
 
             public void ShutdownComponent()
             {
-                _host = null;
             }
 
             #endregion
@@ -255,13 +252,11 @@ private ProjectInstance CreateStandinProject()
         private BuildResult _requestComplete_Result;
 
         private AutoResetEvent _requestResumedEvent;
-        private BuildRequest _requestResumed_Request;
 
         private AutoResetEvent _newRequestEvent;
         private BuildRequestBlocker _newRequest_Request;
 
         private AutoResetEvent _engineStatusChangedEvent;
-        private BuildRequestEngineStatus _engineStatusChanged_Status;
 
         private AutoResetEvent _newConfigurationEvent;
         private BuildRequestConfiguration _newConfiguration_Config;
@@ -270,7 +265,6 @@ private ProjectInstance CreateStandinProject()
         private Exception _engineException_Exception;
 
         private AutoResetEvent _engineResourceRequestEvent;
-        private ResourceRequest _engineResourceRequest_Request;
 
         private IBuildRequestEngine _engine;
         private IConfigCache _cache;
@@ -560,7 +554,6 @@ private void Engine_RequestComplete(BuildRequest request, BuildResult result)
         /// <param name="request">The request being resumed</param>
         private void Engine_RequestResumed(BuildRequest request)
         {
-            _requestResumed_Request = request;
             _requestResumedEvent.Set();
         }
 
@@ -580,7 +573,6 @@ private void Engine_NewRequest(BuildRequestBlocker blocker)
         /// <param name="newStatus">The new status for the engine</param>
         private void Engine_EngineStatusChanged(BuildRequestEngineStatus newStatus)
         {
-            _engineStatusChanged_Status = newStatus;
             _engineStatusChangedEvent.Set();
         }
 
@@ -610,7 +602,6 @@ private void Engine_Exception(Exception e)
         /// <param name="request">The resource request</param>
         private void Engine_ResourceRequest(ResourceRequest request)
         {
-            _engineResourceRequest_Request = request;
             _engineResourceRequestEvent.Set();
         }
     }
diff --git a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
index d2241b404ae..cdd280d3b72 100644
--- a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
+++ b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
@@ -19,11 +19,6 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     internal sealed class MockTaskBuilder : ITaskBuilder, IBuildComponent
     {
-        /// <summary>
-        /// The component host.
-        /// </summary>
-        private IBuildComponentHost _host;
-
         /// <summary>
         /// The current task number.
         /// </summary>
@@ -137,7 +132,6 @@ public Task<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContex
         /// <param name="host">The component host</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            _host = host;
         }
 
         /// <summary>
@@ -145,7 +139,6 @@ public void InitializeComponent(IBuildComponentHost host)
         /// </summary>
         public void ShutdownComponent()
         {
-            _host = null;
         }
 
         #endregion
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 5d0ae210a56..0c22214c0ee 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -105,6 +105,11 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
                 throw new NotImplementedException();
             }
 
+            public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+            {
+                throw new NotImplementedException();
+            }
+
             public void RoutePacket(int nodeId, INodePacket packet)
             {
                 _dataReceivedContext = new DataReceivedContext(Thread.CurrentThread, packet);
diff --git a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
index 61ac9f125d4..797e83393f1 100644
--- a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
@@ -339,7 +339,6 @@ private NodeLoggingContext GetNodeLoggingContext()
 
     internal sealed class TestTargetBuilder : ITargetBuilder, IBuildComponent
     {
-        private IBuildComponentHost _host;
         private IResultsCache _cache;
         private FullyQualifiedBuildRequest[] _newRequests;
         private IRequestBuilderCallback _requestBuilderCallback;
@@ -405,13 +404,11 @@ public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, Buil
 
         public void InitializeComponent(IBuildComponentHost host)
         {
-            _host = host;
             _cache = new ResultsCache();
         }
 
         public void ShutdownComponent()
         {
-            _host = null;
             _cache = null;
         }
         #endregion
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 10a1c5dcd6c..8200c364d2a 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -75,6 +75,33 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
             _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING4", "WARNING2" });
         }
 
+        [Fact]
+        public void AssertSingleResolverErrorLoggedWhenSdkNotResolved()
+        {
+            var service = new SdkResolverService();
+
+            // Use mock loader that only provides a single resolver
+            service.InitializeForTests(new MockLoaderStrategy(includeSingleResolverOnly: true));
+
+            var sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
+
+            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
+
+            result.Success.ShouldBeFalse();
+            result.ShouldNotBeNull();
+            result.SdkReference.ShouldNotBeNull();
+            result.SdkReference.Name.ShouldBe("notfound");
+
+            // Check that only the simplified error (no MSBuild wrapper) is logged
+            _logger.Errors.Count.ShouldBe(1);
+            _logger.Errors[0].Message.ShouldBe(
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                    "SingleResolverFailedToResolveSDK",
+                    "notfound",
+                    "MockSdkResolver1",
+                    "ERROR1"));
+        }
+
         [Fact]
         public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersion()
         {
@@ -743,8 +770,14 @@ private sealed class MockLoaderStrategy : SdkResolverLoader
             public bool ResolversHaveBeenLoaded { get; private set; } = false;
             public bool ManifestsHaveBeenLoaded { get; private set; } = false;
 
-            public MockLoaderStrategy(bool includeErrorResolver = false, bool includeResolversWithPatterns = false, bool includeDefaultResolver = false) : this()
+            public MockLoaderStrategy(bool includeErrorResolver = false, bool includeResolversWithPatterns = false, bool includeDefaultResolver = false , bool includeSingleResolverOnly = false) : this()
             {
+                if (includeSingleResolverOnly)
+                {
+                    _resolvers = new List<SdkResolver> { new MockSdkResolver1() };
+                    return; // Exit early so other ones aren't added
+                }
+
                 if (includeErrorResolver)
                 {
                     _resolvers.Add(new MockSdkResolverThrows());
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 83d4ae0cf0a..0baca3b2dad 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -35,32 +35,19 @@ public class SdkResultOutOfProc_Tests : IDisposable
         /// </summary>
         private readonly BuildManager _buildManager;
 
-        /// <summary>
-        /// The build parameters.
-        /// </summary>
-        private readonly BuildParameters _parameters;
-
         /// <summary>
         /// The project collection used.
         /// </summary>
         private readonly ProjectCollection _projectCollection;
 
         private readonly TestEnvironment _env;
-        private readonly ITestOutputHelper _output;
 
         public SdkResultOutOfProc_Tests(ITestOutputHelper output)
         {
-            _output = output;
             // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.
             BuildManager.DefaultBuildManager.Dispose();
 
             _logger = new MockLogger(output);
-            _parameters = new BuildParameters
-            {
-                ShutdownInProcNodeOnBuildFinish = true,
-                Loggers = new ILogger[] { _logger },
-                EnableNodeReuse = false
-            };
             _buildManager = new BuildManager();
             _projectCollection = new ProjectCollection();
 
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index f0155787682..9bec89727fe 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -32,26 +32,14 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class TaskBuilder_Tests : ITargetBuilderCallback
     {
-        /// <summary>
-        /// The mock component host and logger
-        /// </summary>
-        private MockHost _host;
-
         private readonly ITestOutputHelper _testOutput;
 
-        /// <summary>
-        /// The temporary project we use to run the test
-        /// </summary>
-        private ProjectInstance _testProject;
-
         /// <summary>
         /// Prepares the environment for the test.
         /// </summary>
         public TaskBuilder_Tests(ITestOutputHelper output)
         {
-            _host = new MockHost();
             _testOutput = output;
-            _testProject = CreateTestProject();
         }
 
         /*********************************************************************************
@@ -1098,7 +1086,6 @@ private Project CreateSTATestProject(bool requireSTA, bool failTask, bool throwE
 
             return project;
         }
-#endif
 
         /// <summary>
         /// Helper to create the STA test task.
@@ -1172,80 +1159,7 @@ public ITaskHost HostObject
 }";
             return CustomTaskHelper.GetAssemblyForTask(taskContents);
         }
-
-        /// <summary>
-        /// Creates a test project.
-        /// </summary>
-        /// <returns>The project.</returns>
-        private ProjectInstance CreateTestProject()
-        {
-            string projectFileContents = ObjectModelHelpers.CleanupFileContents(@"
-                <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
-
-                    <ItemGroup>
-                        <Compile Include='b.cs' />
-                        <Compile Include='c.cs' />
-                    </ItemGroup>
-
-                    <ItemGroup>
-                        <Reference Include='System' />
-                    </ItemGroup>
-
-                    <Target Name='Empty' />
-
-                    <Target Name='Skip' Inputs='testProject.proj' Outputs='testProject.proj' />
-
-                    <Target Name='Error' >
-                        <ErrorTask1 ContinueOnError='True'/>
-                        <ErrorTask2 ContinueOnError='False'/>
-                        <ErrorTask3 />
-                        <OnError ExecuteTargets='Foo'/>
-                        <OnError ExecuteTargets='Bar'/>
-                    </Target>
-
-                    <Target Name='Foo' Inputs='foo.cpp' Outputs='foo.o'>
-                        <FooTask1/>
-                    </Target>
-
-                    <Target Name='Bar'>
-                        <BarTask1/>
-                    </Target>
-
-                    <Target Name='Baz' DependsOnTargets='Bar'>
-                        <BazTask1/>
-                        <BazTask2/>
-                    </Target>
-
-                    <Target Name='Baz2' DependsOnTargets='Bar;Foo'>
-                        <Baz2Task1/>
-                        <Baz2Task2/>
-                        <Baz2Task3/>
-                    </Target>
-
-                    <Target Name='DepSkip' DependsOnTargets='Skip'>
-                        <DepSkipTask1/>
-                        <DepSkipTask2/>
-                        <DepSkipTask3/>
-                    </Target>
-
-                    <Target Name='DepError' DependsOnTargets='Foo;Skip;Error'>
-                        <DepSkipTask1/>
-                        <DepSkipTask2/>
-                        <DepSkipTask3/>
-                    </Target>
-
-                </Project>
-                ");
-
-            IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("testfile", new Dictionary<string, string>(), "3.5", Array.Empty<string>(), null), "2.0");
-            using ProjectFromString projectFromString = new(projectFileContents);
-            Project project = projectFromString.Project;
-            config.Project = project.CreateProjectInstance();
-            cache.AddConfiguration(config);
-
-            return config.Project;
-        }
+#endif
 
         /// <summary>
         /// The mock component host object.
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index b1a2a334e8d..54cb31e6598 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1302,18 +1302,6 @@ private void ValidateOutputItem(string outputName, string value)
             Assert.Equal(value, _bucket.Lookup.GetItems("output").First().EvaluatedInclude);
         }
 
-        /// <summary>
-        /// Helper method for tests
-        /// </summary>
-        private void ValidateOutputItem(string outputName, ITaskItem value)
-        {
-            Assert.True(_host.GatherTaskOutputs(outputName, ElementLocation.Create(".", 1, 1), true, "output"));
-            Assert.True(_outputsReadFromTask.ContainsKey(outputName));
-
-            Assert.Single(_bucket.Lookup.GetItems("output"));
-            Assert.Equal(0, TaskItemComparer.Instance.Compare(value, new TaskItem(_bucket.Lookup.GetItems("output").First())));
-        }
-
         /// <summary>
         /// Helper method for tests
         /// </summary>
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index 7e54dd49c91..b462245e17d 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -26,8 +26,6 @@ namespace Microsoft.Build.UnitTests.Definition
     /// </summary>
     public class ToolsetRegistryReader_Tests : IDisposable
     {
-        // The registry key that is passed as the baseKey parameter to the ToolsetRegistryReader class
-        private RegistryKey _testRegistryKey = null;
         // Subkey "3.5"
         private RegistryKey _currentVersionRegistryKey = null;
         // Subkey "ToolsVersions"
@@ -49,7 +47,6 @@ public class ToolsetRegistryReader_Tests : IDisposable
         public ToolsetRegistryReader_Tests()
         {
             DeleteTestRegistryKey();
-            _testRegistryKey = Registry.CurrentUser.CreateSubKey(testRegistryPath);
             _currentVersionRegistryKey = Registry.CurrentUser.CreateSubKey(testRegistryPath + "\\" + Constants.AssemblyVersion);
             _toolsVersionsRegistryKey = Registry.CurrentUser.CreateSubKey(testRegistryPath + "\\ToolsVersions");
 
diff --git a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
index fe0acc1db0d..4b69b86fe02 100644
--- a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
@@ -14,10 +14,6 @@ namespace Microsoft.Build.Engine.UnitTests.Evaluation
 {
     public class ExpanderFunction_Tests
     {
-        private readonly ITestOutputHelper _output;
-
-        public ExpanderFunction_Tests(ITestOutputHelper output) => _output = output;
-
         /* Tests for TryConvertToInt */
 
         [Fact]
diff --git a/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs b/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
index 323326401c6..b10cf9465d4 100644
--- a/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
+++ b/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
@@ -2,7 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
+using System.Linq;
 using System.Reflection;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.UnitTests;
 using Shouldly;
@@ -98,6 +101,23 @@ public void Initialize_ShouldNoOp_WhenCalledMultipleTimes()
             state2.ShouldBe(false);
         }
 
+        [Fact]
+        public void TelemetryLoadFailureIsLoggedOnce()
+        {
+            OpenTelemetryManager.Instance.LoadFailureExceptionMessage = new System.IO.FileNotFoundException().ToString();
+            using BuildManager bm = new BuildManager();
+            var deferredMessages = new List<BuildManager.DeferredBuildMessage>();
+            bm.BeginBuild(new BuildParameters(), deferredMessages);
+            deferredMessages.ShouldContain(x => x.Text.Contains("FileNotFound"));
+            bm.EndBuild();
+            bm.BeginBuild(new BuildParameters());
+            bm.EndBuild();
+
+            // should not add message twice
+            int count = deferredMessages.Count(x => x.Text.Contains("FileNotFound"));
+            count.ShouldBe(1);
+        }
+
         /* Helper methods */
 
         /// <summary>
diff --git a/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs b/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
index 6154403ab83..8eae309431d 100644
--- a/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
+++ b/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
@@ -5,9 +5,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
-#if NET
 using System.Text.Json;
-#endif
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
@@ -282,7 +280,7 @@ public void NodeTelemetryE2E()
                 tasksData.TryGetProperty("Microsoft.Build.Tasks.Message", out var messageTask).ShouldBe(true);
                 messageTask.GetProperty("ExecutionsCount").GetInt32().ShouldBe(3);
                 messageTask.GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
-                messageTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+                messageTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThanOrEqualTo(0);
                 messageTask.GetProperty(nameof(TaskOrTargetTelemetryKey.IsCustom)).GetBoolean().ShouldBe(false);
                 messageTask.GetProperty(nameof(TaskOrTargetTelemetryKey.IsCustom)).GetBoolean().ShouldBe(false);
 
@@ -290,7 +288,7 @@ public void NodeTelemetryE2E()
                 tasksData.TryGetProperty("Microsoft.Build.Tasks.CreateItem", out var createItemTask).ShouldBe(true);
                 createItemTask.GetProperty("ExecutionsCount").GetInt32().ShouldBe(1);
                 createItemTask.GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
-                createItemTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+                createItemTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThanOrEqualTo(0);
 
                 // Verify Targets summary information
                 tags.ShouldContainKey("VS.MSBuild.TargetsSummary");
@@ -311,7 +309,8 @@ public void NodeTelemetryE2E()
                 // Verify task execution summary metrics based on TasksSummaryConverter.Write structure
                 tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("ExecutionsCount").GetInt32().ShouldBe(4);
                 tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
-                tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+                // Allowing 0 for TotalMemoryBytes as it is possible for tasks to allocate no memory in certain scenarios.
+                tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThanOrEqualTo(0);
             }
         }
 
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index 60ed5d2bd01..a29466e852c 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -21,12 +21,9 @@ namespace Microsoft.Build.UnitTests
 {
     public class UtilitiesTestStandard : UtilitiesTest
     {
-        private readonly ITestOutputHelper _output;
-
-        public UtilitiesTestStandard(ITestOutputHelper output)
+        public UtilitiesTestStandard()
         {
             this.loadAsReadOnly = false;
-            _output = output;
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index a60bd4ed0d8..40d303360c4 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -459,7 +459,8 @@ private void UpdatePriority(Process p, ProcessPriorityClass priority)
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public void BeginBuild(BuildParameters parameters)
         {
-            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
+            InitializeTelemetry();
+
             if (_previousLowPriority != null)
             {
                 if (parameters.LowPriority != _previousLowPriority)
@@ -559,6 +560,21 @@ public void BeginBuild(BuildParameters parameters)
                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath("msbuild-cache");
                 }
 
+                // Launch the RAR node before the detoured launcher overrides the default node launcher.
+                if (_buildParameters.EnableRarNode)
+                {
+                    NodeLauncher nodeLauncher = ((IBuildComponentHost)this).GetComponent<NodeLauncher>(BuildComponentType.NodeLauncher);
+                    _ = Task.Run(() =>
+                    {
+                        RarNodeLauncher rarNodeLauncher = new(nodeLauncher);
+
+                        if (!rarNodeLauncher.Start())
+                        {
+                            _buildParameters.EnableRarNode = false;
+                        }
+                    });
+                }
+
 #if FEATURE_REPORTFILEACCESSES
                 if (_buildParameters.ReportFileAccesses)
                 {
@@ -677,7 +693,7 @@ IEnumerable<ILogger> AppendDebuggingLoggers(IEnumerable<ILogger> loggers)
 
                 var logger = new BinaryLogger { Parameters = binlogPath };
 
-                return (loggers ?? [logger]);
+                return (loggers ?? []).Concat([logger]);
             }
 
             void InitializeCaches()
@@ -723,6 +739,26 @@ void InitializeCaches()
             }
         }
 
+        private void InitializeTelemetry()
+        {
+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
+            string? failureMessage = OpenTelemetryManager.Instance.LoadFailureExceptionMessage;
+            if (_deferredBuildMessages != null &&
+                failureMessage != null &&
+                _deferredBuildMessages is ICollection<DeferredBuildMessage> deferredBuildMessagesCollection)
+            {
+                deferredBuildMessagesCollection.Add(
+                    new DeferredBuildMessage(
+                        ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                            "OpenTelemetryLoadFailed",
+                            failureMessage),
+                    MessageImportance.Low));
+
+                // clean up the message from OpenTelemetryManager to avoid double logging it
+                OpenTelemetryManager.Instance.LoadFailureExceptionMessage = null;
+            }
+        }
+
 #if FEATURE_REPORTFILEACCESSES
         /// <summary>
         /// Configure the build to use I/O tracking for nodes.
@@ -779,6 +815,7 @@ private static void AttachDebugger()
         /// </summary>
         public void CancelAllSubmissions()
         {
+            MSBuildEventSource.Log.CancelSubmissionsStart();
             CancelAllSubmissions(true);
         }
 
@@ -2405,7 +2442,7 @@ private void HandleResourceRequest(int node, ResourceRequest request)
             {
                 // Resource request requires a response and may be blocking. Our continuation is effectively a callback
                 // to be called once at least one core becomes available.
-                _scheduler!.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((Task<int> task) =>
+                _scheduler!.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((task) =>
                 {
                     var response = new ResourceResponse(request.GlobalRequestId, task.Result);
                     _nodeManager!.SendData(node, response);
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1bfab1b0e52..9ae5c5f5bde 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -124,6 +124,8 @@ public class BuildParameters : ITranslatable
         private bool _enableNodeReuse = false;
 #endif
 
+        private bool _enableRarNode;
+
         /// <summary>
         /// The original process environment.
         /// </summary>
@@ -277,6 +279,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _culture = other._culture;
             _defaultToolsVersion = other._defaultToolsVersion;
             _enableNodeReuse = other._enableNodeReuse;
+            _enableRarNode = other._enableRarNode;
             _buildProcessEnvironment = resetEnvironment
                 ? CommunicationsUtilities.GetEnvironmentVariables()
                 : other._buildProcessEnvironment != null
@@ -424,6 +427,15 @@ public bool EnableNodeReuse
             set => _enableNodeReuse = Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1" ? false : value;
         }
 
+        /// <summary>
+        /// When true, the ResolveAssemblyReferences task executes in an out-of-proc node which persists across builds.
+        /// </summary>
+        public bool EnableRarNode
+        {
+            get => _enableRarNode;
+            set => _enableRarNode = value;
+        }
+
         /// <summary>
         /// Gets an immutable collection of environment properties.
         /// </summary>
@@ -915,6 +927,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _defaultToolsVersion);
             translator.Translate(ref _disableInProcNode);
             translator.Translate(ref _enableNodeReuse);
+            translator.Translate(ref _enableRarNode);
             translator.TranslateProjectPropertyInstanceDictionary(ref _environmentProperties);
             /* No forwarding logger information sent here - that goes with the node configuration */
             translator.TranslateProjectPropertyInstanceDictionary(ref _globalProperties);
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index cce5abb8e93..ecfcba8af40 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -125,6 +125,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Deserializes a packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes a packet to the appropriate handler.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index d892518e9ea..bd8e221c3dd 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.TelemetryInfra;
+using Microsoft.NET.StringTools;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 #nullable disable
@@ -314,6 +315,8 @@ public void CleanupForBuild()
                 _requestsByGlobalRequestId.Clear();
                 _unsubmittedRequests.Clear();
                 _unresolvedConfigurations.ClearConfigurations();
+                Strings.ClearCachedStrings();
+
                 ChangeStatus(BuildRequestEngineStatus.Uninitialized);
             }
         }
@@ -1131,8 +1134,8 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
             // to the entry rather than a series of them.
             lock (issuingEntry.GlobalLock)
             {
-                var existingResultsToReport = new List<BuildResult>();
-                var unresolvedConfigurationsAdded = new HashSet<int>();
+                List<BuildResult> existingResultsToReport = null;
+                HashSet<int> unresolvedConfigurationsAdded = null;
 
                 foreach (FullyQualifiedBuildRequest request in newRequests)
                 {
@@ -1157,6 +1160,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                             // Not waiting for it
                             request.Config.ConfigurationId = GetNextUnresolvedConfigurationId();
                             _unresolvedConfigurations.AddConfiguration(request.Config);
+                            unresolvedConfigurationsAdded ??= new HashSet<int>();
                             unresolvedConfigurationsAdded.Add(request.Config.ConfigurationId);
                         }
                         else
@@ -1235,6 +1239,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
 
                             // Can't report the result directly here, because that could cause the request to go from
                             // Waiting to Ready.
+                            existingResultsToReport ??= new List<BuildResult>();
                             existingResultsToReport.Add(response.Results);
                         }
                         else
@@ -1246,9 +1251,12 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                 }
 
                 // If we have any results we had to report, do so now.
-                foreach (BuildResult existingResult in existingResultsToReport)
+                if (existingResultsToReport is not null)
                 {
-                    issuingEntry.ReportResult(existingResult);
+                    foreach (BuildResult existingResult in existingResultsToReport)
+                    {
+                        issuingEntry.ReportResult(existingResult);
+                    }
                 }
 
                 // Issue any configuration requests we may still need.
@@ -1257,16 +1265,23 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                 {
                     foreach (BuildRequestConfiguration unresolvedConfigurationToIssue in unresolvedConfigurationsToIssue)
                     {
-                        unresolvedConfigurationsAdded.Remove(unresolvedConfigurationToIssue.ConfigurationId);
+                        if (unresolvedConfigurationsAdded is not null)
+                        {
+                            unresolvedConfigurationsAdded.Remove(unresolvedConfigurationToIssue.ConfigurationId);
+                        }
+
                         IssueConfigurationRequest(unresolvedConfigurationToIssue);
                     }
                 }
 
                 // Remove any configurations we ended up not waiting for, otherwise future requests will think we are still waiting for them
                 // and will never get submitted.
-                foreach (int unresolvedConfigurationId in unresolvedConfigurationsAdded)
+                if (unresolvedConfigurationsAdded is not null)
                 {
-                    _unresolvedConfigurations.RemoveConfiguration(unresolvedConfigurationId);
+                    foreach (int unresolvedConfigurationId in unresolvedConfigurationsAdded)
+                    {
+                        _unresolvedConfigurations.RemoveConfiguration(unresolvedConfigurationId);
+                    }
                 }
 
                 // Finally, if we can issue build requests, do so.
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index b0031746031..31ebde5a1d6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -255,6 +255,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes the specified packet. This is called by the Inproc node directly since it does not have to do any deserialization
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 45334ce6752..54f5205c3f3 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -292,6 +292,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             ErrorUtilities.ThrowInternalErrorUnreachable();
         }
 
+        /// <summary>
+        /// Deserializes and routes a packet.  Not used in the in-proc node.
+        /// </summary>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            // Not used
+            ErrorUtilities.ThrowInternalErrorUnreachable();
+            return null;
+        }
+
         /// <summary>
         /// Routes a packet.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index a41eda70fb5..61d61b8b1cd 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -890,23 +890,6 @@ public async Task WaitForExitAsync(ILoggingService loggingService)
                 _process.KillTree(timeoutMilliseconds: 5000);
             }
 
-#if FEATURE_APM
-            /// <summary>
-            /// Completes the asynchronous packet write to the node.
-            /// </summary>
-            private void PacketWriteComplete(IAsyncResult result)
-            {
-                try
-                {
-                    _serverToClientStream.EndWrite(result);
-                }
-                catch (IOException)
-                {
-                    // Do nothing here because any exception will be caught by the async read handler
-                }
-            }
-#endif
-
             private bool ProcessHeaderBytesRead(int bytesRead)
             {
                 if (bytesRead != _headerByte.Length)
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 0bf758924cd..5fd373aec73 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -287,6 +287,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             }
         }
 
+        /// <summary>
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _localPacketFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes the specified packet
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs
new file mode 100644
index 00000000000..1c3d3b0208a
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs
@@ -0,0 +1,79 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class RarNodeLauncher
+    {
+        private readonly INodeLauncher _nodeLauncher;
+
+        private readonly string _pipeName;
+
+        internal RarNodeLauncher(INodeLauncher nodeLauncher)
+        {
+            _nodeLauncher = nodeLauncher;
+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process with the RAR nodemode.
+        /// </summary>
+        public bool Start()
+        {
+            if (IsRarNodeRunning())
+            {
+                CommunicationsUtilities.Trace("Existing RAR node found.");
+                return true;
+            }
+
+            CommunicationsUtilities.Trace("Launching RAR node...");
+
+            try
+            {
+                LaunchNode();
+            }
+            catch (NodeFailedToLaunchException ex)
+            {
+                CommunicationsUtilities.Trace("Failed to launch RAR node: {0}", ex);
+                return false;
+            }
+
+            return true;
+        }
+
+        private bool IsRarNodeRunning()
+        {
+            // Determine if the node is running by checking if the expected named pipe exists.
+            if (NativeMethodsShared.IsWindows)
+            {
+                const string NamedPipeRoot = @"\\.\pipe\";
+
+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior
+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.
+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);
+
+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));
+            }
+            else
+            {
+                // On Unix, named pipes are implemented via sockets, and the pipe name is simply the file path.
+                return FileSystems.Default.FileExists(_pipeName);
+            }
+        }
+
+        private void LaunchNode()
+        {
+            string msbuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            string commandLineArgs = string.Join(" ", ["/nologo", "/nodemode:3"]);
+            _ = _nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId: 0);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index e7e66d6b886..66c881052b8 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -149,6 +149,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             throw new NotSupportedException("not used");
         }
 
+        /// <summary>
+        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            throw new NotSupportedException("not used");
+        }
+
         /// <summary>
         /// Routes the specified packet. This is called by the Inproc node directly since it does not have to do any deserialization
         /// </summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index c33c0ab6563..c090c05f83b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -482,12 +482,29 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             }
 
             // Filter the metadata as appropriate
+            List<string> metadataToRemove = null;
             if (keepMetadata != null)
             {
-                foreach (var item in items)
+                foreach (ProjectItemInstance item in items)
                 {
-                    var metadataToRemove = item.MetadataNames.Where(name => !keepMetadata.Contains(name));
-                    foreach (var metadataName in metadataToRemove)
+                    if (metadataToRemove == null)
+                    {
+                        metadataToRemove = new List<string>();
+                    }
+                    else
+                    {
+                        metadataToRemove.Clear();
+                    }
+
+                    foreach (string metadataName in item.EnumerableMetadataNames)
+                    {
+                        if (!keepMetadata.Contains(metadataName))
+                        {
+                            metadataToRemove.Add(metadataName);
+                        }
+                    }
+
+                    foreach(string metadataName in metadataToRemove)
                     {
                         item.RemoveMetadata(metadataName);
                     }
@@ -495,10 +512,26 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             }
             else if (removeMetadata != null)
             {
-                foreach (var item in items)
+                foreach (ProjectItemInstance item in items)
                 {
-                    var metadataToRemove = item.MetadataNames.Where(name => removeMetadata.Contains(name));
-                    foreach (var metadataName in metadataToRemove)
+                    if (metadataToRemove == null)
+                    {
+                        metadataToRemove = new List<string>();
+                    }
+                    else
+                    {
+                        metadataToRemove.Clear();
+                    }
+
+                    foreach (string metadataName in item.EnumerableMetadataNames)
+                    {
+                        if (removeMetadata.Contains(metadataName))
+                        {
+                            metadataToRemove.Add(metadataName);
+                        }
+                    }
+
+                    foreach (string metadataName in metadataToRemove)
                     {
                         item.RemoveMetadata(metadataName);
                     }
@@ -517,7 +550,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
         /// <returns>A list of matching items</returns>
         private HashSet<string> EvaluateExcludePaths(IReadOnlyList<string> excludes, ElementLocation excludeLocation)
         {
-            HashSet<string> excludesUnescapedForComparison = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            HashSet<string> excludesUnescapedForComparison = new HashSet<string>(excludes.Count, StringComparer.OrdinalIgnoreCase);
             foreach (string excludeSplit in excludes)
             {
                 string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 596555819ca..93c744c5870 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -480,8 +480,15 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> adds = scope.Adds[itemType];
                     if (adds.Count != 0)
                     {
-                        allAdds ??= new List<ProjectItemInstance>(adds.Count);
-                        allAdds.AddRange(adds);
+                        if (allAdds == null)
+                        {
+                            // Use the List<T>(IEnumerable<T>) constructor to avoid an intermediate array allocation.
+                            allAdds = new List<ProjectItemInstance>(adds);
+                        }
+                        else
+                        {
+                            allAdds.AddRange(adds);
+                        }
                     }
                 }
 
@@ -491,8 +498,14 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> removes = scope.Removes[itemType];
                     if (removes.Count != 0)
                     {
-                        allRemoves ??= new List<ProjectItemInstance>(removes.Count);
-                        allRemoves.AddRange(removes);
+                        if (allRemoves == null)
+                        {
+                            allRemoves = new List<ProjectItemInstance>(removes);
+                        }
+                        else
+                        {
+                            allRemoves.AddRange(removes);
+                        }
                     }
                 }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 4be12ea2854..3f08179f500 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -497,7 +497,7 @@ public int RequestCores(object monitorLockObject, int requestedCores, bool waitF
             // a queue of pending requests.
             ResourceResponse responseObject = null;
             using AutoResetEvent responseEvent = new AutoResetEvent(false);
-            _pendingResourceRequests.Enqueue((ResourceResponse response) =>
+            _pendingResourceRequests.Enqueue((response) =>
             {
                 responseObject = response;
                 responseEvent.Set();
@@ -1106,8 +1106,6 @@ private async Task<BuildResult> BuildProject()
             // logged with the node logging context
             _projectLoggingContext = null;
 
-            MSBuildEventSource.Log.BuildProjectStart(_requestEntry.RequestConfiguration.ProjectFullPath);
-
             try
             {
                 // Load the project
@@ -1145,6 +1143,13 @@ private async Task<BuildResult> BuildProject()
 
             try
             {
+                // Determine the set of targets we need to build
+                (string name, TargetBuiltReason reason)[] allTargets = _requestEntry.RequestConfiguration
+   .GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
+                    MSBuildEventSource.Log.BuildProjectStart(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
+                }
                 HandleProjectStarted(buildCheckManager);
 
                 // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
@@ -1162,9 +1167,6 @@ private async Task<BuildResult> BuildProject()
 
                 _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
 
-                // Determine the set of targets we need to build
-                (string name, TargetBuiltReason reason)[] allTargets = _requestEntry.RequestConfiguration
-                    .GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
 
                 ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0,
                     _requestEntry.RequestConfiguration.Project.ProjectFileLocation, "NoTargetSpecified");
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 30179f2e7a9..ee1dca8557e 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -148,11 +148,6 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// </summary>
         private bool _isExecuting;
 
-        /// <summary>
-        /// The current task builder.
-        /// </summary>
-        private ITaskBuilder _currentTaskBuilder;
-
         /// <summary>
         /// The constructor.
         /// </summary>
@@ -816,46 +811,36 @@ private async ValueTask<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder,
             WorkUnitActionCode finalActionCode = WorkUnitActionCode.Continue;
             WorkUnitResult lastResult = new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null);
 
-            try
+            int currentTask = 0;
+
+            // Walk through all of the tasks and execute them in order.
+            for (; (currentTask < _target.Children.Count) && !_cancellationToken.IsCancellationRequested; ++currentTask)
             {
-                // Grab the task builder so if cancel is called it will have something to operate on.
-                _currentTaskBuilder = taskBuilder;
+                ProjectTargetInstanceChild targetChildInstance = _target.Children[currentTask];
 
-                int currentTask = 0;
+                // Execute the task.
+                lastResult = await taskBuilder.ExecuteTask(targetLoggingContext, _requestEntry, _targetBuilderCallback, targetChildInstance, mode, lookupForInference, lookupForExecution, _cancellationToken);
 
-                // Walk through all of the tasks and execute them in order.
-                for (; (currentTask < _target.Children.Count) && !_cancellationToken.IsCancellationRequested; ++currentTask)
+                if (lastResult.ResultCode == WorkUnitResultCode.Failed)
                 {
-                    ProjectTargetInstanceChild targetChildInstance = _target.Children[currentTask];
-
-                    // Execute the task.
-                    lastResult = await taskBuilder.ExecuteTask(targetLoggingContext, _requestEntry, _targetBuilderCallback, targetChildInstance, mode, lookupForInference, lookupForExecution, _cancellationToken);
-
-                    if (lastResult.ResultCode == WorkUnitResultCode.Failed)
-                    {
-                        aggregatedTaskResult = WorkUnitResultCode.Failed;
-                    }
-                    else if (lastResult.ResultCode == WorkUnitResultCode.Success && aggregatedTaskResult != WorkUnitResultCode.Failed)
-                    {
-                        aggregatedTaskResult = WorkUnitResultCode.Success;
-                    }
-
-                    if (lastResult.ActionCode == WorkUnitActionCode.Stop)
-                    {
-                        finalActionCode = WorkUnitActionCode.Stop;
-                        break;
-                    }
+                    aggregatedTaskResult = WorkUnitResultCode.Failed;
+                }
+                else if (lastResult.ResultCode == WorkUnitResultCode.Success && aggregatedTaskResult != WorkUnitResultCode.Failed)
+                {
+                    aggregatedTaskResult = WorkUnitResultCode.Success;
                 }
 
-                if (_cancellationToken.IsCancellationRequested)
+                if (lastResult.ActionCode == WorkUnitActionCode.Stop)
                 {
-                    aggregatedTaskResult = WorkUnitResultCode.Canceled;
                     finalActionCode = WorkUnitActionCode.Stop;
+                    break;
                 }
             }
-            finally
+
+            if (_cancellationToken.IsCancellationRequested)
             {
-                _currentTaskBuilder = null;
+                aggregatedTaskResult = WorkUnitResultCode.Canceled;
+                finalActionCode = WorkUnitActionCode.Stop;
             }
 
             return new WorkUnitResult(aggregatedTaskResult, finalActionCode, lastResult.Exception);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index a6dac53cb8c..85616c799cf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -430,8 +430,10 @@ private async ValueTask<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBuc
                     {
                         TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance, taskAssemblyLocation);
                         MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-                        // Can be condition with _componentHost.BuildParameters.IsTelemetryEnabled) - but it's a cheap call
-                        taskFactoryWrapper?.Statistics?.ExecutionStarted();
+                        if (_componentHost.BuildParameters.IsTelemetryEnabled)
+                        {
+                            taskFactoryWrapper?.Statistics?.ExecutionStarted();
+                        }
 
                         _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
 
@@ -481,7 +483,10 @@ private async ValueTask<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBuc
 
                             // Flag the completion of the task.
                             taskLoggingContext.LogTaskBatchFinished(_projectFullPath, taskResult.ResultCode == WorkUnitResultCode.Success || taskResult.ResultCode == WorkUnitResultCode.Skipped);
-                            taskFactoryWrapper?.Statistics?.ExecutionStopped();
+                            if (_componentHost.BuildParameters.IsTelemetryEnabled)
+                            {
+                                taskFactoryWrapper?.Statistics?.ExecutionStopped();
+                            }
 
                             if (taskResult.ResultCode == WorkUnitResultCode.Failed && _continueOnError == ContinueOnError.WarnAndContinue)
                             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index a262028f9f9..0cb83e34bed 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -940,6 +940,8 @@ public override bool LogsMessagesOfImportance(MessageImportance importance)
             /// <inheritdoc/>
             public override bool IsTaskInputLoggingEnabled => _taskHost._host.BuildParameters.LogTaskInputs;
 
+            public override bool IsOutOfProcRarNodeEnabled => _taskHost._host.BuildParameters.EnableRarNode;
+
 #if FEATURE_REPORTFILEACCESSES
             /// <summary>
             /// Reports a file access from a task.
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index e0390e978f0..6bcb954c1f3 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -579,7 +579,7 @@ public Task<int> RequestCores(int requestId, int requestedCores, bool waitForCor
                 return Task.FromResult(0);
             }
 
-            Func<int, int> grantCores = (int availableCores) =>
+            Func<int, int> grantCores = (availableCores) =>
             {
                 int grantedCores = Math.Min(requestedCores, availableCores);
                 if (grantedCores > 0)
@@ -599,7 +599,7 @@ public Task<int> RequestCores(int requestId, int requestedCores, bool waitForCor
                 // We have no cores to grant at the moment, queue up the request.
                 TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>();
                 _pendingRequestCoresCallbacks.Enqueue(completionSource);
-                return completionSource.Task.ContinueWith((Task<int> task) => grantCores(task.Result), TaskContinuationOptions.ExecuteSynchronously);
+                return completionSource.Task.ContinueWith((task) => grantCores(task.Result), TaskContinuationOptions.ExecuteSynchronously);
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 19a63a6eb5f..c6a7fb224d1 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -111,7 +111,7 @@ public void WritePlan(int submissionId, ILoggingService loggingService, BuildEve
                     RecursiveAccumulateConfigurationTimes(rootRequest, accumulatedTimeByConfiguration);
 
                     List<KeyValuePair<int, double>> configurationsInOrder = new(accumulatedTimeByConfiguration);
-                    configurationsInOrder.Sort((KeyValuePair<int, double> l, KeyValuePair<int, double> r) => Comparer<int>.Default.Compare(l.Key, r.Key));
+                    configurationsInOrder.Sort((l, r) => Comparer<int>.Default.Compare(l.Key, r.Key));
                     foreach (KeyValuePair<int, double> configuration in configurationsInOrder)
                     {
                         file.WriteLine(String.Format(CultureInfo.InvariantCulture, "{0} {1} {2}", configuration.Key, configuration.Value, _configCache[configuration.Key].ProjectFullPath));
@@ -400,7 +400,7 @@ private void ReadTimes(StreamReader file)
                     return;
                 }
 
-                string[] values = line.Split(MSBuildConstants.SemicolonChar);
+                string[] values = line.Split(MSBuildConstants.SpaceChar);
                 if (values.Length < 3)
                 {
                     throw new InvalidDataException("Too few values in build plan.");
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 1d6ec92f64c..7abc955bee2 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -226,7 +226,7 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
             resolvers = GetResolvers(
                 _generalResolversManifestsRegistry,
                 loggingContext,
-                sdkReferenceLocation).ToList();
+                sdkReferenceLocation);
 
             if (TryResolveSdkUsingSpecifiedResolvers(
                 resolvers,
@@ -250,7 +250,16 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
 
             if (failOnUnresolvedSdk)
             {
-                loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
+                if (resolvers.Count == 1) // Check if only one resolver was used
+                {
+                    // Log the single resolver's error message directly
+                    loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "SingleResolverFailedToResolveSDK", sdk.Name, resolvers[0].Name, string.Join(Environment.NewLine, errors));
+                }
+                else
+                {
+                    // Log the error with the MSBuild wrapper
+                    loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
+                }
             }
 
             LogWarnings(loggingContext, sdkReferenceLocation, warnings);
@@ -265,16 +274,14 @@ private List<SdkResolver> GetResolvers(IReadOnlyList<SdkResolverManifest> resolv
             List<SdkResolver> resolvers = new List<SdkResolver>();
             foreach (var resolverManifest in resolversManifests)
             {
-                if (!_manifestToResolvers.TryGetValue(resolverManifest, out IReadOnlyList<SdkResolver> newResolvers))
+                IReadOnlyList<SdkResolver> newResolvers;
+                lock (_lockObject)
                 {
-                    lock (_lockObject)
+                    if (!_manifestToResolvers.TryGetValue(resolverManifest, out newResolvers))
                     {
-                        if (!_manifestToResolvers.TryGetValue(resolverManifest, out newResolvers))
-                        {
-                            // Loading of the needed resolvers.
-                            newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, sdkReferenceLocation);
-                            _manifestToResolvers[resolverManifest] = newResolvers;
-                        }
+                        // Loading of the needed resolvers.
+                        newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, sdkReferenceLocation);
+                        _manifestToResolvers[resolverManifest] = newResolvers;
                     }
                 }
 
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 7b4049f8905..33d5fb6359d 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -222,6 +222,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             ErrorUtilities.ThrowInternalError("Unexpected call to DeserializeAndRoutePacket on the in-proc node.");
         }
 
+        /// <summary>
+        /// Not necessary for in-proc node - we don't serialize.
+        /// </summary>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            // The in-proc endpoint shouldn't be serializing, just routing.
+            ErrorUtilities.ThrowInternalError("Unexpected call to DeserializePacket on the in-proc node.");
+            return null;
+        }
+
         /// <summary>
         /// Routes the packet to the appropriate handler.
         /// </summary>
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 0adad41674c..f28b906077a 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -5,7 +5,6 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
 using System.Threading;
@@ -343,6 +342,16 @@ void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType pac
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Deserializes a packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        INodePacket INodePacketFactory.DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes a packet to the appropriate handler.
         /// </summary>
@@ -532,7 +541,6 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
         /// <summary>
         /// Clears all the caches used during the build.
         /// </summary>
-        [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.GC.Collect", Justification = "Required because when calling this method, we want the memory back NOW.")]
         private void CleanupCaches()
         {
             if (_componentFactories.GetComponent(BuildComponentType.ConfigCache) is IConfigCache configCache)
@@ -552,9 +560,6 @@ private void CleanupCaches()
                 // We'll experiment here and ship with the best default.
                 s_projectRootElementCacheBase = null;
             }
-
-            // Since we aren't going to be doing any more work, lets clean up all our memory usage.
-            GC.Collect();
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 1588c5e6d63..be7020d49b8 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -210,6 +210,16 @@ void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType pac
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Deserializes a packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        INodePacket INodePacketFactory.DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes a packet to the appropriate handler.
         /// </summary>
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index f071769c772..6248b2aed2e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -24,6 +24,7 @@
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Task = System.Threading.Tasks.Task;
+using Microsoft.Build.Collections;
 
 #nullable disable
 
@@ -1425,9 +1426,26 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
 
                                     static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary customMetadata)
                                     {
-                                        foreach (DictionaryEntry de in customMetadata)
+                                        if (customMetadata is CopyOnWriteDictionary<string> copyOnWriteDictionary)
                                         {
-                                            yield return new KeyValuePair<string, string>((string)de.Key, EscapingUtilities.Escape((string)de.Value));
+                                            foreach (KeyValuePair<string, string> kvp in copyOnWriteDictionary)
+                                            {
+                                                yield return new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.Escape(kvp.Value));
+                                            }
+                                        }
+                                        else if (customMetadata is Dictionary<string, string> dictionary)
+                                        {
+                                            foreach (KeyValuePair<string, string> kvp in dictionary)
+                                            {
+                                                yield return new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.Escape(kvp.Value));
+                                            }
+                                        }
+                                        else
+                                        {
+                                            foreach (DictionaryEntry de in customMetadata)
+                                            {
+                                                yield return new KeyValuePair<string, string>((string)de.Key, EscapingUtilities.Escape((string)de.Value));
+                                            }
                                         }
                                     }
                                 }
diff --git a/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs b/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs
index 868827b24cc..252159162b2 100644
--- a/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs
+++ b/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs
@@ -17,10 +17,10 @@ namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 internal sealed class ExecCliBuildCheck : Check
 {
     public static CheckRule SupportedRule = new CheckRule(
-        "BC0109",
+        "BC0302",
         "ExecCliBuild",
-        ResourceUtilities.GetResourceString("BuildCheck_BC0109_Title")!,
-        ResourceUtilities.GetResourceString("BuildCheck_BC0109_MessageFmt")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0302_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0302_MessageFmt")!,
         new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
     private const string ExecTaskName = "Exec";
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index b2e0055006e..0c9dcb341d1 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -28,25 +28,25 @@ internal BuildCheckBuildEventHandler(
 
         _eventHandlersFull = new()
         {
-            { typeof(BuildSubmissionStartedEventArgs), (BuildEventArgs e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
-            { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
-            { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
-            { typeof(EnvironmentVariableReadEventArgs), (BuildEventArgs e) => HandleEnvironmentVariableReadEvent((EnvironmentVariableReadEventArgs)e) },
-            { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => HandleProjectStartedRequest((ProjectStartedEventArgs)e) },
-            { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => HandleProjectFinishedRequest((ProjectFinishedEventArgs)e) },
-            { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
-            { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => HandleBuildCheckAcquisitionEvent((BuildCheckAcquisitionEventArgs)e) },
-            { typeof(TaskStartedEventArgs), (BuildEventArgs e) => HandleTaskStartedEvent((TaskStartedEventArgs)e) },
-            { typeof(TaskFinishedEventArgs), (BuildEventArgs e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
-            { typeof(TaskParameterEventArgs), (BuildEventArgs e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
-            { typeof(BuildFinishedEventArgs), (BuildEventArgs e) => HandleBuildFinishedEvent((BuildFinishedEventArgs)e) },
-            { typeof(ProjectImportedEventArgs), (BuildEventArgs e) => HandleProjectImportedEvent((ProjectImportedEventArgs)e) },
+            { typeof(BuildSubmissionStartedEventArgs), (e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
+            { typeof(ProjectEvaluationFinishedEventArgs), (e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
+            { typeof(ProjectEvaluationStartedEventArgs), (e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
+            { typeof(EnvironmentVariableReadEventArgs), (e) => HandleEnvironmentVariableReadEvent((EnvironmentVariableReadEventArgs)e) },
+            { typeof(ProjectStartedEventArgs), (e) => HandleProjectStartedRequest((ProjectStartedEventArgs)e) },
+            { typeof(ProjectFinishedEventArgs), (e) => HandleProjectFinishedRequest((ProjectFinishedEventArgs)e) },
+            { typeof(BuildCheckTracingEventArgs), (e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
+            { typeof(BuildCheckAcquisitionEventArgs), (e) => HandleBuildCheckAcquisitionEvent((BuildCheckAcquisitionEventArgs)e) },
+            { typeof(TaskStartedEventArgs), (e) => HandleTaskStartedEvent((TaskStartedEventArgs)e) },
+            { typeof(TaskFinishedEventArgs), (e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
+            { typeof(TaskParameterEventArgs), (e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
+            { typeof(BuildFinishedEventArgs), (e) => HandleBuildFinishedEvent((BuildFinishedEventArgs)e) },
+            { typeof(ProjectImportedEventArgs), (e) => HandleProjectImportedEvent((ProjectImportedEventArgs)e) },
         };
 
         // During restore we'll wait only for restore to be done.
         _eventHandlersRestore = new()
         {
-            { typeof(BuildSubmissionStartedEventArgs), (BuildEventArgs e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
+            { typeof(BuildSubmissionStartedEventArgs), (e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
         };
 
         _eventHandlers = _eventHandlersFull;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 9e8782ae9ee..08c7ea339c4 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -16,15 +16,11 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
-    private readonly IBuildCheckManager _buildCheckManager;
-    private readonly ICheckContextFactory _checkContextFactory;
 
     internal BuildCheckConnectorLogger(
         ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
-        _buildCheckManager = buildCheckManager;
-        _checkContextFactory = checkContextFactory;
         _eventHandler = new BuildCheckBuildEventHandler(checkContextFactory, buildCheckManager);
     }
 
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
index 393a9f7612c..9b72644bdb8 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -12,6 +12,10 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 
 internal sealed class EditorConfigParser
 {
+    // static property for embedding resolved `.editorconfig`s in binlog
+    private static ConcurrentBag<string> editorConfigFilePaths = new ConcurrentBag<string>();
+    public static IEnumerable<string> EditorConfigFilePaths => editorConfigFilePaths;
+
     private const string EditorconfigFile = ".editorconfig";
 
     /// <summary>
@@ -25,6 +29,13 @@ internal Dictionary<string, string> Parse(string filePath)
         return MergeEditorConfigFiles(editorConfigs, filePath);
     }
 
+    /// <summary>
+    /// Clears the editorConfigFilePaths collection after embedding in the binlog.
+    /// </summary>
+    public static void ClearEditorConfigFilePaths()
+    {
+        editorConfigFilePaths = new ConcurrentBag<string>();
+    }
     /// <summary>
     /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.
     /// </summary>
@@ -34,16 +45,15 @@ internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
         var editorConfigDataFromFilesList = new List<EditorConfigFile>();
 
         var directoryOfTheProject = Path.GetDirectoryName(filePath);
-        // The method will look for the file in parent directory if not found in current until found or the directory is root. 
+        // The method will look for the file in parent directory if not found in current until found or the directory is root.
         var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
-
         while (editorConfigFilePath != string.Empty)
         {
             var editorConfig = _editorConfigFileCache.GetOrAdd(editorConfigFilePath, (key) =>
             {
                 return EditorConfigFile.Parse(File.ReadAllText(editorConfigFilePath));
             });
-
+            editorConfigFilePaths.Add(editorConfigFilePath);
             editorConfigDataFromFilesList.Add(editorConfig);
 
             if (editorConfig.IsRoot)
@@ -61,7 +71,7 @@ internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
     }
 
     /// <summary>
-    /// Retrieves the config dictionary from the sections that matched the filePath. 
+    /// Retrieves the config dictionary from the sections that matched the filePath.
     /// </summary>
     /// <param name="editorConfigFiles"></param>
     /// <param name="filePath"></param>
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index 6f77454eaaf..561e2f59fec 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -16,9 +16,9 @@ public abstract class CheckData(string projectFilePath, int? projectConfiguratio
 {
     private string? _projectFileDirectory;
     // The id is going to be used in future revision
-#pragma warning disable CA1823
+#pragma warning disable CA1823, IDE0052
     private int? _projectConfigurationId = projectConfigurationId;
-#pragma warning restore CA1823
+#pragma warning restore CA1823, IDE0052
 
     /// <summary>
     /// Full path to the project file being built.
diff --git a/src/Build/Collections/CopyOnReadEnumerable.cs b/src/Build/Collections/CopyOnReadEnumerable.cs
index 056f5804cfd..72da4089325 100644
--- a/src/Build/Collections/CopyOnReadEnumerable.cs
+++ b/src/Build/Collections/CopyOnReadEnumerable.cs
@@ -72,6 +72,10 @@ public IEnumerator<TResult> GetEnumerator()
 #endif
                 list = new List<TResult>(count);
             }
+            else if (_backingEnumerable is IReadOnlyCollection<TSource> readOnlyCollection)
+            {
+                list = new List<TResult>(readOnlyCollection.Count);
+            }
             else
             {
                 list = new List<TResult>();
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 41dd414b5cf..371e12d9f3d 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -133,16 +133,23 @@ public void Clear()
             _backing = _backing.Clear();
         }
 
+        /// <summary>
+        /// Gets an enumerator over all the properties in the collection
+        /// Enumeration is in undefined order. This overload exposes the struct enumerator
+        /// directly to avoid an allocation due to boxing.
+        /// </summary>
+        public ImmutableDictionary<string, T>.Enumerator GetEnumerator() => _backing.GetEnumerator();
+
         /// <summary>
         /// Gets an enumerator over all the properties in the collection
         /// Enumeration is in undefined order
         /// </summary>
-        public IEnumerator<T> GetEnumerator() => _backing.Values.GetEnumerator();
+        IEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this);
 
         /// <summary>
         /// Get an enumerator over entries
         /// </summary>
-        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+        IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);
 
         #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
 
@@ -347,9 +354,24 @@ public void Set(T projectProperty)
         /// <param name="other">An enumerator over the properties to add.</param>
         public void ImportProperties(IEnumerable<T> other)
         {
-            _backing = _backing.SetItems(Items());
+            if (other is CopyOnWritePropertyDictionary<T> copyOnWriteDictionary)
+            {
+                _backing = _backing.SetItems(DictionaryItems(copyOnWriteDictionary));
+            }
+            else
+            {
+                _backing = _backing.SetItems(Items(other));
+            }
 
-            IEnumerable<KeyValuePair<string, T>> Items()
+            static IEnumerable<KeyValuePair<string, T>> DictionaryItems(CopyOnWritePropertyDictionary<T> copyOnWriteDictionary)
+            {
+                foreach (KeyValuePair<string, T> kvp in copyOnWriteDictionary)
+                {
+                    yield return new(kvp.Value.Key, kvp.Value);
+                }
+            }
+
+            static IEnumerable<KeyValuePair<string, T>> Items(IEnumerable<T> other)
             {
                 foreach (T property in other)
                 {
@@ -366,5 +388,38 @@ public ICopyOnWritePropertyDictionary<T> DeepClone()
         {
             return new CopyOnWritePropertyDictionary<T>(this);
         }
+
+        /// <summary>
+        /// Struct based enumerator to expose the values of the backing collection.
+        /// This avoids the allocation when accessing the Values property directly.
+        /// </summary>
+        public struct Enumerator : IEnumerator<T>
+        {
+            private ImmutableDictionary<string, T>.Enumerator _dictionaryEnumerator;
+            public Enumerator(CopyOnWritePropertyDictionary<T> dictionary)
+            {
+                _dictionaryEnumerator = dictionary._backing.GetEnumerator();
+            }
+
+            public T Current { get; private set; }
+
+            readonly object IEnumerator.Current => Current;
+
+            public void Dispose() => _dictionaryEnumerator.Dispose();
+
+            public bool MoveNext()
+            {
+                if (_dictionaryEnumerator.MoveNext())
+                {
+                    Current = _dictionaryEnumerator.Current.Value;
+
+                    return true;
+                }
+
+                return false;
+            }
+
+            public void Reset() => _dictionaryEnumerator.Reset();
+        }
     }
 }
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 657b92a9f2e..3f55b17a06d 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -551,19 +551,38 @@ internal void Enumerate(Action<string, string> keyValueCallback)
 
         internal IEnumerable<TResult> Filter<TResult>(Func<T, bool> filter, Func<T, TResult> selector)
         {
-            List<TResult> result = new();
             lock (_properties)
             {
-                foreach (T property in (ICollection<T>)_properties)
+                // PERF: Prefer using struct enumerators from the concrete types to avoid allocations.
+                // RetrievableValuedEntryHashSet implements a struct enumerator.
+                if (_properties is RetrievableValuedEntryHashSet<T> hashSet)
                 {
-                    if (filter(property))
+                    List<TResult> result = new(hashSet.Count);
+                    foreach (T property in hashSet)
                     {
-                        result.Add(selector(property));
+                        if (filter(property))
+                        {
+                            result.Add(selector(property));
+                        }
                     }
+
+                    return result;
                 }
-            }
+                else
+                {
+                    ICollection<T> propertiesCollection = _properties;
+                    List<TResult> result = new(propertiesCollection.Count);
+                    foreach (T property in propertiesCollection)
+                    {
+                        if (filter(property))
+                        {
+                            result.Add(selector(property));
+                        }
+                    }
 
-            return result;
+                    return result;
+                }
+            }
         }
     }
 }
diff --git a/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
index dc8d96f9f7c..5db99b8ab70 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
@@ -82,7 +82,7 @@ namespace Microsoft.Build.Collections
 #if FEATURE_SECURITY_PERMISSIONS
     [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
-    internal class RetrievableEntryHashSet<T> : IRetrievableEntryHashSet<T>
+    internal class RetrievableEntryHashSet<T> : IRetrievableEntryHashSet<T> // CodeQL [SM02227] The dangerous method is called only in debug build. It's safe for release build.
         where T : class, IKeyed
     {
         // store lower 31 bits of hash code
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 6c6584e52c7..3ce1b410be9 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -858,7 +858,9 @@ public bool Remove(T item)
                 return false;
             }
 
-            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);
+            public Enumerator GetEnumerator() => new Enumerator(_initial, _forwards);
+
+            IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
 
             IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
@@ -948,13 +950,18 @@ internal ProjectElementSiblingEnumerable(ProjectElement initial, bool forwards =
             /// <summary>
             /// Get enumerator
             /// </summary>
-            public readonly IEnumerator<ProjectElement> GetEnumerator() => _enumerator;
+            public readonly Enumerator GetEnumerator() => _enumerator;
 
             /// <summary>
             /// Get non generic enumerator
             /// </summary>
             IEnumerator IEnumerable.GetEnumerator() => _enumerator;
 
+            /// <summary>
+            /// Get enumerator
+            /// </summary>
+            IEnumerator<ProjectElement> IEnumerable<ProjectElement>.GetEnumerator() => _enumerator;
+
             /// <summary>
             /// Enumerator over a series of sibling ProjectElement objects
             /// </summary>
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 23b235e5ad0..1ac8dde6d77 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3815,7 +3815,7 @@ internal void Initialize(IDictionary<string, string> globalProperties, string to
 
                 // Cause the project to be actually loaded into the collection, and register for
                 // rename notifications so we can subsequently update the collection.
-                _renameHandler = (string oldFullPath) => ProjectCollection.OnAfterRenameLoadedProject(oldFullPath, Owner);
+                _renameHandler = (oldFullPath) => ProjectCollection.OnAfterRenameLoadedProject(oldFullPath, Owner);
 
                 Xml.OnAfterProjectRename += _renameHandler;
                 Xml.OnProjectXmlChanged += ProjectRootElement_ProjectXmlChangedHandler;
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 2f3ca882084..85692818736 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -27,11 +27,6 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class ToolsetReader
     {
-        /// <summary>
-        /// The global properties used to read the toolset.
-        /// </summary>
-        private PropertyDictionary<ProjectPropertyInstance> _globalProperties;
-
         /// <summary>
         /// The environment properties used to read the toolset.
         /// </summary>
@@ -45,7 +40,6 @@ protected ToolsetReader(
             PropertyDictionary<ProjectPropertyInstance> globalProperties)
         {
             _environmentProperties = environmentProperties;
-            _globalProperties = globalProperties;
         }
 
         /// <summary>
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index b5c1d724240..3176644c32d 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Exceptions
     /// Exception subclass that ToolsetReaders should throw.
     /// </summary>
     [Serializable]
-    public class InvalidToolsetDefinitionException : BuildExceptionBase
+    public class InvalidToolsetDefinitionException : BuildExceptionBase // CodeQL [SM02227] The dangerous method is called only in debug build. It's safe for release build.
     {
         /// <summary>
         /// The MSBuild error code corresponding with this exception.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b061b4db88a..8cff4be5fd4 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -264,11 +264,11 @@ private Evaluator(
             _sdkResolverService = sdkResolverService;
             _submissionId = submissionId;
             _evaluationProfiler = new EvaluationProfiler(profileEvaluation);
-            _isRunningInVisualStudio = String.Equals("true", _data.GlobalPropertiesDictionary.GetProperty("BuildingInsideVisualStudio")?.EvaluatedValue, StringComparison.OrdinalIgnoreCase);
+            _isRunningInVisualStudio = string.Equals("true", _data.GlobalPropertiesDictionary.GetProperty("BuildingInsideVisualStudio")?.EvaluatedValue, StringComparison.OrdinalIgnoreCase);
 
             // In 15.9 we added support for the global property "NuGetInteractive" to allow SDK resolvers to be interactive.
             // In 16.0 we added the /interactive command-line argument so the line below keeps back-compat
-            _interactive = interactive || String.Equals("true", _data.GlobalPropertiesDictionary.GetProperty("NuGetInteractive")?.EvaluatedValue, StringComparison.OrdinalIgnoreCase);
+            _interactive = interactive || string.Equals("true", _data.GlobalPropertiesDictionary.GetProperty("NuGetInteractive")?.EvaluatedValue, StringComparison.OrdinalIgnoreCase);
 
             // The last modified project is the project itself unless its an in-memory project
             if (projectRootElement.FullPath != null)
@@ -345,6 +345,11 @@ internal static void Evaluate(
             {
                 evaluator.Evaluate();
             }
+            catch (PathTooLongException ex)
+            {
+                evaluator._evaluationLoggingContext.LogErrorFromText(null, null, null, new BuildEventFileInfo(root.ProjectFileLocation.File),
+                    ex.Message);
+            }
             finally
             {
                 IEnumerable globalProperties = null;
@@ -621,7 +626,7 @@ private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement t
         /// </summary>
         private void Evaluate()
         {
-            string projectFile = String.IsNullOrEmpty(_projectRootElement.ProjectFileLocation.File) ? "(null)" : _projectRootElement.ProjectFileLocation.File;
+            string projectFile = string.IsNullOrEmpty(_projectRootElement.ProjectFileLocation.File) ? "(null)" : _projectRootElement.ProjectFileLocation.File;
             using (_evaluationProfiler.TrackPass(EvaluationPass.TotalEvaluation))
             {
                 ErrorUtilities.VerifyThrow(_data.EvaluationId == BuildEventContext.InvalidEvaluationId, "There is no prior evaluation ID. The evaluator data needs to be reset at this point");
@@ -807,7 +812,7 @@ private void Evaluate()
 
                             foreach (var entry in _data.GlobalPropertiesDictionary)
                             {
-                                if (!String.Equals(entry.Name, "currentsolutionconfigurationcontents", StringComparison.OrdinalIgnoreCase))
+                                if (!string.Equals(entry.Name, "currentsolutionconfigurationcontents", StringComparison.OrdinalIgnoreCase))
                                 {
                                     propertyDump += $"{entry.Name}={entry.EvaluatedValue}\n";
                                 }
@@ -815,7 +820,7 @@ private void Evaluate()
 
                             string line = new string('#', 100) + "\n";
 
-                            string output = String.Format(CultureInfo.CurrentUICulture, "###: MSBUILD: Evaluating or reevaluating project {0} with {1} global properties and {2} tools version, child count {3}, CurrentSolutionConfigurationContents hash {4} other properties:\n{5}", _projectRootElement.FullPath, globalPropertiesCount, _data.Toolset.ToolsVersion, _projectRootElement.Count, hash, propertyDump);
+                            string output = string.Format(CultureInfo.CurrentUICulture, "###: MSBUILD: Evaluating or reevaluating project {0} with {1} global properties and {2} tools version, child count {3}, CurrentSolutionConfigurationContents hash {4} other properties:\n{5}", _projectRootElement.FullPath, globalPropertiesCount, _data.Toolset.ToolsVersion, _projectRootElement.Count, hash, propertyDump);
 
                             Trace.WriteLine(line + output + line);
                         }
@@ -1118,10 +1123,10 @@ private void ValidateChangeWaveState()
             switch (ChangeWaves.ConversionState)
             {
                 case ChangeWaveConversionState.InvalidFormat:
-                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_InvalidFormat", Traits.Instance.MSBuildDisableFeaturesFromVersion, $"[{String.Join(", ", ChangeWaves.AllWaves.Select(x => x.ToString()))}]");
+                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_InvalidFormat", Traits.Instance.MSBuildDisableFeaturesFromVersion, $"[{string.Join(", ", ChangeWaves.AllWaves.Select(x => x.ToString()))}]");
                     break;
                 case ChangeWaveConversionState.OutOfRotation:
-                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_OutOfRotation", ChangeWaves.DisabledWave, Traits.Instance.MSBuildDisableFeaturesFromVersion, $"[{String.Join(", ", ChangeWaves.AllWaves.Select(x => x.ToString()))}]");
+                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_OutOfRotation", ChangeWaves.DisabledWave, Traits.Instance.MSBuildDisableFeaturesFromVersion, $"[{string.Join(", ", ChangeWaves.AllWaves.Select(x => x.ToString()))}]");
                     break;
             }
         }
@@ -1164,9 +1169,9 @@ private void AddBuiltInProperties()
             SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Full");
 #endif
 
-            if (String.IsNullOrEmpty(_projectRootElement.FullPath))
+            if (string.IsNullOrEmpty(_projectRootElement.FullPath))
             {
-                SetBuiltInProperty(ReservedPropertyNames.projectDirectory, String.IsNullOrEmpty(_projectRootElement.DirectoryPath) ?
+                SetBuiltInProperty(ReservedPropertyNames.projectDirectory, string.IsNullOrEmpty(_projectRootElement.DirectoryPath) ?
                     // If this is an un-saved project, this is as far as we can go
                     startupDirectory :
                     // Solution files based on the old OM end up here.  But they do have a location, which is where the solution was loaded from.
@@ -1574,7 +1579,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
 
             _evaluationLoggingContext.LogComment(MessageImportance.Low, "SearchPathsForMSBuildExtensionsPath",
                                         extensionPropertyRefAsString,
-                                        String.Join(";", pathsToSearch));
+                                        string.Join(";", pathsToSearch));
 
             bool atleastOneExactFilePathWasLookedAtAndNotFound = false;
 
@@ -1990,7 +1995,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
             string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
             ElementLocation importLocationInProject = importElement.Location;
 
-            if (String.IsNullOrWhiteSpace(importExpressionEscaped))
+            if (string.IsNullOrWhiteSpace(importExpressionEscaped))
             {
                 if ((_loadSettings & ProjectLoadSettings.IgnoreInvalidImports) != 0)
                 {
@@ -2016,7 +2021,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     return LoadImportsResult.ImportExpressionResolvedToNothing;
                 }
 
-                ProjectErrorUtilities.ThrowInvalidProject(importLocationInProject, "InvalidAttributeValue", String.Empty, XMakeAttributes.project, XMakeElements.import);
+                ProjectErrorUtilities.ThrowInvalidProject(importLocationInProject, "InvalidAttributeValue", string.Empty, XMakeAttributes.project, XMakeElements.import);
             }
 
             bool atleastOneImportIgnored = false;
@@ -2096,7 +2101,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
 
                     // If a file is included twice, or there is a cycle of imports, we ignore all but the first import
                     // and issue a warning to that effect.
-                    if (String.Equals(_projectRootElement.FullPath, importFileUnescaped, StringComparison.OrdinalIgnoreCase) /* We are trying to import ourselves */)
+                    if (string.Equals(_projectRootElement.FullPath, importFileUnescaped, StringComparison.OrdinalIgnoreCase) /* We are trying to import ourselves */)
                     {
                         _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(importLocationInProject), "SelfImport", importFileUnescaped);
                         atleastOneImportIgnored = true;
@@ -2113,7 +2118,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                         if (IntroducesCircularity(importFileUnescaped, importElement))
                         {
                             // Get the full path of the MSBuild file that has this import.
-                            string importedBy = importElement.ContainingProject.FullPath ?? String.Empty;
+                            string importedBy = importElement.ContainingProject.FullPath ?? string.Empty;
 
                             _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(importLocationInProject), "ImportIntroducesCircularity", importFileUnescaped, importedBy);
 
@@ -2134,7 +2139,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
 
                     if (_importsSeen.TryGetValue(importFileUnescaped, out previouslyImportedAt))
                     {
-                        string parenthesizedProjectLocation = String.Empty;
+                        string parenthesizedProjectLocation = string.Empty;
 
                         // If neither file involved is the project itself, append its path in square brackets
                         if (previouslyImportedAt.ContainingProject != _projectRootElement && importElement.ContainingProject != _projectRootElement)
@@ -2366,14 +2371,14 @@ private bool IntroducesCircularity(string importFileUnescaped, ProjectImportElem
                 // Get the full path of the MSBuild file that imports this file.
                 string importedBy = importElement.ContainingProject.FullPath;
 
-                if (String.Equals(importFileUnescaped, importedBy, StringComparison.OrdinalIgnoreCase))
+                if (string.Equals(importFileUnescaped, importedBy, StringComparison.OrdinalIgnoreCase))
                 {
                     // Circular dependency found!
                     foundMatchingAncestor = true;
                     break;
                 }
 
-                if (!String.IsNullOrEmpty(importedBy)) // The full path of a project loaded from memory can be null.
+                if (!string.IsNullOrEmpty(importedBy)) // The full path of a project loaded from memory can be null.
                 {
                     // Set the "counter" to the importing project.
                     _importsSeen.TryGetValue(importedBy, out importElement);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 8e8f26a1233..ae6988de3e4 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -7,7 +7,11 @@
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
+#if NET
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
@@ -1369,7 +1373,7 @@ internal static object ExpandPropertyBody(
                 // if what we have is a function
                 if (!IsValidPropertyName(propertyBody))
                 {
-                    if (propertyBody.Contains(".") || propertyBody[0] == '[')
+                    if (propertyBody.Contains('.') || propertyBody[0] == '[')
                     {
                         if (BuildParameters.DebugExpansion)
                         {
@@ -1400,7 +1404,7 @@ internal static object ExpandPropertyBody(
                             return null;
                         }
                     }
-                    else if (propertyValue == null && propertyBody.Contains("[")) // a single property indexer
+                    else if (propertyValue == null && propertyBody.Contains('[')) // a single property indexer
                     {
                         int indexerStart = propertyBody.IndexOf('[');
                         int indexerEnd = propertyBody.IndexOf(']');
@@ -4092,7 +4096,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                         {
                             coercedArguments[n] = args[n].ToString().ToCharArray();
                         }
-                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains("."))
+                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains('.'))
                         {
                             Type enumType = parameters[n].ParameterType;
                             string typeLeafName = $"{enumType.Name}.";
diff --git a/src/Build/Evaluation/Expander/ArgumentParser.cs b/src/Build/Evaluation/Expander/ArgumentParser.cs
index c2dd113d5ff..2d9fa7954a0 100644
--- a/src/Build/Evaluation/Expander/ArgumentParser.cs
+++ b/src/Build/Evaluation/Expander/ArgumentParser.cs
@@ -3,8 +3,9 @@
 
 using System;
 using System.Globalization;
+
 #if NETFRAMEWORK
-using System.Linq;
+using Microsoft.IO;
 #endif
 
 namespace Microsoft.Build.Evaluation.Expander
diff --git a/src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs b/src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs
index ff6e6d700ee..3e9a03753da 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs
@@ -41,7 +41,6 @@ internal Builder(ImmutableList<ItemData>.Builder listBuilder)
 
                 #region IEnumerable implementation
 
-                private ImmutableList<ItemData>.Enumerator GetEnumerator() => _listBuilder.GetEnumerator();
                 IEnumerator<ItemData> IEnumerable<ItemData>.GetEnumerator() => _listBuilder.GetEnumerator();
 
                 System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 09c7709e062..3a30af61030 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -662,8 +662,10 @@ public void AddOrUpdateEdge((ProjectGraphNode node, ProjectGraphNode reference)
             {
                 ReferenceItems.AddOrUpdate(
                     key,
+#pragma warning disable IDE0350
                     addValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance referenceItem) => referenceItem,
                     updateValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance existingItem, ProjectItemInstance newItem) =>
+#pragma warning restore IDE0350
                     {
                         string existingTargetsMetadata = existingItem.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
                         string newTargetsMetadata = newItem.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
index b92e762eba9..00d34f295f2 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -175,13 +175,11 @@ public ICollection<T> GetItems(string itemType)
 
         private sealed class ListConverter : ICollection<T>
         {
-            private readonly string _itemType;
             private readonly ICollection<TCached> _list;
             private readonly Func<TCached, T?> _getInstance;
 
             public ListConverter(string itemType, ICollection<TCached> list, Func<TCached, T?> getInstance)
             {
-                _itemType = itemType;
                 _list = list;
                 _getInstance = getInstance;
             }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index f77da95817b..27842451119 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -827,7 +827,7 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                                 // any extant metadata.
                                 // UNDONE: This could be achieved at lower GC cost by applying
                                 // the metadata filter at DeepClone time above.
-                                foreach (var metadataName in filteredItem.MetadataNames)
+                                foreach (var metadataName in filteredItem.EnumerableMetadataNames)
                                 {
                                     if (!itemFilter.Value.Contains(metadataName, StringComparer.OrdinalIgnoreCase))
                                     {
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 36f280f88bb..182d6213d8c 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -285,6 +285,8 @@ public ICollection<string> MetadataNames
             get { return new ReadOnlyCollection<string>(_taskItem.MetadataNames.Cast<string>()); }
         }
 
+        internal TaskItem.MetadataNamesEnumerable EnumerableMetadataNames => _taskItem.EnumerableMetadataNames;
+
         /// <summary>
         /// ITaskItem implementation
         /// </summary>
@@ -957,6 +959,8 @@ public ICollection MetadataNames
                 }
             }
 
+            public MetadataNamesEnumerable EnumerableMetadataNames => new MetadataNamesEnumerable(this);
+
             /// <summary>
             /// Gets the number of metadata set on the item.
             /// Computed, not necessarily fast.
@@ -1085,6 +1089,7 @@ public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
                 _directMetadata.ImportProperties(metadata.Select(kvp => new ProjectMetadataInstance(kvp.Key, kvp.Value, allowItemSpecModifiers: true)));
             }
 
+#if FEATURE_APPDOMAIN
             /// <summary>
             /// Used to return metadata from another AppDomain. Can't use yield return because the
             /// generated state machine is not marked as [Serializable], so we need to allocate.
@@ -1106,6 +1111,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(ICopyOn
                 // Probably better to send the raw array across the wire even if it's another allocation.
                 return result.ToArray();
             }
+#endif
 
             private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
@@ -1959,6 +1965,58 @@ private ProjectMetadataInstance GetItemDefinitionMetadata(string metadataName)
                 return null;
             }
 
+            internal readonly struct MetadataNamesEnumerable
+            {
+                private readonly TaskItem _item;
+
+                public MetadataNamesEnumerable(TaskItem taskItem) => _item = taskItem;
+
+                public readonly MetadataNamesEnumerator GetEnumerator() => new MetadataNamesEnumerator(_item.MetadataCollection);
+            }
+
+            internal struct MetadataNamesEnumerator
+            {
+                private readonly IEnumerator<ProjectMetadataInstance> _metadataCollectionEnumerator;
+                private bool _metadataNamesEnumerated;
+                private int _itemSpecModifiersIndex;
+
+                internal MetadataNamesEnumerator(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection)
+                {
+                    _metadataCollectionEnumerator = ((IEnumerable<ProjectMetadataInstance>)metadataCollection).GetEnumerator();
+                    _metadataNamesEnumerated = false;
+                    _itemSpecModifiersIndex = 0;
+                }
+
+                public string Current { get; private set; }
+
+                public bool MoveNext()
+                {
+                    if (!_metadataNamesEnumerated)
+                    {
+                        if (_metadataCollectionEnumerator.MoveNext())
+                        {
+                            Current = _metadataCollectionEnumerator.Current.Name;
+
+                            return true;
+                        }
+                        else
+                        {
+                            _metadataNamesEnumerated = true;
+                        }
+                    }
+
+                    if (_itemSpecModifiersIndex < FileUtilities.ItemSpecModifiers.All.Length)
+                    {
+                        Current = FileUtilities.ItemSpecModifiers.All[_itemSpecModifiersIndex];
+                        ++_itemSpecModifiersIndex;
+
+                        return true;
+                    }
+
+                    return false;
+                }
+            }
+
             /// <summary>
             /// A class factory for instance model items.
             /// </summary>
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 1a5e51eddf8..9299c3a2595 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -375,6 +375,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes the specified packet
         /// </summary>
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 508cb7483b6..c4023835131 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1188,7 +1188,7 @@ internal class Stats()
 
                 public void ExecutionStarted()
                 {
-                    _memoryConsumptionOnStart = GC.GetTotalMemory(false);
+                    _memoryConsumptionOnStart = GetMemoryAllocated();
                     _executedSw.Start();
                     ExecutedCount++;
                 }
@@ -1196,7 +1196,16 @@ public void ExecutionStarted()
                 public void ExecutionStopped()
                 {
                     _executedSw.Stop();
-                    TotalMemoryConsumption += GC.GetTotalMemory(false) - _memoryConsumptionOnStart;
+                    TotalMemoryConsumption += GetMemoryAllocated() - _memoryConsumptionOnStart;
+                }
+
+                private static long GetMemoryAllocated()
+                {
+#if NET
+                    return GC.GetTotalAllocatedBytes(false);
+#else
+                    return GC.GetTotalMemory(false);
+#endif
                 }
 
                 public void Reset()
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 10286b512eb..e5947b6bf33 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -4,6 +4,7 @@
 using System;
 using System.IO;
 using System.IO.Compression;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
@@ -321,6 +322,12 @@ public void Shutdown()
 
             if (projectImportsCollector != null)
             {
+                // Write the build check editorconfig file paths to the log
+                foreach (var filePath in EditorConfigParser.EditorConfigFilePaths)
+                {
+                    projectImportsCollector.AddFile(filePath);
+                }
+                EditorConfigParser.ClearEditorConfigFilePaths();
                 projectImportsCollector.Close();
 
                 if (CollectProjectImports == ProjectImportsCollectionMode.Embed)
@@ -336,6 +343,7 @@ public void Shutdown()
                 projectImportsCollector = null;
             }
 
+
             if (stream != null)
             {
                 // It's hard to determine whether we're at the end of decoding GZipStream
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 9e2368df650..fb60ed2c23c 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1401,22 +1401,6 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
             }
         }
 
-        /// <summary>
-        /// Write message taking into account whether or not the prefix (timestamp and key) have already been written on the line
-        /// </summary>
-        private void WriteBasedOnPrefix(string nonNullMessage, bool prefixAlreadyWritten, int adjustedPrefixWidth)
-        {
-            if (prefixAlreadyWritten)
-            {
-                WriteHandler(nonNullMessage + Environment.NewLine);
-            }
-            else
-            {
-                // No prefix info has been written, indent the line to the proper location
-                WriteHandler(IndentString(nonNullMessage, adjustedPrefixWidth));
-            }
-        }
-
         /// <summary>
         /// Will display the target started event which was deferred until the first visible message for the target is ready to be displayed
         /// </summary>
diff --git a/src/Build/Logging/TerminalLogger/TerminalLogger.cs b/src/Build/Logging/TerminalLogger/TerminalLogger.cs
index eca3e0749a3..bd86c41c6ff 100644
--- a/src/Build/Logging/TerminalLogger/TerminalLogger.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalLogger.cs
@@ -379,7 +379,7 @@ private void ApplyVerbosityParameter(string? parameterValue)
         }
         else
         {
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "InvalidVerbosity", parameterValue);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string? errorCode, out string? helpKeyword, "InvalidVerbosity", parameterValue);
             throw new LoggerException(message, null, errorCode, helpKeyword);
         }
     }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index b28ac113cd2..144e09f128a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -361,6 +361,7 @@
     <Compile Include="BackEnd\Components\Communications\NodeInfo.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderInProc.cs" />
+    <Compile Include="BackEnd\Components\Communications\RarNodeLauncher.cs" />
     <Compile Include="BackEnd\Components\IBuildComponent.cs" />
     <Compile Include="BackEnd\Components\IBuildComponentHost.cs" />
     <Compile Include="BackEnd\Components\Scheduler\IScheduler.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index f36cdbcde75..71a53635fdd 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1340,6 +1340,9 @@
   <data name="SDKResolverFailed" xml:space="preserve">
     <value>The SDK resolver "{0}" failed while attempting to resolve the SDK "{1}". Exception: "{2}"</value>
   </data>
+  <data name="SingleResolverFailedToResolveSDK" xml:space="preserve">
+    <value>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</value>
+  </data>
   <data name="FailedToResolveSDK" xml:space="preserve">
     <value>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</value>
@@ -2206,10 +2209,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</value>
     <comment>Terms in quotes are not to be translated.</comment>
   </data>
-  <data name="BuildCheck_BC0109_Title" xml:space="preserve">
+  <data name="BuildCheck_BC0302_Title" xml:space="preserve">
     <value>The 'Exec' task should not be used to build a project.</value>
   </data>
-  <data name="BuildCheck_BC0109_MessageFmt" xml:space="preserve">
+  <data name="BuildCheck_BC0302_MessageFmt" xml:space="preserve">
     <value>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</value>
   </data>
   <data name="BuildCheck_BC0201_Title" xml:space="preserve">
@@ -2392,6 +2395,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>succeeded: {0}</value>
     <comment>{0} whole number</comment>
   </data>
+  <data name="OpenTelemetryLoadFailed" xml:space="preserve">
+    <value>Loading telemetry libraries failed with exception: {0}.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index a4ed911d08e..03650f88f89 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -221,14 +221,14 @@
         <target state="translated">Vlastnosti TargetFramework a TargetFrameworks se nedodržují a neměly by se zadává v projektech, které nepoužívají sadu .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">Úloha {0} z projektu {1} sestaví projekt pomocí rozhraní příkazového řádku {2}. Místo toho by se měla použít úloha MSBuild.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">Úloha Exec by se neměla používat k sestavení projektu.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Načítání knihoven telemetrie se nezdařilo s výjimkou: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Výstupní vlastnost: </target>
@@ -855,6 +860,11 @@ Chyby: {3}</target>
         <target state="translated">Překladač sady SDK „{0}“ vrátil hodnotu null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Sadu SDK {0} se nepodařilo vyřešit pomocí překladače sady SDK {1}. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Projekt {0} přeskočil omezení izolace grafu v odkazovaném projektu {1}.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 7fe8564cd54..2ad593ea66a 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -221,14 +221,14 @@
         <target state="translated">Die Eigenschaften "TargetFramework" und "TargetFrameworks" werden nicht berücksichtigt und sollten nicht in Projekten angegeben werden, die nicht das .NET SDK verwenden.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">Die {0}-Aufgabe aus dem Projekt {1} erstellt ein Projekt mithilfe der {2} CLI. Stattdessen sollte die MSBuild-Aufgabe verwendet werden.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">Die "Ausführen"-Aufgabe sollte nicht zum Erstellen eines Projekts verwendet werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Fehler beim Laden von Telemetriebibliotheken. Ausnahme:{0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Ausgabeeigenschaft: </target>
@@ -855,6 +860,11 @@ Fehler: {3}</target>
         <target state="translated">Der SDK-Resolver "{0}" hat NULL zurückgegeben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK „{0}“ konnte vom SDK-Resolver „{1}“ nicht aufgelöst werden. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Das Projekt "{0}" hat Graphisolationseinschränkungen für das referenzierte Projekt "{1}" übersprungen.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index d6b69ebe981..b4584d786bf 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -221,14 +221,14 @@
         <target state="translated">Las propiedades "TargetFramework" y "TargetFrameworks" no se respetan y no deben especificarse en proyectos que no usen el SDK de .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">La tarea {0} del proyecto {1} compila un proyecto mediante la CLI {2}. En su lugar, se debe usar la tarea MSBuild.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">La tarea "Exec" no debe usarse para compilar un proyecto.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Error al cargar las bibliotecas de telemetría con la excepción: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Propiedad de salida: </target>
@@ -855,6 +860,11 @@ Errores: {3}</target>
         <target state="translated">La resolución del SDK "{0}" devolvió null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">El SDK '{0}' no se pudo resolver mediante la resolución de SDK '{1}'. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: El proyecto "{0}" ha omitido las restricciones de aislamiento de gráficos en el proyecto "{1}" al que se hace referencia.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 476f81982a5..909a507f566 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -221,14 +221,14 @@
         <target state="translated">Les propriétés 'TargetFramework' et 'TargetFrameworks' ne sont pas respectées et ne doivent pas être spécifiées dans les projets qui n’utilisent pas le SDK .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">La tâche {0} du projet {1} crée un projet en utilisant l’interface CLI {2}. Vous devez utiliser la tâche MSBuild à la place.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">Vous ne devez pas utiliser la tâche « Exec¯ pour construire un projet.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Nous n’avons pas pu charger les bibliothèques de télémétrie avec l’exception : {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Propriété de sortie : </target>
@@ -855,6 +860,11 @@ Erreurs : {3}</target>
         <target state="translated">Le programme de résolution du Kit de développement logiciel (SDK) «{0}» a retourné null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Le Kit de développement logiciel (SDK) « {0} » n’a pas pu être résolu par le résolveur de SDK « {1} ». {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: le projet "{0}" a ignoré les contraintes d'isolement de graphe dans le projet référencé "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 88de2f29361..44e0f02b051 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -221,14 +221,14 @@
         <target state="translated">Le proprietà 'TargetFramework' e 'TargetFrameworks' non vengono rispettate e non devono essere specificate nei progetti che non usano .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">L'attività {0} del progetto{1} compila un progetto utilizzando la CLI {2}. È necessario utilizzare invece l'attività MSBuild.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">L'attività 'Esecuzione' non deve essere utilizzata per compilare un progetto.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Caricamento delle librerie di telemetria non riuscito con eccezione: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Proprietà di output: </target>
@@ -855,6 +860,11 @@ Errori: {3}</target>
         <target state="translated">Il resolver SDK "{0}" ha restituito null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Il resolver SDK '{0}' non è riuscito a risolvere l'SDK '{1}'. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: il progetto "{0}" ha ignorato i vincoli di isolamento del grafico nel progetto di riferimento "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index ac24fa3a8cc..fa181c689ea 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -221,14 +221,14 @@
         <target state="translated">'TargetFramework' プロパティと 'TargetFrameworks' プロパティは優先されないため、.NET SDK を使用しないプロジェクトでは指定しないでください。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">プロジェクト {1} のタスク {0} は、{2} CLI を使用してプロジェクトをビルドします。代わりに MSBuild タスクを使用する必要があります。</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">'Exec' タスクはプロジェクトのビルドには使用しないでください。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">テレメトリ ライブラリの読み込みが次の例外で失敗しました: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">プロパティの出力: </target>
@@ -855,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">SDK リゾルバー "{0}" が null を返しました。</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK '{0}' を SDK リゾルバー '{1}' で解決できませんでした。{2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: プロジェクト "{0}" は、参照先のプロジェクト "{1}" で、グラフの分離制約をスキップしました</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 604e05765c3..f5766935dde 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -221,14 +221,14 @@
         <target state="translated">'TargetFramework' 및 'TargetFrameworks' 속성은 사용되지 않으며 .NET SDK를 사용하지 않는 프로젝트에서 지정해서는 안 됩니다.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">프로젝트 {1}의 작업 {0}(은)는 {2} CLI를 사용하여 프로젝트를 빌드합니다. 대신 MSBuild 작업을 사용해야 합니다.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">'Exec' 작업은 프로젝트를 빌드하는 데 사용하면 안 됩니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">예외 {0}(으)로 인해 원격 분석 라이브러리를 로드하지 못했습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">출력 속성: </target>
@@ -855,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">SDK 확인자 "{0}"이(가) null을 반환했습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK 확인자 '{1}'에서 SDK '{0}'을(를) 확인할 수 없습니다. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 프로젝트 "{0}"에서 참조된 프로젝트 "{1}"의 그래프 격리 제약 조건을 건너뛰었습니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index c4b1e4e7950..a218f56d244 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -221,14 +221,14 @@
         <target state="translated">Właściwości "TargetFramework" i "TargetFrameworks" nie są respektowane i nie należy ich określać w projektach, w których nie jest używany zestaw .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">Zadanie {0} z projektu {1} tworzy projekt przy użyciu interfejsu wiersza polecenia {2}. Zamiast tego należy użyć zadania MSBuild.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">Zadanie „Exec” nie powinno być używane do kompilowania projektu.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Ładowanie bibliotek telemetrii nie powiodło się. Wyjątek: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Właściwość danych wyjściowych: </target>
@@ -855,6 +860,11 @@ Błędy: {3}</target>
         <target state="translated">Narzędzie Resolver zestawu SDK „{0}” zwróciło wartość null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Nie można rozpoznać zestawu SDK „{0}” przez program rozpoznawania nazw zestawu SDK „{1}”. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: W przypadku projektu „{0}” pominięto ograniczenia izolacji grafu dla przywoływanego projektu „{1}”</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index dac69426c0d..bde8513a69a 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -221,14 +221,14 @@
         <target state="translated">As propriedades 'TargetFramework' e 'TargetFrameworks' não são respeitadas e não devem ser especificadas em projetos que não usam o SDK do .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">A tarefa {0} do projeto {1} cria um projeto usando a CLI {2}. Em vez disso, a tarefa do MSBuild deve ser usada.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">A tarefa "Exec" não deve ser usada para criar um projeto.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Falha ao carregar as bibliotecas de telemetria com a exceção: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Propriedade de Saída: </target>
@@ -855,6 +860,11 @@ Erros: {3}</target>
         <target state="translated">O resolvedor do SDK "{0}" retornou nulo.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">O SDK '{0}' não pôde ser resolvido pelo resolvedor de SDK '{1}'. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: o projeto "{0}" ignorou as restrições de isolamento do gráfico no projeto referenciado "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 7761ba40014..34b7d9d8b23 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -221,14 +221,14 @@
         <target state="translated">Свойства TargetFramework и TargetFrameworks не учитываются и не должны указываться в проектах, не использующих пакет SDK для .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">Задача {0} из проекта {1} создает проект с помощью CLI {2}. Вместо этого следует использовать задачу MSBuild.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">Задачу "Exec" не следует использовать для создания проекта.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Не удалось загрузить библиотеки телеметрии с исключением: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Выходное свойство: </target>
@@ -855,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">Сопоставитель пакетов SDK "{0}" вернул значение null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Не удалось разрешить SDK "{0}" с помощью сопоставителя SDK "{1}". {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: проект "{0}" пропустил ограничения изоляции графа в проекте "{1}", на который указывает ссылка.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 2e698dd6995..004fafbaa16 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -221,14 +221,14 @@
         <target state="translated">'TargetFramework' ve 'TargetFrameworks' özellikleri dikkate alınmaz ve .NET SDK kullanmayan projelerde belirtilmeli.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">{1} projesindeki {0} görevi {2} CLI kullanılan bir proje oluşturur. Bunun yerine MSBuild görevi kullanılmalıdır.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">'Exec' görevi, bir projeyi oluşturmak için kullanılmamalıdır.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Telemetri kitaplıklarının yüklenmesi şu hayatla başarısız oldu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Çıkış Özelliği: </target>
@@ -855,6 +860,11 @@ Hatalar: {3}</target>
         <target state="translated">SDK çözümleyici "{0}" null döndürdü.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK '{0}', SDK çözümleyici '{1}' tarafından çözümlenemedi. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: "{0}" projesi, başvurulan "{1}" projesindeki graf yalıtımı kısıtlamalarını atladı</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index f67cf71b15f..13047d4ac40 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -221,14 +221,14 @@
         <target state="translated">不考虑 “TargetFramework” 和 “TargetFrameworks” 属性，不应在不使用 .NET SDK 的项目中指定这些属性。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">项目 {1} 中的任务 {0} 使用 {2} CLI 生成项目。应改用 MSBuild 任务。</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">不应使用 "Exec" 任务来生成项目。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">加载遥测库失败，出现异常: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">输出属性: </target>
@@ -855,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">SDK 解析程序“{0}”返回 null。</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK 解析程序“{1}”无法解析 SDK“{0}”。{2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 项目“{0}”已跳过所引用的项目“{1}”上的图形隔离约束</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 74f2f895537..c4be1e9169a 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -221,14 +221,14 @@
         <target state="translated">未遵守 『TargetFramework』 和 『TargetFrameworks』 屬性，且不應在未使用 .NET SDK 的專案中指定。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
         <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
-        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <target state="translated">來自專案 {1} 的工作 {0} 使用 {2} CLI 建置專案。建議改用 MSBuild 工作。</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildCheck_BC0109_Title">
+      <trans-unit id="BuildCheck_BC0302_Title">
         <source>The 'Exec' task should not be used to build a project.</source>
-        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <target state="translated">不應該使用 'Exec' 工作來建置專案。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
@@ -630,6 +630,11 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">載入遙測程式庫時發生例外狀況: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">輸出屬性: </target>
@@ -855,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">SDK 解析程式 "{0}" 傳回 Null。</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK 解析程式 '{1}' 無法解析 SDK '{0}'。{2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 專案 "{0}" 已跳過參考專案 "{1}" 上的圖形隔離條件約束</target>
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index cf5b6ae383e..3df7fd23a1f 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -5,7 +5,11 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if NET
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
diff --git a/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs b/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs
index edbb0e6bdc9..105ba97f9e1 100644
--- a/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs
+++ b/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs
@@ -74,7 +74,7 @@ public void ExecTask_WithCommandExecutingBuild_ShouldShowWarning(string? command
             }));
 
             _registrationContext.Results.Count.ShouldBe(1);
-            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0109");
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0302");
         }
 
         [Theory]
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 440a60cc86e..76031c5b599 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -24,10 +24,13 @@
   </ItemGroup>
 
   <ItemGroup>
-    <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="Shouldly" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <PackageReference Include="System.Collections.Immutable" />
 
-    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    <Reference Include="System.Net.Http" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/EntryProject/EntryProject.csproj b/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/EntryProject/EntryProject.csproj
index 1ac36d043de..228409c378c 100644
--- a/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/EntryProject/EntryProject.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/EntryProject/EntryProject.csproj
@@ -4,6 +4,7 @@
     <TargetFramework>net9.0</TargetFramework>
     <ImplicitUsings>enable</ImplicitUsings>
     <Nullable>enable</Nullable>
+	<EnableCustomCulture>true</EnableCustomCulture>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/ReferencedProject/ReferencedProject.csproj b/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/ReferencedProject/ReferencedProject.csproj
index 4208181be80..c03ac65c696 100644
--- a/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/ReferencedProject/ReferencedProject.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/ReferencedProject/ReferencedProject.csproj
@@ -5,6 +5,7 @@
     <TargetFramework>net8.0</TargetFramework>
     <ImplicitUsings>enable</ImplicitUsings>
     <Nullable>enable</Nullable>
+	<EnableCustomCulture>true</EnableCustomCulture>
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 91e186d7fe3..deba5dbaf7a 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -138,6 +138,52 @@
 
   <Import Project="$(BUILD_STAGINGDIRECTORY)\MicroBuild\Plugins\MicroBuild.Plugins.IBCMerge.*\**\build\MicroBuild.Plugins.*.targets" Condition="'$(BUILD_STAGINGDIRECTORY)' != '' and $(TargetFramework.StartsWith('net4')) and '$(MicroBuild_EnablePGO)' != 'false'" />
 
+  <PropertyGroup>
+    <UseFrozenMaintenancePackageVersions Condition="'$(UseFrozenMaintenancePackageVersions)' == '' AND '$(IsUnitTestProject)' != 'true' AND $([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net472')) AND '$(OutputType)' != 'exe'">true</UseFrozenMaintenancePackageVersions>
+
+    <FrozenMicrosoftIORedistVersion>6.0.1</FrozenMicrosoftIORedistVersion>
+    <FrozenSystemMemoryVersion>4.5.5</FrozenSystemMemoryVersion>
+    <FrozenSystemRuntimeCompilerServicesUnsafeVersion>6.0.0</FrozenSystemRuntimeCompilerServicesUnsafeVersion>
+    <FrozenSystemThreadingTasksExtensionsVersion>4.5.4</FrozenSystemThreadingTasksExtensionsVersion>
+    <FrozenSystemBuffersVersion>4.5.1</FrozenSystemBuffersVersion>
+    <FrozenSystemNumericsVectorsVersion>4.5.0</FrozenSystemNumericsVectorsVersion>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(UseFrozenMaintenancePackageVersions)' == 'true'">
+    <PackageDownload Include="Microsoft.IO.Redist" Version="[$(FrozenMicrosoftIORedistVersion)]" />
+    <PackageDownload Include="System.Memory" Version="[$(FrozenSystemMemoryVersion)]" />
+    <PackageDownload Include="System.Runtime.CompilerServices.Unsafe" Version="[$(FrozenSystemRuntimeCompilerServicesUnsafeVersion)]" />
+    <PackageDownload Include="System.Threading.Tasks.Extensions" Version="[$(FrozenSystemThreadingTasksExtensionsVersion)]" />
+    <PackageDownload Include="System.Buffers" Version="[$(FrozenSystemBuffersVersion)]" />
+    <PackageDownload Include="System.Numerics.Vectors" Version="[$(FrozenSystemNumericsVectorsVersion)]" />
+  </ItemGroup>
+
+  <!-- Work around maintenance-packages updates breaking stuff -->
+  <Target Name="ReplaceCompileReferencesWithOlderMaintenancePackagesVersions"
+          BeforeTargets="ResolveAssemblyReferences"
+          Condition="$(UseFrozenMaintenancePackageVersions) == 'true'">
+
+    <ItemGroup>
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'Microsoft.IO.Redist' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenMicrosoftIORedistVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)microsoft.io.redist\$(FrozenMicrosoftIORedistVersion)\lib\net472\Microsoft.IO.Redist.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Buffers' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemBuffersVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.buffers\$(FrozenSystemBuffersVersion)\lib\net461\System.Buffers.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Memory' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemMemoryVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.memory\$(FrozenSystemMemoryVersion)\lib\net461\System.Memory.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Numerics.Vectors' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemNumericsVectorsVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.numerics.vectors\$(FrozenSystemNumericsVectorsVersion)\lib\net46\System.Numerics.Vectors.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Runtime.CompilerServices.Unsafe' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemRuntimeCompilerServicesUnsafeVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.runtime.compilerservices.unsafe\$(FrozenSystemRuntimeCompilerServicesUnsafeVersion)\lib\net461\System.Runtime.CompilerServices.Unsafe.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Threading.Tasks.Extensions' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemThreadingTasksExtensionsVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.threading.tasks.extensions\$(FrozenSystemThreadingTasksExtensionsVersion)\lib\net461\System.Threading.Tasks.Extensions.dll" />
+    </ItemGroup>
+  </Target>
+
   <!-- Import parent targets -->
   <Import Project="..\Directory.Build.targets"/>
 
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 4968243235a..a8ba7a3286a 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -16,18 +16,12 @@ namespace Microsoft.Build.UnitTests
     /// </summary>
     public class ProjectStartedEventArgs_Tests
     {
-        /// <summary>
-        /// Default event to use in tests.
-        /// </summary>
-        private static ProjectStartedEventArgs s_baseProjectStartedEvent;
-
         /// <summary>
         /// Setup for text fixture, this is run ONCE for the entire test fixture
         /// </summary>
         public ProjectStartedEventArgs_Tests()
         {
             BuildEventContext parentBuildEventContext = new BuildEventContext(2, 3, 4, 5);
-            s_baseProjectStartedEvent = new ProjectStartedEventArgs(1, "Message", "HelpKeyword", "ProjecFile", "TargetNames", null, null, parentBuildEventContext);
         }
 
         /// <summary>
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 7ff6bfe1338..1be2816fc33 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -56,11 +56,21 @@ internal static ITranslator GetWriteTranslator(Stream stream, byte packetVersion
         /// </summary>
         private class BinaryReadTranslator : ITranslator
         {
+            /// <summary>
+            /// The intern reader used in an intern scope.
+            /// </summary>
+            private readonly InterningReadTranslator _interner;
+
             /// <summary>
             /// The binary reader used in read mode.
             /// </summary>
             private BinaryReader _reader;
 
+            /// <summary>
+            /// Whether the caller has entered an intern scope.
+            /// </summary>
+            private bool _isInterning;
+
 #nullable enable
             /// <summary>
             /// Constructs a serializer from the specified stream, operating in the designated mode.
@@ -68,6 +78,7 @@ private class BinaryReadTranslator : ITranslator
             public BinaryReadTranslator(Stream packetStream, BinaryReaderFactory buffer, byte packetVersion = 0)
             {
                 _reader = buffer.Create(packetStream);
+                _interner = new InterningReadTranslator(this);
                 PacketVersion = packetVersion;
             }
 #nullable disable
@@ -296,7 +307,11 @@ public void Translate(ref HashSet<string> set)
                 }
 
                 int count = _reader.ReadInt32();
+#if NET472_OR_GREATER || NET9_0_OR_GREATER
+                set = new HashSet<string>(count);
+#else
                 set = new HashSet<string>();
+#endif
 
                 for (int i = 0; i < count; i++)
                 {
@@ -786,6 +801,80 @@ public bool TranslateNullable<T>(T value)
                 bool haveRef = _reader.ReadBoolean();
                 return haveRef;
             }
+
+            public void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock)
+            {
+                if (_isInterning)
+                {
+                    throw new InvalidOperationException("Cannot enter recursive intern block.");
+                }
+
+                _isInterning = true;
+
+                // Deserialize the intern header before entering the intern scope.
+                _interner.Translate(this);
+
+                // No other setup is needed since we can parse the packet directly from the stream.
+                internBlock(this);
+
+                _isInterning = false;
+            }
+
+            public void Intern(ref string str, bool nullable = true)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref str);
+                    return;
+                }
+
+                if (nullable && !TranslateNullable(string.Empty))
+                {
+                    str = null;
+                    return;
+                }
+
+                str = _interner.Read();
+            }
+
+            public void Intern(ref string[] array)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref array);
+                    return;
+                }
+
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                array = new string[count];
+
+                for (int i = 0; i < count; i++)
+                {
+                    array[i] = _interner.Read();
+                }
+            }
+
+            public void InternPath(ref string str, bool nullable = true)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref str);
+                    return;
+                }
+
+                if (nullable && !TranslateNullable(string.Empty))
+                {
+                    str = null;
+                    return;
+                }
+
+                str = _interner.ReadPath();
+            }
         }
 
         /// <summary>
@@ -798,6 +887,18 @@ private class BinaryWriteTranslator : ITranslator
             /// </summary>
             private BinaryWriter _writer;
 
+            /// <summary>
+            /// The intern writer used in an intern scope.
+            /// This must be lazily instantiated since the interner has its own internal write translator, and
+            /// would otherwise go into a recursive loop on initalization.
+            /// </summary>
+            private InterningWriteTranslator _interner;
+
+            /// <summary>
+            /// Whether the caller has entered an intern scope.
+            /// </summary>
+            private bool _isInterning;
+
             /// <summary>
             /// Constructs a serializer from the specified stream, operating in the designated mode.
             /// </summary>
@@ -1506,6 +1607,92 @@ public bool TranslateNullable<T>(T value)
                 _writer.Write(haveRef);
                 return haveRef;
             }
+
+            public void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock)
+            {
+                if (_isInterning)
+                {
+                    throw new InvalidOperationException("Cannot enter recursive intern block.");
+                }
+
+                // Every new scope requires the interner's state to be reset.
+                _interner ??= new InterningWriteTranslator();
+                _interner.Setup(comparer, initialCapacity);
+
+                // Temporaily swap our writer with the interner.
+                // This forwards all writes to this translator into the interning buffer, so that any non-interned
+                // writes which are interleaved will be in the correct order.
+                BinaryWriter streamWriter = _writer;
+                _writer = _interner.Writer;
+                _isInterning = true;
+
+                try
+                {
+                    internBlock(this);
+                }
+                finally
+                {
+                    _writer = streamWriter;
+                    _isInterning = false;
+                }
+
+                // Write the interned buffer into the real output stream.
+                _interner.Translate(this);
+            }
+
+            public void Intern(ref string str, bool nullable = true)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref str);
+                    return;
+                }
+
+                if (nullable && !TranslateNullable(str))
+                {
+                    return;
+                }
+
+                _interner.Intern(str);
+            }
+
+            public void Intern(ref string[] array)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref array);
+                    return;
+                }
+
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = array.Length;
+                Translate(ref count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    _interner.Intern(array[i]);
+                }
+            }
+
+            public void InternPath(ref string str, bool nullable = true)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref str);
+                    return;
+                }
+
+                if (nullable && !TranslateNullable(str))
+                {
+                    return;
+                }
+
+                _interner.InternPath(str);
+            }
         }
     }
 }
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 1e1264246ec..a26e7b26948 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -284,7 +284,7 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)
         /// This is used by the Message property overrides to reconstruct the
         /// message lazily on demand.
         /// </summary>
-        internal static Func<string, string?[], string> ResourceStringFormatter = (string resourceName, string?[] arguments) =>
+        internal static Func<string, string?[], string> ResourceStringFormatter = (resourceName, arguments) =>
         {
             var sb = new StringBuilder();
             sb.Append(resourceName);
diff --git a/src/Framework/BuildException/BuildExceptionBase.cs b/src/Framework/BuildException/BuildExceptionBase.cs
index b165050d341..869b74070b6 100644
--- a/src/Framework/BuildException/BuildExceptionBase.cs
+++ b/src/Framework/BuildException/BuildExceptionBase.cs
@@ -20,12 +20,12 @@ private protected BuildExceptionBase()
         : base()
     { }
 
-    private protected BuildExceptionBase(string message)
+    private protected BuildExceptionBase(string? message)
         : base(message)
     { }
 
     private protected BuildExceptionBase(
-        string message,
+        string? message,
         Exception? inner)
         : base(message, inner)
     { }
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 3bbcfe6f6f2..84e325912c2 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -140,7 +140,7 @@ internal static void ApplyChangeWave()
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
             }
-            else if (_cachedWave == EnableAllFeatures || AllWaves.Contains(_cachedWave))
+            else if (_cachedWave == EnableAllFeatures || Array.IndexOf(AllWaves, _cachedWave) >= 0)
             {
                 ConversionState = ChangeWaveConversionState.Valid;
             }
@@ -172,7 +172,7 @@ internal static bool AreFeaturesEnabled(Version wave)
             ApplyChangeWave();
 
 #if DEBUG
-            Debug.Assert(_runningTests || AllWaves.Contains(wave), $"Change wave version {wave} is invalid");
+            Debug.Assert(_runningTests || Array.IndexOf(AllWaves, wave) >= 0, $"Change wave version {wave} is invalid");
 #endif
 
             return wave < _cachedWave;
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 491604c7827..76b3ccb839c 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -20,6 +20,11 @@ public abstract class EngineServices
         /// </summary>
         public const int Version1 = 1;
 
+        /// <summary>
+        /// Version 2 with IsOutOfProcRarNodeEnabled().
+        /// </summary>
+        public const int Version2 = 2;
+
         /// <summary>
         /// Gets an explicit version of this class.
         /// </summary>
@@ -27,7 +32,7 @@ public abstract class EngineServices
         /// Must be incremented whenever new members are added. Derived classes should override
         /// the property to return the version actually being implemented.
         /// </remarks>
-        public virtual int Version => Version1;
+        public virtual int Version => Version2;
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
@@ -48,5 +53,7 @@ public abstract class EngineServices
         /// This is a performance optimization allowing tasks to skip expensive double-logging.
         /// </remarks>
         public virtual bool IsTaskInputLoggingEnabled => throw new NotImplementedException();
+
+        public virtual bool IsOutOfProcRarNodeEnabled => throw new NotImplementedException();
     }
 }
diff --git a/src/Framework/IBuildEngine7.cs b/src/Framework/IBuildEngine7.cs
index c5fcd4c18a4..040e6ac338e 100644
--- a/src/Framework/IBuildEngine7.cs
+++ b/src/Framework/IBuildEngine7.cs
@@ -11,6 +11,6 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public interface IBuildEngine7 : IBuildEngine6
     {
-        public bool AllowFailureWithoutError { get; set; }
+        bool AllowFailureWithoutError { get; set; }
     }
 }
diff --git a/src/Framework/IBuildEngine8.cs b/src/Framework/IBuildEngine8.cs
index 7d08daa0c4d..d31e09ed246 100644
--- a/src/Framework/IBuildEngine8.cs
+++ b/src/Framework/IBuildEngine8.cs
@@ -17,6 +17,6 @@ public interface IBuildEngine8 : IBuildEngine7
         /// </summary>
         /// <param name="warningCode">The warning code to check.</param>
         /// <returns>A boolean to determine whether the warning should be treated as an error.</returns>
-        public bool ShouldTreatWarningAsError(string warningCode);
+        bool ShouldTreatWarningAsError(string warningCode);
     }
 }
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index 7aa3fb44e92..d5a2fffd227 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -371,5 +371,59 @@ void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTrans
         /// <typeparam name="T">The type of object to test.</typeparam>
         /// <returns>True if the object should be written, false otherwise.</returns>
         bool TranslateNullable<T>(T value);
+
+        /// <summary>
+        /// Creates a scope which activates string interning / deduplication for any Intern_xx method.
+        /// This should generally be called from the root level packet.
+        /// </summary>
+        /// <param name="comparer">The string comparer to use when populating the intern cache.</param>
+        /// <param name="initialCapacity">The initial capacity of the intern cache.</param>
+        /// <param name="internBlock">A delegate providing a translator, in which all Intern_xx calls will go through the intern cache.</param>
+        /// <remarks>
+        /// Packet interning is implemented via a header with an array of all interned strings, followed by the body in
+        /// which any interned / duplicated strings are replaced by their ID.
+        /// <see cref="TranslationDirection"/> modes have different ordering requirements, so it would not be
+        /// possible to implement direction-agnostic serialization via the Intern_xx methods alone:
+        /// - Write: Because we don't know the full list of strings ahead of time, we need to create a temporary buffer
+        ///   for the packet body, which we can later offset when flushing to the real stream.
+        /// - Read: The intern header needs to be deserialized before the packet body, otherwise we won't know what
+        ///   string each ID maps to.
+        /// This method abstracts these requirements to the caller, such that the underlying translator will
+        /// automatically handle the appropriate IO ordering when entering / exiting the delegate scope.
+        /// </remarks>
+        void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock);
+
+        /// <summary>
+        /// Interns the string if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method.
+        /// </summary>
+        /// <param name="str">The value to be translated.</param>
+        /// <param name="nullable">
+        /// Whether to null check and translate the nullable marker.
+        /// Setting this to false can reduce packet sizes when interning large numbers of strings
+        /// which are validated to always be non-null, such as dictionary keys.
+        /// </param>
+        void Intern(ref string str, bool nullable = true);
+
+        /// <summary>
+        /// Interns each string in the array if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method. To match behavior, all strings
+        /// assumed to be non-null.
+        /// </summary>
+        /// <param name="array">The array to be translated.</param>
+        void Intern(ref string[] array);
+
+        /// <summary>
+        /// Interns the string if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method.
+        /// If the string is determined to be path-like, the path components will be interned separately.
+        /// </summary>
+        /// <param name="str">The value to be translated.</param>
+        /// <param name="nullable">
+        /// Whether to null check and translate the nullable marker.
+        /// Setting this to false can reduce packet sizes when interning large numbers of strings
+        /// which are validated to always be non-null, such as dictionary keys.
+        /// </param>
+        void InternPath(ref string str, bool nullable = true);
     }
 }
diff --git a/src/Framework/InternPathIds.cs b/src/Framework/InternPathIds.cs
new file mode 100644
index 00000000000..029f31f95ed
--- /dev/null
+++ b/src/Framework/InternPathIds.cs
@@ -0,0 +1,7 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.BackEnd
+{
+    internal readonly record struct InternPathIds(int DirectoryId, int FileNameId);
+}
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index 73180f14fb8..8b1096c5eef 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -148,6 +148,8 @@ private static void LaunchDebugger(string message, string innerMessage)
         }
         #endregion
 
+#if DEBUG
         private static bool RunningTests() => BuildEnvironmentState.s_runningTests;
+#endif
     }
 }
diff --git a/src/Framework/InterningReadTranslator.cs b/src/Framework/InterningReadTranslator.cs
new file mode 100644
index 00000000000..76a3d35b8f0
--- /dev/null
+++ b/src/Framework/InterningReadTranslator.cs
@@ -0,0 +1,84 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// Reads strings form a translator which contains interned packets.
+    /// </summary>
+    /// <remarks>
+    /// This maintains a reusable lookup table to deserialize packets interned by <see cref="InterningWriteTranslator"/>.
+    /// On Translate, the intern header (aka the array of strings indexed by ID) is deserialized.
+    /// The caller can then forward reads to deserialize any interned values in the packet body.
+    /// </remarks>
+    internal sealed class InterningReadTranslator : ITranslatable
+    {
+        private readonly ITranslator _translator;
+
+        private List<string> _strings = [];
+
+        private Dictionary<InternPathIds, string> _pathIdsToString = [];
+
+        internal InterningReadTranslator(ITranslator translator)
+        {
+            if (translator.Mode != TranslationDirection.ReadFromStream)
+            {
+                throw new InvalidOperationException(
+                    $"{nameof(InterningReadTranslator)} can only be used with {nameof(TranslationDirection.ReadFromStream)}.");
+            }
+
+            _translator = translator;
+        }
+
+        internal string? Read()
+        {
+            int key = -1;
+            _translator.Translate(ref key);
+            return _strings[key];
+        }
+
+        internal string? ReadPath()
+        {
+            // If the writer set a null marker, read this as a single string.
+            if (!_translator.TranslateNullable(string.Empty))
+            {
+                return Read();
+            }
+
+            int directoryKey = -1;
+            int fileNameKey = -1;
+            _translator.Translate(ref directoryKey);
+            _translator.Translate(ref fileNameKey);
+
+            InternPathIds pathIds = new(directoryKey, fileNameKey);
+
+            // Only concatenate paths the first time we encounter a pair.
+            if (_pathIdsToString.TryGetValue(pathIds, out string? path))
+            {
+                return path;
+            }
+
+            string directory = _strings[pathIds.DirectoryId];
+            string fileName = _strings[pathIds.FileNameId];
+            string str = string.Concat(directory, fileName);
+            _pathIdsToString.Add(pathIds, str);
+
+            return str;
+        }
+
+        public void Translate(ITranslator translator)
+        {
+            // Only deserialize the intern header since the caller will be reading directly from the stream.
+            _translator.Translate(ref _strings);
+#if NET
+            _pathIdsToString.Clear();
+            _pathIdsToString.EnsureCapacity(_strings.Count);
+#else
+            _pathIdsToString = new(_strings.Count);
+#endif
+        }
+    }
+}
diff --git a/src/Framework/InterningWriteTranslator.cs b/src/Framework/InterningWriteTranslator.cs
new file mode 100644
index 00000000000..ec31eb92eb4
--- /dev/null
+++ b/src/Framework/InterningWriteTranslator.cs
@@ -0,0 +1,173 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// Writes strings into a translator with interning / deduplication.
+    /// </summary>
+    /// <remarks>
+    /// This maintains a reusable temporary buffer and lookup table for deduplicating strings within a translatable packet.
+    /// All unique strings (as determined by the comparer) will be assigned an incrementing ID and stored into a dictionary.
+    /// This ID will be written to a private buffer in place of the string and any repeat occurrences.
+    /// When serialized into another translator, the interner will:
+    /// 1. Serialize the list of unique strings to an array, where the ID is the index.
+    /// 2. Serialize the temporary buffer (aka the packet body) with all interned strings replaced by their ID.
+    /// This ordering is important since the reader will need the string lookup table before parsing the body.
+    /// As such, two rules need to be followed when using this class:
+    /// 1. Any interleaved non-interned writes should be written using the exposed BinaryWriter to keep the overall
+    /// packet in sync.
+    /// 2. Translate should *only* be called after all internable writes have been processed.
+    /// </remarks>
+    internal sealed class InterningWriteTranslator : ITranslatable
+    {
+        private static readonly char[] DirectorySeparatorChars = [Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar];
+
+        private static readonly string IsPathMarker = string.Empty;
+
+        private static readonly string? NotPathMarker = null;
+
+        private readonly ITranslator _translator;
+
+        private readonly MemoryStream _packetStream;
+
+        private List<string> _strings = [];
+
+        private Dictionary<string, int> _stringToIds = [];
+
+        private Dictionary<string, InternPathIds> _stringToPathIds = [];
+
+        internal InterningWriteTranslator()
+        {
+            _packetStream = new MemoryStream();
+            _translator = BinaryTranslator.GetWriteTranslator(_packetStream);
+
+            // Avoid directly exposing the buffered translator - any accidental Intern_xx method calls could go into a
+            // recursive loop.
+            Writer = _translator.Writer;
+        }
+
+        /// <summary>
+        /// The writer for the underlying buffer.
+        /// Use to forward any non-interning writes into this translator.
+        /// </summary>
+        internal BinaryWriter Writer { get; }
+
+        /// <summary>
+        /// Setup the intern cache and underlying buffer. This allows the interner to be reused.
+        /// </summary>
+        /// <param name="comparer">The string comparer to use for string deduplication.</param>
+        /// <param name="initialCapacity">An estimate of the number of unique strings to be interned.</param>
+        internal void Setup(IEqualityComparer<string> comparer, int initialCapacity)
+        {
+#if NET
+            if (_stringToIds.Comparer == comparer)
+            {
+                // Clear before setting capacity, since dictionaries will rehash every entry.
+                _strings.Clear();
+                _stringToIds.Clear();
+                _stringToPathIds.Clear();
+                _strings.EnsureCapacity(initialCapacity);
+                _stringToIds.EnsureCapacity(initialCapacity);
+                _stringToPathIds.EnsureCapacity(initialCapacity);
+            }
+            else
+            {
+#endif
+                // If the interner is in a reused translator, the comparer might not match between packets.
+                // Just throw away the old collections in this case.
+                _strings.Clear();
+                _strings.Capacity = initialCapacity;
+                _stringToIds = new Dictionary<string, int>(initialCapacity, comparer);
+                _stringToPathIds = new Dictionary<string, InternPathIds>(initialCapacity, comparer);
+#if NET
+            }
+#endif
+            _packetStream.Position = 0;
+            _packetStream.SetLength(0);
+
+            // This is a rough estimate since the final size will depend on the length of each string and the total number
+            // of intern cache hits. Assume a mixture of short strings (e.g. item metadata pairs, RAR assembly metadata)
+            // and file paths (e.g. item include paths, RAR statefile entries).
+            const int CharactersPerString = 32;
+            const int BytesPerCharacter = 2;
+            const int BytesPerInternedString = 5;
+            int internHeaderSize = initialCapacity * CharactersPerString * BytesPerCharacter;
+            int packetPayloadSize = initialCapacity * BytesPerInternedString;
+            _packetStream.Capacity = internHeaderSize + packetPayloadSize;
+        }
+
+        internal void Intern(string str) => _ = InternString(str);
+
+        private int InternString(string str)
+        {
+            if (!_stringToIds.TryGetValue(str, out int index))
+            {
+                index = _strings.Count;
+                _stringToIds.Add(str, index);
+                _strings.Add(str);
+            }
+
+            _translator.Translate(ref index);
+            return index;
+        }
+
+        internal void InternPath(string str)
+        {
+            // If we've seen a string already and know it's path-like, we just need the index pair.
+            if (_stringToPathIds.TryGetValue(str, out InternPathIds pathIds))
+            {
+                _ = _translator.TranslateNullable(IsPathMarker);
+                int directoryId = pathIds.DirectoryId;
+                int fileNameId = pathIds.FileNameId;
+                _translator.Translate(ref directoryId);
+                _translator.Translate(ref fileNameId);
+                return;
+            }
+
+            // Quick and basic heuristic to check if we have a path-like string.
+            int splitId = str.LastIndexOfAny(DirectorySeparatorChars);
+            bool hasDirectorySeparator = splitId > -1
+                && splitId < str.Length - 1
+                && str.IndexOf('%') == -1;
+
+            if (!hasDirectorySeparator)
+            {
+                // Set a marker to signal the reader to parse this as a single string.
+                _ = _translator.TranslateNullable(NotPathMarker);
+                _ = InternString(str);
+                return;
+            }
+
+            string directory = str.Substring(0, splitId + 1);
+            string fileName = str.Substring(splitId + 1);
+
+            _ = _translator.TranslateNullable(IsPathMarker);
+            int directoryIndex = InternString(directory);
+            int fileNameIndex = InternString(fileName);
+
+            _stringToPathIds.Add(str, new InternPathIds(directoryIndex, fileNameIndex));
+        }
+
+        public void Translate(ITranslator translator)
+        {
+            if (translator.Mode != TranslationDirection.WriteToStream)
+            {
+                throw new InvalidOperationException(
+                    $"{nameof(InterningWriteTranslator)} can only be used with {nameof(TranslationDirection.WriteToStream)}.");
+            }
+
+            // Write the set of unique strings as the packet header.
+            translator.Translate(ref _strings);
+
+            // Write the temporary buffer as the packet body.
+            byte[] buffer = _packetStream.GetBuffer();
+            int bufferSize = (int)_packetStream.Length;
+            translator.Writer.Write(buffer, 0, bufferSize);
+        }
+    }
+}
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index 1d36dbdd09d..c9d2d96d93c 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -3,14 +3,13 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Runtime.Serialization;
 using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions; // for SecurityPermissionAttribute
 #endif
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -40,7 +39,7 @@ public LoggerException()
         /// Creates an instance of this exception using the specified error message.
         /// </summary>
         /// <param name="message">Message string</param>
-        public LoggerException(string message)
+        public LoggerException(string? message)
             : base(message, null)
         {
             // We do no verification of these parameters.
@@ -52,7 +51,7 @@ public LoggerException(string message)
         /// </summary>
         /// <param name="message">Message string</param>
         /// <param name="innerException">Inner exception. Can be null</param>
-        public LoggerException(string message, Exception innerException)
+        public LoggerException(string? message, Exception? innerException)
             : base(message, innerException)
         {
             // We do no verification of these parameters. Any can be null;
@@ -66,7 +65,7 @@ public LoggerException(string message, Exception innerException)
         /// <param name="innerException">Inner exception. Can be null</param>
         /// <param name="errorCode">Error code</param>
         /// <param name="helpKeyword">Help keyword for host IDE. Can be null</param>
-        public LoggerException(string message, Exception innerException, string errorCode, string helpKeyword)
+        public LoggerException(string? message, Exception? innerException, string? errorCode, string? helpKeyword)
             : this(message, innerException)
         {
             // We do no verification of these parameters. Any can be null.
@@ -112,18 +111,20 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("helpKeyword", helpKeyword);
         }
 
-        protected override IDictionary<string, string> FlushCustomState()
+        protected override IDictionary<string, string?> FlushCustomState()
         {
-            return new Dictionary<string, string>()
+            return new Dictionary<string, string?>()
             {
                 { nameof(errorCode), errorCode },
                 { nameof(helpKeyword), helpKeyword },
             };
         }
 
-        protected override void InitializeCustomState(IDictionary<string, string> state)
+        protected override void InitializeCustomState(IDictionary<string, string?>? state)
         {
-            errorCode = state[nameof(errorCode)];
+            Debug.Assert(state is not null, "state cannot be null");
+
+            errorCode =  state![nameof(errorCode)];
             helpKeyword = state[nameof(helpKeyword)];
         }
 
@@ -135,7 +136,7 @@ protected override void InitializeCustomState(IDictionary<string, string> state)
         /// Gets the error code associated with this exception's message (not the inner exception).
         /// </summary>
         /// <value>The error code string.</value>
-        public string ErrorCode
+        public string? ErrorCode
         {
             get
             {
@@ -147,7 +148,7 @@ public string ErrorCode
         /// Gets the F1-help keyword associated with this error, for the host IDE.
         /// </summary>
         /// <value>The keyword string.</value>
-        public string HelpKeyword
+        public string? HelpKeyword
         {
             get
             {
@@ -158,8 +159,8 @@ public string HelpKeyword
         #endregion
 
         // the error code for this exception's message (not the inner exception)
-        private string errorCode;
+        private string? errorCode;
         // the F1-help keyword for the host IDE
-        private string helpKeyword;
+        private string? helpKeyword;
     }
 }
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 4b403ebdf1d..5ed8c01507d 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -79,11 +79,12 @@ public void BuildStop()
         /// <summary>
         /// Call this method to notify listeners of information of how a project file built.
         /// <param name="projectPath">Filename of the project being built.</param>
+        /// <param name="targets">Names of the targets that built.</param>
         /// </summary>
-        [Event(5, Keywords = Keywords.All | Keywords.PerformanceLog)]
-        public void BuildProjectStart(string projectPath)
+        [Event(5, Keywords = Keywords.All | Keywords.PerformanceLog, Version = 1)]
+        public void BuildProjectStart(string projectPath, string targets)
         {
-            WriteEvent(5, projectPath);
+            WriteEvent(5, projectPath, targets);
         }
 
         /// <param name="projectPath">Filename of the project being built.</param>
@@ -672,6 +673,12 @@ public void ProjectCacheHandleBuildResultStop(string pluginTypeName, string proj
         {
             WriteEvent(92, pluginTypeName, projectPath, targets);
         }
+
+        [Event(93, Keywords = Keywords.All)]
+        public void CancelSubmissionsStart()
+        {
+            WriteEvent(93);
+        }
         #endregion
     }
 }
diff --git a/src/Framework/Telemetry/OpenTelemetryManager.cs b/src/Framework/Telemetry/OpenTelemetryManager.cs
index a659cb9a932..785c90edb42 100644
--- a/src/Framework/Telemetry/OpenTelemetryManager.cs
+++ b/src/Framework/Telemetry/OpenTelemetryManager.cs
@@ -39,6 +39,8 @@ internal class OpenTelemetryManager
         private IOpenTelemetryCollector? _collector;
 #endif
 
+        public string? LoadFailureExceptionMessage { get; set; }
+
         /// <summary>
         /// Optional activity source for MSBuild or other telemetry usage.
         /// </summary>
@@ -104,6 +106,7 @@ public void Initialize(bool isStandalone)
             {
                 // catch exceptions from loading the OTel SDK or Collector to maintain usability of Microsoft.Build.Framework package in our and downstream tests in VS.
                 _telemetryState = TelemetryState.Unsampled;
+                LoadFailureExceptionMessage = ex.ToString();
                 return;
             }
 #endif
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index f2447e47031..da8da210b3c 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -7,11 +7,12 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    ///     Represents toggleable features of the MSBuild engine
+    ///     Represents toggleable features of the MSBuild engine.
     /// </summary>
     internal class Traits
     {
         private static Traits _instance = new Traits();
+
         public static Traits Instance
         {
             get
@@ -120,6 +121,12 @@ public Traits()
         /// </summary>
         public readonly int DictionaryBasedItemRemoveThreshold = ParseIntFromEnvironmentVariableOrDefault("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", 100);
 
+        /// <summary>
+        /// Launches a persistent RAR process.
+        /// </summary>
+        /// TODO: Replace with command line flag when feature is completed. The environment variable is intented to avoid exposing the flag early.
+        public readonly bool EnableRarNode = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildRarNode"));
+
         /// <summary>
         /// Name of environment variables used to enable MSBuild server.
         /// </summary>
@@ -132,7 +139,6 @@ public Traits()
 
         public readonly bool InProcNodeDisabled = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
-
         /// <summary>
         /// Variables controlling opt out at the level of not initializing telemetry infrastructure. Set to "1" or "true" to opt out.
         /// mirroring
diff --git a/src/MSBuild.Bootstrap.Utils/Tasks/LocateVisualStudioTask.cs b/src/MSBuild.Bootstrap.Utils/Tasks/LocateVisualStudioTask.cs
new file mode 100644
index 00000000000..91cf7608e36
--- /dev/null
+++ b/src/MSBuild.Bootstrap.Utils/Tasks/LocateVisualStudioTask.cs
@@ -0,0 +1,62 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Text;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace MSBuild.Bootstrap.Utils.Tasks
+{
+    public class LocateVisualStudioTask : ToolTask
+    {
+        private readonly StringBuilder _standardOutput = new();
+
+        [Output]
+        public string VsInstallPath { get; set; }
+
+        protected override string ToolName => "vswhere.exe";
+
+        protected override string GenerateFullPathToTool()
+        {
+            string programFilesX86 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86);
+            string vsWherePath = Path.Combine(programFilesX86, "Microsoft Visual Studio", "Installer", ToolName);
+
+
+            return vsWherePath;
+        }
+
+        protected override string GenerateCommandLineCommands() => "-latest -prerelease -property installationPath";
+
+        public override bool Execute()
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                Log.LogMessage(MessageImportance.High, "Not running on Windows. Skipping Visual Studio detection.");
+                return true;
+            }
+
+            _ = ExecuteTool(GenerateFullPathToTool(), string.Empty, GenerateCommandLineCommands());
+
+            if (!Log.HasLoggedErrors)
+            {
+                VsInstallPath = _standardOutput.ToString().Trim();
+            }
+
+            return true;
+        }
+
+        // Override to capture standard output
+        protected override void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance)
+        {
+            if (!string.IsNullOrWhiteSpace(singleLine))
+            {
+                _ = _standardOutput.AppendLine(singleLine);
+            }
+
+            base.LogEventsFromTextOutput(singleLine, messageImportance);
+        }
+    }
+}
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 0876e2b8eec..4839c0dcbfa 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -9,6 +9,9 @@
     <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
 
     <DeterministicSourcePaths>false</DeterministicSourcePaths>
+
+    <!-- The output of this project is sort of an "executable" so it can get the latest versions of everything. -->
+    <UseFrozenMaintenancePackageVersions>false</UseFrozenMaintenancePackageVersions>
   </PropertyGroup>
 
   <ItemGroup>
@@ -53,4 +56,4 @@
 
   <Import Project="$(RepoRoot)eng\BootStrapMsBuild.targets" />
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index bc93f3ea4aa..b18eb45c346 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -10,6 +10,7 @@
 using System.Linq;
 using System.Reflection;
 using System.Runtime.InteropServices;
+using System.Text.RegularExpressions;
 using System.Threading;
 using System.Xml.Linq;
 using Microsoft.Build.CommandLine;
@@ -2711,6 +2712,16 @@ public void EndToEndMinimumMessageImportance(string arguments, MessageImportance
 
             TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents);
 
+            // If /bl is specified, set a path for the binlog that is defined by the test environment
+            string pattern = @"/v:(\w+)\s/b"; ;
+            Regex.Match(arguments, pattern);
+            Match match = Regex.Match(arguments, pattern);
+            if (match.Success)
+            {
+                string binlogPath = Path.Combine(testProject.TestRoot, match.Groups[1] + ".binlog");
+                arguments = arguments.Replace("/bl", $"/bl:{binlogPath}");
+            }
+
             // Build in-proc.
             RunnerUtilities.ExecMSBuild($"{arguments} \"{testProject.ProjectFile}\"", out bool success, _output);
             success.ShouldBeTrue();
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index fdfd2b36762..e8ce5dd036d 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.CommandLine
     /// This exception is used to flag (syntax) errors in command line switches passed to the application.
     /// </summary>
     [Serializable]
-    internal sealed class CommandLineSwitchException : Exception
+    internal sealed class CommandLineSwitchException : Exception // CodeQL [SM02227] The dangerous method is called only in debug build. It's safe for release build.
     {
         /// <summary>
         /// This constructor initializes the exception message.
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index 4607ec549af..2d1153029b7 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.CommandLine
     /// Unlike the CommandLineSwitchException, this exception is NOT thrown for syntax errors in switches.
     /// </remarks>
     [Serializable]
-    internal sealed class InitializationException : Exception
+    internal sealed class InitializationException : Exception // CodeQL [SM02227] The dangerous method is called only in debug build. It's safe for release build.
     {
         /// <summary>
         /// This constructor initializes the exception message.
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2edca8c339b..686e78276ab 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -179,7 +179,6 @@
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
-    <PackageReference Include="System.Diagnostics.DiagnosticSource" /><!-- for consistency with Framework via transitives -->
   </ItemGroup>
   <!-- Manually download this library for RoslynCodeTaskFactory.
            See target AddRefAssemblies below. -->
@@ -194,6 +193,7 @@
     <Reference Include="System.Core" />
     <Reference Include="System.Xml" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
+    <PackageReference Include="System.Diagnostics.DiagnosticSource" /><!-- for consistency with Framework via transitives -->
   </ItemGroup>
 
   <ItemGroup>
@@ -274,9 +274,6 @@
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualBasic.CrossTargeting.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualBasic.CurrentVersion.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualBasic.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
-      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualStudioVersion.v11.Common.props" TargetFramework="%(_TargetFrameworks.Identity)" />
-      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualStudioVersion.v12.Common.props" TargetFramework="%(_TargetFrameworks.Identity)" />
-      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualStudioVersion.v14.Common.props" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\ref\**" TargetFramework="%(_TargetFrameworks.Identity)" Subdirectory="ref\" />
     </ItemGroup>
 
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 05365f4f62a..a21af6ba0a0 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -450,7 +450,7 @@ elementFormDefault="qualified">
             <xs:element name="BasicRuntimeChecks" />
             <xs:element name="RuntimeLibrary" />
             <xs:element name="FunctionLevelLinking" />
-            <xs:element name="FloatingPointModel " />
+            <xs:element name="FloatingPointModel" />
             <xs:element name="IntrinsicFunctions" />
             <xs:element name="PrecompiledHeaderFile"/>
             <xs:element name="MultiProcessorCompilation" />
@@ -1893,6 +1893,7 @@ elementFormDefault="qualified">
     <xs:element name="LinkIncremental" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestCertificateThumbprint" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestKeyFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="EnableCustomCulture" type="msb:boolean" substitutionGroup="msb:EnableCustomCulture"/>
     <xs:element name="MapFileExtensions" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="MapFileExtensions" _locComment="" -->boolean</xs:documentation>
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index be768b58b8d..3eeb975bc40 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -97,28 +97,5 @@ public static MSBuildApp.ExitType Execute(
 
             return MSBuildApp.ExitType.MSBuildClientFailure;
         }
-
-        // Copied from NodeProviderOutOfProcBase.cs
-#if RUNTIME_TYPE_NETCORE
-        private static string? CurrentHost;
-        private static string GetCurrentHost()
-        {
-            if (CurrentHost == null)
-            {
-                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
-                    NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
-                if (File.Exists(dotnetExe))
-                {
-                    CurrentHost = dotnetExe;
-                }
-                else
-                {
-                    CurrentHost = EnvironmentUtilities.ProcessPath ?? throw new InvalidOperationException("Failed to retrieve process executable.");
-                }
-            }
-
-            return CurrentHost;
-        }
-#endif
     }
 }
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index fbd97f6e083..9b670a086d4 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -591,6 +591,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes the specified packet
         /// </summary>
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 691ded85c3a..17649c98a14 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -712,6 +712,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 17f88bf1e8b..c6014c6874a 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -2005,6 +2005,14 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2038,7 +2046,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializuje všechny události sestavení do komprimovaného binárního souboru.
                      Tento soubor se standardně nachází v aktuálním adresáři a má název msbuild.binlog.
                      Binární protokol je podrobný popis procesu sestavení, který se
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 03c2ca750fb..d925361988c 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1993,6 +1993,14 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,7 +2034,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serialisiert alle Buildereignisse in eine komprimierte Binärdatei.
                      Standardmäßig befindet sich die Datei im aktuellen Verzeichnis und hat den Namen
                      „msbuild.binlog“. Das binäre Protokoll ist eine detaillierte Beschreibung
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index d8d6d837bb7..a2d5f06ed08 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1999,6 +1999,14 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2032,7 +2040,7 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializa todos los eventos de compilación en un archivo                     binario comprimido.
  De manera predeterminada, el archivo se encuentra en el directorio actual y tiene
                      el nombre "msbuild.binlog". El registro binario es una
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index ac46ff96a7d..859d96f7713 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1994,6 +1994,14 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2027,7 +2035,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Sérialise tous les événements de build dans un fichier binaire compressé.
                      Par défaut, le fichier se trouve dans le répertoire actif et se nomme
                      "msbuild.binlog". Le journal binaire est une description détaillée
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 842cdf22a24..f837954ebb9 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -2006,6 +2006,14 @@ Nota: livello di dettaglio dei logger di file
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2039,7 +2047,7 @@ Nota: livello di dettaglio dei logger di file
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializza tutti gli eventi di compilazione in un file binario compresso.
                      Per impostazione predefinita, il file csi trova nella directory corrente e si chiama
                      "msbuild.binlog". Il log binario è una descrizione
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 4dad67e4fa9..4e2c4166a30 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,7 +2034,7 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      すべてのビルド イベントを圧縮バイナリ ファイルにシリアル化します。
                      既定では、このファイルは "msbuild.binlog" という名前で
                      現在のディレクトリに置かれます。バイナリ ログはビルド プロセスの
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index b4c9c4b26fe..c027f3e3493 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,7 +2034,7 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      모든 빌드 이벤트를 압축된 이진 파일로 직렬화합니다.
                      기본적으로 이 파일은 현재 디렉터리에 있으며 이름은
                      "msbuild.binlog"입니다. 이진 로그는 빌드 프로세스를
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 5d20dcb3b21..3314d604ce6 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -2003,6 +2003,14 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2036,7 +2044,7 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]wyjście.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]wyjście.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializuje wszystkie zdarzenia kompilacji do skompresowanego pliku binarnego.
                      Domyślnie plik znajduje się w bieżącym katalogu i ma nazwę
                      „msbuild.binlog”. Dziennik binarny to szczegółowy opis procesu
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 873f8078d9d..445070bea1c 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1993,6 +1993,14 @@ arquivo de resposta.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,7 +2034,7 @@ arquivo de resposta.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializa todos os eventos da compilação em um arquivo binário compactado.
                      Por padrão, o arquivo está no diretório atual e é chamado de
                      "msbuild.binlog". O log binário é uma descrição detalhada
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 53e8695e09b..2efb0bca84e 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,7 +2034,7 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Сериализует все события сборки в сжатый двоичный файл.
                      По умолчанию файл находится в текущем каталоге и называется
                      "msbuild.binlog". Двоичный журнал включает подробное описание
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index f01b080e37d..45f67f474cc 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1996,6 +1996,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2029,7 +2037,7 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Tüm derleme olaylarını sıkıştırılmış bir ikili dosyada seri hale getirir.
                      Varsayılan olarak, dosya geçerli dizinde bulunur ve "msbuild.binlog"
                      olarak adlandırılır. Daha sonra metin günlüklerini yeniden
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 0968a8a75fb..5b9eb8f6cb4 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1992,6 +1992,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2025,7 +2033,7 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      将所有生成事件序列化为压缩的二进制文件。
                      默认情况下该文件位于当前目录并且名为 "msbuild.binlog"。
                      二进制日志是生成过程的详细描述，
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index b2b8fb45067..69fd2495b08 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,7 +2034,7 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                     將所有建置事件序列化成壓縮的二進位檔案。
                      根據預設，此檔案存放在目前的目錄下，並會命名為
                      「msbuild.binlog」。此二進位記錄檔是
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 357cb767e84..f9006a5b5b2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -35,6 +35,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Tasks.AssemblyDependency;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
 using FileLogger = Microsoft.Build.Logging.FileLogger;
@@ -655,6 +656,9 @@ public static ExitType Execute(
         {
             DebuggerLaunchCheck();
 
+            // Resets the build completion event, signaling that a new build process is starting.
+            s_buildComplete.Reset();
+
             // Initialize new build telemetry and record start of this build, if not initialized already
             KnownTelemetry.PartialBuildTelemetry ??= new BuildTelemetry { StartAt = DateTime.UtcNow };
 
@@ -1045,6 +1049,13 @@ public static ExitType Execute(
 
                 exitType = ExitType.Unexpected;
             }
+            catch (PathTooLongException e)
+            {
+                Console.WriteLine(
+                    $"{e.Message}{(e.InnerException != null ? $" {e.InnerException.Message}" : string.Empty)}");
+
+                exitType = ExitType.Unexpected;
+            }
             // handle fatal errors
             catch (Exception e)
             {
@@ -1529,6 +1540,11 @@ internal static bool BuildProject(
                         }
                     }
 
+                    if (Traits.Instance.EnableRarNode)
+                    {
+                        parameters.EnableRarNode = true;
+                    }
+
                     List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
 
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
@@ -3432,6 +3448,21 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool
                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                     shutdownReason = node.Run(out nodeException);
                 }
+                else if (nodeModeNumber == 3)
+                {
+                    // The RAR service persists between builds, and will continue to process requests until terminated.
+                    OutOfProcRarNode rarNode = new();
+                    RarNodeShutdownReason rarShutdownReason = rarNode.Run(out nodeException, s_buildCancellationSource.Token);
+
+                    shutdownReason = rarShutdownReason switch
+                    {
+                        RarNodeShutdownReason.Complete => NodeEngineShutdownReason.BuildComplete,
+                        RarNodeShutdownReason.Error => NodeEngineShutdownReason.Error,
+                        RarNodeShutdownReason.AlreadyRunning => NodeEngineShutdownReason.Error,
+                        RarNodeShutdownReason.ConnectionTimedOut => NodeEngineShutdownReason.ConnectionFailed,
+                        _ => throw new ArgumentOutOfRangeException(nameof(rarShutdownReason), $"Unexpected value: {rarShutdownReason}"),
+                    };
+                }
                 else if (nodeModeNumber == 8)
                 {
                     // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly
@@ -4526,6 +4557,7 @@ private static void ReplayBinaryLog(
             }
         }
 
+#if FEATURE_XML_SCHEMA_VALIDATION
         /// <summary>
         /// Figures out if the project needs to be validated against a schema.
         /// </summary>
@@ -4546,6 +4578,7 @@ private static string ProcessValidateSwitch(string[] parameters)
 
             return schemaFile;
         }
+#endif
 
         /// <summary>
         /// Given an invalid ToolsVersion string and the collection of valid toolsets,
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index ca919c51e3f..528707c3e22 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -39,8 +39,8 @@
 
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
-          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.1" />
-          <codeBase version="6.0.0.1" href="..\Microsoft.IO.Redist.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.1.0.0" newVersion="6.1.0.0" />
+          <codeBase version="6.1.0.0" href="..\Microsoft.IO.Redist.dll"/>
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
@@ -94,8 +94,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
-          <codeBase version="4.0.3.0" href="..\System.Buffers.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
+          <codeBase version="4.0.4.0" href="..\System.Buffers.dll"/>
         </dependentAssembly>
 
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
@@ -190,13 +190,13 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
-          <codeBase version="4.0.1.2" href="..\System.Memory.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
+          <codeBase version="4.0.2.0" href="..\System.Memory.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
-          <codeBase version="4.1.4.0" href="..\System.Numerics.Vectors.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
+          <codeBase version="4.1.5.0" href="..\System.Numerics.Vectors.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -215,8 +215,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
-          <codeBase version="6.0.0.0" href="..\System.Runtime.CompilerServices.Unsafe.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
+          <codeBase version="6.0.1.0" href="..\System.Runtime.CompilerServices.Unsafe.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -240,8 +240,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
-          <codeBase version="4.2.0.1" href="..\System.Threading.Tasks.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.2.1.0" newVersion="4.2.1.0" />
+          <codeBase version="4.2.1.0" href="..\System.Threading.Tasks.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index f1bb2ea9f69..cd0059bd3db 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -45,7 +45,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.1" newVersion="6.0.0.1" />
+          <bindingRedirect oldVersion="0.0.0.0-6.1.0.0" newVersion="6.1.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -57,7 +57,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
         </dependentAssembly>
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
@@ -78,11 +78,11 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
+          <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -98,7 +98,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -114,7 +114,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
+          <bindingRedirect oldVersion="0.0.0.0-4.2.1.0" newVersion="4.2.1.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index a189f58567a..8512aae44f0 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -221,6 +221,10 @@
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\AssemblyNameExtension.cs" />
 
+    <Compile Include="..\Framework\InterningReadTranslator.cs" />
+    <Compile Include="..\Framework\InterningWriteTranslator.cs" />
+    <Compile Include="..\Framework\InternPathIds.cs" />
+
     <Compile Include="..\Shared\FileSystem\IFileSystem.cs" />
     <Compile Include="..\Shared\FileSystem\FileSystems.cs" />
     <Compile Include="FileSystem\MSBuildTaskHostFileSystem.cs" />
diff --git a/src/Package/DevDivPackage/DevDivPackage.csproj b/src/Package/DevDivPackage/DevDivPackage.csproj
index 5fd8407217e..9ed627a7938 100644
--- a/src/Package/DevDivPackage/DevDivPackage.csproj
+++ b/src/Package/DevDivPackage/DevDivPackage.csproj
@@ -2,6 +2,7 @@
   <Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk" />
   <PropertyGroup>
     <TargetFramework>$(FullFrameworkTFM)</TargetFramework>
+    <UseFrozenMaintenancePackageVersions>false</UseFrozenMaintenancePackageVersions>
     <NuspecFile>VS.ExternalAPIs.MSBuild.nuspec</NuspecFile>
     <IsShipping>false</IsShipping>
     <PlatformTarget>x86</PlatformTarget>
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index ee8123a3994..a9e28eea646 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -22,7 +22,6 @@ vs.relatedProcessFiles
 
 folder InstallDir:\MSBuild\Current
   file source=$(X86BinPath)Microsoft.Common.props
-  file source=$(X86BinPath)Microsoft.VisualStudioVersion.v17.Common.props
   file source=$(ThirdPartyNotice)
 
 folder InstallDir:\MSBuild\Current\Bin
diff --git a/src/Samples/Directory.Build.props b/src/Samples/Directory.Build.props
index be310dc5e89..4e968bdb712 100644
--- a/src/Samples/Directory.Build.props
+++ b/src/Samples/Directory.Build.props
@@ -16,6 +16,8 @@
 
     <IsShipping>false</IsShipping>
     <ExcludeFromSourceOnlyBuild>true</ExcludeFromSourceOnlyBuild>
+
+    <UseFrozenMaintenancePackageVersions>false</UseFrozenMaintenancePackageVersions>
   </PropertyGroup>
 
 </Project>
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index 684e80213ae..ec425f3f969 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -1,4 +1,5 @@
 <Project Sdk="Microsoft.NET.Sdk">
+
   <PropertyGroup>
     <UseProductOutputPath>true</UseProductOutputPath>
     <CopyNuGetImplementations>false</CopyNuGetImplementations>
@@ -7,17 +8,20 @@
     <TargetFrameworks>$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
     <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
   </PropertyGroup>
+
   <ItemGroup>
     <PackageReference Include="Microsoft.Build" Version="16.11.0" PrivateAssets="all" />
+    <PackageReference Include="Shouldly" Version="4.2.1" />
 
     <!-- Bump versions of transitive dependencies to vulnerable packages,
          but don't reference them so the plugin doesn't carry higher references
          than its targeted MSBuild. NOT NECESSARY for public plugins; use higher MSBuild. -->
     <PackageReference Include="System.Drawing.Common" Version="4.7.2" ExcludeAssets="all" />
-    <PackageReference Include="System.Text.Encodings.Web" Version="4.7.2" ExcludeAssets="all" />
   </ItemGroup>
-  <ItemGroup>
-    <PackageReference Include="Shouldly" Version="4.2.1" />
-    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <PackageReference Include="System.Text.Encodings.Web" Version="4.7.2" ExcludeAssets="all" />
+    <Reference Include="System.Net.Http" />
   </ItemGroup>
+
 </Project>
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 12017934f1f..9f4b12b918e 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -989,8 +989,8 @@ public void Translate(ITranslator translator)
 
             // TODO: consider some kind of protection against infinite loop during serialization, hint: pre serialize check for cycle in graph
             translator.TranslateHashSet(ref remappedFrom,
-                (ITranslator t) => new AssemblyNameExtension(t),
-                (int capacity) => CreateRemappedFrom());
+                (t) => new AssemblyNameExtension(t),
+                (capacity) => CreateRemappedFrom());
         }
     }
 }
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 9f43d60c469..465caedb85a 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -93,7 +93,12 @@ internal class Handshake
         protected readonly int fileVersionPrivate;
         private readonly int sessionId;
 
-        protected internal Handshake(HandshakeOptions nodeType)
+        internal Handshake(HandshakeOptions nodeType)
+            : this(nodeType, includeSessionId: true)
+        {
+        }
+
+        protected Handshake(HandshakeOptions nodeType, bool includeSessionId)
         {
             const int handshakeVersion = (int)CommunicationsUtilities.handshakeVersion;
 
@@ -110,7 +115,6 @@ protected internal Handshake(HandshakeOptions nodeType)
                 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
             CommunicationsUtilities.Trace("Tools directory root is {0}", toolsDirectory);
             salt = CommunicationsUtilities.GetHashCode($"{handshakeSalt}{toolsDirectory}");
-
             if (isNetTaskHost)
             {
                 // hardcode version to activate json protocol that allows to have more version flexibility
@@ -128,8 +132,12 @@ protected internal Handshake(HandshakeOptions nodeType)
                 fileVersionPrivate = fileVersion.Revision;
             }
 
-            using Process currentProcess = Process.GetCurrentProcess();
-            sessionId = currentProcess.SessionId;
+            // This reaches out to NtQuerySystemInformation. Due to latency, allow skipping for derived handshake if unused.
+            if (includeSessionId)
+            {
+                using Process currentProcess = Process.GetCurrentProcess();
+                sessionId = currentProcess.SessionId;
+            }
         }
 
         // This is used as a key, so it does not need to be human readable.
@@ -161,7 +169,7 @@ internal sealed class ServerNodeHandshake : Handshake
         public override byte? ExpectedVersionInFirstByte => null;
 
         internal ServerNodeHandshake(HandshakeOptions nodeType)
-            : base(nodeType)
+            : base(nodeType, includeSessionId: false)
         {
         }
 
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index b48401b964f..28797141eba 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -294,13 +294,26 @@ public bool Remove(KeyValuePair<string, V> item)
             return initial != _backing; // whether the removal occured
         }
 
+#if NET472_OR_GREATER || NETCOREAPP
         /// <summary>
         /// Implementation of generic IEnumerable.GetEnumerator()
         /// </summary>
+        public ImmutableDictionary<string, V>.Enumerator GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        IEnumerator<KeyValuePair<string, V>> IEnumerable<KeyValuePair<string, V>>.GetEnumerator()
+        {
+            ImmutableDictionary<string, V>.Enumerator enumerator = _backing.GetEnumerator();
+            return _backing.GetEnumerator();
+        }
+#else
         public IEnumerator<KeyValuePair<string, V>> GetEnumerator()
         {
             return _backing.GetEnumerator();
         }
+#endif
 
         /// <summary>
         /// Implementation of IEnumerable.GetEnumerator()
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index 0702770278a..11618bc3cc6 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if DEBUG
 using System.IO;
+#endif
 using System.Reflection;
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
@@ -38,13 +40,17 @@ internal sealed class PrintLineDebugger : IDisposable
         public static Lazy<PrintLineDebugger> DefaultWithProcessInfo =
             new Lazy<PrintLineDebugger>(() => Create(null, null, true));
 
+#if DEBUG
         private readonly string _id;
+#endif
 
         private readonly CommonWriterType _writerSetByThisInstance;
 
         public PrintLineDebugger(string id, CommonWriterType writer)
         {
+#if DEBUG
             _id = id ?? string.Empty;
+#endif
 
             if (writer != null)
             {
@@ -145,10 +151,12 @@ public void Log(
 #endif
         }
 
+#if DEBUG
         private static string CallsiteString(string sourceFilePath, string memberName, int sourceLineNumber)
         {
             return $"@{Path.GetFileNameWithoutExtension(sourceFilePath)}.{memberName}({sourceLineNumber})";
         }
+#endif
 
         private void ReleaseUnmanagedResources()
         {
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 9d97c12de8d..56f9e88cba2 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -6,7 +6,11 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !NETFRAMEWORK
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
@@ -2633,13 +2637,13 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
 
             // Ensure that the prefix match wasn't to a distinct directory, so that
             // x\y\prefix doesn't falsely match x\y\prefixmatch.
-            if (directorySeparatorCharacters.Contains(possibleParent[possibleParent.Length - 1]))
+            if (Array.IndexOf(directorySeparatorCharacters, possibleParent[possibleParent.Length - 1]) >= 0)
             {
                 return true;
             }
             else
             {
-                return directorySeparatorCharacters.Contains(possibleChild[possibleParent.Length]);
+                return Array.IndexOf(directorySeparatorCharacters, possibleChild[possibleParent.Length]) >= 0;
             }
         }
 
diff --git a/src/Shared/FileSystem/IFileSystem.cs b/src/Shared/FileSystem/IFileSystem.cs
index 191e348ee2d..8bfcb130067 100644
--- a/src/Shared/FileSystem/IFileSystem.cs
+++ b/src/Shared/FileSystem/IFileSystem.cs
@@ -38,7 +38,7 @@ internal interface IFileSystem
 
         FileAttributes GetAttributes(string path);
 
-        public DateTime GetLastWriteTimeUtc(string path);
+        DateTime GetLastWriteTimeUtc(string path);
 
         bool DirectoryExists(string path);
 
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index f2223635f80..53f3c7c4bc7 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -18,6 +18,7 @@ internal class ManagedFileSystem : IFileSystem
 
         public static ManagedFileSystem Singleton() => ManagedFileSystem.Instance;
 
+#if FEATURE_MSIOREDIST
         private static bool ShouldUseMicrosoftIO
         {
             get
@@ -31,6 +32,7 @@ private static bool ShouldUseMicrosoftIO
 #endif
             }
         }
+#endif
 
         protected ManagedFileSystem() { }
 
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 1493d0f29a8..a83d932c00d 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -55,6 +55,12 @@ public override IEnumerable<string> EnumerateFileSystemEntries(string path, stri
 
         public override bool DirectoryExists(string path)
         {
+            if (!string.IsNullOrEmpty(path) && FileUtilities.IsPathTooLong(path))
+            {
+                // If the path is too long, we can't check if it exists on windows
+                string message = ResourceUtilities.FormatString(AssemblyResources.GetString("Shared.PathTooLong"), path, NativeMethodsShared.MaxPath);
+                throw new PathTooLongException(message);
+            }
             return NativeMethodsShared.DirectoryExistsWindows(path);
         }
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 911439a8bb0..71259e9d412 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -1239,7 +1239,7 @@ internal static string AttemptToShortenPath(string path)
             return FixFilePath(path);
         }
 
-        private static bool IsPathTooLong(string path)
+        public static bool IsPathTooLong(string path)
         {
             // >= not > because MAX_PATH assumes a trailing null
             return path.Length >= NativeMethodsShared.MaxPath;
@@ -1565,21 +1565,42 @@ internal static void ClearFileExistenceCache()
 
         internal static void ReadFromStream(this Stream stream, byte[] content, int startIndex, int length)
         {
-#if NET
             stream.ReadExactly(content, startIndex, length);
-#else
-            int bytesRead = 0;
-            while (bytesRead < length)
+        }
+    }
+}
+
+#if !NET
+namespace System.IO
+{
+    internal static class StreamExtensions
+    {
+        internal static void ReadExactly(this Stream stream, byte[] buffer, int offset, int count)
+        {
+            if (buffer == null)
             {
-                int read = stream.Read(content, startIndex + bytesRead, length - bytesRead);
-                if (read == 0)
+                throw new ArgumentNullException(nameof(buffer));
+            }
+            if (offset < 0)
+            {
+                throw new ArgumentOutOfRangeException(nameof(offset));
+            }
+            if ((uint)count > buffer.Length - offset)
+            {
+                throw new ArgumentOutOfRangeException(nameof(count));
+            }
+
+            while (count > 0)
+            {
+                int read = stream.Read(buffer, offset, count);
+                if (read <= 0)
                 {
                     throw new EndOfStreamException();
                 }
-
-                bytesRead += read;
+                offset +=read;
+                count -= read;
             }
-#endif
         }
     }
 }
+#endif
\ No newline at end of file
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 458272bcc30..506ba750ab3 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -1261,26 +1261,11 @@ private class DotNetFrameworkSpec
             private const string HKLM = "HKEY_LOCAL_MACHINE";
             private const string MicrosoftSDKsRegistryKey = @"SOFTWARE\Microsoft\Microsoft SDKs";
 
-            /// <summary>
-            /// The registry key of this .net framework, i.e. "SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full" for .net v4.5.
-            /// </summary>
-            private readonly string _dotNetFrameworkRegistryKey;
-
-            /// <summary>
-            /// The name in registry to indicate that this .net framework is installed, i.e. "Install" for .net v4.5.
-            /// </summary>
-            private readonly string _dotNetFrameworkSetupRegistryInstalledName;
-
             /// <summary>
             /// The key in registry to indicate the sdk tools folder, i.e. "WinSDK-NetFx40Tools-x86" for .net v4.5.
             /// </summary>
             private readonly string _dotNetFrameworkSdkRegistryToolsKey;
 
-            /// <summary>
-            /// The version of visual studio that shipped with this .net framework.
-            /// </summary>
-            private readonly Version _visualStudioVersion;
-
             /// <summary>
             /// Does this .net framework include MSBuild?
             /// </summary>
@@ -1298,9 +1283,24 @@ private class DotNetFrameworkSpec
 
 #if FEATURE_WIN32_REGISTRY
             /// <summary>
-            /// Cached path of the corresponding windows sdk.
+            /// The registry key of this .net framework, i.e. "SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full" for .net v4.5.
+            /// </summary>
+            private readonly string _dotNetFrameworkRegistryKey;
+
+            /// <summary>
+            /// The name in registry to indicate that this .net framework is installed, i.e. "Install" for .net v4.5.
+            /// </summary>
+            private readonly string _dotNetFrameworkSetupRegistryInstalledName;
+
+            /// <summary>
+            /// /// Cached path of the corresponding windows sdk.
             /// </summary>
             private string _pathToWindowsSdk;
+
+            /// <summary>
+            /// The version of visual studio that shipped with this .net framework.
+            /// </summary>
+            private readonly Version _visualStudioVersion;
 #endif
 
             /// <summary>
@@ -1319,15 +1319,18 @@ public DotNetFrameworkSpec(
                 Version visualStudioVersion = null)
             {
                 this.Version = version;
-                this._visualStudioVersion = visualStudioVersion;
-                this._dotNetFrameworkRegistryKey = dotNetFrameworkRegistryKey;
-                this._dotNetFrameworkSetupRegistryInstalledName = dotNetFrameworkSetupRegistryInstalledName;
                 this.DotNetFrameworkFolderPrefix = dotNetFrameworkVersionFolderPrefix;
                 this._dotNetFrameworkSdkRegistryToolsKey = dotNetFrameworkSdkRegistryToolsKey;
                 this.DotNetFrameworkSdkRegistryInstallationFolderName = dotNetFrameworkSdkRegistryInstallationFolderName;
                 this._hasMsBuild = hasMSBuild;
                 this._pathsToDotNetFramework = new ConcurrentDictionary<DotNetFrameworkArchitecture, string>();
                 this._pathsToDotNetFrameworkSdkTools = new ConcurrentDictionary<Version, string>();
+
+#if FEATURE_WIN32_REGISTRY
+                this._dotNetFrameworkRegistryKey = dotNetFrameworkRegistryKey;
+                this._dotNetFrameworkSetupRegistryInstalledName = dotNetFrameworkSetupRegistryInstalledName;
+                this._visualStudioVersion = visualStudioVersion;
+#endif
             }
 
             /// <summary>
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 390978c9863..94c69720a5e 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -207,6 +207,16 @@ internal enum NodePacketType : byte
         // Do not set it for any other packet types to avoid conflicts.
         #region ServerNode enums 
 
+        /// <summary>
+        /// A request contains the inputs to the RAR task.
+        /// </summary>
+        RarNodeExecuteRequest,
+
+        /// <summary>
+        /// A request contains the outputs and log events of a completed RAR task.
+        /// </summary>
+        RarNodeExecuteResponse,
+
         /// <summary>
         /// Command in form of MSBuild command line for server node - MSBuild Server.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI.
diff --git a/src/Shared/INodePacketFactory.cs b/src/Shared/INodePacketFactory.cs
index c972e0408b5..63d469eb021 100644
--- a/src/Shared/INodePacketFactory.cs
+++ b/src/Shared/INodePacketFactory.cs
@@ -43,7 +43,14 @@ internal interface INodePacketFactory
         void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
 
         /// <summary>
-        /// Routes the specified packet
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator);
+
+        /// <summary>
+        /// Routes the specified packet.
         /// </summary>
         /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packet">The packet to route.</param>
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index 6b2f8aed5c8..6be0b228a75 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
-#nullable disable
 
 namespace Microsoft.Build.Shared
 {
@@ -47,7 +46,7 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
             // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.
 
             // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.
-            Type t = type;
+            Type? t = type;
             while (t is not null)
             {
                 if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(LoadInSeparateAppDomainAttribute))))
@@ -92,7 +91,7 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
                 }
 
                 // Check whether it's assignable to ITaskItem or ITaskItem[]. Simplify to just checking for ITaskItem.
-                Type pt = props[i].PropertyType;
+                Type? pt = props[i].PropertyType;
                 if (pt.IsArray)
                 {
                     pt = pt.GetElementType();
@@ -101,9 +100,9 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
                 bool isAssignableToITask = iTaskItemType.IsAssignableFrom(pt);
 
                 Properties[i] = new ReflectableTaskPropertyInfo(props[i], outputAttribute, requiredAttribute, isAssignableToITask);
-                if (loadedViaMetadataLoadContext)
+                if (loadedViaMetadataLoadContext && PropertyAssemblyQualifiedNames != null)
                 {
-                    PropertyAssemblyQualifiedNames[i] = Properties[i].PropertyType.AssemblyQualifiedName;
+                    PropertyAssemblyQualifiedNames[i] = Properties[i]?.PropertyType?.AssemblyQualifiedName?? string.Empty;
                 }
             }
 #else
@@ -143,7 +142,7 @@ private bool CheckForHardcodedSTARequirement()
             {
                 AssemblyName assemblyName = Type.GetTypeInfo().Assembly.GetName();
                 Version lastVersionToForce = new Version(3, 5);
-                if (assemblyName.Version.CompareTo(lastVersionToForce) > 0)
+                if (assemblyName.Version?.CompareTo(lastVersionToForce) > 0)
                 {
                     if (String.Equals(assemblyName.Name, "PresentationBuildTasks", StringComparison.OrdinalIgnoreCase))
                     {
@@ -180,7 +179,7 @@ private bool CheckForHardcodedSTARequirement()
         /// <summary>
         /// Assembly-qualified names for properties. Only has a value if this type was loaded using MetadataLoadContext.
         /// </summary>
-        internal string[] PropertyAssemblyQualifiedNames { get; private set; }
+        internal string[]? PropertyAssemblyQualifiedNames { get; private set; }
 
         /// <summary>
         /// Gets the assembly the type was loaded from.
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index 25094e59035..0b85b05bacd 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.IO;
+using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Shared
 {
@@ -42,5 +43,11 @@ internal static string GetPlatformSpecificPipeName(string pipeName)
                 return pipeName;
             }
         }
+
+        internal static string GetRarNodePipeName(ServerNodeHandshake handshake)
+            => GetPlatformSpecificPipeName($"MSBuildRarNode-{handshake.ComputeHash()}");
+
+        internal static string GetRarNodeEndpointPipeName(ServerNodeHandshake handshake)
+            => GetPlatformSpecificPipeName($"MSBuildRarNodeEndpoint-{handshake.ComputeHash()}");
     }
 }
diff --git a/src/Shared/NodePacketFactory.cs b/src/Shared/NodePacketFactory.cs
index 214ddfa20f9..478c88310eb 100644
--- a/src/Shared/NodePacketFactory.cs
+++ b/src/Shared/NodePacketFactory.cs
@@ -55,7 +55,22 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
                 ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packetType);
             }
 
-            record.DeserializeAndRoutePacket(nodeId, translator);
+            INodePacket packet = record.DeserializePacket(translator);
+            record.RoutePacket(nodeId, packet);
+        }
+
+        /// <summary>
+        /// Creates a packet with data from a binary stream.
+        /// </summary>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            // PERF: Not using VerifyThrow to avoid boxing of packetType in the non-error case
+            if (!_packetFactories.TryGetValue(packetType, out PacketFactoryRecord record))
+            {
+                ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packetType);
+            }
+
+            return record.DeserializePacket(translator);
         }
 
         /// <summary>
@@ -63,7 +78,12 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
         /// </summary>
         public void RoutePacket(int nodeId, INodePacket packet)
         {
-            PacketFactoryRecord record = _packetFactories[packet.Type];
+            // PERF: Not using VerifyThrow to avoid boxing of packetType in the non-error case
+            if (!_packetFactories.TryGetValue(packet.Type, out PacketFactoryRecord record))
+            {
+                ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packet.Type);
+            }
+
             record.RoutePacket(nodeId, packet);
         }
 
@@ -77,12 +97,12 @@ private class PacketFactoryRecord
             /// <summary>
             /// The handler to invoke when the packet is deserialized.
             /// </summary>
-            private INodePacketHandler _handler;
+            private readonly INodePacketHandler _handler;
 
             /// <summary>
             /// The method used to construct a packet from a translator stream.
             /// </summary>
-            private NodePacketFactoryMethod _factoryMethod;
+            private readonly NodePacketFactoryMethod _factoryMethod;
 
             /// <summary>
             /// Constructor.
@@ -94,21 +114,14 @@ public PacketFactoryRecord(INodePacketHandler handler, NodePacketFactoryMethod f
             }
 
             /// <summary>
-            /// Creates a packet from a binary stream and sends it to the registered handler.
+            /// Creates a packet from a binary stream.
             /// </summary>
-            public void DeserializeAndRoutePacket(int nodeId, ITranslator translator)
-            {
-                INodePacket packet = _factoryMethod(translator);
-                RoutePacket(nodeId, packet);
-            }
+            public INodePacket DeserializePacket(ITranslator translator) => _factoryMethod(translator);
 
             /// <summary>
             /// Routes the packet to the correct destination.
             /// </summary>
-            public void RoutePacket(int nodeId, INodePacket packet)
-            {
-                _handler.PacketReceived(nodeId, packet);
-            }
+            public void RoutePacket(int nodeId, INodePacket packet) => _handler.PacketReceived(nodeId, packet);
         }
     }
 }
diff --git a/src/Shared/NodePipeBase.cs b/src/Shared/NodePipeBase.cs
index fd1d08efe9c..2ee91e536c1 100644
--- a/src/Shared/NodePipeBase.cs
+++ b/src/Shared/NodePipeBase.cs
@@ -69,6 +69,14 @@ protected NodePipeBase(string pipeName, Handshake handshake)
             _writeTranslator = BinaryTranslator.GetWriteTranslator(_writeBuffer);
         }
 
+        /// <summary>
+        /// Gets a value indicating whether the pipe is in the connected state. Note that this is not real-time and
+        /// will only be updated when an operation on the pipe fails.
+        /// When a pipe is broken, Disconnect() must be called for the pipe to be reused - otherwise any attempts to
+        /// connect to a new client will throw.
+        /// </summary>
+        internal bool IsConnected => NodeStream.IsConnected;
+
         protected abstract PipeStream NodeStream { get; }
 
         protected string PipeName { get; }
diff --git a/src/Shared/NodePipeClient.cs b/src/Shared/NodePipeClient.cs
index 6585a2558e7..a521f4f34d2 100644
--- a/src/Shared/NodePipeClient.cs
+++ b/src/Shared/NodePipeClient.cs
@@ -84,7 +84,11 @@ private void PerformHandshake(int timeout)
             _pipeClient.WriteEndOfHandshakeSignal();
 
             CommunicationsUtilities.Trace("Reading handshake from pipe {0}", PipeName);
+#if NET
             _pipeClient.ReadEndOfHandshakeSignal(true, timeout);
+#else
+            _pipeClient.ReadEndOfHandshakeSignal(true);
+#endif
         }
     }
 }
diff --git a/src/Shared/NodePipeServer.cs b/src/Shared/NodePipeServer.cs
index dde8e2ee371..0b9855f2a1c 100644
--- a/src/Shared/NodePipeServer.cs
+++ b/src/Shared/NodePipeServer.cs
@@ -25,11 +25,13 @@ internal sealed class NodePipeServer : NodePipeBase
         /// </summary>
         private const int PipeBufferSize = 131_072;
 
+#if NET
         /// <summary>
         /// A timeout for the handshake. This is only used on Unix-like socket implementations, because the
         /// timeout on the PipeStream connection is ignore.
         /// </summary>
         private static readonly int s_handshakeTimeout = NativeMethodsShared.IsWindows ? 0 : 60_000;
+#endif
 
         private readonly NamedPipeServerStream _pipeServer;
 
@@ -45,7 +47,14 @@ internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfSer
             // SIDs or the client will reject this server.  This is used to avoid attacks where a
             // hacked server creates a less restricted pipe in an attempt to lure us into using it and
             // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);
+            PipeAccessRights pipeAccessRights = PipeAccessRights.ReadWrite;
+            if (maxNumberOfServerInstances > 1)
+            {
+                // Multi-instance pipes will fail without this flag.
+                pipeAccessRights |= PipeAccessRights.CreateNewInstance;
+            }
+
+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, pipeAccessRights, AccessControlType.Allow);
             PipeSecurity security = new();
             security.AddAccessRule(rule);
             security.SetOwner(rule.IdentityReference);
@@ -179,7 +188,11 @@ private bool ValidateHandshake()
             for (int i = 0; i < HandshakeComponents.Length; i++)
             {
                 // This will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard.
+#if NET
                 int handshakePart = _pipeServer.ReadIntForHandshake(byteToAccept: i == 0 ? CommunicationsUtilities.handshakeVersion : null, s_handshakeTimeout);
+#else
+                int handshakePart = _pipeServer.ReadIntForHandshake(byteToAccept: i == 0 ? CommunicationsUtilities.handshakeVersion : null);
+#endif
 
                 if (handshakePart != HandshakeComponents[i])
                 {
@@ -190,7 +203,11 @@ private bool ValidateHandshake()
             }
 
             // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
+#if NET
             _pipeServer.ReadEndOfHandshakeSignal(false, s_handshakeTimeout);
+#else
+            _pipeServer.ReadEndOfHandshakeSignal(false);
+#endif
 
             CommunicationsUtilities.Trace("Successfully connected to parent.");
             _pipeServer.WriteEndOfHandshakeSignal();
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index 7ff74c83f19..9d1ccedb342 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -8,9 +8,6 @@
 #endif
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
-using System.ComponentModel;
-
-#nullable disable
 
 #if BUILDINGAPPXTASKS
 namespace Microsoft.Build.AppxPackage.Shared
@@ -36,7 +33,7 @@ internal static class ResourceUtilities
         /// <param name="code">[out] The message code, or null if there was no code.</param>
         /// <returns>The string without its message code prefix, if any.</returns>
         [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope = "member", Target = "Microsoft.Build.Shared.ResourceUtilities.#ExtractMessageCode(System.Boolean,System.String,System.String&)", Justification = "Unavoidable complexity")]
-        internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, out string code)
+        internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, out string? code)
         {
 #if !BUILDINGAPPXTASKS
             ErrorUtilities.VerifyThrowInternalNull(message);
@@ -159,7 +156,7 @@ internal static string GetResourceString(string resourceName)
         /// <param name="resourceName">Resource string to load.</param>
         /// <param name="args">Optional arguments for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, params object[] args)
+        internal static string FormatResourceStringStripCodeAndKeyword(out string? code, out string? helpKeyword, string resourceName, params object?[]? args)
         {
             helpKeyword = GetHelpKeyword(resourceName);
 
@@ -178,7 +175,7 @@ internal static string FormatResourceStringStripCodeAndKeyword(out string code,
         /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
         /// <param name="resourceName">Resource string to load.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName)
+        internal static string FormatResourceStringStripCodeAndKeyword(out string? code, out string? helpKeyword, string resourceName)
         {
             helpKeyword = GetHelpKeyword(resourceName);
             return ExtractMessageCode(true, GetResourceString(resourceName), out code);
@@ -192,7 +189,7 @@ internal static string FormatResourceStringStripCodeAndKeyword(out string code,
         /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
         /// <param name="resourceName">Resource string to load.</param>
         /// <param name="arg1">Argument for formatting the resource string.</param>
-        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1)
+        internal static string FormatResourceStringStripCodeAndKeyword(out string? code, out string? helpKeyword, string resourceName, object? arg1)
         {
             helpKeyword = GetHelpKeyword(resourceName);
             return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1), out code);
@@ -207,7 +204,7 @@ internal static string FormatResourceStringStripCodeAndKeyword(out string code,
         /// <param name="resourceName">Resource string to load.</param>
         /// <param name="arg1">First argument for formatting the resource string.</param>
         /// <param name="arg2">Second argument for formatting the resource string.</param>
-        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1, object arg2)
+        internal static string FormatResourceStringStripCodeAndKeyword(out string? code, out string? helpKeyword, string resourceName, object? arg1, object? arg2)
         {
             helpKeyword = GetHelpKeyword(resourceName);
             return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1, arg2), out code);
@@ -223,19 +220,12 @@ internal static string FormatResourceStringStripCodeAndKeyword(out string code,
         /// <param name="arg1">First argument for formatting the resource string.</param>
         /// <param name="arg2">Second argument for formatting the resource string.</param>
         /// <param name="arg3">Third argument for formatting the resource string.</param>
-        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1, object arg2, object arg3)
+        internal static string FormatResourceStringStripCodeAndKeyword(out string? code, out string? helpKeyword, string resourceName, object? arg1, object? arg2, object? arg3)
         {
             helpKeyword = GetHelpKeyword(resourceName);
             return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1, arg2, arg3), out code);
         }
 
-        [Obsolete("Use GetResourceString instead.", true)]
-        [EditorBrowsable(EditorBrowsableState.Never)]
-        internal static string FormatResourceString(string resourceName)
-        {   // Avoids an accidental dependency on FormatResourceString(string, params object[])
-            return null;
-        }
-
         /// <summary>
         /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they are discarded.
@@ -247,7 +237,7 @@ internal static string FormatResourceString(string resourceName)
         /// <param name="resourceName">Resource string to load.</param>
         /// <param name="args">Optional arguments for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, params object[] args)
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, params object?[]? args)
             => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, args);
 
         // Overloads with 0-3 arguments to avoid array allocations.
@@ -270,7 +260,7 @@ internal static string FormatResourceStringStripCodeAndKeyword(string resourceNa
         /// <param name="resourceName">Resource string to load.</param>
         /// <param name="arg1">Argument for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1)
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object? arg1)
            => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1);
 
         /// <summary>
@@ -282,7 +272,7 @@ internal static string FormatResourceStringStripCodeAndKeyword(string resourceNa
         /// <param name="arg1">First argument for formatting the resource string.</param>
         /// <param name="arg2">Second argument for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1, object arg2)
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object? arg1, object? arg2)
             => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1, arg2);
 
         /// <summary>
@@ -295,7 +285,7 @@ internal static string FormatResourceStringStripCodeAndKeyword(string resourceNa
         /// <param name="arg2">Second argument for formatting the resource string.</param>
         /// <param name="arg3">Third argument for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1, object arg2, object arg3)
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object? arg1, object? arg2, object? arg3)
             => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1, arg2, arg3);
 
         /// <summary>
@@ -306,7 +296,7 @@ internal static string FormatResourceStringStripCodeAndKeyword(string resourceNa
         /// <param name="args">Optional arguments for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
         /// <remarks>the AssemblyResources.GetString() method is thread-safe.</remarks>
-        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, params object[] args)
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, params object?[]? args)
             => FormatString(GetResourceString(resourceName), args);
 
         // Overloads with 0-3 arguments to avoid array allocations.
@@ -327,7 +317,7 @@ internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceN
         /// <param name="resourceName">Resource string to load.</param>
         /// <param name="arg1">Argument for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1)
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object? arg1)
             => FormatString(GetResourceString(resourceName), arg1);
 
         /// <summary>
@@ -338,7 +328,7 @@ internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceN
         /// <param name="arg1">First argument for formatting the resource string.</param>
         /// <param name="arg2">Second argument for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1, object arg2)
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object? arg1, object? arg2)
             => FormatString(GetResourceString(resourceName), arg1, arg2);
 
         /// <summary>
@@ -350,7 +340,7 @@ internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceN
         /// <param name="arg2">Second argument for formatting the resource string.</param>
         /// <param name="arg3">Third argument for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
-        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1, object arg2, object arg3)
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object? arg1, object? arg2, object? arg3)
             => FormatString(GetResourceString(resourceName), arg1, arg2, arg3);
 
         /// <summary>
@@ -364,7 +354,7 @@ internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceN
         /// <param name="unformatted">The string to format.</param>
         /// <param name="args">Optional arguments for formatting the given string.</param>
         /// <returns>The formatted string.</returns>
-        internal static string FormatString(string unformatted, params object[] args)
+        internal static string FormatString(string unformatted, params object?[]? args)
         {
             string formatted = unformatted;
 
@@ -389,7 +379,7 @@ internal static string FormatString(string unformatted, params object[] args)
         /// <param name="unformatted">The string to format.</param>
         /// <param name="arg1">Argument for formatting the given string.</param>
         /// <returns>The formatted string.</returns>
-        internal static string FormatString(string unformatted, object arg1)
+        internal static string FormatString(string unformatted, object? arg1)
         {
             ValidateArgsIfDebug([arg1]);
             return string.Format(CultureInfo.CurrentCulture, unformatted, arg1);
@@ -402,7 +392,7 @@ internal static string FormatString(string unformatted, object arg1)
         /// <param name="arg1">First argument for formatting the given string.</param>
         /// <param name="arg2">Second argument for formatting the given string.</param>
         /// <returns>The formatted string.</returns>
-        internal static string FormatString(string unformatted, object arg1, object arg2)
+        internal static string FormatString(string unformatted, object? arg1, object? arg2)
         {
             ValidateArgsIfDebug([arg1, arg2]);
             return string.Format(CultureInfo.CurrentCulture, unformatted, arg1, arg2);
@@ -416,18 +406,18 @@ internal static string FormatString(string unformatted, object arg1, object arg2
         /// <param name="arg2">Second argument for formatting the given string.</param>
         /// <param name="arg3">Third argument for formatting the given string.</param>
         /// <returns>The formatted string.</returns>
-        internal static string FormatString(string unformatted, object arg1, object arg2, object arg3)
+        internal static string FormatString(string unformatted, object? arg1, object? arg2, object? arg3)
         {
             ValidateArgsIfDebug([arg1, arg2, arg3]);
             return string.Format(CultureInfo.CurrentCulture, unformatted, arg1, arg2, arg3);
         }
 
         [Conditional("DEBUG")]
-        private static void ValidateArgsIfDebug(object[] args)
+        private static void ValidateArgsIfDebug(object?[] args)
         {
             // If you accidentally pass some random type in that can't be converted to a string,
             // FormatResourceString calls ToString() which returns the full name of the type!
-            foreach (object param in args)
+            foreach (object? param in args)
             {
                 // Check it has a real implementation of ToString() and the type is not actually System.String
                 if (param != null)
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index ea170a16a08..602a36871ed 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -5,8 +5,6 @@
 using System.Reflection;
 using Microsoft.Build.Framework;
 
-#nullable disable
-
 namespace Microsoft.Build.Shared
 {
     /// <summary>
@@ -19,7 +17,7 @@ internal static class TaskLoader
         /// For saving the assembly that was loaded by the TypeLoader
         /// We only use this when the assembly failed to load properly into the appdomain
         /// </summary>
-        private static LoadedType s_resolverLoadedType;
+        private static LoadedType? s_resolverLoadedType;
 #endif
 
         /// <summary>
@@ -42,7 +40,7 @@ internal static bool IsTaskClass(Type type, object unused)
         /// Creates an ITask instance and returns it.
         /// </summary>
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-        internal static ITask CreateTask(
+        internal static ITask? CreateTask(
             LoadedType loadedType,
             string taskName,
             string taskLocation,
@@ -55,7 +53,7 @@ internal static ITask CreateTask(
 #endif
             bool isOutOfProc
 #if FEATURE_APPDOMAIN
-            , out AppDomain taskAppDomain
+            , out AppDomain? taskAppDomain
 #endif
             )
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
@@ -64,7 +62,7 @@ bool isOutOfProc
             bool separateAppDomain = loadedType.HasLoadInSeparateAppDomainAttribute;
             s_resolverLoadedType = null;
             taskAppDomain = null;
-            ITask taskInstanceInOtherAppDomain = null;
+            ITask? taskInstanceInOtherAppDomain = null;
 #endif
 
             try
@@ -126,7 +124,7 @@ bool isOutOfProc
                 {
                     // perf improvement for the same appdomain case - we already have the type object
                     // and don't want to go through reflection to recreate it from the name.
-                    return (ITask)Activator.CreateInstance(loadedType.Type);
+                    return (ITask?)Activator.CreateInstance(loadedType.Type);
                 }
 
 #if FEATURE_APPDOMAIN
@@ -158,7 +156,7 @@ bool isOutOfProc
                     taskInstanceInOtherAppDomain = (ITask)taskAppDomain.CreateInstanceAndUnwrap(loadedType.Type.GetTypeInfo().Assembly.FullName, loadedType.Type.FullName);
                 }
 
-                return taskInstanceInOtherAppDomain;
+                return  taskInstanceInOtherAppDomain;
 #endif
             }
             finally
@@ -179,10 +177,14 @@ bool isOutOfProc
         /// This is a resolver to help created AppDomains when they are unable to load an assembly into their domain we will help
         /// them succeed by providing the already loaded one in the currentdomain so that they can derive AssemblyName info from it
         /// </summary>
-        internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
+        internal static Assembly? AssemblyResolver(object sender, ResolveEventArgs args)
         {
-            if (args.Name.Equals(s_resolverLoadedType.LoadedAssemblyName.FullName, StringComparison.OrdinalIgnoreCase))
+            if (args.Name.Equals(s_resolverLoadedType?.LoadedAssemblyName?.FullName, StringComparison.OrdinalIgnoreCase))
             {
+                if (s_resolverLoadedType == null || s_resolverLoadedType.Path == null)
+                {
+                    return null;
+                }
                 return s_resolverLoadedType.LoadedAssembly ?? Assembly.Load(s_resolverLoadedType.Path);
             }
 
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 3b6265ca4d9..2e397ebab7b 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -997,6 +997,7 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 return EnumerateMetadataLazy();
             }
 
+#if FEATURE_APPDOMAIN
             private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
             {
                 if (_customEscapedMetadata == null || _customEscapedMetadata.Count == 0)
@@ -1014,6 +1015,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
 
                 return result;
             }
+#endif
 
             private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataLazy()
             {
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index 2835756fa6c..b3c6a5573bd 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -89,6 +89,68 @@ public static void TranslateDictionary<T>(
             translator.TranslateDictionary(ref dictionary, comparer, AdaptFactory(valueFactory));
         }
 
+        public static void InternDictionary(
+            this ITranslator translator,
+            ref Dictionary<string, string> dictionary,
+            IEqualityComparer<string> comparer)
+        {
+            IDictionary<string, string> localDict = dictionary;
+            translator.TranslateDictionary(
+                ref localDict,
+                (ITranslator translator, ref string key) => translator.Intern(ref key),
+                (ITranslator translator, ref string val) => translator.Intern(ref val),
+                capacity => new Dictionary<string, string>(capacity, comparer));
+            dictionary = (Dictionary<string, string>)localDict;
+        }
+
+        public static void InternDictionary<T>(
+            this ITranslator translator,
+            ref Dictionary<string, T> dictionary,
+            IEqualityComparer<string> stringComparer,
+            NodePacketValueFactory<T> valueFactory)
+            where T : ITranslatable
+        {
+            IDictionary<string, T> localDict = dictionary;
+            translator.TranslateDictionary(
+                ref localDict,
+                (ITranslator translator, ref string key) => translator.Intern(ref key),
+                AdaptFactory(valueFactory),
+                capacity => new Dictionary<string, T>(capacity, stringComparer));
+            dictionary = (Dictionary<string, T>)localDict;
+        }
+
+        public static void InternPathDictionary(
+            this ITranslator translator,
+            ref Dictionary<string, string> dictionary,
+            IEqualityComparer<string> comparer)
+        {
+            IDictionary<string, string> localDict = dictionary;
+
+            // For now, assume only the value contains path-like strings (e.g. TaskItem metadata).
+            translator.TranslateDictionary(
+                ref localDict,
+                (ITranslator translator, ref string key) => translator.Intern(ref key),
+                (ITranslator translator, ref string val) => translator.InternPath(ref val),
+                capacity => new Dictionary<string, string>(capacity, comparer));
+            dictionary = (Dictionary<string, string>)localDict;
+        }
+
+        public static void InternPathDictionary<T>(
+            this ITranslator translator,
+            ref Dictionary<string, T> dictionary,
+            IEqualityComparer<string> stringComparer,
+            NodePacketValueFactory<T> valueFactory)
+            where T : ITranslatable
+        {
+            IDictionary<string, T> localDict = dictionary;
+            translator.TranslateDictionary(
+                ref localDict,
+                (ITranslator translator, ref string key) => translator.InternPath(ref key),
+                AdaptFactory(valueFactory),
+                capacity => new Dictionary<string, T>(capacity, stringComparer));
+            dictionary = (Dictionary<string, T>)localDict;
+        }
+
         public static void TranslateDictionary<D, T>(
             this ITranslator translator,
             ref D dictionary,
diff --git a/src/StringTools.UnitTests/WeakStringCache_Tests.cs b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
index 95c769a5fa7..29e51267c1c 100644
--- a/src/StringTools.UnitTests/WeakStringCache_Tests.cs
+++ b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
@@ -86,7 +86,7 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
 
             for (int i = 0; i < numberOfStrings; i++)
             {
-                string strPart2 = string.Concat(Enumerable.Repeat("100570862200", i + 2));
+                string strPart2 = string.Concat(Enumerable.Repeat("100570862200", i + 100));
                 hashCodes[i] = AddString(string.Empty, strPart2, (string cachedString) =>
                 {
                     _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
@@ -124,7 +124,7 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
         public void RetainsStringUntilCollected()
         {
             // Add a string to the cache using a non-inlinable method to make sure it's not reachable from a GC root.
-            AddString("Random string ", "test", (string cachedString) =>
+            AddString(new string('r', 500), "test", (string cachedString) =>
             {
                 _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
                 {
diff --git a/src/StringTools/StringTools.cs b/src/StringTools/StringTools.cs
index 93b06619b5d..0ee22092369 100644
--- a/src/StringTools/StringTools.cs
+++ b/src/StringTools/StringTools.cs
@@ -92,6 +92,11 @@ public static string CreateDiagnosticReport()
             return WeakStringCacheInterner.Instance.FormatStatistics();
         }
 
+        public static void ClearCachedStrings()
+        {
+            WeakStringCacheInterner.Instance.Dispose();
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/StringTools/WeakStringCache.cs b/src/StringTools/WeakStringCache.cs
index 5e3434fd4ef..5517e1478cc 100644
--- a/src/StringTools/WeakStringCache.cs
+++ b/src/StringTools/WeakStringCache.cs
@@ -35,10 +35,15 @@ private class StringWeakHandle
             /// </summary>
             public GCHandle WeakHandle;
 
+            /// <summary>
+            /// Reference used for smaller strings retained by the cache.
+            /// </summary>
+            private string? referencedString;
+
             /// <summary>
             /// Returns true if the string referenced by the handle is still alive.
             /// </summary>
-            public bool IsUsed => WeakHandle.Target != null;
+            public bool IsUsed => referencedString is not null || WeakHandle.Target != null;
 
             /// <summary>
             /// Returns the string referenced by this handle if it is equal to the given internable.
@@ -47,13 +52,26 @@ private class StringWeakHandle
             /// <returns>The string matching the internable or null if the handle is referencing a collected string or the string is different.</returns>
             public string? GetString(ref InternableString internable)
             {
-                if (WeakHandle.IsAllocated && WeakHandle.Target is string str)
+                if (referencedString is not null && internable.Equals(referencedString))
                 {
-                    if (internable.Equals(str))
-                    {
-                        return str;
-                    }
+                    return referencedString;
+                }
+
+                if (!WeakHandle.IsAllocated)
+                {
+                    return null;
+                }
+
+                if (WeakHandle.Target is not string str)
+                {
+                    return null;
                 }
+
+                if (internable.Equals(str))
+                {
+                    return str;
+                }
+
                 return null;
             }
 
@@ -63,14 +81,28 @@ private class StringWeakHandle
             /// <param name="str">The string to set.</param>
             public void SetString(string str)
             {
-                if (!WeakHandle.IsAllocated)
+                const int stringLengthLimit = 500;
+                if (str.Length > stringLengthLimit)
                 {
-                    // The handle is not allocated - allocate it.
-                    WeakHandle = GCHandle.Alloc(str, GCHandleType.Weak);
+                    if (WeakHandle.IsAllocated)
+                    {
+                        WeakHandle.Target = str;
+                    }
+                    else
+                    {
+                        WeakHandle = GCHandle.Alloc(str, GCHandleType.Weak);
+                    }
+
+                    referencedString = null;
                 }
                 else
                 {
-                    WeakHandle.Target = str;
+                    if (WeakHandle.IsAllocated)
+                    {
+                        WeakHandle.Target = null;
+                    }
+
+                    referencedString = str;
                 }
             }
 
@@ -79,7 +111,10 @@ public void SetString(string str)
             /// </summary>
             public void Free()
             {
-                WeakHandle.Free();
+                if (WeakHandle.IsAllocated)
+                {
+                    WeakHandle.Free();
+                }
             }
         }
 
@@ -106,12 +141,6 @@ private void DisposeImpl()
         }
 
         public void Dispose()
-        {
-            DisposeImpl();
-            GC.SuppressFinalize(this);
-        }
-
-        ~WeakStringCache()
         {
             DisposeImpl();
         }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
index 85700054f33..f320ee47e70 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
@@ -940,13 +940,10 @@ private static IEnumerable<AssemblyNameExtension> MockAssemblyCacheEnumerator(st
         internal sealed class MockEnumerator : IEnumerable<AssemblyNameExtension>
         {
             private List<string> _assembliesToEnumerate = null;
-            private List<string>.Enumerator _enumerator;
 
             public MockEnumerator(List<string> assembliesToEnumerate)
             {
                 _assembliesToEnumerate = assembliesToEnumerate;
-
-                _enumerator = assembliesToEnumerate.GetEnumerator();
             }
 
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 576145d5cd5..eacd689668d 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3268,41 +3268,6 @@ public void ParentAssemblyResolvedFromAForGac()
             Assert.Equal(reference2.ResolvedSearchPath, parentReferenceFolders[0].Directory);
         }
 
-        /// <summary>
-        /// Generate a fake reference which has been resolved from the gac. We will use it to verify the creation of the exclusion list.
-        /// </summary>
-        /// <returns></returns>
-        private ReferenceTable GenerateTableWithAssemblyFromTheGlobalLocation(string location)
-        {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
-#if FEATURE_WIN32_REGISTRY
-                null, null, null,
-#endif
-                null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
-
-            AssemblyNameExtension assemblyNameExtension = new AssemblyNameExtension(new AssemblyName("Microsoft.VisualStudio.Interopt, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"));
-            TaskItem taskItem = new TaskItem("Microsoft.VisualStudio.Interopt, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
-
-            Reference reference = new Reference(isWinMDFile, fileExists, getRuntimeVersion);
-            reference.MakePrimaryAssemblyReference(taskItem, false, ".dll");
-            // "Resolve the assembly from the gac"
-            reference.FullPath = "c:\\Microsoft.VisualStudio.Interopt.dll";
-            reference.ResolvedSearchPath = location;
-            referenceTable.AddReference(assemblyNameExtension, reference);
-
-            assemblyNameExtension = new AssemblyNameExtension(new AssemblyName("Team.System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"));
-            taskItem = new TaskItem("Team, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
-
-            reference = new Reference(isWinMDFile, fileExists, getRuntimeVersion);
-            reference.MakePrimaryAssemblyReference(taskItem, false, ".dll");
-
-            // "Resolve the assembly from the gac"
-            reference.FullPath = "c:\\Team.System.dll";
-            reference.ResolvedSearchPath = location;
-            referenceTable.AddReference(assemblyNameExtension, reference);
-            return referenceTable;
-        }
-
         /// <summary>
         /// Given a reference that resolves to a bad image, we should get a warning and
         /// no reference. We don't want an exception.
@@ -6734,11 +6699,11 @@ public void ReferenceTableDependentItemsInDenyList3()
         [Fact]
         public void ReferenceTableDependentItemsInDenyList4()
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
-                null, null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
+                null, null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null, Array.Empty<string>());
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
             Dictionary<string, string> denyList;
@@ -6912,11 +6877,11 @@ public void ReferenceTableDependentItemsInDenyListPrimaryWithSpecificVersion()
 
         private static ReferenceTable MakeEmptyReferenceTable(TaskLoggingHelper log)
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
-                null, null, new Version("4.0"), null, log, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
+                null, null, new Version("4.0"), null, log, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null, Array.Empty<string>());
             return referenceTable;
         }
 
@@ -7434,77 +7399,6 @@ public void ResolveAssemblyReferenceVerifyFullClientNameNoTablesPassedIn()
             }
         }
 
-        /// <summary>
-        /// Verify the correct references are still in the references table and that references which are in the deny list are not in the references table
-        /// Also verify any expected warning messages are seen in the log.
-        /// </summary>
-        private static void VerifyReferenceTable(ReferenceTable referenceTable, MockEngine mockEngine, AssemblyNameExtension engineAssemblyName, AssemblyNameExtension dataAssemblyName, AssemblyNameExtension sqlclientAssemblyName, AssemblyNameExtension xmlAssemblyName, string warningMessage, string warningMessage2)
-        {
-            IDictionary<AssemblyNameExtension, Reference> table = referenceTable.References;
-            Assert.Equal(3, table.Count); // "Expected there to be three elements in the dictionary"
-            Assert.False(table.ContainsKey(sqlclientAssemblyName)); // "Expected to not find the sqlclientAssemblyName in the referenceList"
-            Assert.True(table.ContainsKey(xmlAssemblyName)); // "Expected to find the xmlssemblyName in the referenceList"
-            Assert.True(table.ContainsKey(dataAssemblyName)); // "Expected to find the dataAssemblyName in the referenceList"
-            Assert.True(table.ContainsKey(engineAssemblyName)); // "Expected to find the engineAssemblyName in the referenceList"
-            if (warningMessage != null)
-            {
-                mockEngine.AssertLogContains(warningMessage);
-            }
-            if (warningMessage2 != null)
-            {
-                mockEngine.AssertLogContains(warningMessage2);
-            }
-            table.Clear();
-        }
-
-        /// <summary>
-        /// Generate helper delegates for returning the file existence and the assembly name.
-        /// Also run the rest and return the result.
-        /// </summary>
-        private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t)
-        {
-            FileExists cachedFileExists = fileExists;
-            GetAssemblyName cachedGetAssemblyName = getAssemblyName;
-            string microsoftBuildEnginePath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\Microsoft.Build.Engine.dll");
-            string systemXmlPath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\System.Xml.dll");
-            fileExists = new FileExists(delegate (string path)
-{
-    if (String.Equals(path, microsoftBuildEnginePath, StringComparison.OrdinalIgnoreCase) ||
-                    String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase) ||
-                    path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-    {
-        return true;
-    }
-    return false;
-});
-
-            getAssemblyName = new GetAssemblyName(delegate (string path)
-            {
-                if (String.Equals(path, microsoftBuildEnginePath, StringComparison.OrdinalIgnoreCase))
-                {
-                    return new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
-                }
-                else if (String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase))
-                {
-                    return new AssemblyNameExtension("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
-                }
-
-                return null;
-            });
-
-            bool success;
-            try
-            {
-                success = Execute(t);
-            }
-            finally
-            {
-                fileExists = cachedFileExists;
-                getAssemblyName = cachedGetAssemblyName;
-            }
-            return success;
-        }
-
         [Fact]
         public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()
         {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index ddfb1bd9c4f..e6b39fd0e94 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2506,6 +2506,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             };
         }
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Registry access delegate. Given a hive and a view, return the registry base key.
         /// </summary>
@@ -2910,6 +2911,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
             Assert.Fail($"New GetRegistrySubKeyDefaultValue parameters encountered, need to add unittesting support for subKey={subKey}");
             return null;
         }
+#endif
 
         /// <summary>
         /// Delegate for System.IO.File.GetLastWriteTime
diff --git a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
index 23adb6a34b1..e86f7cd868a 100644
--- a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
@@ -281,22 +281,6 @@ private static void AssertTokenize(
             AssertTokenize(source, source, expectedTokenKey, expectedLastLineNumber);
         }
 
-        /*
-        * Method:  AssertTokenizeUnicode
-        *
-        * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated
-        * back together,
-        */
-        private static void AssertTokenizeUnicode(
-           string source,
-           string expectedTokenKey,
-           int expectedLastLineNumber)
-        {
-            // Most of the time, we expect the rebuilt source to be the same as the input source.
-            AssertTokenizeUnicode(source, source, expectedTokenKey, expectedLastLineNumber);
-        }
-
         /*
         * Method:  AssertTokenize
         *
diff --git a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
index 8630c8025fb..ec790f6ec35 100644
--- a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
+++ b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
@@ -262,64 +262,6 @@ public void FaultInjectionMainLib()
             }
         }
 
-        private static void CreateFaultInjectionTypeLibs(MockTypeLibrariesFailurePoints failurePoint, out MockTypeLib mainTypeLib,
-            out MockTypeLib dependencyTypeLibGood1, out MockTypeLib dependencyTypeLibBad1,
-            out MockTypeLib dependencyTypeLibGood2, out MockTypeLib dependencyTypeLibBad2)
-        {
-            mainTypeLib = new MockTypeLib();
-            mainTypeLib.AddTypeInfo(new MockTypeInfo());
-            mainTypeLib.AddTypeInfo(new MockTypeInfo());
-
-            dependencyTypeLibGood1 = new MockTypeLib();
-            dependencyTypeLibGood1.AddTypeInfo(new MockTypeInfo());
-
-            // Make it the StdOle lib to exercise the ITypeInfo.GetDocumentation failure point
-            dependencyTypeLibBad1 = new MockTypeLib(NativeMethods.IID_StdOle);
-            dependencyTypeLibBad1.AddTypeInfo(new MockTypeInfo());
-
-            dependencyTypeLibGood2 = new MockTypeLib();
-            dependencyTypeLibGood2.AddTypeInfo(new MockTypeInfo());
-
-            // Make it the StdOle lib to exercise the ITypeInfo.GetDocumentation failure point
-            dependencyTypeLibBad2 = new MockTypeLib(NativeMethods.IID_StdOle);
-            dependencyTypeLibBad2.AddTypeInfo(new MockTypeInfo());
-
-            COMException failureException = new COMException("unhandled exception in " + failurePoint.ToString());
-
-            dependencyTypeLibBad1.InjectFailure(failurePoint, failureException);
-            dependencyTypeLibBad2.InjectFailure(failurePoint, failureException);
-        }
-
-        private void RunDependencyWalkerFaultInjection(MockTypeLibrariesFailurePoints failurePoint, MockTypeLib mainTypeLib, MockTypeLib dependencyTypeLibGood1, MockTypeLib dependencyTypeLibBad1, MockTypeLib dependencyTypeLibGood2, MockTypeLib dependencyTypeLibBad2)
-        {
-            ComDependencyWalker walker = new ComDependencyWalker(new MarshalReleaseComObject(MockReleaseComObject));
-            walker.AnalyzeTypeLibrary(mainTypeLib);
-
-            // Did the current failure point get hit for this test? If not then no point in checking anything
-            // The previous test (FaultInjectionMainLib) ensures that all defined failure points actually
-            // cause some sort of trouble
-            if (walker.EncounteredProblems.Count > 0)
-            {
-                TYPELIBATTR[] dependencies = walker.GetDependencies();
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, mainTypeLib, true);
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, dependencyTypeLibGood1, true);
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, dependencyTypeLibGood2, true);
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, dependencyTypeLibBad1, false);
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, dependencyTypeLibBad2, false);
-            }
-
-            mainTypeLib.AssertAllHandlesReleased();
-            dependencyTypeLibGood1.AssertAllHandlesReleased();
-            dependencyTypeLibGood2.AssertAllHandlesReleased();
-            dependencyTypeLibBad1.AssertAllHandlesReleased();
-            dependencyTypeLibBad2.AssertAllHandlesReleased();
-        }
-
         [Fact]
         public void FullDependenciesWithIncrementalAnalysis()
         {
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index 70ec1fb1452..567eea82ab6 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -665,21 +665,5 @@ public void ResourcesFileWithRootNamespace()
 
             Assert.Equal(@"RootNamespace.MyResource.resources", result);
         }
-
-        private void AssertSimpleCase(string code, string expected)
-        {
-            string result =
-            CreateVisualBasicManifestResourceName.CreateManifestNameImpl(
-                    fileName: "MyForm.resx",
-                    linkFileName: null,    // Link file name
-                    prependCultureAsDirectory: true,
-                    rootNamespace: "RootNamespace",    // Root namespace
-                    dependentUponFileName: "MyForm.vb",
-                    culture: null,
-                    binaryStream: StreamHelpers.StringToStream(code),
-                    log: null);
-
-            Assert.Equal(expected, result);
-        }
     }
 }
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 81b5048f0f7..2ff059b2833 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -64,6 +64,9 @@
     <None Include="..\Shared\UnitTests\xunit.runner.json">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <None Include="TestResources\CustomCulture\**">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
     <None Include="TestResources\Projects\Custom_COM\Custom_COM\Class1.cs">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
@@ -155,6 +158,9 @@
     <None Update="TestResources\Manifests\*">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <EmbeddedResource Update="TestResources\CustomCulture\*.resx">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </EmbeddedResource>
     <None Update="TestResources\mycert.pfx">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
diff --git a/src/Tasks.UnitTests/ProjectExtensionsImportTestBase.cs b/src/Tasks.UnitTests/ProjectExtensionsImportTestBase.cs
index 30eae83deae..a681669e73d 100644
--- a/src/Tasks.UnitTests/ProjectExtensionsImportTestBase.cs
+++ b/src/Tasks.UnitTests/ProjectExtensionsImportTestBase.cs
@@ -22,12 +22,13 @@ protected ProjectExtensionsImportTestBase()
             ObjectModelHelpers.DeleteTempProjectDirectory();
         }
 
-        protected virtual string BasicProjectImportContents => $@"
+        protected virtual string BasicProjectImportContents => $"""
             <Project>
                 <PropertyGroup>
                 <{PropertyNameToSignalImportSucceeded}>true</{PropertyNameToSignalImportSucceeded}>
                 </PropertyGroup>
-            </Project>";
+            </Project>
+            """;
 
         protected abstract string CustomImportProjectPath { get; }
         protected abstract string ImportProjectPath { get; }
@@ -53,13 +54,13 @@ public void DoesNotImportProjectIfNotExist()
             // src\Foo\Foo.csproj
             // ---------------------
 
-            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, @"
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, """
                 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
 
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-            "));
+            """));
 
             string projectExtensionsPath = project.GetPropertyValue("MSBuildProjectExtensionsPath");
 
@@ -74,7 +75,7 @@ public void DoesNotImportProjectIfRestoring()
         {
             ObjectModelHelpers.CreateFileInTempProjectDirectory(ImportProjectPath, BasicProjectImportContents);
 
-            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, $@"
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, $"""
                 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <PropertyGroup>
                         <{MSBuildConstants.MSBuildIsRestoring}>true</{MSBuildConstants.MSBuildIsRestoring}>
@@ -84,7 +85,7 @@ public void DoesNotImportProjectIfRestoring()
 
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-            "));
+            """));
 
             string projectExtensionsPath = project.GetPropertyValue("MSBuildProjectExtensionsPath");
 
@@ -99,7 +100,7 @@ public void ImportsProjectIfRestoringAndExplicitlySet()
         {
             ObjectModelHelpers.CreateFileInTempProjectDirectory(ImportProjectPath, BasicProjectImportContents);
 
-            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, $@"
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, $"""
                 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <PropertyGroup>
                         <{PropertyNameToEnableImport}>true</{PropertyNameToEnableImport}>
@@ -110,7 +111,7 @@ public void ImportsProjectIfRestoringAndExplicitlySet()
 
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-            "));
+            """));
 
             string projectExtensionsPath = project.GetPropertyValue("MSBuildProjectExtensionsPath");
 
@@ -135,7 +136,7 @@ public void DoesNotImportProjectWhenDisabled()
             // src\Foo\Foo.csproj
             // ---------------------
 
-            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, $@"
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, $"""
                 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <PropertyGroup>
                         <{PropertyNameToEnableImport}>false</{PropertyNameToEnableImport}>
@@ -145,7 +146,7 @@ public void DoesNotImportProjectWhenDisabled()
 
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-            "));
+            """));
 
             string projectExtensionsDirectory = Path.Combine(ObjectModelHelpers.TempProjectDir, Path.GetDirectoryName(ImportProjectPath));
 
@@ -167,7 +168,7 @@ public void ImportsProjectIfCustomPath()
             // src\Foo\Foo.csproj
             // ---------------------
 
-            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, $@"
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, $"""
                 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <PropertyGroup>
                         <MSBuildProjectExtensionsPath>{Path.GetDirectoryName(CustomImportProjectPath)}</MSBuildProjectExtensionsPath>
@@ -176,7 +177,7 @@ public void ImportsProjectIfCustomPath()
 
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-            "));
+            """));
 
             project.GetPropertyValue(PropertyNameToEnableImport).ShouldBe("true");
             project.GetPropertyValue(PropertyNameToSignalImportSucceeded).ShouldBe("true");
@@ -194,13 +195,13 @@ public void ImportsProjectIfExists()
             // src\Foo\Foo.csproj
             // ---------------------
 
-            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, @"
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, """
                 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
 
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-            "));
+            """));
 
             project.GetPropertyValue(PropertyNameToEnableImport).ShouldBe("true");
             project.GetPropertyValue(PropertyNameToSignalImportSucceeded).ShouldBe("true");
@@ -212,7 +213,7 @@ public void ImportsProjectIfExists()
         [Fact]
         public void ErrorIfChangedInBodyOfProject()
         {
-            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, @"
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, """
                 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
 
@@ -222,7 +223,7 @@ public void ErrorIfChangedInBodyOfProject()
 
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-            "));
+            """));
 
             MockLogger logger = new MockLogger();
 
@@ -238,7 +239,7 @@ public void ErrorIfChangedInBodyOfProject()
         [Fact]
         public void WarningIfBaseIntermediateOutputPathIsChangedInBodyOfProject()
         {
-            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, @"
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath, """
                 <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
 
@@ -249,7 +250,7 @@ public void WarningIfBaseIntermediateOutputPathIsChangedInBodyOfProject()
 
                     <Import Project=`$(MSBuildBinPath)\Microsoft.CSharp.targets` />
                 </Project>
-            "));
+            """));
 
             MockLogger logger = new MockLogger();
 
diff --git a/src/Tasks.UnitTests/ResolveAssemblyReference_CustomCultureTests.cs b/src/Tasks.UnitTests/ResolveAssemblyReference_CustomCultureTests.cs
new file mode 100644
index 00000000000..1a7d7ed0562
--- /dev/null
+++ b/src/Tasks.UnitTests/ResolveAssemblyReference_CustomCultureTests.cs
@@ -0,0 +1,89 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    /// <summary>
+    /// Unit tests for the ResolveAssemblyReference task.
+    /// </summary>
+    public class ResolveAssemblyReference_CustomCultureTests
+    {
+        private static string TestAssetsRootPath { get; } = Path.Combine(
+            Path.GetDirectoryName(typeof(AddToWin32Manifest_Tests).Assembly.Location) ?? AppContext.BaseDirectory,
+            "TestResources",
+            "CustomCulture");
+
+        [WindowsOnlyTheory]
+        [InlineData(true, "", true, true)]
+        [InlineData(false)]
+        [InlineData(true, "yue", false, true)]
+        [InlineData(false, "yue", false, true)]
+        [InlineData(true, "euy", true)]
+        [InlineData(true, "yue;euy")]
+        [InlineData(true, "euy;yue")]
+        public void E2EScenarioTests(bool enableCustomCulture, string customCultureExclusions = "", bool isYueCultureExpected = false, bool isEuyCultureExpected = false)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                // Set up project paths
+                var testAssetsPath = TestAssetsRootPath;
+                var solutionFolder = env.CreateFolder();
+                var solutionPath = solutionFolder.Path;
+
+                // Create and configure ProjectB
+                var projectBName = "ProjectB.csproj";
+                var projBOutputPath = env.CreateFolder().Path;
+                var projectBFolder = Path.Combine(solutionPath, projectBName);
+                Directory.CreateDirectory(projectBFolder);
+                var projBContent = File.ReadAllText(Path.Combine(testAssetsPath, projectBName))
+                    .Replace("OutputPathPlaceholder", projBOutputPath)
+                    .Replace("NonCultureResourceDirectoriesPlaceholder", customCultureExclusions)
+                    .Replace("EnableCustomCulturePlaceholder", enableCustomCulture.ToString());
+                env.CreateFile(Path.Combine(projectBFolder, projectBName), projBContent);
+
+                // Copy ProjectA files to test solution folder
+                CopyTestAsset(testAssetsPath, "ProjectA.csproj", solutionPath);
+                CopyTestAsset(testAssetsPath, "Test.resx", solutionPath);
+                CopyTestAsset(testAssetsPath, "Test.yue.resx", solutionPath);
+                CopyTestAsset(testAssetsPath, "Test.euy.resx", solutionPath);
+
+                env.SetCurrentDirectory(projectBFolder);
+                var output = RunnerUtilities.ExecBootstrapedMSBuild("-restore", out bool buildSucceeded);
+
+                buildSucceeded.ShouldBeTrue($"MSBuild should complete successfully. Build output: {output}");
+
+                var yueCultureResourceDll = Path.Combine(projBOutputPath, "yue", "ProjectA.resources.dll");
+                AssertCustomCulture(isYueCultureExpected, "yue", yueCultureResourceDll);
+
+                var euyCultureResourceDll = Path.Combine(projBOutputPath, "euy", "ProjectA.resources.dll");
+                AssertCustomCulture(isEuyCultureExpected, "euy", euyCultureResourceDll);
+            }
+
+            void AssertCustomCulture(bool isCultureExpectedToExist, string customCultureName, string cultureResourcePath)
+            {
+                if (enableCustomCulture && isCultureExpectedToExist)
+                {
+                    File.Exists(cultureResourcePath).ShouldBeTrue($"Expected '{customCultureName}' resource DLL not found at: {cultureResourcePath}");
+                }
+                else
+                {
+                    File.Exists(cultureResourcePath).ShouldBeFalse($"Unexpected '{customCultureName}' culture DLL was found at: {cultureResourcePath}");
+                }
+            }
+        }
+
+        private void CopyTestAsset(string sourceFolder, string fileName, string destinationFolder)
+        {
+            var sourcePath = Path.Combine(sourceFolder, fileName);
+
+            File.Copy(sourcePath, Path.Combine(destinationFolder, fileName));
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectA.csproj b/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectA.csproj
new file mode 100644
index 00000000000..aa6d648f1b1
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectA.csproj
@@ -0,0 +1,25 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <OutputType>Library</OutputType>
+    <TargetFramework>net472</TargetFramework>
+  </PropertyGroup>
+
+	<PropertyGroup>
+		<RespectAlreadyAssignedItemCulture>True</RespectAlreadyAssignedItemCulture>
+	</PropertyGroup>
+	<ItemGroup>
+		<EmbeddedResource Update="Test.resx">
+			<Generator>ResXFileCodeGenerator</Generator>
+		</EmbeddedResource>
+		<EmbeddedResource Update="Test.yue.resx">
+			<Culture>yue</Culture>
+			<LogicalName>Test.yue.resources</LogicalName>
+		</EmbeddedResource>
+    <EmbeddedResource Update="Test.euy.resx">
+      <Culture>euy</Culture>
+      <LogicalName>Test.euy.resources</LogicalName>
+    </EmbeddedResource>
+	</ItemGroup>
+
+</Project>
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectB.csproj b/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectB.csproj
new file mode 100644
index 00000000000..1daa05a8bc7
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectB.csproj
@@ -0,0 +1,19 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <TargetFramework>net472</TargetFramework>
+    <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
+    <OutputType>Library</OutputType>
+    <OutputPath>OutputPathPlaceholder</OutputPath>
+	<EnableCustomCulture>EnableCustomCulturePlaceholder</EnableCustomCulture>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <NonCultureResourceDirectories>NonCultureResourceDirectoriesPlaceholder</NonCultureResourceDirectories>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\ProjectA.csproj" />
+  </ItemGroup>
+
+</Project>
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/Test.euy.resx b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.euy.resx
new file mode 100644
index 00000000000..e6136e281c2
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.euy.resx
@@ -0,0 +1,58 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/Test.resx b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.resx
new file mode 100644
index 00000000000..e6136e281c2
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.resx
@@ -0,0 +1,58 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/Test.yue.resx b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.yue.resx
new file mode 100644
index 00000000000..e6136e281c2
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.yue.resx
@@ -0,0 +1,58 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index 633d6ef0435..acabaad7dec 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -319,7 +319,7 @@ public void WriteLinesToFileDoesCreateDirectory()
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        private void WritingNothingErasesExistingFile(bool useNullLines)
+        public void WritingNothingErasesExistingFile(bool useNullLines)
         {
             ITaskItem[] lines = useNullLines ? null : Array.Empty<ITaskItem>();
 
@@ -346,7 +346,7 @@ private void WritingNothingErasesExistingFile(bool useNullLines)
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        private void WritingNothingCreatesNewFile(bool useNullLines)
+        public void WritingNothingCreatesNewFile(bool useNullLines)
         {
             ITaskItem[] lines = useNullLines ? null : Array.Empty<ITaskItem>();
 
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs
new file mode 100644
index 00000000000..4cfd2f053ee
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs
@@ -0,0 +1,70 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a client for sending the ResolveAssemblyReference task to an out-of-proc node.
+    /// This is intended to be reused for all RAR tasks across a single build.
+    /// </summary>
+    internal sealed class OutOfProcRarClient : IDisposable
+    {
+        private readonly NodePipeClient _pipeClient;
+
+        private OutOfProcRarClient()
+        {
+            ServerNodeHandshake handshake = new(HandshakeOptions.None);
+            _pipeClient = new NodePipeClient(NamedPipeUtil.GetRarNodeEndpointPipeName(handshake), handshake);
+
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteResponse, RarNodeExecuteResponse.FactoryForDeserialization, null);
+            _pipeClient.RegisterPacketFactory(packetFactory);
+        }
+
+        public void Dispose() => _pipeClient.Dispose();
+
+        internal static OutOfProcRarClient GetInstance(IBuildEngine10 buildEngine)
+        {
+            // Create a single cached instance for this build.
+            const string OutOfProcRarClientKey = "OutOfProcRarClient";
+
+            // We want to reuse the pipe client across all RAR invocations within a build, but release the connection once
+            // the MSBuild node is idle. Using RegisteredTaskObjectLifetime.Build ensures that the RAR client is disposed between
+            // builds, freeing the server to run other requests.
+            OutOfProcRarClient rarClient = (OutOfProcRarClient)buildEngine.GetRegisteredTaskObject(OutOfProcRarClientKey, RegisteredTaskObjectLifetime.Build);
+
+            if (rarClient == null)
+            {
+                rarClient = new OutOfProcRarClient();
+                buildEngine.RegisterTaskObject(OutOfProcRarClientKey, rarClient, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);
+                CommunicationsUtilities.Trace("Initialized new RAR client.");
+            }
+
+            return rarClient;
+        }
+
+        internal bool Execute(ResolveAssemblyReference rarTask)
+        {
+            // This should only be true at the start of a build.
+            if (!_pipeClient.IsConnected)
+            {
+                // Don't set a timeout since the build manager already blocks until the server is running.
+                _pipeClient.ConnectToServer(0);
+            }
+
+            // TODO: Use RAR task to create the request packet.
+            _pipeClient.WritePacket(new RarNodeExecuteRequest());
+
+            // TODO: Use response packet to set RAR task outputs.
+            _ = (RarNodeExecuteResponse)_pipeClient.ReadPacket();
+
+            return true;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs
new file mode 100644
index 00000000000..12d03329609
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs
@@ -0,0 +1,179 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a persistent node for the ResolveAssemblyReferences task.
+    /// This manages the lifecycle of the multi-instance pipe server which executes RAR requests
+    /// and does not invoke the task itself.
+    /// </summary>
+    public sealed class OutOfProcRarNode
+    {
+        private readonly ServerNodeHandshake _handshake = new(HandshakeOptions.None);
+
+        private readonly int _maxNumberOfConcurrentTasks;
+
+        public OutOfProcRarNode()
+            : this(Environment.ProcessorCount)
+        {
+        }
+
+        public OutOfProcRarNode(int maxNumberOfConcurrentTasks) => _maxNumberOfConcurrentTasks = maxNumberOfConcurrentTasks;
+
+        /// <summary>
+        /// Starts the node and begins processing RAR execution requests until cancelled.
+        /// </summary>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <param name="cancellationToken">A cancellation token to observe while running the node loop.</param>
+        /// <returns>The reason for the node shutdown.</returns>
+        public RarNodeShutdownReason Run(out Exception? shutdownException, CancellationToken cancellationToken = default)
+        {
+            RarNodeShutdownReason shutdownReason;
+            shutdownException = null;
+
+            try
+            {
+                shutdownReason = RunNodeAsync(cancellationToken).GetAwaiter().GetResult();
+            }
+            catch (OperationCanceledException)
+            {
+                // Consider cancellation as an intentional shutdown of the node.
+                shutdownReason = RarNodeShutdownReason.Complete;
+            }
+            catch (UnauthorizedAccessException ex)
+            {
+                // Access to the path is denied if the named pipe already exists or is owned by a different user.
+                shutdownException = new InvalidOperationException("RAR node is already running.", ex);
+                shutdownReason = RarNodeShutdownReason.AlreadyRunning;
+            }
+            catch (Exception ex)
+            {
+                shutdownException = ex;
+                shutdownReason = RarNodeShutdownReason.Error;
+            }
+
+            if (shutdownException == null)
+            {
+                CommunicationsUtilities.Trace("Shutting down with reason: {0}");
+            }
+            else
+            {
+                CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}", shutdownReason, shutdownException);
+            }
+
+            return shutdownReason;
+        }
+
+        private async Task<RarNodeShutdownReason> RunNodeAsync(CancellationToken cancellationToken)
+        {
+            // The RAR node uses two sets of pipe servers:
+            // 1. A single instance pipe to manage the lifecycle of the node.
+            // 2. A multi-instance pipe to execute concurrent RAR requests.
+            // Because multi-instance pipes can live across multiple processes, we can't rely on the instance cap to preven
+            // multiple nodes from running in the event of a race condition.
+            // This also simplifies tearing down all active pipe servers when shutdown is requested.
+            using NodePipeServer pipeServer = new(NamedPipeUtil.GetRarNodePipeName(_handshake), _handshake);
+
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, null);
+            pipeServer.RegisterPacketFactory(packetFactory);
+
+            using CancellationTokenSource linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
+
+            Task nodeEndpointTasks = Task.Run(() => RunNodeEndpointsAsync(linkedCts.Token), linkedCts.Token);
+
+            // Run any static initializers which will add latency to the first task run.
+            _ = new ResolveAssemblyReference();
+
+            while (!cancellationToken.IsCancellationRequested)
+            {
+                LinkStatus linkStatus = await WaitForConnection(pipeServer, cancellationToken);
+
+                if (linkStatus == LinkStatus.Active)
+                {
+                    NodeBuildComplete buildComplete = (NodeBuildComplete)pipeServer.ReadPacket();
+
+                    if (!buildComplete.PrepareForReuse)
+                    {
+                        break;
+                    }
+                }
+
+                pipeServer.Disconnect();
+            }
+
+            // Gracefully shutdown the node endpoints.
+            linkedCts.Cancel();
+
+            try
+            {
+                await nodeEndpointTasks;
+            }
+            catch (OperationCanceledException)
+            {
+                // Ignore since cancellation is expected.
+            }
+
+            return RarNodeShutdownReason.Complete;
+
+            // WaitForConnection does not currently accept cancellation, so use Wait to watch for cancellation.
+            // Cancellation is only expected when MSBuild is gracefully shutting down the node or running in unit tests.
+            static async Task<LinkStatus> WaitForConnection(NodePipeServer pipeServer, CancellationToken cancellationToken)
+            {
+                Task<LinkStatus> linkStatusTask = Task.Run(pipeServer.WaitForConnection);
+                linkStatusTask.Wait(cancellationToken);
+                return await linkStatusTask;
+            }
+        }
+
+        private async Task RunNodeEndpointsAsync(CancellationToken cancellationToken)
+        {
+            // Setup data shared between all endpoints.
+            string pipeName = NamedPipeUtil.GetRarNodeEndpointPipeName(_handshake);
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteRequest, RarNodeExecuteRequest.FactoryForDeserialization, null);
+
+            OutOfProcRarNodeEndpoint[] endpoints = new OutOfProcRarNodeEndpoint[_maxNumberOfConcurrentTasks];
+
+            // Validate all endpoint pipe handles successfully initialize before running any read loops.
+            // This allows us to bail out in the event where we can't control every pipe instance.
+            for (int i = 0; i < endpoints.Length; i++)
+            {
+                endpoints[i] = new OutOfProcRarNodeEndpoint(
+                        endpointId: i + 1,
+                        pipeName,
+                        _handshake,
+                        _maxNumberOfConcurrentTasks,
+                        packetFactory);
+            }
+
+            Task[] endpointTasks = new Task[endpoints.Length];
+
+            for (int i = 0; i < endpoints.Length; i++)
+            {
+                // Avoid capturing the indexer in the closure.
+                OutOfProcRarNodeEndpoint endpoint = endpoints[i];
+                endpointTasks[i] = Task.Run(() => endpoint.RunAsync(cancellationToken), cancellationToken);
+            }
+
+            CommunicationsUtilities.Trace("{0} RAR endpoints started.", _maxNumberOfConcurrentTasks);
+
+            await Task.WhenAll(endpointTasks);
+
+            foreach (OutOfProcRarNodeEndpoint endpoint in endpoints)
+            {
+                endpoint.Dispose();
+            }
+
+            CommunicationsUtilities.Trace("All endpoints successfully stopped. Exiting.");
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs
new file mode 100644
index 00000000000..666ce49b5c5
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs
@@ -0,0 +1,97 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a single instance of a pipe server which executes the ResolveAssemblyReference task.
+    /// </summary>
+    internal sealed class OutOfProcRarNodeEndpoint : IDisposable
+    {
+        private readonly int _endpointId;
+
+        private readonly NodePipeServer _pipeServer;
+
+        internal OutOfProcRarNodeEndpoint(
+            int endpointId,
+            string pipeName,
+            ServerNodeHandshake handshake,
+            int maxNumberOfServerInstances,
+            NodePacketFactory packetFactory)
+        {
+            _endpointId = endpointId;
+            _pipeServer = new NodePipeServer(pipeName, handshake, maxNumberOfServerInstances);
+            _pipeServer.RegisterPacketFactory(packetFactory);
+        }
+
+        public void Dispose() => _pipeServer.Dispose();
+
+        internal async Task RunAsync(CancellationToken cancellationToken = default)
+        {
+            CommunicationsUtilities.Trace("({0}) Starting RAR endpoint.", _endpointId);
+
+            try
+            {
+                await RunInternalAsync(cancellationToken);
+            }
+            catch (OperationCanceledException)
+            {
+                // Swallow cancellation excpetions for now. We're using this as a simple way to gracefully shutdown the
+                // endpoint, instead of having to implement separate Start / Stop methods and deferring to the caller.
+                // Can reevaluate if we need more granular control over cancellation vs shutdown.
+                CommunicationsUtilities.Trace("({0}) RAR endpoint stopped due to cancellation.", _endpointId);
+            }
+        }
+
+        private async Task RunInternalAsync(CancellationToken cancellationToken)
+        {
+            while (!cancellationToken.IsCancellationRequested)
+            {
+                while (!_pipeServer.IsConnected)
+                {
+                    _ = _pipeServer.WaitForConnection();
+                }
+
+                CommunicationsUtilities.Trace("({0}) Received RAR request.", _endpointId);
+
+                try
+                {
+                    INodePacket packet = await _pipeServer.ReadPacketAsync(cancellationToken);
+
+                    if (packet.Type == NodePacketType.NodeShutdown)
+                    {
+                        // Although the client has already disconnected, it is still necessary to Diconnect() so the
+                        // pipe can transition into PipeState.Disonnected, which is treated as an intentional pipe break.
+                        // Otherwise, all future operations on the pipe will throw an exception.
+                        CommunicationsUtilities.Trace("({0}) RAR client disconnected.", _endpointId);
+                        _pipeServer.Disconnect();
+                        continue;
+                    }
+
+                    RarNodeExecuteRequest request = (RarNodeExecuteRequest)packet;
+
+                    // TODO: Use request packet to set inputs on the RAR task.
+                    ResolveAssemblyReference rarTask = new();
+
+                    // TODO: bool success = rarTask.ExecuteInProcess();
+                    // TODO: Use RAR task outputs to create response packet.
+                    await _pipeServer.WritePacketAsync(new RarNodeExecuteResponse(), cancellationToken);
+
+                    CommunicationsUtilities.Trace("({0}) Completed RAR request.", _endpointId);
+                }
+                catch (Exception e) when (e is not OperationCanceledException)
+                {
+                    CommunicationsUtilities.Trace("({0}) Exception while executing RAR request: {1}", _endpointId, e);
+                }
+            }
+
+            _pipeServer.Disconnect();
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs
new file mode 100644
index 00000000000..a129bd56748
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs
@@ -0,0 +1,23 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    internal sealed class RarNodeExecuteRequest : INodePacket
+    {
+        public NodePacketType Type => NodePacketType.RarNodeExecuteRequest;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            RarNodeExecuteRequest request = new();
+            request.Translate(translator);
+            return request;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs
new file mode 100644
index 00000000000..9611897fc82
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs
@@ -0,0 +1,23 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    internal sealed class RarNodeExecuteResponse : INodePacket
+    {
+        public NodePacketType Type => NodePacketType.RarNodeExecuteResponse;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            RarNodeExecuteResponse response = new();
+            response.Translate(translator);
+            return response;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs b/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs
new file mode 100644
index 00000000000..67b37177e4a
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs
@@ -0,0 +1,31 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Reasons why the RAR node shutdown.
+    /// </summary>
+    public enum RarNodeShutdownReason
+    {
+        /// <summary>
+        /// The RAR node was instructed to terminate and gracefully shut down.
+        /// </summary>
+        Complete,
+
+        /// <summary>
+        /// The RAR node is already running.
+        /// </summary>
+        AlreadyRunning,
+
+        /// <summary>
+        /// The RAR node timed out waiting for a connection.
+        /// </summary>
+        ConnectionTimedOut,
+
+        /// <summary>
+        /// The RAR node encountered an unrecoverable error.
+        /// </summary>
+        Error,
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 9e3b0c07d36..2b57c7287f8 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -92,10 +92,6 @@ internal sealed class ReferenceTable
         private readonly GetAssemblyMetadata _getAssemblyMetadata;
         /// <summary>Delegate used to get the image runtime version of a file</summary>
         private readonly GetAssemblyRuntimeVersion _getRuntimeVersion;
-#if FEATURE_WIN32_REGISTRY
-        /// <summary> Delegate to get the base registry key for AssemblyFoldersEx</summary>
-        private OpenBaseKey _openBaseKey;
-#endif
         /// <summary>Version of the runtime we are targeting</summary>
         private readonly Version _targetedRuntimeVersion;
 
@@ -135,7 +131,7 @@ internal sealed class ReferenceTable
         private readonly bool _doNotCopyLocalIfInGac;
 
         /// <summary>
-        ///  Shoould the framework attribute version mismatch be ignored.
+        ///  Should the framework attribute version mismatch be ignored.
         /// </summary>
         private readonly bool _ignoreFrameworkAttributeVersionMismatch;
 
@@ -145,7 +141,17 @@ internal sealed class ReferenceTable
         private readonly GetAssemblyPathInGac _getAssemblyPathInGac;
 
         /// <summary>
-        /// Should a warning or error be emitted on architecture mismatch
+        /// Contains the list of directories that should NOT be considered as custom culture directories.
+        /// </summary>
+        private readonly string[] _nonCultureResourceDirectories = [];
+
+        /// <summary>
+        /// Is true, custom culture processing is enabled.
+        /// </summary>
+        private readonly bool _enableCustomCulture = false;
+
+        /// <summary>
+        /// Should a warning or error be emitted on architecture mismatch.
         /// </summary>
         private readonly WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
 
@@ -174,6 +180,7 @@ internal sealed class ReferenceTable
         /// <param name="findSatellites">If true, then search for satellite files.</param>
         /// <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
         /// <param name="findRelatedFiles">If true, then search for related files.</param>
+        /// <param name="enableCustomCulture">If true, custom culture processing is enabled.</param>
         /// <param name="searchPaths">Paths to search for dependent assemblies on.</param>
         /// <param name="relatedFileExtensions"></param>
         /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
@@ -206,6 +213,7 @@ internal sealed class ReferenceTable
         /// <param name="readMachineTypeFromPEHeader"></param>
         /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
         /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+        /// <param name="nonCultureResourceDirectories"></param>
 #else
         /// <summary>
         /// Construct.
@@ -215,13 +223,14 @@ internal sealed class ReferenceTable
         /// <param name="findSatellites">If true, then search for satellite files.</param>
         /// <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
         /// <param name="findRelatedFiles">If true, then search for related files.</param>
+        /// <param name="enableCustomCulture">If true, custom culture processing is enabled.</param>
         /// <param name="searchPaths">Paths to search for dependent assemblies on.</param>
         /// <param name="relatedFileExtensions"></param>
         /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
         /// <param name="resolvedSDKItems">Resolved sdk items</param>
         /// <param name="frameworkPaths">Path to the FX.</param>
         /// <param name="installedAssemblies">Installed assembly XML tables.</param>
-        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
+        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targeted.</param>
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
         /// <param name="directoryExists">Delegate used for files.</param>
         /// <param name="getDirectories">Delegate used for getting directories.</param>
@@ -234,7 +243,7 @@ internal sealed class ReferenceTable
         /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
         /// <param name="projectTargetFramework">Version of the framework targeted by the project.</param>
         /// <param name="targetFrameworkMoniker">Target framework moniker we are targeting.</param>
-        /// <param name="log">Logging helper to allow the logging of meessages from the Reference Table.</param>
+        /// <param name="log">Logging helper to allow the logging of messages from the Reference Table.</param>
         /// <param name="latestTargetFrameworkDirectories"></param>
         /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
         /// <param name="doNotCopyLocalIfInGac"></param>
@@ -244,6 +253,7 @@ internal sealed class ReferenceTable
         /// <param name="readMachineTypeFromPEHeader"></param>
         /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
         /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+        /// <param name="nonCultureResourceDirectories"></param>
 #endif
         internal ReferenceTable(
             IBuildEngine buildEngine,
@@ -251,6 +261,7 @@ internal ReferenceTable(
             bool findSatellites,
             bool findSerializationAssemblies,
             bool findRelatedFiles,
+            bool enableCustomCulture,
             string[] searchPaths,
             string[] allowedAssemblyExtensions,
             string[] relatedFileExtensions,
@@ -284,7 +295,8 @@ internal ReferenceTable(
             WarnOrErrorOnTargetArchitectureMismatchBehavior warnOrErrorOnTargetArchitectureMismatch,
             bool ignoreFrameworkAttributeVersionMismatch,
             bool unresolveFrameworkAssembliesFromHigherFrameworks,
-            ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
+            ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache,
+            string[] nonCultureResourceDirectories)
         {
             _log = log;
             _findDependencies = findDependencies;
@@ -304,9 +316,6 @@ internal ReferenceTable(
             _getRuntimeVersion = getRuntimeVersion;
             _projectTargetFramework = projectTargetFramework;
             _targetedRuntimeVersion = targetedRuntimeVersion;
-#if FEATURE_WIN32_REGISTRY
-            _openBaseKey = openBaseKey;
-#endif
             _targetFrameworkMoniker = targetFrameworkMoniker;
             _latestTargetFrameworkDirectories = latestTargetFrameworkDirectories;
             _copyLocalDependenciesWhenParentReferenceInGac = copyLocalDependenciesWhenParentReferenceInGac;
@@ -317,6 +326,8 @@ internal ReferenceTable(
             _warnOrErrorOnTargetArchitectureMismatch = warnOrErrorOnTargetArchitectureMismatch;
             _ignoreFrameworkAttributeVersionMismatch = ignoreFrameworkAttributeVersionMismatch;
             _assemblyMetadataCache = assemblyMetadataCache;
+            _nonCultureResourceDirectories = nonCultureResourceDirectories;
+            _enableCustomCulture = enableCustomCulture;
 
             // Set condition for when to check assembly version against the target framework version
             _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? ReferenceTable.s_targetFrameworkVersion_40) <= ReferenceTable.s_targetFrameworkVersion_40);
@@ -970,8 +981,9 @@ private void FindSatellites(
                     // Is there a candidate satellite in that folder?
                     string cultureName = Path.GetFileName(subDirectory);
 
-                    // Custom or unknown cultures can be met as well
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14) || CultureInfoCache.IsValidCultureString(cultureName))
+                    // Custom or unknown cultures can be met only if the feature is enabled and the directory was not added to the exclusion list.
+                    if ((_enableCustomCulture && !_nonCultureResourceDirectories.Contains(cultureName))
+                        || CultureInfoCache.IsValidCultureString(cultureName))
                     {
                         string satelliteAssembly = Path.Combine(subDirectory, satelliteFilename);
                         if (_fileExists(satelliteAssembly))
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index a5a3ae00813..21c3811e476 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -16,6 +16,7 @@
 
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
@@ -177,8 +178,10 @@ internal static void Initialize(TaskLoggingHelper log)
         private ITaskItem[] _resolvedSDKReferences = Array.Empty<TaskItem>();
         private bool _ignoreDefaultInstalledAssemblyTables = false;
         private bool _ignoreDefaultInstalledAssemblySubsetTables = false;
+        private bool _enableCustomCulture = false;
         private string[] _candidateAssemblyFiles = [];
         private string[] _targetFrameworkDirectories = [];
+        private string[] _nonCultureResourceDirectories = [];
         private string[] _searchPaths = [];
         private string[] _allowedAssemblyExtensions = [".winmd", ".dll", ".exe"];
         private string[] _relatedFileExtensions = [".pdb", ".xml", ".pri"];
@@ -422,6 +425,24 @@ public string[] TargetFrameworkDirectories
             set { _targetFrameworkDirectories = value; }
         }
 
+        /// <summary>
+        /// Contains list of directories that point to custom culture resources that has to be ignored by MSBuild.
+        /// </summary>
+        public string[] NonCultureResourceDirectories
+        {
+            get { return _nonCultureResourceDirectories; }
+            set { _nonCultureResourceDirectories = value; }
+        }
+
+        /// <summary>
+        /// Contains the information if custom culture is enabled.
+        /// </summary>
+        public bool EnableCustomCulture
+        {
+            get { return _enableCustomCulture; }
+            set { _enableCustomCulture = value; }     
+        }
+
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be installed on the target machine.
         ///
@@ -900,6 +921,11 @@ public string[] FullFrameworkFolders
 
         public bool FailIfNotIncremental { get; set; }
 
+        /// <summary>
+        /// Allow the task to run on the out-of-proc node if enabled for this build.
+        /// </summary>
+        public bool AllowOutOfProcNode { get; set; }
+
         /// <summary>
         /// This is a list of all primary references resolved to full paths.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
@@ -1511,7 +1537,10 @@ private void LogInputs()
             }
 
             Log.LogMessage(importance, property, "TargetFrameworkDirectories");
-            Log.LogMessage(importance, indent + String.Join(",", TargetFrameworkDirectories));
+            Log.LogMessage(importance, indent + string.Join(",", TargetFrameworkDirectories));
+
+            Log.LogMessage(importance, property, "NonCultureResourceDirectories");
+            Log.LogMessage(importance, indent + string.Join(",", NonCultureResourceDirectories));
 
             Log.LogMessage(importance, property, "InstalledAssemblyTables");
             foreach (ITaskItem installedAssemblyTable in InstalledAssemblyTables)
@@ -1547,6 +1576,12 @@ private void LogInputs()
             Log.LogMessage(importance, property, "AutoUnify");
             Log.LogMessage(importance, $"{indent}{AutoUnify}");
 
+            Log.LogMessage(importance, property, "EnableCustomCulture");
+            Log.LogMessage(importance, $"{indent}{EnableCustomCulture}");
+
+            Log.LogMessage(importance, property, "EnableCustomCulture");
+            Log.LogMessage(importance, $"{indent}{EnableCustomCulture}");
+
             Log.LogMessage(importance, property, "CopyLocalDependenciesWhenParentReferenceInGac");
             Log.LogMessage(importance, $"{indent}{_copyLocalDependenciesWhenParentReferenceInGac}");
 
@@ -2386,6 +2421,7 @@ internal bool Execute(
                         _findSatellites,
                         _findSerializationAssemblies,
                         _findRelatedFiles,
+                        _enableCustomCulture,
                         _searchPaths,
                         _allowedAssemblyExtensions,
                         _relatedFileExtensions,
@@ -2419,7 +2455,8 @@ internal bool Execute(
                         _warnOrErrorOnTargetArchitectureMismatch,
                         _ignoreTargetFrameworkAttributeVersionMismatch,
                         _unresolveFrameworkAssembliesFromHigherFrameworks,
-                        assemblyMetadataCache);
+                        assemblyMetadataCache,
+                        _nonCultureResourceDirectories);
 
                     dependencyTable.FindDependenciesOfExternallyResolvedReferences = FindDependenciesOfExternallyResolvedReferences;
 
@@ -3212,6 +3249,25 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr
         /// <returns>True if there was success.</returns>
         public override bool Execute()
         {
+            if (AllowOutOfProcNode
+                && BuildEngine is IBuildEngine10 buildEngine10
+                && buildEngine10.EngineServices.IsOutOfProcRarNodeEnabled)
+            {
+                try
+                {
+#pragma warning disable CA2000 // The OutOfProcRarClient is disposable but its disposal is handled by RegisterTaskObject.
+                    _ = OutOfProcRarClient.GetInstance(buildEngine10).Execute(this);
+#pragma warning restore CA2000 // Dispose objects before losing scope
+                    CommunicationsUtilities.Trace("RAR out-of-proc test connection completed. Executing task in-proc.");
+                }
+                catch (Exception ex)
+                {
+                    // If the out-of-proc connection failed, fall back to in-proc.
+                    // TODO: Disable out-of-proc for the remainder of the build if any connection fails.
+                    CommunicationsUtilities.Trace("RAR out-of-proc connection failed, failing back to in-proc. Exception: {0}", ex);
+                }
+            }
+
             return Execute(
                 p => FileUtilities.FileExistsNoThrow(p),
                 p => FileUtilities.DirectoryExistsNoThrow(p),
@@ -3234,7 +3290,6 @@ public override bool Execute()
                     => AssemblyInformation.IsWinMDFile(fullPath, getAssemblyRuntimeVersion, fileExists, out imageRuntimeVersion, out isManagedWinmd),
                 p => ReferenceTable.ReadMachineTypeFromPEHeader(p));
         }
-
         #endregion
     }
 }
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index 6f3b6b5a06d..c7f838b16ef 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -51,7 +51,7 @@ protected override string CreateManifestName(
                 Actual implementation is in a static method called CreateManifestNameImpl.
                 The reason is that CreateManifestName can't be static because it is an
                 override of a method declared in the base class, but its convenient
-                to expose a static version anyway for unittesting purposes.
+                to expose a static version anyway for unit testing purposes.
             */
             return CreateManifestNameImpl(
                 fileName,
@@ -62,7 +62,8 @@ The reason is that CreateManifestName can't be static because it is an
                 culture,
                 binaryStream,
                 Log,
-                treatAsCultureNeutral);
+                treatAsCultureNeutral,
+                EnableCustomCulture);
         }
 
         /// <summary>
@@ -81,6 +82,7 @@ The reason is that CreateManifestName can't be static because it is an
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <param name="log">Task's TaskLoggingHelper, for logging warnings or errors</param>
         /// <param name="treatAsCultureNeutral">Whether to treat the current file as 'culture-neutral' and retain the culture in the name.</param>
+        /// <param name="enableCustomCulture">Whether custom culture handling is expected.</param>
         /// <returns>Returns the manifest name</returns>
         internal static string CreateManifestNameImpl(
             string fileName,
@@ -91,7 +93,8 @@ internal static string CreateManifestNameImpl(
             string culture, // may be null
             Stream binaryStream, // File contents binary stream, may be null
             TaskLoggingHelper log,
-            bool treatAsCultureNeutral = false)
+            bool treatAsCultureNeutral = false,
+            bool enableCustomCulture = false)
         {
             // Use the link file name if there is one, otherwise, fall back to file name.
             string embeddedFileName = FileUtilities.FixFilePath(linkFileName);
@@ -103,13 +106,12 @@ internal static string CreateManifestNameImpl(
             dependentUponFileName = FileUtilities.FixFilePath(dependentUponFileName);
             Culture.ItemCultureInfo info;
 
-            if (!string.IsNullOrEmpty(culture) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14))
+            if (!string.IsNullOrEmpty(culture) && enableCustomCulture)
             {
                 info = new Culture.ItemCultureInfo()
                 {
                     culture = culture,
-                    cultureNeutralFilename =
-                        embeddedFileName.RemoveLastInstanceOf("." + culture, StringComparison.OrdinalIgnoreCase),
+                    cultureNeutralFilename = embeddedFileName.RemoveLastInstanceOf("." + culture, StringComparison.OrdinalIgnoreCase),
                 };
             }
             else
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index 934d67c6a68..d974b1a8d1c 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -28,6 +28,8 @@ public abstract class CreateManifestResourceName : TaskExtension
 
         private ITaskItem[] _resourceFiles;
 
+        private bool _enableCustomCulture;
+
         [SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Justification = "Shipped this way in Dev11 Beta (go-live)")]
         [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Taskitem", Justification = "Shipped this way in Dev11 Beta (go-live)")]
         protected Dictionary<string, ITaskItem> itemSpecToTaskitem = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
@@ -56,6 +58,15 @@ public ITaskItem[] ResourceFiles
             set => _resourceFiles = value;
         }
 
+        /// <summary>
+        /// Contains the information if custom culture is enabled.
+        /// </summary>
+        public bool EnableCustomCulture
+        {
+            get { return _enableCustomCulture; }
+            set { _enableCustomCulture = value; }
+        }
+
         /// <summary>
         /// Rootnamespace to use for naming.
         /// </summary>
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 0115685336f..d2cf7f405ef 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -50,7 +50,7 @@ protected override string CreateManifestName(
                 Actual implementation is in a static method called CreateManifestNameImpl.
                 The reason is that CreateManifestName can't be static because it is an
                 override of a method declared in the base class, but its convenient
-                to expose a static version anyway for unittesting purposes.
+                to expose a static version anyway for unit testing purposes.
             */
             return CreateManifestNameImpl(
                 fileName,
@@ -61,7 +61,8 @@ The reason is that CreateManifestName can't be static because it is an
                 culture,
                 binaryStream,
                 Log,
-                treatAsCultureNeutral);
+                treatAsCultureNeutral,
+                EnableCustomCulture);
         }
 
         /// <summary>
@@ -80,6 +81,7 @@ The reason is that CreateManifestName can't be static because it is an
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <param name="log">Task's TaskLoggingHelper, for logging warnings or errors</param>
         /// <param name="treatAsCultureNeutral">Whether to treat the current file as 'culture-neutral' and retain the culture in the name.</param>
+        /// <param name="enableCustomCulture">Whether custom culture handling is expected.</param>
         /// <returns>Returns the manifest name</returns>
         internal static string CreateManifestNameImpl(
             string fileName,
@@ -90,7 +92,8 @@ internal static string CreateManifestNameImpl(
             string culture,
             Stream binaryStream, // File contents binary stream, may be null
             TaskLoggingHelper log,
-            bool treatAsCultureNeutral = false)
+            bool treatAsCultureNeutral = false,
+            bool enableCustomCulture = false)
         {
             // Use the link file name if there is one, otherwise, fall back to file name.
             string embeddedFileName = linkFileName;
@@ -102,13 +105,12 @@ internal static string CreateManifestNameImpl(
             dependentUponFileName = FileUtilities.FixFilePath(dependentUponFileName);
             Culture.ItemCultureInfo info;
 
-            if (!string.IsNullOrEmpty(culture) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14))
+            if (!string.IsNullOrEmpty(culture) && enableCustomCulture)
             {
                 info = new Culture.ItemCultureInfo()
                 {
                     culture = culture,
-                    cultureNeutralFilename =
-                        embeddedFileName.RemoveLastInstanceOf("." + culture, StringComparison.OrdinalIgnoreCase)
+                    cultureNeutralFilename = embeddedFileName.RemoveLastInstanceOf("." + culture, StringComparison.OrdinalIgnoreCase),
                 };
             }
             else
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index baca3658583..66baa32d31f 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -2,12 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.Globalization;
 #if NET
 using System.Linq;
-#endif
+#else
+using System.Collections.Generic;
 using Microsoft.Build.Shared;
+#endif
 
 #nullable disable
 
@@ -32,6 +33,7 @@ internal static class CultureInfoCache
         // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
         private static readonly string[] pseudoLocales = ["qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh"];
 
+#if !NET
         private static HashSet<string> InitializeValidCultureNames()
         {
 #if !FEATURE_CULTUREINFO_GETCULTURES
@@ -54,6 +56,7 @@ private static HashSet<string> InitializeValidCultureNames()
 
             return validCultureNames;
         }
+#endif
 
         /// <summary>
         /// Determine if a culture string represents a valid <see cref="CultureInfo"/> instance.
@@ -79,7 +82,7 @@ internal static bool IsValidCultureString(string name)
 #endif
         }
 
-#if !FEATURE_CULTUREINFO_GETCULTURES
+#if !NET && !FEATURE_CULTUREINFO_GETCULTURES
         // Copied from https://github.com/aspnet/Localization/blob/5e1fb16071affd15f15b9c732833f3ae2ac46e10/src/Microsoft.Framework.Globalization.CultureInfoCache/CultureInfoList.cs
         // Regenerated using the tool (removed by https://github.com/aspnet/Localization/pull/130)
         //   * Removed the empty string from the list
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 9028bd1f386..1e32984bd73 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -169,7 +169,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
 #endif
                     }
 
-                    if (!TryGetFileName(response, out string filename))
+                    if (!TryGetFileName(uri, out string filename))
                     {
                         Log.LogErrorWithCodeFromResources("DownloadFile.ErrorUnknownFileName", SourceUrl, nameof(DestinationFileName));
                         return;
@@ -308,25 +308,24 @@ private static bool IsRetriable(Exception exception, out Exception actualExcepti
         /// <summary>
         /// Attempts to get the file name to use when downloading the file.
         /// </summary>
-        /// <param name="response">The <see cref="HttpResponseMessage"/> with information about the response.</param>
+        /// <param name="requestUri">The uri we sent request to.</param>
         /// <param name="filename">Receives the name of the file.</param>
         /// <returns><code>true</code> if a file name could be determined, otherwise <code>false</code>.</returns>
-        private bool TryGetFileName(HttpResponseMessage response, out string filename)
+        private bool TryGetFileName(Uri requestUri, out string filename)
         {
-            if (response == null)
+            if (requestUri == null)
             {
-                throw new ArgumentNullException(nameof(response));
+                throw new ArgumentNullException(nameof(requestUri));
             }
 
             // Not all URIs contain a file name so users will have to specify one
             // Example: http://www.download.com/file/1/
 
-            filename = !String.IsNullOrWhiteSpace(DestinationFileName?.ItemSpec)
+            filename = !string.IsNullOrWhiteSpace(DestinationFileName?.ItemSpec)
                 ? DestinationFileName.ItemSpec // Get the file name from what the user specified
-                : response.Content?.Headers?.ContentDisposition?.FileName // Attempt to get the file name from the content-disposition header value
-                  ?? Path.GetFileName(response.RequestMessage.RequestUri.LocalPath); // Otherwise attempt to get a file name from the URI
+                : Path.GetFileName(requestUri.LocalPath); // Otherwise attempt to get a file name from the URI
 
-            return !String.IsNullOrWhiteSpace(filename);
+            return !string.IsNullOrWhiteSpace(filename);
         }
 
 #if !NET
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index d761f90b332..7c41f6fcbf3 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -16,6 +16,7 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Resources;
 using System.Resources.Extensions;
 using System.Reflection;
@@ -41,7 +42,6 @@
 using Microsoft.Build.Utilities;
 #if FEATURE_RESXREADER_LIVEDESERIALIZATION
 using Microsoft.Win32;
-using System.Linq;
 #endif
 
 #nullable disable
@@ -1705,7 +1705,7 @@ private void UpdateNewestUncorrelatedInputWriteTime()
 
             // Check the timestamp of each of the passed-in references to find the newest;
             // and then the additional inputs
-            ITaskItem[] inputs = this.References ?? [.. (this.AdditionalInputs ?? [])];
+            var inputs = (this.References ?? []).Concat(this.AdditionalInputs ?? []);
 
             foreach (ITaskItem input in inputs)
             {
@@ -2015,7 +2015,6 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
                 return result != null;
             }
         }
-#endif
 
         /// <summary>
         /// Turns the nicely justified block of base64 found in a resx into a byte array.
@@ -2046,6 +2045,7 @@ private static byte[] ByteArrayFromBase64WrappedString(string text)
                 return Convert.FromBase64String(text);
             }
         }
+#endif
 
         /// <summary>
         /// Make sure that OutputResources has 1 file name for each name in Sources.
@@ -2295,10 +2295,12 @@ internal string StronglyTypedClassName
         /// </summary>
         private List<ITaskItem> _inFiles;
 
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// List of satellite input files to process.
         /// </summary>
         private List<ITaskItem> _satelliteInFiles;
+#endif
 
         /// <summary>
         /// List of output files to process.
@@ -2310,11 +2312,6 @@ internal string StronglyTypedClassName
         /// </summary>
         private bool _extractResWFiles;
 
-        /// <summary>
-        /// Where to write extracted ResW files.
-        /// </summary>
-        private string _resWOutputDirectory;
-
         private bool _usePreserializedResources;
 
         internal List<ITaskItem> ExtractedResWFiles
@@ -2402,7 +2399,9 @@ internal void Run(
             _logger = log;
             _assemblyFiles = assemblyFilesList;
             _inFiles = inputs;
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             _satelliteInFiles = satelliteInputs;
+#endif
             _outFiles = outputs;
             _useSourcePath = sourcePath;
             _stronglyTypedLanguage = language;
@@ -2413,7 +2412,6 @@ internal void Run(
             _stronglyTypedClassIsPublic = publicClass;
             _readers = new List<ReaderInfo>();
             _extractResWFiles = extractingResWFiles;
-            _resWOutputDirectory = resWOutputDirectory;
             _portableLibraryCacheInfo = new List<ResGenDependencies.PortableLibraryFile>();
             _usePreserializedResources = usePreserializedResources;
             _logWarningForBinaryFormatter = logWarningForBinaryFormatter;
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index 1bd48abe2db..87e7e3d452d 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -54,9 +54,7 @@ private static XmlDocument GetXmlDocument(string path)
             using (Stream s = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
                 byte[] buffer = new byte[2];
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read' The check of bytes happens later in the code. In case of invalid documents the code will throw an exception during xml loading.
-                s.Read(buffer, 0, 2);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+                s.ReadExactly(buffer, 0, 2);
                 s.Position = 0;
                 var document = new XmlDocument();
                 var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
@@ -140,9 +138,7 @@ public static Manifest ReadManifest(string manifestType, string path, bool prese
             using (Stream s = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
                 byte[] buffer = new byte[2];
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read' The check of bytes happens later in the code. In case of invalid document the exception is expected later
-                s.Read(buffer, 0, 2);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+                s.ReadExactly(buffer, 0, 2);
                 s.Position = 0;
                 // if first two bytes are "MZ" then we're looking at an .exe or a .dll not a .manifest
                 if ((buffer[0] == 0x4D) && (buffer[1] == 0x5A))
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 93ec71a20a8..83184f8f618 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -166,9 +166,7 @@ public static bool IsPEFile(string path)
             byte[] buffer = new byte[2];
             using (Stream s = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read'
-                s.Read(buffer, 0, 2);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+                s.ReadExactly(buffer, 0, 2);
             }
 
             // if first two bytes are "MZ" then we're looking at an .exe or a .dll not a .manifest
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index a737ed59012..0013fbde3e2 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -502,7 +502,7 @@ public static PermissionSet XmlToPermissionSet(XmlElement element)
         [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint, Uri timestampUrl, string path)
         {
-            SignFile(certThumbprint, timestampUrl, path, null, null);
+            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion: null, targetFrameworkIdentifier: null);
         }
 
         /// <summary>
@@ -518,7 +518,7 @@ public static void SignFile(string certThumbprint,
                                     string path,
                                     string targetFrameworkVersion)
         {
-            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, null);
+            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, targetFrameworkIdentifier: null);
         }
 
         /// <summary>
@@ -536,7 +536,7 @@ public static void SignFile(string certThumbprint,
                                     string targetFrameworkVersion,
                                     string targetFrameworkIdentifier)
         {
-            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, targetFrameworkIdentifier, false);
+            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, targetFrameworkIdentifier, disallowMansignTimestampFallback: false);
         }
 
         /// <summary>
@@ -637,7 +637,7 @@ public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path
         {
             // setup resources
             System.Resources.ResourceManager resources = new System.Resources.ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", typeof(SecurityUtilities).Module.Assembly);
-            SignFileInternal(cert, timestampUrl, path, true, resources);
+            SignFileInternal(cert, timestampUrl, path, targetFrameworkSupportsSha256: true, resources);
         }
 
         [SupportedOSPlatform("windows")]
@@ -701,6 +701,7 @@ private static void SignFileInternal(X509Certificate2 cert,
                         {
                             doc.Load(xr);
                         }
+
                         var manifest = new SignedCmiManifest2(doc, useSha256);
                         CmiManifestSigner2 signer;
                         if (useSha256 && rsa is RSACryptoServiceProvider rsacsp)
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index d23e63c0870..522a2173045 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -550,126 +550,68 @@ private static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlg
             }
         }
 
+        [SuppressMessage("Security", "CA5350:Do Not Use Weak Cryptographic Algorithms", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
         private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool useSha256)
         {
-#if (true) // BUGBUG: Remove before RTM when old format support is no longer needed.
-            return ComputeHashFromManifest(manifestDom, false, useSha256);
-        }
+            // Since the DOM given to us is not guaranteed to be normalized,
+            // we need to normalize it ourselves. Also, we always preserve
+            // white space as Fusion XML engine always preserve white space.
+            XmlDocument normalizedDom = new XmlDocument();
+            normalizedDom.PreserveWhitespace = true;
+
+            // Normalize the document
+            using (TextReader stringReader = new StringReader(manifestDom.OuterXml))
+            {
+                XmlReaderSettings settings = new XmlReaderSettings();
+                settings.DtdProcessing = DtdProcessing.Parse;
+                using (XmlReader reader = XmlReader.Create(stringReader, settings, manifestDom.BaseURI))
+                {
+                    normalizedDom.Load(reader);
+                }
+            }
 
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Security", "CA5350:Do Not Use Weak Cryptographic Algorithms", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
-        private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldFormat, bool useSha256)
-        {
-            if (oldFormat)
-            {
-                XmlDsigExcC14NTransform exc = new XmlDsigExcC14NTransform();
-                exc.LoadInput(manifestDom);
+            XmlDsigExcC14NTransform exc = new XmlDsigExcC14NTransform();
+            exc.LoadInput(normalizedDom);
 
-                if (useSha256)
-                {
+            if (useSha256)
+            {
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    using (SHA256 sha2 = SHA256.Create(
+                using (SHA256 sha2 = SHA256.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
-                        "System.Security.Cryptography.SHA256CryptoServiceProvider"
+                    "System.Security.Cryptography.SHA256CryptoServiceProvider"
 #endif
-                ))
+                    ))
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    {
-                        byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
-                        if (hash == null)
-                        {
-                            throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
-                        }
-
-                        return hash;
-                    }
-                }
-                else
                 {
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    // codeql[cs/weak-crypto] SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
-                    using (SHA1 sha1 = SHA1.Create(
-#if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
-                        "System.Security.Cryptography.SHA1CryptoServiceProvider"
-#endif
-                        ))
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+                    byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
+                    if (hash == null)
                     {
-                        byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
-                        if (hash == null)
-                        {
-                            throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
-                        }
-
-                        return hash;
+                        throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
                     }
+
+                    return hash;
                 }
             }
             else
             {
-#endif
-                // Since the DOM given to us is not guaranteed to be normalized,
-                // we need to normalize it ourselves. Also, we always preserve
-                // white space as Fusion XML engine always preserve white space.
-                XmlDocument normalizedDom = new XmlDocument();
-                normalizedDom.PreserveWhitespace = true;
-
-                // Normalize the document
-                using (TextReader stringReader = new StringReader(manifestDom.OuterXml))
-                {
-                    XmlReaderSettings settings = new XmlReaderSettings();
-                    settings.DtdProcessing = DtdProcessing.Parse;
-                    using (XmlReader reader = XmlReader.Create(stringReader, settings, manifestDom.BaseURI))
-                    {
-                        normalizedDom.Load(reader);
-                    }
-                }
-
-                XmlDsigExcC14NTransform exc = new XmlDsigExcC14NTransform();
-                exc.LoadInput(normalizedDom);
-
-                if (useSha256)
-                {
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    using (SHA256 sha2 = SHA256.Create(
+                // codeql[cs/weak-crypto] SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
+                using (SHA1 sha1 = SHA1.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
-                        "System.Security.Cryptography.SHA256CryptoServiceProvider"
+                    "System.Security.Cryptography.SHA1CryptoServiceProvider"
 #endif
-                        ))
+                     ))
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    {
-                        byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
-                        if (hash == null)
-                        {
-                            throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
-                        }
-
-                        return hash;
-                    }
-                }
-                else
                 {
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    // codeql[cs/weak-crypto] SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
-                    using (SHA1 sha1 = SHA1.Create(
-#if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
-                        "System.Security.Cryptography.SHA1CryptoServiceProvider"
-#endif
-                         ))
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+                    byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
+                    if (hash == null)
                     {
-                        byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
-                        if (hash == null)
-                        {
-                            throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
-                        }
-
-                        return hash;
+                        throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
                     }
-                }
 
-#if (true) // BUGBUG: Remove before RTM when old format support is no longer needed.
+                    return hash;
+                }
             }
-#endif
         }
 
         private const string AssemblyNamespaceUri = "urn:schemas-microsoft-com:asm.v1";
@@ -739,8 +681,8 @@ private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManife
             signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
             if (signer.UseSha256)
             {
-                signedXml.SignedInfo.SignatureMethod = Sha256SignatureMethodUri;
-            }
+                    signedXml.SignedInfo.SignatureMethod = Sha256SignatureMethodUri;
+                }
             else
             {
                 signedXml.SignedInfo.SignatureMethod = Sha1SignatureMethodUri;
@@ -1108,12 +1050,12 @@ internal class CmiManifestSigner2
         private X509Certificate2Collection _certificates;
         private X509IncludeOption _includeOption;
         private CmiManifestSignerFlag _signerFlag;
-        private bool _useSha256;
+        private readonly bool _useSha256;
 
         private CmiManifestSigner2() { }
 
         internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey) :
-            this(strongNameKey, null, false)
+            this(strongNameKey, certificate: null, useSha256: false)
         { }
 
         internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate, bool useSha256)
@@ -1311,7 +1253,7 @@ internal CmiAuthenticodeSignerInfo(int errorCode)
         }
 
         internal CmiAuthenticodeSignerInfo(Win32.AXL_SIGNER_INFO signerInfo,
-                                            Win32.AXL_TIMESTAMPER_INFO timestamperInfo)
+                                           Win32.AXL_TIMESTAMPER_INFO timestamperInfo)
         {
             _error = (int)signerInfo.dwError;
             if (signerInfo.pChainContext != IntPtr.Zero)
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 37d7cece260..48d3df90c79 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -34,6 +34,20 @@
     <!-- Binary serialization by ITranslatable -->
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
+
+    <!-- Node communication -->
+    <Compile Include="..\Shared\CommunicationsUtilities.cs" />
+    <Compile Include="..\Shared\INodeEndpoint.cs" />
+    <Compile Include="..\Shared\INodePacket.cs" />
+    <Compile Include="..\Shared\INodePacketFactory.cs" />
+    <Compile Include="..\Shared\INodePacketHandler.cs" />
+    <Compile Include="..\Shared\NodeBuildComplete.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
+    <Compile Include="..\Shared\NodePacketFactory.cs" />
+    <Compile Include="..\Shared\NodePipeBase.cs" />
+    <Compile Include="..\Shared\NodePipeClient.cs" />
+    <Compile Include="..\Shared\NodePipeServer.cs" />
+    <Compile Include="..\Shared\NodeShutdown.cs" />
   </ItemGroup>
   <ItemGroup>
     <!-- Source Files -->
@@ -183,6 +197,12 @@
     <Compile Include="AssemblyDependency\UnificationVersion.cs" />
     <Compile Include="AssemblyDependency\UnifiedAssemblyName.cs" />
     <Compile Include="AssemblyDependency\WarnOrErrorOnTargetArchitectureMismatchBehavior.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarClient.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarNode.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarNodeEndpoint.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeExecuteRequest.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeExecuteResponse.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeShutdownReason.cs" />
     <Compile Include="AssemblyFolder.cs" />
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyRemapping.cs" />
@@ -447,24 +467,6 @@
     <Content Include="Microsoft.NETFramework.props">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v11.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v12.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v14.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v15.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v16.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v17.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
     <!-- Resource Files -->
     <EmbeddedResource Include="Resources\Strings.resx">
       <LogicalName>$(AssemblyName).Strings.resources</LogicalName>
@@ -663,7 +665,6 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
-    <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
 
@@ -682,6 +683,7 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'">
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
+    <PackageReference Include="System.Collections.Immutable" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
@@ -694,6 +696,7 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="Microsoft.Win32.Registry" />
     <PackageReference Include="System.Reflection.Metadata" />
+    <PackageReference Include="System.Threading.Channels" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index 60045885791..6e30cf7fba4 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -100,6 +100,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <CreateCSharpManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
               RootNamespace="$(RootNamespace)"
+              EnableCustomCulture="$(EnableCustomCulture)"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
@@ -247,6 +248,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          ChecksumAlgorithm="$(ChecksumAlgorithm)"
          CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)"
          CodePage="$(CodePage)"
+         CompilerType="$(RoslynCompilerType)"
          DebugType="none"
          DefineConstants="$(DefineConstants)"
          DelaySign="$(DelaySign)"
@@ -261,6 +263,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          ErrorLog="$(ErrorLog)"
          ErrorReport="$(ErrorReport)"
          Features="$(Features)"
+         InterceptorsNamespaces="$(InterceptorsNamespaces)"
          InterceptorsPreviewNamespaces="$(InterceptorsPreviewNamespaces)"
          FileAlignment="$(FileAlignment)"
          GeneratedFilesOutputPath="$(CompilerGeneratedFilesOutputPath)"
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 48b9de51827..b0ffa3fa5b6 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2385,6 +2385,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
     </PropertyGroup>
 
+    <PropertyGroup>
+      <AllowResolveAssemblyReferencesOutOfProcNode Condition="'$(AllowResolveAssemblyReferencesOutOfProcNode)' == ''">false</AllowResolveAssemblyReferencesOutOfProcNode>
+    </PropertyGroup>
+
     <!-- Make an App.Config item that exists when AutoUnify is false. -->
     <ItemGroup>
       <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoGenerateBindingRedirects)'=='true' or '$(AutoUnifyAssemblyReferences)'=='false'"/>
@@ -2412,6 +2416,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </Reference>
     </ItemGroup>
 
+    <!--Converts string property NonCultureResourceDirectories to array if present. NonCultureResourceDirectories defines exclusions for the custom cultures.  -->
+    <ItemGroup Condition="'$(NonCultureResourceDirectories)' != ''">
+      <NonCultureResourceDirectory Include="$(NonCultureResourceDirectories)" />
+    </ItemGroup>
+
+    <PropertyGroup Condition="'$(EnableCustomCulture)' == ''">
+      <EnableCustomCulture>false</EnableCustomCulture>
+    </PropertyGroup>
+
     <!--
       Normally, as an optimization, finding dependencies of references marked with ExternallyResolved=true metadata is skipped.
       However, skipping that step breaks binding redirect generation when there are conflicting versions within the externally
@@ -2465,6 +2478,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         FindDependenciesOfExternallyResolvedReferences="$(FindDependenciesOfExternallyResolvedReferences)"
         ContinueOnError="$(ContinueOnError)"
         OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)"
+        NonCultureResourceDirectories="@(NonCultureResourceDirectory)"
+        EnableCustomCulture="$(EnableCustomCulture)"
+        AllowOutOfProcNode="$(AllowResolveAssemblyReferencesOutOfProcNode)"
         Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''"
         >
 
@@ -2569,24 +2585,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
 
-    <PropertyGroup>
-      <ConfigFileExists Condition="Exists('@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')')">true</ConfigFileExists>
-      <HasNoBindingRedirects Condition="'@(SuggestedBindingRedirects)' == ''">true</HasNoBindingRedirects>
-    </PropertyGroup>
-
-    <!-- Overwrites .config file with a App.config content if RAR returned empty @(SuggestedBindingRedirects). -->
-    <Copy
-      SourceFiles="@(AppConfigWithTargetPath->'%(FullPath)')"
-      DestinationFiles="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      SkipUnchangedFiles="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'">
-      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
-    </Copy>
-    <Touch
-      Files="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      AlwaysCreate="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'"/>
-
     <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
@@ -5411,11 +5409,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!--
         Not using SkipUnchangedFiles="true" by default for backwards compatibility.
         -->
-        
+
     <PropertyGroup>
       <SkipUnchangedFilesOnCopyAlways Condition="'$(SkipUnchangedFilesOnCopyAlways)' == ''">false</SkipUnchangedFilesOnCopyAlways>
     </PropertyGroup>
-        
+
     <Copy
         SourceFiles = "@(_SourceItemsToCopyToOutputDirectoryAlways)"
         DestinationFiles = "@(_SourceItemsToCopyToOutputDirectoryAlways->'$(OutDir)%(TargetPath)')"
@@ -5463,7 +5461,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </Copy>
 
   </Target>
-  
+
   <!--
     ============================================================
                                         _CopyAppConfigFile
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index e322c4a2f1e..be186f628bd 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -108,7 +108,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <WMSJSProjectDirectory Condition="'$(WMSJSProjectDirectory)' == ''">JavaScript</WMSJSProjectDirectory>
   </PropertyGroup>
 
-  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" Condition="'$(VisualStudioVersion)' == ''" />
+  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" />
 
   <Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)')" />
 
diff --git a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
index 1e64f51125c..fe304b229f5 100644
--- a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
@@ -110,6 +110,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               ResourceFiles="@(EmbeddedResource)"
               RootNamespace="$(RootNamespace)"
               PrependCultureAsDirectory="false"
+              EnableCustomCulture="$(EnableCustomCulture)"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
@@ -237,6 +238,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          ChecksumAlgorithm="$(ChecksumAlgorithm)"
          CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)"
          CodePage="$(CodePage)"
+         CompilerType="$(RoslynCompilerType)"
          DebugType="none"
          DefineConstants="$(FinalDefineConstants)"
          DelaySign="$(DelaySign)"
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props
deleted file mode 100644
index 9ef50e92c14..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v11.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project ToolsVersion="4.0">
-
-  <PropertyGroup>
-    <VisualStudioVersion>11.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props
deleted file mode 100644
index 428a5c1d571..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v11.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project ToolsVersion="4.0">
-
-  <PropertyGroup>
-    <VisualStudioVersion>12.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props
deleted file mode 100644
index c2e2af3ad8e..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v14.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project ToolsVersion="4.0">
-
-  <PropertyGroup>
-    <VisualStudioVersion>14.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props
deleted file mode 100644
index 9d9e0f62d71..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v15.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project>
-
-  <PropertyGroup>
-    <VisualStudioVersion>15.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props
deleted file mode 100644
index 1843227e760..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v16.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project>
-
-  <PropertyGroup>
-    <VisualStudioVersion>16.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props
deleted file mode 100644
index 94031c33888..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v17.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project>
-
-  <PropertyGroup>
-    <VisualStudioVersion>17.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index 6a7ae609617..366f0badba0 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -62,6 +62,7 @@ public override bool Execute()
             return ResolveAssemblyKey() && ResolveManifestKey();
         }
 
+#if FEATURE_PFX_SIGNING
         // We we use hash the contens of .pfx file so we can establish relationship file <-> container name, whithout
         // need to prompt for password. Note this is not used for any security reasons. With the departure from standard MD5 algoritm
         // we need as simple hash function for replacement. The data blobs we use (.pfx files)  are
@@ -87,6 +88,7 @@ private static UInt64 HashFromBlob(byte[] data)
             result |= dw2;
             return result;
         }
+#endif
 
         private bool ResolveAssemblyKey()
         {
diff --git a/src/Tasks/StrongNameUtils.cs b/src/Tasks/StrongNameUtils.cs
index 26fce852479..f1aef67e8c0 100644
--- a/src/Tasks/StrongNameUtils.cs
+++ b/src/Tasks/StrongNameUtils.cs
@@ -49,10 +49,8 @@ internal static void ReadKeyFile(TaskLoggingHelper log, string keyFile, out Stro
                     int fileLength = (int)fs.Length;
                     keyFileContents = new byte[fileLength];
 
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read'
                     // TODO: Read the count of read bytes and check if it matches the expected length, if not raise an exception
-                    fs.Read(keyFileContents, 0, fileLength);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+                    fs.ReadExactly(keyFileContents, 0, fileLength);
                 }
             }
             catch (ArgumentException e)
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index cbb66f13907..0d1dac8f86c 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -171,10 +171,8 @@ public void Translate(ITranslator translator)
                 ErrorUtilities.VerifyThrowArgumentNull(translator);
 
                 translator.Translate(ref lastModified);
-                translator.Translate(ref assemblyName,
-                    (ITranslator t) => new AssemblyNameExtension(t));
-                translator.TranslateArray(ref dependencies,
-                    (ITranslator t) => new AssemblyNameExtension(t));
+                translator.Translate(ref assemblyName, (t) => new AssemblyNameExtension(t));
+                translator.TranslateArray(ref dependencies, (t) => new AssemblyNameExtension(t));
                 translator.Translate(ref scatterFiles);
                 translator.Translate(ref runtimeVersion);
                 translator.Translate(ref frameworkName);
@@ -268,7 +266,7 @@ public override void Translate(ITranslator translator)
             translator.TranslateDictionary(
                 ref (translator.Mode == TranslationDirection.WriteToStream) ? ref instanceLocalOutgoingFileStateCache : ref instanceLocalFileStateCache,
                 StringComparer.OrdinalIgnoreCase,
-                (ITranslator t) => new FileState(t));
+                (t) => new FileState(t));
 
             // IsDirty should be false for either direction. Either this cache was brought
             // up-to-date with the on-disk cache or vice versa. Either way, they agree.
diff --git a/src/Tasks/TaskRequiresFramework.cs b/src/Tasks/TaskRequiresFramework.cs
index cbc3caf0b2f..f29331729e6 100644
--- a/src/Tasks/TaskRequiresFramework.cs
+++ b/src/Tasks/TaskRequiresFramework.cs
@@ -1,6 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#pragma warning disable IDE0052
+
 #if NETFRAMEWORK
 using System;
 #endif
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index f2fbe04a6b2..f9eb9441801 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -6,6 +6,11 @@
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
+
+#if NETFRAMEWORK
+using Microsoft.IO;
+#endif
+
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.XamlTypes;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 90b49a9780b..6130771ccd4 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -2,9 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
 using System.Xml;
 using System.Xml.XPath;
 using System.Xml.Xsl;
@@ -12,6 +10,11 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
+#if FEATURE_COMPILED_XSL
+using System.Collections.Generic;
+using System.Reflection;
+#endif
+
 #nullable disable
 
 namespace Microsoft.Build.Tasks
@@ -495,6 +498,7 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
                 return xslct;
             }
 
+#if FEATURE_COMPILED_XSL
             /// <summary>
             /// Find the type from an assembly and loads it.
             /// </summary>
@@ -528,6 +532,7 @@ private static Type FindType(string assemblyPath, string typeName)
                     throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("XslTransform.MustSpecifyType", assemblyPath));
                 }
             }
+#endif
         }
         #endregion
     }
diff --git a/src/UnitTests.Shared/EngineTestEnvironment.cs b/src/UnitTests.Shared/EngineTestEnvironment.cs
index 9f543926223..6464653bcf9 100644
--- a/src/UnitTests.Shared/EngineTestEnvironment.cs
+++ b/src/UnitTests.Shared/EngineTestEnvironment.cs
@@ -25,9 +25,9 @@ namespace Microsoft.Build.UnitTests
     public partial class TestEnvironment
     {
         // reset the default build manager and the state it might have accumulated from other tests
-#pragma warning disable CA1823 // Avoid unused private fields
+#pragma warning disable CA1823, IDE0052 // Avoid unused private fields
         private object _resetBuildManager = new ResetDefaultBuildManager();
-#pragma warning restore CA1823 // Avoid unused private fields
+#pragma warning restore CA1823, IDE0052 // Avoid unused private fields
 
         private sealed class ResetDefaultBuildManager
         {
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 035cfbf57d2..ed84445bbfd 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -21,6 +21,9 @@ public static class RunnerUtilities
         public static ArtifactsLocationAttribute ArtifactsLocationAttribute = Assembly.GetExecutingAssembly().GetCustomAttribute<ArtifactsLocationAttribute>()
                                                    ?? throw new InvalidOperationException("This test assembly does not have the ArtifactsLocationAttribute");
 
+        internal static BootstrapLocationAttribute BootstrapLocationAttribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
+                                                   ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
+        public static string BootstrapMsBuildBinaryLocation => BootstrapLocationAttribute.BootstrapMsBuildBinaryLocation;
 #if !FEATURE_RUN_EXE_IN_TESTS
         private static readonly string s_dotnetExePath = EnvironmentProvider.GetDotnetExePath();
 
@@ -64,15 +67,11 @@ public static string ExecBootstrapedMSBuild(
             bool attachProcessId = true,
             int timeoutMilliseconds = 30_000)
         {
-            BootstrapLocationAttribute attribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
-                                                   ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
-
-            string binaryFolder = attribute.BootstrapMsBuildBinaryLocation;
 #if NET
-            string pathToExecutable = EnvironmentProvider.GetDotnetExePathFromFolder(binaryFolder);
-            msbuildParameters = Path.Combine(binaryFolder, "sdk", attribute.BootstrapSdkVersion, Constants.MSBuildAssemblyName) + " " + msbuildParameters;
+            string pathToExecutable = EnvironmentProvider.GetDotnetExePathFromFolder(BootstrapMsBuildBinaryLocation);
+            msbuildParameters = Path.Combine(BootstrapMsBuildBinaryLocation, "sdk", BootstrapLocationAttribute.BootstrapSdkVersion, "MSBuild.dll") + " " + msbuildParameters;
 #else
-            string pathToExecutable = Path.Combine(binaryFolder, Constants.MSBuildExecutableName);
+            string pathToExecutable = Path.Combine(BootstrapMsBuildBinaryLocation, "MSBuild.exe");
 #endif
             return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper, attachProcessId, timeoutMilliseconds);
         }
diff --git a/src/UnitTests.Shared/TestEnvironment.cs b/src/UnitTests.Shared/TestEnvironment.cs
index 1df70aad6af..39374abd308 100644
--- a/src/UnitTests.Shared/TestEnvironment.cs
+++ b/src/UnitTests.Shared/TestEnvironment.cs
@@ -677,19 +677,16 @@ public override void Revert()
 
     public class TransientTestFile : TransientTestState
     {
-        private readonly bool _createFile;
         private readonly bool _expectedAsOutput;
 
         public TransientTestFile(string extension, bool createFile, bool expectedAsOutput)
         {
-            _createFile = createFile;
             _expectedAsOutput = expectedAsOutput;
             Path = FileUtilities.GetTemporaryFile(null, null, extension, createFile);
         }
 
         public TransientTestFile(string rootPath, string extension, bool createFile, bool expectedAsOutput)
         {
-            _createFile = createFile;
             _expectedAsOutput = expectedAsOutput;
             Path = FileUtilities.GetTemporaryFile(rootPath, null, extension, createFile);
         }
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index a06401e8191..a14605728ea 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -30,7 +30,9 @@ namespace Microsoft.Build.UnitTests
 {
     public sealed class ToolLocationHelper_Tests
     {
+#if FEATURE_CODETASKFACTORY
         private readonly ITestOutputHelper _output;
+#endif
 
 #if USE_MSBUILD_DLL_EXTN
         private const string MSBuildExeName = "MSBuild.dll";
@@ -40,7 +42,9 @@ public sealed class ToolLocationHelper_Tests
 
         public ToolLocationHelper_Tests(ITestOutputHelper output)
         {
+#if FEATURE_CODETASKFACTORY
             _output = output;
+#endif
             ToolLocationHelper.ClearStaticCaches();
         }
 
@@ -2922,7 +2926,6 @@ public class GetPlatformExtensionSDKLocationsTestFixture : IDisposable
         // Path to the fake SDk directory structure created under the temp directory.
         private readonly string _fakeStructureRoot;
         private readonly string _fakeStructureRoot2;
-        private readonly ITestOutputHelper _output;
 
         public GetPlatformExtensionSDKLocationsTestFixture(ITestOutputHelper output)
         {
@@ -2930,8 +2933,6 @@ public GetPlatformExtensionSDKLocationsTestFixture(ITestOutputHelper output)
             getRegistrySubKeyDefaultValue = GetRegistrySubKeyDefaultValue;
 #endif
 
-            _output = output;
-
             _fakeStructureRoot = MakeFakeSDKStructure();
             _fakeStructureRoot2 = MakeFakeSDKStructure2();
         }
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index 1bcad909332..f99b7af9a60 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -1735,9 +1735,7 @@ public void CreateFileDoesntRecordWriteIfNotWrittenTo()
                 var buffer = new byte[10];
                 using (FileStream fs = File.Open(readFile, FileMode.Open, FileAccess.ReadWrite, FileShare.None))
                 {
-#pragma warning disable CA2022
-                    fs.Read(buffer, 0, 10);
-#pragma warning restore CA2022
+                    fs.ReadExactly(buffer, 0, 10);
                 }
 
                 FileTracker.WriteContextTLogs(testDir, tlogRootName);
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index e5a0a89b595..86e032a484b 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -23,7 +23,7 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
-    <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Collections.Immutable" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
 
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index d43175b77aa..c1820c060aa 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -508,6 +508,7 @@ void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>>
             _metadata.SetItems(metadata.Select(kvp => new KeyValuePair<string, string>(kvp.Key, kvp.Value ?? string.Empty)));
         }
 
+#if FEATURE_APPDOMAIN
         private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
@@ -526,6 +527,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
 
             return result;
         }
+#endif
 
         private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataLazy()
         {
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index ef175ad916b..c3ac96f1f15 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -9,7 +9,6 @@
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
-using System.Linq;
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -80,7 +79,7 @@ public static class FileTracker
         /// This must be the base system-wide temp path because we use it to filter out I/O of tools outside of our control.
         /// Tools running under the tracker may put temp files in the temp base or in a sub-directory of their choosing.
         /// </remarks>
-        private static readonly string s_tempPath = Path.GetTempPath();
+        private static readonly string s_tempPath = FileUtilities.EnsureTrailingSlash(Path.GetTempPath());
 
         // The short path to temp
         private static readonly string s_tempShortPath = FileUtilities.EnsureTrailingSlash(NativeMethodsShared.GetShortFilePath(s_tempPath).ToUpperInvariant());
@@ -247,12 +246,25 @@ public static bool FileIsExcludedFromDependencies(string fileName)
             // 5. Files under the common ("All Users") Application Data location -- C:\Documents and Settings\All Users\Application Data
             //    on XP and either C:\Users\All Users\Application Data or C:\ProgramData on Vista+
 
-            return FileIsUnderPath(fileName, s_applicationDataPath) ||
-                   FileIsUnderPath(fileName, s_localApplicationDataPath) ||
-                   FileIsUnderPath(fileName, s_localLowApplicationDataPath) ||
-                   FileIsUnderPath(fileName, s_tempShortPath) ||
-                   FileIsUnderPath(fileName, s_tempLongPath) ||
-                   s_commonApplicationDataPaths.Any(p => FileIsUnderPath(fileName, p));
+            if (FileIsUnderNormalizedPath(fileName, s_applicationDataPath) ||
+                FileIsUnderNormalizedPath(fileName, s_localApplicationDataPath) ||
+                FileIsUnderNormalizedPath(fileName, s_localLowApplicationDataPath) ||
+                FileIsUnderNormalizedPath(fileName, s_tempShortPath) ||
+                FileIsUnderNormalizedPath(fileName, s_tempLongPath))
+            {
+                return true;
+            }
+
+            // PERF: Avoid LINQ in this path.
+            foreach (string p in s_commonApplicationDataPaths)
+            {
+                if (FileIsUnderNormalizedPath(fileName, p))
+                {
+                    return true;
+                }
+            }
+
+            return false;
         }
 
         /// <summary>
@@ -266,15 +278,31 @@ public static bool FileIsExcludedFromDependencies(string fileName)
         /// </param>
         public static bool FileIsUnderPath(string fileName, string path)
         {
+            // Ensure that the path has a trailing slash that we are checking under
+            // By default the paths that we check for most often will have, so this will
+            // return fast and not allocate memory in the process
+            return FileIsUnderNormalizedPath(fileName, FileUtilities.EnsureTrailingSlash(path));
+        }
+
+        internal static bool FileIsUnderNormalizedPath(string fileName, string path)
+        {
+            int pathLength = path.Length;
+
+            Debug.Assert(path[pathLength - 1] == Path.DirectorySeparatorChar);
+
             // UNDONE: Get the long file path for the entry
             // This is an incredibly expensive operation. The tracking log
             // as written by CL etc. does not contain short paths
             // fileDirectory = NativeMethods.GetFullLongFilePath(fileDirectory);
 
-            // Ensure that the path has a trailing slash that we are checking under
-            // By default the paths that we check for most often will have, so this will
-            // return fast and not allocate memory in the process
-            path = FileUtilities.EnsureTrailingSlash(path);
+            // quick checks to return early. If our given filename is less than the length of the path, it can't be under it.
+            // Similarly, if the file name doesn't have a path separator
+            // at the index of the last separator in the path, it doesn't match.
+            // Because we have a normalized path below we can check against normal-slash directly.
+            if (fileName.Length < pathLength || fileName[pathLength - 1] != Path.DirectorySeparatorChar)
+            {
+                return false;
+            }
 
             // Is the fileName under the filePath?
             return string.Compare(fileName, 0, path, 0, path.Length, StringComparison.OrdinalIgnoreCase) == 0;
